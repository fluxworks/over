//! Implementation of Unicode Standard Annex #31 for 
//! determining which `char` values are valid in programming language identifiers.
#![feature
(
    
)]

#![allow
(
    bare_trait_objects,
    mismatched_lifetime_syntaxes,
    non_camel_case_types,
    non_fmt_panics,
    non_snake_case,
    non_upper_case_globals,
    unused_attributes,
    unused_imports,
    unused_variables,
)]
/*
pub mod _
{
    pub use std::_::{ * };
}

pub mod __
{
    use ::
    {
        *,
    };
    /*
    */
}
*/
extern crate proc_macro;

#[macro_use] pub mod macros
{
    /// Performs variable interpolation against the input and produces it as [`process::macros::TokenStream`].
    #[macro_export] macro_rules! quote
    {
        () =>
        {
            ::__private::TokenStream::new()
        };
       
        ($tt:tt) => 
        {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt _s}
            _s
        }};
       
        (# $var:ident) => {{
            let mut _s = ::__private::TokenStream::new();
            ::ToTokens::to_tokens(&$var, &mut _s);
            _s
        }};
        ($tt1:tt $tt2:tt) => {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt1 _s}
            ::quote_token!{$tt2 _s}
            _s
        }};
       
        ($($tt:tt)*) => {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_each_token!{_s $($tt)*}
            _s
        }};
    }
    /// Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.
    #[macro_export] macro_rules! quote_spanned
    {
        ($span:expr=>) => {{
            let _: ::__private::Span = ::__private::get_span($span).__into_span();
            ::__private::TokenStream::new()
        }};
       
        ($span:expr=> $tt:tt) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span($span).__into_span();
            ::quote_token_spanned!{$tt _s _span}
            _s
        }};
       
        ($span:expr=> # $var:ident) => {{
            let mut _s = ::__private::TokenStream::new();
            let _: ::__private::Span = ::__private::get_span($span).__into_span();
            ::ToTokens::to_tokens(&$var, &mut _s);
            _s
        }};
        ($span:expr=> $tt1:tt $tt2:tt) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span($span).__into_span();
            ::quote_token_spanned!{$tt1 _s _span}
            ::quote_token_spanned!{$tt2 _s _span}
            _s
        }};
       
        ($span:expr=> $($tt:tt)*) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span($span).__into_span();
            ::quote_each_token_spanned!{_s _span $($tt)*}
            _s
        }};
    }
   
    #[macro_export] macro_rules! pounded_var_names
    {
        ($call:ident! $extra:tt $($tts:tt)*) => {
            ::pounded_var_names_with_context!{$call! $extra
                (@ $($tts)*)
                ($($tts)* @)
            }
        };
    }

    #[macro_export] macro_rules! pounded_var_names_with_context
    {
        ($call:ident! $extra:tt ($($b1:tt)*) ($($curr:tt)*)) => {
            $(
                ::pounded_var_with_context!{$call! $extra $b1 $curr}
            )*
        };
    }

    #[macro_export] macro_rules! pounded_var_with_context
    {
        ($call:ident! $extra:tt $b1:tt ( $($inner:tt)* )) => {
            ::pounded_var_names!{$call! $extra $($inner)*}
        };

        ($call:ident! $extra:tt $b1:tt [ $($inner:tt)* ]) => {
            ::pounded_var_names!{$call! $extra $($inner)*}
        };

        ($call:ident! $extra:tt $b1:tt { $($inner:tt)* }) => {
            ::pounded_var_names!{$call! $extra $($inner)*}
        };

        ($call:ident!($($extra:tt)*) # $var:ident) => {
            ::$call!($($extra)* $var);
        };

        ($call:ident! $extra:tt $b1:tt $curr:tt) => {};
    }

    #[macro_export] macro_rules! quote_bind_into_iter 
    {
        ($has_iter:ident $var:ident) => {
           
            #[allow(unused_mut)]
            let (mut $var, i) = $var.quote_into_iter();
            let $has_iter = $has_iter | i;
        };
    }

    #[macro_export] macro_rules! quote_bind_next_or_break 
    {
        ($var:ident) => {
            let $var = match $var.next() {
                Some(_x) => ::__private::RepInterp(_x),
                None => break,
            };
        };
    }
    
    #[macro_export] macro_rules! quote_each_token 
    {
        ($tokens:ident $($tts:tt)*) => {
            ::quote_tokens_with_context!{$tokens
                (@ @ @ @ @ @ $($tts)*)
                (@ @ @ @ @ $($tts)* @)
                (@ @ @ @ $($tts)* @ @)
                (@ @ @ $(($tts))* @ @ @)
                (@ @ $($tts)* @ @ @ @)
                (@ $($tts)* @ @ @ @ @)
                ($($tts)* @ @ @ @ @ @)
            }
        };
    }

    #[macro_export] macro_rules! quote_each_token_spanned 
    {
        ($tokens:ident $span:ident $($tts:tt)*) => {
            ::quote_tokens_with_context_spanned!{$tokens $span
                (@ @ @ @ @ @ $($tts)*)
                (@ @ @ @ @ $($tts)* @)
                (@ @ @ @ $($tts)* @ @)
                (@ @ @ $(($tts))* @ @ @)
                (@ @ $($tts)* @ @ @ @)
                (@ $($tts)* @ @ @ @ @)
                ($($tts)* @ @ @ @ @ @)
            }
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context
    {
        ($tokens:ident
            ($($b3:tt)*) ($($b2:tt)*) ($($b1:tt)*)
            ($($curr:tt)*)
            ($($a1:tt)*) ($($a2:tt)*) ($($a3:tt)*)
        ) => {
            $(
                ::quote_token_with_context!{$tokens $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context_spanned
    {
        ($tokens:ident $span:ident
            ($($b3:tt)*) ($($b2:tt)*) ($($b1:tt)*)
            ($($curr:tt)*)
            ($($a1:tt)*) ($($a2:tt)*) ($($a3:tt)*)
        ) => {
            $(
                ::quote_token_with_context_spanned!{$tokens $span $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_token_with_context
    {  
        ($tokens:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) * $a3:tt) => 
        {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            
            while true 
            {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                ::quote_each_token!{$tokens $($inner)*}
            }
        }};
       
        ($tokens:ident $b3:tt $b2:tt # (( $($inner:tt)* )) * $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt # ( $($inner:tt)* ) (*) $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) $sep:tt *) => 
        {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                if _i > 0 {
                    ::quote_token!{$sep $tokens}
                }
                _i += 1;
                ::quote_each_token!{$tokens $($inner)*}
            }
        }};
       
        ($tokens:ident $b3:tt $b2:tt # (( $($inner:tt)* )) $sep:tt * $a3:tt) => {};
       
        ($tokens:ident $b3:tt # ( $($inner:tt)* ) ($sep:tt) * $a2:tt $a3:tt) => {};
       
       
        ($tokens:ident # ( $($inner:tt)* ) * (*) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token!{* $tokens}
        };
       
        ($tokens:ident # ( $($inner:tt)* ) $sep:tt (*) $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt (#) $var:ident $a2:tt $a3:tt) => {
            ::ToTokens::to_tokens(&$var, &mut $tokens);
        };
       
        ($tokens:ident $b3:tt $b2:tt # ($var:ident) $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt ($curr:tt) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token!{$curr $tokens}
        };
    }
    
    #[macro_export] macro_rules! quote_token_with_context_spanned 
    {
        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) * $a3:tt) => {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                ::quote_each_token_spanned!{$tokens $span $($inner)*}
            }
        }};
        ($tokens:ident $span:ident $b3:tt $b2:tt # (( $($inner:tt)* )) * $a2:tt $a3:tt) => {};
        ($tokens:ident $span:ident $b3:tt # ( $($inner:tt)* ) (*) $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) $sep:tt *) => {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                if _i > 0 {
                    ::quote_token_spanned!{$sep $tokens $span}
                }
                _i += 1;
                ::quote_each_token_spanned!{$tokens $span $($inner)*}
            }
        }};
        ($tokens:ident $span:ident $b3:tt $b2:tt # (( $($inner:tt)* )) $sep:tt * $a3:tt) => {};
        ($tokens:ident $span:ident $b3:tt # ( $($inner:tt)* ) ($sep:tt) * $a2:tt $a3:tt) => {};
        ($tokens:ident $span:ident # ( $($inner:tt)* ) * (*) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token_spanned!{* $tokens $span}
        };
        ($tokens:ident $span:ident # ( $($inner:tt)* ) $sep:tt (*) $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt (#) $var:ident $a2:tt $a3:tt) => {
            ::ToTokens::to_tokens(&$var, &mut $tokens);
        };
        ($tokens:ident $span:ident $b3:tt $b2:tt # ($var:ident) $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ($curr:tt) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token_spanned!{$curr $tokens $span}
        };
    }
    
    #[macro_export] macro_rules! quote_token
    {
        ($ident:ident $tokens:ident) =>
        {
            ::__private::push_ident(&mut $tokens, stringify!($ident));
        };

        (:: $tokens:ident) =>
        {
            ::__private::push_colon2(&mut $tokens);
        };

        (( $($inner:tt)* ) $tokens:ident) =>
        {
            ::__private::push_group
            (
                &mut $tokens,
                ::__private::Delimiter::Parenthesis,
                ::quote!($($inner)*),
            );
        };

        ([ $($inner:tt)* ] $tokens:ident) =>
        {
            ::__private::push_group
            (
                &mut $tokens,
                ::__private::Delimiter::Bracket,
                ::quote!($($inner)*),
            );
        };

        ({ $($inner:tt)* } $tokens:ident) =>
        {
            ::__private::push_group
            (
                &mut $tokens,
                ::__private::Delimiter::Brace,
                ::quote!($($inner)*),
            );
        };

        (# $tokens:ident) =>
        {
            ::__private::push_pound(&mut $tokens);
        };

        (, $tokens:ident) =>
        {
            ::__private::push_comma(&mut $tokens);
        };

        (. $tokens:ident) =>
        {
            ::__private::push_dot(&mut $tokens);
        };

        (; $tokens:ident) =>
        {
            ::__private::push_semi(&mut $tokens);
        };

        (: $tokens:ident) =>
        {
            ::__private::push_colon(&mut $tokens);
        };

        (+ $tokens:ident) =>
        {
            ::__private::push_add(&mut $tokens);
        };

        (+= $tokens:ident) =>
        {
            ::__private::push_add_eq(&mut $tokens);
        };

        (& $tokens:ident) =>
        {
            ::__private::push_and(&mut $tokens);
        };

        (&& $tokens:ident) =>
        {
            ::__private::push_and_and(&mut $tokens);
        };

        (&= $tokens:ident) =>
        {
            ::__private::push_and_eq(&mut $tokens);
        };

        (@ $tokens:ident) =>
        {
            ::__private::push_at(&mut $tokens);
        };

        (! $tokens:ident) =>
        {
            ::__private::push_bang(&mut $tokens);
        };

        (^ $tokens:ident) =>
        {
            ::__private::push_caret(&mut $tokens);
        };

        (^= $tokens:ident) =>
        {
            ::__private::push_caret_eq(&mut $tokens);
        };

        (/ $tokens:ident) =>
        {
            ::__private::push_div(&mut $tokens);
        };

        (/= $tokens:ident) =>
        {
            ::__private::push_div_eq(&mut $tokens);
        };

        (.. $tokens:ident) =>
        {
            ::__private::push_dot2(&mut $tokens);
        };

        (... $tokens:ident) =>
        {
            ::__private::push_dot3(&mut $tokens);
        };

        (..= $tokens:ident) =>
        {
            ::__private::push_dot_dot_eq(&mut $tokens);
        };

        (= $tokens:ident) =>
        {
            ::__private::push_eq(&mut $tokens);
        };

        (== $tokens:ident) =>
        {
            ::__private::push_eq_eq(&mut $tokens);
        };

        (>= $tokens:ident) =>
        {
            ::__private::push_ge(&mut $tokens);
        };

        (> $tokens:ident) =>
        {
            ::__private::push_gt(&mut $tokens);
        };

        (<= $tokens:ident) =>
        {
            ::__private::push_le(&mut $tokens);
        };

        (< $tokens:ident) =>
        {
            ::__private::push_lt(&mut $tokens);
        };

        (*= $tokens:ident) =>
        {
            ::__private::push_mul_eq(&mut $tokens);
        };

        (!= $tokens:ident) =>
        {
            ::__private::push_ne(&mut $tokens);
        };

        (| $tokens:ident) =>
        {
            ::__private::push_or(&mut $tokens);
        };

        (|= $tokens:ident) =>
        {
            ::__private::push_or_eq(&mut $tokens);
        };

        (|| $tokens:ident) =>
        {
            ::__private::push_or_or(&mut $tokens);
        };

        (? $tokens:ident) =>
        {
            ::__private::push_question(&mut $tokens);
        };

        (-> $tokens:ident) =>
        {
            ::__private::push_rarrow(&mut $tokens);
        };

        (<- $tokens:ident) =>
        {
            ::__private::push_larrow(&mut $tokens);
        };

        (% $tokens:ident) =>
        {
            ::__private::push_rem(&mut $tokens);
        };

        (%= $tokens:ident) =>
        {
            ::__private::push_rem_eq(&mut $tokens);
        };

        (=> $tokens:ident) =>
        {
            ::__private::push_fat_arrow(&mut $tokens);
        };

        (<< $tokens:ident) =>
        {
            ::__private::push_shl(&mut $tokens);
        };

        (<<= $tokens:ident) =>
        {
            ::__private::push_shl_eq(&mut $tokens);
        };

        (>> $tokens:ident) =>
        {
            ::__private::push_shr(&mut $tokens);
        };

        (>>= $tokens:ident) =>
        {
            ::__private::push_shr_eq(&mut $tokens);
        };

        (* $tokens:ident) =>
        {
            ::__private::push_star(&mut $tokens);
        };

        (- $tokens:ident) =>
        {
            ::__private::push_sub(&mut $tokens);
        };

        (-= $tokens:ident) =>
        {
            ::__private::push_sub_eq(&mut $tokens);
        };

        ($lifetime:lifetime $tokens:ident) =>
        {
            ::__private::push_lifetime(&mut $tokens, stringify!($lifetime));
        };

        (_ $tokens:ident) =>
        {
            ::__private::push_underscore(&mut $tokens);
        };

        ($other:tt $tokens:ident) =>
        {
            ::__private::parse(&mut $tokens, stringify!($other));
        };
    }

    #[macro_export] macro_rules! quote_token_spanned
    {
        ($ident:ident $tokens:ident $span:ident) =>
        {
            ::__private::push_ident_spanned(&mut $tokens, $span, stringify!($ident));
        };

        (:: $tokens:ident $span:ident) =>
        {
            ::__private::push_colon2_spanned(&mut $tokens, $span);
        };

        (( $($inner:tt)* ) $tokens:ident $span:ident) =>
        {
            ::__private::push_group_spanned            
            (
                &mut $tokens,
                $span,
                ::__private::Delimiter::Parenthesis,
                ::quote_spanned!($span=> $($inner)*),
            );
        };

        ([ $($inner:tt)* ] $tokens:ident $span:ident) =>
        {
            ::__private::push_group_spanned
            (
                &mut $tokens,
                $span,
                ::__private::Delimiter::Bracket,
                ::quote_spanned!($span=> $($inner)*),
            );
        };

        ({ $($inner:tt)* } $tokens:ident $span:ident) =>
        {
            ::__private::push_group_spanned
            
            (
                &mut $tokens,
                $span,
                ::__private::Delimiter::Brace,
                ::quote_spanned!($span=> $($inner)*),
            );
        };

        (# $tokens:ident $span:ident) =>
        {
            ::__private::push_pound_spanned(&mut $tokens, $span);
        };

        (, $tokens:ident $span:ident) =>
        {
            ::__private::push_comma_spanned(&mut $tokens, $span);
        };

        (. $tokens:ident $span:ident) =>
        {
            ::__private::push_dot_spanned(&mut $tokens, $span);
        };

        (; $tokens:ident $span:ident) =>
        {
            ::__private::push_semi_spanned(&mut $tokens, $span);
        };

        (: $tokens:ident $span:ident) =>
        {
            ::__private::push_colon_spanned(&mut $tokens, $span);
        };

        (+ $tokens:ident $span:ident) =>
        {
            ::__private::push_add_spanned(&mut $tokens, $span);
        };

        (+= $tokens:ident $span:ident) =>
        {
            ::__private::push_add_eq_spanned(&mut $tokens, $span);
        };

        (& $tokens:ident $span:ident) =>
        {
            ::__private::push_and_spanned(&mut $tokens, $span);
        };

        (&& $tokens:ident $span:ident) =>
        {
            ::__private::push_and_and_spanned(&mut $tokens, $span);
        };

        (&= $tokens:ident $span:ident) =>
        {
            ::__private::push_and_eq_spanned(&mut $tokens, $span);
        };

        (@ $tokens:ident $span:ident) =>
        {
            ::__private::push_at_spanned(&mut $tokens, $span);
        };

        (! $tokens:ident $span:ident) =>
        {
            ::__private::push_bang_spanned(&mut $tokens, $span);
        };

        (^ $tokens:ident $span:ident) =>
        {
            ::__private::push_caret_spanned(&mut $tokens, $span);
        };

        (^= $tokens:ident $span:ident) =>
        {
            ::__private::push_caret_eq_spanned(&mut $tokens, $span);
        };

        (/ $tokens:ident $span:ident) =>
        {
            ::__private::push_div_spanned(&mut $tokens, $span);
        };

        (/= $tokens:ident $span:ident) =>
        {
            ::__private::push_div_eq_spanned(&mut $tokens, $span);
        };

        (.. $tokens:ident $span:ident) =>
        {
            ::__private::push_dot2_spanned(&mut $tokens, $span);
        };

        (... $tokens:ident $span:ident) =>
        {
            ::__private::push_dot3_spanned(&mut $tokens, $span);
        };

        (..= $tokens:ident $span:ident) =>
        {
            ::__private::push_dot_dot_eq_spanned(&mut $tokens, $span);
        };

        (= $tokens:ident $span:ident) =>
        {
            ::__private::push_eq_spanned(&mut $tokens, $span);
        };

        (== $tokens:ident $span:ident) =>
        {
            ::__private::push_eq_eq_spanned(&mut $tokens, $span);
        };

        (>= $tokens:ident $span:ident) =>
        {
            ::__private::push_ge_spanned(&mut $tokens, $span);
        };

        (> $tokens:ident $span:ident) =>
        {
            ::__private::push_gt_spanned(&mut $tokens, $span);
        };

        (<= $tokens:ident $span:ident) =>
        {
            ::__private::push_le_spanned(&mut $tokens, $span);
        };

        (< $tokens:ident $span:ident) =>
        {
            ::__private::push_lt_spanned(&mut $tokens, $span);
        };

        (*= $tokens:ident $span:ident) =>
        {
            ::__private::push_mul_eq_spanned(&mut $tokens, $span);
        };

        (!= $tokens:ident $span:ident) =>
        {
            ::__private::push_ne_spanned(&mut $tokens, $span);
        };

        (| $tokens:ident $span:ident) =>
        {
            ::__private::push_or_spanned(&mut $tokens, $span);
        };

        (|= $tokens:ident $span:ident) =>
        {
            ::__private::push_or_eq_spanned(&mut $tokens, $span);
        };

        (|| $tokens:ident $span:ident) =>
        {
            ::__private::push_or_or_spanned(&mut $tokens, $span);
        };

        (? $tokens:ident $span:ident) =>
        {
            ::__private::push_question_spanned(&mut $tokens, $span);
        };

        (-> $tokens:ident $span:ident) =>
        {
            ::__private::push_rarrow_spanned(&mut $tokens, $span);
        };

        (<- $tokens:ident $span:ident) =>
        {
            ::__private::push_larrow_spanned(&mut $tokens, $span);
        };

        (% $tokens:ident $span:ident) =>
        {
            ::__private::push_rem_spanned(&mut $tokens, $span);
        };

        (%= $tokens:ident $span:ident) =>
        {
            ::__private::push_rem_eq_spanned(&mut $tokens, $span);
        };

        (=> $tokens:ident $span:ident) =>
        {
            ::__private::push_fat_arrow_spanned(&mut $tokens, $span);
        };

        (<< $tokens:ident $span:ident) =>
        {
            ::__private::push_shl_spanned(&mut $tokens, $span);
        };

        (<<= $tokens:ident $span:ident) =>
        {
            ::__private::push_shl_eq_spanned(&mut $tokens, $span);
        };

        (>> $tokens:ident $span:ident) =>
        {
            ::__private::push_shr_spanned(&mut $tokens, $span);
        };

        (>>= $tokens:ident $span:ident) =>
        {
            ::__private::push_shr_eq_spanned(&mut $tokens, $span);
        };

        (* $tokens:ident $span:ident) =>
        {
            ::__private::push_star_spanned(&mut $tokens, $span);
        };

        (- $tokens:ident $span:ident) =>
        {
            ::__private::push_sub_spanned(&mut $tokens, $span);
        };

        (-= $tokens:ident $span:ident) =>
        {
            ::__private::push_sub_eq_spanned(&mut $tokens, $span);
        };

        ($lifetime:lifetime $tokens:ident $span:ident) =>
        {
            ::__private::push_lifetime_spanned(&mut $tokens, $span, stringify!($lifetime));
        };

        (_ $tokens:ident $span:ident) =>
        {
            ::__private::push_underscore_spanned(&mut $tokens, $span);
        };

        ($other:tt $tokens:ident $span:ident) =>
        {
            ::__private::parse_spanned(&mut $tokens, $span, stringify!($other));
        };
    }

    #[macro_export] macro_rules! format_ident
    {
        ($fmt:expr) => {
            format_ident_impl!([
                ::quote::__private::Option::None,
                $fmt
            ])
        };

        ($fmt:expr, $($rest:tt)*) => {
            format_ident_impl!([
                ::quote::__private::Option::None,
                $fmt
            ] $($rest)*)
        };
    }

    #[macro_export] macro_rules! format_ident_impl
    {
       
        ([$span:expr, $($fmt:tt)*]) => {
            ::quote::__private::mk_ident(
                &::quote::__private::format!($($fmt)*),
                $span,
            )
        };

       
        ([$old:expr, $($fmt:tt)*] span = $span:expr) => {
            format_ident_impl!([$old, $($fmt)*] span = $span,)
        };
        ([$old:expr, $($fmt:tt)*] span = $span:expr, $($rest:tt)*) => {
            format_ident_impl!([
                ::quote::__private::Option::Some::<::quote::__private::Span>($span),
                $($fmt)*
            ] $($rest)*)
        };

       
        ([$span:expr, $($fmt:tt)*] $name:ident = $arg:expr) => {
            format_ident_impl!([$span, $($fmt)*] $name = $arg,)
        };
        ([$span:expr, $($fmt:tt)*] $name:ident = $arg:expr, $($rest:tt)*) => {
            match ::quote::__private::IdentFragmentAdapter(&$arg) {
                arg => format_ident_impl!([$span.or(arg.span()), $($fmt)*, $name = arg] $($rest)*),
            }
        };

       
        ([$span:expr, $($fmt:tt)*] $arg:expr) => {
            format_ident_impl!([$span, $($fmt)*] $arg,)
        };
        ([$span:expr, $($fmt:tt)*] $arg:expr, $($rest:tt)*) => {
            match ::quote::__private::IdentFragmentAdapter(&$arg) {
                arg => format_ident_impl!([$span.or(arg.span()), $($fmt)*, arg] $($rest)*),
            }
        };
    }

    #[macro_export] macro_rules! ast_struct 
    {
        (
            $(#[$attr:meta])*
            $pub:ident $struct:ident $name:ident #full $body:tt
        ) =>
        {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(struct $struct);
            $(#[$attr])* $pub $struct $name $body
        };

        (
            $(#[$attr:meta])*
            $pub:ident $struct:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(struct $struct);

            $(#[$attr])* $pub $struct $name $body
        };
    }
    
    #[macro_export] macro_rules! ast_enum
    {
        (
            $(#[$enum_attr:meta])*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(enum $enum);

            $(#[$enum_attr])* $pub $enum $name $body
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs
    {
        (
            $(#[$enum_attr:meta])*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(enum $enum);

            $(#[$enum_attr])* $pub $enum $name $body

            ast_enum_of_structs_impl!($name $body);

                generate_to_tokens!(() tokens $name $body);
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs_impl
    {
        (
            $name:ident {
                $(
                    $(#[cfg $cfg_attr:tt])*
                    $(#[doc $($doc_attr:tt)*])*
                    $variant:ident $( ($member:ident) )*,
                )*
            }
        ) => {
            $($(
                ast_enum_from_struct!($name::$variant, $member);
            )*)*
        };
    }

    #[macro_export] macro_rules! ast_enum_from_struct
    {
        ($name:ident::Verbatim, $member:ident) => {};

        ($name:ident::$variant:ident, $member:ident) =>
        {
            impl From<$member> for $name
            {
                fn from(e: $member) -> $name {
                    $name::$variant(e)
                }
            }
        };
    }
    
    #[macro_export] macro_rules! generate_to_tokens
    {
        (
            ($($arms:tt)*) $tokens:ident $name:ident {
                $(#[cfg $cfg_attr:tt])*
                $(#[doc $($doc_attr:tt)*])*
                $variant:ident,
                $($next:tt)*
            }
        ) => {
            generate_to_tokens!(
                ($($arms)* $(#[cfg $cfg_attr])* $name::$variant => {})
                $tokens $name { $($next)* }
            );
        };

        (
            ($($arms:tt)*) $tokens:ident $name:ident {
                $(#[cfg $cfg_attr:tt])*
                $(#[doc $($doc_attr:tt)*])*
                $variant:ident($member:ident),
                $($next:tt)*
            }
        ) => {
            generate_to_tokens!(
                ($($arms)* $(#[cfg $cfg_attr])* $name::$variant(_e) => _e.to_tokens($tokens),)
                $tokens $name { $($next)* }
            );
        };

        (($($arms:tt)*) $tokens:ident $name:ident {}) => {
            impl ::quote::ToTokens for $name {
                fn to_tokens(&self, $tokens:&mut ::process::macros::TokenStream )
                {
                    match self {
                        $($arms)*
                    }
                }
            }
        };
    }
    
    #[macro_export] macro_rules! pub_if_not_doc
    {
        ($(#[$m:meta])* $pub:ident $($item:tt)*) => {
            check_keyword_matches!(pub $pub);

            $(#[$m])*
            $pub $($item)*
        };
    }

    #[macro_export] macro_rules! check_keyword_matches 
    {
        (enum enum) => {};
        (pub pub) => {};
        (struct struct) => {};
    }

    #[macro_export] macro_rules! return_impl_trait
    {
        (
            $(#[$attr:meta])*
            $vis:vis fn $name:ident $args:tt -> $impl_trait:ty [$concrete:ty] $body:block
        ) => {
            #[cfg(not(docsrs))]
            $(#[$attr])*
            $vis fn $name $args -> $concrete $body

            #[cfg(docsrs)]
            $(#[$attr])*
            $vis fn $name $args -> $impl_trait $body
        };
    }
    /// Parse a set of parentheses and expose their content to subsequent parsers.
    #[macro_export] macro_rules! parenthesized
    {
        ($content:ident in $cursor:expr) => {
            match ::syntax::__private::parse_parens(&$cursor) {
                ::syntax::__private::Ok(parens) => {
                    $content = parens.content;
                    parens.token
                }
                ::syntax::__private::Err(error) => {
                    return ::syntax::__private::Err(error);
                }
            }
        };
    }
    /// Parse a set of curly braces and expose their content to subsequent parsers.
    #[macro_export] macro_rules! braced
    {
        ($content:ident in $cursor:expr) => 
        {
            match ::syntax::__private::parse_braces(&$cursor) {
                ::syntax::__private::Ok(braces) => {
                    $content = braces.content;
                    braces.token
                }
                ::syntax::__private::Err(error) => {
                    return ::syntax::__private::Err(error);
                }
            }
        };
    }
    /// Parse a set of square brackets and expose their content to subsequent parsers.
    #[macro_export] macro_rules! bracketed
    {
        ($content:ident in $cursor:expr) =>
        {
            match ::syntax::__private::parse_brackets(&$cursor)
            {
                ::syntax::__private::Ok(brackets) => {
                    $content = brackets.content;
                    brackets.token
                }
                ::syntax::__private::Err(error) => {
                    return ::syntax::__private::Err(error);
                }
            }
        };
    }

    #[macro_export] macro_rules! parse_quote
    {
        ($($tt:tt)*) =>
        {
            ::syntax::__private::parse_quote(::syntax::__private::quote::quote!($($tt)*))
        };
    }
    /// This macro is [`parse_quote!`] + [`quote_spanned!`][quote::quote_spanned].
    #[macro_export] macro_rules! parse_quote_spanned
    {
        ($span:expr=> $($tt:tt)*) =>
        {
            ::syntax::__private::parse_quote(::syntax::__private::quote::quote_spanned!($span=> $($tt)*))
        };
    }
    
    #[macro_export] macro_rules! parse_macro_input
    {
        ($tokenstream:ident as $ty:ty) => {
            match ::syntax::parse::<$ty>($tokenstream) {
                ::syntax::__private::Ok(data) => data,
                ::syntax::__private::Err(err) => {
                    return ::syntax::__private::TokenStream::from(err.to_compile_error());
                }
            }
        };
        ($tokenstream:ident with $parser:path) => {
            match ::syntax::parse::Parser::parse($parser, $tokenstream) {
                ::syntax::__private::Ok(data) => data,
                ::syntax::__private::Err(err) => {
                    return ::syntax::__private::TokenStream::from(err.to_compile_error());
                }
            }
        };
        ($tokenstream:ident) => {
            ::syntax::parse_macro_input!($tokenstream as _)
        };
    }

    #[macro_export] macro_rules! custom_punctuation
    {
        ($ident:ident, $($tt:tt)+) =>
        {
            pub struct $ident {
                #[allow(dead_code)]
                pub spans: ::syntax::custom_punctuation_repr!($($tt)+),
            }

                #[allow(dead_code, non_snake_case)]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::custom_punctuation_repr!($($tt)+)>>(
                spans: __S,
            ) -> $ident {
                let _validate_len = 0 $(+ ::syntax::custom_punctuation_len!(strict, $tt))*;
                $ident {
                    spans: ::syntax::__private::IntoSpans::into_spans(spans)
                }
            }

            const _: () = {
                impl ::syntax::__private::Default for $ident {
                    fn default() -> Self {
                        $ident(::syntax::__private::Span::call_site())
                    }
                }

                ::syntax::impl_parse_for_custom_punctuation!($ident, $($tt)+);
                ::syntax::impl_to_tokens_for_custom_punctuation!($ident, $($tt)+);
                ::syntax::impl_clone_for_custom_punctuation!($ident, $($tt)+);
                ::syntax::impl_extra_traits_for_custom_punctuation!($ident, $($tt)+);
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_punctuation {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::CustomToken for $ident {
                fn peek(cursor: ::syntax::buffer::Cursor) -> ::syntax::__private::bool {
                    ::syntax::__private::peek_punct(cursor, ::syntax::stringify_punct!($($tt)+))
                }

                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!("`", ::syntax::stringify_punct!($($tt)+), "`")
                }
            }

            impl ::syntax::parse::Parse for $ident
            {
                fn parse(input: ::syntax::parse::ParseStream) -> ::syntax::parse::Result<$ident> {
                    let spans: ::syntax::custom_punctuation_repr!($($tt)+) =
                        ::syntax::__private::parse_punct(input, ::syntax::stringify_punct!($($tt)+))?;
                    Ok($ident(spans))
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_punctuation {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens(&self, tokens: &mut ::syntax::__private::TokenStream2) {
                    ::syntax::__private::print_punct(::syntax::stringify_punct!($($tt)+), &self.spans, tokens)
                }
            }
        };
    }
        
    #[macro_export] macro_rules! impl_clone_for_custom_punctuation {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::Copy for $ident {}

            #[allow(clippy::expl_impl_clone_on_copy)]
            impl ::syntax::__private::Clone for $ident {
                fn clone(&self) -> Self {
                    *self
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_punctuation {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::Debug for $ident {
                fn fmt(&self, f: &mut ::syntax::__private::Formatter) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str(f, ::syntax::__private::stringify!($ident))
                }
            }

            impl ::syntax::__private::Eq for $ident {}

            impl ::syntax::__private::PartialEq for $ident {
                fn eq(&self, _other: &Self) -> ::syntax::__private::bool {
                    true
                }
            }

            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>(&self, _state: &mut __H) {}
            }
        };
    }
        
    #[macro_export] macro_rules! custom_punctuation_repr {
        ($($tt:tt)+) => {
            [::syntax::__private::Span; 0 $(+ ::syntax::custom_punctuation_len!(lenient, $tt))+]
        };
    }
    
    #[macro_export] macro_rules! custom_punctuation_len {
        ($mode:ident, &)     => { 1 };
        ($mode:ident, &&)    => { 2 };
        ($mode:ident, &=)    => { 2 };
        ($mode:ident, @)     => { 1 };
        ($mode:ident, ^)     => { 1 };
        ($mode:ident, ^=)    => { 2 };
        ($mode:ident, :)     => { 1 };
        ($mode:ident, ,)     => { 1 };
        ($mode:ident, $)     => { 1 };
        ($mode:ident, .)     => { 1 };
        ($mode:ident, ..)    => { 2 };
        ($mode:ident, ...)   => { 3 };
        ($mode:ident, ..=)   => { 3 };
        ($mode:ident, =)     => { 1 };
        ($mode:ident, ==)    => { 2 };
        ($mode:ident, =>)    => { 2 };
        ($mode:ident, >=)    => { 2 };
        ($mode:ident, >)     => { 1 };
        ($mode:ident, <-)    => { 2 };
        ($mode:ident, <=)    => { 2 };
        ($mode:ident, <)     => { 1 };
        ($mode:ident, -)     => { 1 };
        ($mode:ident, -=)    => { 2 };
        ($mode:ident, !=)    => { 2 };
        ($mode:ident, !)     => { 1 };
        ($mode:ident, |)     => { 1 };
        ($mode:ident, |=)    => { 2 };
        ($mode:ident, ||)    => { 2 };
        ($mode:ident, ::)    => { 2 };
        ($mode:ident, %)     => { 1 };
        ($mode:ident, %=)    => { 2 };
        ($mode:ident, +)     => { 1 };
        ($mode:ident, +=)    => { 2 };
        ($mode:ident, #)     => { 1 };
        ($mode:ident, ?)     => { 1 };
        ($mode:ident, ->)    => { 2 };
        ($mode:ident, ;)     => { 1 };
        ($mode:ident, <<)    => { 2 };
        ($mode:ident, <<=)   => { 3 };
        ($mode:ident, >>)    => { 2 };
        ($mode:ident, >>=)   => { 3 };
        ($mode:ident, /)     => { 1 };
        ($mode:ident, /=)    => { 2 };
        ($mode:ident, *)     => { 1 };
        ($mode:ident, *=)    => { 2 };
        ($mode:ident, ~)     => { 1 };
        (lenient, $tt:tt)    => { 0 };
        (strict, $tt:tt)     => {{ ::syntax::custom_punctuation_unexpected!($tt); 0 }};
    }
    
    #[macro_export] macro_rules! custom_punctuation_unexpected {
        () => {};
    }
    
    #[macro_export] macro_rules! stringify_punct {
        ($($tt:tt)+) => {
            ::syntax::__private::concat!($(::syntax::__private::stringify!($tt)),+)
        };
    }

    #[macro_export] macro_rules! custom_keyword
    {
        ($ident:ident) => {
            #[allow(non_camel_case_types)]
            pub struct $ident {
                #[allow(dead_code)]
                pub span: ::syntax::__private::Span,
            }

                #[allow(dead_code, non_snake_case)]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: ::syntax::__private::IntoSpans::into_spans(span),
                }
            }

            const _: () = {
                impl ::syntax::__private::Default for $ident {
                    fn default() -> Self {
                        $ident {
                            span: ::syntax::__private::Span::call_site(),
                        }
                    }
                }

                ::syntax::impl_parse_for_custom_keyword!($ident);
                ::syntax::impl_to_tokens_for_custom_keyword!($ident);
                ::syntax::impl_clone_for_custom_keyword!($ident);
                ::syntax::impl_extra_traits_for_custom_keyword!($ident);
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_keyword {
        ($ident:ident) => {
           
            impl ::syntax::__private::CustomToken for $ident {
                fn peek(cursor: ::syntax::buffer::Cursor) -> ::syntax::__private::bool {
                    if let ::syntax::__private::Some((ident, _rest)) = cursor.ident() {
                        ident == ::syntax::__private::stringify!($ident)
                    } else {
                        false
                    }
                }

                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!("`", ::syntax::__private::stringify!($ident), "`")
                }
            }

            impl ::syntax::parse::Parse for $ident
            {
                fn parse(input: ::syntax::parse::ParseStream) -> ::syntax::parse::Result<$ident> {
                    input.step(|cursor| {
                        if let ::syntax::__private::Some((ident, rest)) = cursor.ident() {
                            if ident == ::syntax::__private::stringify!($ident) {
                                return ::syntax::__private::Ok(($ident { span: ident.span() }, rest));
                            }
                        }
                        ::syntax::__private::Err(cursor.error(::syntax::__private::concat!(
                            "expected `",
                            ::syntax::__private::stringify!($ident),
                            "`",
                        )))
                    })
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_keyword {
        ($ident:ident) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens(&self, tokens: &mut ::syntax::__private::TokenStream2) {
                    let ident = ::syntax::Ident::new(::syntax::__private::stringify!($ident), self.span);
                    ::syntax::__private::TokenStreamExt::append(tokens, ident);
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_clone_for_custom_keyword {
        ($ident:ident) => {
            impl ::syntax::__private::Copy for $ident {}

            #[allow(clippy::expl_impl_clone_on_copy)]
            impl ::syntax::__private::Clone for $ident {
                fn clone(&self) -> Self {
                    *self
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_keyword 
    {
        ($ident:ident) => {
            impl ::syntax::__private::Debug for $ident {
                fn fmt(&self, f: &mut ::syntax::__private::Formatter) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str(
                        f,
                        ::syntax::__private::concat!(
                            "Keyword [",
                            ::syntax::__private::stringify!($ident),
                            "]",
                        ),
                    )
                }
            }

            impl ::syntax::__private::Eq for $ident {}

            impl ::syntax::__private::PartialEq for $ident {
                fn eq(&self, _other: &Self) -> ::syntax::__private::bool {
                    true
                }
            }

            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>(&self, _state: &mut __H) {}
            }
        };
    }
    /// Forward a method to an inherent method or a base trait method.
    #[macro_export] macro_rules! forward
    {
        ($( Self :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
            => {$(
                #[inline]
                fn $method(self $( , $arg : $ty )* ) -> $ret {
                    Self::$method(self $( , $arg )* )
                }
            )*};
        ($( $base:ident :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
            => {$(
                #[inline]
                fn $method(self $( , $arg : $ty )* ) -> $ret {
                    <Self as $base>::$method(self $( , $arg )* )
                }
            )*};
        ($( $base:ident :: $method:ident ( $( $arg:ident : $ty:ty ),* ) -> $ret:ty ; )*)
            => {$(
                #[inline]
                fn $method( $( $arg : $ty ),* ) -> $ret {
                    <Self as $base>::$method( $( $arg ),* )
                }
            )*};
        ($( $imp:path as $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
            => {$(
                #[inline]
                fn $method(self $( , $arg : $ty )* ) -> $ret {
                    $imp(self $( , $arg )* )
                }
            )*};
    }

    #[macro_export] macro_rules! constant
    {
        ($( $method:ident () -> $ret:expr ; )*)
            => {$(
                #[inline]
                fn $method() -> Self {
                    $ret
                }
            )*};
    }
}

pub mod ascii
{
    pub use std::ascii::{ * };
    
    const T: bool = true;
    const F: bool = false;

    #[repr(C, align(8))]
    pub struct Align8<T>(pub T);
    #[repr(C, align(64))]
    pub struct Align64<T>(pub T);

    pub static ASCII_START: Align64<[bool; 128]> = Align64
    ([
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ]);

    pub static ASCII_CONTINUE: Align64<[bool; 128]> = Align64
    ([
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, 
        F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, T, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ]);

    pub const CHUNK: usize = 64;

    pub static TRIE_START: Align8<[u8; 411]> = Align8
    ([
        0x04, 0x0B, 0x0F, 0x13, 0x17, 0x1B, 0x1F, 0x23, 0x27, 0x2D, 0x31, 0x34, 0x38, 0x3C, 0x40, 0x02, 0x45, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x4D, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x51, 0x54, 0x58, 0x5C, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x60, 
        0x64, 0x66, 0x6A, 0x6E, 0x72, 0x28, 0x76, 0x78, 0x7C, 0x80, 0x84, 0x88, 0x8C, 0x90, 0x94, 0x98, 0x9C, 0xA0, 
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xA8, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x00, 
        0x05, 0xB2, 0xB6, 0xBA, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xD1, 0xD3, 0x00, 0x00, 0x00, 0xC9, 0xD9, 0xDD, 0xE1, 0xE5, 0xE9, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7,
    ]);

    pub static TRIE_CONTINUE: Align8<[u8; 1793]> = Align8
    ([
        0x08, 0x0D, 0x11, 0x15, 0x19, 0x1D, 0x21, 0x25, 0x2A, 0x2F, 0x31, 0x36, 0x3A, 0x3E, 0x42, 0x02,0x47, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x4F, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x51, 0x56, 0x5A, 0x5E, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62, 
        0x64, 0x68,0x6C, 0x70, 0x74, 0x28, 0x76, 0x7A, 0x7E, 0x82, 0x86, 0x8A, 0x8E, 0x92, 0x96, 0x9A, 0x9E, 0xA2,
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xAB, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xB0, 0x00, 0x00, 0x00, 
        0x05, 0xB4, 0xB8, 0xBC, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xC3, 0xC6, 0xCE, 
        0xD1, 0xD5, 0x00, 0xD7, 0x00, 0xC9,0xDB, 0xDF, 0xE3, 0xE7, 0xEB, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xCC, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xCF,
    ]);

    pub static LEAF: Align64<[u8; 7968]> = Align64
    ([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xAA, 
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x5F, 0xDC, 0x1F, 0xCF, 0x0F, 0xFF, 0x1F, 
        0xDC, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xA0, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 
        0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0xDF, 0xB8, 0x40, 0xD7, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xB8, 0xC0, 0xD7, 0xFF, 0xFF,
        0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
        0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0x87, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFB, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xB6, 0x00, 0xFF, 0xFF, 0xFF, 0x87, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC0, 0xFE, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2F, 0x00, 0x60, 0xC0, 0x00, 0x9C,
        0x00, 0x00, 0xFD, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x02, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x07, 0x30, 0x04,
        0x00, 0x00, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0x9F, 0xFF, 0xFD, 0xFF, 0x9F,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x24,
        0xFF, 0xFF, 0x3F, 0x04, 0x10, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0x01, 0xFF, 0x03, 0x00, 0xFE, 0xFF,
        0xE1, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0x23, 0x00, 0x40, 0x00, 0xB0, 0x03, 0x00, 0x03, 0x10,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFE, 0xFF,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0xF3, 0x9F, 0x79, 0x80, 0xB0, 0xCF, 0xFF, 0x03, 0x50,
        0xE0, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0x03, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x00, 0x1C, 0x00,
        0xE0, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x02,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x02, 0x00,
        0xE8, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEE, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0xD3, 0x87, 0x39, 0x02, 0x5E, 0xC0, 0xFF, 0x3F, 0x00,
        0xEE, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0xBF, 0x3B, 0x01, 0x00, 0xCF, 0xFF, 0x00, 0xFE,
        0xEE, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0x9F, 0x39, 0xE0, 0xB0, 0xCF, 0xFF, 0x02, 0x00,
        0xEC, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0xC3, 0xC7, 0x3D, 0x81, 0x00, 0xC0, 0xFF, 0x00, 0x00,
        0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0x23, 0x00, 0x00, 0x00, 0x37, 0x03, 0x00, 0x00, 0x00,
        0xE1, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x23, 0x00, 0x00, 0x00, 0x70, 0x03, 0x00, 0x06, 0x00,
        0xF0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x27, 0x00, 0x40, 0x70, 0x80, 0x03, 0x00, 0x00, 0xFC,
        0xE0, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0xF3, 0xDF, 0x3D, 0x60, 0x37, 0xCF, 0xFF, 0x00, 0x00,
        0xEF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0xF3, 0xDF, 0x3D, 0x60, 0x70, 0xCF, 0xFF, 0x0E, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x7D, 0xF0, 0x80, 0xCF, 0xFF, 0x00, 0xFC,
        0xEE, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x84, 0x5F, 0xFF, 0xC0, 0xFF, 0x0C, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0x05, 0x20, 0x5F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x7F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0xFF, 0x3F, 0x5F, 0x7F, 0xFF, 0xF3, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x03, 0xFF, 0x03, 0xA0, 0xC2, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0xFE, 0xFF,
        0xDF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x80, 0x00, 0x00, 0x3F, 0x3C, 0x62, 0xC0, 0xE1, 0xFF,
        0x03, 0x40, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0xFE, 0x03, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x03, 0x80, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xDF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF, 0x1F, 0x00, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xDF, 0x0D, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F, 0x30, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xB8, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x0F, 0xFF, 0x0F, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x01, 0xC0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x9F,
        0xFF, 0x03, 0xFF, 0x03, 0x80, 0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x0F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03, 0x00, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDE, 0x6F, 0x04,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x27, 0x00, 0xF0, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x1F, 0xE2, 0xFF, 0x01, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x78, 0x0C, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x80,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE6, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0x00, 0x0C, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xBF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xBB, 0xF7, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x68,
        0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x80, 0x00, 0x00, 0xDF, 0xFF, 0x00, 0x7C,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xE8,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x80, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0xF7, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0xC4,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x62, 0x3E, 0x05, 0x00, 0x00, 0x38, 0xFF, 0x07, 0x1C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0x7F, 0xFC,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x38, 0xFF, 0xFF, 0x7C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x37, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xA0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xE0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0xFF, 0xFF, 0x07, 0xC0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0xFF, 0x03, 0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07, 0xE0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0x3F, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x91, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x37, 0x00,
        0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x6F, 0xF0, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x87, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xBE, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1B, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x90, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x47, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x3F, 0x80,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x4F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xDE, 0xFF, 0x17, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0x0F, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0xE0, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x03,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xFB, 0x9F, 0x39, 0x81, 0xE0, 0xCF, 0x1F, 0x1F, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xA5, 0xF7, 0x0F, 0x00, 0x06, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x80, 0x07, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xC3, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x01, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0x0F, 0xFF, 0x03, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0xBF, 0xF9, 0x0F, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x1B, 0x00, 0x00, 0x00,
        0x01, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0x00, 0x01, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x20, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0x03,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x01, 0x00, 0xFF, 0x03, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFE, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xB4, 0xFF, 0x00, 0xFF, 0x03, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x7F, 0xFB, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xF4, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x07, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x0F, 0x00, 0xFF, 0x03, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x7C, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x80, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x6F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE3, 0x07, 0xF8,
        0xE7, 0x0F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xE0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xDF, 0x64, 0xDE, 0xFF, 0xEB, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xBF, 0xE7, 0xDF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7B, 0x5F, 0xFC, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x20, 0x00,
        0x10, 0x00, 0x00, 0xF8, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x3F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFF, 0xFF, 0xF9, 0xDB, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x3F, 0xFF, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xB7, 0x3F, 0x1F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x3F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEF, 0xFF, 0xFF, 0xFF, 0x96, 0xFE, 0xF7, 0x0A, 0x84, 0xEA, 0x96, 0xAA, 0x96, 0xF7, 0xF7, 0x5E,
        0xFF, 0xFB, 0xFF, 0x0F, 0xEE, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]);
}

pub mod backtrace
{
    pub use std::backtrace::{ * };
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod cell
{
    pub use std::cell::{ * };
}

pub mod char
{
    pub use std::char::{ * };
}

pub mod clone
{
    pub use std::clone::{ * };
}

pub mod cmp
{
    pub use std::cmp::{ * };
}

pub mod collections
{
    pub use std::collections::{ * };
}

pub mod convert
{
    pub use std::convert::{ * };
}

pub mod default
{
    pub use std::default::{ * };
}

pub mod error
{
    pub use std::error::{ * };
}

pub mod f32
{
    pub use std::f32::{ * };
}

pub mod f64
{
    pub use std::f64::{ * };
}

pub mod ffi
{
    pub use std::ffi::{ * };
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod hash
{
    pub use std::hash::{ * };
}

pub mod i8
{
    pub use std::i8::{ * };
}

pub mod i16
{
    pub use std::i16::{ * };
}

pub mod i32
{
    pub use std::i32::{ * };
}

pub mod i64
{
    pub use std::i64::{ * };
}

pub mod isize
{
    pub use std::isize::{ * };
}

pub mod i128
{
    pub use std::i128::{ * };
}

pub mod is
{
    use ::
    {
        *,
    };
    /// Whether the character has the Unicode property XID\_Start.
    /*
    pub fn is_xid_start( ... ) -> bool*/
    pub fn xid_start( ch:char ) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_START.0[ch as usize]; }
        let chunk = * ::ascii::TRIE_START.0.get(ch as usize / 8 / ::ascii::CHUNK).unwrap_or(&0);
        let offset = chunk as usize *  ::ascii::CHUNK / 2 + ch as usize / 8 %  ::ascii::CHUNK;
        unsafe {  ::ascii::LEAF.0.get_unchecked(offset) }.wrapping_shr(ch as u32 % 8) & 1 != 0
    }
    /// Whether the character has the Unicode property XID\_Continue.
    /*
    pub fn is_xid_continue(ch: char) -> bool */
    pub fn xid_continue(ch: char) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_CONTINUE.0[ch as usize]; }
        let chunk = *::ascii::TRIE_CONTINUE.0.get(ch as usize / 8 / ::ascii::CHUNK).unwrap_or(&0);
        let offset = chunk as usize * ::ascii::CHUNK / 2 + ch as usize / 8 % ::ascii::CHUNK;
        unsafe { ::ascii::LEAF.0.get_unchecked(offset) }.wrapping_shr(ch as u32 % 8) & 1 != 0
    }
    /*
    fn is_whitespace(ch: char) -> bool*/
    pub fn whitespace(ch: char) -> bool
    {
        ch.is_whitespace() || ch == '\u{200e}' || ch == '\u{200f}'
    }
    /*
    pub fn is_ident_start(c: char) -> bool*/
    pub fn ident_start(c: char) -> bool
    {
        c == '_' || ::is::xid_start(c)
    }
    /*
    pub fn is_ident_continue(c: char) -> bool */
    pub fn ident_continue(c: char) -> bool
    {
        xid_continue(c)
    }
}

pub mod iter
{
    pub use std::iter::{ * };
}

pub mod marker
{
    pub use std::marker::{ * };
    use ::
    {
        rc::{ Rc },
        panic::{ RefUnwindSafe, UnwindSafe },
        *,
    };
    /*
    use alloc::rc::Rc;
    use core::marker::PhantomData;
    use core::panic::{RefUnwindSafe, UnwindSafe};
    */
    pub const MARKER: ProcMacroAutoTraits = ProcMacroAutoTraits(PhantomData);
    /// Zero sized marker with the correct set of autotrait impls we want all proc macro types to have.
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct ProcMacroAutoTraits( pub PhantomData<Rc<()>> );
    impl UnwindSafe for ProcMacroAutoTraits {}
    impl RefUnwindSafe for ProcMacroAutoTraits {}
}

pub mod num
{
    pub use std::num::{ * };
    use ::
    {
        *,
    };
    /*
    */
    pub mod traits
    {
        //! Numeric traits for generic mathematics
        use ::
        {
            num::{ Wrapping },
            ops::{ Add, Div, Mul, Rem, Sub, AddAssign, DivAssign, MulAssign, RemAssign, SubAssign },
            *,
        };
        /*
        */
        pub mod bounds
        {
            use ::
            {
                num::
                {
                    NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize, NonZeroU128,
                    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize,
                },
                *,
            };
            /*
            */
            /// Numbers which have upper and lower bounds
            pub trait Bounded
            {
               
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }
            /// Numbers which have lower bounds
            pub trait LowerBounded
            {
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
            }
           
            impl<T: Bounded> LowerBounded for T
            {
                fn min_value() -> T {
                    Bounded::min_value()
                }
            }
            /// Numbers which have upper bounds
            pub trait UpperBounded
            {
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }
           
            impl<T: Bounded> UpperBounded for T
            {
                fn max_value() -> T {
                    Bounded::max_value()
                }
            }

            macro_rules! bounded_impl
            {
                ($t:ty, $min:expr, $max:expr) =>
                {
                    impl Bounded for $t {
                        #[inline]
                        fn min_value() -> $t {
                            $min
                        }

                        #[inline]
                        fn max_value() -> $t {
                            $max
                        }
                    }
                };
            }

            bounded_impl!(usize, usize::MIN, usize::MAX);
            bounded_impl!(u8, u8::MIN, u8::MAX);
            bounded_impl!(u16, u16::MIN, u16::MAX);
            bounded_impl!(u32, u32::MIN, u32::MAX);
            bounded_impl!(u64, u64::MIN, u64::MAX);
            bounded_impl!(u128, u128::MIN, u128::MAX);

            bounded_impl!(isize, isize::MIN, isize::MAX);
            bounded_impl!(i8, i8::MIN, i8::MAX);
            bounded_impl!(i16, i16::MIN, i16::MAX);
            bounded_impl!(i32, i32::MIN, i32::MAX);
            bounded_impl!(i64, i64::MIN, i64::MAX);
            bounded_impl!(i128, i128::MIN, i128::MAX);

            macro_rules! bounded_impl_nonzero_const 
            {
                ($t:ty, $v:expr, $i:ident) => {
                    const $i: $t = match <$t>::new($v) {
                        Some(nz) => nz,
                        None => panic!("bad nonzero bound!"),
                    };
                };
            }

            macro_rules! bounded_impl_nonzero 
            {
                ($t:ty, $min:expr, $max:expr) => {
                    impl Bounded for $t {
                        #[inline]
                        fn min_value() -> $t {
                           
                            bounded_impl_nonzero_const!($t, $min, MIN);
                            MIN
                        }

                        #[inline]
                        fn max_value() -> $t {
                           
                            bounded_impl_nonzero_const!($t, $max, MAX);
                            MAX
                        }
                    }
                };
            }

            bounded_impl_nonzero!(NonZeroUsize, 1, usize::MAX);
            bounded_impl_nonzero!(NonZeroU8, 1, u8::MAX);
            bounded_impl_nonzero!(NonZeroU16, 1, u16::MAX);
            bounded_impl_nonzero!(NonZeroU32, 1, u32::MAX);
            bounded_impl_nonzero!(NonZeroU64, 1, u64::MAX);
            bounded_impl_nonzero!(NonZeroU128, 1, u128::MAX);

            bounded_impl_nonzero!(NonZeroIsize, isize::MIN, isize::MAX);
            bounded_impl_nonzero!(NonZeroI8, i8::MIN, i8::MAX);
            bounded_impl_nonzero!(NonZeroI16, i16::MIN, i16::MAX);
            bounded_impl_nonzero!(NonZeroI32, i32::MIN, i32::MAX);
            bounded_impl_nonzero!(NonZeroI64, i64::MIN, i64::MAX);
            bounded_impl_nonzero!(NonZeroI128, i128::MIN, i128::MAX);

            impl<T: Bounded> Bounded for Wrapping<T> 
            {
                fn min_value() -> Self {
                    Wrapping(T::min_value())
                }
                fn max_value() -> Self {
                    Wrapping(T::max_value())
                }
            }

            bounded_impl!(f32, f32::MIN, f32::MAX);

            macro_rules! for_each_tuple_ 
            {
                ( $m:ident !! ) => (
                    $m! { }
                );
                ( $m:ident !! $h:ident, $($t:ident,)* ) => (
                    $m! { $h $($t)* }
                    for_each_tuple_! { $m !! $($t,)* }
                );
            }

            macro_rules! for_each_tuple 
            {
                ($m:ident) => {
                    for_each_tuple_! { $m !! A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, }
                };
            }

            macro_rules! bounded_tuple 
            {
                ( $($name:ident)* ) => (
                    impl<$($name: Bounded,)*> Bounded for ($($name,)*) {
                        #[inline]
                        fn min_value() -> Self {
                            ($($name::min_value(),)*)
                        }
                        #[inline]
                        fn max_value() -> Self {
                            ($($name::max_value(),)*)
                        }
                    }
                );
            }

            for_each_tuple!(bounded_tuple);
            bounded_impl!(f64, f64::MIN, f64::MAX);
        } pub use self::bounds::Bounded;

        pub mod cast
        {
            use ::
            {
                mem::{ size_of },
                num::
                {
                    NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize, NonZeroU128,
                    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize, Wrapping,
                },
                *,
            };
            /*
            */
            /// A generic trait for converting a value to a number.
            pub trait ToPrimitive {
                /// Converts the value of `self` to an `isize`. If the value cannot be
                /// represented by an `isize`, then `None` is returned.
                #[inline]
                fn to_isize(&self) -> Option<isize> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_isize)
                }

                /// Converts the value of `self` to an `i8`. If the value cannot be
                /// represented by an `i8`, then `None` is returned.
                #[inline]
                fn to_i8(&self) -> Option<i8> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i8)
                }

                /// Converts the value of `self` to an `i16`. If the value cannot be
                /// represented by an `i16`, then `None` is returned.
                #[inline]
                fn to_i16(&self) -> Option<i16> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i16)
                }

                /// Converts the value of `self` to an `i32`. If the value cannot be
                /// represented by an `i32`, then `None` is returned.
                #[inline]
                fn to_i32(&self) -> Option<i32> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i32)
                }

                /// Converts the value of `self` to an `i64`. If the value cannot be
                /// represented by an `i64`, then `None` is returned.
                fn to_i64(&self) -> Option<i64>;

                /// Converts the value of `self` to an `i128`. If the value cannot be
                /// represented by an `i128` (`i64` under the default implementation), then
                /// `None` is returned.
                ///
                /// The default implementation converts through `to_i64()`. Types implementing
                /// this trait should override this method if they can represent a greater range.
                #[inline]
                fn to_i128(&self) -> Option<i128> {
                    self.to_i64().map(From::from)
                }

                /// Converts the value of `self` to a `usize`. If the value cannot be
                /// represented by a `usize`, then `None` is returned.
                #[inline]
                fn to_usize(&self) -> Option<usize> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_usize)
                }

                /// Converts the value of `self` to a `u8`. If the value cannot be
                /// represented by a `u8`, then `None` is returned.
                #[inline]
                fn to_u8(&self) -> Option<u8> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u8)
                }

                /// Converts the value of `self` to a `u16`. If the value cannot be
                /// represented by a `u16`, then `None` is returned.
                #[inline]
                fn to_u16(&self) -> Option<u16> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u16)
                }

                /// Converts the value of `self` to a `u32`. If the value cannot be
                /// represented by a `u32`, then `None` is returned.
                #[inline]
                fn to_u32(&self) -> Option<u32> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u32)
                }

                /// Converts the value of `self` to a `u64`. If the value cannot be
                /// represented by a `u64`, then `None` is returned.
                fn to_u64(&self) -> Option<u64>;

                /// Converts the value of `self` to a `u128`. If the value cannot be
                /// represented by a `u128` (`u64` under the default implementation), then
                /// `None` is returned.
                ///
                /// The default implementation converts through `to_u64()`. Types implementing
                /// this trait should override this method if they can represent a greater range.
                #[inline]
                fn to_u128(&self) -> Option<u128> {
                    self.to_u64().map(From::from)
                }

                /// Converts the value of `self` to an `f32`. Overflows may map to positive
                /// or negative inifinity, otherwise `None` is returned if the value cannot
                /// be represented by an `f32`.
                #[inline]
                fn to_f32(&self) -> Option<f32> {
                    self.to_f64().as_ref().and_then(ToPrimitive::to_f32)
                }

                /// Converts the value of `self` to an `f64`. Overflows may map to positive
                /// or negative inifinity, otherwise `None` is returned if the value cannot
                /// be represented by an `f64`.
                ///
                /// The default implementation tries to convert through `to_i64()`, and
                /// failing that through `to_u64()`. Types implementing this trait should
                /// override this method if they can represent a greater range.
                #[inline]
                fn to_f64(&self) -> Option<f64> {
                    match self.to_i64() {
                        Some(i) => i.to_f64(),
                        None => self.to_u64().as_ref().and_then(ToPrimitive::to_f64),
                    }
                }
            }

            macro_rules! impl_to_primitive_int_to_int {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        let min = $DstT::MIN as $SrcT;
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_int_to_uint {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_int {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_int_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_int_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline]
                        fn to_f32(&self) -> Option<f32> {
                            Some(*self as f32)
                        }
                        #[inline]
                        fn to_f64(&self) -> Option<f64> {
                            Some(*self as f64)
                        }
                    }
                };
            }

            impl_to_primitive_int!(isize);
            impl_to_primitive_int!(i8);
            impl_to_primitive_int!(i16);
            impl_to_primitive_int!(i32);
            impl_to_primitive_int!(i64);
            impl_to_primitive_int!(i128);

            macro_rules! impl_to_primitive_uint_to_int {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_uint_to_uint {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_uint {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_uint_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_uint_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline]
                        fn to_f32(&self) -> Option<f32> {
                            Some(*self as f32)
                        }
                        #[inline]
                        fn to_f64(&self) -> Option<f64> {
                            Some(*self as f64)
                        }
                    }
                };
            }

            impl_to_primitive_uint!(usize);
            impl_to_primitive_uint!(u8);
            impl_to_primitive_uint!(u16);
            impl_to_primitive_uint!(u32);
            impl_to_primitive_uint!(u64);
            impl_to_primitive_uint!(u128);

            macro_rules! impl_to_primitive_nonzero_to_method {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        self.get().$method()
                    }
                )*}
            }

            macro_rules! impl_to_primitive_nonzero {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_nonzero_to_method! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;

                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;

                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }

            impl_to_primitive_nonzero!(NonZeroUsize);
            impl_to_primitive_nonzero!(NonZeroU8);
            impl_to_primitive_nonzero!(NonZeroU16);
            impl_to_primitive_nonzero!(NonZeroU32);
            impl_to_primitive_nonzero!(NonZeroU64);
            impl_to_primitive_nonzero!(NonZeroU128);

            impl_to_primitive_nonzero!(NonZeroIsize);
            impl_to_primitive_nonzero!(NonZeroI8);
            impl_to_primitive_nonzero!(NonZeroI16);
            impl_to_primitive_nonzero!(NonZeroI32);
            impl_to_primitive_nonzero!(NonZeroI64);
            impl_to_primitive_nonzero!(NonZeroI128);

            macro_rules! impl_to_primitive_float_to_float {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                       
                       
                        Some(*self as $DstT)
                    }
                )*}
            }

            macro_rules! float_to_int_unchecked {
               
               
                ($float:expr => $int:ty) => {
                    unsafe { $float.to_int_unchecked::<$int>() }
                };
            }

            macro_rules! impl_to_primitive_float_to_signed_int {
                ($f:ident : $( fn $method:ident -> $i:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$i> {
                       
                       
                        if size_of::<$f>() > size_of::<$i>() {
                           
                            const MIN_M1: $f = $i::MIN as $f - 1.0;
                            const MAX_P1: $f = $i::MAX as $f + 1.0;
                            if *self > MIN_M1 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $i));
                            }
                        } else {
                           
                           
                            const MIN: $f = $i::MIN as $f;
                           
                           
                            const MAX_P1: $f = $i::MAX as $f;
                            if *self >= MIN && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $i));
                            }
                        }
                        None
                    }
                )*}
            }

            macro_rules! impl_to_primitive_float_to_unsigned_int {
                ($f:ident : $( fn $method:ident -> $u:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$u> {
                       
                       
                        if size_of::<$f>() > size_of::<$u>() {
                           
                            const MAX_P1: $f = $u::MAX as $f + 1.0;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $u));
                            }
                        } else {
                           
                           
                           
                            const MAX_P1: $f = $u::MAX as $f;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $u));
                            }
                        }
                        None
                    }
                )*}
            }

            macro_rules! impl_to_primitive_float {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_float_to_signed_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_float_to_unsigned_int! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        impl_to_primitive_float_to_float! { $T:
                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }

            impl_to_primitive_float!(f32);
            impl_to_primitive_float!(f64);
            /// A generic trait for converting a number to a value.
            pub trait FromPrimitive: Sized {
                /// Converts an `isize` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_isize(n: isize) -> Option<Self> {
                    n.to_i64().and_then(FromPrimitive::from_i64)
                }

                /// Converts an `i8` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_i8(n: i8) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }

                /// Converts an `i16` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_i16(n: i16) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }

                /// Converts an `i32` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_i32(n: i32) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }

                /// Converts an `i64` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                fn from_i64(n: i64) -> Option<Self>;

                /// Converts an `i128` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                ///
                /// The default implementation converts through `from_i64()`. Types implementing
                /// this trait should override this method if they can represent a greater range.
                #[inline]
                fn from_i128(n: i128) -> Option<Self> {
                    n.to_i64().and_then(FromPrimitive::from_i64)
                }

                /// Converts a `usize` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_usize(n: usize) -> Option<Self> {
                    n.to_u64().and_then(FromPrimitive::from_u64)
                }

                /// Converts an `u8` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_u8(n: u8) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }

                /// Converts an `u16` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_u16(n: u16) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }

                /// Converts an `u32` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_u32(n: u32) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }

                /// Converts an `u64` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                fn from_u64(n: u64) -> Option<Self>;

                /// Converts an `u128` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                ///
                /// The default implementation converts through `from_u64()`. Types implementing
                /// this trait should override this method if they can represent a greater range.
                #[inline]
                fn from_u128(n: u128) -> Option<Self> {
                    n.to_u64().and_then(FromPrimitive::from_u64)
                }

                /// Converts a `f32` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_f32(n: f32) -> Option<Self> {
                    FromPrimitive::from_f64(From::from(n))
                }

                /// Converts a `f64` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                ///
                /// The default implementation tries to convert through `from_i64()`, and
                /// failing that through `from_u64()`. Types implementing this trait should
                /// override this method if they can represent a greater range.
                #[inline]
                fn from_f64(n: f64) -> Option<Self> {
                    match n.to_i64() {
                        Some(i) => FromPrimitive::from_i64(i),
                        None => n.to_u64().and_then(FromPrimitive::from_u64),
                    }
                }
            }

            macro_rules! impl_from_primitive {
                ($T:ty, $to_ty:ident) => {
                    impl FromPrimitive for $T {
                        #[inline]
                        fn from_isize(n: isize) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i8(n: i8) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i16(n: i16) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i32(n: i32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i64(n: i64) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i128(n: i128) -> Option<$T> {
                            n.$to_ty()
                        }

                        #[inline]
                        fn from_usize(n: usize) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u8(n: u8) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u16(n: u16) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u32(n: u32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u64(n: u64) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u128(n: u128) -> Option<$T> {
                            n.$to_ty()
                        }

                        #[inline]
                        fn from_f32(n: f32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_f64(n: f64) -> Option<$T> {
                            n.$to_ty()
                        }
                    }
                };
            }

            impl_from_primitive!(isize, to_isize);
            impl_from_primitive!(i8, to_i8);
            impl_from_primitive!(i16, to_i16);
            impl_from_primitive!(i32, to_i32);
            impl_from_primitive!(i64, to_i64);
            impl_from_primitive!(i128, to_i128);
            impl_from_primitive!(usize, to_usize);
            impl_from_primitive!(u8, to_u8);
            impl_from_primitive!(u16, to_u16);
            impl_from_primitive!(u32, to_u32);
            impl_from_primitive!(u64, to_u64);
            impl_from_primitive!(u128, to_u128);
            impl_from_primitive!(f32, to_f32);
            impl_from_primitive!(f64, to_f64);

            macro_rules! impl_from_primitive_nonzero {
                ($T:ty, $to_ty:ident) => {
                    impl FromPrimitive for $T {
                        #[inline]
                        fn from_isize(n: isize) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i8(n: i8) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i16(n: i16) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i32(n: i32) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i64(n: i64) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i128(n: i128) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }

                        #[inline]
                        fn from_usize(n: usize) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u8(n: u8) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u16(n: u16) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u32(n: u32) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u64(n: u64) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u128(n: u128) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }

                        #[inline]
                        fn from_f32(n: f32) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_f64(n: f64) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                    }
                };
            }

            impl_from_primitive_nonzero!(NonZeroIsize, to_isize);
            impl_from_primitive_nonzero!(NonZeroI8, to_i8);
            impl_from_primitive_nonzero!(NonZeroI16, to_i16);
            impl_from_primitive_nonzero!(NonZeroI32, to_i32);
            impl_from_primitive_nonzero!(NonZeroI64, to_i64);
            impl_from_primitive_nonzero!(NonZeroI128, to_i128);
            impl_from_primitive_nonzero!(NonZeroUsize, to_usize);
            impl_from_primitive_nonzero!(NonZeroU8, to_u8);
            impl_from_primitive_nonzero!(NonZeroU16, to_u16);
            impl_from_primitive_nonzero!(NonZeroU32, to_u32);
            impl_from_primitive_nonzero!(NonZeroU64, to_u64);
            impl_from_primitive_nonzero!(NonZeroU128, to_u128);

            macro_rules! impl_to_primitive_wrapping {
                ($( fn $method:ident -> $i:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$i> {
                        (self.0).$method()
                    }
                )*}
            }

            impl<T: ToPrimitive> ToPrimitive for Wrapping<T> {
                impl_to_primitive_wrapping! {
                    fn to_isize -> isize;
                    fn to_i8 -> i8;
                    fn to_i16 -> i16;
                    fn to_i32 -> i32;
                    fn to_i64 -> i64;
                    fn to_i128 -> i128;

                    fn to_usize -> usize;
                    fn to_u8 -> u8;
                    fn to_u16 -> u16;
                    fn to_u32 -> u32;
                    fn to_u64 -> u64;
                    fn to_u128 -> u128;

                    fn to_f32 -> f32;
                    fn to_f64 -> f64;
                }
            }

            macro_rules! impl_from_primitive_wrapping {
                ($( fn $method:ident ( $i:ident ); )*) => {$(
                    #[inline]
                    fn $method(n: $i) -> Option<Self> {
                        T::$method(n).map(Wrapping)
                    }
                )*}
            }

            impl<T: FromPrimitive> FromPrimitive for Wrapping<T> {
                impl_from_primitive_wrapping! {
                    fn from_isize(isize);
                    fn from_i8(i8);
                    fn from_i16(i16);
                    fn from_i32(i32);
                    fn from_i64(i64);
                    fn from_i128(i128);

                    fn from_usize(usize);
                    fn from_u8(u8);
                    fn from_u16(u16);
                    fn from_u32(u32);
                    fn from_u64(u64);
                    fn from_u128(u128);

                    fn from_f32(f32);
                    fn from_f64(f64);
                }
            }
            /// Cast from one machine scalar to another.
            /// # use num_traits as num;
            /// let twenty: f32 = num::cast(0x14).unwrap();
            /// assert_eq!(twenty, 20f32);
            /// ```
            ///
            #[inline]
            pub fn cast<T: NumCast, U: NumCast>(n: T) -> Option<U> {
                NumCast::from(n)
            }
            /// An interface for casting between machine scalars.
            pub trait NumCast: Sized + ToPrimitive {
                /// Creates a number from another value that can be converted into
                /// a primitive via the `ToPrimitive` trait. If the source value cannot be
                /// represented by the target type, then `None` is returned.
                ///
                /// A value can be represented by the target type when it lies within
                /// the range of scalars supported by the target type.
                /// For example, a negative integer cannot be represented by an unsigned
                /// integer type, and an `i64` with a very high magnitude might not be
                /// convertible to an `i32`.
                /// On the other hand, conversions with possible precision loss or truncation
                /// are admitted, like an `f32` with a decimal part to an integer type, or
                /// even a large `f64` saturating to `f32` infinity.
                fn from<T: ToPrimitive>(n: T) -> Option<Self>;
            }

            macro_rules! impl_num_cast {
                ($T:ty, $conv:ident) => {
                    impl NumCast for $T {
                        #[inline]
                        fn from<N: ToPrimitive>(n: N) -> Option<$T> {
                            n.$conv()
                        }
                    }
                };
            }

            impl_num_cast!(u8, to_u8);
            impl_num_cast!(u16, to_u16);
            impl_num_cast!(u32, to_u32);
            impl_num_cast!(u64, to_u64);
            impl_num_cast!(u128, to_u128);
            impl_num_cast!(usize, to_usize);
            impl_num_cast!(i8, to_i8);
            impl_num_cast!(i16, to_i16);
            impl_num_cast!(i32, to_i32);
            impl_num_cast!(i64, to_i64);
            impl_num_cast!(i128, to_i128);
            impl_num_cast!(isize, to_isize);
            impl_num_cast!(f32, to_f32);
            impl_num_cast!(f64, to_f64);

            macro_rules! impl_num_cast_nonzero {
                ($T:ty, $conv:ident) => {
                    impl NumCast for $T {
                        #[inline]
                        fn from<N: ToPrimitive>(n: N) -> Option<$T> {
                            n.$conv().and_then(Self::new)
                        }
                    }
                };
            }

            impl_num_cast_nonzero!(NonZeroUsize, to_usize);
            impl_num_cast_nonzero!(NonZeroU8, to_u8);
            impl_num_cast_nonzero!(NonZeroU16, to_u16);
            impl_num_cast_nonzero!(NonZeroU32, to_u32);
            impl_num_cast_nonzero!(NonZeroU64, to_u64);
            impl_num_cast_nonzero!(NonZeroU128, to_u128);

            impl_num_cast_nonzero!(NonZeroIsize, to_isize);
            impl_num_cast_nonzero!(NonZeroI8, to_i8);
            impl_num_cast_nonzero!(NonZeroI16, to_i16);
            impl_num_cast_nonzero!(NonZeroI32, to_i32);
            impl_num_cast_nonzero!(NonZeroI64, to_i64);
            impl_num_cast_nonzero!(NonZeroI128, to_i128);

            impl<T: NumCast> NumCast for Wrapping<T> {
                fn from<U: ToPrimitive>(n: U) -> Option<Self> {
                    T::from(n).map(Wrapping)
                }
            }
            /// A generic interface for casting between machine scalars with the
            /// `as` operator, which admits narrowing and precision loss.
            /// Implementers of this trait `AsPrimitive` should behave like a primitive
            /// numeric type (e.g. a newtype around another primitive), and the
            /// intended conversion must never fail.
            /// # use num_traits::AsPrimitive;
            /// let three: i32 = (3.14159265f32).as_();
            /// assert_eq!(three, 3);
            /// ```
            ///
            /// # Safety
            ///
            /// **In Rust versions before 1.45.0**, some uses of the `as` operator were not entirely safe.
            /// In particular, it was undefined behavior if
            /// a truncated floating point value could not fit in the target integer
            /// type ([#10184](https://github.com/rust-lang/rust/issues/10184)).
            /// let x: u8 = (1.04E+17).as_();
            /// ```
            ///
            pub trait AsPrimitive<T>: 'static + Copy
            where
                T: 'static + Copy,
            {
                /// Convert a value to another, using the `as` operator.
                fn as_(self) -> T;
            }

            macro_rules! impl_as_primitive {
                (@ $T: ty =>  impl $U: ty ) => {
                    impl AsPrimitive<$U> for $T {
                        #[inline] fn as_(self) -> $U { self as $U }
                    }
                };
                (@ $T: ty => { $( $U: ty ),* } ) => {$(
                    impl_as_primitive!(@ $T => impl $U);
                )*};
                ($T: ty => { $( $U: ty ),* } ) => {
                    impl_as_primitive!(@ $T => { $( $U ),* });
                    impl_as_primitive!(@ $T => { u8, u16, u32, u64, u128, usize });
                    impl_as_primitive!(@ $T => { i8, i16, i32, i64, i128, isize });
                };
            }

            impl_as_primitive!(u8 => { char, f32, f64 });
            impl_as_primitive!(i8 => { f32, f64 });
            impl_as_primitive!(u16 => { f32, f64 });
            impl_as_primitive!(i16 => { f32, f64 });
            impl_as_primitive!(u32 => { f32, f64 });
            impl_as_primitive!(i32 => { f32, f64 });
            impl_as_primitive!(u64 => { f32, f64 });
            impl_as_primitive!(i64 => { f32, f64 });
            impl_as_primitive!(u128 => { f32, f64 });
            impl_as_primitive!(i128 => { f32, f64 });
            impl_as_primitive!(usize => { f32, f64 });
            impl_as_primitive!(isize => { f32, f64 });
            impl_as_primitive!(f32 => { f32, f64 });
            impl_as_primitive!(f64 => { f32, f64 });
            impl_as_primitive!(char => { char });
            impl_as_primitive!(bool => {});

        } pub use self::cast::{cast, AsPrimitive, FromPrimitive, NumCast, ToPrimitive};

        pub mod float
        {
            use ::
            {
                *,
            };
            /*
                use core::cmp::Ordering;
                use core::num::FpCategory;
                use core::ops::{Add, Div, Neg};

                use core::f32;
                use core::f64;

                use crate::{Num, NumCast, ToPrimitive};
            */
            /// Generic trait for floating point numbers that works with `no_std`.
            ///
            /// This trait implements a subset of the `Float` trait.
            pub trait FloatCore: Num + NumCast + Neg<Output = Self> + PartialOrd + Copy {
                /// Returns positive infinity.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::infinity() == x);
                /// }
                ///
                /// check(f32::INFINITY);
                /// check(f64::INFINITY);
                /// ```
                fn infinity() -> Self;

                /// Returns negative infinity.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::neg_infinity() == x);
                /// }
                ///
                /// check(f32::NEG_INFINITY);
                /// check(f64::NEG_INFINITY);
                /// ```
                fn neg_infinity() -> Self;

                /// Returns NaN.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                ///
                /// fn check<T: FloatCore>() {
                ///     let n = T::nan();
                ///     assert!(n != n);
                /// }
                ///
                /// check::<f32>();
                /// check::<f64>();
                /// ```
                fn nan() -> Self;

                /// Returns `-0.0`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(n: T) {
                ///     let z = T::neg_zero();
                ///     assert!(z.is_zero());
                ///     assert!(T::one() / z == n);
                /// }
                ///
                /// check(f32::NEG_INFINITY);
                /// check(f64::NEG_INFINITY);
                /// ```
                fn neg_zero() -> Self;

                /// Returns the smallest finite value that this type can represent.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::min_value() == x);
                /// }
                ///
                /// check(f32::MIN);
                /// check(f64::MIN);
                /// ```
                fn min_value() -> Self;

                /// Returns the smallest positive, normalized value that this type can represent.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::min_positive_value() == x);
                /// }
                ///
                /// check(f32::MIN_POSITIVE);
                /// check(f64::MIN_POSITIVE);
                /// ```
                fn min_positive_value() -> Self;

                /// Returns epsilon, a small positive value.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::epsilon() == x);
                /// }
                ///
                /// check(f32::EPSILON);
                /// check(f64::EPSILON);
                /// ```
                fn epsilon() -> Self;

                /// Returns the largest finite value that this type can represent.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::max_value() == x);
                /// }
                ///
                /// check(f32::MAX);
                /// check(f64::MAX);
                /// ```
                fn max_value() -> Self;

                /// Returns `true` if the number is NaN.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_nan() == p);
                /// }
                ///
                /// check(f32::NAN, true);
                /// check(f32::INFINITY, false);
                /// check(f64::NAN, true);
                /// check(0.0f64, false);
                /// ```
                #[inline]
                #[allow(clippy::eq_op)]
                fn is_nan(self) -> bool {
                    self != self
                }

                /// Returns `true` if the number is infinite.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_infinite() == p);
                /// }
                ///
                /// check(f32::INFINITY, true);
                /// check(f32::NEG_INFINITY, true);
                /// check(f32::NAN, false);
                /// check(f64::INFINITY, true);
                /// check(f64::NEG_INFINITY, true);
                /// check(0.0f64, false);
                /// ```
                #[inline]
                fn is_infinite(self) -> bool {
                    self == Self::infinity() || self == Self::neg_infinity()
                }

                /// Returns `true` if the number is neither infinite or NaN.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_finite() == p);
                /// }
                ///
                /// check(f32::INFINITY, false);
                /// check(f32::MAX, true);
                /// check(f64::NEG_INFINITY, false);
                /// check(f64::MIN_POSITIVE, true);
                /// check(f64::NAN, false);
                /// ```
                #[inline]
                fn is_finite(self) -> bool {
                    !(self.is_nan() || self.is_infinite())
                }

                /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_normal() == p);
                /// }
                ///
                /// check(f32::INFINITY, false);
                /// check(f32::MAX, true);
                /// check(f64::NEG_INFINITY, false);
                /// check(f64::MIN_POSITIVE, true);
                /// check(0.0f64, false);
                /// ```
                #[inline]
                fn is_normal(self) -> bool {
                    self.classify() == FpCategory::Normal
                }

                /// Returns `true` if the number is [subnormal].
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::f64;
                ///
                /// let min = f64::MIN_POSITIVE;
                /// let max = f64::MAX;
                /// let lower_than_min = 1.0e-308_f64;
                /// let zero = 0.0_f64;
                ///
                /// assert!(!min.is_subnormal());
                /// assert!(!max.is_subnormal());
                ///
                /// assert!(!zero.is_subnormal());
                /// assert!(!f64::NAN.is_subnormal());
                /// assert!(!f64::INFINITY.is_subnormal());
                ///
                /// assert!(lower_than_min.is_subnormal());
                /// ```
                /// [subnormal]: https://en.wikipedia.org/wiki/Subnormal_number
                #[inline]
                fn is_subnormal(self) -> bool {
                    self.classify() == FpCategory::Subnormal
                }

                /// Returns the floating point category of the number. If only one property
                /// is going to be tested, it is generally faster to use the specific
                /// predicate instead.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                /// use std::num::FpCategory;
                ///
                /// fn check<T: FloatCore>(x: T, c: FpCategory) {
                ///     assert!(x.classify() == c);
                /// }
                ///
                /// check(f32::INFINITY, FpCategory::Infinite);
                /// check(f32::MAX, FpCategory::Normal);
                /// check(f64::NAN, FpCategory::Nan);
                /// check(f64::MIN_POSITIVE, FpCategory::Normal);
                /// check(f64::MIN_POSITIVE / 2.0, FpCategory::Subnormal);
                /// check(0.0f64, FpCategory::Zero);
                /// ```
                fn classify(self) -> FpCategory;

                /// Returns the largest integer less than or equal to a number.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.floor() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(0.9f32, 0.0);
                /// check(1.0f32, 1.0);
                /// check(1.1f32, 1.0);
                /// check(-0.0f64, 0.0);
                /// check(-0.9f64, -1.0);
                /// check(-1.0f64, -1.0);
                /// check(-1.1f64, -2.0);
                /// check(f64::MIN, f64::MIN);
                /// ```
                #[inline]
                fn floor(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self < Self::zero() {
                        self - f - Self::one()
                    } else {
                        self - f
                    }
                }

                /// Returns the smallest integer greater than or equal to a number.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.ceil() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(0.9f32, 1.0);
                /// check(1.0f32, 1.0);
                /// check(1.1f32, 2.0);
                /// check(-0.0f64, 0.0);
                /// check(-0.9f64, -0.0);
                /// check(-1.0f64, -1.0);
                /// check(-1.1f64, -1.0);
                /// check(f64::MIN, f64::MIN);
                /// ```
                #[inline]
                fn ceil(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        self - f + Self::one()
                    } else {
                        self - f
                    }
                }

                /// Returns the nearest integer to a number. Round half-way cases away from `0.0`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.round() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(0.4f32, 0.0);
                /// check(0.5f32, 1.0);
                /// check(0.6f32, 1.0);
                /// check(-0.4f64, 0.0);
                /// check(-0.5f64, -1.0);
                /// check(-0.6f64, -1.0);
                /// check(f64::MIN, f64::MIN);
                /// ```
                #[inline]
                fn round(self) -> Self {
                    let one = Self::one();
                    let h = Self::from(0.5).expect("Unable to cast from 0.5");
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        if f < h {
                            self - f
                        } else {
                            self - f + one
                        }
                    } else if -f < h {
                        self - f
                    } else {
                        self - f - one
                    }
                }

                /// Return the integer part of a number.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.trunc() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(0.9f32, 0.0);
                /// check(1.0f32, 1.0);
                /// check(1.1f32, 1.0);
                /// check(-0.0f64, 0.0);
                /// check(-0.9f64, -0.0);
                /// check(-1.0f64, -1.0);
                /// check(-1.1f64, -1.0);
                /// check(f64::MIN, f64::MIN);
                /// ```
                #[inline]
                fn trunc(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() {
                        self
                    } else {
                        self - f
                    }
                }

                /// Returns the fractional part of a number.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.fract() == y);
                /// }
                ///
                /// check(f32::MAX, 0.0);
                /// check(0.75f32, 0.75);
                /// check(1.0f32, 0.0);
                /// check(1.25f32, 0.25);
                /// check(-0.0f64, 0.0);
                /// check(-0.75f64, -0.75);
                /// check(-1.0f64, 0.0);
                /// check(-1.25f64, -0.25);
                /// check(f64::MIN, 0.0);
                /// ```
                #[inline]
                fn fract(self) -> Self {
                    if self.is_zero() {
                        Self::zero()
                    } else {
                        self % Self::one()
                    }
                }

                /// Computes the absolute value of `self`. Returns `FloatCore::nan()` if the
                /// number is `FloatCore::nan()`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.abs() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(1.0f32, 1.0);
                /// check(0.0f64, 0.0);
                /// check(-0.0f64, 0.0);
                /// check(-1.0f64, 1.0);
                /// check(f64::MIN, f64::MAX);
                /// ```
                #[inline]
                fn abs(self) -> Self {
                    if self.is_sign_positive() {
                        return self;
                    }
                    if self.is_sign_negative() {
                        return -self;
                    }
                    Self::nan()
                }

                /// Returns a number that represents the sign of `self`.
                ///
                /// - `1.0` if the number is positive, `+0.0` or `FloatCore::infinity()`
                /// - `-1.0` if the number is negative, `-0.0` or `FloatCore::neg_infinity()`
                /// - `FloatCore::nan()` if the number is `FloatCore::nan()`
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.signum() == y);
                /// }
                ///
                /// check(f32::INFINITY, 1.0);
                /// check(3.0f32, 1.0);
                /// check(0.0f32, 1.0);
                /// check(-0.0f64, -1.0);
                /// check(-3.0f64, -1.0);
                /// check(f64::MIN, -1.0);
                /// ```
                #[inline]
                fn signum(self) -> Self {
                    if self.is_nan() {
                        Self::nan()
                    } else if self.is_sign_negative() {
                        -Self::one()
                    } else {
                        Self::one()
                    }
                }

                /// Returns `true` if `self` is positive, including `+0.0` and
                /// `FloatCore::infinity()`, and `FloatCore::nan()`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_sign_positive() == p);
                /// }
                ///
                /// check(f32::INFINITY, true);
                /// check(f32::MAX, true);
                /// check(0.0f32, true);
                /// check(-0.0f64, false);
                /// check(f64::NEG_INFINITY, false);
                /// check(f64::MIN_POSITIVE, true);
                /// check(f64::NAN, true);
                /// check(-f64::NAN, false);
                /// ```
                #[inline]
                fn is_sign_positive(self) -> bool {
                    !self.is_sign_negative()
                }

                /// Returns `true` if `self` is negative, including `-0.0` and
                /// `FloatCore::neg_infinity()`, and `-FloatCore::nan()`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_sign_negative() == p);
                /// }
                ///
                /// check(f32::INFINITY, false);
                /// check(f32::MAX, false);
                /// check(0.0f32, false);
                /// check(-0.0f64, true);
                /// check(f64::NEG_INFINITY, true);
                /// check(f64::MIN_POSITIVE, false);
                /// check(f64::NAN, false);
                /// check(-f64::NAN, true);
                /// ```
                #[inline]
                fn is_sign_negative(self) -> bool {
                    let (_, _, sign) = self.integer_decode();
                    sign < 0
                }

                /// Returns the minimum of the two numbers.
                ///
                /// If one of the arguments is NaN, then the other argument is returned.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T, min: T) {
                ///     assert!(x.min(y) == min);
                /// }
                ///
                /// check(1.0f32, 2.0, 1.0);
                /// check(f32::NAN, 2.0, 2.0);
                /// check(1.0f64, -2.0, -2.0);
                /// check(1.0f64, f64::NAN, 1.0);
                /// ```
                #[inline]
                fn min(self, other: Self) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self < other {
                        self
                    } else {
                        other
                    }
                }

                /// Returns the maximum of the two numbers.
                ///
                /// If one of the arguments is NaN, then the other argument is returned.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T, max: T) {
                ///     assert!(x.max(y) == max);
                /// }
                ///
                /// check(1.0f32, 2.0, 2.0);
                /// check(1.0f32, f32::NAN, 1.0);
                /// check(-1.0f64, 2.0, 2.0);
                /// check(-1.0f64, f64::NAN, -1.0);
                /// ```
                #[inline]
                fn max(self, other: Self) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self > other {
                        self
                    } else {
                        other
                    }
                }

                /// A value bounded by a minimum and a maximum
                ///
                ///  If input is less than min then this returns min.
                ///  If input is greater than max then this returns max.
                ///  Otherwise this returns input.
                ///
                /// **Panics** in debug mode if `!(min <= max)`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                ///
                /// fn check<T: FloatCore>(val: T, min: T, max: T, expected: T) {
                ///     assert!(val.clamp(min, max) == expected);
                /// }
                ///
                ///
                /// check(1.0f32, 0.0, 2.0, 1.0);
                /// check(1.0f32, 2.0, 3.0, 2.0);
                /// check(3.0f32, 0.0, 2.0, 2.0);
                ///
                /// check(1.0f64, 0.0, 2.0, 1.0);
                /// check(1.0f64, 2.0, 3.0, 2.0);
                /// check(3.0f64, 0.0, 2.0, 2.0);
                /// ```
                fn clamp(self, min: Self, max: Self) -> Self {
                    crate::clamp(self, min, max)
                }

                /// Returns the reciprocal (multiplicative inverse) of the number.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.recip() == y);
                ///     assert!(y.recip() == x);
                /// }
                ///
                /// check(f32::INFINITY, 0.0);
                /// check(2.0f32, 0.5);
                /// check(-0.25f64, -4.0);
                /// check(-0.0f64, f64::NEG_INFINITY);
                /// ```
                #[inline]
                fn recip(self) -> Self {
                    Self::one() / self
                }

                /// Raise a number to an integer power.
                ///
                /// Using this function is generally faster than using `powf`
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                ///
                /// fn check<T: FloatCore>(x: T, exp: i32, powi: T) {
                ///     assert!(x.powi(exp) == powi);
                /// }
                ///
                /// check(9.0f32, 2, 81.0);
                /// check(1.0f32, -2, 1.0);
                /// check(10.0f64, 20, 1e20);
                /// check(4.0f64, -2, 0.0625);
                /// check(-1.0f64, std::i32::MIN, 1.0);
                /// ```
                #[inline]
                fn powi(mut self, mut exp: i32) -> Self {
                    if exp < 0 {
                        exp = exp.wrapping_neg();
                        self = self.recip();
                    }
                   
                   
                   
                    super::pow(self, (exp as u32).to_usize().unwrap())
                }

                /// Converts to degrees, assuming the number is in radians.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(rad: T, deg: T) {
                ///     assert!(rad.to_degrees() == deg);
                /// }
                ///
                /// check(0.0f32, 0.0);
                /// check(f32::consts::PI, 180.0);
                /// check(f64::consts::FRAC_PI_4, 45.0);
                /// check(f64::INFINITY, f64::INFINITY);
                /// ```
                fn to_degrees(self) -> Self;

                /// Converts to radians, assuming the number is in degrees.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(deg: T, rad: T) {
                ///     assert!(deg.to_radians() == rad);
                /// }
                ///
                /// check(0.0f32, 0.0);
                /// check(180.0, f32::consts::PI);
                /// check(45.0, f64::consts::FRAC_PI_4);
                /// check(f64::INFINITY, f64::INFINITY);
                /// ```
                fn to_radians(self) -> Self;

                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use std::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, m: u64, e: i16, s:i8) {
                ///     let (mantissa, exponent, sign) = x.integer_decode();
                ///     assert_eq!(mantissa, m);
                ///     assert_eq!(exponent, e);
                ///     assert_eq!(sign, s);
                /// }
                ///
                /// check(2.0f32, 1 << 23, -22, 1);
                /// check(-2.0f32, 1 << 23, -22, -1);
                /// check(f32::INFINITY, 1 << 23, 105, 1);
                /// check(f64::NEG_INFINITY, 1 << 52, 972, -1);
                /// ```
                fn integer_decode(self) -> (u64, i16, i8);
            }

            impl FloatCore for f32 {
                constant! {
                    infinity() -> f32::INFINITY;
                    neg_infinity() -> f32::NEG_INFINITY;
                    nan() -> f32::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f32::MIN;
                    min_positive_value() -> f32::MIN_POSITIVE;
                    epsilon() -> f32::EPSILON;
                    max_value() -> f32::MAX;
                }

                #[inline]
                fn integer_decode(self) -> (u64, i16, i8) {
                    integer_decode_f32(self)
                }

                forward! {
                    Self::is_nan(self) -> bool;
                    Self::is_infinite(self) -> bool;
                    Self::is_finite(self) -> bool;
                    Self::is_normal(self) -> bool;
                    Self::is_subnormal(self) -> bool;
                    Self::clamp(self, min: Self, max: Self) -> Self;
                    Self::classify(self) -> FpCategory;
                    Self::is_sign_positive(self) -> bool;
                    Self::is_sign_negative(self) -> bool;
                    Self::min(self, other: Self) -> Self;
                    Self::max(self, other: Self) -> Self;
                    Self::recip(self) -> Self;
                    Self::to_degrees(self) -> Self;
                    Self::to_radians(self) -> Self;
                }

                #[cfg(feature = "std")]
                forward! {
                    Self::floor(self) -> Self;
                    Self::ceil(self) -> Self;
                    Self::round(self) -> Self;
                    Self::trunc(self) -> Self;
                    Self::fract(self) -> Self;
                    Self::abs(self) -> Self;
                    Self::signum(self) -> Self;
                    Self::powi(self, n: i32) -> Self;
                }

                #[cfg(all(not(feature = "std"), feature = "libm"))]
                forward! {
                    libm::floorf as floor(self) -> Self;
                    libm::ceilf as ceil(self) -> Self;
                    libm::roundf as round(self) -> Self;
                    libm::truncf as trunc(self) -> Self;
                    libm::fabsf as abs(self) -> Self;
                }

                #[cfg(all(not(feature = "std"), feature = "libm"))]
                #[inline]
                fn fract(self) -> Self {
                    self - libm::truncf(self)
                }
            }

            impl FloatCore for f64 {
                constant! {
                    infinity() -> f64::INFINITY;
                    neg_infinity() -> f64::NEG_INFINITY;
                    nan() -> f64::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f64::MIN;
                    min_positive_value() -> f64::MIN_POSITIVE;
                    epsilon() -> f64::EPSILON;
                    max_value() -> f64::MAX;
                }

                #[inline]
                fn integer_decode(self) -> (u64, i16, i8) {
                    integer_decode_f64(self)
                }

                forward! {
                    Self::is_nan(self) -> bool;
                    Self::is_infinite(self) -> bool;
                    Self::is_finite(self) -> bool;
                    Self::is_normal(self) -> bool;
                    Self::is_subnormal(self) -> bool;
                    Self::clamp(self, min: Self, max: Self) -> Self;
                    Self::classify(self) -> FpCategory;
                    Self::is_sign_positive(self) -> bool;
                    Self::is_sign_negative(self) -> bool;
                    Self::min(self, other: Self) -> Self;
                    Self::max(self, other: Self) -> Self;
                    Self::recip(self) -> Self;
                    Self::to_degrees(self) -> Self;
                    Self::to_radians(self) -> Self;
                }

                #[cfg(feature = "std")]
                forward! {
                    Self::floor(self) -> Self;
                    Self::ceil(self) -> Self;
                    Self::round(self) -> Self;
                    Self::trunc(self) -> Self;
                    Self::fract(self) -> Self;
                    Self::abs(self) -> Self;
                    Self::signum(self) -> Self;
                    Self::powi(self, n: i32) -> Self;
                }

                #[cfg(all(not(feature = "std"), feature = "libm"))]
                forward! {
                    libm::floor as floor(self) -> Self;
                    libm::ceil as ceil(self) -> Self;
                    libm::round as round(self) -> Self;
                    libm::trunc as trunc(self) -> Self;
                    libm::fabs as abs(self) -> Self;
                }

                #[cfg(all(not(feature = "std"), feature = "libm"))]
                #[inline]
                fn fract(self) -> Self {
                    self - libm::trunc(self)
                }
            }

           
           

            /// Generic trait for floating point numbers
            ///
            /// This trait is only available with the `std` feature, or with the `libm` feature otherwise.
            #[cfg(any(feature = "std", feature = "libm"))]
            pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {
                /// Returns the `NaN` value.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let nan: f32 = Float::nan();
                ///
                /// assert!(nan.is_nan());
                /// ```
                fn nan() -> Self;
                /// Returns the infinite value.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f32;
                ///
                /// let infinity: f32 = Float::infinity();
                ///
                /// assert!(infinity.is_infinite());
                /// assert!(!infinity.is_finite());
                /// assert!(infinity > f32::MAX);
                /// ```
                fn infinity() -> Self;
                /// Returns the negative infinite value.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f32;
                ///
                /// let neg_infinity: f32 = Float::neg_infinity();
                ///
                /// assert!(neg_infinity.is_infinite());
                /// assert!(!neg_infinity.is_finite());
                /// assert!(neg_infinity < f32::MIN);
                /// ```
                fn neg_infinity() -> Self;
                /// Returns `-0.0`.
                ///
                /// ```
                /// use num_traits::{Zero, Float};
                ///
                /// let inf: f32 = Float::infinity();
                /// let zero: f32 = Zero::zero();
                /// let neg_zero: f32 = Float::neg_zero();
                ///
                /// assert_eq!(zero, neg_zero);
                /// assert_eq!(7.0f32/inf, zero);
                /// assert_eq!(zero * 10.0, zero);
                /// ```
                fn neg_zero() -> Self;

                /// Returns the smallest finite value that this type can represent.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x: f64 = Float::min_value();
                ///
                /// assert_eq!(x, f64::MIN);
                /// ```
                fn min_value() -> Self;

                /// Returns the smallest positive, normalized value that this type can represent.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x: f64 = Float::min_positive_value();
                ///
                /// assert_eq!(x, f64::MIN_POSITIVE);
                /// ```
                fn min_positive_value() -> Self;

                /// Returns epsilon, a small positive value.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x: f64 = Float::epsilon();
                ///
                /// assert_eq!(x, f64::EPSILON);
                /// ```
                ///
                /// # Panics
                ///
                /// The default implementation will panic if `f32::EPSILON` cannot
                /// be cast to `Self`.
                fn epsilon() -> Self {
                    Self::from(f32::EPSILON).expect("Unable to cast from f32::EPSILON")
                }

                /// Returns the largest finite value that this type can represent.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x: f64 = Float::max_value();
                /// assert_eq!(x, f64::MAX);
                /// ```
                fn max_value() -> Self;

                /// Returns `true` if this value is `NaN` and false otherwise.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let nan = f64::NAN;
                /// let f = 7.0;
                ///
                /// assert!(nan.is_nan());
                /// assert!(!f.is_nan());
                /// ```
                fn is_nan(self) -> bool;

                /// Returns `true` if this value is positive infinity or negative infinity and
                /// false otherwise.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f32;
                ///
                /// let f = 7.0f32;
                /// let inf: f32 = Float::infinity();
                /// let neg_inf: f32 = Float::neg_infinity();
                /// let nan: f32 = f32::NAN;
                ///
                /// assert!(!f.is_infinite());
                /// assert!(!nan.is_infinite());
                ///
                /// assert!(inf.is_infinite());
                /// assert!(neg_inf.is_infinite());
                /// ```
                fn is_infinite(self) -> bool;

                /// Returns `true` if this number is neither infinite nor `NaN`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f32;
                ///
                /// let f = 7.0f32;
                /// let inf: f32 = Float::infinity();
                /// let neg_inf: f32 = Float::neg_infinity();
                /// let nan: f32 = f32::NAN;
                ///
                /// assert!(f.is_finite());
                ///
                /// assert!(!nan.is_finite());
                /// assert!(!inf.is_finite());
                /// assert!(!neg_inf.is_finite());
                /// ```
                fn is_finite(self) -> bool;

                /// Returns `true` if the number is neither zero, infinite,
                /// [subnormal][subnormal], or `NaN`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f32;
                ///
                /// let min = f32::MIN_POSITIVE;
                /// let max = f32::MAX;
                /// let lower_than_min = 1.0e-40_f32;
                /// let zero = 0.0f32;
                ///
                /// assert!(min.is_normal());
                /// assert!(max.is_normal());
                ///
                /// assert!(!zero.is_normal());
                /// assert!(!f32::NAN.is_normal());
                /// assert!(!f32::INFINITY.is_normal());
                ///
                /// assert!(!lower_than_min.is_normal());
                /// ```
                /// [subnormal]: http://en.wikipedia.org/wiki/Subnormal_number
                fn is_normal(self) -> bool;

                /// Returns `true` if the number is [subnormal].
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let min = f64::MIN_POSITIVE;
                /// let max = f64::MAX;
                /// let lower_than_min = 1.0e-308_f64;
                /// let zero = 0.0_f64;
                ///
                /// assert!(!min.is_subnormal());
                /// assert!(!max.is_subnormal());
                ///
                /// assert!(!zero.is_subnormal());
                /// assert!(!f64::NAN.is_subnormal());
                /// assert!(!f64::INFINITY.is_subnormal());
                ///
                /// assert!(lower_than_min.is_subnormal());
                /// ```
                /// [subnormal]: https://en.wikipedia.org/wiki/Subnormal_number
                #[inline]
                fn is_subnormal(self) -> bool {
                    self.classify() == FpCategory::Subnormal
                }

                /// Returns the floating point category of the number. If only one property
                /// is going to be tested, it is generally faster to use the specific
                /// predicate instead.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::num::FpCategory;
                /// use std::f32;
                ///
                /// let num = 12.4f32;
                /// let inf = f32::INFINITY;
                ///
                /// assert_eq!(num.classify(), FpCategory::Normal);
                /// assert_eq!(inf.classify(), FpCategory::Infinite);
                /// ```
                fn classify(self) -> FpCategory;

                /// Returns the largest integer less than or equal to a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 3.99;
                /// let g = 3.0;
                ///
                /// assert_eq!(f.floor(), 3.0);
                /// assert_eq!(g.floor(), 3.0);
                /// ```
                fn floor(self) -> Self;

                /// Returns the smallest integer greater than or equal to a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 3.01;
                /// let g = 4.0;
                ///
                /// assert_eq!(f.ceil(), 4.0);
                /// assert_eq!(g.ceil(), 4.0);
                /// ```
                fn ceil(self) -> Self;

                /// Returns the nearest integer to a number. Round half-way cases away from
                /// `0.0`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 3.3;
                /// let g = -3.3;
                ///
                /// assert_eq!(f.round(), 3.0);
                /// assert_eq!(g.round(), -3.0);
                /// ```
                fn round(self) -> Self;

                /// Return the integer part of a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 3.3;
                /// let g = -3.7;
                ///
                /// assert_eq!(f.trunc(), 3.0);
                /// assert_eq!(g.trunc(), -3.0);
                /// ```
                fn trunc(self) -> Self;

                /// Returns the fractional part of a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 3.5;
                /// let y = -3.5;
                /// let abs_difference_x = (x.fract() - 0.5).abs();
                /// let abs_difference_y = (y.fract() - (-0.5)).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                /// ```
                fn fract(self) -> Self;

                /// Computes the absolute value of `self`. Returns `Float::nan()` if the
                /// number is `Float::nan()`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x = 3.5;
                /// let y = -3.5;
                ///
                /// let abs_difference_x = (x.abs() - x).abs();
                /// let abs_difference_y = (y.abs() - (-y)).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                ///
                /// assert!(f64::NAN.abs().is_nan());
                /// ```
                fn abs(self) -> Self;

                /// Returns a number that represents the sign of `self`.
                ///
                /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`
                /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`
                /// - `Float::nan()` if the number is `Float::nan()`
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let f = 3.5;
                ///
                /// assert_eq!(f.signum(), 1.0);
                /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);
                ///
                /// assert!(f64::NAN.signum().is_nan());
                /// ```
                fn signum(self) -> Self;

                /// Returns `true` if `self` is positive, including `+0.0`,
                /// `Float::infinity()`, and `Float::nan()`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let nan: f64 = f64::NAN;
                /// let neg_nan: f64 = -f64::NAN;
                ///
                /// let f = 7.0;
                /// let g = -7.0;
                ///
                /// assert!(f.is_sign_positive());
                /// assert!(!g.is_sign_positive());
                /// assert!(nan.is_sign_positive());
                /// assert!(!neg_nan.is_sign_positive());
                /// ```
                fn is_sign_positive(self) -> bool;

                /// Returns `true` if `self` is negative, including `-0.0`,
                /// `Float::neg_infinity()`, and `-Float::nan()`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let nan: f64 = f64::NAN;
                /// let neg_nan: f64 = -f64::NAN;
                ///
                /// let f = 7.0;
                /// let g = -7.0;
                ///
                /// assert!(!f.is_sign_negative());
                /// assert!(g.is_sign_negative());
                /// assert!(!nan.is_sign_negative());
                /// assert!(neg_nan.is_sign_negative());
                /// ```
                fn is_sign_negative(self) -> bool;

                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                ///
                /// Using `mul_add` can be more performant than an unfused multiply-add if
                /// the target architecture has a dedicated `fma` CPU instruction.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let m = 10.0;
                /// let x = 4.0;
                /// let b = 60.0;
                ///
                ///
                /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn mul_add(self, a: Self, b: Self) -> Self;
                /// Take the reciprocal (inverse) of a number, `1/x`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.recip() - (1.0/x)).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn recip(self) -> Self;

                /// Raise a number to an integer power.
                ///
                /// Using this function is generally faster than using `powf`
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.powi(2) - x*x).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn powi(self, n: i32) -> Self;

                /// Raise a number to a floating point power.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.powf(2.0) - x*x).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn powf(self, n: Self) -> Self;

                /// Take the square root of a number.
                ///
                /// Returns NaN if `self` is a negative number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let positive = 4.0;
                /// let negative = -4.0;
                ///
                /// let abs_difference = (positive.sqrt() - 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// assert!(negative.sqrt().is_nan());
                /// ```
                fn sqrt(self) -> Self;

                /// Returns `e^(self)`, (the exponential function).
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let one = 1.0;
                ///
                /// let e = one.exp();
                ///
                ///
                /// let abs_difference = (e.ln() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp(self) -> Self;

                /// Returns `2^(self)`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 2.0;
                ///
                ///
                /// let abs_difference = (f.exp2() - 4.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp2(self) -> Self;

                /// Returns the natural logarithm of the number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let one = 1.0;
                ///
                /// let e = one.exp();
                ///
                ///
                /// let abs_difference = (e.ln() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn ln(self) -> Self;

                /// Returns the logarithm of the number with respect to an arbitrary base.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let ten = 10.0;
                /// let two = 2.0;
                ///
                ///
                /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();
                ///
                ///
                /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();
                ///
                /// assert!(abs_difference_10 < 1e-10);
                /// assert!(abs_difference_2 < 1e-10);
                /// ```
                fn log(self, base: Self) -> Self;

                /// Returns the base 2 logarithm of the number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let two = 2.0;
                ///
                ///
                /// let abs_difference = (two.log2() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn log2(self) -> Self;

                /// Returns the base 10 logarithm of the number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let ten = 10.0;
                ///
                ///
                /// let abs_difference = (ten.log10() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn log10(self) -> Self;

                /// Converts radians to degrees.
                ///
                /// ```
                /// use std::f64::consts;
                ///
                /// let angle = consts::PI;
                ///
                /// let abs_difference = (angle.to_degrees() - 180.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                #[inline]
                fn to_degrees(self) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from(90u8).unwrap();
                    self * ninety / halfpi
                }

                /// Converts degrees to radians.
                ///
                /// ```
                /// use std::f64::consts;
                ///
                /// let angle = 180.0_f64;
                ///
                /// let abs_difference = (angle.to_radians() - consts::PI).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                #[inline]
                fn to_radians(self) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from(90u8).unwrap();
                    self * halfpi / ninety
                }

                /// Returns the maximum of the two numbers.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                ///
                /// assert_eq!(x.max(y), y);
                /// ```
                fn max(self, other: Self) -> Self;

                /// Returns the minimum of the two numbers.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                ///
                /// assert_eq!(x.min(y), x);
                /// ```
                fn min(self, other: Self) -> Self;

                /// Clamps a value between a min and max.
                ///
                /// **Panics** in debug mode if `!(min <= max)`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                /// let z = 3.0;
                ///
                /// assert_eq!(x.clamp(y, z), 2.0);
                /// ```
                fn clamp(self, min: Self, max: Self) -> Self {
                    crate::clamp(self, min, max)
                }

                /// The positive difference of two numbers.
                ///
                /// * If `self <= other`: `0:0`
                /// * Else: `self - other`
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 3.0;
                /// let y = -3.0;
                ///
                /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();
                /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                /// ```
                fn abs_sub(self, other: Self) -> Self;

                /// Take the cubic root of a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 8.0;
                ///
                ///
                /// let abs_difference = (x.cbrt() - 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn cbrt(self) -> Self;

                /// Calculate the length of the hypotenuse of a right-angle triangle given
                /// legs of length `x` and `y`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 2.0;
                /// let y = 3.0;
                ///
                ///
                /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn hypot(self, other: Self) -> Self;

                /// Computes the sine of a number (in radians).
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x = f64::consts::PI/2.0;
                ///
                /// let abs_difference = (x.sin() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn sin(self) -> Self;

                /// Computes the cosine of a number (in radians).
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x = 2.0*f64::consts::PI;
                ///
                /// let abs_difference = (x.cos() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn cos(self) -> Self;

                /// Computes the tangent of a number (in radians).
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x = f64::consts::PI/4.0;
                /// let abs_difference = (x.tan() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-14);
                /// ```
                fn tan(self) -> Self;

                /// Computes the arcsine of a number. Return value is in radians in
                /// the range [-pi/2, pi/2] or NaN if the number is outside the range
                /// [-1, 1].
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let f = f64::consts::PI / 2.0;
                ///
                ///
                /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn asin(self) -> Self;

                /// Computes the arccosine of a number. Return value is in radians in
                /// the range [0, pi] or NaN if the number is outside the range
                /// [-1, 1].
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let f = f64::consts::PI / 4.0;
                ///
                ///
                /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn acos(self) -> Self;

                /// Computes the arctangent of a number. Return value is in radians in the
                /// range [-pi/2, pi/2];
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 1.0;
                ///
                ///
                /// let abs_difference = (f.tan().atan() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn atan(self) -> Self;

                /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).
                ///
                /// * `x = 0`, `y = 0`: `0`
                /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`
                /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`
                /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let pi = f64::consts::PI;
                ///
                ///
                /// let x1 = 3.0;
                /// let y1 = -3.0;
                ///
                ///
                /// let x2 = -3.0;
                /// let y2 = 3.0;
                ///
                /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();
                /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();
                ///
                /// assert!(abs_difference_1 < 1e-10);
                /// assert!(abs_difference_2 < 1e-10);
                /// ```
                fn atan2(self, other: Self) -> Self;

                /// Simultaneously computes the sine and cosine of the number, `x`. Returns
                /// `(sin(x), cos(x))`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x = f64::consts::PI/4.0;
                /// let f = x.sin_cos();
                ///
                /// let abs_difference_0 = (f.0 - x.sin()).abs();
                /// let abs_difference_1 = (f.1 - x.cos()).abs();
                ///
                /// assert!(abs_difference_0 < 1e-10);
                /// assert!(abs_difference_0 < 1e-10);
                /// ```
                fn sin_cos(self) -> (Self, Self);

                /// Returns `e^(self) - 1` in a way that is accurate even if the
                /// number is close to zero.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 7.0;
                ///
                ///
                /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp_m1(self) -> Self;

                /// Returns `ln(1+n)` (natural logarithm) more accurately than if
                /// the operations were performed separately.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let x = f64::consts::E - 1.0;
                ///
                ///
                /// let abs_difference = (x.ln_1p() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn ln_1p(self) -> Self;

                /// Hyperbolic sine function.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                ///
                /// let f = x.sinh();
                ///
                /// let g = (e*e - 1.0)/(2.0*e);
                /// let abs_difference = (f - g).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn sinh(self) -> Self;

                /// Hyperbolic cosine function.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                /// let f = x.cosh();
                ///
                /// let g = (e*e + 1.0)/(2.0*e);
                /// let abs_difference = (f - g).abs();
                ///
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn cosh(self) -> Self;

                /// Hyperbolic tangent function.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                ///
                /// let f = x.tanh();
                ///
                /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));
                /// let abs_difference = (f - g).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn tanh(self) -> Self;

                /// Inverse hyperbolic sine function.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let f = x.sinh().asinh();
                ///
                /// let abs_difference = (f - x).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn asinh(self) -> Self;

                /// Inverse hyperbolic cosine function.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let f = x.cosh().acosh();
                ///
                /// let abs_difference = (f - x).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn acosh(self) -> Self;

                /// Inverse hyperbolic tangent function.
                ///
                /// ```
                /// use num_traits::Float;
                /// use std::f64;
                ///
                /// let e = f64::consts::E;
                /// let f = e.tanh().atanh();
                ///
                /// let abs_difference = (f - e).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn atanh(self) -> Self;

                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let num = 42_f32;
                ///
                ///
                /// let (mantissa, exponent, sign) = Float::integer_decode(num);
                /// let sign_f = sign as f32;
                /// let mantissa_f = mantissa as f32;
                /// let exponent_f = exponent as f32;
                ///
                ///
                /// let abs_difference = (sign_f * mantissa_f * exponent_f.exp2() - num).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn integer_decode(self) -> (u64, i16, i8);

                /// Returns a number composed of the magnitude of `self` and the sign of
                /// `sign`.
                ///
                /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise
                /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of
                /// `sign` is returned.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 3.5_f32;
                ///
                /// assert_eq!(f.copysign(0.42), 3.5_f32);
                /// assert_eq!(f.copysign(-0.42), -3.5_f32);
                /// assert_eq!((-f).copysign(0.42), 3.5_f32);
                /// assert_eq!((-f).copysign(-0.42), -3.5_f32);
                ///
                /// assert!(f32::nan().copysign(1.0).is_nan());
                /// ```
                fn copysign(self, sign: Self) -> Self {
                    if self.is_sign_negative() == sign.is_sign_negative() {
                        self
                    } else {
                        self.neg()
                    }
                }
            }

            #[cfg(feature = "std")]
            macro_rules! float_impl_std {
                ($T:ident $decode:ident) => {
                    impl Float for $T {
                        constant! {
                            nan() -> $T::NAN;
                            infinity() -> $T::INFINITY;
                            neg_infinity() -> $T::NEG_INFINITY;
                            neg_zero() -> -0.0;
                            min_value() -> $T::MIN;
                            min_positive_value() -> $T::MIN_POSITIVE;
                            epsilon() -> $T::EPSILON;
                            max_value() -> $T::MAX;
                        }

                        #[inline]
                        #[allow(deprecated)]
                        fn abs_sub(self, other: Self) -> Self {
                            <$T>::abs_sub(self, other)
                        }

                        #[inline]
                        fn integer_decode(self) -> (u64, i16, i8) {
                            $decode(self)
                        }

                        forward! {
                            Self::is_nan(self) -> bool;
                            Self::is_infinite(self) -> bool;
                            Self::is_finite(self) -> bool;
                            Self::is_normal(self) -> bool;
                            Self::is_subnormal(self) -> bool;
                            Self::classify(self) -> FpCategory;
                            Self::clamp(self, min: Self, max: Self) -> Self;
                            Self::floor(self) -> Self;
                            Self::ceil(self) -> Self;
                            Self::round(self) -> Self;
                            Self::trunc(self) -> Self;
                            Self::fract(self) -> Self;
                            Self::abs(self) -> Self;
                            Self::signum(self) -> Self;
                            Self::is_sign_positive(self) -> bool;
                            Self::is_sign_negative(self) -> bool;
                            Self::mul_add(self, a: Self, b: Self) -> Self;
                            Self::recip(self) -> Self;
                            Self::powi(self, n: i32) -> Self;
                            Self::powf(self, n: Self) -> Self;
                            Self::sqrt(self) -> Self;
                            Self::exp(self) -> Self;
                            Self::exp2(self) -> Self;
                            Self::ln(self) -> Self;
                            Self::log(self, base: Self) -> Self;
                            Self::log2(self) -> Self;
                            Self::log10(self) -> Self;
                            Self::to_degrees(self) -> Self;
                            Self::to_radians(self) -> Self;
                            Self::max(self, other: Self) -> Self;
                            Self::min(self, other: Self) -> Self;
                            Self::cbrt(self) -> Self;
                            Self::hypot(self, other: Self) -> Self;
                            Self::sin(self) -> Self;
                            Self::cos(self) -> Self;
                            Self::tan(self) -> Self;
                            Self::asin(self) -> Self;
                            Self::acos(self) -> Self;
                            Self::atan(self) -> Self;
                            Self::atan2(self, other: Self) -> Self;
                            Self::sin_cos(self) -> (Self, Self);
                            Self::exp_m1(self) -> Self;
                            Self::ln_1p(self) -> Self;
                            Self::sinh(self) -> Self;
                            Self::cosh(self) -> Self;
                            Self::tanh(self) -> Self;
                            Self::asinh(self) -> Self;
                            Self::acosh(self) -> Self;
                            Self::atanh(self) -> Self;
                            Self::copysign(self, sign: Self) -> Self;
                        }
                    }
                };
            }

            #[cfg(all(not(feature = "std"), feature = "libm"))]
            macro_rules! float_impl_libm {
                ($T:ident $decode:ident) => {
                    constant! {
                        nan() -> $T::NAN;
                        infinity() -> $T::INFINITY;
                        neg_infinity() -> $T::NEG_INFINITY;
                        neg_zero() -> -0.0;
                        min_value() -> $T::MIN;
                        min_positive_value() -> $T::MIN_POSITIVE;
                        epsilon() -> $T::EPSILON;
                        max_value() -> $T::MAX;
                    }

                    #[inline]
                    fn integer_decode(self) -> (u64, i16, i8) {
                        $decode(self)
                    }

                    #[inline]
                    fn fract(self) -> Self {
                        self - Float::trunc(self)
                    }

                    #[inline]
                    fn log(self, base: Self) -> Self {
                        self.ln() / base.ln()
                    }

                    forward! {
                        Self::is_nan(self) -> bool;
                        Self::is_infinite(self) -> bool;
                        Self::is_finite(self) -> bool;
                        Self::is_normal(self) -> bool;
                        Self::is_subnormal(self) -> bool;
                        Self::clamp(self, min: Self, max: Self) -> Self;
                        Self::classify(self) -> FpCategory;
                        Self::is_sign_positive(self) -> bool;
                        Self::is_sign_negative(self) -> bool;
                        Self::min(self, other: Self) -> Self;
                        Self::max(self, other: Self) -> Self;
                        Self::recip(self) -> Self;
                        Self::to_degrees(self) -> Self;
                        Self::to_radians(self) -> Self;
                    }

                    forward! {
                        FloatCore::signum(self) -> Self;
                        FloatCore::powi(self, n: i32) -> Self;
                    }
                };
            }

            fn integer_decode_f32(f: f32) -> (u64, i16, i8) {
                let bits: u32 = f.to_bits();
                let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;
                let mantissa = if exponent == 0 {
                    (bits & 0x7fffff) << 1
                } else {
                    (bits & 0x7fffff) | 0x800000
                };
               
                exponent -= 127 + 23;
                (mantissa as u64, exponent, sign)
            }

            fn integer_decode_f64(f: f64) -> (u64, i16, i8) {
                let bits: u64 = f.to_bits();
                let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;
                let mantissa = if exponent == 0 {
                    (bits & 0xfffffffffffff) << 1
                } else {
                    (bits & 0xfffffffffffff) | 0x10000000000000
                };
               
                exponent -= 1023 + 52;
                (mantissa, exponent, sign)
            }

            #[cfg(feature = "std")]
            float_impl_std!(f32 integer_decode_f32);
            #[cfg(feature = "std")]
            float_impl_std!(f64 integer_decode_f64);

            #[cfg(all(not(feature = "std"), feature = "libm"))]
            impl Float for f32 {
                float_impl_libm!(f32 integer_decode_f32);

                #[inline]
                #[allow(deprecated)]
                fn abs_sub(self, other: Self) -> Self {
                    libm::fdimf(self, other)
                }

                forward! {
                    libm::floorf as floor(self) -> Self;
                    libm::ceilf as ceil(self) -> Self;
                    libm::roundf as round(self) -> Self;
                    libm::truncf as trunc(self) -> Self;
                    libm::fabsf as abs(self) -> Self;
                    libm::fmaf as mul_add(self, a: Self, b: Self) -> Self;
                    libm::powf as powf(self, n: Self) -> Self;
                    libm::sqrtf as sqrt(self) -> Self;
                    libm::expf as exp(self) -> Self;
                    libm::exp2f as exp2(self) -> Self;
                    libm::logf as ln(self) -> Self;
                    libm::log2f as log2(self) -> Self;
                    libm::log10f as log10(self) -> Self;
                    libm::cbrtf as cbrt(self) -> Self;
                    libm::hypotf as hypot(self, other: Self) -> Self;
                    libm::sinf as sin(self) -> Self;
                    libm::cosf as cos(self) -> Self;
                    libm::tanf as tan(self) -> Self;
                    libm::asinf as asin(self) -> Self;
                    libm::acosf as acos(self) -> Self;
                    libm::atanf as atan(self) -> Self;
                    libm::atan2f as atan2(self, other: Self) -> Self;
                    libm::sincosf as sin_cos(self) -> (Self, Self);
                    libm::expm1f as exp_m1(self) -> Self;
                    libm::log1pf as ln_1p(self) -> Self;
                    libm::sinhf as sinh(self) -> Self;
                    libm::coshf as cosh(self) -> Self;
                    libm::tanhf as tanh(self) -> Self;
                    libm::asinhf as asinh(self) -> Self;
                    libm::acoshf as acosh(self) -> Self;
                    libm::atanhf as atanh(self) -> Self;
                    libm::copysignf as copysign(self, other: Self) -> Self;
                }
            }

            #[cfg(all(not(feature = "std"), feature = "libm"))]
            impl Float for f64 {
                float_impl_libm!(f64 integer_decode_f64);

                #[inline]
                #[allow(deprecated)]
                fn abs_sub(self, other: Self) -> Self {
                    libm::fdim(self, other)
                }

                forward! {
                    libm::floor as floor(self) -> Self;
                    libm::ceil as ceil(self) -> Self;
                    libm::round as round(self) -> Self;
                    libm::trunc as trunc(self) -> Self;
                    libm::fabs as abs(self) -> Self;
                    libm::fma as mul_add(self, a: Self, b: Self) -> Self;
                    libm::pow as powf(self, n: Self) -> Self;
                    libm::sqrt as sqrt(self) -> Self;
                    libm::exp as exp(self) -> Self;
                    libm::exp2 as exp2(self) -> Self;
                    libm::log as ln(self) -> Self;
                    libm::log2 as log2(self) -> Self;
                    libm::log10 as log10(self) -> Self;
                    libm::cbrt as cbrt(self) -> Self;
                    libm::hypot as hypot(self, other: Self) -> Self;
                    libm::sin as sin(self) -> Self;
                    libm::cos as cos(self) -> Self;
                    libm::tan as tan(self) -> Self;
                    libm::asin as asin(self) -> Self;
                    libm::acos as acos(self) -> Self;
                    libm::atan as atan(self) -> Self;
                    libm::atan2 as atan2(self, other: Self) -> Self;
                    libm::sincos as sin_cos(self) -> (Self, Self);
                    libm::expm1 as exp_m1(self) -> Self;
                    libm::log1p as ln_1p(self) -> Self;
                    libm::sinh as sinh(self) -> Self;
                    libm::cosh as cosh(self) -> Self;
                    libm::tanh as tanh(self) -> Self;
                    libm::asinh as asinh(self) -> Self;
                    libm::acosh as acosh(self) -> Self;
                    libm::atanh as atanh(self) -> Self;
                    libm::copysign as copysign(self, sign: Self) -> Self;
                }
            }

            macro_rules! float_const_impl {
                ($(#[$doc:meta] $constant:ident,)+) => (
                    #[allow(non_snake_case)]
                    pub trait FloatConst {
                        $(#[$doc] fn $constant() -> Self;)+
                        #[doc = "Return the full circle constant `τ`."]
                        #[inline]
                        fn TAU() -> Self where Self: Sized + Add<Self, Output = Self> {
                            Self::PI() + Self::PI()
                        }
                        #[doc = "Return `log10(2.0)`."]
                        #[inline]
                        fn LOG10_2() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_2() / Self::LN_10()
                        }
                        #[doc = "Return `log2(10.0)`."]
                        #[inline]
                        fn LOG2_10() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_10() / Self::LN_2()
                        }
                    }
                    float_const_impl! { @float f32, $($constant,)+ }
                    float_const_impl! { @float f64, $($constant,)+ }
                );
                (@float $T:ident, $($constant:ident,)+) => (
                    impl FloatConst for $T {
                        constant! {
                            $( $constant() -> $T::consts::$constant; )+
                            TAU() -> 6.28318530717958647692528676655900577;
                            LOG10_2() -> 0.301029995663981195213738894724493027;
                            LOG2_10() -> 3.32192809488736234787031942948939018;
                        }
                    }
                );
            }

            float_const_impl! {
                #[doc = "Return Euler’s number."]
                E,
                #[doc = "Return `1.0 / π`."]
                FRAC_1_PI,
                #[doc = "Return `1.0 / sqrt(2.0)`."]
                FRAC_1_SQRT_2,
                #[doc = "Return `2.0 / π`."]
                FRAC_2_PI,
                #[doc = "Return `2.0 / sqrt(π)`."]
                FRAC_2_SQRT_PI,
                #[doc = "Return `π / 2.0`."]
                FRAC_PI_2,
                #[doc = "Return `π / 3.0`."]
                FRAC_PI_3,
                #[doc = "Return `π / 4.0`."]
                FRAC_PI_4,
                #[doc = "Return `π / 6.0`."]
                FRAC_PI_6,
                #[doc = "Return `π / 8.0`."]
                FRAC_PI_8,
                #[doc = "Return `ln(10.0)`."]
                LN_10,
                #[doc = "Return `ln(2.0)`."]
                LN_2,
                #[doc = "Return `log10(e)`."]
                LOG10_E,
                #[doc = "Return `log2(e)`."]
                LOG2_E,
                #[doc = "Return Archimedes’ constant `π`."]
                PI,
                #[doc = "Return `sqrt(2.0)`."]
                SQRT_2,
            }
            /// Trait for floating point numbers that provide an implementation
            /// of the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)
            /// floating point standard.
            pub trait TotalOrder {
                /// Return the ordering between `self` and `other`.
                ///
                /// Unlike the standard partial comparison between floating point numbers,
                /// this comparison always produces an ordering in accordance to
                /// the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)
                /// floating point standard. The values are ordered in the following sequence:
                ///
                /// - negative quiet NaN
                /// - negative signaling NaN
                /// - negative infinity
                /// - negative numbers
                /// - negative subnormal numbers
                /// - negative zero
                /// - positive zero
                /// - positive subnormal numbers
                /// - positive numbers
                /// - positive infinity
                /// - positive signaling NaN
                /// - positive quiet NaN.
                ///
                /// The ordering established by this function does not always agree with the
                /// [`PartialOrd`] and [`PartialEq`] implementations. For example,
                /// they consider negative and positive zero equal, while `total_cmp`
                /// doesn't.
                ///
                /// The interpretation of the signaling NaN bit follows the definition in
                /// the IEEE 754 standard, which may not match the interpretation by some of
                /// the older, non-conformant (e.g. MIPS) hardware implementations.
                ///
                /// # Examples
                /// ```
                /// use num_traits::float::TotalOrder;
                /// use std::cmp::Ordering;
                /// use std::{f32, f64};
                ///
                /// fn check_eq<T: TotalOrder>(x: T, y: T) {
                ///     assert_eq!(x.total_cmp(&y), Ordering::Equal);
                /// }
                ///
                /// check_eq(f64::NAN, f64::NAN);
                /// check_eq(f32::NAN, f32::NAN);
                ///
                /// fn check_lt<T: TotalOrder>(x: T, y: T) {
                ///     assert_eq!(x.total_cmp(&y), Ordering::Less);
                /// }
                ///
                /// check_lt(-f64::NAN, f64::NAN);
                /// check_lt(f64::INFINITY, f64::NAN);
                /// check_lt(-0.0_f64, 0.0_f64);
                /// ```
                fn total_cmp(&self, other: &Self) -> Ordering;
            }
            macro_rules! totalorder_impl {
                ($T:ident, $I:ident, $U:ident, $bits:expr) => {
                    impl TotalOrder for $T {
                        #[inline]
                        #[cfg(has_total_cmp)]
                        fn total_cmp(&self, other: &Self) -> Ordering {
                           
                            Self::total_cmp(&self, other)
                        }
                        #[inline]
                        #[cfg(not(has_total_cmp))]
                        fn total_cmp(&self, other: &Self) -> Ordering {
                           
                            let mut left = self.to_bits() as $I;
                            let mut right = other.to_bits() as $I;

                            left ^= (((left >> ($bits - 1)) as $U) >> 1) as $I;
                            right ^= (((right >> ($bits - 1)) as $U) >> 1) as $I;

                            left.cmp(&right)
                        }
                    }
                };
            }
            totalorder_impl!(f64, i64, u64, 64);
            totalorder_impl!(f32, i32, u32, 32);
        } pub use self::float::{ Float, FloatConst };

        pub mod identities
        {
            use ::
            {
                *,
            };
            /*
                use core::num::Wrapping;
                use core::ops::{Add, Mul};

                #[cfg(has_num_saturating)]
                use core::num::Saturating;
            */
            /// Defines an additive identity element for `Self`.
            /// a + 0 = a       ∀ a ∈ Self
            /// 0 + a = a       ∀ a ∈ Self
            /// ```
            pub trait Zero: Sized + Add<Self, Output = Self> {
                /// Returns the additive identity element of `Self`, `0`.
                /// # Purity
                ///
                /// This function should return the same result at all times regardless of
                /// external mutable state, for example values stored in TLS or in
                /// `static mut`s.
               
                fn zero() -> Self;

                /// Sets `self` to the additive identity element of `Self`, `0`.
                fn set_zero(&mut self) {
                    *self = Zero::zero();
                }

                /// Returns `true` if `self` is equal to the additive identity.
                fn is_zero(&self) -> bool;
            }
            /// Defines an associated constant representing the additive identity element
            /// for `Self`.
            pub trait ConstZero: Zero {
                /// The additive identity element of `Self`, `0`.
                const ZERO: Self;
            }

            macro_rules! zero_impl {
                ($t:ty, $v:expr) => {
                    impl Zero for $t {
                        #[inline]
                        fn zero() -> $t {
                            $v
                        }
                        #[inline]
                        fn is_zero(&self) -> bool {
                            *self == $v
                        }
                    }

                    impl ConstZero for $t {
                        const ZERO: Self = $v;
                    }
                };
            }

            zero_impl!(usize, 0);
            zero_impl!(u8, 0);
            zero_impl!(u16, 0);
            zero_impl!(u32, 0);
            zero_impl!(u64, 0);
            zero_impl!(u128, 0);

            zero_impl!(isize, 0);
            zero_impl!(i8, 0);
            zero_impl!(i16, 0);
            zero_impl!(i32, 0);
            zero_impl!(i64, 0);
            zero_impl!(i128, 0);

            zero_impl!(f32, 0.0);
            zero_impl!(f64, 0.0);

            impl<T: Zero> Zero for Wrapping<T>
            where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                fn is_zero(&self) -> bool {
                    self.0.is_zero()
                }

                fn set_zero(&mut self) {
                    self.0.set_zero();
                }

                fn zero() -> Self {
                    Wrapping(T::zero())
                }
            }

            impl<T: ConstZero> ConstZero for Wrapping<T>
            where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                const ZERO: Self = Wrapping(T::ZERO);
            }

            #[cfg(has_num_saturating)]
            impl<T: Zero> Zero for Saturating<T>
            where
                Saturating<T>: Add<Output = Saturating<T>>,
            {
                fn is_zero(&self) -> bool {
                    self.0.is_zero()
                }

                fn set_zero(&mut self) {
                    self.0.set_zero();
                }

                fn zero() -> Self {
                    Saturating(T::zero())
                }
            }

            #[cfg(has_num_saturating)]
            impl<T: ConstZero> ConstZero for Saturating<T>
            where
                Saturating<T>: Add<Output = Saturating<T>>,
            {
                const ZERO: Self = Saturating(T::ZERO);
            }
            /// Defines a multiplicative identity element for `Self`.
            /// a * 1 = a       ∀ a ∈ Self
            /// 1 * a = a       ∀ a ∈ Self
            /// ```
            pub trait One: Sized + Mul<Self, Output = Self> {
                /// Returns the multiplicative identity element of `Self`, `1`.
                ///
                /// # Purity
                ///
                /// This function should return the same result at all times regardless of
                /// external mutable state, for example values stored in TLS or in
                /// `static mut`s.
               
                fn one() -> Self;

                /// Sets `self` to the multiplicative identity element of `Self`, `1`.
                fn set_one(&mut self) {
                    *self = One::one();
                }

                /// Returns `true` if `self` is equal to the multiplicative identity.
                ///
                /// For performance reasons, it's best to implement this manually.
                /// After a semver bump, this method will be required, and the
                /// `where Self: PartialEq` bound will be removed.
                #[inline]
                fn is_one(&self) -> bool
                where
                    Self: PartialEq,
                {
                    *self == Self::one()
                }
            }
            /// Defines an associated constant representing the multiplicative identity
            /// element for `Self`.
            pub trait ConstOne: One {
                /// The multiplicative identity element of `Self`, `1`.
                const ONE: Self;
            }

            macro_rules! one_impl {
                ($t:ty, $v:expr) => {
                    impl One for $t {
                        #[inline]
                        fn one() -> $t {
                            $v
                        }
                        #[inline]
                        fn is_one(&self) -> bool {
                            *self == $v
                        }
                    }

                    impl ConstOne for $t {
                        const ONE: Self = $v;
                    }
                };
            }

            one_impl!(usize, 1);
            one_impl!(u8, 1);
            one_impl!(u16, 1);
            one_impl!(u32, 1);
            one_impl!(u64, 1);
            one_impl!(u128, 1);

            one_impl!(isize, 1);
            one_impl!(i8, 1);
            one_impl!(i16, 1);
            one_impl!(i32, 1);
            one_impl!(i64, 1);
            one_impl!(i128, 1);

            one_impl!(f32, 1.0);
            one_impl!(f64, 1.0);

            impl<T: One> One for Wrapping<T>
            where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                fn set_one(&mut self) {
                    self.0.set_one();
                }

                fn one() -> Self {
                    Wrapping(T::one())
                }
            }

            impl<T: ConstOne> ConstOne for Wrapping<T>
            where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                const ONE: Self = Wrapping(T::ONE);
            }

            #[cfg(has_num_saturating)]
            impl<T: One> One for Saturating<T>
            where
                Saturating<T>: Mul<Output = Saturating<T>>,
            {
                fn set_one(&mut self) {
                    self.0.set_one();
                }

                fn one() -> Self {
                    Saturating(T::one())
                }
            }

            #[cfg(has_num_saturating)]
            impl<T: ConstOne> ConstOne for Saturating<T>
            where
                Saturating<T>: Mul<Output = Saturating<T>>,
            {
                const ONE: Self = Saturating(T::ONE);
            }

           

            /// Returns the additive identity, `0`.
            #[inline( always )] pub fn zero<T: Zero>() -> T {
                Zero::zero()
            }
            /// Returns the multiplicative identity, `1`.
            #[inline( always )] pub fn one<T: One>() -> T {
                One::one()
            }
        } pub use self::identities::{one, zero, ConstOne, ConstZero, One, Zero};

        pub mod int
        {
            use ::
            {
                *,
            };
            /*
                use core::ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr};
                use crate::bounds::Bounded;
                use crate::ops::checked::*;
                use crate::ops::saturating::Saturating;
                use crate::{Num, NumCast};
            */
            /// Generic trait for primitive integers.
            /// bitwise operators and non-wrapping arithmetic.
            /// compile-time.
            /// implement the trait was well.
            /// standard library.
            pub trait PrimInt:
                Sized
                + Copy
                + Num
                + NumCast
                + Bounded
                + PartialOrd
                + Ord
                + Eq
                + Not<Output = Self>
                + BitAnd<Output = Self>
                + BitOr<Output = Self>
                + BitXor<Output = Self>
                + Shl<usize, Output = Self>
                + Shr<usize, Output = Self>
                + CheckedAdd<Output = Self>
                + CheckedSub<Output = Self>
                + CheckedMul<Output = Self>
                + CheckedDiv<Output = Self>
                + Saturating
            {
                /// Returns the number of ones in the binary representation of `self`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0b01001100u8;
                ///
                /// assert_eq!(n.count_ones(), 3);
                /// ```
                fn count_ones(self) -> u32;

                /// Returns the number of zeros in the binary representation of `self`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0b01001100u8;
                ///
                /// assert_eq!(n.count_zeros(), 5);
                /// ```
                fn count_zeros(self) -> u32;

                /// Returns the number of leading ones in the binary representation
                /// of `self`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0xF00Du16;
                ///
                /// assert_eq!(n.leading_ones(), 4);
                /// ```
                fn leading_ones(self) -> u32 {
                    (!self).leading_zeros()
                }

                /// Returns the number of leading zeros in the binary representation
                /// of `self`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0b0101000u16;
                ///
                /// assert_eq!(n.leading_zeros(), 10);
                /// ```
                fn leading_zeros(self) -> u32;

                /// Returns the number of trailing ones in the binary representation
                /// of `self`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0xBEEFu16;
                ///
                /// assert_eq!(n.trailing_ones(), 4);
                /// ```
                fn trailing_ones(self) -> u32 {
                    (!self).trailing_zeros()
                }

                /// Returns the number of trailing zeros in the binary representation
                /// of `self`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0b0101000u16;
                ///
                /// assert_eq!(n.trailing_zeros(), 3);
                /// ```
                fn trailing_zeros(self) -> u32;

                /// Shifts the bits to the left by a specified amount, `n`, wrapping
                /// the truncated bits to the end of the resulting integer.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                /// let m = 0x3456789ABCDEF012u64;
                ///
                /// assert_eq!(n.rotate_left(12), m);
                /// ```
                fn rotate_left(self, n: u32) -> Self;

                /// Shifts the bits to the right by a specified amount, `n`, wrapping
                /// the truncated bits to the beginning of the resulting integer.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                /// let m = 0xDEF0123456789ABCu64;
                ///
                /// assert_eq!(n.rotate_right(12), m);
                /// ```
                fn rotate_right(self, n: u32) -> Self;

                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                ///
                /// This is bitwise equivalent to signed `Shl`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                /// let m = 0x3456789ABCDEF000u64;
                ///
                /// assert_eq!(n.signed_shl(12), m);
                /// ```
                fn signed_shl(self, n: u32) -> Self;

                /// Shifts the bits to the right by a specified amount, `n`, copying
                /// the "sign bit" in the most significant bits even for unsigned types.
                ///
                /// This is bitwise equivalent to signed `Shr`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0xFEDCBA9876543210u64;
                /// let m = 0xFFFFEDCBA9876543u64;
                ///
                /// assert_eq!(n.signed_shr(12), m);
                /// ```
                fn signed_shr(self, n: u32) -> Self;

                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                ///
                /// This is bitwise equivalent to unsigned `Shl`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFi64;
                /// let m = 0x3456789ABCDEF000i64;
                ///
                /// assert_eq!(n.unsigned_shl(12), m);
                /// ```
                fn unsigned_shl(self, n: u32) -> Self;

                /// Shifts the bits to the right by a specified amount, `n`, filling
                /// zeros in the most significant bits.
                ///
                /// This is bitwise equivalent to unsigned `Shr`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = -8i8;
                /// let m = 62i8;
                ///
                /// assert_eq!(n.unsigned_shr(2), m);
                /// ```
                fn unsigned_shr(self, n: u32) -> Self;

                /// Reverses the byte order of the integer.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                /// let m = 0xEFCDAB8967452301u64;
                ///
                /// assert_eq!(n.swap_bytes(), m);
                /// ```
                fn swap_bytes(self) -> Self;

                /// Reverses the order of bits in the integer.
                ///
                /// The least significant bit becomes the most significant bit, second least-significant bit
                /// becomes second most-significant bit, etc.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x12345678u32;
                /// let m = 0x1e6a2c48u32;
                ///
                /// assert_eq!(n.reverse_bits(), m);
                /// assert_eq!(0u32.reverse_bits(), 0);
                /// ```
                fn reverse_bits(self) -> Self {
                    reverse_bits_fallback(self)
                }

                /// Convert an integer from big endian to the target's endianness.
                ///
                /// On big endian this is a no-op. On little endian the bytes are swapped.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                ///
                /// if cfg!(target_endian = "big") {
                ///     assert_eq!(u64::from_be(n), n)
                /// } else {
                ///     assert_eq!(u64::from_be(n), n.swap_bytes())
                /// }
                /// ```
                fn from_be(x: Self) -> Self;

                /// Convert an integer from little endian to the target's endianness.
                ///
                /// On little endian this is a no-op. On big endian the bytes are swapped.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                ///
                /// if cfg!(target_endian = "little") {
                ///     assert_eq!(u64::from_le(n), n)
                /// } else {
                ///     assert_eq!(u64::from_le(n), n.swap_bytes())
                /// }
                /// ```
                fn from_le(x: Self) -> Self;

                /// Convert `self` to big endian from the target's endianness.
                ///
                /// On big endian this is a no-op. On little endian the bytes are swapped.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                ///
                /// if cfg!(target_endian = "big") {
                ///     assert_eq!(n.to_be(), n)
                /// } else {
                ///     assert_eq!(n.to_be(), n.swap_bytes())
                /// }
                /// ```
                fn to_be(self) -> Self;

                /// Convert `self` to little endian from the target's endianness.
                ///
                /// On little endian this is a no-op. On big endian the bytes are swapped.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                ///
                /// if cfg!(target_endian = "little") {
                ///     assert_eq!(n.to_le(), n)
                /// } else {
                ///     assert_eq!(n.to_le(), n.swap_bytes())
                /// }
                /// ```
                fn to_le(self) -> Self;

                /// Raises self to the power of `exp`, using exponentiation by squaring.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// assert_eq!(2i32.pow(4), 16);
                /// ```
                fn pow(self, exp: u32) -> Self;
            }

            fn one_per_byte<P: PrimInt>() -> P {
               
               
               
               
                let mut ret = P::one();
                let mut shift = 8;
                let mut b = ret.count_zeros() >> 3;
                while b != 0 {
                    ret = (ret << shift) | ret;
                    shift <<= 1;
                    b >>= 1;
                }
                ret
            }

            fn reverse_bits_fallback<P: PrimInt>(i: P) -> P {
                let rep_01: P = one_per_byte();
                let rep_03 = (rep_01 << 1) | rep_01;
                let rep_05 = (rep_01 << 2) | rep_01;
                let rep_0f = (rep_03 << 2) | rep_03;
                let rep_33 = (rep_03 << 4) | rep_03;
                let rep_55 = (rep_05 << 4) | rep_05;

               
               
                let mut ret = i.swap_bytes();
                ret = ((ret & rep_0f) << 4) | ((ret >> 4) & rep_0f);
                ret = ((ret & rep_33) << 2) | ((ret >> 2) & rep_33);
                ret = ((ret & rep_55) << 1) | ((ret >> 1) & rep_55);
                ret
            }

            macro_rules! prim_int_impl {
                ($T:ty, $S:ty, $U:ty) => {
                    impl PrimInt for $T {
                        #[inline]
                        fn count_ones(self) -> u32 {
                            <$T>::count_ones(self)
                        }

                        #[inline]
                        fn count_zeros(self) -> u32 {
                            <$T>::count_zeros(self)
                        }

                        #[inline]
                        fn leading_ones(self) -> u32 {
                            <$T>::leading_ones(self)
                        }

                        #[inline]
                        fn leading_zeros(self) -> u32 {
                            <$T>::leading_zeros(self)
                        }

                        #[inline]
                        fn trailing_ones(self) -> u32 {
                            <$T>::trailing_ones(self)
                        }

                        #[inline]
                        fn trailing_zeros(self) -> u32 {
                            <$T>::trailing_zeros(self)
                        }

                        #[inline]
                        fn rotate_left(self, n: u32) -> Self {
                            <$T>::rotate_left(self, n)
                        }

                        #[inline]
                        fn rotate_right(self, n: u32) -> Self {
                            <$T>::rotate_right(self, n)
                        }

                        #[inline]
                        fn signed_shl(self, n: u32) -> Self {
                            ((self as $S) << n) as $T
                        }

                        #[inline]
                        fn signed_shr(self, n: u32) -> Self {
                            ((self as $S) >> n) as $T
                        }

                        #[inline]
                        fn unsigned_shl(self, n: u32) -> Self {
                            ((self as $U) << n) as $T
                        }

                        #[inline]
                        fn unsigned_shr(self, n: u32) -> Self {
                            ((self as $U) >> n) as $T
                        }

                        #[inline]
                        fn swap_bytes(self) -> Self {
                            <$T>::swap_bytes(self)
                        }

                        #[inline]
                        fn reverse_bits(self) -> Self {
                            <$T>::reverse_bits(self)
                        }

                        #[inline]
                        fn from_be(x: Self) -> Self {
                            <$T>::from_be(x)
                        }

                        #[inline]
                        fn from_le(x: Self) -> Self {
                            <$T>::from_le(x)
                        }

                        #[inline]
                        fn to_be(self) -> Self {
                            <$T>::to_be(self)
                        }

                        #[inline]
                        fn to_le(self) -> Self {
                            <$T>::to_le(self)
                        }

                        #[inline]
                        fn pow(self, exp: u32) -> Self {
                            <$T>::pow(self, exp)
                        }
                    }
                };
            }

           
            prim_int_impl!(u8, i8, u8);
            prim_int_impl!(u16, i16, u16);
            prim_int_impl!(u32, i32, u32);
            prim_int_impl!(u64, i64, u64);
            prim_int_impl!(u128, i128, u128);
            prim_int_impl!(usize, isize, usize);
            prim_int_impl!(i8, i8, u8);
            prim_int_impl!(i16, i16, u16);
            prim_int_impl!(i32, i32, u32);
            prim_int_impl!(i64, i64, u64);
            prim_int_impl!(i128, i128, u128);
            prim_int_impl!(isize, isize, usize);
        } pub use self::int::PrimInt;

        pub mod ops
        {
            use ::
            {
                *,
            };
            /*
            */
            pub mod bytes
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use core::borrow::{Borrow, BorrowMut};
                    use core::cmp::{Eq, Ord, PartialEq, PartialOrd};
                    use core::fmt::Debug;
                    use core::hash::Hash;
                */
                pub trait NumBytes:
                    Debug
                    + AsRef<[u8]>
                    + AsMut<[u8]>
                    + PartialEq
                    + Eq
                    + PartialOrd
                    + Ord
                    + Hash
                    + Borrow<[u8]>
                    + BorrowMut<[u8]>
                {
                }

                impl<T> NumBytes for T where
                    T: Debug
                        + AsRef<[u8]>
                        + AsMut<[u8]>
                        + PartialEq
                        + Eq
                        + PartialOrd
                        + Ord
                        + Hash
                        + Borrow<[u8]>
                        + BorrowMut<[u8]>
                        + ?Sized
                {
                }

                pub trait ToBytes {
                    type Bytes: NumBytes;

                    /// Return the memory representation of this number as a byte array in big-endian byte order.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::ToBytes;
                    ///
                    /// let bytes = ToBytes::to_be_bytes(&0x12345678u32);
                    /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);
                    /// ```
                    fn to_be_bytes(&self) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in little-endian byte order.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::ToBytes;
                    ///
                    /// let bytes = ToBytes::to_le_bytes(&0x12345678u32);
                    /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);
                    /// ```
                    fn to_le_bytes(&self) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in native byte order.
                    ///
                    /// As the target platform's native endianness is used,
                    /// portable code should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.
                    ///
                    /// [`to_be_bytes`]: #method.to_be_bytes
                    /// [`to_le_bytes`]: #method.to_le_bytes
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::ToBytes;
                    ///
                    /// #[cfg(target_endian = "big")]
                    /// let expected = [0x12, 0x34, 0x56, 0x78];
                    ///
                    /// #[cfg(target_endian = "little")]
                    /// let expected = [0x78, 0x56, 0x34, 0x12];
                    ///
                    /// let bytes = ToBytes::to_ne_bytes(&0x12345678u32);
                    /// assert_eq!(bytes, expected)
                    /// ```
                    fn to_ne_bytes(&self) -> Self::Bytes {
                        #[cfg(target_endian = "big")]
                        let bytes = self.to_be_bytes();
                        #[cfg(target_endian = "little")]
                        let bytes = self.to_le_bytes();
                        bytes
                    }
                }

                pub trait FromBytes: Sized {
                    type Bytes: NumBytes + ?Sized;

                    /// Create a number from its representation as a byte array in big endian.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::FromBytes;
                    ///
                    /// let value: u32 = FromBytes::from_be_bytes(&[0x12, 0x34, 0x56, 0x78]);
                    /// assert_eq!(value, 0x12345678);
                    /// ```
                    fn from_be_bytes(bytes: &Self::Bytes) -> Self;

                    /// Create a number from its representation as a byte array in little endian.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::FromBytes;
                    ///
                    /// let value: u32 = FromBytes::from_le_bytes(&[0x78, 0x56, 0x34, 0x12]);
                    /// assert_eq!(value, 0x12345678);
                    /// ```
                    fn from_le_bytes(bytes: &Self::Bytes) -> Self;

                    /// Create a number from its memory representation as a byte array in native endianness.
                    ///
                    /// As the target platform's native endianness is used,
                    /// portable code likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as appropriate instead.
                    ///
                    /// [`from_be_bytes`]: #method.from_be_bytes
                    /// [`from_le_bytes`]: #method.from_le_bytes
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::FromBytes;
                    ///
                    /// #[cfg(target_endian = "big")]
                    /// let bytes = [0x12, 0x34, 0x56, 0x78];
                    ///
                    /// #[cfg(target_endian = "little")]
                    /// let bytes = [0x78, 0x56, 0x34, 0x12];
                    ///
                    /// let value: u32 = FromBytes::from_ne_bytes(&bytes);
                    /// assert_eq!(value, 0x12345678)
                    /// ```
                    fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                        #[cfg(target_endian = "big")]
                        let this = Self::from_be_bytes(bytes);
                        #[cfg(target_endian = "little")]
                        let this = Self::from_le_bytes(bytes);
                        this
                    }
                }

                macro_rules! float_to_from_bytes_impl {
                    ($T:ty, $L:expr) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes(&self) -> Self::Bytes {
                                <$T>::to_be_bytes(*self)
                            }

                            #[inline]
                            fn to_le_bytes(&self) -> Self::Bytes {
                                <$T>::to_le_bytes(*self)
                            }

                            #[inline]
                            fn to_ne_bytes(&self) -> Self::Bytes {
                                <$T>::to_ne_bytes(*self)
                            }
                        }

                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_be_bytes(*bytes)
                            }

                            #[inline]
                            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_le_bytes(*bytes)
                            }

                            #[inline]
                            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_ne_bytes(*bytes)
                            }
                        }
                    };
                }

                macro_rules! int_to_from_bytes_impl {
                    ($T:ty, $L:expr) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes(&self) -> Self::Bytes {
                                <$T>::to_be_bytes(*self)
                            }

                            #[inline]
                            fn to_le_bytes(&self) -> Self::Bytes {
                                <$T>::to_le_bytes(*self)
                            }

                            #[inline]
                            fn to_ne_bytes(&self) -> Self::Bytes {
                                <$T>::to_ne_bytes(*self)
                            }
                        }

                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_be_bytes(*bytes)
                            }

                            #[inline]
                            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_le_bytes(*bytes)
                            }

                            #[inline]
                            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_ne_bytes(*bytes)
                            }
                        }
                    };
                }

                int_to_from_bytes_impl!(u8, 1);
                int_to_from_bytes_impl!(u16, 2);
                int_to_from_bytes_impl!(u32, 4);
                int_to_from_bytes_impl!(u64, 8);
                int_to_from_bytes_impl!(u128, 16);
                #[cfg(target_pointer_width = "64")]
                int_to_from_bytes_impl!(usize, 8);
                #[cfg(target_pointer_width = "32")]
                int_to_from_bytes_impl!(usize, 4);

                int_to_from_bytes_impl!(i8, 1);
                int_to_from_bytes_impl!(i16, 2);
                int_to_from_bytes_impl!(i32, 4);
                int_to_from_bytes_impl!(i64, 8);
                int_to_from_bytes_impl!(i128, 16);
                #[cfg(target_pointer_width = "64")]
                int_to_from_bytes_impl!(isize, 8);
                #[cfg(target_pointer_width = "32")]
                int_to_from_bytes_impl!(isize, 4);

                float_to_from_bytes_impl!(f32, 4);
                float_to_from_bytes_impl!(f64, 8);
            }
            
            pub mod checked
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use core::ops::{Add, Div, Mul, Rem, Shl, Shr, Sub};
                */
                /// Performs addition, returning `None` if overflow occurred.
                pub trait CheckedAdd: Sized + Add<Self, Output = Self> {
                    /// Adds two numbers, checking for overflow. If overflow happens, `None` is
                    /// returned.
                    fn checked_add(&self, v: &Self) -> Option<Self>;
                }

                macro_rules! checked_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &$t) -> Option<$t> {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                checked_impl!(CheckedAdd, checked_add, u8);
                checked_impl!(CheckedAdd, checked_add, u16);
                checked_impl!(CheckedAdd, checked_add, u32);
                checked_impl!(CheckedAdd, checked_add, u64);
                checked_impl!(CheckedAdd, checked_add, usize);
                checked_impl!(CheckedAdd, checked_add, u128);

                checked_impl!(CheckedAdd, checked_add, i8);
                checked_impl!(CheckedAdd, checked_add, i16);
                checked_impl!(CheckedAdd, checked_add, i32);
                checked_impl!(CheckedAdd, checked_add, i64);
                checked_impl!(CheckedAdd, checked_add, isize);
                checked_impl!(CheckedAdd, checked_add, i128);

                /// Performs subtraction, returning `None` if overflow occurred.
                pub trait CheckedSub: Sized + Sub<Self, Output = Self> {
                    /// Subtracts two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_sub(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedSub, checked_sub, u8);
                checked_impl!(CheckedSub, checked_sub, u16);
                checked_impl!(CheckedSub, checked_sub, u32);
                checked_impl!(CheckedSub, checked_sub, u64);
                checked_impl!(CheckedSub, checked_sub, usize);
                checked_impl!(CheckedSub, checked_sub, u128);

                checked_impl!(CheckedSub, checked_sub, i8);
                checked_impl!(CheckedSub, checked_sub, i16);
                checked_impl!(CheckedSub, checked_sub, i32);
                checked_impl!(CheckedSub, checked_sub, i64);
                checked_impl!(CheckedSub, checked_sub, isize);
                checked_impl!(CheckedSub, checked_sub, i128);

                /// Performs multiplication, returning `None` if overflow occurred.
                pub trait CheckedMul: Sized + Mul<Self, Output = Self> {
                    /// Multiplies two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_mul(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedMul, checked_mul, u8);
                checked_impl!(CheckedMul, checked_mul, u16);
                checked_impl!(CheckedMul, checked_mul, u32);
                checked_impl!(CheckedMul, checked_mul, u64);
                checked_impl!(CheckedMul, checked_mul, usize);
                checked_impl!(CheckedMul, checked_mul, u128);

                checked_impl!(CheckedMul, checked_mul, i8);
                checked_impl!(CheckedMul, checked_mul, i16);
                checked_impl!(CheckedMul, checked_mul, i32);
                checked_impl!(CheckedMul, checked_mul, i64);
                checked_impl!(CheckedMul, checked_mul, isize);
                checked_impl!(CheckedMul, checked_mul, i128);

                /// Performs division, returning `None` on division by zero or if overflow
                /// occurred.
                pub trait CheckedDiv: Sized + Div<Self, Output = Self> {
                    /// Divides two numbers, checking for overflow and division by
                    /// zero. If any of that happens, `None` is returned.
                    fn checked_div(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedDiv, checked_div, u8);
                checked_impl!(CheckedDiv, checked_div, u16);
                checked_impl!(CheckedDiv, checked_div, u32);
                checked_impl!(CheckedDiv, checked_div, u64);
                checked_impl!(CheckedDiv, checked_div, usize);
                checked_impl!(CheckedDiv, checked_div, u128);

                checked_impl!(CheckedDiv, checked_div, i8);
                checked_impl!(CheckedDiv, checked_div, i16);
                checked_impl!(CheckedDiv, checked_div, i32);
                checked_impl!(CheckedDiv, checked_div, i64);
                checked_impl!(CheckedDiv, checked_div, isize);
                checked_impl!(CheckedDiv, checked_div, i128);

                /// Performs integral remainder, returning `None` on division by zero or if
                /// overflow occurred.
                pub trait CheckedRem: Sized + Rem<Self, Output = Self> {
                    /// Finds the remainder of dividing two numbers, checking for overflow and
                    /// division by zero. If any of that happens, `None` is returned.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::CheckedRem;
                    /// use std::i32::MIN;
                    ///
                    /// assert_eq!(CheckedRem::checked_rem(&10, &7), Some(3));
                    /// assert_eq!(CheckedRem::checked_rem(&10, &-7), Some(3));
                    /// assert_eq!(CheckedRem::checked_rem(&-10, &7), Some(-3));
                    /// assert_eq!(CheckedRem::checked_rem(&-10, &-7), Some(-3));
                    ///
                    /// assert_eq!(CheckedRem::checked_rem(&10, &0), None);
                    ///
                    /// assert_eq!(CheckedRem::checked_rem(&MIN, &1), Some(0));
                    /// assert_eq!(CheckedRem::checked_rem(&MIN, &-1), None);
                    /// ```
                    fn checked_rem(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedRem, checked_rem, u8);
                checked_impl!(CheckedRem, checked_rem, u16);
                checked_impl!(CheckedRem, checked_rem, u32);
                checked_impl!(CheckedRem, checked_rem, u64);
                checked_impl!(CheckedRem, checked_rem, usize);
                checked_impl!(CheckedRem, checked_rem, u128);

                checked_impl!(CheckedRem, checked_rem, i8);
                checked_impl!(CheckedRem, checked_rem, i16);
                checked_impl!(CheckedRem, checked_rem, i32);
                checked_impl!(CheckedRem, checked_rem, i64);
                checked_impl!(CheckedRem, checked_rem, isize);
                checked_impl!(CheckedRem, checked_rem, i128);

                macro_rules! checked_impl_unary {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self) -> Option<$t> {
                                <$t>::$method(*self)
                            }
                        }
                    };
                }

                /// Performs negation, returning `None` if the result can't be represented.
                pub trait CheckedNeg: Sized {
                    /// Negates a number, returning `None` for results that can't be represented, like signed `MIN`
                    /// values that can't be positive, or non-zero unsigned values that can't be negative.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::CheckedNeg;
                    /// use std::i32::MIN;
                    ///
                    /// assert_eq!(CheckedNeg::checked_neg(&1_i32), Some(-1));
                    /// assert_eq!(CheckedNeg::checked_neg(&-1_i32), Some(1));
                    /// assert_eq!(CheckedNeg::checked_neg(&MIN), None);
                    ///
                    /// assert_eq!(CheckedNeg::checked_neg(&0_u32), Some(0));
                    /// assert_eq!(CheckedNeg::checked_neg(&1_u32), None);
                    /// ```
                    fn checked_neg(&self) -> Option<Self>;
                }

                checked_impl_unary!(CheckedNeg, checked_neg, u8);
                checked_impl_unary!(CheckedNeg, checked_neg, u16);
                checked_impl_unary!(CheckedNeg, checked_neg, u32);
                checked_impl_unary!(CheckedNeg, checked_neg, u64);
                checked_impl_unary!(CheckedNeg, checked_neg, usize);
                checked_impl_unary!(CheckedNeg, checked_neg, u128);

                checked_impl_unary!(CheckedNeg, checked_neg, i8);
                checked_impl_unary!(CheckedNeg, checked_neg, i16);
                checked_impl_unary!(CheckedNeg, checked_neg, i32);
                checked_impl_unary!(CheckedNeg, checked_neg, i64);
                checked_impl_unary!(CheckedNeg, checked_neg, isize);
                checked_impl_unary!(CheckedNeg, checked_neg, i128);

                /// Performs shift left, returning `None` on shifts larger than or equal to
                /// the type width.
                pub trait CheckedShl: Sized + Shl<u32, Output = Self> {
                    /// Checked shift left. Computes `self << rhs`, returning `None`
                    /// if `rhs` is larger than or equal to the number of bits in `self`.
                    ///
                    /// ```
                    /// use num_traits::CheckedShl;
                    ///
                    /// let x: u16 = 0x0001;
                    ///
                    /// assert_eq!(CheckedShl::checked_shl(&x, 0),  Some(0x0001));
                    /// assert_eq!(CheckedShl::checked_shl(&x, 1),  Some(0x0002));
                    /// assert_eq!(CheckedShl::checked_shl(&x, 15), Some(0x8000));
                    /// assert_eq!(CheckedShl::checked_shl(&x, 16), None);
                    /// ```
                    fn checked_shl(&self, rhs: u32) -> Option<Self>;
                }

                macro_rules! checked_shift_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, rhs: u32) -> Option<$t> {
                                <$t>::$method(*self, rhs)
                            }
                        }
                    };
                }

                checked_shift_impl!(CheckedShl, checked_shl, u8);
                checked_shift_impl!(CheckedShl, checked_shl, u16);
                checked_shift_impl!(CheckedShl, checked_shl, u32);
                checked_shift_impl!(CheckedShl, checked_shl, u64);
                checked_shift_impl!(CheckedShl, checked_shl, usize);
                checked_shift_impl!(CheckedShl, checked_shl, u128);

                checked_shift_impl!(CheckedShl, checked_shl, i8);
                checked_shift_impl!(CheckedShl, checked_shl, i16);
                checked_shift_impl!(CheckedShl, checked_shl, i32);
                checked_shift_impl!(CheckedShl, checked_shl, i64);
                checked_shift_impl!(CheckedShl, checked_shl, isize);
                checked_shift_impl!(CheckedShl, checked_shl, i128);

                /// Performs shift right, returning `None` on shifts larger than or equal to
                /// the type width.
                pub trait CheckedShr: Sized + Shr<u32, Output = Self> {
                    /// Checked shift right. Computes `self >> rhs`, returning `None`
                    /// if `rhs` is larger than or equal to the number of bits in `self`.
                    ///
                    /// ```
                    /// use num_traits::CheckedShr;
                    ///
                    /// let x: u16 = 0x8000;
                    ///
                    /// assert_eq!(CheckedShr::checked_shr(&x, 0),  Some(0x8000));
                    /// assert_eq!(CheckedShr::checked_shr(&x, 1),  Some(0x4000));
                    /// assert_eq!(CheckedShr::checked_shr(&x, 15), Some(0x0001));
                    /// assert_eq!(CheckedShr::checked_shr(&x, 16), None);
                    /// ```
                    fn checked_shr(&self, rhs: u32) -> Option<Self>;
                }

                checked_shift_impl!(CheckedShr, checked_shr, u8);
                checked_shift_impl!(CheckedShr, checked_shr, u16);
                checked_shift_impl!(CheckedShr, checked_shr, u32);
                checked_shift_impl!(CheckedShr, checked_shr, u64);
                checked_shift_impl!(CheckedShr, checked_shr, usize);
                checked_shift_impl!(CheckedShr, checked_shr, u128);

                checked_shift_impl!(CheckedShr, checked_shr, i8);
                checked_shift_impl!(CheckedShr, checked_shr, i16);
                checked_shift_impl!(CheckedShr, checked_shr, i32);
                checked_shift_impl!(CheckedShr, checked_shr, i64);
                checked_shift_impl!(CheckedShr, checked_shr, isize);
                checked_shift_impl!(CheckedShr, checked_shr, i128);

            }
            
            pub mod euclid
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use core::ops::{Div, Rem};
                */
                pub trait Euclid: Sized + Div<Self, Output = Self> + Rem<Self, Output = Self> {
                    /// Calculates Euclidean division, the matching method for `rem_euclid`.
                    ///
                    /// This computes the integer `n` such that
                    /// `self = n * v + self.rem_euclid(v)`.
                    /// In other words, the result is `self / v` rounded to the integer `n`
                    /// such that `self >= n * v`.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::Euclid;
                    ///
                    /// let a: i32 = 7;
                    /// let b: i32 = 4;
                    /// assert_eq!(Euclid::div_euclid(&a, &b), 1);
                    /// assert_eq!(Euclid::div_euclid(&-a, &b), -2);
                    /// assert_eq!(Euclid::div_euclid(&a, &-b), -1);
                    /// assert_eq!(Euclid::div_euclid(&-a, &-b), 2);
                    /// ```
                    fn div_euclid(&self, v: &Self) -> Self;

                    /// Calculates the least nonnegative remainder of `self (mod v)`.
                    ///
                    /// In particular, the return value `r` satisfies `0.0 <= r < v.abs()` in
                    /// most cases. However, due to a floating point round-off error it can
                    /// result in `r == v.abs()`, violating the mathematical definition, if
                    /// `self` is much smaller than `v.abs()` in magnitude and `self < 0.0`.
                    /// This result is not an element of the function's codomain, but it is the
                    /// closest floating point number in the real numbers and thus fulfills the
                    /// property `self == self.div_euclid(v) * v + self.rem_euclid(v)`
                    /// approximatively.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::Euclid;
                    ///
                    /// let a: i32 = 7;
                    /// let b: i32 = 4;
                    /// assert_eq!(Euclid::rem_euclid(&a, &b), 3);
                    /// assert_eq!(Euclid::rem_euclid(&-a, &b), 1);
                    /// assert_eq!(Euclid::rem_euclid(&a, &-b), 3);
                    /// assert_eq!(Euclid::rem_euclid(&-a, &-b), 1);
                    /// ```
                    fn rem_euclid(&self, v: &Self) -> Self;

                    /// Returns both the quotient and remainder from Euclidean division.
                    ///
                    /// By default, it internally calls both `Euclid::div_euclid` and `Euclid::rem_euclid`,
                    /// but it can be overridden in order to implement some optimization.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// # use num_traits::Euclid;
                    /// let x = 5u8;
                    /// let y = 3u8;
                    ///
                    /// let div = Euclid::div_euclid(&x, &y);
                    /// let rem = Euclid::rem_euclid(&x, &y);
                    ///
                    /// assert_eq!((div, rem), Euclid::div_rem_euclid(&x, &y));
                    /// ```
                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                        (self.div_euclid(v), self.rem_euclid(v))
                    }
                }

                macro_rules! euclid_forward_impl {
                    ($($t:ty)*) => {$(
                        impl Euclid for $t {
                            #[inline]
                            fn div_euclid(&self, v: &$t) -> Self {
                                <$t>::div_euclid(*self, *v)
                            }

                            #[inline]
                            fn rem_euclid(&self, v: &$t) -> Self {
                                <$t>::rem_euclid(*self, *v)
                            }
                        }
                    )*}
                }

                euclid_forward_impl!(isize i8 i16 i32 i64 i128);
                euclid_forward_impl!(usize u8 u16 u32 u64 u128);

                #[cfg(feature = "std")]
                euclid_forward_impl!(f32 f64);

                #[cfg(not(feature = "std"))]
                impl Euclid for f32 {
                    #[inline]
                    fn div_euclid(&self, v: &f32) -> f32 {
                        let q = <f32 as crate::float::FloatCore>::trunc(self / v);
                        if self % v < 0.0 {
                            return if *v > 0.0 { q - 1.0 } else { q + 1.0 };
                        }
                        q
                    }

                    #[inline]
                    fn rem_euclid(&self, v: &f32) -> f32 {
                        let r = self % v;
                        if r < 0.0 {
                            r + <f32 as crate::float::FloatCore>::abs(*v)
                        } else {
                            r
                        }
                    }
                }

                #[cfg(not(feature = "std"))]
                impl Euclid for f64 {
                    #[inline]
                    fn div_euclid(&self, v: &f64) -> f64 {
                        let q = <f64 as crate::float::FloatCore>::trunc(self / v);
                        if self % v < 0.0 {
                            return if *v > 0.0 { q - 1.0 } else { q + 1.0 };
                        }
                        q
                    }

                    #[inline]
                    fn rem_euclid(&self, v: &f64) -> f64 {
                        let r = self % v;
                        if r < 0.0 {
                            r + <f64 as crate::float::FloatCore>::abs(*v)
                        } else {
                            r
                        }
                    }
                }

                pub trait CheckedEuclid: Euclid {
                    /// Performs euclid division, returning `None` on division by zero or if
                    /// overflow occurred.
                    fn checked_div_euclid(&self, v: &Self) -> Option<Self>;

                    /// Finds the euclid remainder of dividing two numbers, returning `None` on
                    /// division by zero or if overflow occurred.
                    fn checked_rem_euclid(&self, v: &Self) -> Option<Self>;

                    /// Returns both the quotient and remainder from checked Euclidean division,
                    /// returning `None` on division by zero or if overflow occurred.
                    ///
                    /// By default, it internally calls both `CheckedEuclid::checked_div_euclid` and `CheckedEuclid::checked_rem_euclid`,
                    /// but it can be overridden in order to implement some optimization.
                    /// # Examples
                    ///
                    /// ```
                    /// # use num_traits::CheckedEuclid;
                    /// let x = 5u8;
                    /// let y = 3u8;
                    ///
                    /// let div = CheckedEuclid::checked_div_euclid(&x, &y);
                    /// let rem = CheckedEuclid::checked_rem_euclid(&x, &y);
                    ///
                    /// assert_eq!(Some((div.unwrap(), rem.unwrap())), CheckedEuclid::checked_div_rem_euclid(&x, &y));
                    /// ```
                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some((self.checked_div_euclid(v)?, self.checked_rem_euclid(v)?))
                    }
                }

                macro_rules! checked_euclid_forward_impl {
                    ($($t:ty)*) => {$(
                        impl CheckedEuclid for $t {
                            #[inline]
                            fn checked_div_euclid(&self, v: &$t) -> Option<Self> {
                                <$t>::checked_div_euclid(*self, *v)
                            }

                            #[inline]
                            fn checked_rem_euclid(&self, v: &$t) -> Option<Self> {
                                <$t>::checked_rem_euclid(*self, *v)
                            }
                        }
                    )*}
                }

                checked_euclid_forward_impl!(isize i8 i16 i32 i64 i128);
                checked_euclid_forward_impl!(usize u8 u16 u32 u64 u128);
            }
            
            pub mod inv
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                /// Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.
                pub trait Inv {
                    /// The result after applying the operator.
                    type Output;

                    /// Returns the multiplicative inverse of `self`.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use std::f64::INFINITY;
                    /// use num_traits::Inv;
                    ///
                    /// assert_eq!(7.0.inv() * 7.0, 1.0);
                    /// assert_eq!((-0.0).inv(), -INFINITY);
                    /// ```
                    fn inv(self) -> Self::Output;
                }

                impl Inv for f32 {
                    type Output = f32;
                    #[inline]
                    fn inv(self) -> f32 {
                        1.0 / self
                    }
                }
                impl Inv for f64 {
                    type Output = f64;
                    #[inline]
                    fn inv(self) -> f64 {
                        1.0 / self
                    }
                }
                impl<'a> Inv for &'a f32 {
                    type Output = f32;
                    #[inline]
                    fn inv(self) -> f32 {
                        1.0 / *self
                    }
                }
                impl<'a> Inv for &'a f64 {
                    type Output = f64;
                    #[inline]
                    fn inv(self) -> f64 {
                        1.0 / *self
                    }
                }

            }
            
            pub mod mul_add
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                ///
                /// Using `mul_add` can be more performant than an unfused multiply-add if
                /// the target architecture has a dedicated `fma` CPU instruction.
                ///
                /// Note that `A` and `B` are `Self` by default, but this is not mandatory.
                ///
                /// # Example
                ///
                /// ```
                /// use std::f32;
                ///
                /// let m = 10.0_f32;
                /// let x = 4.0_f32;
                /// let b = 60.0_f32;
                ///
                ///
                /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();
                ///
                /// assert!(abs_difference <= 100.0 * f32::EPSILON);
                /// ```
                pub trait MulAdd<A = Self, B = Self> {
                    /// The resulting type after applying the fused multiply-add.
                    type Output;

                    /// Performs the fused multiply-add operation `(self * a) + b`
                    fn mul_add(self, a: A, b: B) -> Self::Output;
                }

                /// The fused multiply-add assignment operation `*self = (*self * a) + b`
                pub trait MulAddAssign<A = Self, B = Self> {
                    /// Performs the fused multiply-add assignment operation `*self = (*self * a) + b`
                    fn mul_add_assign(&mut self, a: A, b: B);
                }

                #[cfg(any(feature = "std", feature = "libm"))]
                impl MulAdd<f32, f32> for f32 {
                    type Output = Self;

                    #[inline]
                    fn mul_add(self, a: Self, b: Self) -> Self::Output {
                        <Self as crate::Float>::mul_add(self, a, b)
                    }
                }

                #[cfg(any(feature = "std", feature = "libm"))]
                impl MulAdd<f64, f64> for f64 {
                    type Output = Self;

                    #[inline]
                    fn mul_add(self, a: Self, b: Self) -> Self::Output {
                        <Self as crate::Float>::mul_add(self, a, b)
                    }
                }

                macro_rules! mul_add_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            type Output = Self;

                            #[inline]
                            fn mul_add(self, a: Self, b: Self) -> Self::Output {
                                (self * a) + b
                            }
                        }
                    )*}
                }

                mul_add_impl!(MulAdd for isize i8 i16 i32 i64 i128);
                mul_add_impl!(MulAdd for usize u8 u16 u32 u64 u128);

                #[cfg(any(feature = "std", feature = "libm"))]
                impl MulAddAssign<f32, f32> for f32 {
                    #[inline]
                    fn mul_add_assign(&mut self, a: Self, b: Self) {
                        *self = <Self as crate::Float>::mul_add(*self, a, b)
                    }
                }

                #[cfg(any(feature = "std", feature = "libm"))]
                impl MulAddAssign<f64, f64> for f64 {
                    #[inline]
                    fn mul_add_assign(&mut self, a: Self, b: Self) {
                        *self = <Self as crate::Float>::mul_add(*self, a, b)
                    }
                }

                macro_rules! mul_add_assign_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            #[inline]
                            fn mul_add_assign(&mut self, a: Self, b: Self) {
                                *self = (*self * a) + b
                            }
                        }
                    )*}
                }

                mul_add_assign_impl!(MulAddAssign for isize i8 i16 i32 i64 i128);
                mul_add_assign_impl!(MulAddAssign for usize u8 u16 u32 u64 u128);
            }
            
            pub mod overflowing
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use core::ops::{Add, Mul, Sub};
                    use core::{i128, i16, i32, i64, i8, isize};
                    use core::{u128, u16, u32, u64, u8, usize};
                */
                macro_rules! overflowing_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> (Self, bool) {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                /// Performs addition with a flag for overflow.
                pub trait OverflowingAdd: Sized + Add<Self, Output = Self> {
                    /// Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_add(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingAdd, overflowing_add, u8);
                overflowing_impl!(OverflowingAdd, overflowing_add, u16);
                overflowing_impl!(OverflowingAdd, overflowing_add, u32);
                overflowing_impl!(OverflowingAdd, overflowing_add, u64);
                overflowing_impl!(OverflowingAdd, overflowing_add, usize);
                overflowing_impl!(OverflowingAdd, overflowing_add, u128);

                overflowing_impl!(OverflowingAdd, overflowing_add, i8);
                overflowing_impl!(OverflowingAdd, overflowing_add, i16);
                overflowing_impl!(OverflowingAdd, overflowing_add, i32);
                overflowing_impl!(OverflowingAdd, overflowing_add, i64);
                overflowing_impl!(OverflowingAdd, overflowing_add, isize);
                overflowing_impl!(OverflowingAdd, overflowing_add, i128);

                /// Performs substraction with a flag for overflow.
                pub trait OverflowingSub: Sized + Sub<Self, Output = Self> {
                    /// Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_sub(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingSub, overflowing_sub, u8);
                overflowing_impl!(OverflowingSub, overflowing_sub, u16);
                overflowing_impl!(OverflowingSub, overflowing_sub, u32);
                overflowing_impl!(OverflowingSub, overflowing_sub, u64);
                overflowing_impl!(OverflowingSub, overflowing_sub, usize);
                overflowing_impl!(OverflowingSub, overflowing_sub, u128);

                overflowing_impl!(OverflowingSub, overflowing_sub, i8);
                overflowing_impl!(OverflowingSub, overflowing_sub, i16);
                overflowing_impl!(OverflowingSub, overflowing_sub, i32);
                overflowing_impl!(OverflowingSub, overflowing_sub, i64);
                overflowing_impl!(OverflowingSub, overflowing_sub, isize);
                overflowing_impl!(OverflowingSub, overflowing_sub, i128);

                /// Performs multiplication with a flag for overflow.
                pub trait OverflowingMul: Sized + Mul<Self, Output = Self> {
                    /// Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_mul(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingMul, overflowing_mul, u8);
                overflowing_impl!(OverflowingMul, overflowing_mul, u16);
                overflowing_impl!(OverflowingMul, overflowing_mul, u32);
                overflowing_impl!(OverflowingMul, overflowing_mul, u64);
                overflowing_impl!(OverflowingMul, overflowing_mul, usize);
                overflowing_impl!(OverflowingMul, overflowing_mul, u128);

                overflowing_impl!(OverflowingMul, overflowing_mul, i8);
                overflowing_impl!(OverflowingMul, overflowing_mul, i16);
                overflowing_impl!(OverflowingMul, overflowing_mul, i32);
                overflowing_impl!(OverflowingMul, overflowing_mul, i64);
                overflowing_impl!(OverflowingMul, overflowing_mul, isize);
                overflowing_impl!(OverflowingMul, overflowing_mul, i128);
            }
            
            pub mod saturating
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use core::ops::{Add, Mul, Sub};
                */
                /// Saturating math operations. Deprecated, use `SaturatingAdd`, `SaturatingSub` and
                /// `SaturatingMul` instead.
                pub trait Saturating {
                    /// Saturating addition operator.
                    /// Returns a+b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_add(self, v: Self) -> Self;

                    /// Saturating subtraction operator.
                    /// Returns a-b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_sub(self, v: Self) -> Self;
                }

                macro_rules! deprecated_saturating_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            #[inline]
                            fn saturating_add(self, v: Self) -> Self {
                                Self::saturating_add(self, v)
                            }

                            #[inline]
                            fn saturating_sub(self, v: Self) -> Self {
                                Self::saturating_sub(self, v)
                            }
                        }
                    )*}
                }

                deprecated_saturating_impl!(Saturating for isize i8 i16 i32 i64 i128);
                deprecated_saturating_impl!(Saturating for usize u8 u16 u32 u64 u128);

                macro_rules! saturating_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                /// Performs addition that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingAdd: Sized + Add<Self, Output = Self> {
                    /// Saturating addition. Computes `self + other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_add(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingAdd, saturating_add, u8);
                saturating_impl!(SaturatingAdd, saturating_add, u16);
                saturating_impl!(SaturatingAdd, saturating_add, u32);
                saturating_impl!(SaturatingAdd, saturating_add, u64);
                saturating_impl!(SaturatingAdd, saturating_add, usize);
                saturating_impl!(SaturatingAdd, saturating_add, u128);

                saturating_impl!(SaturatingAdd, saturating_add, i8);
                saturating_impl!(SaturatingAdd, saturating_add, i16);
                saturating_impl!(SaturatingAdd, saturating_add, i32);
                saturating_impl!(SaturatingAdd, saturating_add, i64);
                saturating_impl!(SaturatingAdd, saturating_add, isize);
                saturating_impl!(SaturatingAdd, saturating_add, i128);

                /// Performs subtraction that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingSub: Sized + Sub<Self, Output = Self> {
                    /// Saturating subtraction. Computes `self - other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_sub(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingSub, saturating_sub, u8);
                saturating_impl!(SaturatingSub, saturating_sub, u16);
                saturating_impl!(SaturatingSub, saturating_sub, u32);
                saturating_impl!(SaturatingSub, saturating_sub, u64);
                saturating_impl!(SaturatingSub, saturating_sub, usize);
                saturating_impl!(SaturatingSub, saturating_sub, u128);

                saturating_impl!(SaturatingSub, saturating_sub, i8);
                saturating_impl!(SaturatingSub, saturating_sub, i16);
                saturating_impl!(SaturatingSub, saturating_sub, i32);
                saturating_impl!(SaturatingSub, saturating_sub, i64);
                saturating_impl!(SaturatingSub, saturating_sub, isize);
                saturating_impl!(SaturatingSub, saturating_sub, i128);

                /// Performs multiplication that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingMul: Sized + Mul<Self, Output = Self> {
                    /// Saturating multiplication. Computes `self * other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_mul(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingMul, saturating_mul, u8);
                saturating_impl!(SaturatingMul, saturating_mul, u16);
                saturating_impl!(SaturatingMul, saturating_mul, u32);
                saturating_impl!(SaturatingMul, saturating_mul, u64);
                saturating_impl!(SaturatingMul, saturating_mul, usize);
                saturating_impl!(SaturatingMul, saturating_mul, u128);

                saturating_impl!(SaturatingMul, saturating_mul, i8);
                saturating_impl!(SaturatingMul, saturating_mul, i16);
                saturating_impl!(SaturatingMul, saturating_mul, i32);
                saturating_impl!(SaturatingMul, saturating_mul, i64);
                saturating_impl!(SaturatingMul, saturating_mul, isize);
                saturating_impl!(SaturatingMul, saturating_mul, i128);
            }
            
            pub mod wrapping
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use core::num::Wrapping;
                    use core::ops::{Add, Mul, Neg, Shl, Shr, Sub};
                */
                macro_rules! wrapping_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                    ($trait_name:ident, $method:ident, $t:ty, $rhs:ty) => {
                        impl $trait_name<$rhs> for $t {
                            #[inline]
                            fn $method(&self, v: &$rhs) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                /// Performs addition that wraps around on overflow.
                pub trait WrappingAdd: Sized + Add<Self, Output = Self> {
                    /// Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of
                    /// the type.
                    fn wrapping_add(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingAdd, wrapping_add, u8);
                wrapping_impl!(WrappingAdd, wrapping_add, u16);
                wrapping_impl!(WrappingAdd, wrapping_add, u32);
                wrapping_impl!(WrappingAdd, wrapping_add, u64);
                wrapping_impl!(WrappingAdd, wrapping_add, usize);
                wrapping_impl!(WrappingAdd, wrapping_add, u128);

                wrapping_impl!(WrappingAdd, wrapping_add, i8);
                wrapping_impl!(WrappingAdd, wrapping_add, i16);
                wrapping_impl!(WrappingAdd, wrapping_add, i32);
                wrapping_impl!(WrappingAdd, wrapping_add, i64);
                wrapping_impl!(WrappingAdd, wrapping_add, isize);
                wrapping_impl!(WrappingAdd, wrapping_add, i128);

                /// Performs subtraction that wraps around on overflow.
                pub trait WrappingSub: Sized + Sub<Self, Output = Self> {
                    /// Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_sub(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingSub, wrapping_sub, u8);
                wrapping_impl!(WrappingSub, wrapping_sub, u16);
                wrapping_impl!(WrappingSub, wrapping_sub, u32);
                wrapping_impl!(WrappingSub, wrapping_sub, u64);
                wrapping_impl!(WrappingSub, wrapping_sub, usize);
                wrapping_impl!(WrappingSub, wrapping_sub, u128);

                wrapping_impl!(WrappingSub, wrapping_sub, i8);
                wrapping_impl!(WrappingSub, wrapping_sub, i16);
                wrapping_impl!(WrappingSub, wrapping_sub, i32);
                wrapping_impl!(WrappingSub, wrapping_sub, i64);
                wrapping_impl!(WrappingSub, wrapping_sub, isize);
                wrapping_impl!(WrappingSub, wrapping_sub, i128);

                /// Performs multiplication that wraps around on overflow.
                pub trait WrappingMul: Sized + Mul<Self, Output = Self> {
                    /// Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_mul(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingMul, wrapping_mul, u8);
                wrapping_impl!(WrappingMul, wrapping_mul, u16);
                wrapping_impl!(WrappingMul, wrapping_mul, u32);
                wrapping_impl!(WrappingMul, wrapping_mul, u64);
                wrapping_impl!(WrappingMul, wrapping_mul, usize);
                wrapping_impl!(WrappingMul, wrapping_mul, u128);

                wrapping_impl!(WrappingMul, wrapping_mul, i8);
                wrapping_impl!(WrappingMul, wrapping_mul, i16);
                wrapping_impl!(WrappingMul, wrapping_mul, i32);
                wrapping_impl!(WrappingMul, wrapping_mul, i64);
                wrapping_impl!(WrappingMul, wrapping_mul, isize);
                wrapping_impl!(WrappingMul, wrapping_mul, i128);

                macro_rules! wrapping_unary_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self) -> $t {
                                <$t>::$method(*self)
                            }
                        }
                    };
                }

                /// Performs a negation that does not panic.
                pub trait WrappingNeg: Sized {
                    /// Wrapping (modular) negation. Computes `-self`,
                    /// wrapping around at the boundary of the type.
                    ///
                    /// Since unsigned types do not have negative equivalents
                    /// all applications of this function will wrap (except for `-0`).
                    /// For values smaller than the corresponding signed type's maximum
                    /// the result is the same as casting the corresponding signed value.
                    /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where
                    /// `MAX` is the corresponding signed type's maximum.
                    ///
                    /// ```
                    /// use num_traits::WrappingNeg;
                    ///
                    /// assert_eq!(100i8.wrapping_neg(), -100);
                    /// assert_eq!((-100i8).wrapping_neg(), 100);
                    /// assert_eq!((-128i8).wrapping_neg(), -128);
                    /// ```
                    fn wrapping_neg(&self) -> Self;
                }

                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u8);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u16);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u32);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u64);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, usize);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u128);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i8);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i16);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i32);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i64);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, isize);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i128);

                macro_rules! wrapping_shift_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, rhs: u32) -> $t {
                                <$t>::$method(*self, rhs)
                            }
                        }
                    };
                }

                /// Performs a left shift that does not panic.
                pub trait WrappingShl: Sized + Shl<usize, Output = Self> {
                    /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    ///
                    /// ```
                    /// use num_traits::WrappingShl;
                    ///
                    /// let x: u16 = 0x0001;
                    ///
                    /// assert_eq!(WrappingShl::wrapping_shl(&x, 0),  0x0001);
                    /// assert_eq!(WrappingShl::wrapping_shl(&x, 1),  0x0002);
                    /// assert_eq!(WrappingShl::wrapping_shl(&x, 15), 0x8000);
                    /// assert_eq!(WrappingShl::wrapping_shl(&x, 16), 0x0001);
                    /// ```
                    fn wrapping_shl(&self, rhs: u32) -> Self;
                }

                wrapping_shift_impl!(WrappingShl, wrapping_shl, u8);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u16);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u32);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u64);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, usize);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u128);

                wrapping_shift_impl!(WrappingShl, wrapping_shl, i8);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i16);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i32);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i64);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, isize);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i128);

                /// Performs a right shift that does not panic.
                pub trait WrappingShr: Sized + Shr<usize, Output = Self> {
                    /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    ///
                    /// ```
                    /// use num_traits::WrappingShr;
                    ///
                    /// let x: u16 = 0x8000;
                    ///
                    /// assert_eq!(WrappingShr::wrapping_shr(&x, 0),  0x8000);
                    /// assert_eq!(WrappingShr::wrapping_shr(&x, 1),  0x4000);
                    /// assert_eq!(WrappingShr::wrapping_shr(&x, 15), 0x0001);
                    /// assert_eq!(WrappingShr::wrapping_shr(&x, 16), 0x8000);
                    /// ```
                    fn wrapping_shr(&self, rhs: u32) -> Self;
                }

                wrapping_shift_impl!(WrappingShr, wrapping_shr, u8);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u16);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u32);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u64);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, usize);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u128);

                wrapping_shift_impl!(WrappingShr, wrapping_shr, i8);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i16);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i32);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i64);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, isize);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i128);

               
                impl<T: WrappingAdd> WrappingAdd for Wrapping<T>
                where
                    Wrapping<T>: Add<Output = Wrapping<T>>,
                {
                    fn wrapping_add(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_add(&v.0))
                    }
                }
                impl<T: WrappingSub> WrappingSub for Wrapping<T>
                where
                    Wrapping<T>: Sub<Output = Wrapping<T>>,
                {
                    fn wrapping_sub(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_sub(&v.0))
                    }
                }
                impl<T: WrappingMul> WrappingMul for Wrapping<T>
                where
                    Wrapping<T>: Mul<Output = Wrapping<T>>,
                {
                    fn wrapping_mul(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_mul(&v.0))
                    }
                }
                impl<T: WrappingNeg> WrappingNeg for Wrapping<T>
                where
                    Wrapping<T>: Neg<Output = Wrapping<T>>,
                {
                    fn wrapping_neg(&self) -> Self {
                        Wrapping(self.0.wrapping_neg())
                    }
                }
                impl<T: WrappingShl> WrappingShl for Wrapping<T>
                where
                    Wrapping<T>: Shl<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shl(&self, rhs: u32) -> Self {
                        Wrapping(self.0.wrapping_shl(rhs))
                    }
                }
                impl<T: WrappingShr> WrappingShr for Wrapping<T>
                where
                    Wrapping<T>: Shr<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shr(&self, rhs: u32) -> Self {
                        Wrapping(self.0.wrapping_shr(rhs))
                    }
                }
            }
        } pub use self::ops::
        {
            bytes::{ FromBytes, ToBytes },
            checked::{ CheckedAdd, CheckedDiv, CheckedMul, CheckedNeg, CheckedRem, CheckedShl, CheckedShr, CheckedSub },
            euclid::{ CheckedEuclid, Euclid },
            inv::{ Inv },
            mul_add::{ MulAdd, MulAddAssign },
            saturating::{ Saturating, SaturatingAdd, SaturatingMul, SaturatingSub },
            wrapping::{ WrappingAdd, WrappingMul, WrappingNeg, WrappingShl, WrappingShr, WrappingSub },
        };

        pub mod pow
        {
            use ::
            {
                *,
            };
            /*
            use crate::{CheckedMul, One};
            use core::num::Wrapping;
            use core::ops::Mul;
            */
            /// Binary operator for raising a value to a power.
            pub trait Pow<RHS> {
                /// The result after applying the operator.
                type Output;

                /// Returns `self` to the power `rhs`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::Pow;
                /// assert_eq!(Pow::pow(10u32, 2u32), 100);
                /// ```
                fn pow(self, rhs: RHS) -> Self::Output;
            }

            macro_rules! pow_impl {
                ($t:ty) => {
                    pow_impl!($t, u8);
                    pow_impl!($t, usize);

                   
                   
                   
                   
                };
                ($t:ty, $rhs:ty) => {
                    pow_impl!($t, $rhs, usize, pow);
                };
                ($t:ty, $rhs:ty, $desired_rhs:ty, $method:expr) => {
                    impl Pow<$rhs> for $t {
                        type Output = $t;
                        #[inline]
                        fn pow(self, rhs: $rhs) -> $t {
                            ($method)(self, <$desired_rhs>::from(rhs))
                        }
                    }

                    impl<'a> Pow<&'a $rhs> for $t {
                        type Output = $t;
                        #[inline]
                        fn pow(self, rhs: &'a $rhs) -> $t {
                            ($method)(self, <$desired_rhs>::from(*rhs))
                        }
                    }

                    impl<'a> Pow<$rhs> for &'a $t {
                        type Output = $t;
                        #[inline]
                        fn pow(self, rhs: $rhs) -> $t {
                            ($method)(*self, <$desired_rhs>::from(rhs))
                        }
                    }

                    impl<'a, 'b> Pow<&'a $rhs> for &'b $t {
                        type Output = $t;
                        #[inline]
                        fn pow(self, rhs: &'a $rhs) -> $t {
                            ($method)(*self, <$desired_rhs>::from(*rhs))
                        }
                    }
                };
            }

            pow_impl!(u8, u8, u32, u8::pow);
            pow_impl!(u8, u16, u32, u8::pow);
            pow_impl!(u8, u32, u32, u8::pow);
            pow_impl!(u8, usize);
            pow_impl!(i8, u8, u32, i8::pow);
            pow_impl!(i8, u16, u32, i8::pow);
            pow_impl!(i8, u32, u32, i8::pow);
            pow_impl!(i8, usize);
            pow_impl!(u16, u8, u32, u16::pow);
            pow_impl!(u16, u16, u32, u16::pow);
            pow_impl!(u16, u32, u32, u16::pow);
            pow_impl!(u16, usize);
            pow_impl!(i16, u8, u32, i16::pow);
            pow_impl!(i16, u16, u32, i16::pow);
            pow_impl!(i16, u32, u32, i16::pow);
            pow_impl!(i16, usize);
            pow_impl!(u32, u8, u32, u32::pow);
            pow_impl!(u32, u16, u32, u32::pow);
            pow_impl!(u32, u32, u32, u32::pow);
            pow_impl!(u32, usize);
            pow_impl!(i32, u8, u32, i32::pow);
            pow_impl!(i32, u16, u32, i32::pow);
            pow_impl!(i32, u32, u32, i32::pow);
            pow_impl!(i32, usize);
            pow_impl!(u64, u8, u32, u64::pow);
            pow_impl!(u64, u16, u32, u64::pow);
            pow_impl!(u64, u32, u32, u64::pow);
            pow_impl!(u64, usize);
            pow_impl!(i64, u8, u32, i64::pow);
            pow_impl!(i64, u16, u32, i64::pow);
            pow_impl!(i64, u32, u32, i64::pow);
            pow_impl!(i64, usize);

            pow_impl!(u128, u8, u32, u128::pow);
            pow_impl!(u128, u16, u32, u128::pow);
            pow_impl!(u128, u32, u32, u128::pow);
            pow_impl!(u128, usize);

            pow_impl!(i128, u8, u32, i128::pow);
            pow_impl!(i128, u16, u32, i128::pow);
            pow_impl!(i128, u32, u32, i128::pow);
            pow_impl!(i128, usize);

            pow_impl!(usize, u8, u32, usize::pow);
            pow_impl!(usize, u16, u32, usize::pow);
            pow_impl!(usize, u32, u32, usize::pow);
            pow_impl!(usize, usize);
            pow_impl!(isize, u8, u32, isize::pow);
            pow_impl!(isize, u16, u32, isize::pow);
            pow_impl!(isize, u32, u32, isize::pow);
            pow_impl!(isize, usize);
            pow_impl!(Wrapping<u8>);
            pow_impl!(Wrapping<i8>);
            pow_impl!(Wrapping<u16>);
            pow_impl!(Wrapping<i16>);
            pow_impl!(Wrapping<u32>);
            pow_impl!(Wrapping<i32>);
            pow_impl!(Wrapping<u64>);
            pow_impl!(Wrapping<i64>);
            pow_impl!(Wrapping<u128>);
            pow_impl!(Wrapping<i128>);
            pow_impl!(Wrapping<usize>);
            pow_impl!(Wrapping<isize>);

           
           
           
           
           
           
           
           
           
           
           

            #[cfg(any(feature = "std", feature = "libm"))]
            mod float_impls {
                use super::Pow;
                use crate::Float;

                pow_impl!(f32, i8, i32, <f32 as Float>::powi);
                pow_impl!(f32, u8, i32, <f32 as Float>::powi);
                pow_impl!(f32, i16, i32, <f32 as Float>::powi);
                pow_impl!(f32, u16, i32, <f32 as Float>::powi);
                pow_impl!(f32, i32, i32, <f32 as Float>::powi);
                pow_impl!(f64, i8, i32, <f64 as Float>::powi);
                pow_impl!(f64, u8, i32, <f64 as Float>::powi);
                pow_impl!(f64, i16, i32, <f64 as Float>::powi);
                pow_impl!(f64, u16, i32, <f64 as Float>::powi);
                pow_impl!(f64, i32, i32, <f64 as Float>::powi);
                pow_impl!(f32, f32, f32, <f32 as Float>::powf);
                pow_impl!(f64, f32, f64, <f64 as Float>::powf);
                pow_impl!(f64, f64, f64, <f64 as Float>::powf);
            }
            /// Raises a value to the power of exp, using exponentiation by squaring.
            ///
            /// assert_eq!(pow(2i8, 4), 16);
            /// assert_eq!(pow(6u8, 3), 216);
            /// assert_eq!(pow(0u8, 0), 1);
            /// ```
            #[inline]
            pub fn pow<T: Clone + One + Mul<T, Output = T>>(mut base: T, mut exp: usize) -> T {
                if exp == 0 {
                    return T::one();
                }

                while exp & 1 == 0 {
                    base = base.clone() * base;
                    exp >>= 1;
                }
                if exp == 1 {
                    return base;
                }

                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.clone() * base;
                    if exp & 1 == 1 {
                        acc = acc * base.clone();
                    }
                }
                acc
            }
            /// Raises a value to the power of exp, returning `None` if an overflow occurred.
            ///
            /// # Example
            ///
            /// ```rust
            /// use num_traits::checked_pow;
            ///
            /// assert_eq!(checked_pow(2i8, 4), Some(16));
            /// assert_eq!(checked_pow(7i8, 8), None);
            /// assert_eq!(checked_pow(7u32, 8), Some(5_764_801));
            /// assert_eq!(checked_pow(0u32, 0), Some(1));
            /// ```
            #[inline]
            pub fn checked_pow<T: Clone + One + CheckedMul>(mut base: T, mut exp: usize) -> Option<T> {
                if exp == 0 {
                    return Some(T::one());
                }

                while exp & 1 == 0 {
                    base = base.checked_mul(&base)?;
                    exp >>= 1;
                }
                if exp == 1 {
                    return Some(base);
                }

                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.checked_mul(&base)?;
                    if exp & 1 == 1 {
                        acc = acc.checked_mul(&base)?;
                    }
                }
                Some(acc)
            }

        } pub use self::pow::{checked_pow, pow, Pow};

        pub mod real
        {
            use ::
            {
                *,
            };
            /*	
                use core::ops::Neg;
                use crate::{Float, Num, NumCast};
            */
            /// A trait for real number types that do not necessarily have
            /// floating-point-specific characteristics such as NaN and infinity.
            ///
            /// This trait is only available with the `std` feature, or with the `libm` feature otherwise.
            pub trait Real: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {
                /// Returns the smallest finite value that this type can represent.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x: f64 = Real::min_value();
                ///
                /// assert_eq!(x, f64::MIN);
                /// ```
                fn min_value() -> Self;

                /// Returns the smallest positive, normalized value that this type can represent.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x: f64 = Real::min_positive_value();
                ///
                /// assert_eq!(x, f64::MIN_POSITIVE);
                /// ```
                fn min_positive_value() -> Self;

                /// Returns epsilon, a small positive value.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x: f64 = Real::epsilon();
                ///
                /// assert_eq!(x, f64::EPSILON);
                /// ```
                ///
                /// # Panics
                ///
                /// The default implementation will panic if `f32::EPSILON` cannot
                /// be cast to `Self`.
                fn epsilon() -> Self;

                /// Returns the largest finite value that this type can represent.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x: f64 = Real::max_value();
                /// assert_eq!(x, f64::MAX);
                /// ```
                fn max_value() -> Self;

                /// Returns the largest integer less than or equal to a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 3.99;
                /// let g = 3.0;
                ///
                /// assert_eq!(f.floor(), 3.0);
                /// assert_eq!(g.floor(), 3.0);
                /// ```
                fn floor(self) -> Self;

                /// Returns the smallest integer greater than or equal to a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 3.01;
                /// let g = 4.0;
                ///
                /// assert_eq!(f.ceil(), 4.0);
                /// assert_eq!(g.ceil(), 4.0);
                /// ```
                fn ceil(self) -> Self;

                /// Returns the nearest integer to a number. Round half-way cases away from
                /// `0.0`.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 3.3;
                /// let g = -3.3;
                ///
                /// assert_eq!(f.round(), 3.0);
                /// assert_eq!(g.round(), -3.0);
                /// ```
                fn round(self) -> Self;

                /// Return the integer part of a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 3.3;
                /// let g = -3.7;
                ///
                /// assert_eq!(f.trunc(), 3.0);
                /// assert_eq!(g.trunc(), -3.0);
                /// ```
                fn trunc(self) -> Self;

                /// Returns the fractional part of a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 3.5;
                /// let y = -3.5;
                /// let abs_difference_x = (x.fract() - 0.5).abs();
                /// let abs_difference_y = (y.fract() - (-0.5)).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                /// ```
                fn fract(self) -> Self;

                /// Computes the absolute value of `self`. Returns `Float::nan()` if the
                /// number is `Float::nan()`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x = 3.5;
                /// let y = -3.5;
                ///
                /// let abs_difference_x = (x.abs() - x).abs();
                /// let abs_difference_y = (y.abs() - (-y)).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                ///
                /// assert!(::num_traits::Float::is_nan(f64::NAN.abs()));
                /// ```
                fn abs(self) -> Self;

                /// Returns a number that represents the sign of `self`.
                ///
                /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`
                /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`
                /// - `Float::nan()` if the number is `Float::nan()`
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let f = 3.5;
                ///
                /// assert_eq!(f.signum(), 1.0);
                /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);
                ///
                /// assert!(f64::NAN.signum().is_nan());
                /// ```
                fn signum(self) -> Self;

                /// Returns `true` if `self` is positive, including `+0.0`,
                /// `Float::infinity()`, and with newer versions of Rust `f64::NAN`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let neg_nan: f64 = -f64::NAN;
                ///
                /// let f = 7.0;
                /// let g = -7.0;
                ///
                /// assert!(f.is_sign_positive());
                /// assert!(!g.is_sign_positive());
                /// assert!(!neg_nan.is_sign_positive());
                /// ```
                fn is_sign_positive(self) -> bool;

                /// Returns `true` if `self` is negative, including `-0.0`,
                /// `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let nan: f64 = f64::NAN;
                ///
                /// let f = 7.0;
                /// let g = -7.0;
                ///
                /// assert!(!f.is_sign_negative());
                /// assert!(g.is_sign_negative());
                /// assert!(!nan.is_sign_negative());
                /// ```
                fn is_sign_negative(self) -> bool;

                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                ///
                /// Using `mul_add` can be more performant than an unfused multiply-add if
                /// the target architecture has a dedicated `fma` CPU instruction.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let m = 10.0;
                /// let x = 4.0;
                /// let b = 60.0;
                ///
                ///
                /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn mul_add(self, a: Self, b: Self) -> Self;

                /// Take the reciprocal (inverse) of a number, `1/x`.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.recip() - (1.0/x)).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn recip(self) -> Self;

                /// Raise a number to an integer power.
                ///
                /// Using this function is generally faster than using `powf`
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.powi(2) - x*x).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn powi(self, n: i32) -> Self;

                /// Raise a number to a real number power.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.powf(2.0) - x*x).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn powf(self, n: Self) -> Self;

                /// Take the square root of a number.
                ///
                /// Returns NaN if `self` is a negative floating-point number.
                ///
                /// # Panics
                ///
                /// If the implementing type doesn't support NaN, this method should panic if `self < 0`.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let positive = 4.0;
                /// let negative = -4.0;
                ///
                /// let abs_difference = (positive.sqrt() - 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// assert!(::num_traits::Float::is_nan(negative.sqrt()));
                /// ```
                fn sqrt(self) -> Self;

                /// Returns `e^(self)`, (the exponential function).
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let one = 1.0;
                ///
                /// let e = one.exp();
                ///
                ///
                /// let abs_difference = (e.ln() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp(self) -> Self;

                /// Returns `2^(self)`.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 2.0;
                ///
                ///
                /// let abs_difference = (f.exp2() - 4.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp2(self) -> Self;

                /// Returns the natural logarithm of the number.
                ///
                /// # Panics
                ///
                /// If `self <= 0` and this type does not support a NaN representation, this function should panic.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let one = 1.0;
                ///
                /// let e = one.exp();
                ///
                ///
                /// let abs_difference = (e.ln() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn ln(self) -> Self;

                /// Returns the logarithm of the number with respect to an arbitrary base.
                ///
                /// # Panics
                ///
                /// If `self <= 0` and this type does not support a NaN representation, this function should panic.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let ten = 10.0;
                /// let two = 2.0;
                ///
                ///
                /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();
                ///
                ///
                /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();
                ///
                /// assert!(abs_difference_10 < 1e-10);
                /// assert!(abs_difference_2 < 1e-10);
                /// ```
                fn log(self, base: Self) -> Self;

                /// Returns the base 2 logarithm of the number.
                ///
                /// # Panics
                ///
                /// If `self <= 0` and this type does not support a NaN representation, this function should panic.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let two = 2.0;
                ///
                ///
                /// let abs_difference = (two.log2() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn log2(self) -> Self;

                /// Returns the base 10 logarithm of the number.
                ///
                /// # Panics
                ///
                /// If `self <= 0` and this type does not support a NaN representation, this function should panic.
                ///
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let ten = 10.0;
                ///
                ///
                /// let abs_difference = (ten.log10() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn log10(self) -> Self;

                /// Converts radians to degrees.
                ///
                /// ```
                /// use std::f64::consts;
                ///
                /// let angle = consts::PI;
                ///
                /// let abs_difference = (angle.to_degrees() - 180.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn to_degrees(self) -> Self;

                /// Converts degrees to radians.
                ///
                /// ```
                /// use std::f64::consts;
                ///
                /// let angle = 180.0_f64;
                ///
                /// let abs_difference = (angle.to_radians() - consts::PI).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn to_radians(self) -> Self;

                /// Returns the maximum of the two numbers.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                ///
                /// assert_eq!(x.max(y), y);
                /// ```
                fn max(self, other: Self) -> Self;

                /// Returns the minimum of the two numbers.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                ///
                /// assert_eq!(x.min(y), x);
                /// ```
                fn min(self, other: Self) -> Self;

                /// The positive difference of two numbers.
                ///
                /// * If `self <= other`: `0:0`
                /// * Else: `self - other`
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 3.0;
                /// let y = -3.0;
                ///
                /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();
                /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                /// ```
                fn abs_sub(self, other: Self) -> Self;

                /// Take the cubic root of a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 8.0;
                ///
                ///
                /// let abs_difference = (x.cbrt() - 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn cbrt(self) -> Self;

                /// Calculate the length of the hypotenuse of a right-angle triangle given
                /// legs of length `x` and `y`.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 2.0;
                /// let y = 3.0;
                ///
                ///
                /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn hypot(self, other: Self) -> Self;

                /// Computes the sine of a number (in radians).
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x = f64::consts::PI/2.0;
                ///
                /// let abs_difference = (x.sin() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn sin(self) -> Self;

                /// Computes the cosine of a number (in radians).
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x = 2.0*f64::consts::PI;
                ///
                /// let abs_difference = (x.cos() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn cos(self) -> Self;

                /// Computes the tangent of a number (in radians).
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x = f64::consts::PI/4.0;
                /// let abs_difference = (x.tan() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-14);
                /// ```
                fn tan(self) -> Self;

                /// Computes the arcsine of a number. Return value is in radians in
                /// the range [-pi/2, pi/2] or NaN if the number is outside the range
                /// [-1, 1].
                ///
                /// # Panics
                ///
                /// If this type does not support a NaN representation, this function should panic
                /// if the number is outside the range [-1, 1].
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let f = f64::consts::PI / 2.0;
                ///
                ///
                /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn asin(self) -> Self;

                /// Computes the arccosine of a number. Return value is in radians in
                /// the range [0, pi] or NaN if the number is outside the range
                /// [-1, 1].
                ///
                /// # Panics
                ///
                /// If this type does not support a NaN representation, this function should panic
                /// if the number is outside the range [-1, 1].
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let f = f64::consts::PI / 4.0;
                ///
                ///
                /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn acos(self) -> Self;

                /// Computes the arctangent of a number. Return value is in radians in the
                /// range [-pi/2, pi/2];
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 1.0;
                ///
                ///
                /// let abs_difference = (f.tan().atan() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn atan(self) -> Self;

                /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).
                ///
                /// * `x = 0`, `y = 0`: `0`
                /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`
                /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`
                /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let pi = f64::consts::PI;
                ///
                ///
                /// let x1 = 3.0;
                /// let y1 = -3.0;
                ///
                ///
                /// let x2 = -3.0;
                /// let y2 = 3.0;
                ///
                /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();
                /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();
                ///
                /// assert!(abs_difference_1 < 1e-10);
                /// assert!(abs_difference_2 < 1e-10);
                /// ```
                fn atan2(self, other: Self) -> Self;

                /// Simultaneously computes the sine and cosine of the number, `x`. Returns
                /// `(sin(x), cos(x))`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x = f64::consts::PI/4.0;
                /// let f = x.sin_cos();
                ///
                /// let abs_difference_0 = (f.0 - x.sin()).abs();
                /// let abs_difference_1 = (f.1 - x.cos()).abs();
                ///
                /// assert!(abs_difference_0 < 1e-10);
                /// assert!(abs_difference_0 < 1e-10);
                /// ```
                fn sin_cos(self) -> (Self, Self);

                /// Returns `e^(self) - 1` in a way that is accurate even if the
                /// number is close to zero.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 7.0;
                ///
                ///
                /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp_m1(self) -> Self;

                /// Returns `ln(1+n)` (natural logarithm) more accurately than if
                /// the operations were performed separately.
                ///
                /// # Panics
                ///
                /// If this type does not support a NaN representation, this function should panic
                /// if `self-1 <= 0`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let x = f64::consts::E - 1.0;
                ///
                ///
                /// let abs_difference = (x.ln_1p() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn ln_1p(self) -> Self;

                /// Hyperbolic sine function.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                ///
                /// let f = x.sinh();
                ///
                /// let g = (e*e - 1.0)/(2.0*e);
                /// let abs_difference = (f - g).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn sinh(self) -> Self;

                /// Hyperbolic cosine function.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                /// let f = x.cosh();
                ///
                /// let g = (e*e + 1.0)/(2.0*e);
                /// let abs_difference = (f - g).abs();
                ///
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn cosh(self) -> Self;

                /// Hyperbolic tangent function.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                ///
                /// let f = x.tanh();
                ///
                /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));
                /// let abs_difference = (f - g).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn tanh(self) -> Self;

                /// Inverse hyperbolic sine function.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 1.0;
                /// let f = x.sinh().asinh();
                ///
                /// let abs_difference = (f - x).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn asinh(self) -> Self;

                /// Inverse hyperbolic cosine function.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 1.0;
                /// let f = x.cosh().acosh();
                ///
                /// let abs_difference = (f - x).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn acosh(self) -> Self;

                /// Inverse hyperbolic tangent function.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use std::f64;
                ///
                /// let e = f64::consts::E;
                /// let f = e.tanh().atanh();
                ///
                /// let abs_difference = (f - e).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn atanh(self) -> Self;
            }

            impl<T: Float> Real for T {
                forward! {
                    Float::min_value() -> Self;
                    Float::min_positive_value() -> Self;
                    Float::epsilon() -> Self;
                    Float::max_value() -> Self;
                }
                forward! {
                    Float::floor(self) -> Self;
                    Float::ceil(self) -> Self;
                    Float::round(self) -> Self;
                    Float::trunc(self) -> Self;
                    Float::fract(self) -> Self;
                    Float::abs(self) -> Self;
                    Float::signum(self) -> Self;
                    Float::is_sign_positive(self) -> bool;
                    Float::is_sign_negative(self) -> bool;
                    Float::mul_add(self, a: Self, b: Self) -> Self;
                    Float::recip(self) -> Self;
                    Float::powi(self, n: i32) -> Self;
                    Float::powf(self, n: Self) -> Self;
                    Float::sqrt(self) -> Self;
                    Float::exp(self) -> Self;
                    Float::exp2(self) -> Self;
                    Float::ln(self) -> Self;
                    Float::log(self, base: Self) -> Self;
                    Float::log2(self) -> Self;
                    Float::log10(self) -> Self;
                    Float::to_degrees(self) -> Self;
                    Float::to_radians(self) -> Self;
                    Float::max(self, other: Self) -> Self;
                    Float::min(self, other: Self) -> Self;
                    Float::abs_sub(self, other: Self) -> Self;
                    Float::cbrt(self) -> Self;
                    Float::hypot(self, other: Self) -> Self;
                    Float::sin(self) -> Self;
                    Float::cos(self) -> Self;
                    Float::tan(self) -> Self;
                    Float::asin(self) -> Self;
                    Float::acos(self) -> Self;
                    Float::atan(self) -> Self;
                    Float::atan2(self, other: Self) -> Self;
                    Float::sin_cos(self) -> (Self, Self);
                    Float::exp_m1(self) -> Self;
                    Float::ln_1p(self) -> Self;
                    Float::sinh(self) -> Self;
                    Float::cosh(self) -> Self;
                    Float::tanh(self) -> Self;
                    Float::asinh(self) -> Self;
                    Float::acosh(self) -> Self;
                    Float::atanh(self) -> Self;
                }
            }

        }

        pub mod sign
        {
            use ::
            {
                *,
            };
            /*
                use core::num::Wrapping;
                use core::ops::Neg;

                use crate::float::FloatCore;
                use crate::Num;
            */
            /// Useful functions for signed numbers (i.e. numbers that can be negative).
            pub trait Signed: Sized + Num + Neg<Output = Self>
            {
                /// Computes the absolute value.
                ///
                /// For `f32` and `f64`, `NaN` will be returned if the number is `NaN`.
                ///
                /// For signed integers, `::MIN` will be returned if the number is `::MIN`.
                fn abs(&self) -> Self;

                /// The positive difference of two numbers.
                ///
                /// Returns `zero` if the number is less than or equal to `other`, otherwise the difference
                /// between `self` and `other` is returned.
                fn abs_sub(&self, other: &Self) -> Self;

                /// Returns the sign of the number.
                ///
                /// For `f32` and `f64`:
                ///
                /// * `1.0` if the number is positive, `+0.0` or `INFINITY`
                /// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
                /// * `NaN` if the number is `NaN`
                ///
                /// For signed integers:
                ///
                /// * `0` if the number is zero
                /// * `1` if the number is positive
                /// * `-1` if the number is negative
                fn signum(&self) -> Self;

                /// Returns true if the number is positive and false if the number is zero or negative.
                fn is_positive(&self) -> bool;

                /// Returns true if the number is negative and false if the number is zero or positive.
                fn is_negative(&self) -> bool;
            }

            macro_rules! signed_impl {
                ($($t:ty)*) => ($(
                    impl Signed for $t {
                        #[inline]
                        fn abs(&self) -> $t {
                            if self.is_negative() { -*self } else { *self }
                        }

                        #[inline]
                        fn abs_sub(&self, other: &$t) -> $t {
                            if *self <= *other { 0 } else { *self - *other }
                        }

                        #[inline]
                        fn signum(&self) -> $t {
                            match *self {
                                n if n > 0 => 1,
                                0 => 0,
                                _ => -1,
                            }
                        }

                        #[inline]
                        fn is_positive(&self) -> bool { *self > 0 }

                        #[inline]
                        fn is_negative(&self) -> bool { *self < 0 }
                    }
                )*)
            }

            signed_impl!(isize i8 i16 i32 i64 i128);

            impl<T: Signed> Signed for Wrapping<T>
            where
                Wrapping<T>: Num + Neg<Output = Wrapping<T>>,
            {
                #[inline]
                fn abs(&self) -> Self {
                    Wrapping(self.0.abs())
                }

                #[inline]
                fn abs_sub(&self, other: &Self) -> Self {
                    Wrapping(self.0.abs_sub(&other.0))
                }

                #[inline]
                fn signum(&self) -> Self {
                    Wrapping(self.0.signum())
                }

                #[inline]
                fn is_positive(&self) -> bool {
                    self.0.is_positive()
                }

                #[inline]
                fn is_negative(&self) -> bool {
                    self.0.is_negative()
                }
            }

            macro_rules! signed_float_impl {
                ($t:ty) => {
                    impl Signed for $t {
                        /// Computes the absolute value. Returns `NAN` if the number is `NAN`.
                        #[inline]
                        fn abs(&self) -> $t {
                            FloatCore::abs(*self)
                        }

                        /// The positive difference of two numbers. Returns `0.0` if the number is
                        /// less than or equal to `other`, otherwise the difference between`self`
                        /// and `other` is returned.
                        #[inline]
                        fn abs_sub(&self, other: &$t) -> $t {
                            if *self <= *other {
                                0.
                            } else {
                                *self - *other
                            }
                        }

                        /// # Returns
                        ///
                        /// - `1.0` if the number is positive, `+0.0` or `INFINITY`
                        /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
                        /// - `NAN` if the number is NaN
                        #[inline]
                        fn signum(&self) -> $t {
                            FloatCore::signum(*self)
                        }

                        /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`
                        #[inline]
                        fn is_positive(&self) -> bool {
                            FloatCore::is_sign_positive(*self)
                        }

                        /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`
                        #[inline]
                        fn is_negative(&self) -> bool {
                            FloatCore::is_sign_negative(*self)
                        }
                    }
                };
            }

            signed_float_impl!(f32);
            signed_float_impl!(f64);
            /// Computes the absolute value.
            #[inline( always )] pub fn abs<T: Signed>(value: T) -> T {
                value.abs()
            }
            /// The positive difference of two numbers.
            #[inline( always )] pub fn abs_sub<T: Signed>(x: T, y: T) -> T {
                x.abs_sub(&y)
            }
            /// Returns the sign of the number.
            #[inline( always )] pub fn signum<T: Signed>(value: T) -> T {
                value.signum()
            }
            /// A trait for values which cannot be negative
            pub trait Unsigned: Num {}

            macro_rules! empty_trait_impl
            {
                ($name:ident for $($t:ty)*) => ($(
                    impl $name for $t {}
                )*)
            }

            empty_trait_impl!(Unsigned for usize u8 u16 u32 u64 u128);

            impl<T: Unsigned> Unsigned for Wrapping<T> where Wrapping<T>: Num {}
        } pub use self::sign::{abs, abs_sub, signum, Signed, Unsigned};

        /// The base trait for numeric types, covering `0` and `1` values,
        /// comparisons, basic numeric operations, and string conversion.
        pub trait Num: PartialEq + Zero + One + NumOps
        {
            type FromStrRadixErr;

            /// Convert from a string and radix (typically `2..=36`).
            /// use num_traits::Num;
            ///
            /// let result = <i32 as Num>::from_str_radix("27", 10);
            /// assert_eq!(result, Ok(27));
            ///
            /// let result = <i32 as Num>::from_str_radix("foo", 10);
            /// assert!(result.is_err());
            /// ```
            ///
            /// # Supported radices
            ///
            /// The exact range of supported radices is at the discretion of each type implementation. For
            /// primitive integers, this is implemented by the inherent `from_str_radix` methods in the
            /// standard library, which **panic** if the radix is not in the range from 2 to 36. The
            /// implementation in this crate for primitive floats is similar.
            /// It's possible that a type might not even support the common radix 10, nor any, if string
            /// parsing doesn't make sense for that type.
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr>;
        }
        /// Generic trait for types implementing basic numeric operations
        ///
        /// This is automatically implemented for types which implement the operators.
        pub trait NumOps<Rhs = Self, Output = Self>:
            Add<Rhs, Output = Output>
            + Sub<Rhs, Output = Output>
            + Mul<Rhs, Output = Output>
            + Div<Rhs, Output = Output>
            + Rem<Rhs, Output = Output>
        {
        }

        impl<T, Rhs, Output> NumOps<Rhs, Output> for T where
            T: Add<Rhs, Output = Output>
                + Sub<Rhs, Output = Output>
                + Mul<Rhs, Output = Output>
                + Div<Rhs, Output = Output>
                + Rem<Rhs, Output = Output>
        {
        }
        /// The trait for `Num` types which also implement numeric operations taking
        /// the second operand by reference.
        ///
        /// This is automatically implemented for types which implement the operators.
        pub trait NumRef: Num + for<'r> NumOps<&'r Self> {}
        impl<T> NumRef for T where T: Num + for<'r> NumOps<&'r T> {}
        /// The trait for `Num` references which implement numeric operations, taking the
        /// second operand either by value or by reference.
        ///
        /// This is automatically implemented for all types which implement the operators. It covers
        /// every type implementing the operations though, regardless of it being a reference or
        /// related to `Num`.
        pub trait RefNum<Base>: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        impl<T, Base> RefNum<Base> for T where T: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        /// Generic trait for types implementing numeric assignment operators (like `+=`).
        ///
        /// This is automatically implemented for types which implement the operators.
        pub trait NumAssignOps<Rhs = Self>:
        AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }

        impl<T, Rhs> NumAssignOps<Rhs> for T where
            T: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }
        /// The trait for `Num` types which also implement assignment operators.
        ///
        /// This is automatically implemented for types which implement the operators.
        pub trait NumAssign: Num + NumAssignOps {}
        impl<T> NumAssign for T where T: Num + NumAssignOps {}
        /// The trait for `NumAssign` types which also implement assignment operations
        /// taking the second operand by reference.
        ///
        /// This is automatically implemented for types which implement the operators.
        pub trait NumAssignRef: NumAssign + for<'r> NumAssignOps<&'r Self> {}
        impl<T> NumAssignRef for T where T: NumAssign + for<'r> NumAssignOps<&'r T> {}

        macro_rules! int_trait_impl {
            ($name:ident for $($t:ty)*) => ($(
                impl $name for $t {
                    type FromStrRadixErr = ::core::num::ParseIntError;
                    #[inline]
                    fn from_str_radix(s: &str, radix: u32)
                                    -> Result<Self, ::core::num::ParseIntError>
                    {
                        <$t>::from_str_radix(s, radix)
                    }
                }
            )*)
        }
        int_trait_impl!(Num for usize u8 u16 u32 u64 u128);
        int_trait_impl!(Num for isize i8 i16 i32 i64 i128);

        impl<T: Num> Num for Wrapping<T>
        where
            Wrapping<T>: NumOps,
        {
            type FromStrRadixErr = T::FromStrRadixErr;
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> {
                T::from_str_radix(str, radix).map(Wrapping)
            }
        }

        #[cfg(has_num_saturating)]
        impl<T: Num> Num for core::num::Saturating<T>
        where
            core::num::Saturating<T>: NumOps,
        {
            type FromStrRadixErr = T::FromStrRadixErr;
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> {
                T::from_str_radix(str, radix).map(core::num::Saturating)
            }
        }

        #[derive(Debug)]
        pub enum FloatErrorKind {
            Empty,
            Invalid,
        }
       
       
        #[derive(Debug)]
        pub struct ParseFloatError {
            pub kind: FloatErrorKind,
        }

        impl fmt::Display for ParseFloatError {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                let description = match self.kind {
                    FloatErrorKind::Empty => "cannot parse float from empty string",
                    FloatErrorKind::Invalid => "invalid float literal",
                };

                description.fmt(f)
            }
        }

        fn str_to_ascii_lower_eq_str(a: &str, b: &str) -> bool {
            a.len() == b.len()
                && a.bytes().zip(b.bytes()).all(|(a, b)| {
                    let a_to_ascii_lower = a | (((b'A' <= a && a <= b'Z') as u8) << 5);
                    a_to_ascii_lower == b
                })
        }

       
       
       
        macro_rules! float_trait_impl {
            ($name:ident for $($t:ident)*) => ($(
                impl $name for $t {
                    type FromStrRadixErr = ParseFloatError;

                    fn from_str_radix(src: &str, radix: u32)
                                    -> Result<Self, Self::FromStrRadixErr>
                    {
                        use self::FloatErrorKind::*;
                        use self::ParseFloatError as PFE;

                       
                        if radix == 10 {
                            return src.parse().map_err(|_| PFE {
                                kind: if src.is_empty() { Empty } else { Invalid },
                            });
                        }

                       
                        if str_to_ascii_lower_eq_str(src, "inf")
                            || str_to_ascii_lower_eq_str(src, "infinity")
                        {
                            return Ok(core::$t::INFINITY);
                        } else if str_to_ascii_lower_eq_str(src, "-inf")
                            || str_to_ascii_lower_eq_str(src, "-infinity")
                        {
                            return Ok(core::$t::NEG_INFINITY);
                        } else if str_to_ascii_lower_eq_str(src, "nan") {
                            return Ok(core::$t::NAN);
                        } else if str_to_ascii_lower_eq_str(src, "-nan") {
                            return Ok(-core::$t::NAN);
                        }

                        fn slice_shift_char(src: &str) -> Option<(char, &str)> {
                            let mut chars = src.chars();
                            Some((chars.next()?, chars.as_str()))
                        }

                        let (is_positive, src) =  match slice_shift_char(src) {
                            None             => return Err(PFE { kind: Empty }),
                            Some(('-', ""))  => return Err(PFE { kind: Empty }),
                            Some(('-', src)) => (false, src),
                            Some((_, _))     => (true,  src),
                        };

                       
                        let mut sig = if is_positive { 0.0 } else { -0.0 };
                       
                        let mut prev_sig = sig;
                        let mut cs = src.chars().enumerate();
                       
                        let mut exp_info = None::<(char, usize)>;

                       
                        for (i, c) in cs.by_ref() {
                            match c.to_digit(radix) {
                                Some(digit) => {
                                   
                                    sig *= radix as $t;

                                   
                                    if is_positive {
                                        sig += (digit as isize) as $t;
                                    } else {
                                        sig -= (digit as isize) as $t;
                                    }

                                   
                                   
                                    if prev_sig != 0.0 {
                                        if is_positive && sig <= prev_sig
                                            { return Ok(core::$t::INFINITY); }
                                        if !is_positive && sig >= prev_sig
                                            { return Ok(core::$t::NEG_INFINITY); }

                                       
                                        if is_positive && (prev_sig != (sig - digit as $t) / radix as $t)
                                            { return Ok(core::$t::INFINITY); }
                                        if !is_positive && (prev_sig != (sig + digit as $t) / radix as $t)
                                            { return Ok(core::$t::NEG_INFINITY); }
                                    }
                                    prev_sig = sig;
                                },
                                None => match c {
                                    'e' | 'E' | 'p' | 'P' => {
                                        exp_info = Some((c, i + 1));
                                        break; 
                                    },
                                    '.' => {
                                        break; 
                                    },
                                    _ => {
                                        return Err(PFE { kind: Invalid });
                                    },
                                },
                            }
                        }

                       
                       
                        if exp_info.is_none() {
                            let mut power = 1.0;
                            for (i, c) in cs.by_ref() {
                                match c.to_digit(radix) {
                                    Some(digit) => {
                                       
                                        power /= radix as $t;
                                       
                                        sig = if is_positive {
                                            sig + (digit as $t) * power
                                        } else {
                                            sig - (digit as $t) * power
                                        };
                                       
                                        if is_positive && sig < prev_sig
                                            { return Ok(core::$t::INFINITY); }
                                        if !is_positive && sig > prev_sig
                                            { return Ok(core::$t::NEG_INFINITY); }
                                        prev_sig = sig;
                                    },
                                    None => match c {
                                        'e' | 'E' | 'p' | 'P' => {
                                            exp_info = Some((c, i + 1));
                                            break;
                                        },
                                        _ => {
                                            return Err(PFE { kind: Invalid });
                                        },
                                    },
                                }
                            }
                        }

                       
                        let exp = match exp_info {
                            Some((c, offset)) => {
                                let base = match c {
                                    'E' | 'e' if radix == 10 => 10.0,
                                    'P' | 'p' if radix == 16 => 2.0,
                                    _ => return Err(PFE { kind: Invalid }),
                                };

                               
                                let src = &src[offset..];
                                let (is_positive, exp) = match slice_shift_char(src) {
                                    Some(('-', src)) => (false, src.parse::<usize>()),
                                    Some(('+', src)) => (true,  src.parse::<usize>()),
                                    Some((_, _))     => (true,  src.parse::<usize>()),
                                    None             => return Err(PFE { kind: Invalid }),
                                };

                                #[cfg(feature = "std")]
                                fn pow(base: $t, exp: usize) -> $t {
                                    Float::powi(base, exp as i32)
                                }
                               

                                match (is_positive, exp) {
                                    (true,  Ok(exp)) => pow(base, exp),
                                    (false, Ok(exp)) => 1.0 / pow(base, exp),
                                    (_, Err(_))      => return Err(PFE { kind: Invalid }),
                                }
                            },
                            None => 1.0,
                        };

                        Ok(sig * exp)
                    }
                }
            )*)
        }
        float_trait_impl!(Num for f32 f64);

        /// A value bounded by a minimum and a maximum
        ///
        ///  If input is less than min then this returns min.
        ///  If input is greater than max then this returns max.
        ///  Otherwise this returns input.
        ///
        /// **Panics** in debug mode if `!(min <= max)`.
        #[inline]
        pub fn clamp<T: PartialOrd>(input: T, min: T, max: T) -> T {
            debug_assert!(min <= max, "min must be less than or equal to max");
            if input < min {
                min
            } else if input > max {
                max
            } else {
                input
            }
        }
        /// A value bounded by a minimum value
        ///
        ///  If input is less than min then this returns min.
        ///  Otherwise this returns input.
        ///  `clamp_min(std::f32::NAN, 1.0)` preserves `NAN` different from `f32::min(std::f32::NAN, 1.0)`.
        ///
        /// **Panics** in debug mode if `!(min == min)`. (This occurs if `min` is `NAN`.)
        #[inline]
        #[allow(clippy::eq_op)]
        pub fn clamp_min<T: PartialOrd>(input: T, min: T) -> T {
            debug_assert!(min == min, "min must not be NAN");
            if input < min {
                min
            } else {
                input
            }
        }
        /// A value bounded by a maximum value
        ///
        ///  If input is greater than max then this returns max.
        ///  Otherwise this returns input.
        ///  `clamp_max(std::f32::NAN, 1.0)` preserves `NAN` different from `f32::max(std::f32::NAN, 1.0)`.
        ///
        /// **Panics** in debug mode if `!(max == max)`. (This occurs if `max` is `NAN`.)
        #[inline]
        #[allow(clippy::eq_op)]
        pub fn clamp_max<T: PartialOrd>(input: T, max: T) -> T {
            debug_assert!(max == max, "max must not be NAN");
            if input > max {
                max
            } else {
                input
            }
        }
    }
    /*
    */
    pub mod integers
    {
        //! Integer trait and functions.
        use ::
        {
            *,
        };
        /*
        #![doc(html_root_url = "https://docs.rs/num-integer/0.1")]
        #![no_std]

        use core::mem;
        use core::ops::Add;

        use num_traits::{Num, Signed, Zero}; 

        mod roots;
        pub use crate::roots::Roots;
        pub use crate::roots::{cbrt, nth_root, sqrt};

        mod average;
        pub use crate::average::Average;
        pub use crate::average::{average_ceil, average_floor}; */
        pub mod average
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            use crate::Integer;
            use core::ops::{BitAnd, BitOr, BitXor, Shr};
            */
            /// Provides methods to compute the average of two integers, without overflows.
            pub trait Average: Integer {
                /// Returns the ceiling value of the average of `self` and `other`.
                /// -- `⌈(self + other)/2⌉`
                ///
                /// # Examples
                ///
                /// ```
                /// use num_integer::Average;
                ///
                /// assert_eq!(( 3).average_ceil(&10),  7);
                /// assert_eq!((-2).average_ceil(&-5), -3);
                /// assert_eq!(( 4).average_ceil(& 4),  4);
                ///
                /// assert_eq!(u8::max_value().average_ceil(&2), 129);
                /// assert_eq!(i8::min_value().average_ceil(&-1), -64);
                /// assert_eq!(i8::min_value().average_ceil(&i8::max_value()), 0);
                /// ```
                ///
                fn average_ceil(&self, other: &Self) -> Self;

                /// Returns the floor value of the average of `self` and `other`.
                /// -- `⌊(self + other)/2⌋`
                ///
                /// # Examples
                ///
                /// ```
                /// use num_integer::Average;
                ///
                /// assert_eq!(( 3).average_floor(&10),  6);
                /// assert_eq!((-2).average_floor(&-5), -4);
                /// assert_eq!(( 4).average_floor(& 4),  4);
                ///
                /// assert_eq!(u8::max_value().average_floor(&2), 128);
                /// assert_eq!(i8::min_value().average_floor(&-1), -65);
                /// assert_eq!(i8::min_value().average_floor(&i8::max_value()), -1);
                /// ```
                ///
                fn average_floor(&self, other: &Self) -> Self;
            }

            impl<I> Average for I
            where
                I: Integer + Shr<usize, Output = I>,
                for<'a, 'b> &'a I:
                    BitAnd<&'b I, Output = I> + BitOr<&'b I, Output = I> + BitXor<&'b I, Output = I>,
            {
               
               

                /// Returns the floor value of the average of `self` and `other`.
                #[inline]
                fn average_floor(&self, other: &I) -> I {
                    (self & other) + ((self ^ other) >> 1)
                }

                /// Returns the ceil value of the average of `self` and `other`.
                #[inline]
                fn average_ceil(&self, other: &I) -> I {
                    (self | other) - ((self ^ other) >> 1)
                }
            }
            /// Returns the floor value of the average of `x` and `y` --
            /// see [Average::average_floor](trait.Average.html#tymethod.average_floor).
            #[inline]
            pub fn average_floor<T: Average>(x: T, y: T) -> T {
                x.average_floor(&y)
            }
            /// Returns the ceiling value of the average of `x` and `y` --
            /// see [Average::average_ceil](trait.Average.html#tymethod.average_ceil).
            #[inline]
            pub fn average_ceil<T: Average>(x: T, y: T) -> T {
                x.average_ceil(&y)
            }
        }

        pub mod roots
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            use crate::Integer;
            use core::mem;
            use num_traits::{checked_pow, PrimInt};
            */
            /// Provides methods to compute an integer's square root, cube root,
            /// and arbitrary `n`th root.
            pub trait Roots: Integer {
                /// Returns the truncated principal `n`th root of an integer
                /// -- `if x >= 0 { ⌊ⁿ√x⌋ } else { ⌈ⁿ√x⌉ }`
                ///
                /// This is solving for `r` in `rⁿ = x`, rounding toward zero.
                /// If `x` is positive, the result will satisfy `rⁿ ≤ x < (r+1)ⁿ`.
                /// If `x` is negative and `n` is odd, then `(r-1)ⁿ < x ≤ rⁿ`.
                ///
                /// # Panics
                ///
                /// Panics if `n` is zero:
                ///
                /// ```should_panic
                /// # use num_integer::Roots;
                /// println!("can't compute ⁰√x : {}", 123.nth_root(0));
                /// ```
                ///
                /// or if `n` is even and `self` is negative:
                ///
                /// ```should_panic
                /// # use num_integer::Roots;
                /// println!("no imaginary numbers... {}", (-1).nth_root(10));
                /// ```
                ///
                /// # Examples
                ///
                /// ```
                /// use num_integer::Roots;
                ///
                /// let x: i32 = 12345;
                /// assert_eq!(x.nth_root(1), x);
                /// assert_eq!(x.nth_root(2), x.sqrt());
                /// assert_eq!(x.nth_root(3), x.cbrt());
                /// assert_eq!(x.nth_root(4), 10);
                /// assert_eq!(x.nth_root(13), 2);
                /// assert_eq!(x.nth_root(14), 1);
                /// assert_eq!(x.nth_root(std::u32::MAX), 1);
                ///
                /// assert_eq!(std::i32::MAX.nth_root(30), 2);
                /// assert_eq!(std::i32::MAX.nth_root(31), 1);
                /// assert_eq!(std::i32::MIN.nth_root(31), -2);
                /// assert_eq!((std::i32::MIN + 1).nth_root(31), -1);
                ///
                /// assert_eq!(std::u32::MAX.nth_root(31), 2);
                /// assert_eq!(std::u32::MAX.nth_root(32), 1);
                /// ```
                fn nth_root(&self, n: u32) -> Self;

                /// Returns the truncated principal square root of an integer -- `⌊√x⌋`
                ///
                /// This is solving for `r` in `r² = x`, rounding toward zero.
                /// The result will satisfy `r² ≤ x < (r+1)²`.
                ///
                /// # Panics
                ///
                /// Panics if `self` is less than zero:
                ///
                /// ```should_panic
                /// # use num_integer::Roots;
                /// println!("no imaginary numbers... {}", (-1).sqrt());
                /// ```
                ///
                /// # Examples
                ///
                /// ```
                /// use num_integer::Roots;
                ///
                /// let x: i32 = 12345;
                /// assert_eq!((x * x).sqrt(), x);
                /// assert_eq!((x * x + 1).sqrt(), x);
                /// assert_eq!((x * x - 1).sqrt(), x - 1);
                /// ```
                #[inline]
                fn sqrt(&self) -> Self {
                    self.nth_root(2)
                }

                /// Returns the truncated principal cube root of an integer --
                /// `if x >= 0 { ⌊∛x⌋ } else { ⌈∛x⌉ }`
                ///
                /// This is solving for `r` in `r³ = x`, rounding toward zero.
                /// If `x` is positive, the result will satisfy `r³ ≤ x < (r+1)³`.
                /// If `x` is negative, then `(r-1)³ < x ≤ r³`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_integer::Roots;
                ///
                /// let x: i32 = 1234;
                /// assert_eq!((x * x * x).cbrt(), x);
                /// assert_eq!((x * x * x + 1).cbrt(), x);
                /// assert_eq!((x * x * x - 1).cbrt(), x - 1);
                ///
                /// assert_eq!((-(x * x * x)).cbrt(), -x);
                /// assert_eq!((-(x * x * x + 1)).cbrt(), -x);
                /// assert_eq!((-(x * x * x - 1)).cbrt(), -(x - 1));
                /// ```
                #[inline]
                fn cbrt(&self) -> Self {
                    self.nth_root(3)
                }
            }
            /// Returns the truncated principal square root of an integer --
            /// see [Roots::sqrt](trait.Roots.html#method.sqrt).
            #[inline]
            pub fn sqrt<T: Roots>(x: T) -> T {
                x.sqrt()
            }
            /// Returns the truncated principal cube root of an integer --
            /// see [Roots::cbrt](trait.Roots.html#method.cbrt).
            #[inline]
            pub fn cbrt<T: Roots>(x: T) -> T {
                x.cbrt()
            }
            /// Returns the truncated principal `n`th root of an integer --
            /// see [Roots::nth_root](trait.Roots.html#tymethod.nth_root).
            #[inline]
            pub fn nth_root<T: Roots>(x: T, n: u32) -> T {
                x.nth_root(n)
            }

            macro_rules! signed_roots {
                ($T:ty, $U:ty) => {
                    impl Roots for $T {
                        #[inline]
                        fn nth_root(&self, n: u32) -> Self {
                            if *self >= 0 {
                                (*self as $U).nth_root(n) as Self
                            } else {
                                assert!(n.is_odd(), "even roots of a negative are imaginary");
                                -((self.wrapping_neg() as $U).nth_root(n) as Self)
                            }
                        }

                        #[inline]
                        fn sqrt(&self) -> Self {
                            assert!(*self >= 0, "the square root of a negative is imaginary");
                            (*self as $U).sqrt() as Self
                        }

                        #[inline]
                        fn cbrt(&self) -> Self {
                            if *self >= 0 {
                                (*self as $U).cbrt() as Self
                            } else {
                                -((self.wrapping_neg() as $U).cbrt() as Self)
                            }
                        }
                    }
                };
            }

            signed_roots!(i8, u8);
            signed_roots!(i16, u16);
            signed_roots!(i32, u32);
            signed_roots!(i64, u64);
            signed_roots!(i128, u128);
            signed_roots!(isize, usize);

            #[inline]
            fn fixpoint<T, F>(mut x: T, f: F) -> T
            where
                T: Integer + Copy,
                F: Fn(T) -> T,
            {
                let mut xn = f(x);
                while x < xn {
                    x = xn;
                    xn = f(x);
                }
                while x > xn {
                    x = xn;
                    xn = f(x);
                }
                x
            }

            #[inline]
            fn bits<T>() -> u32 {
                8 * mem::size_of::<T>() as u32
            }

            #[inline]
            fn log2<T: PrimInt>(x: T) -> u32 {
                debug_assert!(x > T::zero());
                bits::<T>() - 1 - x.leading_zeros()
            }

            macro_rules! unsigned_roots {
                ($T:ident) => {
                    impl Roots for $T {
                        #[inline]
                        fn nth_root(&self, n: u32) -> Self {
                            fn go(a: $T, n: u32) -> $T {
                               
                                match n {
                                    0 => panic!("can't find a root of degree 0!"),
                                    1 => return a,
                                    2 => return a.sqrt(),
                                    3 => return a.cbrt(),
                                    _ => (),
                                }

                               
                                if bits::<$T>() <= n || a < (1 << n) {
                                    return (a > 0) as $T;
                                }

                                if bits::<$T>() > 64 {
                                   
                                    return if a <= core::u64::MAX as $T {
                                        (a as u64).nth_root(n) as $T
                                    } else {
                                        let lo = (a >> n).nth_root(n) << 1;
                                        let hi = lo + 1;
                                       
                                       
                                        if hi.next_power_of_two().trailing_zeros() * n >= bits::<$T>() {
                                            match checked_pow(hi, n as usize) {
                                                Some(x) if x <= a => hi,
                                                _ => lo,
                                            }
                                        } else {
                                            if hi.pow(n) <= a {
                                                hi
                                            } else {
                                                lo
                                            }
                                        }
                                    };
                                }

                                #[cfg(feature = "std")]
                                #[inline]
                                fn guess(x: $T, n: u32) -> $T {
                                   
                                    if bits::<$T>() <= 32 || x <= core::u32::MAX as $T {
                                        1 << ((log2(x) + n - 1) / n)
                                    } else {
                                        ((x as f64).ln() / f64::from(n)).exp() as $T
                                    }
                                }

                                #[cfg(not(feature = "std"))]
                                #[inline]
                                fn guess(x: $T, n: u32) -> $T {
                                    1 << ((log2(x) + n - 1) / n)
                                }

                               
                                let n1 = n - 1;
                                let next = |x: $T| {
                                    let y = match checked_pow(x, n1 as usize) {
                                        Some(ax) => a / ax,
                                        None => 0,
                                    };
                                    (y + x * n1 as $T) / n as $T
                                };
                                fixpoint(guess(a, n), next)
                            }
                            go(*self, n)
                        }

                        #[inline]
                        fn sqrt(&self) -> Self {
                            fn go(a: $T) -> $T {
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= core::u64::MAX as $T {
                                        (a as u64).sqrt() as $T
                                    } else {
                                        let lo = (a >> 2u32).sqrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }

                                if a < 4 {
                                    return (a > 0) as $T;
                                }

                                #[cfg(feature = "std")]
                                #[inline]
                                fn guess(x: $T) -> $T {
                                    (x as f64).sqrt() as $T
                                }

                                #[cfg(not(feature = "std"))]
                                #[inline]
                                fn guess(x: $T) -> $T {
                                    1 << ((log2(x) + 1) / 2)
                                }

                               
                                let next = |x: $T| (a / x + x) >> 1;
                                fixpoint(guess(a), next)
                            }
                            go(*self)
                        }

                        #[inline]
                        fn cbrt(&self) -> Self {
                            fn go(a: $T) -> $T {
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= core::u64::MAX as $T {
                                        (a as u64).cbrt() as $T
                                    } else {
                                        let lo = (a >> 3u32).cbrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }

                                if bits::<$T>() <= 32 {
                                   
                                    let mut x = a;
                                    let mut y2 = 0;
                                    let mut y = 0;
                                    let smax = bits::<$T>() / 3;
                                    for s in (0..smax + 1).rev() {
                                        let s = s * 3;
                                        y2 *= 4;
                                        y *= 2;
                                        let b = 3 * (y2 + y) + 1;
                                        if x >> s >= b {
                                            x -= b << s;
                                            y2 += 2 * y + 1;
                                            y += 1;
                                        }
                                    }
                                    return y;
                                }

                                if a < 8 {
                                    return (a > 0) as $T;
                                }
                                if a <= core::u32::MAX as $T {
                                    return (a as u32).cbrt() as $T;
                                }

                                #[cfg(feature = "std")]
                                #[inline]
                                fn guess(x: $T) -> $T {
                                    (x as f64).cbrt() as $T
                                }

                                #[cfg(not(feature = "std"))]
                                #[inline]
                                fn guess(x: $T) -> $T {
                                    1 << ((log2(x) + 2) / 3)
                                }

                               
                                let next = |x: $T| (a / (x * x) + x * 2) / 3;
                                fixpoint(guess(a), next)
                            }
                            go(*self)
                        }
                    }
                };
            }

            unsigned_roots!(u8);
            unsigned_roots!(u16);
            unsigned_roots!(u32);
            unsigned_roots!(u64);
            unsigned_roots!(u128);
            unsigned_roots!(usize);
        }

        pub trait Integer: Sized + Num + PartialOrd + Ord + Eq {
            /// Floored integer division.
            /// # use num_integer::Integer;
            /// assert!(( 8).div_floor(& 3) ==  2);
            /// assert!(( 8).div_floor(&-3) == -3);
            /// assert!((-8).div_floor(& 3) == -3);
            /// assert!((-8).div_floor(&-3) ==  2);
            ///
            /// assert!(( 1).div_floor(& 2) ==  0);
            /// assert!(( 1).div_floor(&-2) == -1);
            /// assert!((-1).div_floor(& 2) == -1);
            /// assert!((-1).div_floor(&-2) ==  0);
            /// ~~~
            fn div_floor(&self, other: &Self) -> Self;

            /// Floored integer modulo, satisfying:
            ///
            /// ~~~
            /// # use num_integer::Integer;
            /// # let n = 1; let d = 1;
            /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)
            /// ~~~
            ///
            /// # Examples
            ///
            /// ~~~
            /// # use num_integer::Integer;
            /// assert!(( 8).mod_floor(& 3) ==  2);
            /// assert!(( 8).mod_floor(&-3) == -1);
            /// assert!((-8).mod_floor(& 3) ==  1);
            /// assert!((-8).mod_floor(&-3) == -2);
            ///
            /// assert!(( 1).mod_floor(& 2) ==  1);
            /// assert!(( 1).mod_floor(&-2) == -1);
            /// assert!((-1).mod_floor(& 2) ==  1);
            /// assert!((-1).mod_floor(&-2) == -1);
            /// ~~~
            fn mod_floor(&self, other: &Self) -> Self;

            /// Ceiled integer division.
            /// # use num_integer::Integer;
            /// assert_eq!(( 8).div_ceil( &3),  3);
            /// assert_eq!(( 8).div_ceil(&-3), -2);
            /// assert_eq!((-8).div_ceil( &3), -2);
            /// assert_eq!((-8).div_ceil(&-3),  3);
            ///
            /// assert_eq!(( 1).div_ceil( &2), 1);
            /// assert_eq!(( 1).div_ceil(&-2), 0);
            /// assert_eq!((-1).div_ceil( &2), 0);
            /// assert_eq!((-1).div_ceil(&-2), 1);
            /// ~~~
            fn div_ceil(&self, other: &Self) -> Self {
                let (q, r) = self.div_mod_floor(other);
                if r.is_zero() {
                    q
                } else {
                    q + Self::one()
                }
            }
            /// Greatest Common Divisor (GCD).
            /// # use num_integer::Integer;
            /// assert_eq!(6.gcd(&8), 2);
            /// assert_eq!(7.gcd(&3), 1);
            /// ~~~
            fn gcd(&self, other: &Self) -> Self;

            /// Lowest Common Multiple (LCM).
            /// # use num_integer::Integer;
            /// assert_eq!(7.lcm(&3), 21);
            /// assert_eq!(2.lcm(&4), 4);
            /// assert_eq!(0.lcm(&0), 0);
            /// ~~~
            fn lcm(&self, other: &Self) -> Self;

            /// Greatest Common Divisor (GCD) and
            /// Lowest Common Multiple (LCM) together.
            /// # use num_integer::Integer;
            /// assert_eq!(10.gcd_lcm(&4), (2, 20));
            /// assert_eq!(8.gcd_lcm(&9), (1, 72));
            /// ~~~
            #[inline]
            fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                (self.gcd(other), self.lcm(other))
            }
            /// Greatest common divisor and Bézout coefficients.
            /// # fn main() {
            /// # use num_integer::{ExtendedGcd, Integer};
            /// # use num_traits::NumAssign;
            /// fn check<A: Copy + Integer + NumAssign>(a: A, b: A) -> bool {
            ///     let ExtendedGcd { gcd, x, y, .. } = a.extended_gcd(&b);
            ///     gcd == x * a + y * b
            /// }
            /// assert!(check(10isize, 4isize));
            /// assert!(check(8isize,  9isize));
            /// # }
            /// ~~~
            #[inline]
            fn extended_gcd(&self, other: &Self) -> ExtendedGcd<Self>
            where
                Self: Clone,
            {
                let mut s = (Self::zero(), Self::one());
                let mut t = (Self::one(), Self::zero());
                let mut r = (other.clone(), self.clone());

                while !r.0.is_zero() {
                    let q = r.1.clone() / r.0.clone();
                    let f = |mut r: (Self, Self)| {
                        mem::swap(&mut r.0, &mut r.1);
                        r.0 = r.0 - q.clone() * r.1.clone();
                        r
                    };
                    r = f(r);
                    s = f(s);
                    t = f(t);
                }

                if r.1 >= Self::zero() {
                    ExtendedGcd {
                        gcd: r.1,
                        x: s.1,
                        y: t.1,
                    }
                } else {
                    ExtendedGcd {
                        gcd: Self::zero() - r.1,
                        x: Self::zero() - s.1,
                        y: Self::zero() - t.1,
                    }
                }
            }
            /// Greatest common divisor, least common multiple, and Bézout coefficients.
            #[inline]
            fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self)
            where
                Self: Clone + Signed,
            {
                (self.extended_gcd(other), self.lcm(other))
            }
            /// Deprecated, use `is_multiple_of` instead.
            #[deprecated(note = "Please use is_multiple_of instead")]
            #[inline]
            fn divides(&self, other: &Self) -> bool {
                self.is_multiple_of(other)
            }
            /// Returns `true` if `self` is a multiple of `other`.
            /// # use num_integer::Integer;
            /// assert_eq!(9.is_multiple_of(&3), true);
            /// assert_eq!(3.is_multiple_of(&9), false);
            /// ~~~
            fn is_multiple_of(&self, other: &Self) -> bool;

            /// Returns `true` if the number is even.
            /// # use num_integer::Integer;
            /// assert_eq!(3.is_even(), false);
            /// assert_eq!(4.is_even(), true);
            /// ~~~
            fn is_even(&self) -> bool;

            /// Returns `true` if the number is odd.
            /// # use num_integer::Integer;
            /// assert_eq!(3.is_odd(), true);
            /// assert_eq!(4.is_odd(), false);
            /// ~~~
            fn is_odd(&self) -> bool;

            /// Simultaneous truncated integer division and modulus.
            /// Returns `(quotient, remainder)`.
            /// # use num_integer::Integer;
            /// assert_eq!(( 8).div_rem( &3), ( 2,  2));
            /// assert_eq!(( 8).div_rem(&-3), (-2,  2));
            /// assert_eq!((-8).div_rem( &3), (-2, -2));
            /// assert_eq!((-8).div_rem(&-3), ( 2, -2));
            ///
            /// assert_eq!(( 1).div_rem( &2), ( 0,  1));
            /// assert_eq!(( 1).div_rem(&-2), ( 0,  1));
            /// assert_eq!((-1).div_rem( &2), ( 0, -1));
            /// assert_eq!((-1).div_rem(&-2), ( 0, -1));
            /// ~~~
            fn div_rem(&self, other: &Self) -> (Self, Self);
            /// Simultaneous floored integer division and modulus.
            /// Returns `(quotient, remainder)`.
            /// # use num_integer::Integer;
            /// assert_eq!(( 8).div_mod_floor( &3), ( 2,  2));
            /// assert_eq!(( 8).div_mod_floor(&-3), (-3, -1));
            /// assert_eq!((-8).div_mod_floor( &3), (-3,  1));
            /// assert_eq!((-8).div_mod_floor(&-3), ( 2, -2));
            ///
            /// assert_eq!(( 1).div_mod_floor( &2), ( 0,  1));
            /// assert_eq!(( 1).div_mod_floor(&-2), (-1, -1));
            /// assert_eq!((-1).div_mod_floor( &2), (-1,  1));
            /// assert_eq!((-1).div_mod_floor(&-2), ( 0, -1));
            /// ~~~
            fn div_mod_floor(&self, other: &Self) -> (Self, Self) {
                (self.div_floor(other), self.mod_floor(other))
            }
            /// Rounds up to nearest multiple of argument.
            ///
            /// # Examples
            ///
            /// ~~~
            /// # use num_integer::Integer;
            /// assert_eq!(( 16).next_multiple_of(& 8),  16);
            /// assert_eq!(( 23).next_multiple_of(& 8),  24);
            /// assert_eq!(( 16).next_multiple_of(&-8),  16);
            /// assert_eq!(( 23).next_multiple_of(&-8),  16);
            /// assert_eq!((-16).next_multiple_of(& 8), -16);
            /// assert_eq!((-23).next_multiple_of(& 8), -16);
            /// assert_eq!((-16).next_multiple_of(&-8), -16);
            /// assert_eq!((-23).next_multiple_of(&-8), -24);
            /// ~~~
            #[inline]
            fn next_multiple_of(&self, other: &Self) -> Self
            where
                Self: Clone,
            {
                let m = self.mod_floor(other);
                self.clone()
                    + if m.is_zero() {
                        Self::zero()
                    } else {
                        other.clone() - m
                    }
            }
            /// Rounds down to nearest multiple of argument.
            ///
            /// # Examples
            ///
            /// ~~~
            /// # use num_integer::Integer;
            /// assert_eq!(( 16).prev_multiple_of(& 8),  16);
            /// assert_eq!(( 23).prev_multiple_of(& 8),  16);
            /// assert_eq!(( 16).prev_multiple_of(&-8),  16);
            /// assert_eq!(( 23).prev_multiple_of(&-8),  24);
            /// assert_eq!((-16).prev_multiple_of(& 8), -16);
            /// assert_eq!((-23).prev_multiple_of(& 8), -24);
            /// assert_eq!((-16).prev_multiple_of(&-8), -16);
            /// assert_eq!((-23).prev_multiple_of(&-8), -16);
            /// ~~~
            #[inline]
            fn prev_multiple_of(&self, other: &Self) -> Self
            where
                Self: Clone,
            {
                self.clone() - self.mod_floor(other)
            }
            /// Decrements self by one.
            /// # use num_integer::Integer;
            /// let mut x: i32 = 43;
            /// x.dec();
            /// assert_eq!(x, 42);
            /// ~~~
            fn dec(&mut self)
            where
                Self: Clone,
            {
                *self = self.clone() - Self::one()
            }
            /// Increments self by one.
            /// # use num_integer::Integer;
            /// let mut x: i32 = 41;
            /// x.inc();
            /// assert_eq!(x, 42);
            /// ~~~
            fn inc(&mut self)
            where
                Self: Clone,
            {
                *self = self.clone() + Self::one()
            }
        }
        /// Greatest common divisor and Bézout coefficients
        ///
        /// ```no_build
        /// let e = isize::extended_gcd(a, b);
        /// assert_eq!(e.gcd, e.x*a + e.y*b);
        /// ```
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        pub struct ExtendedGcd<A> {
            pub gcd: A,
            pub x: A,
            pub y: A,
        }
        /// Simultaneous integer division and modulus
        #[inline]
        pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) {
            x.div_rem(&y)
        }
        /// Floored integer division
        #[inline]
        pub fn div_floor<T: Integer>(x: T, y: T) -> T {
            x.div_floor(&y)
        }
        /// Floored integer modulus
        #[inline]
        pub fn mod_floor<T: Integer>(x: T, y: T) -> T {
            x.mod_floor(&y)
        }
        /// Simultaneous floored integer division and modulus
        #[inline]
        pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) {
            x.div_mod_floor(&y)
        }
        /// Ceiled integer division
        #[inline]
        pub fn div_ceil<T: Integer>(x: T, y: T) -> T {
            x.div_ceil(&y)
        }
        /// Calculates the Greatest Common Divisor (GCD) of the number and `other`. The
        /// result is always non-negative.
        #[inline(always)]
        pub fn gcd<T: Integer>(x: T, y: T) -> T {
            x.gcd(&y)
        }
        /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
        #[inline(always)]
        pub fn lcm<T: Integer>(x: T, y: T) -> T {
            x.lcm(&y)
        }
        /// Calculates the Greatest Common Divisor (GCD) and
        /// Lowest Common Multiple (LCM) of the number and `other`.
        #[inline(always)]
        pub fn gcd_lcm<T: Integer>(x: T, y: T) -> (T, T) {
            x.gcd_lcm(&y)
        }

        macro_rules! impl_integer_for_isize {
            ($T:ty, $test_mod:ident) => {
                impl Integer for $T {
                    /// Floored integer division
                    #[inline]
                    fn div_floor(&self, other: &Self) -> Self {
                       
                       
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            d - 1
                        } else {
                            d
                        }
                    }

                    /// Floored integer modulo
                    #[inline]
                    fn mod_floor(&self, other: &Self) -> Self {
                       
                       
                        let r = *self % *other;
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            r + *other
                        } else {
                            r
                        }
                    }

                    /// Calculates `div_floor` and `mod_floor` simultaneously
                    #[inline]
                    fn div_mod_floor(&self, other: &Self) -> (Self, Self) {
                       
                       
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            (d - 1, r + *other)
                        } else {
                            (d, r)
                        }
                    }

                    #[inline]
                    fn div_ceil(&self, other: &Self) -> Self {
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other > 0) || (r < 0 && *other < 0) {
                            d + 1
                        } else {
                            d
                        }
                    }

                    /// Calculates the Greatest Common Divisor (GCD) of the number and
                    /// `other`. The result is always non-negative.
                    #[inline]
                    fn gcd(&self, other: &Self) -> Self {
                       
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return (m | n).abs();
                        }

                       
                        let shift = (m | n).trailing_zeros();

                       
                       
                       
                       

                       
                       
                       
                        if m == Self::min_value() || n == Self::min_value() {
                            return (1 << shift).abs();
                        }

                       
                        m = m.abs();
                        n = n.abs();

                       
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }

                    #[inline]
                    fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) {
                        let egcd = self.extended_gcd(other);
                       
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            (*self * (*other / egcd.gcd)).abs()
                        };
                        (egcd, lcm)
                    }

                    /// Calculates the Lowest Common Multiple (LCM) of the number and
                    /// `other`.
                    #[inline]
                    fn lcm(&self, other: &Self) -> Self {
                        self.gcd_lcm(other).1
                    }

                    /// Calculates the Greatest Common Divisor (GCD) and
                    /// Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline]
                    fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                        if self.is_zero() && other.is_zero() {
                            return (Self::zero(), Self::zero());
                        }
                        let gcd = self.gcd(other);
                       
                        let lcm = (*self * (*other / gcd)).abs();
                        (gcd, lcm)
                    }

                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline]
                    fn is_multiple_of(&self, other: &Self) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    /// Returns `true` if the number is divisible by `2`
                    #[inline]
                    fn is_even(&self) -> bool {
                        (*self) & 1 == 0
                    }

                    /// Returns `true` if the number is not divisible by `2`
                    #[inline]
                    fn is_odd(&self) -> bool {
                        !self.is_even()
                    }

                    /// Simultaneous truncated integer division and modulus.
                    #[inline]
                    fn div_rem(&self, other: &Self) -> (Self, Self) {
                        (*self / *other, *self % *other)
                    }

                    /// Rounds up to nearest multiple of argument.
                    #[inline]
                    fn next_multiple_of(&self, other: &Self) -> Self {
                       
                        if *other == -1 {
                            return *self;
                        }

                        let m = Integer::mod_floor(self, other);
                        *self + if m == 0 { 0 } else { other - m }
                    }

                    /// Rounds down to nearest multiple of argument.
                    #[inline]
                    fn prev_multiple_of(&self, other: &Self) -> Self {
                       
                        if *other == -1 {
                            return *self;
                        }

                        *self - Integer::mod_floor(self, other)
                    }
                }
            };
        }

        impl_integer_for_isize!(i8, test_integer_i8);
        impl_integer_for_isize!(i16, test_integer_i16);
        impl_integer_for_isize!(i32, test_integer_i32);
        impl_integer_for_isize!(i64, test_integer_i64);
        impl_integer_for_isize!(i128, test_integer_i128);
        impl_integer_for_isize!(isize, test_integer_isize);

        macro_rules! impl_integer_for_usize {
            ($T:ty, $test_mod:ident) => {
                impl Integer for $T {
                    /// Unsigned integer division. Returns the same result as `div` (`/`).
                    #[inline]
                    fn div_floor(&self, other: &Self) -> Self {
                        *self / *other
                    }

                    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).
                    #[inline]
                    fn mod_floor(&self, other: &Self) -> Self {
                        *self % *other
                    }

                    #[inline]
                    fn div_ceil(&self, other: &Self) -> Self {
                        *self / *other + (0 != *self % *other) as Self
                    }

                    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`
                    #[inline]
                    fn gcd(&self, other: &Self) -> Self {
                       
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return m | n;
                        }

                       
                        let shift = (m | n).trailing_zeros();

                       
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }

                    #[inline]
                    fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) {
                        let egcd = self.extended_gcd(other);
                       
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            *self * (*other / egcd.gcd)
                        };
                        (egcd, lcm)
                    }

                    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline]
                    fn lcm(&self, other: &Self) -> Self {
                        self.gcd_lcm(other).1
                    }

                    /// Calculates the Greatest Common Divisor (GCD) and
                    /// Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline]
                    fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                        if self.is_zero() && other.is_zero() {
                            return (Self::zero(), Self::zero());
                        }
                        let gcd = self.gcd(other);
                        let lcm = *self * (*other / gcd);
                        (gcd, lcm)
                    }

                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline]
                    fn is_multiple_of(&self, other: &Self) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    /// Returns `true` if the number is divisible by `2`.
                    #[inline]
                    fn is_even(&self) -> bool {
                        *self % 2 == 0
                    }

                    /// Returns `true` if the number is not divisible by `2`.
                    #[inline]
                    fn is_odd(&self) -> bool {
                        !self.is_even()
                    }

                    /// Simultaneous truncated integer division and modulus.
                    #[inline]
                    fn div_rem(&self, other: &Self) -> (Self, Self) {
                        (*self / *other, *self % *other)
                    }
                }
            };
        }

        impl_integer_for_usize!(u8, test_integer_u8);
        impl_integer_for_usize!(u16, test_integer_u16);
        impl_integer_for_usize!(u32, test_integer_u32);
        impl_integer_for_usize!(u64, test_integer_u64);
        impl_integer_for_usize!(u128, test_integer_u128);
        impl_integer_for_usize!(usize, test_integer_usize);

        /// An iterator over binomial coefficients.
        pub struct IterBinomial<T> {
            a: T,
            n: T,
            k: T,
        }

        impl<T> IterBinomial<T>
        where
            T: Integer,
        {
            /// For a given n, iterate over all binomial coefficients binomial(n, k), for k=0...n.
            /// be no overflow:
            ///
            /// type | n
            /// -----|---
            /// u8   | 10
            /// i8   |  9
            /// u16  | 18
            /// i16  | 17
            /// u32  | 34
            /// i32  | 33
            /// u64  | 67
            /// i64  | 66
            ///
            /// For larger n, `T` should be a bigint type.
            pub fn new(n: T) -> IterBinomial<T> {
                IterBinomial {
                    k: T::zero(),
                    a: T::one(),
                    n,
                }
            }
        }

        impl<T> Iterator for IterBinomial<T>
        where
            T: Integer + Clone,
        {
            type Item = T;

            fn next(&mut self) -> Option<T> {
                if self.k > self.n {
                    return None;
                }
                self.a = if !self.k.is_zero() {
                    multiply_and_divide(
                        self.a.clone(),
                        self.n.clone() - self.k.clone() + T::one(),
                        self.k.clone(),
                    )
                } else {
                    T::one()
                };
                self.k = self.k.clone() + T::one();
                Some(self.a.clone())
            }
        }
        /// Calculate r * a / b, avoiding overflows and fractions.
        ///
        /// Assumes that b divides r * a evenly.
        fn multiply_and_divide<T: Integer + Clone>(r: T, a: T, b: T) -> T {
           
            let g = gcd(r.clone(), b.clone());
            r / g.clone() * (a / (b / g))
        }
        /// Calculate the binomial coefficient.
        ///
        /// Note that this might overflow, depending on `T`. For the primitive integer
        /// types, the following n are the largest ones possible such that there will
        /// be no overflow for any k:
        ///
        /// type | n
        /// -----|---
        /// u8   | 10
        /// i8   |  9
        /// u16  | 18
        /// i16  | 17
        /// u32  | 34
        /// i32  | 33
        /// u64  | 67
        /// i64  | 66
        ///
        /// For larger n, consider using a bigint type for `T`.
        pub fn binomial<T: Integer + Clone>(mut n: T, k: T) -> T {
           
            if k > n {
                return T::zero();
            }
            if k > n.clone() - k.clone() {
                return binomial(n.clone(), n - k);
            }
            let mut r = T::one();
            let mut d = T::one();
            loop {
                if d > k {
                    break;
                }
                r = multiply_and_divide(r, n.clone(), d.clone());
                n = n - T::one();
                d = d + T::one();
            }
            r
        }
        /// Calculate the multinomial coefficient.
        pub fn multinomial<T: Integer + Clone>(k: &[T]) -> T
        where
            for<'a> T: Add<&'a T, Output = T>,
        {
            let mut r = T::one();
            let mut p = T::zero();
            for i in k {
                p = p + i;
                r = r * binomial(p.clone(), i.clone());
            }
            r
        }
    }
    /*
    */
    pub mod big
    {
        //! Big Integer Types for Rust
        use ::
        {
            *,
        };
        /*
        */
        pub mod bigint
        {
            use ::
            {
                *,
            };
            /*
                use alloc::string::String;
                use alloc::vec::Vec;
                use core::cmp::Ordering::{self, Equal};
                use core::default::Default;
                use core::fmt;
                use core::hash;
                use core::ops::{Neg, Not};
                use core::str;

                use num_integer::{Integer, Roots};
                use num_traits::{ConstZero, Num, One, Pow, Signed, Zero};

                use self::Sign::{Minus, NoSign, Plus};

                use crate::big_digit::BigDigit;
                use crate::biguint::to_str_radix_reversed;
                use crate::biguint::{BigUint, IntDigits, U32Digits, U64Digits};
            */
            pub mod addition
            {
                use ::
                {
                    *,
                };
                /*
                    use super::CheckedUnsignedAbs::{Negative, Positive};
                    use super::Sign::{Minus, NoSign, Plus};
                    use super::{BigInt, UnsignedAbs};

                    use crate::{IsizePromotion, UsizePromotion};

                    use core::cmp::Ordering::{Equal, Greater, Less};
                    use core::iter::Sum;
                    use core::mem;
                    use core::ops::{Add, AddAssign};
                    use num_traits::CheckedAdd;
                */
               
               
               
                macro_rules! bigint_add {
                    ($a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr) => {
                        match ($a.sign, $b.sign) {
                            (_, NoSign) => $a_owned,
                            (NoSign, _) => $b_owned,
                           
                            (Plus, Plus) | (Minus, Minus) => BigInt::from_biguint($a.sign, $a_data + $b_data),
                           
                            (Plus, Minus) | (Minus, Plus) => match $a.data.cmp(&$b.data) {
                                Less => BigInt::from_biguint($b.sign, $b_data - $a_data),
                                Greater => BigInt::from_biguint($a.sign, $a_data - $b_data),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }

                impl Add<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: &BigInt) -> BigInt {
                        bigint_add!(
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }

                impl Add<BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: BigInt) -> BigInt {
                        bigint_add!(self, self.clone(), &self.data, other, other, other.data)
                    }
                }

                impl Add<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: &BigInt) -> BigInt {
                        bigint_add!(self, self, self.data, other, other.clone(), &other.data)
                    }
                }

                impl Add<BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: BigInt) -> BigInt {
                        bigint_add!(self, self, self.data, other, other, other.data)
                    }
                }

                impl AddAssign<&BigInt> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: &BigInt) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }
                forward_val_assign!(impl AddAssign for BigInt, add_assign);

                promote_all_scalars!(impl Add for BigInt, add);
                promote_all_scalars_assign!(impl AddAssign for BigInt, add_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u32> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u64> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u128> for BigInt, add);

                impl Add<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: u32) -> BigInt {
                        match self.sign {
                            NoSign => From::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }

                impl AddAssign<u32> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: u32) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                impl Add<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: u64) -> BigInt {
                        match self.sign {
                            NoSign => From::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }

                impl AddAssign<u64> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: u64) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                impl Add<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: u128) -> BigInt {
                        match self.sign {
                            NoSign => BigInt::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }
                impl AddAssign<u128> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: u128) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i32> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i64> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i128> for BigInt, add);

                impl Add<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i32> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl Add<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i64> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl Add<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i128> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl CheckedAdd for BigInt {
                    #[inline]
                    fn checked_add(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.add(v))
                    }
                }

                impl_sum_iter_type!(BigInt);

            }

            pub mod division
            {
                use ::
                {
                    *,
                };
                /*
                    use super::CheckedUnsignedAbs::{Negative, Positive};
                    use super::Sign::NoSign;
                    use super::{BigInt, UnsignedAbs};

                    use crate::{IsizePromotion, UsizePromotion};

                    use core::ops::{Div, DivAssign, Rem, RemAssign};
                    use num_integer::Integer;
                    use num_traits::{CheckedDiv, CheckedEuclid, Euclid, Signed, ToPrimitive, Zero};
                */
                forward_all_binop_to_ref_ref!(impl Div for BigInt, div);

                impl Div<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: &BigInt) -> BigInt {
                        let (q, _) = self.div_rem(other);
                        q
                    }
                }

                impl DivAssign<&BigInt> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: &BigInt) {
                        *self = &*self / other;
                    }
                }
                forward_val_assign!(impl DivAssign for BigInt, div_assign);

                promote_all_scalars!(impl Div for BigInt, div);
                promote_all_scalars_assign!(impl DivAssign for BigInt, div_assign);
                forward_all_scalar_binop_to_val_val!(impl Div<u32> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u64> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u128> for BigInt, div);

                impl Div<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u32> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: u32) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                impl Div<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u64> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: u64) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                impl Div<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u128> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: u128) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Div<i32> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<i64> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<i128> for BigInt, div);

                impl Div<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i32> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                impl Div<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i64> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                impl Div<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i128> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                forward_all_binop_to_ref_ref!(impl Rem for BigInt, rem);

                impl Rem<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: &BigInt) -> BigInt {
                        if let Some(other) = other.to_u32() {
                            self % other
                        } else if let Some(other) = other.to_i32() {
                            self % other
                        } else {
                            let (_, r) = self.div_rem(other);
                            r
                        }
                    }
                }

                impl RemAssign<&BigInt> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: &BigInt) {
                        *self = &*self % other;
                    }
                }
                forward_val_assign!(impl RemAssign for BigInt, rem_assign);

                promote_all_scalars!(impl Rem for BigInt, rem);
                promote_all_scalars_assign!(impl RemAssign for BigInt, rem_assign);
                forward_all_scalar_binop_to_val_val!(impl Rem<u32> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u64> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u128> for BigInt, rem);

                impl Rem<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u32> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: u32) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                impl Rem<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u64> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: u64) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                impl Rem<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u128> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: u128) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Rem<i32> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<i64> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<i128> for BigInt, rem);

                impl Rem<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: i32) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i32> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: i32) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl Rem<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: i64) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i64> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: i64) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl Rem<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: i128) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i128> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: i128) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl CheckedDiv for BigInt {
                    #[inline]
                    fn checked_div(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div(v))
                    }
                }

                impl CheckedEuclid for BigInt {
                    #[inline]
                    fn checked_div_euclid(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div_euclid(v))
                    }

                    #[inline]
                    fn checked_rem_euclid(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.rem_euclid(v))
                    }

                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some(self.div_rem_euclid(v))
                    }
                }

                impl Euclid for BigInt {
                    #[inline]
                    fn div_euclid(&self, v: &BigInt) -> BigInt {
                        let (q, r) = self.div_rem(v);
                        if r.is_negative() {
                            if v.is_positive() {
                                q - 1
                            } else {
                                q + 1
                            }
                        } else {
                            q
                        }
                    }

                    #[inline]
                    fn rem_euclid(&self, v: &BigInt) -> BigInt {
                        let r = self % v;
                        if r.is_negative() {
                            if v.is_positive() {
                                r + v
                            } else {
                                r - v
                            }
                        } else {
                            r
                        }
                    }

                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                        let (q, r) = self.div_rem(v);
                        if r.is_negative() {
                            if v.is_positive() {
                                (q - 1, r + v)
                            } else {
                                (q + 1, r - v)
                            }
                        } else {
                            (q, r)
                        }
                    }
                }

            }
            
            pub mod multiplication
            {
                use ::
                {
                    *,
                };
                /*
                    use super::CheckedUnsignedAbs::{Negative, Positive};
                    use super::Sign::{self, Minus, NoSign, Plus};
                    use super::{BigInt, UnsignedAbs};

                    use crate::{IsizePromotion, UsizePromotion};

                    use core::iter::Product;
                    use core::ops::{Mul, MulAssign};
                    use num_traits::{CheckedMul, One, Zero};
                */
                impl Mul<Sign> for Sign {
                    type Output = Sign;

                    #[inline]
                    fn mul(self, other: Sign) -> Sign {
                        match (self, other) {
                            (NoSign, _) | (_, NoSign) => NoSign,
                            (Plus, Plus) | (Minus, Minus) => Plus,
                            (Plus, Minus) | (Minus, Plus) => Minus,
                        }
                    }
                }

                macro_rules! impl_mul {
                    ($(impl Mul<$Other:ty> for $Self:ty;)*) => {$(
                        impl Mul<$Other> for $Self {
                            type Output = BigInt;

                            #[inline]
                            fn mul(self, other: $Other) -> BigInt {
                               
                                let BigInt { data: x, .. } = self;
                                let BigInt { data: y, .. } = other;
                                BigInt::from_biguint(self.sign * other.sign, x * y)
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigInt> for BigInt;
                    impl Mul<BigInt> for &BigInt;
                    impl Mul<&BigInt> for BigInt;
                    impl Mul<&BigInt> for &BigInt;
                }

                macro_rules! impl_mul_assign {
                    ($(impl MulAssign<$Other:ty> for BigInt;)*) => {$(
                        impl MulAssign<$Other> for BigInt {
                            #[inline]
                            fn mul_assign(&mut self, other: $Other) {
                               
                                let BigInt { data: y, .. } = other;
                                self.data *= y;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                } else {
                                    self.sign = self.sign * other.sign;
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigInt> for BigInt;
                    impl MulAssign<&BigInt> for BigInt;
                }

                promote_all_scalars!(impl Mul for BigInt, mul);
                promote_all_scalars_assign!(impl MulAssign for BigInt, mul_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u32> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u64> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u128> for BigInt, mul);

                impl Mul<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u32> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: u32) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Mul<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u64> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: u64) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Mul<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u128> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: u128) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i32> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i64> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i128> for BigInt, mul);

                impl Mul<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i32> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl Mul<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i64> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl Mul<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i128> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl CheckedMul for BigInt {
                    #[inline]
                    fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.mul(v))
                    }
                }

                impl_product_iter_type!(BigInt);

            }

            pub mod subtraction
            {
                use ::
                {
                    *,
                };
                /*
                    use super::CheckedUnsignedAbs::{Negative, Positive};
                    use super::Sign::{Minus, NoSign, Plus};
                    use super::{BigInt, UnsignedAbs};

                    use crate::{IsizePromotion, UsizePromotion};

                    use core::cmp::Ordering::{Equal, Greater, Less};
                    use core::mem;
                    use core::ops::{Sub, SubAssign};
                    use num_traits::CheckedSub;
                */
               
               
               
                macro_rules! bigint_sub {
                    ($a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr) => {
                        match ($a.sign, $b.sign) {
                            (_, NoSign) => $a_owned,
                            (NoSign, _) => -$b_owned,
                           
                            (Plus, Minus) | (Minus, Plus) => BigInt::from_biguint($a.sign, $a_data + $b_data),
                           
                            (Plus, Plus) | (Minus, Minus) => match $a.data.cmp(&$b.data) {
                                Less => BigInt::from_biguint(-$a.sign, $b_data - $a_data),
                                Greater => BigInt::from_biguint($a.sign, $a_data - $b_data),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }

                impl Sub<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: &BigInt) -> BigInt {
                        bigint_sub!(
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }

                impl Sub<BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        bigint_sub!(self, self.clone(), &self.data, other, other, other.data)
                    }
                }

                impl Sub<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: &BigInt) -> BigInt {
                        bigint_sub!(self, self, self.data, other, other.clone(), &other.data)
                    }
                }

                impl Sub<BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        bigint_sub!(self, self, self.data, other, other, other.data)
                    }
                }

                impl SubAssign<&BigInt> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: &BigInt) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }
                forward_val_assign!(impl SubAssign for BigInt, sub_assign);

                promote_all_scalars!(impl Sub for BigInt, sub);
                promote_all_scalars_assign!(impl SubAssign for BigInt, sub_assign);
                forward_all_scalar_binop_to_val_val!(impl Sub<u32> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u64> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u128> for BigInt, sub);

                impl Sub<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: u32) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }
                impl SubAssign<u32> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: u32) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                impl Sub<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: u64) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }

                impl SubAssign<u64> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: u64) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                impl Sub<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: u128) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }

                impl SubAssign<u128> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: u128) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Sub<i32> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<i64> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<i128> for BigInt, sub);

                impl Sub<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }
                impl SubAssign<i32> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl Sub<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }
                impl SubAssign<i64> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl Sub<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }

                impl SubAssign<i128> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl CheckedSub for BigInt {
                    #[inline]
                    fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.sub(v))
                    }
                }

            }

            pub mod bits
            {
                use ::
                {
                    *,
                };
                /*
                    use super::BigInt;
                    use super::Sign::{Minus, NoSign, Plus};

                    use crate::big_digit::{self, BigDigit, DoubleBigDigit};
                    use crate::biguint::IntDigits;

                    use alloc::vec::Vec;
                    use core::cmp::Ordering::{Equal, Greater, Less};
                    use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign};
                    use num_traits::{ToPrimitive, Zero};
                */
               
               
                //
               
               
               
               
                //
               
               
               
               
               
               
               
               
                #[inline]
                fn negate_carry(a: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
                    *acc += DoubleBigDigit::from(!a);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }

               
               
               
                fn bitand_pos_neg(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut carry_b = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai &= twos_b;
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                }

               
               
               
                fn bitand_neg_pos(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = twos_a & bi;
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => a.truncate(b.len()),
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().cloned());
                        }
                    }
                }

               
               
               
               
                fn bitand_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_and = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(twos_a & twos_b, &mut carry_and);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                *ai = negate_carry(twos_a, &mut carry_and);
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_and)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                    if carry_and != 0 {
                        a.push(1);
                    }
                }

                forward_val_val_binop!(impl BitAnd for BigInt, bitand);
                forward_ref_val_binop!(impl BitAnd for BigInt, bitand);

               
               
                impl BitAnd<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitand(self, other: &BigInt) -> BigInt {
                        match (self.sign, other.sign) {
                            (NoSign, _) | (_, NoSign) => BigInt::ZERO,
                            (Plus, Plus) => BigInt::from(&self.data & &other.data),
                            (Plus, Minus) => self.clone() & other,
                            (Minus, Plus) => other.clone() & self,
                            (Minus, Minus) => {
                               
                                if self.len() >= other.len() {
                                    self.clone() & other
                                } else {
                                    other.clone() & self
                                }
                            }
                        }
                    }
                }

                impl BitAnd<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitand(mut self, other: &BigInt) -> BigInt {
                        self &= other;
                        self
                    }
                }

                forward_val_assign!(impl BitAndAssign for BigInt, bitand_assign);

                impl BitAndAssign<&BigInt> for BigInt {
                    fn bitand_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (NoSign, _) => {}
                            (_, NoSign) => self.set_zero(),
                            (Plus, Plus) => {
                                self.data &= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            (Plus, Minus) => {
                                bitand_pos_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitand_neg_pos(self.digits_mut(), other.digits());
                                self.sign = Plus;
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitand_neg_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                        }
                    }
                }

               
               
               
                fn bitor_pos_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(*ai | twos_b, &mut carry_or);
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            a.truncate(b.len());
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_or)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                   
                    debug_assert!(carry_or == 0);
                }

               
               
               
                fn bitor_neg_pos(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = negate_carry(twos_a | bi, &mut carry_or);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    if a.len() > b.len() {
                        for ai in a[b.len()..].iter_mut() {
                            let twos_a = negate_carry(*ai, &mut carry_a);
                            *ai = negate_carry(twos_a, &mut carry_or);
                        }
                        debug_assert!(carry_a == 0);
                    }
                   
                    debug_assert!(carry_or == 0);
                }

               
               
               
                fn bitor_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(twos_a | twos_b, &mut carry_or);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    if a.len() > b.len() {
                        a.truncate(b.len());
                    }
                   
                    debug_assert!(carry_or == 0);
                }

                forward_val_val_binop!(impl BitOr for BigInt, bitor);
                forward_ref_val_binop!(impl BitOr for BigInt, bitor);

               
               
                impl BitOr<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitor(self, other: &BigInt) -> BigInt {
                        match (self.sign, other.sign) {
                            (NoSign, _) => other.clone(),
                            (_, NoSign) => self.clone(),
                            (Plus, Plus) => BigInt::from(&self.data | &other.data),
                            (Plus, Minus) => other.clone() | self,
                            (Minus, Plus) => self.clone() | other,
                            (Minus, Minus) => {
                               
                                if self.len() <= other.len() {
                                    self.clone() | other
                                } else {
                                    other.clone() | self
                                }
                            }
                        }
                    }
                }

                impl BitOr<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitor(mut self, other: &BigInt) -> BigInt {
                        self |= other;
                        self
                    }
                }

                forward_val_assign!(impl BitOrAssign for BigInt, bitor_assign);

                impl BitOrAssign<&BigInt> for BigInt {
                    fn bitor_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (_, NoSign) => {}
                            (NoSign, _) => self.clone_from(other),
                            (Plus, Plus) => self.data |= &other.data,
                            (Plus, Minus) => {
                                bitor_pos_neg(self.digits_mut(), other.digits());
                                self.sign = Minus;
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitor_neg_pos(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitor_neg_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                        }
                    }
                }

               
               
               
                fn bitxor_pos_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_b = 1;
                    let mut carry_xor = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(*ai ^ twos_b, &mut carry_xor);
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_b = !0;
                                *ai = negate_carry(*ai ^ twos_b, &mut carry_xor);
                            }
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_xor)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                    if carry_xor != 0 {
                        a.push(1);
                    }
                }

               
               
               
                fn bitxor_neg_pos(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_xor = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = negate_carry(twos_a ^ bi, &mut carry_xor);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                *ai = negate_carry(twos_a, &mut carry_xor);
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_a = !0;
                                negate_carry(twos_a ^ bi, &mut carry_xor)
                            }));
                        }
                    }
                    if carry_xor != 0 {
                        a.push(1);
                    }
                }

               
               
               
                fn bitxor_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = twos_a ^ twos_b;
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                let twos_b = !0;
                                *ai = twos_a ^ twos_b;
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_a = !0;
                                let twos_b = negate_carry(bi, &mut carry_b);
                                twos_a ^ twos_b
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitXor for BigInt, bitxor);

                impl BitXor<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitxor(mut self, other: &BigInt) -> BigInt {
                        self ^= other;
                        self
                    }
                }

                forward_val_assign!(impl BitXorAssign for BigInt, bitxor_assign);

                impl BitXorAssign<&BigInt> for BigInt {
                    fn bitxor_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (_, NoSign) => {}
                            (NoSign, _) => self.clone_from(other),
                            (Plus, Plus) => {
                                self.data ^= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            (Plus, Minus) => {
                                bitxor_pos_neg(self.digits_mut(), other.digits());
                                self.sign = Minus;
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitxor_neg_pos(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitxor_neg_neg(self.digits_mut(), other.digits());
                                self.sign = Plus;
                                self.normalize();
                            }
                        }
                    }
                }

                pub(super) fn set_negative_bit(x: &mut BigInt, bit: u64, value: bool) {
                    debug_assert_eq!(x.sign, Minus);
                    let data = &mut x.data;

                    let bits_per_digit = u64::from(big_digit::BITS);
                    if bit >= bits_per_digit * data.len() as u64 {
                        if !value {
                            data.set_bit(bit, true);
                        }
                    } else {
                       
                       
                       
                       
                       
                       
                        let trailing_zeros = data.trailing_zeros().unwrap();
                        if bit > trailing_zeros {
                            data.set_bit(bit, !value);
                        } else if bit == trailing_zeros && !value {
                           
                           
                           
                           
                           
                            let bit_index = (bit / bits_per_digit).to_usize().unwrap();
                            let bit_mask = (1 as BigDigit) << (bit % bits_per_digit);
                            let mut digit_iter = data.digits_mut().iter_mut().skip(bit_index);
                            let mut carry_in = 1;
                            let mut carry_out = 1;

                            let digit = digit_iter.next().unwrap();
                            let twos_in = negate_carry(*digit, &mut carry_in);
                            let twos_out = twos_in & !bit_mask;
                            *digit = negate_carry(twos_out, &mut carry_out);

                            for digit in digit_iter {
                                if carry_in == 0 && carry_out == 0 {
                                   
                                    break;
                                }
                                let twos = negate_carry(*digit, &mut carry_in);
                                *digit = negate_carry(twos, &mut carry_out);
                            }

                            if carry_out != 0 {
                               
                                debug_assert_eq!(carry_in, 0);
                                data.digits_mut().push(1);
                            }
                        } else if bit < trailing_zeros && value {
                           
                           
                           
                           
                           
                           
                            let index_lo = (bit / bits_per_digit).to_usize().unwrap();
                            let index_hi = (trailing_zeros / bits_per_digit).to_usize().unwrap();
                            let bit_mask_lo = big_digit::MAX << (bit % bits_per_digit);
                            let bit_mask_hi =
                                big_digit::MAX >> (bits_per_digit - 1 - (trailing_zeros % bits_per_digit));
                            let digits = data.digits_mut();

                            if index_lo == index_hi {
                                digits[index_lo] ^= bit_mask_lo & bit_mask_hi;
                            } else {
                                digits[index_lo] = bit_mask_lo;
                                for digit in &mut digits[index_lo + 1..index_hi] {
                                    *digit = big_digit::MAX;
                                }
                                digits[index_hi] ^= bit_mask_hi;
                            }
                        } else {
                           
                           
                           
                        }
                    }
                }

            }

            pub mod convert
            {
                use ::
                {
                    *,
                };
                /*
                use super::Sign::{self, Minus, NoSign, Plus};
                use super::{BigInt, ToBigInt};

                use crate::TryFromBigIntError;
                use crate::{BigUint, ParseBigIntError, ToBigUint};

                use alloc::vec::Vec;
                use core::cmp::Ordering::{Equal, Greater, Less};
                use core::convert::TryFrom;
                use core::str::{self, FromStr};
                use num_traits::{FromPrimitive, Num, One, ToPrimitive, Zero};
                */
                impl FromStr for BigInt {
                    type Err = ParseBigIntError;

                    #[inline]
                    fn from_str(s: &str) -> Result<BigInt, ParseBigIntError> {
                        BigInt::from_str_radix(s, 10)
                    }
                }

                impl Num for BigInt {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a [`BigInt`].
                    #[inline]
                    fn from_str_radix(mut s: &str, radix: u32) -> Result<BigInt, ParseBigIntError> {
                        let sign = if let Some(tail) = s.strip_prefix('-') {
                            if !tail.starts_with('+') {
                                s = tail
                            }
                            Minus
                        } else {
                            Plus
                        };
                        let bu = BigUint::from_str_radix(s, radix)?;
                        Ok(BigInt::from_biguint(sign, bu))
                    }
                }

                impl ToPrimitive for BigInt {
                    #[inline]
                    fn to_i64(&self) -> Option<i64> {
                        match self.sign {
                            Plus => self.data.to_i64(),
                            NoSign => Some(0),
                            Minus => {
                                let n = self.data.to_u64()?;
                                let m: u64 = 1 << 63;
                                match n.cmp(&m) {
                                    Less => Some(-(n as i64)),
                                    Equal => Some(i64::MIN),
                                    Greater => None,
                                }
                            }
                        }
                    }

                    #[inline]
                    fn to_i128(&self) -> Option<i128> {
                        match self.sign {
                            Plus => self.data.to_i128(),
                            NoSign => Some(0),
                            Minus => {
                                let n = self.data.to_u128()?;
                                let m: u128 = 1 << 127;
                                match n.cmp(&m) {
                                    Less => Some(-(n as i128)),
                                    Equal => Some(i128::MIN),
                                    Greater => None,
                                }
                            }
                        }
                    }

                    #[inline]
                    fn to_u64(&self) -> Option<u64> {
                        match self.sign {
                            Plus => self.data.to_u64(),
                            NoSign => Some(0),
                            Minus => None,
                        }
                    }

                    #[inline]
                    fn to_u128(&self) -> Option<u128> {
                        match self.sign {
                            Plus => self.data.to_u128(),
                            NoSign => Some(0),
                            Minus => None,
                        }
                    }

                    #[inline]
                    fn to_f32(&self) -> Option<f32> {
                        let n = self.data.to_f32()?;
                        Some(if self.sign == Minus { -n } else { n })
                    }

                    #[inline]
                    fn to_f64(&self) -> Option<f64> {
                        let n = self.data.to_f64()?;
                        Some(if self.sign == Minus { -n } else { n })
                    }
                }

                macro_rules! impl_try_from_bigint {
                    ($T:ty, $to_ty:path) => {
                        impl TryFrom<&BigInt> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: &BigInt) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }

                        impl TryFrom<BigInt> for $T {
                            type Error = TryFromBigIntError<BigInt>;

                            #[inline]
                            fn try_from(value: BigInt) -> Result<$T, TryFromBigIntError<BigInt>> {
                                <$T>::try_from(&value).map_err(|_| TryFromBigIntError::new(value))
                            }
                        }
                    };
                }

                impl_try_from_bigint!(u8, ToPrimitive::to_u8);
                impl_try_from_bigint!(u16, ToPrimitive::to_u16);
                impl_try_from_bigint!(u32, ToPrimitive::to_u32);
                impl_try_from_bigint!(u64, ToPrimitive::to_u64);
                impl_try_from_bigint!(usize, ToPrimitive::to_usize);
                impl_try_from_bigint!(u128, ToPrimitive::to_u128);

                impl_try_from_bigint!(i8, ToPrimitive::to_i8);
                impl_try_from_bigint!(i16, ToPrimitive::to_i16);
                impl_try_from_bigint!(i32, ToPrimitive::to_i32);
                impl_try_from_bigint!(i64, ToPrimitive::to_i64);
                impl_try_from_bigint!(isize, ToPrimitive::to_isize);
                impl_try_from_bigint!(i128, ToPrimitive::to_i128);

                impl FromPrimitive for BigInt {
                    #[inline]
                    fn from_i64(n: i64) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline]
                    fn from_i128(n: i128) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline]
                    fn from_u64(n: u64) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline]
                    fn from_u128(n: u128) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline]
                    fn from_f64(n: f64) -> Option<BigInt> {
                        if n >= 0.0 {
                            BigUint::from_f64(n).map(BigInt::from)
                        } else {
                            let x = BigUint::from_f64(-n)?;
                            Some(-BigInt::from(x))
                        }
                    }
                }

                impl From<i64> for BigInt {
                    #[inline]
                    fn from(n: i64) -> Self {
                        if n >= 0 {
                            BigInt::from(n as u64)
                        } else {
                            let u = u64::MAX - (n as u64) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from(u),
                            }
                        }
                    }
                }

                impl From<i128> for BigInt {
                    #[inline]
                    fn from(n: i128) -> Self {
                        if n >= 0 {
                            BigInt::from(n as u128)
                        } else {
                            let u = u128::MAX - (n as u128) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from(u),
                            }
                        }
                    }
                }

                macro_rules! impl_bigint_from_int {
                    ($T:ty) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigInt::from(n as i64)
                            }
                        }
                    };
                }

                impl_bigint_from_int!(i8);
                impl_bigint_from_int!(i16);
                impl_bigint_from_int!(i32);
                impl_bigint_from_int!(isize);

                impl From<u64> for BigInt {
                    #[inline]
                    fn from(n: u64) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from(n),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }

                impl From<u128> for BigInt {
                    #[inline]
                    fn from(n: u128) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from(n),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }

                macro_rules! impl_bigint_from_uint {
                    ($T:ty) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigInt::from(n as u64)
                            }
                        }
                    };
                }

                impl_bigint_from_uint!(u8);
                impl_bigint_from_uint!(u16);
                impl_bigint_from_uint!(u32);
                impl_bigint_from_uint!(usize);

                impl From<BigUint> for BigInt {
                    #[inline]
                    fn from(n: BigUint) -> Self {
                        if n.is_zero() {
                            Self::ZERO
                        } else {
                            BigInt {
                                sign: Plus,
                                data: n,
                            }
                        }
                    }
                }

                impl ToBigInt for BigInt {
                    #[inline]
                    fn to_bigint(&self) -> Option<BigInt> {
                        Some(self.clone())
                    }
                }

                impl ToBigInt for BigUint {
                    #[inline]
                    fn to_bigint(&self) -> Option<BigInt> {
                        if self.is_zero() {
                            Some(BigInt::ZERO)
                        } else {
                            Some(BigInt {
                                sign: Plus,
                                data: self.clone(),
                            })
                        }
                    }
                }

                impl ToBigUint for BigInt {
                    #[inline]
                    fn to_biguint(&self) -> Option<BigUint> {
                        match self.sign() {
                            Plus => Some(self.data.clone()),
                            NoSign => Some(BigUint::ZERO),
                            Minus => None,
                        }
                    }
                }

                impl TryFrom<&BigInt> for BigUint {
                    type Error = TryFromBigIntError<()>;

                    #[inline]
                    fn try_from(value: &BigInt) -> Result<BigUint, TryFromBigIntError<()>> {
                        value
                            .to_biguint()
                            .ok_or_else(|| TryFromBigIntError::new(()))
                    }
                }

                impl TryFrom<BigInt> for BigUint {
                    type Error = TryFromBigIntError<BigInt>;

                    #[inline]
                    fn try_from(value: BigInt) -> Result<BigUint, TryFromBigIntError<BigInt>> {
                        if value.sign() == Sign::Minus {
                            Err(TryFromBigIntError::new(value))
                        } else {
                            Ok(value.data)
                        }
                    }
                }

                macro_rules! impl_to_bigint {
                    ($T:ty, $from_ty:path) => {
                        impl ToBigInt for $T {
                            #[inline]
                            fn to_bigint(&self) -> Option<BigInt> {
                                $from_ty(*self)
                            }
                        }
                    };
                }

                impl_to_bigint!(isize, FromPrimitive::from_isize);
                impl_to_bigint!(i8, FromPrimitive::from_i8);
                impl_to_bigint!(i16, FromPrimitive::from_i16);
                impl_to_bigint!(i32, FromPrimitive::from_i32);
                impl_to_bigint!(i64, FromPrimitive::from_i64);
                impl_to_bigint!(i128, FromPrimitive::from_i128);

                impl_to_bigint!(usize, FromPrimitive::from_usize);
                impl_to_bigint!(u8, FromPrimitive::from_u8);
                impl_to_bigint!(u16, FromPrimitive::from_u16);
                impl_to_bigint!(u32, FromPrimitive::from_u32);
                impl_to_bigint!(u64, FromPrimitive::from_u64);
                impl_to_bigint!(u128, FromPrimitive::from_u128);

                impl_to_bigint!(f32, FromPrimitive::from_f32);
                impl_to_bigint!(f64, FromPrimitive::from_f64);

                impl From<bool> for BigInt {
                    fn from(x: bool) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }

                #[inline]
                pub(super) fn from_signed_bytes_be(digits: &[u8]) -> BigInt {
                    let sign = match digits.first() {
                        Some(v) if *v > 0x7f => Sign::Minus,
                        Some(_) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                       
                        let mut digits = Vec::from(digits);
                        twos_complement_be(&mut digits);
                        BigInt::from_biguint(sign, BigUint::from_bytes_be(&digits))
                    } else {
                        BigInt::from_biguint(sign, BigUint::from_bytes_be(digits))
                    }
                }

                #[inline]
                pub(super) fn from_signed_bytes_le(digits: &[u8]) -> BigInt {
                    let sign = match digits.last() {
                        Some(v) if *v > 0x7f => Sign::Minus,
                        Some(_) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                       
                        let mut digits = Vec::from(digits);
                        twos_complement_le(&mut digits);
                        BigInt::from_biguint(sign, BigUint::from_bytes_le(&digits))
                    } else {
                        BigInt::from_biguint(sign, BigUint::from_bytes_le(digits))
                    }
                }

                #[inline]
                pub(super) fn to_signed_bytes_be(x: &BigInt) -> Vec<u8> {
                    let mut bytes = x.data.to_bytes_be();
                    let first_byte = bytes.first().cloned().unwrap_or(0);
                    if first_byte > 0x7f
                        && !(first_byte == 0x80 && bytes.iter().skip(1).all(Zero::is_zero) && x.sign == Sign::Minus)
                    {
                       
                        bytes.insert(0, 0);
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_be(&mut bytes);
                    }
                    bytes
                }

                #[inline]
                pub(super) fn to_signed_bytes_le(x: &BigInt) -> Vec<u8> {
                    let mut bytes = x.data.to_bytes_le();
                    let last_byte = bytes.last().cloned().unwrap_or(0);
                    if last_byte > 0x7f
                        && !(last_byte == 0x80
                            && bytes.iter().rev().skip(1).all(Zero::is_zero)
                            && x.sign == Sign::Minus)
                    {
                       
                        bytes.push(0);
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_le(&mut bytes);
                    }
                    bytes
                }

                /// Perform in-place two's complement of the given binary representation,
                /// in little-endian byte order.
                #[inline]
                fn twos_complement_le(digits: &mut [u8]) {
                    twos_complement(digits)
                }

                /// Perform in-place two's complement of the given binary representation
                /// in big-endian byte order.
                #[inline]
                fn twos_complement_be(digits: &mut [u8]) {
                    twos_complement(digits.iter_mut().rev())
                }

                /// Perform in-place two's complement of the given digit iterator
                /// starting from the least significant byte.
                #[inline]
                fn twos_complement<'a, I>(digits: I)
                where
                    I: IntoIterator<Item = &'a mut u8>,
                {
                    let mut carry = true;
                    for d in digits {
                        *d = !*d;
                        if carry {
                            *d = d.wrapping_add(1);
                            carry = d.is_zero();
                        }
                    }
                }

            }

            pub mod power
            {
                use ::
                {
                    *,
                };
                /*
                use super::BigInt;
                use super::Sign::{self, Minus, Plus};

                use crate::BigUint;

                use num_integer::Integer;
                use num_traits::{Pow, Signed, Zero};
                */
                /// Help function for pow
                ///
                /// Computes the effect of the exponent on the sign.
                #[inline]
                fn powsign<T: Integer>(sign: Sign, other: &T) -> Sign {
                    if other.is_zero() {
                        Plus
                    } else if sign != Minus || other.is_odd() {
                        sign
                    } else {
                        -sign
                    }
                }

                macro_rules! pow_impl {
                    ($T:ty) => {
                        impl Pow<$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: $T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, &rhs), self.data.pow(rhs))
                            }
                        }

                        impl Pow<&$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: &$T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, rhs), self.data.pow(rhs))
                            }
                        }

                        impl Pow<$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: $T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, &rhs), Pow::pow(&self.data, rhs))
                            }
                        }

                        impl Pow<&$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: &$T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, rhs), Pow::pow(&self.data, rhs))
                            }
                        }
                    };
                }

                pow_impl!(u8);
                pow_impl!(u16);
                pow_impl!(u32);
                pow_impl!(u64);
                pow_impl!(usize);
                pow_impl!(u128);
                pow_impl!(BigUint);

                pub(super) fn modpow(x: &BigInt, exponent: &BigInt, modulus: &BigInt) -> BigInt {
                    assert!(
                        !exponent.is_negative(),
                        "negative exponentiation is not supported!"
                    );
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    let result = x.data.modpow(&exponent.data, &modulus.data);
                    if result.is_zero() {
                        return BigInt::ZERO;
                    }

                   
                    let (sign, mag) = match (x.is_negative() && exponent.is_odd(), modulus.is_negative()) {
                        (false, false) => (Plus, result),
                        (true, false) => (Plus, &modulus.data - result),
                        (false, true) => (Minus, &modulus.data - result),
                        (true, true) => (Minus, result),
                    };
                    BigInt::from_biguint(sign, mag)
                }

            }

            pub mod shift
            {
                use ::
                {
                    *,
                };
                /*
                use super::BigInt;
                use super::Sign::NoSign;

                use core::ops::{Shl, ShlAssign, Shr, ShrAssign};
                use num_traits::{PrimInt, Signed, Zero};
                */
                macro_rules! impl_shift {
                    (@ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty) => {
                        impl $Shx<&$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigInt {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $Shx<&$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigInt {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigInt {
                            #[inline]
                            fn $shx_assign(&mut self, rhs: &$rhs) {
                                $ShxAssign::$shx_assign(self, *rhs);
                            }
                        }
                    };
                    ($($rhs:ty),+) => {$(
                        impl Shl<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigInt {
                                BigInt::from_biguint(self.sign, self.data << rhs)
                            }
                        }
                        impl Shl<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigInt {
                                BigInt::from_biguint(self.sign, &self.data << rhs)
                            }
                        }
                        impl ShlAssign<$rhs> for BigInt {
                            #[inline]
                            fn shl_assign(&mut self, rhs: $rhs) {
                                self.data <<= rhs
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }

                        impl Shr<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigInt {
                                let round_down = shr_round_down(&self, rhs);
                                let data = self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint(self.sign, data)
                            }
                        }
                        impl Shr<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigInt {
                                let round_down = shr_round_down(self, rhs);
                                let data = &self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint(self.sign, data)
                            }
                        }
                        impl ShrAssign<$rhs> for BigInt {
                            #[inline]
                            fn shr_assign(&mut self, rhs: $rhs) {
                                let round_down = shr_round_down(self, rhs);
                                self.data >>= rhs;
                                if round_down {
                                    self.data += 1u8;
                                } else if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }

                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }

               
               
                fn shr_round_down<T: PrimInt>(i: &BigInt, shift: T) -> bool {
                    if i.is_negative() {
                        let zeros = i.trailing_zeros().expect("negative values are non-zero");
                        shift > T::zero() && shift.to_u64().map(|shift| zeros < shift).unwrap_or(true)
                    } else {
                        false
                    }
                }

            }
            /// A `Sign` is a [`BigInt`]'s composing element.
            #[derive(PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash)]
            pub enum Sign {
                Minus,
                NoSign,
                Plus,
            }

            impl Neg for Sign {
                type Output = Sign;

                /// Negate `Sign` value.
                #[inline]
                fn neg(self) -> Sign {
                    match self {
                        Minus => Plus,
                        NoSign => NoSign,
                        Plus => Minus,
                    }
                }
            }
            /// A big signed integer type.
            pub struct BigInt {
                sign: Sign,
                data: BigUint,
            }

           
           
            impl Clone for BigInt {
                #[inline]
                fn clone(&self) -> Self {
                    BigInt {
                        sign: self.sign,
                        data: self.data.clone(),
                    }
                }

                #[inline]
                fn clone_from(&mut self, other: &Self) {
                    self.sign = other.sign;
                    self.data.clone_from(&other.data);
                }
            }

            impl hash::Hash for BigInt {
                #[inline]
                fn hash<H: hash::Hasher>(&self, state: &mut H) {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    self.sign.hash(state);
                    if self.sign != NoSign {
                        self.data.hash(state);
                    }
                }
            }

            impl PartialEq for BigInt {
                #[inline]
                fn eq(&self, other: &BigInt) -> bool {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    debug_assert!((other.sign != NoSign) ^ other.data.is_zero());
                    self.sign == other.sign && (self.sign == NoSign || self.data == other.data)
                }
            }

            impl Eq for BigInt {}

            impl PartialOrd for BigInt {
                #[inline]
                fn partial_cmp(&self, other: &BigInt) -> Option<Ordering> {
                    Some(self.cmp(other))
                }
            }

            impl Ord for BigInt {
                #[inline]
                fn cmp(&self, other: &BigInt) -> Ordering {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    debug_assert!((other.sign != NoSign) ^ other.data.is_zero());
                    let scmp = self.sign.cmp(&other.sign);
                    if scmp != Equal {
                        return scmp;
                    }

                    match self.sign {
                        NoSign => Equal,
                        Plus => self.data.cmp(&other.data),
                        Minus => other.data.cmp(&self.data),
                    }
                }
            }

            impl Default for BigInt {
                #[inline]
                fn default() -> BigInt {
                    Self::ZERO
                }
            }

            impl fmt::Debug for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Display::fmt(self, f)
                }
            }

            impl fmt::Display for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "", &self.data.to_str_radix(10))
                }
            }

            impl fmt::Binary for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "0b", &self.data.to_str_radix(2))
                }
            }

            impl fmt::Octal for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "0o", &self.data.to_str_radix(8))
                }
            }

            impl fmt::LowerHex for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    f.pad_integral(!self.is_negative(), "0x", &self.data.to_str_radix(16))
                }
            }

            impl fmt::UpperHex for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    let mut s = self.data.to_str_radix(16);
                    s.make_ascii_uppercase();
                    f.pad_integral(!self.is_negative(), "0x", &s)
                }
            }

           
           
           
           
            impl Not for BigInt {
                type Output = BigInt;

                fn not(mut self) -> BigInt {
                    match self.sign {
                        NoSign | Plus => {
                            self.data += 1u32;
                            self.sign = Minus;
                        }
                        Minus => {
                            self.data -= 1u32;
                            self.sign = if self.data.is_zero() { NoSign } else { Plus };
                        }
                    }
                    self
                }
            }

            impl Not for &BigInt {
                type Output = BigInt;

                fn not(self) -> BigInt {
                    match self.sign {
                        NoSign => -BigInt::one(),
                        Plus => -BigInt::from(&self.data + 1u32),
                        Minus => BigInt::from(&self.data - 1u32),
                    }
                }
            }

            impl Zero for BigInt {
                #[inline]
                fn zero() -> BigInt {
                    Self::ZERO
                }

                #[inline]
                fn set_zero(&mut self) {
                    self.data.set_zero();
                    self.sign = NoSign;
                }

                #[inline]
                fn is_zero(&self) -> bool {
                    self.sign == NoSign
                }
            }

            impl ConstZero for BigInt {
               
                const ZERO: Self = Self::ZERO;
            }

            impl One for BigInt {
                #[inline]
                fn one() -> BigInt {
                    BigInt {
                        sign: Plus,
                        data: BigUint::one(),
                    }
                }

                #[inline]
                fn set_one(&mut self) {
                    self.data.set_one();
                    self.sign = Plus;
                }

                #[inline]
                fn is_one(&self) -> bool {
                    self.sign == Plus && self.data.is_one()
                }
            }

            impl Signed for BigInt {
                #[inline]
                fn abs(&self) -> BigInt {
                    match self.sign {
                        Plus | NoSign => self.clone(),
                        Minus => BigInt::from(self.data.clone()),
                    }
                }

                #[inline]
                fn abs_sub(&self, other: &BigInt) -> BigInt {
                    if *self <= *other {
                        Self::ZERO
                    } else {
                        self - other
                    }
                }

                #[inline]
                fn signum(&self) -> BigInt {
                    match self.sign {
                        Plus => BigInt::one(),
                        Minus => -BigInt::one(),
                        NoSign => Self::ZERO,
                    }
                }

                #[inline]
                fn is_positive(&self) -> bool {
                    self.sign == Plus
                }

                #[inline]
                fn is_negative(&self) -> bool {
                    self.sign == Minus
                }
            }

            trait UnsignedAbs {
                type Unsigned;

                fn checked_uabs(self) -> CheckedUnsignedAbs<Self::Unsigned>;
            }

            enum CheckedUnsignedAbs<T> {
                Positive(T),
                Negative(T),
            }
            use self::CheckedUnsignedAbs::{Negative, Positive};

            macro_rules! impl_unsigned_abs {
                ($Signed:ty, $Unsigned:ty) => {
                    impl UnsignedAbs for $Signed {
                        type Unsigned = $Unsigned;

                        #[inline]
                        fn checked_uabs(self) -> CheckedUnsignedAbs<Self::Unsigned> {
                            if self >= 0 {
                                Positive(self as $Unsigned)
                            } else {
                                Negative(self.wrapping_neg() as $Unsigned)
                            }
                        }
                    }
                };
            }
            impl_unsigned_abs!(i8, u8);
            impl_unsigned_abs!(i16, u16);
            impl_unsigned_abs!(i32, u32);
            impl_unsigned_abs!(i64, u64);
            impl_unsigned_abs!(i128, u128);
            impl_unsigned_abs!(isize, usize);

            impl Neg for BigInt {
                type Output = BigInt;

                #[inline]
                fn neg(mut self) -> BigInt {
                    self.sign = -self.sign;
                    self
                }
            }

            impl Neg for &BigInt {
                type Output = BigInt;

                #[inline]
                fn neg(self) -> BigInt {
                    -self.clone()
                }
            }

            impl Integer for BigInt {
                #[inline]
                fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {
                   
                    let (d_ui, r_ui) = self.data.div_rem(&other.data);
                    let d = BigInt::from_biguint(self.sign, d_ui);
                    let r = BigInt::from_biguint(self.sign, r_ui);
                    if other.is_negative() {
                        (-d, r)
                    } else {
                        (d, r)
                    }
                }

                #[inline]
                fn div_floor(&self, other: &BigInt) -> BigInt {
                    let (d_ui, m) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => d,
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                -d
                            } else {
                                -d - 1u32
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                #[inline]
                fn mod_floor(&self, other: &BigInt) -> BigInt {
                   
                    let m_ui = self.data.mod_floor(&other.data);
                    let m = BigInt::from_biguint(other.sign, m_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => m,
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                m
                            } else {
                                other - m
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {
                   
                    let (d_ui, m_ui) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    let m = BigInt::from_biguint(other.sign, m_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => (d, m),
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                (-d, m)
                            } else {
                                (-d - 1u32, other - m)
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                #[inline]
                fn div_ceil(&self, other: &Self) -> Self {
                    let (d_ui, m) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    match (self.sign, other.sign) {
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => -d,
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => {
                            if m.is_zero() {
                                d
                            } else {
                                d + 1u32
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.
                ///
                /// The result is always positive.
                #[inline]
                fn gcd(&self, other: &BigInt) -> BigInt {
                    BigInt::from(self.data.gcd(&other.data))
                }

                /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                #[inline]
                fn lcm(&self, other: &BigInt) -> BigInt {
                    BigInt::from(self.data.lcm(&other.data))
                }

                /// Calculates the Greatest Common Divisor (GCD) and
                /// Lowest Common Multiple (LCM) together.
                #[inline]
                fn gcd_lcm(&self, other: &BigInt) -> (BigInt, BigInt) {
                    let (gcd, lcm) = self.data.gcd_lcm(&other.data);
                    (BigInt::from(gcd), BigInt::from(lcm))
                }

                /// Greatest common divisor, least common multiple, and Bézout coefficients.
                #[inline]
                fn extended_gcd_lcm(&self, other: &BigInt) -> (num_integer::ExtendedGcd<BigInt>, BigInt) {
                    let egcd = self.extended_gcd(other);
                    let lcm = if egcd.gcd.is_zero() {
                        Self::ZERO
                    } else {
                        BigInt::from(&self.data / &egcd.gcd.data * &other.data)
                    };
                    (egcd, lcm)
                }

                /// Deprecated, use `is_multiple_of` instead.
                #[inline]
                fn divides(&self, other: &BigInt) -> bool {
                    self.is_multiple_of(other)
                }

                /// Returns `true` if the number is a multiple of `other`.
                #[inline]
                fn is_multiple_of(&self, other: &BigInt) -> bool {
                    self.data.is_multiple_of(&other.data)
                }

                /// Returns `true` if the number is divisible by `2`.
                #[inline]
                fn is_even(&self) -> bool {
                    self.data.is_even()
                }

                /// Returns `true` if the number is not divisible by `2`.
                #[inline]
                fn is_odd(&self) -> bool {
                    self.data.is_odd()
                }

                /// Rounds up to nearest multiple of argument.
                #[inline]
                fn next_multiple_of(&self, other: &Self) -> Self {
                    let m = self.mod_floor(other);
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + (other - m)
                    }
                }
                /// Rounds down to nearest multiple of argument.
                #[inline]
                fn prev_multiple_of(&self, other: &Self) -> Self {
                    self - self.mod_floor(other)
                }

                fn dec(&mut self) {
                    *self -= 1u32;
                }

                fn inc(&mut self) {
                    *self += 1u32;
                }
            }

            impl Roots for BigInt {
                fn nth_root(&self, n: u32) -> Self {
                    assert!(
                        !(self.is_negative() && n.is_even()),
                        "root of degree {} is imaginary",
                        n
                    );

                    BigInt::from_biguint(self.sign, self.data.nth_root(n))
                }

                fn sqrt(&self) -> Self {
                    assert!(!self.is_negative(), "square root is imaginary");

                    BigInt::from_biguint(self.sign, self.data.sqrt())
                }

                fn cbrt(&self) -> Self {
                    BigInt::from_biguint(self.sign, self.data.cbrt())
                }
            }

            impl IntDigits for BigInt {
                #[inline]
                fn digits(&self) -> &[BigDigit] {
                    self.data.digits()
                }
                #[inline]
                fn digits_mut(&mut self) -> &mut Vec<BigDigit> {
                    self.data.digits_mut()
                }
                #[inline]
                fn normalize(&mut self) {
                    self.data.normalize();
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
                #[inline]
                fn capacity(&self) -> usize {
                    self.data.capacity()
                }
                #[inline]
                fn len(&self) -> usize {
                    self.data.len()
                }
            }
            /// A generic trait for converting a value to a [`BigInt`]. This may return
            /// `None` when converting from `f32` or `f64`, and will always succeed
            /// when converting from any integer or unsigned primitive, or [`BigUint`].
            pub trait ToBigInt {
                /// Converts the value of `self` to a [`BigInt`].
                fn to_bigint(&self) -> Option<BigInt>;
            }

            impl BigInt {
                /// A constant `BigInt` with value 0, useful for static initialization.
                pub const ZERO: Self = BigInt {
                    sign: NoSign,
                    data: BigUint::ZERO,
                };

                /// Creates and initializes a [`BigInt`].
                ///
                /// The base 2<sup>32</sup> digits are ordered least significant digit first.
                #[inline]
                pub fn new(sign: Sign, digits: Vec<u32>) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::new(digits))
                }

                /// Creates and initializes a [`BigInt`].
                ///
                /// The base 2<sup>32</sup> digits are ordered least significant digit first.
                #[inline]
                pub fn from_biguint(mut sign: Sign, mut data: BigUint) -> BigInt {
                    if sign == NoSign {
                        data.assign_from_slice(&[]);
                    } else if data.is_zero() {
                        sign = NoSign;
                    }

                    BigInt { sign, data }
                }

                /// Creates and initializes a [`BigInt`].
                ///
                /// The base 2<sup>32</sup> digits are ordered least significant digit first.
                #[inline]
                pub fn from_slice(sign: Sign, slice: &[u32]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_slice(slice))
                }

                /// Reinitializes a [`BigInt`].
                ///
                /// The base 2<sup>32</sup> digits are ordered least significant digit first.
                #[inline]
                pub fn assign_from_slice(&mut self, sign: Sign, slice: &[u32]) {
                    if sign == NoSign {
                        self.set_zero();
                    } else {
                        self.data.assign_from_slice(slice);
                        self.sign = if self.data.is_zero() { NoSign } else { sign };
                    }
                }

                /// Creates and initializes a [`BigInt`].
                ///
                /// The bytes are in big-endian byte order.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from_bytes_be(Sign::Plus, b"A"),
                ///            BigInt::parse_bytes(b"65", 10).unwrap());
                /// assert_eq!(BigInt::from_bytes_be(Sign::Plus, b"AA"),
                ///            BigInt::parse_bytes(b"16705", 10).unwrap());
                /// assert_eq!(BigInt::from_bytes_be(Sign::Plus, b"AB"),
                ///            BigInt::parse_bytes(b"16706", 10).unwrap());
                /// assert_eq!(BigInt::from_bytes_be(Sign::Plus, b"Hello world!"),
                ///            BigInt::parse_bytes(b"22405534230753963835153736737", 10).unwrap());
                /// ```
                #[inline]
                pub fn from_bytes_be(sign: Sign, bytes: &[u8]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_bytes_be(bytes))
                }

                /// Creates and initializes a [`BigInt`].
                ///
                /// The bytes are in little-endian byte order.
                #[inline]
                pub fn from_bytes_le(sign: Sign, bytes: &[u8]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_bytes_le(bytes))
                }

                /// Creates and initializes a [`BigInt`] from an array of bytes in
                /// two's complement binary representation.
                ///
                /// The digits are in big-endian base 2<sup>8</sup>.
                #[inline]
                pub fn from_signed_bytes_be(digits: &[u8]) -> BigInt {
                    convert::from_signed_bytes_be(digits)
                }

                /// Creates and initializes a [`BigInt`] from an array of bytes in two's complement.
                ///
                /// The digits are in little-endian base 2<sup>8</sup>.
                #[inline]
                pub fn from_signed_bytes_le(digits: &[u8]) -> BigInt {
                    convert::from_signed_bytes_le(digits)
                }

                /// Creates and initializes a [`BigInt`].
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, ToBigInt};
                ///
                /// assert_eq!(BigInt::parse_bytes(b"1234", 10), ToBigInt::to_bigint(&1234));
                /// assert_eq!(BigInt::parse_bytes(b"ABCD", 16), ToBigInt::to_bigint(&0xABCD));
                /// assert_eq!(BigInt::parse_bytes(b"G", 16), None);
                /// ```
                #[inline]
                pub fn parse_bytes(buf: &[u8], radix: u32) -> Option<BigInt> {
                    let s = str::from_utf8(buf).ok()?;
                    BigInt::from_str_radix(s, radix).ok()
                }

                /// Creates and initializes a [`BigInt`]. Each `u8` of the input slice is
                /// interpreted as one digit of the number
                /// and must therefore be less than `radix`.
                ///
                /// The bytes are in big-endian byte order.
                /// `radix` must be in the range `2...256`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, Sign};
                ///
                /// let inbase190 = vec![15, 33, 125, 12, 14];
                /// let a = BigInt::from_radix_be(Sign::Minus, &inbase190, 190).unwrap();
                /// assert_eq!(a.to_radix_be(190), (Sign:: Minus, inbase190));
                /// ```
                pub fn from_radix_be(sign: Sign, buf: &[u8], radix: u32) -> Option<BigInt> {
                    let u = BigUint::from_radix_be(buf, radix)?;
                    Some(BigInt::from_biguint(sign, u))
                }

                /// Creates and initializes a [`BigInt`]. Each `u8` of the input slice is
                /// interpreted as one digit of the number
                /// and must therefore be less than `radix`.
                ///
                /// The bytes are in little-endian byte order.
                /// `radix` must be in the range `2...256`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, Sign};
                ///
                /// let inbase190 = vec![14, 12, 125, 33, 15];
                /// let a = BigInt::from_radix_be(Sign::Minus, &inbase190, 190).unwrap();
                /// assert_eq!(a.to_radix_be(190), (Sign::Minus, inbase190));
                /// ```
                pub fn from_radix_le(sign: Sign, buf: &[u8], radix: u32) -> Option<BigInt> {
                    let u = BigUint::from_radix_le(buf, radix)?;
                    Some(BigInt::from_biguint(sign, u))
                }

                /// Returns the sign and the byte representation of the [`BigInt`] in big-endian byte order.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{ToBigInt, Sign};
                ///
                /// let i = -1125.to_bigint().unwrap();
                /// assert_eq!(i.to_bytes_be(), (Sign::Minus, vec![4, 101]));
                /// ```
                #[inline]
                pub fn to_bytes_be(&self) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_bytes_be())
                }

                /// Returns the sign and the byte representation of the [`BigInt`] in little-endian byte order.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{ToBigInt, Sign};
                ///
                /// let i = -1125.to_bigint().unwrap();
                /// assert_eq!(i.to_bytes_le(), (Sign::Minus, vec![101, 4]));
                /// ```
                #[inline]
                pub fn to_bytes_le(&self) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_bytes_le())
                }

                /// Returns the sign and the `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(-1125).to_u32_digits(), (Sign::Minus, vec![1125]));
                /// assert_eq!(BigInt::from(4294967295u32).to_u32_digits(), (Sign::Plus, vec![4294967295]));
                /// assert_eq!(BigInt::from(4294967296u64).to_u32_digits(), (Sign::Plus, vec![0, 1]));
                /// assert_eq!(BigInt::from(-112500000000i64).to_u32_digits(), (Sign::Minus, vec![830850304, 26]));
                /// assert_eq!(BigInt::from(112500000000i64).to_u32_digits(), (Sign::Plus, vec![830850304, 26]));
                /// ```
                #[inline]
                pub fn to_u32_digits(&self) -> (Sign, Vec<u32>) {
                    (self.sign, self.data.to_u32_digits())
                }

                /// Returns the sign and the `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(-1125).to_u64_digits(), (Sign::Minus, vec![1125]));
                /// assert_eq!(BigInt::from(4294967295u32).to_u64_digits(), (Sign::Plus, vec![4294967295]));
                /// assert_eq!(BigInt::from(4294967296u64).to_u64_digits(), (Sign::Plus, vec![4294967296]));
                /// assert_eq!(BigInt::from(-112500000000i64).to_u64_digits(), (Sign::Minus, vec![112500000000]));
                /// assert_eq!(BigInt::from(112500000000i64).to_u64_digits(), (Sign::Plus, vec![112500000000]));
                /// assert_eq!(BigInt::from(1u128 << 64).to_u64_digits(), (Sign::Plus, vec![0, 1]));
                /// ```
                #[inline]
                pub fn to_u64_digits(&self) -> (Sign, Vec<u64>) {
                    (self.sign, self.data.to_u64_digits())
                }

                /// Returns an iterator of `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::BigInt;
                ///
                /// assert_eq!(BigInt::from(-1125).iter_u32_digits().collect::<Vec<u32>>(), vec![1125]);
                /// assert_eq!(BigInt::from(4294967295u32).iter_u32_digits().collect::<Vec<u32>>(), vec![4294967295]);
                /// assert_eq!(BigInt::from(4294967296u64).iter_u32_digits().collect::<Vec<u32>>(), vec![0, 1]);
                /// assert_eq!(BigInt::from(-112500000000i64).iter_u32_digits().collect::<Vec<u32>>(), vec![830850304, 26]);
                /// assert_eq!(BigInt::from(112500000000i64).iter_u32_digits().collect::<Vec<u32>>(), vec![830850304, 26]);
                /// ```
                #[inline]
                pub fn iter_u32_digits(&self) -> U32Digits<'_> {
                    self.data.iter_u32_digits()
                }

                /// Returns an iterator of `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::BigInt;
                ///
                /// assert_eq!(BigInt::from(-1125).iter_u64_digits().collect::<Vec<u64>>(), vec![1125u64]);
                /// assert_eq!(BigInt::from(4294967295u32).iter_u64_digits().collect::<Vec<u64>>(), vec![4294967295u64]);
                /// assert_eq!(BigInt::from(4294967296u64).iter_u64_digits().collect::<Vec<u64>>(), vec![4294967296u64]);
                /// assert_eq!(BigInt::from(-112500000000i64).iter_u64_digits().collect::<Vec<u64>>(), vec![112500000000u64]);
                /// assert_eq!(BigInt::from(112500000000i64).iter_u64_digits().collect::<Vec<u64>>(), vec![112500000000u64]);
                /// assert_eq!(BigInt::from(1u128 << 64).iter_u64_digits().collect::<Vec<u64>>(), vec![0, 1]);
                /// ```
                #[inline]
                pub fn iter_u64_digits(&self) -> U64Digits<'_> {
                    self.data.iter_u64_digits()
                }

                /// Returns the two's-complement byte representation of the [`BigInt`] in big-endian byte order.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::ToBigInt;
                ///
                /// let i = -1125.to_bigint().unwrap();
                /// assert_eq!(i.to_signed_bytes_be(), vec![251, 155]);
                /// ```
                #[inline]
                pub fn to_signed_bytes_be(&self) -> Vec<u8> {
                    convert::to_signed_bytes_be(self)
                }

                /// Returns the two's-complement byte representation of the [`BigInt`] in little-endian byte order.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::ToBigInt;
                ///
                /// let i = -1125.to_bigint().unwrap();
                /// assert_eq!(i.to_signed_bytes_le(), vec![155, 251]);
                /// ```
                #[inline]
                pub fn to_signed_bytes_le(&self) -> Vec<u8> {
                    convert::to_signed_bytes_le(self)
                }

                /// Returns the integer formatted as a string in the given radix.
                /// `radix` must be in the range `2...36`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::BigInt;
                ///
                /// let i = BigInt::parse_bytes(b"ff", 16).unwrap();
                /// assert_eq!(i.to_str_radix(16), "ff");
                /// ```
                #[inline]
                pub fn to_str_radix(&self, radix: u32) -> String {
                    let mut v = to_str_radix_reversed(&self.data, radix);

                    if self.is_negative() {
                        v.push(b'-');
                    }

                    v.reverse();
                    unsafe { String::from_utf8_unchecked(v) }
                }

                /// Returns the integer in the requested base in big-endian digit order.
                /// The output is not given in a human readable alphabet but as a zero
                /// based `u8` number.
                /// `radix` must be in the range `2...256`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(-0xFFFFi64).to_radix_be(159),
                ///            (Sign::Minus, vec![2, 94, 27]));
                ///
                /// ```
                #[inline]
                pub fn to_radix_be(&self, radix: u32) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_radix_be(radix))
                }

                /// Returns the integer in the requested base in little-endian digit order.
                /// The output is not given in a human readable alphabet but as a zero
                /// based `u8` number.
                /// `radix` must be in the range `2...256`.
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(-0xFFFFi64).to_radix_le(159),
                ///            (Sign::Minus, vec![27, 94, 2]));
                ///
                /// ```
                #[inline]
                pub fn to_radix_le(&self, radix: u32) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_radix_le(radix))
                }

                /// Returns the sign of the [`BigInt`] as a [`Sign`].
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(1234).sign(), Sign::Plus);
                /// assert_eq!(BigInt::from(-4321).sign(), Sign::Minus);
                /// assert_eq!(BigInt::ZERO.sign(), Sign::NoSign);
                /// ```
                #[inline]
                pub fn sign(&self) -> Sign {
                    self.sign
                }

                /// Returns the magnitude of the [`BigInt`] as a [`BigUint`].
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, BigUint};
                /// use num_traits::Zero;
                ///
                /// assert_eq!(BigInt::from(1234).magnitude(), &BigUint::from(1234u32));
                /// assert_eq!(BigInt::from(-4321).magnitude(), &BigUint::from(4321u32));
                /// assert!(BigInt::ZERO.magnitude().is_zero());
                /// ```
                #[inline]
                pub fn magnitude(&self) -> &BigUint {
                    &self.data
                }

                /// Convert this [`BigInt`] into its [`Sign`] and [`BigUint`] magnitude,
                /// the reverse of [`BigInt::from_biguint()`].
                ///
                /// # Examples
                ///
                /// ```
                /// use num_bigint::{BigInt, BigUint, Sign};
                ///
                /// assert_eq!(BigInt::from(1234).into_parts(), (Sign::Plus, BigUint::from(1234u32)));
                /// assert_eq!(BigInt::from(-4321).into_parts(), (Sign::Minus, BigUint::from(4321u32)));
                /// assert_eq!(BigInt::ZERO.into_parts(), (Sign::NoSign, BigUint::ZERO));
                /// ```
                #[inline]
                pub fn into_parts(self) -> (Sign, BigUint) {
                    (self.sign, self.data)
                }

                /// Determines the fewest bits necessary to express the [`BigInt`],
                /// not including the sign.
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.data.bits()
                }

                /// Converts this [`BigInt`] into a [`BigUint`], if it's not negative.
                #[inline]
                pub fn to_biguint(&self) -> Option<BigUint> {
                    match self.sign {
                        Plus => Some(self.data.clone()),
                        NoSign => Some(BigUint::ZERO),
                        Minus => None,
                    }
                }

                #[inline]
                pub fn checked_add(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self + v)
                }

                #[inline]
                pub fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self - v)
                }

                #[inline]
                pub fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self * v)
                }

                #[inline]
                pub fn checked_div(&self, v: &BigInt) -> Option<BigInt> {
                    if v.is_zero() {
                        return None;
                    }
                    Some(self / v)
                }

                /// Returns `self ^ exponent`.
                pub fn pow(&self, exponent: u32) -> Self {
                    Pow::pow(self, exponent)
                }

                /// Returns `(self ^ exponent) mod modulus`
                ///
                /// Note that this rounds like `mod_floor`, not like the `%` operator,
                /// which makes a difference when given a negative `self` or `modulus`.
                /// The result will be in the interval `[0, modulus)` for `modulus > 0`,
                /// or in the interval `(modulus, 0]` for `modulus < 0`
                ///
                /// Panics if the exponent is negative or the modulus is zero.
                pub fn modpow(&self, exponent: &Self, modulus: &Self) -> Self {
                    power::modpow(self, exponent, modulus)
                }

                /// Returns the modular multiplicative inverse if it exists, otherwise `None`.
                ///
                /// This solves for `x` such that `self * x ≡ 1 (mod modulus)`.
                /// Note that this rounds like `mod_floor`, not like the `%` operator,
                /// which makes a difference when given a negative `self` or `modulus`.
                /// The solution will be in the interval `[0, modulus)` for `modulus > 0`,
                /// or in the interval `(modulus, 0]` for `modulus < 0`,
                /// and it exists if and only if `gcd(self, modulus) == 1`.
                ///
                /// ```
                /// use num_bigint::BigInt;
                /// use num_integer::Integer;
                /// use num_traits::{One, Zero};
                ///
                /// let m = BigInt::from(383);
                ///
                ///
                /// assert_eq!(BigInt::zero().modinv(&m), None);
                /// assert_eq!(BigInt::one().modinv(&m), Some(BigInt::one()));
                /// let neg1 = &m - 1u32;
                /// assert_eq!(neg1.modinv(&m), Some(neg1));
                ///
                ///
                /// let a = BigInt::from(271);
                /// let x = a.modinv(&m).unwrap();
                /// assert_eq!(x, BigInt::from(106));
                /// assert_eq!(x.modinv(&m).unwrap(), a);
                /// assert_eq!((&a * x).mod_floor(&m), BigInt::one());
                ///
                ///
                /// let b = -&a;
                /// let x = b.modinv(&m).unwrap();
                /// assert_eq!(x, BigInt::from(277));
                /// assert_eq!((&b * x).mod_floor(&m), BigInt::one());
                ///
                ///
                /// let n = -&m;
                /// let x = a.modinv(&n).unwrap();
                /// assert_eq!(x, BigInt::from(-277));
                /// assert_eq!((&a * x).mod_floor(&n), &n + 1);
                ///
                ///
                /// let x = b.modinv(&n).unwrap();
                /// assert_eq!(x, BigInt::from(-106));
                /// assert_eq!((&b * x).mod_floor(&n), &n + 1);
                /// ```
                pub fn modinv(&self, modulus: &Self) -> Option<Self> {
                    let result = self.data.modinv(&modulus.data)?;
                   
                    let (sign, mag) = match (self.is_negative(), modulus.is_negative()) {
                        (false, false) => (Plus, result),
                        (true, false) => (Plus, &modulus.data - result),
                        (false, true) => (Minus, &modulus.data - result),
                        (true, true) => (Minus, result),
                    };
                    Some(BigInt::from_biguint(sign, mag))
                }

                /// Returns the truncated principal square root of `self` --
                /// see [`num_integer::Roots::sqrt()`].
                pub fn sqrt(&self) -> Self {
                    Roots::sqrt(self)
                }

                /// Returns the truncated principal cube root of `self` --
                /// see [`num_integer::Roots::cbrt()`].
                pub fn cbrt(&self) -> Self {
                    Roots::cbrt(self)
                }

                /// Returns the truncated principal `n`th root of `self` --
                /// See [`num_integer::Roots::nth_root()`].
                pub fn nth_root(&self, n: u32) -> Self {
                    Roots::nth_root(self, n)
                }

                /// Returns the number of least-significant bits that are zero,
                /// or `None` if the entire number is zero.
                pub fn trailing_zeros(&self) -> Option<u64> {
                    self.data.trailing_zeros()
                }

                /// Returns whether the bit in position `bit` is set,
                /// using the two's complement for negative numbers
                pub fn bit(&self, bit: u64) -> bool {
                    if self.is_negative() {
                       
                       
                       
                       
                       
                        if bit >= u64::from(crate::big_digit::BITS) * self.len() as u64 {
                            true
                        } else {
                            let trailing_zeros = self.data.trailing_zeros().unwrap();
                            match Ord::cmp(&bit, &trailing_zeros) {
                                Ordering::Less => false,
                                Ordering::Equal => true,
                                Ordering::Greater => !self.data.bit(bit),
                            }
                        }
                    } else {
                        self.data.bit(bit)
                    }
                }

                /// Sets or clears the bit in the given position,
                /// using the two's complement for negative numbers
                ///
                /// Note that setting/clearing a bit (for positive/negative numbers,
                /// respectively) greater than the current bit length, a reallocation
                /// may be needed to store the new digits
                pub fn set_bit(&mut self, bit: u64, value: bool) {
                    match self.sign {
                        Sign::Plus => self.data.set_bit(bit, value),
                        Sign::Minus => bits::set_negative_bit(self, bit, value),
                        Sign::NoSign => {
                            if value {
                                self.data.set_bit(bit, true);
                                self.sign = Sign::Plus;
                            } else {
                               
                            }
                        }
                    }
                   
                    self.normalize();
                }
            }

            impl num_traits::FromBytes for BigInt {
                type Bytes = [u8];

                fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                    Self::from_signed_bytes_be(bytes)
                }

                fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                    Self::from_signed_bytes_le(bytes)
                }
            }

            impl num_traits::ToBytes for BigInt {
                type Bytes = Vec<u8>;

                fn to_be_bytes(&self) -> Self::Bytes {
                    self.to_signed_bytes_be()
                }

                fn to_le_bytes(&self) -> Self::Bytes {
                    self.to_signed_bytes_le()
                }
            }
        }

        pub mod bigrand
        {
            //! Randomization of big integers
            use ::
            {
                *,
            };
            /*
                #![cfg(feature = "rand")]
                #![cfg_attr(docsrs, doc(cfg(feature = "rand")))]

                use rand::distributions::uniform::{SampleBorrow, SampleUniform, UniformSampler};
                use rand::prelude::*;

                use crate::BigInt;
                use crate::BigUint;
                use crate::Sign::*;

                use crate::biguint::biguint_from_vec;

                use num_integer::Integer;
                use num_traits::{ToPrimitive, Zero};
            */
            /// A trait for sampling random big integers.
            ///
            /// The `rand` feature must be enabled to use this. See crate-level documentation for details.
            pub trait RandBigInt {
                /// Generate a random [`BigUint`] of the given bit size.
                fn gen_biguint(&mut self, bit_size: u64) -> BigUint;

                /// Generate a random [ BigInt`] of the given bit size.
                fn gen_bigint(&mut self, bit_size: u64) -> BigInt;

                /// Generate a random [`BigUint`] less than the given bound. Fails
                /// when the bound is zero.
                fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;

                /// Generate a random [`BigUint`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;

                /// Generate a random [`BigInt`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;
            }

            fn gen_bits<R: Rng + ?Sized>(rng: &mut R, data: &mut [u32], rem: u64) {
               
                rng.fill(data);
                if rem > 0 {
                    let last = data.len() - 1;
                    data[last] >>= 32 - rem;
                }
            }

            impl<R: Rng + ?Sized> RandBigInt for R {
                cfg_digit!(
                    fn gen_biguint(&mut self, bit_size: u64) -> BigUint {
                        let (digits, rem) = bit_size.div_rem(&32);
                        let len = (digits + (rem > 0) as u64)
                            .to_usize()
                            .expect("capacity overflow");
                        let mut data = vec![0u32; len];
                        gen_bits(self, &mut data, rem);
                        biguint_from_vec(data)
                    }

                    fn gen_biguint(&mut self, bit_size: u64) -> BigUint {
                        use core::slice;

                        let (digits, rem) = bit_size.div_rem(&32);
                        let len = (digits + (rem > 0) as u64)
                            .to_usize()
                            .expect("capacity overflow");
                        let native_digits = Integer::div_ceil(&bit_size, &64);
                        let native_len = native_digits.to_usize().expect("capacity overflow");
                        let mut data = vec![0u64; native_len];
                        unsafe {
                           
                            let ptr = data.as_mut_ptr() as *mut u32;
                            debug_assert!(native_len * 2 >= len);
                            let data = slice::from_raw_parts_mut(ptr, len);
                            gen_bits(self, data, rem);
                        }
                        #[cfg(target_endian = "big")]
                        for digit in &mut data {
                           
                            *digit = (*digit << 32) | (*digit >> 32);
                        }
                        biguint_from_vec(data)
                    }
                );

                fn gen_bigint(&mut self, bit_size: u64) -> BigInt {
                    loop {
                       
                        let biguint = self.gen_biguint(bit_size);
                       
                        let sign = if biguint.is_zero() {
                           
                           
                           
                           
                            if self.gen() {
                                continue;
                            } else {
                                NoSign
                            }
                        } else if self.gen() {
                            Plus
                        } else {
                            Minus
                        };
                        return BigInt::from_biguint(sign, biguint);
                    }
                }

                fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint {
                    assert!(!bound.is_zero());
                    let bits = bound.bits();
                    loop {
                        let n = self.gen_biguint(bits);
                        if n < *bound {
                            return n;
                        }
                    }
                }

                fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint {
                    assert!(*lbound < *ubound);
                    if lbound.is_zero() {
                        self.gen_biguint_below(ubound)
                    } else {
                        lbound + self.gen_biguint_below(&(ubound - lbound))
                    }
                }

                fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt {
                    assert!(*lbound < *ubound);
                    if lbound.is_zero() {
                        BigInt::from(self.gen_biguint_below(ubound.magnitude()))
                    } else if ubound.is_zero() {
                        lbound + BigInt::from(self.gen_biguint_below(lbound.magnitude()))
                    } else {
                        let delta = ubound - lbound;
                        lbound + BigInt::from(self.gen_biguint_below(delta.magnitude()))
                    }
                }
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigUint`].
            #[derive(Clone, Debug)]
            pub struct UniformBigUint {
                base: BigUint,
                len: BigUint,
            }

            impl UniformSampler for UniformBigUint {
                type X = BigUint;

                #[inline]
                fn new<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low < high);
                    UniformBigUint {
                        len: high - low,
                        base: low.clone(),
                    }
                }

                #[inline]
                fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low <= high);
                    Self::new(low, high + 1u32)
                }

                #[inline]
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
                    &self.base + rng.gen_biguint_below(&self.len)
                }

                #[inline]
                fn sample_single<R: Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_biguint_range(low.borrow(), high.borrow())
                }
            }

            impl SampleUniform for BigUint {
                type Sampler = UniformBigUint;
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigInt`].
            #[derive(Clone, Debug)]
            pub struct UniformBigInt {
                base: BigInt,
                len: BigUint,
            }

            impl UniformSampler for UniformBigInt {
                type X = BigInt;

                #[inline]
                fn new<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low < high);
                    UniformBigInt {
                        len: (high - low).into_parts().1,
                        base: low.clone(),
                    }
                }

                #[inline]
                fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low <= high);
                    Self::new(low, high + 1u32)
                }

                #[inline]
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
                    &self.base + BigInt::from(rng.gen_biguint_below(&self.len))
                }

                #[inline]
                fn sample_single<R: Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_bigint_range(low.borrow(), high.borrow())
                }
            }

            impl SampleUniform for BigInt {
                type Sampler = UniformBigInt;
            }
            /// A random distribution for [`BigUint`] and [`BigInt`] values of a particular bit size.
            ///
            /// The `rand` feature must be enabled to use this. See crate-level documentation for details.
            #[derive(Clone, Copy, Debug)]
            pub struct RandomBits {
                bits: u64,
            }

            impl RandomBits {
                #[inline]
                pub fn new(bits: u64) -> RandomBits {
                    RandomBits { bits }
                }
            }

            impl Distribution<BigUint> for RandomBits {
                #[inline]
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> BigUint {
                    rng.gen_biguint(self.bits)
                }
            }

            impl Distribution<BigInt> for RandomBits {
                #[inline]
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> BigInt {
                    rng.gen_bigint(self.bits)
                }
            }

        }

        pub mod biguint
        {
            use ::
            {
                *,
            };
            /*
            use crate::big_digit::{self, BigDigit};
            use alloc::string::String;
            use alloc::vec::Vec;
            use core::cmp;
            use core::cmp::Ordering;
            use core::default::Default;
            use core::fmt;
            use core::hash;
            use core::mem;
            use core::str;
            use num_integer::{Integer, Roots};
            use num_traits::{ConstZero, Num, One, Pow, ToPrimitive, Unsigned, Zero};

            pub(crate) use self::convert::to_str_radix_reversed;
            pub use self::iter::{U32Digits, U64Digits};
            */
            pub mod addition
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use super::{BigUint, IntDigits};

                use crate::big_digit::{self, BigDigit};
                use crate::UsizePromotion;

                use core::iter::Sum;
                use core::ops::{Add, AddAssign};
                use num_traits::CheckedAdd;

                #[cfg(target_arch = "x86_64")]
                use core::arch::x86_64 as arch;

                #[cfg(target_arch = "x86")]
                use core::arch::x86 as arch;
                */
               
                #[cfg(target_arch = "x86_64")]
                cfg_64!(
                    #[inline]
                    fn adc(carry: u8, a: u64, b: u64, out: &mut u64) -> u8 {
                       
                       
                        unsafe { arch::_addcarry_u64(carry, a, b, out) }
                    }
                );

                #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
                cfg_32!(
                    #[inline]
                    fn adc(carry: u8, a: u32, b: u32, out: &mut u32) -> u8 {
                       
                       
                        unsafe { arch::_addcarry_u32(carry, a, b, out) }
                    }
                );

               
               
                #[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
                #[inline]
                fn adc(carry: u8, lhs: BigDigit, rhs: BigDigit, out: &mut BigDigit) -> u8 {
                    let (a, b) = lhs.overflowing_add(rhs);
                    let (c, d) = a.overflowing_add(carry as BigDigit);
                    *out = c;
                    u8::from(b || d)
                }

                /// Two argument addition of raw slices, `a += b`, returning the carry.
                ///
                /// This is used when the data `Vec` might need to resize to push a non-zero carry, so we perform
                /// the addition first hoping that it will fit.
                ///
                /// The caller _must_ ensure that `a` is at least as long as `b`.
                #[inline]
                pub(super) fn __add2(a: &mut [BigDigit], b: &[BigDigit]) -> BigDigit {
                    debug_assert!(a.len() >= b.len());

                    let mut carry = 0;
                    let (a_lo, a_hi) = a.split_at_mut(b.len());

                    for (a, b) in a_lo.iter_mut().zip(b) {
                        carry = adc(carry, *a, *b, a);
                    }

                    if carry != 0 {
                        for a in a_hi {
                            carry = adc(carry, *a, 0, a);
                            if carry == 0 {
                                break;
                            }
                        }
                    }

                    carry as BigDigit
                }

                /// Two argument addition of raw slices:
                /// a += b
                ///
                /// The caller _must_ ensure that a is big enough to store the result - typically this means
                /// resizing a to max(a.len(), b.len()) + 1, to fit a possible carry.
                pub(super) fn add2(a: &mut [BigDigit], b: &[BigDigit]) {
                    let carry = __add2(a, b);

                    debug_assert!(carry == 0);
                }

                forward_all_binop_to_val_ref_commutative!(impl Add for BigUint, add);
                forward_val_assign!(impl AddAssign for BigUint, add_assign);

                impl Add<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn add(mut self, other: &BigUint) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<&BigUint> for BigUint {
                    #[inline]
                    fn add_assign(&mut self, other: &BigUint) {
                        let self_len = self.data.len();
                        let carry = if self_len < other.data.len() {
                            let lo_carry = __add2(&mut self.data[..], &other.data[..self_len]);
                            self.data.extend_from_slice(&other.data[self_len..]);
                            __add2(&mut self.data[self_len..], &[lo_carry])
                        } else {
                            __add2(&mut self.data[..], &other.data[..])
                        };
                        if carry != 0 {
                            self.data.push(carry);
                        }
                    }
                }

                promote_unsigned_scalars!(impl Add for BigUint, add);
                promote_unsigned_scalars_assign!(impl AddAssign for BigUint, add_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u32> for BigUint, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u64> for BigUint, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u128> for BigUint, add);

                impl Add<u32> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn add(mut self, other: u32) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u32> for BigUint {
                    #[inline]
                    fn add_assign(&mut self, other: u32) {
                        if other != 0 {
                            if self.data.is_empty() {
                                self.data.push(0);
                            }

                            let carry = __add2(&mut self.data, &[other as BigDigit]);
                            if carry != 0 {
                                self.data.push(carry);
                            }
                        }
                    }
                }

                impl Add<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn add(mut self, other: u64) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn add_assign(&mut self, other: u64) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[lo, hi]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }

                        #[inline]
                        fn add_assign(&mut self, other: u64) {
                            if other != 0 {
                                if self.data.is_empty() {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[other as BigDigit]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }
                    );
                }

                impl Add<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn add(mut self, other: u128) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn add_assign(&mut self, other: u128) {
                            if other <= u128::from(u64::MAX) {
                                *self += other as u64
                            } else {
                                let (a, b, c, d) = super::u32_from_u128(other);
                                let carry = if a > 0 {
                                    while self.data.len() < 4 {
                                        self.data.push(0);
                                    }
                                    __add2(&mut self.data, &[d, c, b, a])
                                } else {
                                    debug_assert!(b > 0);
                                    while self.data.len() < 3 {
                                        self.data.push(0);
                                    }
                                    __add2(&mut self.data, &[d, c, b])
                                };

                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }

                        #[inline]
                        fn add_assign(&mut self, other: u128) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[lo, hi]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }
                    );
                }

                impl CheckedAdd for BigUint {
                    #[inline]
                    fn checked_add(&self, v: &BigUint) -> Option<BigUint> {
                        Some(self.add(v))
                    }
                }

                impl_sum_iter_type!(BigUint);

            }

            pub mod division
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use super::addition::__add2;
                use super::{cmp_slice, BigUint};

                use crate::big_digit::{self, BigDigit, DoubleBigDigit};
                use crate::UsizePromotion;

                use core::cmp::Ordering::{Equal, Greater, Less};
                use core::mem;
                use core::ops::{Div, DivAssign, Rem, RemAssign};
                use num_integer::Integer;
                use num_traits::{CheckedDiv, CheckedEuclid, Euclid, One, ToPrimitive, Zero};

                */
                pub(super) const FAST_DIV_WIDE: bool = cfg!(any(target_arch = "x86", target_arch = "x86_64"));

                /// Divide a two digit numerator by a one digit divisor, returns quotient and remainder:
                ///
                /// Note: the caller must ensure that both the quotient and remainder will fit into a single digit.
                /// This is _not_ true for an arbitrary numerator/denominator.
                ///
                /// (This function also matches what the x86 divide instruction does).
                #[cfg(any(miri, not(any(target_arch = "x86", target_arch = "x86_64"))))]
                #[inline]
                fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
                    debug_assert!(hi < divisor);

                    let lhs = big_digit::to_doublebigdigit(hi, lo);
                    let rhs = DoubleBigDigit::from(divisor);
                    ((lhs / rhs) as BigDigit, (lhs % rhs) as BigDigit)
                }

                /// x86 and x86_64 can use a real `div` instruction.
                #[cfg(all(not(miri), any(target_arch = "x86", target_arch = "x86_64")))]
                #[inline]
                fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
                   
                   
                   
                    debug_assert!(hi < divisor);

                   
                   
                   
                   
                    unsafe {
                        let (div, rem);

                        cfg_digit!(
                            macro_rules! div {
                                () => {
                                    "div {0:e}"
                                };
                            }
                            macro_rules! div {
                                () => {
                                    "div {0:r}"
                                };
                            }
                        );

                        core::arch::asm!(
                            div!(),
                            in(reg) divisor,
                            inout("dx") hi => rem,
                            inout("ax") lo => div,
                            options(pure, nomem, nostack),
                        );

                        (div, rem)
                    }
                }

                /// For small divisors, we can divide without promoting to `DoubleBigDigit` by
                /// using half-size pieces of digit, like long-division.
                #[inline]
                fn div_half(rem: BigDigit, digit: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
                    use crate::big_digit::{HALF, HALF_BITS};

                    debug_assert!(rem < divisor && divisor <= HALF);
                    let (hi, rem) = ((rem << HALF_BITS) | (digit >> HALF_BITS)).div_rem(&divisor);
                    let (lo, rem) = ((rem << HALF_BITS) | (digit & HALF)).div_rem(&divisor);
                    ((hi << HALF_BITS) | lo, rem)
                }

                #[inline]
                pub(super) fn div_rem_digit(mut a: BigUint, b: BigDigit) -> (BigUint, BigDigit) {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= big_digit::HALF {
                        for d in a.data.iter_mut().rev() {
                            let (q, r) = div_half(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    } else {
                        for d in a.data.iter_mut().rev() {
                            let (q, r) = div_wide(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    }

                    (a.normalized(), rem)
                }

                #[inline]
                fn rem_digit(a: &BigUint, b: BigDigit) -> BigDigit {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= big_digit::HALF {
                        for &digit in a.data.iter().rev() {
                            let (_, r) = div_half(rem, digit, b);
                            rem = r;
                        }
                    } else {
                        for &digit in a.data.iter().rev() {
                            let (_, r) = div_wide(rem, digit, b);
                            rem = r;
                        }
                    }

                    rem
                }

                /// Subtract a multiple.
                /// a -= b * c
                /// Returns a borrow (if a < b then borrow > 0).
                fn sub_mul_digit_same_len(a: &mut [BigDigit], b: &[BigDigit], c: BigDigit) -> BigDigit {
                    debug_assert!(a.len() == b.len());

                   
                   
                    let mut offset_carry = big_digit::MAX;

                    for (x, y) in a.iter_mut().zip(b) {
                       
                       
                       
                       
                        let offset_sum = big_digit::to_doublebigdigit(big_digit::MAX, *x)
                            - big_digit::MAX as DoubleBigDigit
                            + offset_carry as DoubleBigDigit
                            - *y as DoubleBigDigit * c as DoubleBigDigit;

                        let (new_offset_carry, new_x) = big_digit::from_doublebigdigit(offset_sum);
                        offset_carry = new_offset_carry;
                        *x = new_x;
                    }

                   
                    big_digit::MAX - offset_carry
                }

                fn div_rem(mut u: BigUint, mut d: BigUint) -> (BigUint, BigUint) {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u, BigUint::ZERO);
                        }
                        let (div, rem) = div_rem_digit(u, d.data[0]);
                       
                        d.data.clear();
                        d += rem;
                        return (div, d);
                    }

                   
                    match u.cmp(&d) {
                        Less => return (BigUint::ZERO, u),
                        Equal => {
                            u.set_one();
                            return (u, BigUint::ZERO);
                        }
                        Greater => {}
                    }

                   
                    //
                   
                   
                   
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                       
                        div_rem_core(u, &d.data)
                    } else {
                        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
                       
                        (q, r >> shift)
                    }
                }

                pub(super) fn div_rem_ref(u: &BigUint, d: &BigUint) -> (BigUint, BigUint) {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u.clone(), BigUint::ZERO);
                        }

                        let (div, rem) = div_rem_digit(u.clone(), d.data[0]);
                        return (div, rem.into());
                    }

                   
                    match u.cmp(d) {
                        Less => return (BigUint::ZERO, u.clone()),
                        Equal => return (One::one(), BigUint::ZERO),
                        Greater => {}
                    }

                   
                    //
                   
                   
                   
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                       
                        div_rem_core(u.clone(), &d.data)
                    } else {
                        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
                       
                        (q, r >> shift)
                    }
                }

                /// An implementation of the base division algorithm.
                /// Knuth, TAOCP vol 2 section 4.3.1, algorithm D, with an improvement from exercises 19-21.
                fn div_rem_core(mut a: BigUint, b: &[BigDigit]) -> (BigUint, BigUint) {
                    debug_assert!(a.data.len() >= b.len() && b.len() > 1);
                    debug_assert!(b.last().unwrap().leading_zeros() == 0);

                   
                   
                    //
                   
                   
                    //
                   
                    //
                   
                   
                   
                   
                    //
                   
                   
                   

                   
                    let mut a0 = 0;

                   
                    let b0 = b[b.len() - 1];
                    let b1 = b[b.len() - 2];

                    let q_len = a.data.len() - b.len() + 1;
                    let mut q = BigUint {
                        data: vec![0; q_len],
                    };

                    for j in (0..q_len).rev() {
                        debug_assert!(a.data.len() == b.len() + j);

                        let a1 = *a.data.last().unwrap();
                        let a2 = a.data[a.data.len() - 2];

                       
                       
                        let (mut q0, mut r) = if a0 < b0 {
                            let (q0, r) = div_wide(a0, a1, b0);
                            (q0, r as DoubleBigDigit)
                        } else {
                            debug_assert!(a0 == b0);
                           
                           
                            (big_digit::MAX, a0 as DoubleBigDigit + a1 as DoubleBigDigit)
                        };

                       
                        //
                       
                       
                        //
                       
                       
                       
                        while r <= big_digit::MAX as DoubleBigDigit
                            && big_digit::to_doublebigdigit(r as BigDigit, a2)
                                < q0 as DoubleBigDigit * b1 as DoubleBigDigit
                        {
                            q0 -= 1;
                            r += b0 as DoubleBigDigit;
                        }

                       
                       

                        let mut borrow = sub_mul_digit_same_len(&mut a.data[j..], b, q0);
                        if borrow > a0 {
                           
                            q0 -= 1;
                            borrow -= __add2(&mut a.data[j..], b);
                        }
                       
                        debug_assert!(borrow == a0);

                        q.data[j] = q0;

                       
                        a0 = a.data.pop().unwrap();
                    }

                    a.data.push(a0);
                    a.normalize();

                    debug_assert_eq!(cmp_slice(&a.data, b), Less);

                    (q.normalized(), a)
                }

                forward_val_ref_binop!(impl Div for BigUint, div);
                forward_ref_val_binop!(impl Div for BigUint, div);
                forward_val_assign!(impl DivAssign for BigUint, div_assign);

                impl Div<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: BigUint) -> BigUint {
                        let (q, _) = div_rem(self, other);
                        q
                    }
                }

                impl Div<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: &BigUint) -> BigUint {
                        let (q, _) = self.div_rem(other);
                        q
                    }
                }
                impl DivAssign<&BigUint> for BigUint {
                    #[inline]
                    fn div_assign(&mut self, other: &BigUint) {
                        *self = &*self / other;
                    }
                }

                promote_unsigned_scalars!(impl Div for BigUint, div);
                promote_unsigned_scalars_assign!(impl DivAssign for BigUint, div_assign);
                forward_all_scalar_binop_to_val_val!(impl Div<u32> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u64> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u128> for BigUint, div);

                impl Div<u32> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: u32) -> BigUint {
                        let (q, _) = div_rem_digit(self, other as BigDigit);
                        q
                    }
                }
                impl DivAssign<u32> for BigUint {
                    #[inline]
                    fn div_assign(&mut self, other: u32) {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u32 {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: BigUint) -> BigUint {
                        match other.data.len() {
                            0 => panic!("attempt to divide by zero"),
                            1 => From::from(self as BigDigit / other.data[0]),
                            _ => BigUint::ZERO,
                        }
                    }
                }

                impl Div<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: u64) -> BigUint {
                        let (q, _) = div_rem(self, From::from(other));
                        q
                    }
                }
                impl DivAssign<u64> for BigUint {
                    #[inline]
                    fn div_assign(&mut self, other: u64) {
                       
                        let temp = mem::replace(self, Self::ZERO);
                        *self = temp / other;
                    }
                }

                impl Div<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u64::from(other.data[0])),
                                2 => From::from(self / big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline]
                        fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0]),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                impl Div<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: u128) -> BigUint {
                        let (q, _) = div_rem(self, From::from(other));
                        q
                    }
                }

                impl DivAssign<u128> for BigUint {
                    #[inline]
                    fn div_assign(&mut self, other: u128) {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn div(self, other: BigUint) -> BigUint {
                            use super::u32_to_u128;
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u128::from(other.data[0])),
                                2 => From::from(
                                    self / u128::from(big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                ),
                                3 => From::from(self / u32_to_u128(0, other.data[2], other.data[1], other.data[0])),
                                4 => From::from(
                                    self / u32_to_u128(other.data[3], other.data[2], other.data[1], other.data[0]),
                                ),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline]
                        fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0] as u128),
                                2 => From::from(self / big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                forward_val_ref_binop!(impl Rem for BigUint, rem);
                forward_ref_val_binop!(impl Rem for BigUint, rem);
                forward_val_assign!(impl RemAssign for BigUint, rem_assign);

                impl Rem<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: BigUint) -> BigUint {
                        if let Some(other) = other.to_u32() {
                            &self % other
                        } else {
                            let (_, r) = div_rem(self, other);
                            r
                        }
                    }
                }

                impl Rem<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: &BigUint) -> BigUint {
                        if let Some(other) = other.to_u32() {
                            self % other
                        } else {
                            let (_, r) = self.div_rem(other);
                            r
                        }
                    }
                }
                impl RemAssign<&BigUint> for BigUint {
                    #[inline]
                    fn rem_assign(&mut self, other: &BigUint) {
                        *self = &*self % other;
                    }
                }

                promote_unsigned_scalars!(impl Rem for BigUint, rem);
                promote_unsigned_scalars_assign!(impl RemAssign for BigUint, rem_assign);
                forward_all_scalar_binop_to_ref_val!(impl Rem<u32> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u64> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u128> for BigUint, rem);

                impl Rem<u32> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: u32) -> BigUint {
                        rem_digit(self, other as BigDigit).into()
                    }
                }
                impl RemAssign<u32> for BigUint {
                    #[inline]
                    fn rem_assign(&mut self, other: u32) {
                        *self = &*self % other;
                    }
                }

                impl Rem<&BigUint> for u32 {
                    type Output = BigUint;

                    #[inline]
                    fn rem(mut self, other: &BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                macro_rules! impl_rem_assign_scalar {
                    ($scalar:ty, $to_scalar:ident) => {
                        forward_val_assign_scalar!(impl RemAssign for BigUint, $scalar, rem_assign);
                        impl RemAssign<&BigUint> for $scalar {
                            #[inline]
                            fn rem_assign(&mut self, other: &BigUint) {
                                *self = match other.$to_scalar() {
                                    None => *self,
                                    Some(0) => panic!("attempt to divide by zero"),
                                    Some(v) => *self % v
                                };
                            }
                        }
                    }
                }

               
                impl_rem_assign_scalar!(u128, to_u128);
                impl_rem_assign_scalar!(usize, to_usize);
                impl_rem_assign_scalar!(u64, to_u64);
                impl_rem_assign_scalar!(u32, to_u32);
                impl_rem_assign_scalar!(u16, to_u16);
                impl_rem_assign_scalar!(u8, to_u8);
                impl_rem_assign_scalar!(i128, to_i128);
                impl_rem_assign_scalar!(isize, to_isize);
                impl_rem_assign_scalar!(i64, to_i64);
                impl_rem_assign_scalar!(i32, to_i32);
                impl_rem_assign_scalar!(i16, to_i16);
                impl_rem_assign_scalar!(i8, to_i8);

                impl Rem<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: u64) -> BigUint {
                        let (_, r) = div_rem(self, From::from(other));
                        r
                    }
                }
                impl RemAssign<u64> for BigUint {
                    #[inline]
                    fn rem_assign(&mut self, other: u64) {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u64 {
                    type Output = BigUint;

                    #[inline]
                    fn rem(mut self, other: BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                impl Rem<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: u128) -> BigUint {
                        let (_, r) = div_rem(self, From::from(other));
                        r
                    }
                }

                impl RemAssign<u128> for BigUint {
                    #[inline]
                    fn rem_assign(&mut self, other: u128) {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u128 {
                    type Output = BigUint;

                    #[inline]
                    fn rem(mut self, other: BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                impl CheckedDiv for BigUint {
                    #[inline]
                    fn checked_div(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div(v))
                    }
                }

                impl CheckedEuclid for BigUint {
                    #[inline]
                    fn checked_div_euclid(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div_euclid(v))
                    }

                    #[inline]
                    fn checked_rem_euclid(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.rem_euclid(v))
                    }

                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some(self.div_rem_euclid(v))
                    }
                }

                impl Euclid for BigUint {
                    #[inline]
                    fn div_euclid(&self, v: &BigUint) -> BigUint {
                       
                        self / v
                    }

                    #[inline]
                    fn rem_euclid(&self, v: &BigUint) -> BigUint {
                       
                        self % v
                    }

                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                       
                        self.div_rem(v)
                    }
                }

            }

            pub mod multiplication
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use super::addition::{__add2, add2};
                use super::subtraction::sub2;
                use super::{biguint_from_vec, cmp_slice, BigUint, IntDigits};

                use crate::big_digit::{self, BigDigit, DoubleBigDigit};
                use crate::Sign::{self, Minus, NoSign, Plus};
                use crate::{BigInt, UsizePromotion};

                use core::cmp::Ordering;
                use core::iter::Product;
                use core::ops::{Mul, MulAssign};
                use num_traits::{CheckedMul, FromPrimitive, One, Zero};
                */
                #[inline]
                pub(super) fn mac_with_carry(
                    a: BigDigit,
                    b: BigDigit,
                    c: BigDigit,
                    acc: &mut DoubleBigDigit,
                ) -> BigDigit {
                    *acc += DoubleBigDigit::from(a);
                    *acc += DoubleBigDigit::from(b) * DoubleBigDigit::from(c);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }

                #[inline]
                fn mul_with_carry(a: BigDigit, b: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
                    *acc += DoubleBigDigit::from(a) * DoubleBigDigit::from(b);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }

                /// Three argument multiply accumulate:
                /// acc += b * c
                fn mac_digit(acc: &mut [BigDigit], b: &[BigDigit], c: BigDigit) {
                    if c == 0 {
                        return;
                    }

                    let mut carry = 0;
                    let (a_lo, a_hi) = acc.split_at_mut(b.len());

                    for (a, &b) in a_lo.iter_mut().zip(b) {
                        *a = mac_with_carry(*a, b, c, &mut carry);
                    }

                    let (carry_hi, carry_lo) = big_digit::from_doublebigdigit(carry);

                    let final_carry = if carry_hi == 0 {
                        __add2(a_hi, &[carry_lo])
                    } else {
                        __add2(a_hi, &[carry_hi, carry_lo])
                    };
                    assert_eq!(final_carry, 0, "carry overflow during multiplication!");
                }

                fn bigint_from_slice(slice: &[BigDigit]) -> BigInt {
                    BigInt::from(biguint_from_vec(slice.to_vec()))
                }

                /// Three argument multiply accumulate:
                /// acc += b * c
                #[allow(clippy::many_single_char_names)]
                fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) {
                   
                    if let Some(&0) = b.first() {
                        if let Some(nz) = b.iter().position(|&d| d != 0) {
                            b = &b[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }
                    if let Some(&0) = c.first() {
                        if let Some(nz) = c.iter().position(|&d| d != 0) {
                            c = &c[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }

                    let acc = acc;
                    let (x, y) = if b.len() < c.len() { (b, c) } else { (c, b) };

                   
                    //
                   
                   
                   
                   
                   
                   
                    //
                   
                   

                    if x.len() <= 32 {
                       
                        for (i, xi) in x.iter().enumerate() {
                            mac_digit(&mut acc[i..], y, *xi);
                        }
                    } else if x.len() * 2 <= y.len() {
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                       
                        //
                       
                        //
                       
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                       
                        let m2 = y.len() / 2;
                        let (low2, high2) = y.split_at(m2);

                       
                        mac3(acc, x, low2);
                        mac3(&mut acc[m2..], x, high2);
                    } else if x.len() <= 256 {
                       
                        //
                       
                       
                        //
                       
                       
                        //
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                       

                       
                       
                        let b = x.len() / 2;
                        let (x0, x1) = x.split_at(b);
                        let (y0, y1) = y.split_at(b);

                       
                       
                        let len = x1.len() + y1.len() + 1;
                        let mut p = BigUint { data: vec![0; len] };

                       
                        mac3(&mut p.data, x1, y1);

                       
                        p.normalize();

                        add2(&mut acc[b..], &p.data);
                        add2(&mut acc[b * 2..], &p.data);

                       
                        p.data.truncate(0);
                        p.data.resize(len, 0);

                       
                        mac3(&mut p.data, x0, y0);
                        p.normalize();

                        add2(acc, &p.data);
                        add2(&mut acc[b..], &p.data);

                       
                       
                        let (j0_sign, j0) = sub_sign(x1, x0);
                        let (j1_sign, j1) = sub_sign(y1, y0);

                        match j0_sign * j1_sign {
                            Plus => {
                                p.data.truncate(0);
                                p.data.resize(len, 0);

                                mac3(&mut p.data, &j0.data, &j1.data);
                                p.normalize();

                                sub2(&mut acc[b..], &p.data);
                            }
                            Minus => {
                                mac3(&mut acc[b..], &j0.data, &j1.data);
                            }
                            NoSign => (),
                        }
                    } else {
                       
                        //
                       
                       
                        //
                       
                       
                       
                        let i = y.len() / 3 + 1;

                        let x0_len = Ord::min(x.len(), i);
                        let x1_len = Ord::min(x.len() - x0_len, i);

                        let y0_len = i;
                        let y1_len = Ord::min(y.len() - y0_len, i);

                       
                       
                       
                        //
                       
                        let x0 = bigint_from_slice(&x[..x0_len]);
                        let x1 = bigint_from_slice(&x[x0_len..x0_len + x1_len]);
                        let x2 = bigint_from_slice(&x[x0_len + x1_len..]);

                       
                        let y0 = bigint_from_slice(&y[..y0_len]);
                        let y1 = bigint_from_slice(&y[y0_len..y0_len + y1_len]);
                        let y2 = bigint_from_slice(&y[y0_len + y1_len..]);

                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                       
                       

                       
                        let p = &x0 + &x2;

                       
                        let q = &y0 + &y2;

                       
                        let p2 = &p - &x1;

                       
                        let q2 = &q - &y1;

                       
                        let r0 = &x0 * &y0;

                       
                        let r4 = &x2 * &y2;

                       
                        let r1 = (p + x1) * (q + y1);

                       
                        let r2 = &p2 * &q2;

                       
                        let r3 = ((p2 + x2) * 2 - x0) * ((q2 + y2) * 2 - y0);

                       
                        //
                       
                       
                       
                       
                       
                        //
                       
                       
                        //
                       
                       
                       
                       
                       
                        //
                       
                       
                        let mut comp3: BigInt = (r3 - &r1) / 3u32;
                        let mut comp1: BigInt = (r1 - &r2) >> 1;
                        let mut comp2: BigInt = r2 - &r0;
                        comp3 = ((&comp2 - comp3) >> 1) + (&r4 << 1);
                        comp2 += &comp1 - &r4;
                        comp1 -= &comp3;

                       
                        //
                       
                        //
                       
                       
                       
                       
                       
                       
                       
                       
                        //
                       
                        for (j, result) in [&r0, &comp1, &comp2, &comp3, &r4].iter().enumerate().rev() {
                            match result.sign() {
                                Plus => add2(&mut acc[i * j..], result.digits()),
                                Minus => sub2(&mut acc[i * j..], result.digits()),
                                NoSign => {}
                            }
                        }
                    }
                }

                fn mul3(x: &[BigDigit], y: &[BigDigit]) -> BigUint {
                    let len = x.len() + y.len() + 1;
                    let mut prod = BigUint { data: vec![0; len] };

                    mac3(&mut prod.data, x, y);
                    prod.normalized()
                }

                fn scalar_mul(a: &mut BigUint, b: BigDigit) {
                    match b {
                        0 => a.set_zero(),
                        1 => {}
                        _ => {
                            if b.is_power_of_two() {
                                *a <<= b.trailing_zeros();
                            } else {
                                let mut carry = 0;
                                for a in a.data.iter_mut() {
                                    *a = mul_with_carry(*a, b, &mut carry);
                                }
                                if carry != 0 {
                                    a.data.push(carry as BigDigit);
                                }
                            }
                        }
                    }
                }

                fn sub_sign(mut a: &[BigDigit], mut b: &[BigDigit]) -> (Sign, BigUint) {
                   
                    if let Some(&0) = a.last() {
                        a = &a[..a.iter().rposition(|&x| x != 0).map_or(0, |i| i + 1)];
                    }
                    if let Some(&0) = b.last() {
                        b = &b[..b.iter().rposition(|&x| x != 0).map_or(0, |i| i + 1)];
                    }

                    match cmp_slice(a, b) {
                        Ordering::Greater => {
                            let mut a = a.to_vec();
                            sub2(&mut a, b);
                            (Plus, biguint_from_vec(a))
                        }
                        Ordering::Less => {
                            let mut b = b.to_vec();
                            sub2(&mut b, a);
                            (Minus, biguint_from_vec(b))
                        }
                        Ordering::Equal => (NoSign, BigUint::ZERO),
                    }
                }

                macro_rules! impl_mul {
                    ($(impl Mul<$Other:ty> for $Self:ty;)*) => {$(
                        impl Mul<$Other> for $Self {
                            type Output = BigUint;

                            #[inline]
                            fn mul(self, other: $Other) -> BigUint {
                                match (&*self.data, &*other.data) {
                                   
                                    (&[], _) | (_, &[]) => BigUint::ZERO,
                                   
                                    (_, &[digit]) => self * digit,
                                    (&[digit], _) => other * digit,
                                   
                                    (x, y) => mul3(x, y),
                                }
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigUint> for BigUint;
                    impl Mul<BigUint> for &BigUint;
                    impl Mul<&BigUint> for BigUint;
                    impl Mul<&BigUint> for &BigUint;
                }

                macro_rules! impl_mul_assign {
                    ($(impl MulAssign<$Other:ty> for BigUint;)*) => {$(
                        impl MulAssign<$Other> for BigUint {
                            #[inline]
                            fn mul_assign(&mut self, other: $Other) {
                                match (&*self.data, &*other.data) {
                                   
                                    (&[], _) => {},
                                    (_, &[]) => self.set_zero(),
                                   
                                    (_, &[digit]) => *self *= digit,
                                    (&[digit], _) => *self = other * digit,
                                   
                                    (x, y) => *self = mul3(x, y),
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigUint> for BigUint;
                    impl MulAssign<&BigUint> for BigUint;
                }

                promote_unsigned_scalars!(impl Mul for BigUint, mul);
                promote_unsigned_scalars_assign!(impl MulAssign for BigUint, mul_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u32> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u64> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u128> for BigUint, mul);

                impl Mul<u32> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn mul(mut self, other: u32) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u32> for BigUint {
                    #[inline]
                    fn mul_assign(&mut self, other: u32) {
                        scalar_mul(self, other as BigDigit);
                    }
                }

                impl Mul<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn mul(mut self, other: u64) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn mul_assign(&mut self, other: u64) {
                            if let Some(other) = BigDigit::from_u64(other) {
                                scalar_mul(self, other);
                            } else {
                                let (hi, lo) = big_digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }

                        #[inline]
                        fn mul_assign(&mut self, other: u64) {
                            scalar_mul(self, other);
                        }
                    );
                }

                impl Mul<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn mul(mut self, other: u128) -> BigUint {
                        self *= other;
                        self
                    }
                }

                impl MulAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn mul_assign(&mut self, other: u128) {
                            if let Some(other) = BigDigit::from_u128(other) {
                                scalar_mul(self, other);
                            } else {
                                *self = match super::u32_from_u128(other) {
                                    (0, 0, c, d) => mul3(&self.data, &[d, c]),
                                    (0, b, c, d) => mul3(&self.data, &[d, c, b]),
                                    (a, b, c, d) => mul3(&self.data, &[d, c, b, a]),
                                };
                            }
                        }

                        #[inline]
                        fn mul_assign(&mut self, other: u128) {
                            if let Some(other) = BigDigit::from_u128(other) {
                                scalar_mul(self, other);
                            } else {
                                let (hi, lo) = big_digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }
                    );
                }

                impl CheckedMul for BigUint {
                    #[inline]
                    fn checked_mul(&self, v: &BigUint) -> Option<BigUint> {
                        Some(self.mul(v))
                    }
                }

                impl_product_iter_type!(BigUint);
            }

            pub mod subtraction
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use super::BigUint;

                use crate::big_digit::{self, BigDigit};
                use crate::UsizePromotion;

                use core::cmp::Ordering::{Equal, Greater, Less};
                use core::ops::{Sub, SubAssign};
                use num_traits::CheckedSub;

                #[cfg(target_arch = "x86_64")]
                use core::arch::x86_64 as arch;

                #[cfg(target_arch = "x86")]
                use core::arch::x86 as arch;
                */
               
                #[cfg(target_arch = "x86_64")]
                cfg_64!(
                    #[inline]
                    fn sbb(borrow: u8, a: u64, b: u64, out: &mut u64) -> u8 {
                       
                       
                        unsafe { arch::_subborrow_u64(borrow, a, b, out) }
                    }
                );

                #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
                cfg_32!(
                    #[inline]
                    fn sbb(borrow: u8, a: u32, b: u32, out: &mut u32) -> u8 {
                       
                       
                        unsafe { arch::_subborrow_u32(borrow, a, b, out) }
                    }
                );

               
               
                #[cfg(not(any(target_arch = "x86", target_arch = "x86_64")))]
                #[inline]
                fn sbb(borrow: u8, lhs: BigDigit, rhs: BigDigit, out: &mut BigDigit) -> u8 {
                    let (a, b) = lhs.overflowing_sub(rhs);
                    let (c, d) = a.overflowing_sub(borrow as BigDigit);
                    *out = c;
                    u8::from(b || d)
                }

                pub(super) fn sub2(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut borrow = 0;

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi) = a.split_at_mut(len);
                    let (b_lo, b_hi) = b.split_at(len);

                    for (a, b) in a_lo.iter_mut().zip(b_lo) {
                        borrow = sbb(borrow, *a, *b, a);
                    }

                    if borrow != 0 {
                        for a in a_hi {
                            borrow = sbb(borrow, *a, 0, a);
                            if borrow == 0 {
                                break;
                            }
                        }
                    }

                   
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }

               
                #[inline]
                fn __sub2rev(a: &[BigDigit], b: &mut [BigDigit]) -> u8 {
                    debug_assert!(b.len() == a.len());

                    let mut borrow = 0;

                    for (ai, bi) in a.iter().zip(b) {
                        borrow = sbb(borrow, *ai, *bi, bi);
                    }

                    borrow
                }

                fn sub2rev(a: &[BigDigit], b: &mut [BigDigit]) {
                    debug_assert!(b.len() >= a.len());

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi) = a.split_at(len);
                    let (b_lo, b_hi) = b.split_at_mut(len);

                    let borrow = __sub2rev(a_lo, b_lo);

                    assert!(a_hi.is_empty());

                   
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }

                forward_val_val_binop!(impl Sub for BigUint, sub);
                forward_ref_ref_binop!(impl Sub for BigUint, sub);
                forward_val_assign!(impl SubAssign for BigUint, sub_assign);

                impl Sub<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn sub(mut self, other: &BigUint) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<&BigUint> for BigUint {
                    fn sub_assign(&mut self, other: &BigUint) {
                        sub2(&mut self.data[..], &other.data[..]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for &BigUint {
                    type Output = BigUint;

                    fn sub(self, mut other: BigUint) -> BigUint {
                        let other_len = other.data.len();
                        if other_len < self.data.len() {
                            let lo_borrow = __sub2rev(&self.data[..other_len], &mut other.data);
                            other.data.extend_from_slice(&self.data[other_len..]);
                            if lo_borrow != 0 {
                                sub2(&mut other.data[other_len..], &[1])
                            }
                        } else {
                            sub2rev(&self.data[..], &mut other.data[..]);
                        }
                        other.normalized()
                    }
                }

                promote_unsigned_scalars!(impl Sub for BigUint, sub);
                promote_unsigned_scalars_assign!(impl SubAssign for BigUint, sub_assign);
                forward_all_scalar_binop_to_val_val!(impl Sub<u32> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u64> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u128> for BigUint, sub);

                impl Sub<u32> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn sub(mut self, other: u32) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u32> for BigUint {
                    fn sub_assign(&mut self, other: u32) {
                        sub2(&mut self.data[..], &[other as BigDigit]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for u32 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.len() == 0 {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }

                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push(self as BigDigit);
                            } else {
                                sub2rev(&[self as BigDigit], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn sub(mut self, other: u64) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn sub_assign(&mut self, other: u64) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }

                        #[inline]
                        fn sub_assign(&mut self, other: u64) {
                            sub2(&mut self.data[..], &[other as BigDigit]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push(0);
                            }

                            let (hi, lo) = big_digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn sub(mut self, other: u128) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn sub_assign(&mut self, other: u128) {
                            let (a, b, c, d) = super::u32_from_u128(other);
                            sub2(&mut self.data[..], &[d, c, b, a]);
                            self.normalize();
                        }

                        #[inline]
                        fn sub_assign(&mut self, other: u128) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 4 {
                                other.data.push(0);
                            }

                            let (a, b, c, d) = super::u32_from_u128(self);
                            sub2rev(&[d, c, b, a], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push(0);
                            }

                            let (hi, lo) = big_digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }
                    );
                }

                impl CheckedSub for BigUint {
                    #[inline]
                    fn checked_sub(&self, v: &BigUint) -> Option<BigUint> {
                        match self.cmp(v) {
                            Less => None,
                            Equal => Some(Self::ZERO),
                            Greater => Some(self.sub(v)),
                        }
                    }
                }

            }

            pub mod bits
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use super::{BigUint, IntDigits};
                use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign};
                */
                forward_val_val_binop!(impl BitAnd for BigUint, bitand);
                forward_ref_val_binop!(impl BitAnd for BigUint, bitand);

               
               
                impl BitAnd<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn bitand(self, other: &BigUint) -> BigUint {
                       
                        if self.data.len() <= other.data.len() {
                            self.clone() & other
                        } else {
                            other.clone() & self
                        }
                    }
                }

                forward_val_assign!(impl BitAndAssign for BigUint, bitand_assign);

                impl BitAnd<&BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn bitand(mut self, other: &BigUint) -> BigUint {
                        self &= other;
                        self
                    }
                }
                impl BitAndAssign<&BigUint> for BigUint {
                    #[inline]
                    fn bitand_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai &= bi;
                        }
                        self.data.truncate(other.data.len());
                        self.normalize();
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitOr for BigUint, bitor);
                forward_val_assign!(impl BitOrAssign for BigUint, bitor_assign);

                impl BitOr<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn bitor(mut self, other: &BigUint) -> BigUint {
                        self |= other;
                        self
                    }
                }
                impl BitOrAssign<&BigUint> for BigUint {
                    #[inline]
                    fn bitor_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai |= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitXor for BigUint, bitxor);
                forward_val_assign!(impl BitXorAssign for BigUint, bitxor_assign);

                impl BitXor<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn bitxor(mut self, other: &BigUint) -> BigUint {
                        self ^= other;
                        self
                    }
                }
                impl BitXorAssign<&BigUint> for BigUint {
                    #[inline]
                    fn bitxor_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai ^= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                        self.normalize();
                    }
                }

            }

            pub mod convert
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use super::{biguint_from_vec, BigUint, ToBigUint};

                use super::addition::add2;
                use super::division::{div_rem_digit, FAST_DIV_WIDE};
                use super::multiplication::mac_with_carry;

                use crate::big_digit::{self, BigDigit};
                use crate::ParseBigIntError;
                use crate::TryFromBigIntError;

                use alloc::vec::Vec;
                use core::cmp::Ordering::{Equal, Greater, Less};
                use core::convert::TryFrom;
                use core::mem;
                use core::str::FromStr;
                use num_integer::{Integer, Roots};
                use num_traits::float::FloatCore;
                use num_traits::{FromPrimitive, Num, One, PrimInt, ToPrimitive, Zero};
                */
                /// Find last set bit
                /// fls(0) == 0, fls(u32::MAX) == 32
                fn fls<T: PrimInt>(v: T) -> u8 {
                    mem::size_of::<T>() as u8 * 8 - v.leading_zeros() as u8
                }

                fn ilog2<T: PrimInt>(v: T) -> u8 {
                    fls(v) - 1
                }

                impl FromStr for BigUint {
                    type Err = ParseBigIntError;

                    #[inline]
                    fn from_str(s: &str) -> Result<BigUint, ParseBigIntError> {
                        BigUint::from_str_radix(s, 10)
                    }
                }

               
               
                pub(super) fn from_bitwise_digits_le(v: &[u8], bits: u8) -> BigUint {
                    debug_assert!(!v.is_empty() && bits <= 8 && big_digit::BITS % bits == 0);
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c) < (1 << bits)));

                    let digits_per_big_digit = big_digit::BITS / bits;

                    let data = v
                        .chunks(digits_per_big_digit.into())
                        .map(|chunk| {
                            chunk
                                .iter()
                                .rev()
                                .fold(0, |acc, &c| (acc << bits) | BigDigit::from(c))
                        })
                        .collect();

                    biguint_from_vec(data)
                }

               
               
                fn from_inexact_bitwise_digits_le(v: &[u8], bits: u8) -> BigUint {
                    debug_assert!(!v.is_empty() && bits <= 8 && big_digit::BITS % bits != 0);
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c) < (1 << bits)));

                    let total_bits = (v.len() as u64).saturating_mul(bits.into());
                    let big_digits = Integer::div_ceil(&total_bits, &big_digit::BITS.into())
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut data = Vec::with_capacity(big_digits);

                    let mut d = 0;
                    let mut dbits = 0;

                   
                   
                    for &c in v {
                        d |= BigDigit::from(c) << dbits;
                        dbits += bits;

                        if dbits >= big_digit::BITS {
                            data.push(d);
                            dbits -= big_digit::BITS;
                           
                           
                            d = BigDigit::from(c) >> (bits - dbits);
                        }
                    }

                    if dbits > 0 {
                        debug_assert!(dbits < big_digit::BITS);
                        data.push(d as BigDigit);
                    }

                    biguint_from_vec(data)
                }

               
                fn from_radix_digits_be(v: &[u8], radix: u32) -> BigUint {
                    debug_assert!(!v.is_empty() && !radix.is_power_of_two());
                    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));

                   
                    #[cfg(feature = "std")]
                    let big_digits = {
                        let radix_log2 = f64::from(radix).log2();
                        let bits = radix_log2 * v.len() as f64;
                        (bits / big_digit::BITS as f64).ceil()
                    };
                    #[cfg(not(feature = "std"))]
                    let big_digits = {
                        let radix_log2 = ilog2(radix.next_power_of_two()) as usize;
                        let bits = radix_log2 * v.len();
                        (bits / big_digit::BITS as usize) + 1
                    };

                    let mut data = Vec::with_capacity(big_digits.to_usize().unwrap_or(0));

                    let (base, power) = get_radix_base(radix);
                    let radix = radix as BigDigit;

                    let r = v.len() % power;
                    let i = if r == 0 { power } else { r };
                    let (head, tail) = v.split_at(i);

                    let first = head
                        .iter()
                        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                    data.push(first);

                    debug_assert!(tail.len() % power == 0);
                    for chunk in tail.chunks(power) {
                        if data.last() != Some(&0) {
                            data.push(0);
                        }

                        let mut carry = 0;
                        for d in data.iter_mut() {
                            *d = mac_with_carry(0, *d, base, &mut carry);
                        }
                        debug_assert!(carry == 0);

                        let n = chunk
                            .iter()
                            .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                        add2(&mut data, &[n]);
                    }

                    biguint_from_vec(data)
                }

                pub(super) fn from_radix_be(buf: &[u8], radix: u32) -> Option<BigUint> {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                       
                        let bits = ilog2(radix);
                        let mut v = Vec::from(buf);
                        v.reverse();
                        if big_digit::BITS % bits == 0 {
                            from_bitwise_digits_le(&v, bits)
                        } else {
                            from_inexact_bitwise_digits_le(&v, bits)
                        }
                    } else {
                        from_radix_digits_be(buf, radix)
                    };

                    Some(res)
                }

                pub(super) fn from_radix_le(buf: &[u8], radix: u32) -> Option<BigUint> {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                       
                        let bits = ilog2(radix);
                        if big_digit::BITS % bits == 0 {
                            from_bitwise_digits_le(buf, bits)
                        } else {
                            from_inexact_bitwise_digits_le(buf, bits)
                        }
                    } else {
                        let mut v = Vec::from(buf);
                        v.reverse();
                        from_radix_digits_be(&v, radix)
                    };

                    Some(res)
                }

                impl Num for BigUint {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a `BigUint`.
                    fn from_str_radix(s: &str, radix: u32) -> Result<BigUint, ParseBigIntError> {
                        assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
                        let mut s = s;
                        if let Some(tail) = s.strip_prefix('+') {
                            if !tail.starts_with('+') {
                                s = tail
                            }
                        }

                        if s.is_empty() {
                            return Err(ParseBigIntError::empty());
                        }

                        if s.starts_with('_') {
                           
                            return Err(ParseBigIntError::invalid());
                        }

                       
                        let mut v = Vec::with_capacity(s.len());
                        for b in s.bytes() {
                            let d = match b {
                                b'0'..=b'9' => b - b'0',
                                b'a'..=b'z' => b - b'a' + 10,
                                b'A'..=b'Z' => b - b'A' + 10,
                                b'_' => continue,
                                _ => u8::MAX,
                            };
                            if d < radix as u8 {
                                v.push(d);
                            } else {
                                return Err(ParseBigIntError::invalid());
                            }
                        }

                        let res = if radix.is_power_of_two() {
                           
                            let bits = ilog2(radix);
                            v.reverse();
                            if big_digit::BITS % bits == 0 {
                                from_bitwise_digits_le(&v, bits)
                            } else {
                                from_inexact_bitwise_digits_le(&v, bits)
                            }
                        } else {
                            from_radix_digits_be(&v, radix)
                        };
                        Ok(res)
                    }
                }

                fn high_bits_to_u64(v: &BigUint) -> u64 {
                    match v.data.len() {
                        0 => 0,
                        1 => {
                           
                            #[allow(clippy::useless_conversion)]
                            let v0 = u64::from(v.data[0]);
                            v0
                        }
                        _ => {
                            let mut bits = v.bits();
                            let mut ret = 0u64;
                            let mut ret_bits = 0;

                            for d in v.data.iter().rev() {
                                let digit_bits = (bits - 1) % u64::from(big_digit::BITS) + 1;
                                let bits_want = Ord::min(64 - ret_bits, digit_bits);

                                if bits_want != 0 {
                                    if bits_want != 64 {
                                        ret <<= bits_want;
                                    }
                                   
                                    #[allow(clippy::useless_conversion)]
                                    let d0 = u64::from(*d) >> (digit_bits - bits_want);
                                    ret |= d0;
                                }

                               
                               
                               
                                //
                               

                                if digit_bits - bits_want != 0 {
                                   
                                    #[allow(clippy::useless_conversion)]
                                    let masked = u64::from(*d) << (64 - (digit_bits - bits_want) as u32);
                                    ret |= (masked != 0) as u64;
                                }

                                ret_bits += bits_want;
                                bits -= bits_want;
                            }

                            ret
                        }
                    }
                }

                impl ToPrimitive for BigUint {
                    #[inline]
                    fn to_i64(&self) -> Option<i64> {
                        self.to_u64().as_ref().and_then(u64::to_i64)
                    }

                    #[inline]
                    fn to_i128(&self) -> Option<i128> {
                        self.to_u128().as_ref().and_then(u128::to_i128)
                    }

                    #[allow(clippy::useless_conversion)]
                    #[inline]
                    fn to_u64(&self) -> Option<u64> {
                        let mut ret: u64 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 64 {
                                return None;
                            }

                           
                            ret += u64::from(*i) << bits;
                            bits += big_digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline]
                    fn to_u128(&self) -> Option<u128> {
                        let mut ret: u128 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 128 {
                                return None;
                            }

                            ret |= u128::from(*i) << bits;
                            bits += big_digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline]
                    fn to_f32(&self) -> Option<f32> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f32::MAX_EXP as u64 {
                            Some(f32::INFINITY)
                        } else {
                            Some((mantissa as f32) * 2.0f32.powi(exponent as i32))
                        }
                    }

                    #[inline]
                    fn to_f64(&self) -> Option<f64> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f64::MAX_EXP as u64 {
                            Some(f64::INFINITY)
                        } else {
                            Some((mantissa as f64) * 2.0f64.powi(exponent as i32))
                        }
                    }
                }

                macro_rules! impl_try_from_biguint {
                    ($T:ty, $to_ty:path) => {
                        impl TryFrom<&BigUint> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: &BigUint) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }

                        impl TryFrom<BigUint> for $T {
                            type Error = TryFromBigIntError<BigUint>;

                            #[inline]
                            fn try_from(value: BigUint) -> Result<$T, TryFromBigIntError<BigUint>> {
                                <$T>::try_from(&value).map_err(|_| TryFromBigIntError::new(value))
                            }
                        }
                    };
                }

                impl_try_from_biguint!(u8, ToPrimitive::to_u8);
                impl_try_from_biguint!(u16, ToPrimitive::to_u16);
                impl_try_from_biguint!(u32, ToPrimitive::to_u32);
                impl_try_from_biguint!(u64, ToPrimitive::to_u64);
                impl_try_from_biguint!(usize, ToPrimitive::to_usize);
                impl_try_from_biguint!(u128, ToPrimitive::to_u128);

                impl_try_from_biguint!(i8, ToPrimitive::to_i8);
                impl_try_from_biguint!(i16, ToPrimitive::to_i16);
                impl_try_from_biguint!(i32, ToPrimitive::to_i32);
                impl_try_from_biguint!(i64, ToPrimitive::to_i64);
                impl_try_from_biguint!(isize, ToPrimitive::to_isize);
                impl_try_from_biguint!(i128, ToPrimitive::to_i128);

                impl FromPrimitive for BigUint {
                    #[inline]
                    fn from_i64(n: i64) -> Option<BigUint> {
                        if n >= 0 {
                            Some(BigUint::from(n as u64))
                        } else {
                            None
                        }
                    }

                    #[inline]
                    fn from_i128(n: i128) -> Option<BigUint> {
                        if n >= 0 {
                            Some(BigUint::from(n as u128))
                        } else {
                            None
                        }
                    }

                    #[inline]
                    fn from_u64(n: u64) -> Option<BigUint> {
                        Some(BigUint::from(n))
                    }

                    #[inline]
                    fn from_u128(n: u128) -> Option<BigUint> {
                        Some(BigUint::from(n))
                    }

                    #[inline]
                    fn from_f64(mut n: f64) -> Option<BigUint> {
                       
                        if !n.is_finite() {
                            return None;
                        }

                       
                        n = n.trunc();

                       
                        if n.is_zero() {
                            return Some(Self::ZERO);
                        }

                        let (mantissa, exponent, sign) = FloatCore::integer_decode(n);

                        if sign == -1 {
                            return None;
                        }

                        let mut ret = BigUint::from(mantissa);
                        match exponent.cmp(&0) {
                            Greater => ret <<= exponent as usize,
                            Equal => {}
                            Less => ret >>= (-exponent) as usize,
                        }
                        Some(ret)
                    }
                }

                impl From<u64> for BigUint {
                    #[inline]
                    fn from(mut n: u64) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                           
                            n = (n >> 1) >> (big_digit::BITS - 1);
                        }

                        ret
                    }
                }

                impl From<u128> for BigUint {
                    #[inline]
                    fn from(mut n: u128) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                            n >>= big_digit::BITS;
                        }

                        ret
                    }
                }

                macro_rules! impl_biguint_from_uint {
                    ($T:ty) => {
                        impl From<$T> for BigUint {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigUint::from(n as u64)
                            }
                        }
                    };
                }

                impl_biguint_from_uint!(u8);
                impl_biguint_from_uint!(u16);
                impl_biguint_from_uint!(u32);
                impl_biguint_from_uint!(usize);

                macro_rules! impl_biguint_try_from_int {
                    ($T:ty, $from_ty:path) => {
                        impl TryFrom<$T> for BigUint {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: $T) -> Result<BigUint, TryFromBigIntError<()>> {
                                $from_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }
                    };
                }

                impl_biguint_try_from_int!(i8, FromPrimitive::from_i8);
                impl_biguint_try_from_int!(i16, FromPrimitive::from_i16);
                impl_biguint_try_from_int!(i32, FromPrimitive::from_i32);
                impl_biguint_try_from_int!(i64, FromPrimitive::from_i64);
                impl_biguint_try_from_int!(isize, FromPrimitive::from_isize);
                impl_biguint_try_from_int!(i128, FromPrimitive::from_i128);

                impl ToBigUint for BigUint {
                    #[inline]
                    fn to_biguint(&self) -> Option<BigUint> {
                        Some(self.clone())
                    }
                }

                macro_rules! impl_to_biguint {
                    ($T:ty, $from_ty:path) => {
                        impl ToBigUint for $T {
                            #[inline]
                            fn to_biguint(&self) -> Option<BigUint> {
                                $from_ty(*self)
                            }
                        }
                    };
                }

                impl_to_biguint!(isize, FromPrimitive::from_isize);
                impl_to_biguint!(i8, FromPrimitive::from_i8);
                impl_to_biguint!(i16, FromPrimitive::from_i16);
                impl_to_biguint!(i32, FromPrimitive::from_i32);
                impl_to_biguint!(i64, FromPrimitive::from_i64);
                impl_to_biguint!(i128, FromPrimitive::from_i128);

                impl_to_biguint!(usize, FromPrimitive::from_usize);
                impl_to_biguint!(u8, FromPrimitive::from_u8);
                impl_to_biguint!(u16, FromPrimitive::from_u16);
                impl_to_biguint!(u32, FromPrimitive::from_u32);
                impl_to_biguint!(u64, FromPrimitive::from_u64);
                impl_to_biguint!(u128, FromPrimitive::from_u128);

                impl_to_biguint!(f32, FromPrimitive::from_f32);
                impl_to_biguint!(f64, FromPrimitive::from_f64);

                impl From<bool> for BigUint {
                    fn from(x: bool) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }

               
                pub(super) fn to_bitwise_digits_le(u: &BigUint, bits: u8) -> Vec<u8> {
                    debug_assert!(!u.is_zero() && bits <= 8 && big_digit::BITS % bits == 0);

                    let last_i = u.data.len() - 1;
                    let mask: BigDigit = (1 << bits) - 1;
                    let digits_per_big_digit = big_digit::BITS / bits;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    for mut r in u.data[..last_i].iter().cloned() {
                        for _ in 0..digits_per_big_digit {
                            res.push((r & mask) as u8);
                            r >>= bits;
                        }
                    }

                    let mut r = u.data[last_i];
                    while r != 0 {
                        res.push((r & mask) as u8);
                        r >>= bits;
                    }

                    res
                }

               
                fn to_inexact_bitwise_digits_le(u: &BigUint, bits: u8) -> Vec<u8> {
                    debug_assert!(!u.is_zero() && bits <= 8 && big_digit::BITS % bits != 0);

                    let mask: BigDigit = (1 << bits) - 1;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    let mut r = 0;
                    let mut rbits = 0;

                    for c in &u.data {
                        r |= *c << rbits;
                        rbits += big_digit::BITS;

                        while rbits >= bits {
                            res.push((r & mask) as u8);
                            r >>= bits;

                           
                            if rbits > big_digit::BITS {
                                r = *c >> (big_digit::BITS - (rbits - bits));
                            }

                            rbits -= bits;
                        }
                    }

                    if rbits != 0 {
                        res.push(r as u8);
                    }

                    while let Some(&0) = res.last() {
                        res.pop();
                    }

                    res
                }

               
                #[inline(always)]
                pub(super) fn to_radix_digits_le(u: &BigUint, radix: u32) -> Vec<u8> {
                    debug_assert!(!u.is_zero() && !radix.is_power_of_two());

                    #[cfg(feature = "std")]
                    let radix_digits = {
                        let radix_log2 = f64::from(radix).log2();
                        ((u.bits() as f64) / radix_log2).ceil()
                    };
                    #[cfg(not(feature = "std"))]
                    let radix_digits = {
                        let radix_log2 = ilog2(radix) as usize;
                        ((u.bits() as usize) / radix_log2) + 1
                    };

                   
                    let mut res = Vec::with_capacity(radix_digits.to_usize().unwrap_or(0));

                    let mut digits = u.clone();

                   
                   
                    let (base, power) = if FAST_DIV_WIDE {
                        get_radix_base(radix)
                    } else {
                        get_half_radix_base(radix)
                    };
                    let radix = radix as BigDigit;

                   
                   
                   
                   
                    if digits.data.len() >= 64 {
                        let mut big_base = BigUint::from(base);
                        let mut big_power = 1usize;

                       
                        let target_len = digits.data.len().sqrt();
                        while big_base.data.len() < target_len {
                            big_base = &big_base * &big_base;
                            big_power *= 2;
                        }

                       
                        while digits > big_base {
                           
                            let (q, mut big_r) = digits.div_rem(&big_base);
                            digits = q;

                           
                            for _ in 0..big_power {
                                let (q, mut r) = div_rem_digit(big_r, base);
                                big_r = q;
                                for _ in 0..power {
                                    res.push((r % radix) as u8);
                                    r /= radix;
                                }
                            }
                        }
                    }

                    while digits.data.len() > 1 {
                        let (q, mut r) = div_rem_digit(digits, base);
                        for _ in 0..power {
                            res.push((r % radix) as u8);
                            r /= radix;
                        }
                        digits = q;
                    }

                    let mut r = digits.data[0];
                    while r != 0 {
                        res.push((r % radix) as u8);
                        r /= radix;
                    }

                    res
                }

                pub(super) fn to_radix_le(u: &BigUint, radix: u32) -> Vec<u8> {
                    if u.is_zero() {
                        vec![0]
                    } else if radix.is_power_of_two() {
                       
                        let bits = ilog2(radix);
                        if big_digit::BITS % bits == 0 {
                            to_bitwise_digits_le(u, bits)
                        } else {
                            to_inexact_bitwise_digits_le(u, bits)
                        }
                    } else if radix == 10 {
                       
                       
                        to_radix_digits_le(u, 10)
                    } else {
                        to_radix_digits_le(u, radix)
                    }
                }

                pub(crate) fn to_str_radix_reversed(u: &BigUint, radix: u32) -> Vec<u8> {
                    assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");

                    if u.is_zero() {
                        return vec![b'0'];
                    }

                    let mut res = to_radix_le(u, radix);

                   
                    for r in &mut res {
                        debug_assert!(u32::from(*r) < radix);
                        if *r < 10 {
                            *r += b'0';
                        } else {
                            *r += b'a' - 10;
                        }
                    }
                    res
                }

                /// Returns the greatest power of the radix for the `BigDigit` bit size
                #[inline]
                fn get_radix_base(radix: u32) -> (BigDigit, usize) {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(big_digit::MAX);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }

                /// Returns the greatest power of the radix for half the `BigDigit` bit size
                #[inline]
                fn get_half_radix_base(radix: u32) -> (BigDigit, usize) {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(big_digit::HALF);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }

                /// Generate tables of the greatest power of each radix that is less that the given maximum. These
                /// are returned from `get_radix_base` to batch the multiplication/division of radix conversions on
                /// full `BigUint` values, operating on primitive integers as much as possible.
                ///
                /// e.g. BASES_16[3] = (59049, 10)
                ///      BASES_32[3] = (3486784401, 20)
                ///      BASES_64[3] = (12157665459056928801, 40)
                ///
                /// Powers of two are not included, just zeroed, as they're implemented with shifts.
                const fn generate_radix_bases(max: BigDigit) -> [(BigDigit, usize); 257] {
                    let mut bases = [(0, 0); 257];

                    let mut radix: BigDigit = 3;
                    while radix < 256 {
                        if !radix.is_power_of_two() {
                            let mut power = 1;
                            let mut base = radix;

                            while let Some(b) = base.checked_mul(radix) {
                                if b > max {
                                    break;
                                }
                                base = b;
                                power += 1;
                            }
                            bases[radix as usize] = (base, power)
                        }
                        radix += 1;
                    }

                    bases
                }

            }

            pub mod iter
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use core::iter::FusedIterator;
                */
                cfg_digit!(
                    /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U32Digits<'a> {
                        it: core::slice::Iter<'a, u32>,
                    }

                    /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U32Digits<'a> {
                        data: &'a [u64],
                        next_is_lo: bool,
                        last_hi_is_zero: bool,
                    }
                );

                cfg_digit!(
                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub(super) fn new(data: &'a [u32]) -> Self {
                                Self { it: data.iter() }
                            }
                        }

                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next(&mut self) -> Option<u32> {
                                self.it.next().cloned()
                            }

                            #[inline]
                            fn size_hint(&self) -> (usize, Option<usize>) {
                                self.it.size_hint()
                            }

                            #[inline]
                            fn nth(&mut self, n: usize) -> Option<u32> {
                                self.it.nth(n).cloned()
                            }

                            #[inline]
                            fn last(self) -> Option<u32> {
                                self.it.last().cloned()
                            }

                            #[inline]
                            fn count(self) -> usize {
                                self.it.count()
                            }
                        }

                        impl DoubleEndedIterator for U32Digits<'_> {
                            fn next_back(&mut self) -> Option<Self::Item> {
                                self.it.next_back().cloned()
                            }
                        }

                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len(&self) -> usize {
                                self.it.len()
                            }
                        }
                    };

                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub(super) fn new(data: &'a [u64]) -> Self {
                                let last_hi_is_zero = data
                                    .last()
                                    .map(|&last| {
                                        let last_hi = (last >> 32) as u32;
                                        last_hi == 0
                                    })
                                    .unwrap_or(false);
                                U32Digits {
                                    data,
                                    next_is_lo: true,
                                    last_hi_is_zero,
                                }
                            }
                        }

                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next(&mut self) -> Option<u32> {
                                match self.data.split_first() {
                                    Some((&first, data)) => {
                                        let next_is_lo = self.next_is_lo;
                                        self.next_is_lo = !next_is_lo;
                                        if next_is_lo {
                                            Some(first as u32)
                                        } else {
                                            self.data = data;
                                            if data.is_empty() && self.last_hi_is_zero {
                                                self.last_hi_is_zero = false;
                                                None
                                            } else {
                                                Some((first >> 32) as u32)
                                            }
                                        }
                                    }
                                    None => None,
                                }
                            }

                            #[inline]
                            fn size_hint(&self) -> (usize, Option<usize>) {
                                let len = self.len();
                                (len, Some(len))
                            }

                            #[inline]
                            fn last(self) -> Option<u32> {
                                self.data.last().map(|&last| {
                                    if self.last_hi_is_zero {
                                        last as u32
                                    } else {
                                        (last >> 32) as u32
                                    }
                                })
                            }

                            #[inline]
                            fn count(self) -> usize {
                                self.len()
                            }
                        }

                        impl DoubleEndedIterator for U32Digits<'_> {
                            fn next_back(&mut self) -> Option<Self::Item> {
                                match self.data.split_last() {
                                    Some((&last, data)) => {
                                        let last_is_lo = self.last_hi_is_zero;
                                        self.last_hi_is_zero = !last_is_lo;
                                        if last_is_lo {
                                            self.data = data;
                                            if data.is_empty() && !self.next_is_lo {
                                                self.next_is_lo = true;
                                                None
                                            } else {
                                                Some(last as u32)
                                            }
                                        } else {
                                            Some((last >> 32) as u32)
                                        }
                                    }
                                    None => None,
                                }
                            }
                        }

                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len(&self) -> usize {
                                self.data.len() * 2
                                    - usize::from(self.last_hi_is_zero)
                                    - usize::from(!self.next_is_lo)
                            }
                        }
                    };
                );

                impl FusedIterator for U32Digits<'_> {}

                cfg_digit!(
                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: core::slice::Chunks<'a, u32>,
                    }

                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: core::slice::Iter<'a, u64>,
                    }
                );

                cfg_digit!(
                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub(super) fn new(data: &'a [u32]) -> Self {
                                U64Digits { it: data.chunks(2) }
                            }
                        }

                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next(&mut self) -> Option<u64> {
                                self.it.next().map(super::u32_chunk_to_u64)
                            }

                            #[inline]
                            fn size_hint(&self) -> (usize, Option<usize>) {
                                let len = self.len();
                                (len, Some(len))
                            }

                            #[inline]
                            fn last(self) -> Option<u64> {
                                self.it.last().map(super::u32_chunk_to_u64)
                            }

                            #[inline]
                            fn count(self) -> usize {
                                self.len()
                            }
                        }

                        impl DoubleEndedIterator for U64Digits<'_> {
                            fn next_back(&mut self) -> Option<Self::Item> {
                                self.it.next_back().map(super::u32_chunk_to_u64)
                            }
                        }
                    };

                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub(super) fn new(data: &'a [u64]) -> Self {
                                Self { it: data.iter() }
                            }
                        }

                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next(&mut self) -> Option<u64> {
                                self.it.next().cloned()
                            }

                            #[inline]
                            fn size_hint(&self) -> (usize, Option<usize>) {
                                self.it.size_hint()
                            }

                            #[inline]
                            fn nth(&mut self, n: usize) -> Option<u64> {
                                self.it.nth(n).cloned()
                            }

                            #[inline]
                            fn last(self) -> Option<u64> {
                                self.it.last().cloned()
                            }

                            #[inline]
                            fn count(self) -> usize {
                                self.it.count()
                            }
                        }

                        impl DoubleEndedIterator for U64Digits<'_> {
                            fn next_back(&mut self) -> Option<Self::Item> {
                                self.it.next_back().cloned()
                            }
                        }
                    };
                );

                impl ExactSizeIterator for U64Digits<'_> {
                    #[inline]
                    fn len(&self) -> usize {
                        self.it.len()
                    }
                }

                impl FusedIterator for U64Digits<'_> {}

            }

            pub mod monty
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use alloc::vec::Vec;
                use core::mem;
                use core::ops::Shl;
                use num_traits::One;

                use crate::big_digit::{self, BigDigit, DoubleBigDigit};
                use crate::biguint::BigUint
                */
                struct MontyReducer {
                    n0inv: BigDigit,
                }

               
               
                fn inv_mod_alt(b: BigDigit) -> BigDigit {
                    assert_ne!(b & 1, 0);

                    let mut k0 = BigDigit::wrapping_sub(2, b);
                    let mut t = b - 1;
                    let mut i = 1;
                    while i < big_digit::BITS {
                        t = t.wrapping_mul(t);
                        k0 = k0.wrapping_mul(t + 1);

                        i <<= 1;
                    }
                    debug_assert_eq!(k0.wrapping_mul(b), 1);
                    k0.wrapping_neg()
                }

                impl MontyReducer {
                    fn new(n: &BigUint) -> Self {
                        let n0inv = inv_mod_alt(n.data[0]);
                        MontyReducer { n0inv }
                    }
                }

                /// Computes z mod m = x * y * 2 ** (-n*_W) mod m
                /// assuming k = -1/m mod 2**_W
                /// See Gueron, "Efficient Software Implementations of Modular Exponentiation".
                /// <https://eprint.iacr.org/2011/239.pdf>
                /// In the terminology of that paper, this is an "Almost Montgomery Multiplication":
                /// x and y are required to satisfy 0 <= z < 2**(n*_W) and then the result
                /// z is guaranteed to satisfy 0 <= z < 2**(n*_W), but it may not be < m.
                #[allow(clippy::many_single_char_names)]
                fn montgomery(x: &BigUint, y: &BigUint, m: &BigUint, k: BigDigit, n: usize) -> BigUint {
                   
                   
                   
                   
                    assert!(
                        x.data.len() == n && y.data.len() == n && m.data.len() == n,
                        "{:?} {:?} {:?} {}",
                        x,
                        y,
                        m,
                        n
                    );

                    let mut z = BigUint::ZERO;
                    z.data.resize(n * 2, 0);

                    let mut c: BigDigit = 0;
                    for i in 0..n {
                        let c2 = add_mul_vvw(&mut z.data[i..n + i], &x.data, y.data[i]);
                        let t = z.data[i].wrapping_mul(k);
                        let c3 = add_mul_vvw(&mut z.data[i..n + i], &m.data, t);
                        let cx = c.wrapping_add(c2);
                        let cy = cx.wrapping_add(c3);
                        z.data[n + i] = cy;
                        if cx < c2 || cy < c3 {
                            c = 1;
                        } else {
                            c = 0;
                        }
                    }

                    if c == 0 {
                        z.data = z.data[n..].to_vec();
                    } else {
                        {
                            let (first, second) = z.data.split_at_mut(n);
                            sub_vv(first, second, &m.data);
                        }
                        z.data = z.data[..n].to_vec();
                    }

                    z
                }

                #[inline(always)]
                fn add_mul_vvw(z: &mut [BigDigit], x: &[BigDigit], y: BigDigit) -> BigDigit {
                    let mut c = 0;
                    for (zi, xi) in z.iter_mut().zip(x.iter()) {
                        let (z1, z0) = mul_add_www(*xi, y, *zi);
                        let (c_, zi_) = add_ww(z0, c, 0);
                        *zi = zi_;
                        c = c_ + z1;
                    }

                    c
                }

                /// The resulting carry c is either 0 or 1.
                #[inline(always)]
                fn sub_vv(z: &mut [BigDigit], x: &[BigDigit], y: &[BigDigit]) -> BigDigit {
                    let mut c = 0;
                    for (i, (xi, yi)) in x.iter().zip(y.iter()).enumerate().take(z.len()) {
                        let zi = xi.wrapping_sub(*yi).wrapping_sub(c);
                        z[i] = zi;
                       
                        c = ((yi & !xi) | ((yi | !xi) & zi)) >> (big_digit::BITS - 1)
                    }

                    c
                }

                /// z1<<_W + z0 = x+y+c, with c == 0 or 1
                #[inline(always)]
                fn add_ww(x: BigDigit, y: BigDigit, c: BigDigit) -> (BigDigit, BigDigit) {
                    let yc = y.wrapping_add(c);
                    let z0 = x.wrapping_add(yc);
                    let z1 = if z0 < x || yc < y { 1 } else { 0 };

                    (z1, z0)
                }

                /// z1 << _W + z0 = x * y + c
                #[inline(always)]
                fn mul_add_www(x: BigDigit, y: BigDigit, c: BigDigit) -> (BigDigit, BigDigit) {
                    let z = x as DoubleBigDigit * y as DoubleBigDigit + c as DoubleBigDigit;
                    ((z >> big_digit::BITS) as BigDigit, z as BigDigit)
                }

                /// Calculates x ** y mod m using a fixed, 4-bit window.
                #[allow(clippy::many_single_char_names)]
                pub(super) fn monty_modpow(x: &BigUint, y: &BigUint, m: &BigUint) -> BigUint {
                    assert!(m.data[0] & 1 == 1);
                    let mr = MontyReducer::new(m);
                    let num_words = m.data.len();

                    let mut x = x.clone();

                   
                   
                    if x.data.len() > num_words {
                        x %= m;
                       
                    }
                    if x.data.len() < num_words {
                        x.data.resize(num_words, 0);
                    }

                   
                    let mut rr = BigUint::one();
                    rr = (rr.shl(2 * num_words as u64 * u64::from(big_digit::BITS))) % m;
                    if rr.data.len() < num_words {
                        rr.data.resize(num_words, 0);
                    }
                   
                    let mut one = BigUint::one();
                    one.data.resize(num_words, 0);

                    let n = 4;
                   
                    let mut powers = Vec::with_capacity(1 << n);
                    powers.push(montgomery(&one, &rr, m, mr.n0inv, num_words));
                    powers.push(montgomery(&x, &rr, m, mr.n0inv, num_words));
                    for i in 2..1 << n {
                        let r = montgomery(&powers[i - 1], &powers[1], m, mr.n0inv, num_words);
                        powers.push(r);
                    }

                   
                    let mut z = powers[0].clone();
                    z.data.resize(num_words, 0);
                    let mut zz = BigUint::ZERO;
                    zz.data.resize(num_words, 0);

                   
                    for i in (0..y.data.len()).rev() {
                        let mut yi = y.data[i];
                        let mut j = 0;
                        while j < big_digit::BITS {
                            if i != y.data.len() - 1 || j != 0 {
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                            }
                            zz = montgomery(
                                &z,
                                &powers[(yi >> (big_digit::BITS - n)) as usize],
                                m,
                                mr.n0inv,
                                num_words,
                            );
                            mem::swap(&mut z, &mut zz);
                            yi <<= n;
                            j += n;
                        }
                    }

                   
                    zz = montgomery(&z, &one, m, mr.n0inv, num_words);

                    zz.normalize();
                   
                   
                    if zz >= *m {
                       
                       
                       
                       
                       
                       
                       
                        zz -= m;
                        if zz >= *m {
                            zz %= m;
                        }
                    }

                    zz.normalize();
                    zz
                }

            }

            pub mod power
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use super::monty::monty_modpow;
                use super::BigUint;

                use crate::big_digit::{self, BigDigit};

                use num_integer::Integer;
                use num_traits::{One, Pow, ToPrimitive, Zero};
                */
                impl Pow<&BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn pow(self, exp: &BigUint) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            Self::ZERO
                        } else if let Some(exp) = exp.to_u64() {
                            self.pow(exp)
                        } else if let Some(exp) = exp.to_u128() {
                            self.pow(exp)
                        } else {
                           
                           
                            panic!("memory overflow")
                        }
                    }
                }

                impl Pow<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn pow(self, exp: BigUint) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                impl Pow<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn pow(self, exp: &BigUint) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            BigUint::ZERO
                        } else {
                            self.clone().pow(exp)
                        }
                    }
                }

                impl Pow<BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn pow(self, exp: BigUint) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                macro_rules! pow_impl {
                    ($T:ty) => {
                        impl Pow<$T> for BigUint {
                            type Output = BigUint;

                            fn pow(self, mut exp: $T) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                let mut base = self;

                                while exp & 1 == 0 {
                                    base = &base * &base;
                                    exp >>= 1;
                                }

                                if exp == 1 {
                                    return base;
                                }

                                let mut acc = base.clone();
                                while exp > 1 {
                                    exp >>= 1;
                                    base = &base * &base;
                                    if exp & 1 == 1 {
                                        acc *= &base;
                                    }
                                }
                                acc
                            }
                        }

                        impl Pow<&$T> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }

                        impl Pow<$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: $T) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                Pow::pow(self.clone(), exp)
                            }
                        }

                        impl Pow<&$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }
                    };
                }

                pow_impl!(u8);
                pow_impl!(u16);
                pow_impl!(u32);
                pow_impl!(u64);
                pow_impl!(usize);
                pow_impl!(u128);

                pub(super) fn modpow(x: &BigUint, exponent: &BigUint, modulus: &BigUint) -> BigUint {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    if modulus.is_odd() {
                       
                        monty_modpow(x, exponent, modulus)
                    } else {
                       
                        plain_modpow(x, &exponent.data, modulus)
                    }
                }

                fn plain_modpow(base: &BigUint, exp_data: &[BigDigit], modulus: &BigUint) -> BigUint {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    let i = match exp_data.iter().position(|&r| r != 0) {
                        None => return BigUint::one(),
                        Some(i) => i,
                    };

                    let mut base = base % modulus;
                    for _ in 0..i {
                        for _ in 0..big_digit::BITS {
                            base = &base * &base % modulus;
                        }
                    }

                    let mut r = exp_data[i];
                    let mut b = 0u8;
                    while r.is_even() {
                        base = &base * &base % modulus;
                        r >>= 1;
                        b += 1;
                    }

                    let mut exp_iter = exp_data[i + 1..].iter();
                    if exp_iter.len() == 0 && r.is_one() {
                        return base;
                    }

                    let mut acc = base.clone();
                    r >>= 1;
                    b += 1;

                    {
                        let mut unit = |exp_is_odd| {
                            base = &base * &base % modulus;
                            if exp_is_odd {
                                acc *= &base;
                                acc %= modulus;
                            }
                        };

                        if let Some(&last) = exp_iter.next_back() {
                           
                            for _ in b..big_digit::BITS {
                                unit(r.is_odd());
                                r >>= 1;
                            }

                           
                            for &r in exp_iter {
                                let mut r = r;
                                for _ in 0..big_digit::BITS {
                                    unit(r.is_odd());
                                    r >>= 1;
                                }
                            }
                            r = last;
                        }

                        debug_assert_ne!(r, 0);
                        while !r.is_zero() {
                            unit(r.is_odd());
                            r >>= 1;
                        }
                    }
                    acc
                }
            }

            pub mod shift
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use super::{biguint_from_vec, BigUint};

                use crate::big_digit;

                use alloc::borrow::Cow;
                use alloc::vec::Vec;
                use core::mem;
                use core::ops::{Shl, ShlAssign, Shr, ShrAssign};
                use num_traits::{PrimInt, Zero};
                */
                #[inline]
                fn biguint_shl<T: PrimInt>(n: Cow<'_, BigUint>, shift: T) -> BigUint {
                    if shift < T::zero() {
                        panic!("attempt to shift left with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(big_digit::BITS).unwrap();
                    let digits = (shift / bits).to_usize().expect("capacity overflow");
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shl2(n, digits, shift)
                }

                fn biguint_shl2(n: Cow<'_, BigUint>, digits: usize, shift: u8) -> BigUint {
                    let mut data = match digits {
                        0 => n.into_owned().data,
                        _ => {
                            let len = digits.saturating_add(n.data.len() + 1);
                            let mut data = Vec::with_capacity(len);
                            data.resize(digits, 0);
                            data.extend(n.data.iter());
                            data
                        }
                    };

                    if shift > 0 {
                        let mut carry = 0;
                        let carry_shift = big_digit::BITS - shift;
                        for elem in data[digits..].iter_mut() {
                            let new_carry = *elem >> carry_shift;
                            *elem = (*elem << shift) | carry;
                            carry = new_carry;
                        }
                        if carry != 0 {
                            data.push(carry);
                        }
                    }

                    biguint_from_vec(data)
                }

                #[inline]
                fn biguint_shr<T: PrimInt>(n: Cow<'_, BigUint>, shift: T) -> BigUint {
                    if shift < T::zero() {
                        panic!("attempt to shift right with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(big_digit::BITS).unwrap();
                    let digits = (shift / bits).to_usize().unwrap_or(usize::MAX);
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shr2(n, digits, shift)
                }

                fn biguint_shr2(n: Cow<'_, BigUint>, digits: usize, shift: u8) -> BigUint {
                    if digits >= n.data.len() {
                        let mut n = n.into_owned();
                        n.set_zero();
                        return n;
                    }
                    let mut data = match n {
                        Cow::Borrowed(n) => n.data[digits..].to_vec(),
                        Cow::Owned(mut n) => {
                            n.data.drain(..digits);
                            n.data
                        }
                    };

                    if shift > 0 {
                        let mut borrow = 0;
                        let borrow_shift = big_digit::BITS - shift;
                        for elem in data.iter_mut().rev() {
                            let new_borrow = *elem << borrow_shift;
                            *elem = (*elem >> shift) | borrow;
                            borrow = new_borrow;
                        }
                    }

                    biguint_from_vec(data)
                }

                macro_rules! impl_shift {
                    (@ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty) => {
                        impl $Shx<&$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $Shx<&$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigUint {
                            #[inline]
                            fn $shx_assign(&mut self, rhs: &$rhs) {
                                $ShxAssign::$shx_assign(self, *rhs);
                            }
                        }
                    };
                    ($($rhs:ty),+) => {$(
                        impl Shl<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigUint {
                                biguint_shl(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shl<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigUint {
                                biguint_shl(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShlAssign<$rhs> for BigUint {
                            #[inline]
                            fn shl_assign(&mut self, rhs: $rhs) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n << rhs;
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }

                        impl Shr<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigUint {
                                biguint_shr(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shr<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigUint {
                                biguint_shr(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShrAssign<$rhs> for BigUint {
                            #[inline]
                            fn shr_assign(&mut self, rhs: $rhs) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n >> rhs;
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }

                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }

            }

        }

        #[cfg(target_pointer_width = "32")]
        type UsizePromotion = u32;
        #[cfg(target_pointer_width = "64")]
        type UsizePromotion = u64;

        #[cfg(target_pointer_width = "32")]
        type IsizePromotion = i32;
        #[cfg(target_pointer_width = "64")]
        type IsizePromotion = i64;

        #[derive(Debug, Clone, PartialEq, Eq)]
        pub struct ParseBigIntError {
            kind: BigIntErrorKind,
        }

        #[derive(Debug, Clone, PartialEq, Eq)]
        enum BigIntErrorKind {
            Empty,
            InvalidDigit,
        }

        impl ParseBigIntError {
            fn __description(&self) -> &str {
                use crate::BigIntErrorKind::*;
                match self.kind {
                    Empty => "cannot parse integer from empty string",
                    InvalidDigit => "invalid digit found in string",
                }
            }

            fn empty() -> Self {
                ParseBigIntError {
                    kind: BigIntErrorKind::Empty,
                }
            }

            fn invalid() -> Self {
                ParseBigIntError {
                    kind: BigIntErrorKind::InvalidDigit,
                }
            }
        }

        impl fmt::Display for ParseBigIntError {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                self.__description().fmt(f)
            }
        }

        #[cfg(feature = "std")]
        #[cfg_attr(docsrs, doc(cfg(feature = "std")))]
        impl std::error::Error for ParseBigIntError {
            fn description(&self) -> &str {
                self.__description()
            }
        }
        /// The error type returned when a checked conversion regarding big integer fails.
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TryFromBigIntError<T> {
            original: T,
        }

        impl<T> TryFromBigIntError<T> {
            fn new(original: T) -> Self {
                TryFromBigIntError { original }
            }

            fn __description(&self) -> &str {
                "out of range conversion regarding big integer attempted"
            }
            /// Extract the original value, if available. The value will be available
            /// if the type before conversion was either [`BigInt`] or [`BigUint`].
            pub fn into_original(self) -> T {
                self.original
            }
        }

        #[cfg(feature = "std")]
        #[cfg_attr(docsrs, doc(cfg(feature = "std")))]
        impl<T> std::error::Error for TryFromBigIntError<T>
        where
            T: fmt::Debug,
        {
            fn description(&self) -> &str {
                self.__description()
            }
        }

        impl<T> fmt::Display for TryFromBigIntError<T> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                self.__description().fmt(f)
            }
        }

        pub use crate::biguint::BigUint;
        pub use crate::biguint::ToBigUint;
        pub use crate::biguint::U32Digits;
        pub use crate::biguint::U64Digits;

        pub use crate::bigint::BigInt;
        pub use crate::bigint::Sign;
        pub use crate::bigint::ToBigInt;

        #[cfg(feature = "rand")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rand")))]
        pub use crate::bigrand::{RandBigInt, RandomBits, UniformBigInt, UniformBigUint};

        mod big_digit {
           
            cfg_digit!(
                pub(crate) type BigDigit = u32;
                pub(crate) type BigDigit = u64;
            );

           
           
            cfg_digit!(
                pub(crate) type DoubleBigDigit = u64;
                pub(crate) type DoubleBigDigit = u128;
            );

            pub(crate) const BITS: u8 = BigDigit::BITS as u8;
            pub(crate) const HALF_BITS: u8 = BITS / 2;
            pub(crate) const HALF: BigDigit = (1 << HALF_BITS) - 1;

            pub(crate) const MAX: BigDigit = BigDigit::MAX;
            const LO_MASK: DoubleBigDigit = MAX as DoubleBigDigit;

            #[inline]
            fn get_hi(n: DoubleBigDigit) -> BigDigit {
                (n >> BITS) as BigDigit
            }
            #[inline]
            fn get_lo(n: DoubleBigDigit) -> BigDigit {
                (n & LO_MASK) as BigDigit
            }
            /// Split one [`DoubleBigDigit`] into two [`BigDigit`]s.
            #[inline]
            pub(crate) fn from_doublebigdigit(n: DoubleBigDigit) -> (BigDigit, BigDigit) {
                (get_hi(n), get_lo(n))
            }
            /// Join two [`BigDigit`]s into one [`DoubleBigDigit`].
            #[inline]
            pub(crate) fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit {
                DoubleBigDigit::from(lo) | (DoubleBigDigit::from(hi) << BITS)
            }
        }
    }
    /*
    */
    pub mod rational
    {

        //! Rational numbers
        use ::
        {
            *,
        };
        /*
        #![doc(html_root_url = "https://docs.rs/num-rational/0.4")]
        #![no_std]
       
        #![allow(clippy::suspicious_arithmetic_impl)]
        #![allow(clippy::suspicious_op_assign_impl)]

        #[cfg(feature = "std")]
        #[macro_use]
        extern crate std;

        use core::cmp;
        use core::fmt;
        use core::fmt::{Binary, Display, Formatter, LowerExp, LowerHex, Octal, UpperExp, UpperHex};
        use core::hash::{Hash, Hasher};
        use core::ops::{Add, Div, Mul, Neg, Rem, ShlAssign, Sub};
        use core::str::FromStr;
        #[cfg(feature = "std")]
        use std::error::Error;

        #[cfg(feature = "num-bigint")]
        use num_bigint::{BigInt, BigUint, Sign, ToBigInt};

        use num_integer::Integer;
        use num_traits::float::FloatCore;
        use num_traits::{
            Bounded, CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, ConstOne, ConstZero, FromPrimitive,
            Inv, Num, NumCast, One, Pow, Signed, ToPrimitive, Unsigned, Zero,
        };
        */
        pub mod pow
        {
            use ::
            {
                *,
            };
            /*
                use crate::Ratio;

                use core::cmp;
                use num_integer::Integer;
                use num_traits::{One, Pow};
            */
            macro_rules! pow_unsigned_impl {
                (@ $exp:ty) => {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: $exp) -> Ratio<T> {
                        Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))
                    }
                };
                ($exp:ty) => {
                    impl<T: Clone + Integer + Pow<$exp, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_unsigned_impl!(@ $exp);
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        pow_unsigned_impl!(@ $exp);
                    }
                    impl<'b, T: Clone + Integer + Pow<$exp, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                };
            }
            pow_unsigned_impl!(u8);
            pow_unsigned_impl!(u16);
            pow_unsigned_impl!(u32);
            pow_unsigned_impl!(u64);
            pow_unsigned_impl!(u128);
            pow_unsigned_impl!(usize);

            macro_rules! pow_signed_impl {
                (@ &'b BigInt, BigUint) => {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: &'b BigInt) -> Ratio<T> {
                        match expon.sign() {
                            Sign::NoSign => One::one(),
                            Sign::Minus => {
                                Pow::pow(self, expon.magnitude()).into_recip()
                            }
                            Sign::Plus => Pow::pow(self, expon.magnitude()),
                        }
                    }
                };
                (@ $exp:ty, $unsigned:ty) => {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: $exp) -> Ratio<T> {
                        match expon.cmp(&0) {
                            cmp::Ordering::Equal => One::one(),
                            cmp::Ordering::Less => {
                                let expon = expon.wrapping_abs() as $unsigned;
                                Pow::pow(self, expon).into_recip()
                            }
                            cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),
                        }
                    }
                };
                ($exp:ty, $unsigned:ty) => {
                    impl<T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_signed_impl!(@ $exp, $unsigned);
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        pow_signed_impl!(@ $exp, $unsigned);
                    }
                    impl<'b, T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                };
            }
            pow_signed_impl!(i8, u8);
            pow_signed_impl!(i16, u16);
            pow_signed_impl!(i32, u32);
            pow_signed_impl!(i64, u64);
            pow_signed_impl!(i128, u128);
            pow_signed_impl!(isize, usize);

            #[cfg(feature = "num-bigint")]
            mod bigint {
                use super::*;
                use num_bigint::{BigInt, BigUint, Sign};

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigUint> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: BigUint) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigUint> for &'a Ratio<T>
                where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: BigUint) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigUint> for Ratio<T> {
                    pow_unsigned_impl!(@ &'b BigUint);
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigUint> for &'a Ratio<T>
                where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_unsigned_impl!(@ &'b BigUint);
                }

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigInt> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: BigInt) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigInt> for &'a Ratio<T>
                where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: BigInt) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigInt> for Ratio<T> {
                    pow_signed_impl!(@ &'b BigInt, BigUint);
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigInt> for &'a Ratio<T>
                where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_signed_impl!(@ &'b BigInt, BigUint);
                }
            }

        }
        /// Represents the ratio between two numbers.
        #[derive(Copy, Clone, Debug)]
        #[allow(missing_docs)]
        pub struct Ratio<T> {
            /// Numerator.
            numer: T,
            /// Denominator.
            denom: T,
        }
        /// Alias for a `Ratio` of machine-sized integers.
        #[deprecated(
            since = "0.4.0",
            note = "it's better to use a specific size, like `Rational32` or `Rational64`"
        )]
        pub type Rational = Ratio<isize>;
        /// Alias for a `Ratio` of 32-bit-sized integers.
        pub type Rational32 = Ratio<i32>;
        /// Alias for a `Ratio` of 64-bit-sized integers.
        pub type Rational64 = Ratio<i64>;

        #[cfg(feature = "num-bigint")]
        /// Alias for arbitrary precision rationals.
        pub type BigRational = Ratio<BigInt>;

        /// These method are `const`.
        impl<T> Ratio<T> {
            /// Creates a `Ratio` without checking for `denom == 0` or reducing.
            #[inline]
            pub const fn new_raw(numer: T, denom: T) -> Ratio<T> {
                Ratio { numer, denom }
            }
            /// Deconstructs a `Ratio` into its numerator and denominator.
            #[inline]
            pub fn into_raw(self) -> (T, T) {
                (self.numer, self.denom)
            }
            /// Gets an immutable reference to the numerator.
            #[inline]
            pub const fn numer(&self) -> &T {
                &self.numer
            }
            /// Gets an immutable reference to the denominator.
            #[inline]
            pub const fn denom(&self) -> &T {
                &self.denom
            }
        }

        impl<T: Clone + Integer> Ratio<T> {
            /// Creates a new `Ratio`.
            ///
            /// **Panics if `denom` is zero.**
            #[inline]
            pub fn new(numer: T, denom: T) -> Ratio<T> {
                let mut ret = Ratio::new_raw(numer, denom);
                ret.reduce();
                ret
            }
            /// Creates a `Ratio` representing the integer `t`.
            #[inline]
            pub fn from_integer(t: T) -> Ratio<T> {
                Ratio::new_raw(t, One::one())
            }
            /// Converts to an integer, rounding towards zero.
            #[inline]
            pub fn to_integer(&self) -> T {
                self.trunc().numer
            }
            /// Returns true if the rational number is an integer (denominator is 1).
            #[inline]
            pub fn is_integer(&self) -> bool {
                self.denom.is_one()
            }
            /// Puts self into lowest terms, with `denom` > 0.
            ///
            /// **Panics if `denom` is zero.**
            fn reduce(&mut self) {
                if self.denom.is_zero() {
                    panic!("denominator == 0");
                }
                if self.numer.is_zero() {
                    self.denom.set_one();
                    return;
                }
                if self.numer == self.denom {
                    self.set_one();
                    return;
                }
                let g: T = self.numer.gcd(&self.denom);

               
               

                #[inline]
                fn replace_with<T: Zero>(x: &mut T, f: impl FnOnce(T) -> T) {
                    let y = core::mem::replace(x, T::zero());
                    *x = f(y);
                }

               
                replace_with(&mut self.numer, |x| x / g.clone());

               
                replace_with(&mut self.denom, |x| x / g);

               
                if self.denom < T::zero() {
                    replace_with(&mut self.numer, |x| T::zero() - x);
                    replace_with(&mut self.denom, |x| T::zero() - x);
                }
            }
            /// Returns a reduced copy of self.
            ///
            /// **Panics if `denom` is zero.**
            pub fn reduced(&self) -> Ratio<T> {
                let mut ret = self.clone();
                ret.reduce();
                ret
            }
            /// Returns the reciprocal.
            ///
            /// **Panics if the `Ratio` is zero.**
            #[inline]
            pub fn recip(&self) -> Ratio<T> {
                self.clone().into_recip()
            }

            #[inline]
            fn into_recip(self) -> Ratio<T> {
                match self.numer.cmp(&T::zero()) {
                    cmp::Ordering::Equal => panic!("division by zero"),
                    cmp::Ordering::Greater => Ratio::new_raw(self.denom, self.numer),
                    cmp::Ordering::Less => Ratio::new_raw(T::zero() - self.denom, T::zero() - self.numer),
                }
            }
            /// Rounds towards minus infinity.
            #[inline]
            pub fn floor(&self) -> Ratio<T> {
                if *self < Zero::zero() {
                    let one: T = One::one();
                    Ratio::from_integer(
                        (self.numer.clone() - self.denom.clone() + one) / self.denom.clone(),
                    )
                } else {
                    Ratio::from_integer(self.numer.clone() / self.denom.clone())
                }
            }
            /// Rounds towards plus infinity.
            #[inline]
            pub fn ceil(&self) -> Ratio<T> {
                if *self < Zero::zero() {
                    Ratio::from_integer(self.numer.clone() / self.denom.clone())
                } else {
                    let one: T = One::one();
                    Ratio::from_integer(
                        (self.numer.clone() + self.denom.clone() - one) / self.denom.clone(),
                    )
                }
            }
            /// Rounds to the nearest integer. Rounds half-way cases away from zero.
            #[inline]
            pub fn round(&self) -> Ratio<T> {
                let zero: Ratio<T> = Zero::zero();
                let one: T = One::one();
                let two: T = one.clone() + one.clone();

               
                let mut fractional = self.fract();
                if fractional < zero {
                    fractional = zero - fractional
                };

               
               
               
                let half_or_larger = if fractional.denom.is_even() {
                    fractional.numer >= fractional.denom / two
                } else {
                    fractional.numer >= (fractional.denom / two) + one
                };

                if half_or_larger {
                    let one: Ratio<T> = One::one();
                    if *self >= Zero::zero() {
                        self.trunc() + one
                    } else {
                        self.trunc() - one
                    }
                } else {
                    self.trunc()
                }
            }
            /// Rounds towards zero.
            #[inline]
            pub fn trunc(&self) -> Ratio<T> {
                Ratio::from_integer(self.numer.clone() / self.denom.clone())
            }
            /// Returns the fractional part of a number, with division rounded towards zero.
            ///
            /// Satisfies `self == self.trunc() + self.fract()`.
            #[inline]
            pub fn fract(&self) -> Ratio<T> {
                Ratio::new_raw(self.numer.clone() % self.denom.clone(), self.denom.clone())
            }
            /// Raises the `Ratio` to the power of an exponent.
            #[inline]
            pub fn pow(&self, expon: i32) -> Ratio<T>
            where
                for<'a> &'a T: Pow<u32, Output = T>,
            {
                Pow::pow(self, expon)
            }
        }

        #[cfg(feature = "num-bigint")]
        impl Ratio<BigInt> {
            /// Converts a float into a rational number.
            pub fn from_float<T: FloatCore>(f: T) -> Option<BigRational> {
                if !f.is_finite() {
                    return None;
                }
                let (mantissa, exponent, sign) = f.integer_decode();
                let bigint_sign = if sign == 1 { Sign::Plus } else { Sign::Minus };
                if exponent < 0 {
                    let one: BigInt = One::one();
                    let denom: BigInt = one << ((-exponent) as usize);
                    let numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();
                    Some(Ratio::new(BigInt::from_biguint(bigint_sign, numer), denom))
                } else {
                    let mut numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();
                    numer <<= exponent as usize;
                    Some(Ratio::from_integer(BigInt::from_biguint(
                        bigint_sign,
                        numer,
                    )))
                }
            }
        }

        impl<T: Clone + Integer> Default for Ratio<T> {
            /// Returns zero
            fn default() -> Self {
                Ratio::zero()
            }
        }

       
        impl<T> From<T> for Ratio<T>
        where
            T: Clone + Integer,
        {
            fn from(x: T) -> Ratio<T> {
                Ratio::from_integer(x)
            }
        }

       
        impl<T> From<(T, T)> for Ratio<T>
        where
            T: Clone + Integer,
        {
            fn from(pair: (T, T)) -> Ratio<T> {
                Ratio::new(pair.0, pair.1)
            }
        }

       

       
       

        impl<T: Clone + Integer> Ord for Ratio<T> {
            #[inline]
            fn cmp(&self, other: &Self) -> cmp::Ordering {
               
                if self.denom == other.denom {
                    let ord = self.numer.cmp(&other.numer);
                    return if self.denom < T::zero() {
                        ord.reverse()
                    } else {
                        ord
                    };
                }

               
                if self.numer == other.numer {
                    if self.numer.is_zero() {
                        return cmp::Ordering::Equal;
                    }
                    let ord = self.denom.cmp(&other.denom);
                    return if self.numer < T::zero() {
                        ord
                    } else {
                        ord.reverse()
                    };
                }

               
               
               

               
                let (self_int, self_rem) = self.numer.div_mod_floor(&self.denom);
                let (other_int, other_rem) = other.numer.div_mod_floor(&other.denom);
                match self_int.cmp(&other_int) {
                    cmp::Ordering::Greater => cmp::Ordering::Greater,
                    cmp::Ordering::Less => cmp::Ordering::Less,
                    cmp::Ordering::Equal => {
                        match (self_rem.is_zero(), other_rem.is_zero()) {
                            (true, true) => cmp::Ordering::Equal,
                            (true, false) => cmp::Ordering::Less,
                            (false, true) => cmp::Ordering::Greater,
                            (false, false) => {
                               
                                let self_recip = Ratio::new_raw(self.denom.clone(), self_rem);
                                let other_recip = Ratio::new_raw(other.denom.clone(), other_rem);
                                self_recip.cmp(&other_recip).reverse()
                            }
                        }
                    }
                }
            }
        }

        impl<T: Clone + Integer> PartialOrd for Ratio<T> {
            #[inline]
            fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
                Some(self.cmp(other))
            }
        }

        impl<T: Clone + Integer> PartialEq for Ratio<T> {
            #[inline]
            fn eq(&self, other: &Self) -> bool {
                self.cmp(other) == cmp::Ordering::Equal
            }
        }

        impl<T: Clone + Integer> Eq for Ratio<T> {}

       
       
        impl<T: Clone + Integer + Hash> Hash for Ratio<T> {
            fn hash<H: Hasher>(&self, state: &mut H) {
                recurse(&self.numer, &self.denom, state);

                fn recurse<T: Integer + Hash, H: Hasher>(numer: &T, denom: &T, state: &mut H) {
                    if !denom.is_zero() {
                        let (int, rem) = numer.div_mod_floor(denom);
                        int.hash(state);
                        recurse(denom, &rem, state);
                    } else {
                        denom.hash(state);
                    }
                }
            }
        }

        mod iter_sum_product {
            use crate::Ratio;
            use core::iter::{Product, Sum};
            use num_integer::Integer;
            use num_traits::{One, Zero};

            impl<T: Integer + Clone> Sum for Ratio<T> {
                fn sum<I>(iter: I) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold(Self::zero(), |sum, num| sum + num)
                }
            }

            impl<'a, T: Integer + Clone> Sum<&'a Ratio<T>> for Ratio<T> {
                fn sum<I>(iter: I) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold(Self::zero(), |sum, num| sum + num)
                }
            }

            impl<T: Integer + Clone> Product for Ratio<T> {
                fn product<I>(iter: I) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold(Self::one(), |prod, num| prod * num)
                }
            }

            impl<'a, T: Integer + Clone> Product<&'a Ratio<T>> for Ratio<T> {
                fn product<I>(iter: I) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold(Self::one(), |prod, num| prod * num)
                }
            }
        }

        mod opassign {
            use core::ops::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign};

            use crate::Ratio;
            use num_integer::Integer;
            use num_traits::NumAssign;

            impl<T: Clone + Integer + NumAssign> AddAssign for Ratio<T> {
                fn add_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer += other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer + rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> DivAssign for Ratio<T> {
                fn div_assign(&mut self, other: Ratio<T>) {
                    let gcd_ac = self.numer.gcd(&other.numer);
                    let gcd_bd = self.denom.gcd(&other.denom);
                    self.numer /= gcd_ac.clone();
                    self.numer *= other.denom / gcd_bd.clone();
                    self.denom /= gcd_bd;
                    self.denom *= other.numer / gcd_ac;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> MulAssign for Ratio<T> {
                fn mul_assign(&mut self, other: Ratio<T>) {
                    let gcd_ad = self.numer.gcd(&other.denom);
                    let gcd_bc = self.denom.gcd(&other.numer);
                    self.numer /= gcd_ad.clone();
                    self.numer *= other.numer / gcd_bc.clone();
                    self.denom /= gcd_bc;
                    self.denom *= other.denom / gcd_ad;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> RemAssign for Ratio<T> {
                fn rem_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer %= other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer % rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> SubAssign for Ratio<T> {
                fn sub_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer -= other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer - rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> AddAssign<T> for Ratio<T> {
                fn add_assign(&mut self, other: T) {
                    self.numer += self.denom.clone() * other;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> DivAssign<T> for Ratio<T> {
                fn div_assign(&mut self, other: T) {
                    let gcd = self.numer.gcd(&other);
                    self.numer /= gcd.clone();
                    self.denom *= other / gcd;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> MulAssign<T> for Ratio<T> {
                fn mul_assign(&mut self, other: T) {
                    let gcd = self.denom.gcd(&other);
                    self.denom /= gcd.clone();
                    self.numer *= other / gcd;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> RemAssign<T> for Ratio<T> {
                fn rem_assign(&mut self, other: T) {
                    self.numer %= self.denom.clone() * other;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> SubAssign<T> for Ratio<T> {
                fn sub_assign(&mut self, other: T) {
                    self.numer -= self.denom.clone() * other;
                    self.reduce();
                }
            }

            macro_rules! forward_op_assign {
                (impl $imp:ident, $method:ident) => {
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a Ratio<T>> for Ratio<T> {
                        #[inline]
                        fn $method(&mut self, other: &Ratio<T>) {
                            self.$method(other.clone())
                        }
                    }
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a T> for Ratio<T> {
                        #[inline]
                        fn $method(&mut self, other: &T) {
                            self.$method(other.clone())
                        }
                    }
                };
            }

            forward_op_assign!(impl AddAssign, add_assign);
            forward_op_assign!(impl DivAssign, div_assign);
            forward_op_assign!(impl MulAssign, mul_assign);
            forward_op_assign!(impl RemAssign, rem_assign);
            forward_op_assign!(impl SubAssign, sub_assign);
        }

        macro_rules! forward_ref_ref_binop {
            (impl $imp:ident, $method:ident) => {
                impl<'a, 'b, T: Clone + Integer> $imp<&'b Ratio<T>> for &'a Ratio<T> {
                    type Output = Ratio<T>;

                    #[inline]
                    fn $method(self, other: &'b Ratio<T>) -> Ratio<T> {
                        self.clone().$method(other.clone())
                    }
                }
                impl<'a, 'b, T: Clone + Integer> $imp<&'b T> for &'a Ratio<T> {
                    type Output = Ratio<T>;

                    #[inline]
                    fn $method(self, other: &'b T) -> Ratio<T> {
                        self.clone().$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_ref_val_binop {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T> $imp<Ratio<T>> for &'a Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline]
                    fn $method(self, other: Ratio<T>) -> Ratio<T> {
                        self.clone().$method(other)
                    }
                }
                impl<'a, T> $imp<T> for &'a Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline]
                    fn $method(self, other: T) -> Ratio<T> {
                        self.clone().$method(other)
                    }
                }
            };
        }

        macro_rules! forward_val_ref_binop {
            (impl $imp:ident, $method:ident) => {
                impl<'a, T> $imp<&'a Ratio<T>> for Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline]
                    fn $method(self, other: &Ratio<T>) -> Ratio<T> {
                        self.$method(other.clone())
                    }
                }
                impl<'a, T> $imp<&'a T> for Ratio<T>
                where
                    T: Clone + Integer,
                {
                    type Output = Ratio<T>;

                    #[inline]
                    fn $method(self, other: &T) -> Ratio<T> {
                        self.$method(other.clone())
                    }
                }
            };
        }

        macro_rules! forward_all_binop {
            (impl $imp:ident, $method:ident) => {
                forward_ref_ref_binop!(impl $imp, $method);
                forward_ref_val_binop!(impl $imp, $method);
                forward_val_ref_binop!(impl $imp, $method);
            };
        }

       
        forward_all_binop!(impl Mul, mul);
       
        impl<T> Mul<Ratio<T>> for Ratio<T>
        where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline]
            fn mul(self, rhs: Ratio<T>) -> Ratio<T> {
                let gcd_ad = self.numer.gcd(&rhs.denom);
                let gcd_bc = self.denom.gcd(&rhs.numer);
                Ratio::new(
                    self.numer / gcd_ad.clone() * (rhs.numer / gcd_bc.clone()),
                    self.denom / gcd_bc * (rhs.denom / gcd_ad),
                )
            }
        }
       
        impl<T> Mul<T> for Ratio<T>
        where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline]
            fn mul(self, rhs: T) -> Ratio<T> {
                let gcd = self.denom.gcd(&rhs);
                Ratio::new(self.numer * (rhs / gcd.clone()), self.denom / gcd)
            }
        }

        forward_all_binop!(impl Div, div);
       
        impl<T> Div<Ratio<T>> for Ratio<T>
        where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline]
            fn div(self, rhs: Ratio<T>) -> Ratio<T> {
                let gcd_ac = self.numer.gcd(&rhs.numer);
                let gcd_bd = self.denom.gcd(&rhs.denom);
                Ratio::new(
                    self.numer / gcd_ac.clone() * (rhs.denom / gcd_bd.clone()),
                    self.denom / gcd_bd * (rhs.numer / gcd_ac),
                )
            }
        }
       
        impl<T> Div<T> for Ratio<T>
        where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline]
            fn div(self, rhs: T) -> Ratio<T> {
                let gcd = self.numer.gcd(&rhs);
                Ratio::new(self.numer / gcd.clone(), self.denom * (rhs / gcd))
            }
        }

        macro_rules! arith_impl {
            (impl $imp:ident, $method:ident) => {
                forward_all_binop!(impl $imp, $method);
               
                impl<T: Clone + Integer> $imp<Ratio<T>> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline]
                    fn $method(self, rhs: Ratio<T>) -> Ratio<T> {
                        if self.denom == rhs.denom {
                            return Ratio::new(self.numer.$method(rhs.numer), rhs.denom);
                        }
                        let lcm = self.denom.lcm(&rhs.denom);
                        let lhs_numer = self.numer * (lcm.clone() / self.denom);
                        let rhs_numer = rhs.numer * (lcm.clone() / rhs.denom);
                        Ratio::new(lhs_numer.$method(rhs_numer), lcm)
                    }
                }
               
                impl<T: Clone + Integer> $imp<T> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline]
                    fn $method(self, rhs: T) -> Ratio<T> {
                        Ratio::new(self.numer.$method(self.denom.clone() * rhs), self.denom)
                    }
                }
            };
        }

        arith_impl!(impl Add, add);
        arith_impl!(impl Sub, sub);
        arith_impl!(impl Rem, rem);

       
        impl<T> CheckedMul for Ratio<T>
        where
            T: Clone + Integer + CheckedMul,
        {
            #[inline]
            fn checked_mul(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                let gcd_ad = self.numer.gcd(&rhs.denom);
                let gcd_bc = self.denom.gcd(&rhs.numer);
                Some(Ratio::new(
                    (self.numer.clone() / gcd_ad.clone())
                        .checked_mul(&(rhs.numer.clone() / gcd_bc.clone()))?,
                    (self.denom.clone() / gcd_bc).checked_mul(&(rhs.denom.clone() / gcd_ad))?,
                ))
            }
        }

       
        impl<T> CheckedDiv for Ratio<T>
        where
            T: Clone + Integer + CheckedMul,
        {
            #[inline]
            fn checked_div(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                if rhs.is_zero() {
                    return None;
                }
                let (numer, denom) = if self.denom == rhs.denom {
                    (self.numer.clone(), rhs.numer.clone())
                } else if self.numer == rhs.numer {
                    (rhs.denom.clone(), self.denom.clone())
                } else {
                    let gcd_ac = self.numer.gcd(&rhs.numer);
                    let gcd_bd = self.denom.gcd(&rhs.denom);
                    (
                        (self.numer.clone() / gcd_ac.clone())
                            .checked_mul(&(rhs.denom.clone() / gcd_bd.clone()))?,
                        (self.denom.clone() / gcd_bd).checked_mul(&(rhs.numer.clone() / gcd_ac))?,
                    )
                };
               
                if denom.is_zero() {
                    None
                } else if numer.is_zero() {
                    Some(Self::zero())
                } else if numer == denom {
                    Some(Self::one())
                } else {
                    let g = numer.gcd(&denom);
                    let numer = numer / g.clone();
                    let denom = denom / g;
                    let raw = if denom < T::zero() {
                       
                       
                        let n1 = T::zero() - T::one();
                        Ratio::new_raw(numer.checked_mul(&n1)?, denom.checked_mul(&n1)?)
                    } else {
                        Ratio::new_raw(numer, denom)
                    };
                    Some(raw)
                }
            }
        }

       
        macro_rules! checked_arith_impl {
            (impl $imp:ident, $method:ident) => {
                impl<T: Clone + Integer + CheckedMul + $imp> $imp for Ratio<T> {
                    #[inline]
                    fn $method(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                        let gcd = self.denom.clone().gcd(&rhs.denom);
                        let lcm = (self.denom.clone() / gcd.clone()).checked_mul(&rhs.denom)?;
                        let lhs_numer = (lcm.clone() / self.denom.clone()).checked_mul(&self.numer)?;
                        let rhs_numer = (lcm.clone() / rhs.denom.clone()).checked_mul(&rhs.numer)?;
                        Some(Ratio::new(lhs_numer.$method(&rhs_numer)?, lcm))
                    }
                }
            };
        }

       
        checked_arith_impl!(impl CheckedAdd, checked_add);

       
        checked_arith_impl!(impl CheckedSub, checked_sub);

        impl<T> Neg for Ratio<T>
        where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline]
            fn neg(self) -> Ratio<T> {
                Ratio::new_raw(-self.numer, self.denom)
            }
        }

        impl<'a, T> Neg for &'a Ratio<T>
        where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline]
            fn neg(self) -> Ratio<T> {
                -self.clone()
            }
        }

        impl<T> Inv for Ratio<T>
        where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline]
            fn inv(self) -> Ratio<T> {
                self.recip()
            }
        }

        impl<'a, T> Inv for &'a Ratio<T>
        where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline]
            fn inv(self) -> Ratio<T> {
                self.recip()
            }
        }

       
        impl<T: ConstZero + ConstOne> Ratio<T> {
            /// A constant `Ratio` 0/1.
            pub const ZERO: Self = Self::new_raw(T::ZERO, T::ONE);
        }

        impl<T: Clone + Integer + ConstZero + ConstOne> ConstZero for Ratio<T> {
            const ZERO: Self = Self::ZERO;
        }

        impl<T: Clone + Integer> Zero for Ratio<T> {
            #[inline]
            fn zero() -> Ratio<T> {
                Ratio::new_raw(Zero::zero(), One::one())
            }

            #[inline]
            fn is_zero(&self) -> bool {
                self.numer.is_zero()
            }

            #[inline]
            fn set_zero(&mut self) {
                self.numer.set_zero();
                self.denom.set_one();
            }
        }

        impl<T: ConstOne> Ratio<T> {
            /// A constant `Ratio` 1/1.
            pub const ONE: Self = Self::new_raw(T::ONE, T::ONE);
        }

        impl<T: Clone + Integer + ConstOne> ConstOne for Ratio<T> {
            const ONE: Self = Self::ONE;
        }

        impl<T: Clone + Integer> One for Ratio<T> {
            #[inline]
            fn one() -> Ratio<T> {
                Ratio::new_raw(One::one(), One::one())
            }

            #[inline]
            fn is_one(&self) -> bool {
                self.numer == self.denom
            }

            #[inline]
            fn set_one(&mut self) {
                self.numer.set_one();
                self.denom.set_one();
            }
        }

        impl<T: Clone + Integer> Num for Ratio<T> {
            type FromStrRadixErr = ParseRatioError;

            /// Parses `numer/denom` where the numbers are in base `radix`.
            fn from_str_radix(s: &str, radix: u32) -> Result<Ratio<T>, ParseRatioError> {
                if s.splitn(2, '/').count() == 2 {
                    let mut parts = s.splitn(2, '/').map(|ss| {
                        T::from_str_radix(ss, radix).map_err(|_| ParseRatioError {
                            kind: RatioErrorKind::ParseError,
                        })
                    });
                    let numer: T = parts.next().unwrap()?;
                    let denom: T = parts.next().unwrap()?;
                    if denom.is_zero() {
                        Err(ParseRatioError {
                            kind: RatioErrorKind::ZeroDenominator,
                        })
                    } else {
                        Ok(Ratio::new(numer, denom))
                    }
                } else {
                    Err(ParseRatioError {
                        kind: RatioErrorKind::ParseError,
                    })
                }
            }
        }

        impl<T: Clone + Integer + Signed> Signed for Ratio<T> {
            #[inline]
            fn abs(&self) -> Ratio<T> {
                if self.is_negative() {
                    -self.clone()
                } else {
                    self.clone()
                }
            }

            #[inline]
            fn abs_sub(&self, other: &Ratio<T>) -> Ratio<T> {
                if *self <= *other {
                    Zero::zero()
                } else {
                    self - other
                }
            }

            #[inline]
            fn signum(&self) -> Ratio<T> {
                if self.is_positive() {
                    Self::one()
                } else if self.is_zero() {
                    Self::zero()
                } else {
                    -Self::one()
                }
            }

            #[inline]
            fn is_positive(&self) -> bool {
                (self.numer.is_positive() && self.denom.is_positive())
                    || (self.numer.is_negative() && self.denom.is_negative())
            }

            #[inline]
            fn is_negative(&self) -> bool {
                (self.numer.is_negative() && self.denom.is_positive())
                    || (self.numer.is_positive() && self.denom.is_negative())
            }
        }

       
        macro_rules! impl_formatting {
            ($fmt_trait:ident, $prefix:expr, $fmt_str:expr, $fmt_alt:expr) => {
                impl<T: $fmt_trait + Clone + Integer> $fmt_trait for Ratio<T> {
                    #[cfg(feature = "std")]
                    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                        let pre_pad = if self.denom.is_one() {
                            format!($fmt_str, self.numer)
                        } else {
                            if f.alternate() {
                                format!(concat!($fmt_str, "/", $fmt_alt), self.numer, self.denom)
                            } else {
                                format!(concat!($fmt_str, "/", $fmt_str), self.numer, self.denom)
                            }
                        };
                        if let Some(pre_pad) = pre_pad.strip_prefix("-") {
                            f.pad_integral(false, $prefix, pre_pad)
                        } else {
                            f.pad_integral(true, $prefix, &pre_pad)
                        }
                    }
                    #[cfg(not(feature = "std"))]
                    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
                        let plus = if f.sign_plus() && self.numer >= T::zero() {
                            "+"
                        } else {
                            ""
                        };
                        if self.denom.is_one() {
                            if f.alternate() {
                                write!(f, concat!("{}", $fmt_alt), plus, self.numer)
                            } else {
                                write!(f, concat!("{}", $fmt_str), plus, self.numer)
                            }
                        } else {
                            if f.alternate() {
                                write!(
                                    f,
                                    concat!("{}", $fmt_alt, "/", $fmt_alt),
                                    plus, self.numer, self.denom
                                )
                            } else {
                                write!(
                                    f,
                                    concat!("{}", $fmt_str, "/", $fmt_str),
                                    plus, self.numer, self.denom
                                )
                            }
                        }
                    }
                }
            };
        }

        impl_formatting!(Display, "", "{}", "{:#}");
        impl_formatting!(Octal, "0o", "{:o}", "{:#o}");
        impl_formatting!(Binary, "0b", "{:b}", "{:#b}");
        impl_formatting!(LowerHex, "0x", "{:x}", "{:#x}");
        impl_formatting!(UpperHex, "0x", "{:X}", "{:#X}");
        impl_formatting!(LowerExp, "", "{:e}", "{:#e}");
        impl_formatting!(UpperExp, "", "{:E}", "{:#E}");

        impl<T: FromStr + Clone + Integer> FromStr for Ratio<T> {
            type Err = ParseRatioError;

            /// Parses `numer/denom` or just `numer`.
            fn from_str(s: &str) -> Result<Ratio<T>, ParseRatioError> {
                let mut split = s.splitn(2, '/');

                let n = split.next().ok_or(ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;
                let num = FromStr::from_str(n).map_err(|_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;

                let d = split.next().unwrap_or("1");
                let den = FromStr::from_str(d).map_err(|_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;

                if Zero::is_zero(&den) {
                    Err(ParseRatioError {
                        kind: RatioErrorKind::ZeroDenominator,
                    })
                } else {
                    Ok(Ratio::new(num, den))
                }
            }
        }

        impl<T> From<Ratio<T>> for (T, T) {
            fn from(val: Ratio<T>) -> Self {
                (val.numer, val.denom)
            }
        }

        #[cfg(feature = "serde")]
        impl<T> serde::Serialize for Ratio<T>
        where
            T: serde::Serialize + Clone + Integer + PartialOrd,
        {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                (self.numer(), self.denom()).serialize(serializer)
            }
        }

        #[cfg(feature = "serde")]
        impl<'de, T> serde::Deserialize<'de> for Ratio<T>
        where
            T: serde::Deserialize<'de> + Clone + Integer + PartialOrd,
        {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use serde::de::Error;
                use serde::de::Unexpected;
                let (numer, denom): (T, T) = serde::Deserialize::deserialize(deserializer)?;
                if denom.is_zero() {
                    Err(Error::invalid_value(
                        Unexpected::Signed(0),
                        &"a ratio with non-zero denominator",
                    ))
                } else {
                    Ok(Ratio::new_raw(numer, denom))
                }
            }
        }

       
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct ParseRatioError {
            kind: RatioErrorKind,
        }

        #[derive(Copy, Clone, Debug, PartialEq)]
        enum RatioErrorKind {
            ParseError,
            ZeroDenominator,
        }

        impl fmt::Display for ParseRatioError {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                self.kind.description().fmt(f)
            }
        }

        #[cfg(feature = "std")]
        impl Error for ParseRatioError {
            #[allow(deprecated)]
            fn description(&self) -> &str {
                self.kind.description()
            }
        }

        impl RatioErrorKind {
            fn description(&self) -> &'static str {
                match *self {
                    RatioErrorKind::ParseError => "failed to parse integer",
                    RatioErrorKind::ZeroDenominator => "zero value denominator",
                }
            }
        }

        #[cfg(feature = "num-bigint")]
        impl FromPrimitive for Ratio<BigInt> {
            fn from_i64(n: i64) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_i128(n: i128) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_u64(n: u64) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_u128(n: u128) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_f32(n: f32) -> Option<Self> {
                Ratio::from_float(n)
            }

            fn from_f64(n: f64) -> Option<Self> {
                Ratio::from_float(n)
            }
        }

        macro_rules! from_primitive_integer {
            ($typ:ty, $approx:ident) => {
                impl FromPrimitive for Ratio<$typ> {
                    fn from_i64(n: i64) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)
                    }

                    fn from_i128(n: i128) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)
                    }

                    fn from_u64(n: u64) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)
                    }

                    fn from_u128(n: u128) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)
                    }

                    fn from_f32(n: f32) -> Option<Self> {
                        $approx(n, 10e-20, 30)
                    }

                    fn from_f64(n: f64) -> Option<Self> {
                        $approx(n, 10e-20, 30)
                    }
                }
            };
        }

        from_primitive_integer!(i8, approximate_float);
        from_primitive_integer!(i16, approximate_float);
        from_primitive_integer!(i32, approximate_float);
        from_primitive_integer!(i64, approximate_float);
        from_primitive_integer!(i128, approximate_float);
        from_primitive_integer!(isize, approximate_float);

        from_primitive_integer!(u8, approximate_float_unsigned);
        from_primitive_integer!(u16, approximate_float_unsigned);
        from_primitive_integer!(u32, approximate_float_unsigned);
        from_primitive_integer!(u64, approximate_float_unsigned);
        from_primitive_integer!(u128, approximate_float_unsigned);
        from_primitive_integer!(usize, approximate_float_unsigned);

        impl<T: Integer + Signed + Bounded + NumCast + Clone> Ratio<T> {
            pub fn approximate_float<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>> {
               
               
               
                let epsilon = <F as NumCast>::from(10e-20).expect("Can't convert 10e-20");
                approximate_float(f, epsilon, 30)
            }
        }

        impl<T: Integer + Unsigned + Bounded + NumCast + Clone> Ratio<T> {
            pub fn approximate_float_unsigned<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>> {
               
               
               
                let epsilon = <F as NumCast>::from(10e-20).expect("Can't convert 10e-20");
                approximate_float_unsigned(f, epsilon, 30)
            }
        }

        fn approximate_float<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>>
        where
            T: Integer + Signed + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
            let negative = val.is_sign_negative();
            let abs_val = val.abs();

            let r = approximate_float_unsigned(abs_val, max_error, max_iterations)?;

           
            Some(if negative { r.neg() } else { r })
        }

       
       
        fn approximate_float_unsigned<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>>
        where
            T: Integer + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
           
           

            if val < F::zero() || val.is_nan() {
                return None;
            }

            let mut q = val;
            let mut n0 = T::zero();
            let mut d0 = T::one();
            let mut n1 = T::one();
            let mut d1 = T::zero();

            let t_max = T::max_value();
            let t_max_f = <F as NumCast>::from(t_max.clone())?;

           
            let epsilon = t_max_f.recip();

           
            if q > t_max_f {
                return None;
            }

            for _ in 0..max_iterations {
                let a = match <T as NumCast>::from(q) {
                    None => break,
                    Some(a) => a,
                };

                let a_f = match <F as NumCast>::from(a.clone()) {
                    None => break,
                    Some(a_f) => a_f,
                };
                let f = q - a_f;

               
                if !a.is_zero()
                    && (n1 > t_max.clone() / a.clone()
                        || d1 > t_max.clone() / a.clone()
                        || a.clone() * n1.clone() > t_max.clone() - n0.clone()
                        || a.clone() * d1.clone() > t_max.clone() - d0.clone())
                {
                    break;
                }

                let n = a.clone() * n1.clone() + n0.clone();
                let d = a.clone() * d1.clone() + d0.clone();

                n0 = n1;
                d0 = d1;
                n1 = n.clone();
                d1 = d.clone();

               
               
                let g = Integer::gcd(&n1, &d1);
                if !g.is_zero() {
                    n1 = n1 / g.clone();
                    d1 = d1 / g.clone();
                }

               
                let (n_f, d_f) = match (<F as NumCast>::from(n), <F as NumCast>::from(d)) {
                    (Some(n_f), Some(d_f)) => (n_f, d_f),
                    _ => break,
                };
                if (n_f / d_f - val).abs() < max_error {
                    break;
                }

               
                if f < epsilon {
                    break;
                }
                q = f.recip();
            }

           
            if d1.is_zero() {
                return None;
            }

            Some(Ratio::new(n1, d1))
        }

        #[cfg(not(feature = "num-bigint"))]
        macro_rules! to_primitive_small {
            ($($type_name:ty)*) => ($(
                impl ToPrimitive for Ratio<$type_name> {
                    fn to_i64(&self) -> Option<i64> {
                        self.to_integer().to_i64()
                    }

                    fn to_i128(&self) -> Option<i128> {
                        self.to_integer().to_i128()
                    }

                    fn to_u64(&self) -> Option<u64> {
                        self.to_integer().to_u64()
                    }

                    fn to_u128(&self) -> Option<u128> {
                        self.to_integer().to_u128()
                    }

                    fn to_f64(&self) -> Option<f64> {
                        let float = self.numer.to_f64().unwrap() / self.denom.to_f64().unwrap();
                        if float.is_nan() {
                            None
                        } else {
                            Some(float)
                        }
                    }
                }
            )*)
        }

        #[cfg(not(feature = "num-bigint"))]
        to_primitive_small!(u8 i8 u16 i16 u32 i32);

        #[cfg(all(target_pointer_width = "32", not(feature = "num-bigint")))]
        to_primitive_small!(usize isize);

        #[cfg(not(feature = "num-bigint"))]
        macro_rules! to_primitive_64 {
            ($($type_name:ty)*) => ($(
                impl ToPrimitive for Ratio<$type_name> {
                    fn to_i64(&self) -> Option<i64> {
                        self.to_integer().to_i64()
                    }

                    fn to_i128(&self) -> Option<i128> {
                        self.to_integer().to_i128()
                    }

                    fn to_u64(&self) -> Option<u64> {
                        self.to_integer().to_u64()
                    }

                    fn to_u128(&self) -> Option<u128> {
                        self.to_integer().to_u128()
                    }

                    fn to_f64(&self) -> Option<f64> {
                        let float = ratio_to_f64(
                            self.numer as i128,
                            self.denom as i128
                        );
                        if float.is_nan() {
                            None
                        } else {
                            Some(float)
                        }
                    }
                }
            )*)
        }

        #[cfg(not(feature = "num-bigint"))]
        to_primitive_64!(u64 i64);

        #[cfg(all(target_pointer_width = "64", not(feature = "num-bigint")))]
        to_primitive_64!(usize isize);

        #[cfg(feature = "num-bigint")]
        impl<T: Clone + Integer + ToPrimitive + ToBigInt> ToPrimitive for Ratio<T> {
            fn to_i64(&self) -> Option<i64> {
                self.to_integer().to_i64()
            }

            fn to_i128(&self) -> Option<i128> {
                self.to_integer().to_i128()
            }

            fn to_u64(&self) -> Option<u64> {
                self.to_integer().to_u64()
            }

            fn to_u128(&self) -> Option<u128> {
                self.to_integer().to_u128()
            }

            fn to_f64(&self) -> Option<f64> {
                let float = match (self.numer.to_i64(), self.denom.to_i64()) {
                    (Some(numer), Some(denom)) => ratio_to_f64(
                        <i128 as From<_>>::from(numer),
                        <i128 as From<_>>::from(denom),
                    ),
                    _ => {
                        let numer: BigInt = self.numer.to_bigint()?;
                        let denom: BigInt = self.denom.to_bigint()?;
                        ratio_to_f64(numer, denom)
                    }
                };
                if float.is_nan() {
                    None
                } else {
                    Some(float)
                }
            }
        }

        trait Bits {
            fn bits(&self) -> u64;
        }

        #[cfg(feature = "num-bigint")]
        impl Bits for BigInt {
            fn bits(&self) -> u64 {
                self.bits()
            }
        }

        impl Bits for i128 {
            fn bits(&self) -> u64 {
                (128 - self.wrapping_abs().leading_zeros()).into()
            }
        }
        /// Converts a ratio of `T` to an f64.
        ///
        /// In addition to stated trait bounds, `T` must be able to hold numbers 56 bits larger than
        /// the largest of `numer` and `denom`. This is automatically true if `T` is `BigInt`.
        fn ratio_to_f64<T: Bits + Clone + Integer + Signed + ShlAssign<usize> + ToPrimitive>(
            numer: T,
            denom: T,
        ) -> f64 {
            use core::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, MIN_EXP, RADIX};

            assert_eq!(
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
            );

           
            const MAX_EXACT_INT: i64 = 1i64 << MANTISSA_DIGITS;
            const MIN_EXACT_INT: i64 = -MAX_EXACT_INT;

            let flo_sign = numer.signum().to_f64().unwrap() / denom.signum().to_f64().unwrap();
            if !flo_sign.is_normal() {
                return flo_sign;
            }

           
           
           
            if let (Some(n), Some(d)) = (numer.to_i64(), denom.to_i64()) {
                let exact = MIN_EXACT_INT..=MAX_EXACT_INT;
                if exact.contains(&n) && exact.contains(&d) {
                    return n.to_f64().unwrap() / d.to_f64().unwrap();
                }
            }

           
           
           
           
            let mut numer = numer.abs();
            let mut denom = denom.abs();
            let (is_diff_positive, absolute_diff) = match numer.bits().checked_sub(denom.bits()) {
                Some(diff) => (true, diff),
                None => (false, denom.bits() - numer.bits()),
            };

           
           
            if is_diff_positive && absolute_diff > MAX_EXP as u64 {
                return INFINITY * flo_sign;
            }
            if !is_diff_positive && absolute_diff > -MIN_EXP as u64 + MANTISSA_DIGITS as u64 + 1 {
                return 0.0 * flo_sign;
            }
            let diff = if is_diff_positive {
                absolute_diff.to_isize().unwrap()
            } else {
                -absolute_diff.to_isize().unwrap()
            };

           
           
            let shift: isize = diff.max(MIN_EXP as isize) - MANTISSA_DIGITS as isize - 2;
            if shift >= 0 {
                denom <<= shift as usize
            } else {
                numer <<= -shift as usize
            };

            let (quotient, remainder) = numer.div_rem(&denom);

           
            let mut quotient = quotient.to_u64().unwrap();
            let n_rounding_bits = {
                let quotient_bits = 64 - quotient.leading_zeros() as isize;
                let subnormal_bits = MIN_EXP as isize - shift;
                quotient_bits.max(subnormal_bits) - MANTISSA_DIGITS as isize
            } as usize;
            debug_assert!(n_rounding_bits == 2 || n_rounding_bits == 3);
            let rounding_bit_mask = (1u64 << n_rounding_bits) - 1;

           
           
            let ls_bit = quotient & (1u64 << n_rounding_bits) != 0;
            let ms_rounding_bit = quotient & (1u64 << (n_rounding_bits - 1)) != 0;
            let ls_rounding_bits = quotient & (rounding_bit_mask >> 1) != 0;
            if ms_rounding_bit && (ls_bit || ls_rounding_bits || !remainder.is_zero()) {
                quotient += 1u64 << n_rounding_bits;
            }
            quotient &= !rounding_bit_mask;

           
           
            let q_float = quotient as f64 * flo_sign;
            ldexp(q_float, shift as i32)
        }
        /// Multiply `x` by 2 to the power of `exp`. Returns an accurate result even if `2^exp` is not
        /// representable.
        fn ldexp(x: f64, exp: i32) -> f64 {
            use core::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, RADIX};

            assert_eq!(
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
            );

            const EXPONENT_MASK: u64 = 0x7ff << 52;
            const MAX_UNSIGNED_EXPONENT: i32 = 0x7fe;
            const MIN_SUBNORMAL_POWER: i32 = MANTISSA_DIGITS as i32;

            if x.is_zero() || x.is_infinite() || x.is_nan() {
                return x;
            }

           
            if exp > 3 * MAX_EXP {
                return INFINITY * x.signum();
            } else if exp < -3 * MAX_EXP {
                return 0.0 * x.signum();
            }

           
            let (bits, curr_exp) = if !x.is_normal() {
               
               
                let normal_x = x * 2f64.powi(MIN_SUBNORMAL_POWER);
                let bits = normal_x.to_bits();
               
                (
                    bits,
                    ((bits & EXPONENT_MASK) >> 52) as i32 - MIN_SUBNORMAL_POWER,
                )
            } else {
                let bits = x.to_bits();
                let curr_exp = (bits & EXPONENT_MASK) >> 52;
               
                (bits, curr_exp as i32)
            };

           
           
            let new_exp = curr_exp + exp;

            if new_exp > MAX_UNSIGNED_EXPONENT {
                INFINITY * x.signum()
            } else if new_exp > 0 {
               
                let new_bits = (bits & !EXPONENT_MASK) | ((new_exp as u64) << 52);
                f64::from_bits(new_bits)
            } else if new_exp >= -(MANTISSA_DIGITS as i32) {
               
               
               
               
                let new_exp = new_exp + MIN_SUBNORMAL_POWER;
                debug_assert!(new_exp >= 0);
                let new_bits = (bits & !EXPONENT_MASK) | ((new_exp as u64) << 52);
                f64::from_bits(new_bits) * 2f64.powi(-MIN_SUBNORMAL_POWER)
            } else {
               
                return 0.0 * x.signum();
            }
        }

    }
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod ops
{
    pub use std::ops::{ * };
}

pub mod option
{
    pub use std::option::{ * };
}

pub mod panic
{
    pub use std::panic::{ * };
}

pub mod path
{
    pub use std::path::{ * };
}

pub mod primitive
{
    pub use std::primitive::{ * };
}

pub mod process
{
    pub use std::process::{ * };

    pub mod macros
    {
        use ::
        {
            cmp::{ Ordering },
            error::{ Error },
            fmt::{ self, Debug, Display },
            hash::{ Hash, Hasher },
            ops::{ Range, RangeBounds },
            path::{ PathBuf },
            *,
        };
        /*
            use ::process::macros::extra::DelimSpan;
            use ::process::macros::marker::{ProcMacroAutoTraits, MARKER};
            use core::cmp::Ordering;
            use core::fmt::{self, Debug, Display};
            use core::hash::{Hash, Hasher};
            use core::ops::Range;
            use core::ops::RangeBounds;
            use core::str::FromStr;
            use std::error::Error;
            use std::ffi::CStr;
            use std::path::PathBuf;
            pub use ::process::macros::location::LineColumn;
        */        
        pub mod detection
        {
            use ::
            {
                sync::
                {
                    atomic::{ AtomicUsize, Ordering },
                    Once
                },
                *,
            };
            /*
            */
            static WORKS: AtomicUsize = AtomicUsize::new(0);
            static INIT: Once = Once::new();

            pub fn inside_proc_macro() -> bool
            {
                match WORKS.load(Ordering::Relaxed)
                {
                    1 => return false,
                    2 => return true,
                    _ =>
                    {}
                }

                INIT.call_once(initialize);
                inside_proc_macro()
            }

            pub fn force_fallback() { WORKS.store(1, Ordering::Relaxed); }

            pub fn unforce_fallback() { initialize(); }
            
            #[allow(deprecated)]
            fn initialize()
            {
                use ::panic::{self, PanicInfo};

                type PanicHook = dyn Fn(&PanicInfo) + Sync + Send + 'static;

                let null_hook: Box<PanicHook> = Box::new(|_panic_info| { /* ignore */ });
                let sanity_check = &*null_hook as *const PanicHook;
                let original_hook = panic::take_hook();
                panic::set_hook(null_hook);

                let works = panic::catch_unwind(proc_macro::Span::call_site).is_ok();
                WORKS.store(works as usize + 1, Ordering::Relaxed);

                let hopefully_null_hook = panic::take_hook();
                panic::set_hook(original_hook);
                if sanity_check != &*hopefully_null_hook
                {
                    panic!("observed race condition in process::macros::inside_proc_macro");
                }
            }
        }

        pub mod extra
        {
            use ::
            {
                fmt::{ self, Debug },
                process::macros::
                {
                    fallback, imp, Span, 
                },
                marker::{ ProcMacroAutoTraits, MARKER },
                *,
            };
            /*
            */
            /// Invalidate any `process::macros::Span` that exist on the current thread.
            pub fn invalidate_current_thread_spans()
            {
                ::process::macros::imp::invalidate_current_thread_spans();
            }
            /// An object that holds a [`Group`]'s `span_open()` and `span_close()` together
            /// in a more compact representation than holding those 2 spans individually.
            #[derive(Copy, Clone)]
            pub struct DelimSpan 
            {
                inner: DelimSpanEnum,
                _marker: ProcMacroAutoTraits,
            }

            #[derive(Copy, Clone)]
            enum DelimSpanEnum 
            {
                    Compiler {
                    join: proc_macro::Span,
                    open: proc_macro::Span,
                    close: proc_macro::Span,
                },
                Fallback(fallback::Span),
            }

            impl DelimSpan
            {
                pub fn new(group: &imp::Group) -> Self
               
                {
                    let inner = match group
                    {
                        imp::Group::Compiler(group) => DelimSpanEnum::Compiler
                        {
                            join: group.span(),
                            open: group.span_open(),
                            close: group.span_close(),
                        },
                        imp::Group::Fallback(group) => DelimSpanEnum::Fallback(group.span()),
                    };

                    DelimSpan
                    {
                        inner,
                        _marker: marker::MARKER,
                    }
                }
                /// Returns a span covering the entire delimited group.
                pub fn join( &self ) -> Span
                {
                    match &self.inner
                    {
                        DelimSpanEnum::Compiler { join, .. } => Span::_new(imp::Span::Compiler(*join)),
                        DelimSpanEnum::Fallback(span) => Span::_new_fallback(*span),
                    }
                }
                /// Returns a span for the opening punctuation of the group only.
                pub fn open( &self ) -> Span
                {
                    match &self.inner
                    {
                        DelimSpanEnum::Compiler { open, .. } => Span::_new(imp::Span::Compiler(*open)),
                        DelimSpanEnum::Fallback(span) => Span::_new_fallback(span.first_byte()),
                    }
                }
                /// Returns a span for the closing punctuation of the group only.
                pub fn close( &self ) -> Span
                {
                    match &self.inner
                    {
                        DelimSpanEnum::Compiler { close, .. } => Span::_new(imp::Span::Compiler(*close)),
                        DelimSpanEnum::Fallback(span) => Span::_new_fallback(span.last_byte()),
                    }
                }
            }

            impl Debug for DelimSpan           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    Debug::fmt(&self.join(), f)
                }
            }
        }
        
        pub mod fallback
        {
            use ::
            {
                cell::{ RefCell },
                collections::{ BTreeMap },
                convert::{ TryFrom },
                cmp::{ Ordering },
                fmt::{ self, Debug, Display, Write },
                ffi::{ CStr },
                mem::{ ManuallyDrop },
                ops::{ Range, RangeBounds },
                path::{ PathBuf },
                process::macros::
                {
                    location::LineColumn,
                    parse::{self, Cursor},
                    rcvec::{RcVec, RcVecBuilder, RcVecIntoIter, RcVecMut},
                    imp, Delimiter, Spacing, TokenTree,
                },
                str::{ FromStr },
                *,
            };
            /*
            */
            macro_rules! suffixed_numbers
            {
                ($($name:ident => $kind:ident,)*) => 
                ($(
                    pub fn $name(n: $kind) -> Literal 
                    {
                        Literal::_new(format!(concat!("{}", stringify!($kind)), n))
                    }
                )*)
            }

            macro_rules! unsuffixed_numbers
            {
                ($($name:ident => $kind:ident,)*) => 
                ($(
                    pub fn $name(n: $kind) -> Literal { Literal::_new(n.to_string()) }
                )*)
            }
            /// Force use of proc-macro2's fallback for now, even if the compiler's implementation is available.
            pub fn force()
            {
                ::process::macros::detection::force_fallback();
            }
            /// Resume using the compiler's implementation of the proc macro API if it is available.
            pub fn unforce()
            {
                ::process::macros::detection::unforce_fallback();
            }

            #[derive(Clone)]
            pub struct TokenStream 
            {
                inner: RcVec<TokenTree>,
            }

            #[derive(Debug)]
            pub struct LexError 
            {
                pub span: Span,
            }

            impl LexError           
            {
                pub fn span( &self ) -> Span { self.span }
                pub fn call_site() -> Self
                {
                    LexError
                    {
                        span: Span::call_site(),
                    }
                }
            }

            impl TokenStream
            {
                pub fn new() -> Self
                {
                    TokenStream
                    {
                        inner: RcVecBuilder::new().build(),
                    }
                }

                pub fn from_str_checked(src: &str) -> Result<Self, LexError>
               
                {
                    let mut cursor = get_cursor(src);
                    const BYTE_ORDER_MARK: &str = "\u{feff}";
                    if cursor.starts_with(BYTE_ORDER_MARK) {
                        cursor = cursor.advance(BYTE_ORDER_MARK.len());
                    }

                    parse::token_stream(cursor)
                }
                
                pub fn from_str_unchecked(src: &str) -> Self {
                    Self::from_str_checked(src).unwrap()
                }

                pub fn is_empty( &self ) -> bool
                {
                    self.inner.len() == 0
                }

                fn take_inner( self ) -> RcVecBuilder<TokenTree>
                {
                    let nodrop = ManuallyDrop::new( self );
                    unsafe { ptr::read(&nodrop.inner) }.make_owned()
                }
            }

            fn push_token_from_proc_macro(mut vec: RcVecMut<TokenTree>, token: TokenTree)
            {
                match token
                {
                    TokenTree::Literal
                    (
                        ::process::macros::Literal
                        {
                            inner: ::process::macros::imp::Literal::Fallback(literal),
                            _marker: marker::ProcMacroAutoTraits(_),
                        }
                    ) if literal.repr.starts_with('-') =>
                    {
                        push_negative_literal(vec, literal);
                    }
                    _ => vec.push(token),
                }

                #[cold] fn push_negative_literal(mut vec: RcVecMut<TokenTree>, mut literal: Literal)
                {
                    literal.repr.remove(0);
                    let mut punct = ::process::macros::Punct::new('-', Spacing::Alone);
                    punct.set_span(::process::macros::Span::_new_fallback(literal.span));
                    vec.push(TokenTree::Punct(punct));
                    vec.push(TokenTree::Literal(::process::macros::Literal::_new_fallback(literal)));
                }
            }
            
            impl Drop for TokenStream           
            {
                fn drop( &mut self )
                {
                    let mut stack = Vec::new();
                    let mut current = match self.inner.get_mut() {
                        Some(inner) => inner.take().into_iter(),
                        None => return,
                    };
                    loop {
                        while let Some(token) = current.next() {
                            let group = match token {
                                TokenTree::Group(group) => group.inner,
                                _ => continue,
                            };
                                            let group = match group {
                                ::process::macros::imp::Group::Fallback(group) => group,
                                ::process::macros::imp::Group::Compiler(_) => continue,
                            };
                            let mut group = group;
                            if let Some(inner) = group.stream.inner.get_mut() {
                                stack.push(current);
                                current = inner.take().into_iter();
                            }
                        }
                        match stack.pop() {
                            Some(next) => current = next,
                            None => return,
                        }
                    }
                }
            }

            pub struct TokenStreamBuilder {
                inner: RcVecBuilder<TokenTree>,
            }

            impl TokenStreamBuilder
            {
                pub fn new() -> Self {
                    TokenStreamBuilder {
                        inner: RcVecBuilder::new(),
                    }
                }

                pub fn with_capacity(cap: usize) -> Self {
                    TokenStreamBuilder {
                        inner: RcVecBuilder::with_capacity(cap),
                    }
                }

                pub fn push_token_from_parser(&mut self, tt: TokenTree) {
                    self.inner.push(tt);
                }

                pub fn build( self ) -> TokenStream {
                    TokenStream {
                        inner: self.inner.build(),
                    }
                }
            }
            
            fn get_cursor(src: &str) -> Cursor<'_>
            {
                SOURCE_MAP.with(|sm|
               
                {
                    let mut sm = sm.borrow_mut();
                    let span = sm.add_file(src);
                    Cursor {
                        rest: src,
                        off: span.lo,
                    }
                })
            }

            impl Display for LexError
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                    f.write_str("cannot parse string into token stream")
                }
            }

            impl Display for TokenStream
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    let mut joint = false;
                    for (i, tt) in self.inner.iter().enumerate() {
                        if i != 0 && !joint {
                            write!(f, " ")?;
                        }
                        joint = false;
                        match tt {
                            TokenTree::Group(tt) => Display::fmt(tt, f),
                            TokenTree::Ident(tt) => Display::fmt(tt, f),
                            TokenTree::Punct(tt) =>
                    {
                                joint = tt.spacing() == Spacing::Joint;
                                Display::fmt(tt, f)
                            }
                            TokenTree::Literal(tt) => Display::fmt(tt, f),
                        }?;
                    }

                    Ok(())
                }
            }

            impl Debug for TokenStream
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                    f.write_str("TokenStream ")?;
                    f.debug_list().entries(self.clone()).finish()
                }
            }
            
            impl From<proc_macro::TokenStream> for TokenStream
            {
                fn from(inner: proc_macro::TokenStream) -> Self {
                    TokenStream::from_str_unchecked(&inner.to_string())
                }
            }
            
            impl From<TokenStream> for proc_macro::TokenStream
            {
                fn from(inner: TokenStream) -> Self {
                    proc_macro::TokenStream::from_str_unchecked(&inner.to_string())
                }
            }

            impl From<TokenTree> for TokenStream
            {
                fn from(tree: TokenTree) -> Self
                {
                    let mut stream = RcVecBuilder::new();
                    push_token_from_proc_macro(stream.as_mut(), tree);
                    TokenStream {
                        inner: stream.build(),
                    }
                }
            }

            impl iter::FromIterator<TokenTree> for TokenStream
            {
                fn from_iter<I: IntoIterator<Item = TokenTree>>(tokens: I) -> Self
                {
                    let mut stream = TokenStream::new();
                    stream.extend(tokens);
                    stream
                }
            }

            impl iter::FromIterator<TokenStream> for TokenStream
            {
                fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self
                {
                    let mut v = RcVecBuilder::new();

                    for stream in streams {
                        v.extend(stream.take_inner());
                    }

                    TokenStream { inner: v.build() }
                }
            }

            impl Extend<TokenTree> for TokenStream
            {
                fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, tokens: I)
                {
                    let mut vec = self.inner.make_mut();
                    tokens
                        .into_iter()
                        .for_each(|token| push_token_from_proc_macro(vec.as_mut(), token));
                }
            }

            impl Extend<TokenStream> for TokenStream
            {
                fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {
                    self.inner.make_mut().extend(streams.into_iter().flatten());
                }
            }

            pub type TokenTreeIter = RcVecIntoIter<TokenTree>;

            impl IntoIterator for TokenStream {
                type Item = TokenTree;
                type IntoIter = TokenTreeIter;
                fn into_iter( self ) -> TokenTreeIter {
                    self.take_inner().into_iter()
                }
            }

            thread_local! {
                static SOURCE_MAP: RefCell<SourceMap> = RefCell::new(SourceMap {
                   
                   
                    files: vec![FileInfo {
                        source_text: String::new(),
                        span: Span { lo: 0, hi: 0 },
                        lines: vec![0],
                        char_index_to_byte_offset: BTreeMap::new(),
                    }],
                });
            }

            pub fn invalidate_current_thread_spans() {
                #[cfg(not(fuzzing))]
                SOURCE_MAP.with(|sm| sm.borrow_mut().files.truncate(1));
            }

            struct FileInfo {
                source_text: String,
                span: Span,
                lines: Vec<usize>,
                char_index_to_byte_offset: BTreeMap<usize, usize>,
            }

            impl FileInfo
            {
                fn offset_line_column( &self, offset: usize) -> LineColumn {
                    assert!(self.span_within(Span {
                        lo: offset as u32,
                        hi: offset as u32,
                    }));
                    let offset = offset - self.span.lo as usize;
                    match self.lines.binary_search(&offset) {
                        Ok(found) => LineColumn {
                            line: found + 1,
                            column: 0,
                        },
                        Err(idx) => LineColumn {
                            line: idx,
                            column: offset - self.lines[idx - 1],
                        },
                    }
                }

                fn span_within( &self, span: Span) -> bool
        {
                    span.lo >= self.span.lo && span.hi <= self.span.hi
                }

                fn byte_range(&mut self, span: Span) -> Range<usize>
                {
                    let lo_char = (span.lo - self.span.lo) as usize;

                   
                   
                   
                    let (&last_char_index, &last_byte_offset) = self
                        .char_index_to_byte_offset
                        .range(..=lo_char)
                        .next_back()
                        .unwrap_or((&0, &0));

                    let lo_byte = if last_char_index == lo_char {
                        last_byte_offset
                    } else {
                        let total_byte_offset = match self.source_text[last_byte_offset..]
                            .char_indices()
                            .nth(lo_char - last_char_index)
                        {
                            Some((additional_offset, _ch)) => last_byte_offset + additional_offset,
                            None => self.source_text.len(),
                        };
                        self.char_index_to_byte_offset
                            .insert(lo_char, total_byte_offset);
                        total_byte_offset
                    };

                    let trunc_lo = &self.source_text[lo_byte..];
                    let char_len = (span.hi - span.lo) as usize;
                    lo_byte..match trunc_lo.char_indices().nth(char_len) {
                        Some((offset, _ch)) => lo_byte + offset,
                        None => self.source_text.len(),
                    }
                }

                fn source_text(&mut self, span: Span) -> String
                {
                    let byte_range = self.byte_range(span);
                    self.source_text[byte_range].to_owned()
                }
            }
            /// Computes the offsets of each line in the given source string and the total number of characters
            fn lines_offsets(s: &str) -> (usize, Vec<usize>)
            {
                let mut lines = vec![0];
                let mut total = 0;

                for ch in s.chars() {
                    total += 1;
                    if ch == '\n' {
                        lines.push(total);
                    }
                }

                (total, lines)
            }

            struct SourceMap {
                files: Vec<FileInfo>,
            }

            impl SourceMap
            {
                fn next_start_pos( &self ) -> u32 {

                   
                   
                    self.files.last().unwrap().span.hi + 1
                }

                fn add_file(&mut self, src: &str) -> Span
                {
                    let (len, lines) = lines_offsets(src);
                    let lo = self.next_start_pos();
                    let span = Span {
                        lo,
                        hi: lo + (len as u32),
                    };

                    self.files.push(FileInfo {
                        source_text: src.to_owned(),
                        span,
                        lines,
                       
                        char_index_to_byte_offset: BTreeMap::new(),
                    });

                    span
                }

                fn find( &self, span: Span) -> usize {
                    match self.files.binary_search_by(|file| {
                        if file.span.hi < span.lo {
                            Ordering::Less
                        } else if file.span.lo > span.hi {
                            Ordering::Greater
                        } else {
                            assert!(file.span_within(span));
                            Ordering::Equal
                        }
                    }) {
                        Ok(i) => i,
                        Err(_) => unreachable!("Invalid span with no related FileInfo!"),
                    }
                }

                fn filepath( &self, span: Span) -> String
                {
                    let i = self.find(span);
                    if i == 0 {
                        "<unspecified>".to_owned()
                    } else {
                        format!("<parsed string {}>", i)
                    }
                }

                fn fileinfo( &self, span: Span) -> &FileInfo
                {
                    let i = self.find(span);
                    &self.files[i]
                }

                fn fileinfo_mut(&mut self, span: Span) -> &mut FileInfo
                {
                    let i = self.find(span);
                    &mut self.files[i]
                }
            }

            #[derive(Clone, Copy, PartialEq, Eq)]
            pub struct Span {
                    pub lo: u32,
                    pub hi: u32,
            }

            impl Span 
            {
                pub fn call_site() -> Self {
                    Span { lo: 0, hi: 0 }
                }

                pub fn mixed_site() -> Self {
                    Span::call_site()
                }
                
                pub fn def_site() -> Self {
                    Span::call_site()
                }

                pub fn resolved_at( &self, _other: Span) -> Span {
                    *self
                }

                pub fn located_at( &self, other: Span) -> Span {
                    other
                }

                pub fn byte_range( &self ) -> Range<usize>
                    {
                    #[cfg(fuzzing)]
                    return 0..0;

                    #[cfg(not(fuzzing))]
                    {
                        if self.is_call_site() {
                            0..0
                        } else {
                            SOURCE_MAP.with(|sm| sm.borrow_mut().fileinfo_mut(*self).byte_range(*self))
                        }
                    }
                }

                pub fn start( &self ) -> LineColumn {
                    #[cfg(fuzzing)]
                    return LineColumn { line: 0, column: 0 };

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                        let fi = sm.fileinfo(*self);
                        fi.offset_line_column(self.lo as usize)
                    })
                }

                pub fn end( &self ) -> LineColumn {
                    #[cfg(fuzzing)]
                    return LineColumn { line: 0, column: 0 };

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                        let fi = sm.fileinfo(*self);
                        fi.offset_line_column(self.hi as usize)
                    })
                }

                pub fn file( &self ) -> String {
                    #[cfg(fuzzing)]
                    return "<unspecified>".to_owned();

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                        sm.filepath(*self)
                    })
                }

                pub fn local_file( &self ) -> Option<PathBuf>
                    {
                    None
                }

                pub fn join( &self, other: Span) -> Option<Span>
                    {
                    #[cfg(fuzzing)]
                    return {
                        let _ = other;
                        None
                    };

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                       
                        if !sm.fileinfo(*self).span_within(other) {
                            return None;
                        }
                        Some(Span {
                            lo: cmp::min(self.lo, other.lo),
                            hi: cmp::max(self.hi, other.hi),
                        })
                    })
                }
                
                pub fn source_text( &self ) -> Option<String>
                    {
                    #[cfg(fuzzing)]
                    return None;

                    #[cfg(not(fuzzing))]
                    {
                        if self.is_call_site() {
                            None
                        } else {
                            Some(SOURCE_MAP.with(|sm| sm.borrow_mut().fileinfo_mut(*self).source_text(*self)))
                        }
                    }
                }
                
                pub fn first_byte( self ) -> Self {
                    Span {
                        lo: self.lo,
                        hi: cmp::min(self.lo.saturating_add(1), self.hi),
                    }
                }

                pub fn last_byte( self ) -> Self {
                    Span {
                        lo: cmp::max(self.hi.saturating_sub(1), self.lo),
                        hi: self.hi,
                    }
                }
                
                fn is_call_site( &self ) -> bool
        {
                    self.lo == 0 && self.hi == 0
                }
            }

            impl Debug for Span
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                            return write!(f, "bytes({}..{})", self.lo, self.hi);

                }
            }

            pub fn debug_span_field_if_nontrivial(debug: &mut fmt::DebugStruct, span: Span) {
                    {
                    if span.is_call_site() {
                        return;
                    }
                }

                if cfg!(span_locations) {
                    debug.field("span", &span);
                }
            }

            #[derive(Clone)]
            pub struct Group {
                delimiter: Delimiter,
                stream: TokenStream,
                span: Span,
            }

            impl Group
            {
                pub fn new(delimiter: Delimiter, stream: TokenStream) -> Self {
                    Group {
                        delimiter,
                        stream,
                        span: Span::call_site(),
                    }
                }

                pub fn delimiter( &self ) -> Delimiter {
                    self.delimiter
                }

                pub fn stream( &self ) -> TokenStream {
                    self.stream.clone()
                }

                pub fn span( &self ) -> Span {
                    self.span
                }

                pub fn span_open( &self ) -> Span {
                    self.span.first_byte()
                }

                pub fn span_close( &self ) -> Span {
                    self.span.last_byte()
                }

                pub fn set_span(&mut self, span: Span) {
                    self.span = span;
                }
            }

            impl Display for Group 
            {
               
               
               
               
               
               
               
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    let (open, close) = match self.delimiter {
                        Delimiter::Parenthesis => ("(", ")"),
                        Delimiter::Brace => ("{ ", "}"),
                        Delimiter::Bracket => ("[", "]"),
                        Delimiter::None => ("", ""),
                    };

                    f.write_str(open)?;
                    Display::fmt(&self.stream, f)?;
                    /*
                    if self.delimiter == Delimiter::Brace && !self.stream.inner.is_empty() {
                        f.write_str(" ")?;
                    } */
                    f.write_str(close)?;

                    Ok(())
                }
            }

            impl Debug for Group
            {
                fn fmt( &self, fmt: &mut fmt::Formatter) -> fmt::Result
                {
                    let mut debug = fmt.debug_struct("Group");
                    debug.field("delimiter", &self.delimiter);
                    debug.field("stream", &self.stream);
                    debug_span_field_if_nontrivial(&mut debug, self.span);
                    debug.finish()
                }
            }

            #[derive(Clone)]
            pub struct Ident 
            {
                sym: Box<str>,
                span: Span,
                raw: bool,
            }

            impl Ident 
            {
                #[track_caller]
                pub fn new_checked(string: &str, span: Span) -> Self {
                    validate_ident(string);
                    Ident::new_unchecked(string, span)
                }

                pub fn new_unchecked(string: &str, span: Span) -> Self {
                    Ident {
                        sym: Box::from(string),
                        span,
                        raw: false,
                    }
                }

                #[track_caller]
                pub fn new_raw_checked(string: &str, span: Span) -> Self {
                    validate_ident_raw(string);
                    Ident::new_raw_unchecked(string, span)
                }

                pub fn new_raw_unchecked(string: &str, span: Span) -> Self {
                    Ident {
                        sym: Box::from(string),
                        span,
                        raw: true,
                    }
                }

                pub fn span( &self ) -> Span {
                    self.span
                }

                pub fn set_span(&mut self, span: Span) {
                    self.span = span;
                }
            }

            #[track_caller] fn validate_ident(string: &str) {
                if string.is_empty() {
                    panic!("Ident is not allowed to be empty; use Option<Ident>");
                }

                if string.bytes().all(|digit| b'0' <= digit && digit <= b'9') {
                    panic!("Ident cannot be a number; use Literal instead");
                }

                fn ident_ok(string: &str) -> bool
                {
                    let mut chars = string.chars();
                    let first = chars.next().unwrap();
                    if !::is::ident_start(first) {
                        return false;
                    }
                    for ch in chars {
                        if !::is::ident_continue(ch) {
                            return false;
                        }
                    }
                    true
                }

                if !ident_ok(string) {
                    panic!("{:?} is not a valid Ident", string);
                }
            }

            #[track_caller] fn validate_ident_raw(string: &str) {
                validate_ident(string);

                match string {
                    "_" | "super" | "self" | "Self" | "crate" =>
                    {
                        panic!("`r#{}` cannot be a raw identifier", string);
                    }
                    _ =>
                    {}
                }
            }

            impl PartialEq for Ident
            {
                fn eq( &self, other: &Ident) -> bool
        {
                    self.sym == other.sym && self.raw == other.raw
                }
            }

            impl<T> PartialEq<T> for Ident where
            T: ?Sized + AsRef<str>
            {
                fn eq( &self, other: &T) -> bool
                {
                    let other = other.as_ref();
                    if self.raw {
                        other.starts_with("r#") && *self.sym == other[2..]
                    } else {
                        *self.sym == *other
                    }
                }
            }

            impl Display for Ident
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                    if self.raw {
                        f.write_str("r#")?;
                    }
                    Display::fmt(&self.sym, f)
                }
            }
            
            impl Debug for Ident
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
               
                {
                    let mut debug = f.debug_struct("Ident");
                    debug.field("sym", &format_args!("{}", self));
                    debug_span_field_if_nontrivial(&mut debug, self.span);
                    debug.finish()
                }
            }

            #[derive(Clone)]
            pub struct Literal {
                pub repr: String,
                span: Span,
            }

            impl Literal
            {
                pub fn _new(repr: String) -> Self {
                    Literal {
                        repr,
                        span: Span::call_site(),
                    }
                }

                pub fn from_str_checked(repr: &str) -> Result<Self, LexError>
                {
                    let mut cursor = get_cursor(repr);
                            let lo = cursor.off;

                    let negative = cursor.starts_with_char('-');
                    if negative {
                        cursor = cursor.advance(1);
                        if !cursor.starts_with_fn(|ch| ch.is_ascii_digit()) {
                            return Err(LexError::call_site());
                        }
                    }

                    if let Ok((rest, mut literal)) = parse::literal(cursor) {
                        if rest.is_empty() {
                            if negative {
                                literal.repr.insert(0, '-');
                            }
                            literal.span = Span {
                                                    lo,
                                                    hi: rest.off,
                            };
                            return Ok(literal);
                        }
                    }
                    Err(LexError::call_site())
                }

                pub unsafe fn from_str_unchecked(repr: &str) -> Self {
                    Literal::_new(repr.to_owned())
                }

                suffixed_numbers! {
                    u8_suffixed => u8,
                    u16_suffixed => u16,
                    u32_suffixed => u32,
                    u64_suffixed => u64,
                    u128_suffixed => u128,
                    usize_suffixed => usize,
                    i8_suffixed => i8,
                    i16_suffixed => i16,
                    i32_suffixed => i32,
                    i64_suffixed => i64,
                    i128_suffixed => i128,
                    isize_suffixed => isize,

                    f32_suffixed => f32,
                    f64_suffixed => f64,
                }

                unsuffixed_numbers! {
                    u8_unsuffixed => u8,
                    u16_unsuffixed => u16,
                    u32_unsuffixed => u32,
                    u64_unsuffixed => u64,
                    u128_unsuffixed => u128,
                    usize_unsuffixed => usize,
                    i8_unsuffixed => i8,
                    i16_unsuffixed => i16,
                    i32_unsuffixed => i32,
                    i64_unsuffixed => i64,
                    i128_unsuffixed => i128,
                    isize_unsuffixed => isize,
                }

                pub fn f32_unsuffixed(f: f32) -> Literal
                {
                    let mut s = f.to_string();
                    if !s.contains('.') {
                        s.push_str(".0");
                    }
                    Literal::_new(s)
                }

                pub fn f64_unsuffixed(f: f64) -> Literal
                {
                    let mut s = f.to_string();
                    if !s.contains('.') {
                        s.push_str(".0");
                    }
                    Literal::_new(s)
                }

                pub fn string(string: &str) -> Literal
                {
                    let mut repr = String::with_capacity(string.len() + 2);
                    repr.push('"');
                    escape_utf8(string, &mut repr);
                    repr.push('"');
                    Literal::_new(repr)
                }

                pub fn character(ch: char) -> Literal
                {
                    let mut repr = String::new();
                    repr.push('\'');
                    if ch == '"' {
                       
                        repr.push(ch);
                    } else {
                        repr.extend(ch.escape_debug());
                    }
                    repr.push('\'');
                    Literal::_new(repr)
                }

                pub fn byte_character(byte: u8) -> Literal
                {
                    let mut repr = "b'".to_string();
                    #[allow(clippy::match_overlapping_arm)]
                    match byte {
                        b'\0' => repr.push_str(r"\0"),
                        b'\t' => repr.push_str(r"\t"),
                        b'\n' => repr.push_str(r"\n"),
                        b'\r' => repr.push_str(r"\r"),
                        b'\'' => repr.push_str(r"\'"),
                        b'\\' => repr.push_str(r"\\"),
                        b'\x20'..=b'\x7E' => repr.push(byte as char),
                        _ =>
                    {
                            let _ = write!(repr, r"\x{:02X}", byte);
                        }
                    }
                    repr.push('\'');
                    Literal::_new(repr)
                }

                pub fn byte_string(bytes: &[u8]) -> Literal
                {
                    let mut repr = "b\"".to_string();
                    let mut bytes = bytes.iter();
                    while let Some(&b) = bytes.next() {
                        #[allow(clippy::match_overlapping_arm)]
                        match b {
                            b'\0' => repr.push_str(match bytes.as_slice().first() {
                               
                                Some(b'0'..=b'7') => r"\x00",
                                _ => r"\0",
                            }),
                            b'\t' => repr.push_str(r"\t"),
                            b'\n' => repr.push_str(r"\n"),
                            b'\r' => repr.push_str(r"\r"),
                            b'"' => repr.push_str("\\\""),
                            b'\\' => repr.push_str(r"\\"),
                            b'\x20'..=b'\x7E' => repr.push(b as char),
                            _ =>
                    {
                                let _ = write!(repr, r"\x{:02X}", b);
                            }
                        }
                    }
                    repr.push('"');
                    Literal::_new(repr)
                }

                pub fn c_string(string: &CStr) -> Literal
                {
                    let mut repr = "c\"".to_string();
                    let mut bytes = string.to_bytes();
                    while !bytes.is_empty() {
                        let (valid, invalid) = match str::from_utf8(bytes) {
                            Ok(all_valid) =>
                    {
                                bytes = b"";
                                (all_valid, bytes)
                            }
                            Err(utf8_error) =>
                    {
                                let (valid, rest) = bytes.split_at(utf8_error.valid_up_to());
                                let valid = str::from_utf8(valid).unwrap();
                                let invalid = utf8_error
                                    .error_len()
                                    .map_or(rest, |error_len| &rest[..error_len]);
                                bytes = &bytes[valid.len() + invalid.len()..];
                                (valid, invalid)
                            }
                        };
                        escape_utf8(valid, &mut repr);
                        for &byte in invalid {
                            let _ = write!(repr, r"\x{:02X}", byte);
                        }
                    }
                    repr.push('"');
                    Literal::_new(repr)
                }

                pub fn span( &self ) -> Span {
                    self.span
                }

                pub fn set_span(&mut self, span: Span) {
                    self.span = span;
                }

                pub fn subspan<R: RangeBounds<usize>>( &self, range: R) -> Option<Span> 
                {
                    use ::ops::Bound;

                    let lo = match range.start_bound() {
                        Bound::Included(start) =>
                    {
                            let start = u32::try_from(*start).ok()?;
                            self.span.lo.checked_add(start)?
                        }
                        Bound::Excluded(start) =>
                    {
                            let start = u32::try_from(*start).ok()?;
                            self.span.lo.checked_add(start)?.checked_add(1)?
                        }
                        Bound::Unbounded => self.span.lo,
                    };
                    let hi = match range.end_bound() {
                        Bound::Included(end) =>
                    {
                            let end = u32::try_from(*end).ok()?;
                            self.span.lo.checked_add(end)?.checked_add(1)?
                        }
                        Bound::Excluded(end) =>
                    {
                            let end = u32::try_from(*end).ok()?;
                            self.span.lo.checked_add(end)?
                        }
                        Bound::Unbounded => self.span.hi,
                    };
                    if lo <= hi && hi <= self.span.hi {
                        Some(Span { lo, hi })
                    } else {
                        None
                    }
                }
            }

            impl Display for Literal
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                    Display::fmt(&self.repr, f)
                }
            }

            impl Debug for Literal
            {
                fn fmt( &self, fmt: &mut fmt::Formatter) -> fmt::Result
                {
                    let mut debug = fmt.debug_struct("Literal");
                    debug.field("lit", &format_args!("{}", self.repr));
                    debug_span_field_if_nontrivial(&mut debug, self.span);
                    debug.finish()
                }
            }
            
            pub trait FromStr2: FromStr<Err = proc_macro::LexError>
            {
                    fn valid(src: &str) -> bool;

                    fn from_str_checked(src: &str) -> Result<Self, imp::LexError>
                    {
                   
                   
                   
                    if !Self::valid(src) {
                        return Err(imp::LexError::CompilerPanic);
                    }

                   
                    match panic::catch_unwind(|| Self::from_str(src)) {
                        Ok(Ok(ok)) => Ok(ok),
                        Ok(Err(lex)) => Err(imp::LexError::Compiler(lex)),
                        Err(_panic) => Err(imp::LexError::CompilerPanic),
                    }
                }

                fn from_str_unchecked(src: &str) -> Self {
                    Self::from_str(src).unwrap()
                }
            }
            
            impl FromStr2 for proc_macro::TokenStream
            {
                fn valid(src: &str) -> bool 
                {
                    TokenStream::from_str_checked(src).is_ok()
                }
            }
            
            impl FromStr2 for proc_macro::Literal
            {
                fn valid(src: &str) -> bool 
                {
                    Literal::from_str_checked(src).is_ok()
                }
            }

            fn escape_utf8(string: &str, repr: &mut String)
            {
                let mut chars = string.chars();
                while let Some(ch) = chars.next() {
                    if ch == '\0' {
                        repr.push_str(
                            if chars
                                .as_str()
                                .starts_with(|next| '0' <= next && next <= '7')
                            {
                               
                                r"\x00"
                            } else {
                                r"\0"
                            },
                        );
                    } else if ch == '\'' {
                       
                        repr.push(ch);
                    } else {
                        repr.extend(ch.escape_debug());
                    }
                }
            }
        }
           
        pub mod imp
        {
            use ::
            {
                ffi::{ CStr },
                fmt::{ self, Debug, Display },
                ops::{ Range, RangeBounds },
                path::{ PathBuf },
                process::
                {
                    macros::
                    {
                        detection::inside_proc_macro,
                        fallback::{self, FromStr2 as _},
                        location::LineColumn,
                        probe::{ proc_macro_span, proc_macro_span_file, proc_macro_span_location },
                        Delimiter, Punct, Spacing, TokenTree,                        
                    },
                },
                *,
            };
            /*
            */
            #[derive(Clone)]
            pub enum TokenStream 
            {
                Compiler(DeferredTokenStream),
                Fallback(fallback::TokenStream),
            }

            #[derive(Clone)]
            pub struct DeferredTokenStream 
            {
                stream: proc_macro::TokenStream,
                extra: Vec<proc_macro::TokenTree>,
            }

            pub enum LexError
            {
                Compiler(proc_macro::LexError),
                Fallback(fallback::LexError),
                CompilerPanic,
            }

            #[cold] fn mismatch(line: u32) -> !
            {
                let backtrace = ::backtrace::Backtrace::force_capture();
                panic!("compiler/fallback mismatch L{}\n\n{}", line, backtrace)
            }

            impl DeferredTokenStream           
            {
                fn new(stream: proc_macro::TokenStream) -> Self
                {
                    DeferredTokenStream
                    {
                        stream,
                        extra: Vec::new(),
                    }
                }

                fn is_empty( &self ) -> bool { self.stream.is_empty() && self.extra.is_empty() }

                fn evaluate_now( &mut self )
                {
                    if !self.extra.is_empty() { self.stream.extend(self.extra.drain(..)); }
                }

                fn into_token_stream(mut self) -> proc_macro::TokenStream
                {
                    self.evaluate_now();
                    self.stream
                }
            }

            impl TokenStream           
            {
                pub fn new() -> Self
                {
                    if inside_proc_macro() {
                        TokenStream::Compiler(DeferredTokenStream::new(proc_macro::TokenStream::new()))
                    } else {
                        TokenStream::Fallback(fallback::TokenStream::new())
                    }
                }

                pub fn from_str_checked(src: &str) -> Result<Self, LexError>
                    {
                    if inside_proc_macro() {
                        Ok(TokenStream::Compiler(DeferredTokenStream::new(
                            proc_macro::TokenStream::from_str_checked(src)?,
                        )))
                    } else {
                        Ok(TokenStream::Fallback(
                            fallback::TokenStream::from_str_checked(src)?,
                        ))
                    }
                }

                pub fn is_empty( &self ) -> bool
                {
                    match self {
                        TokenStream::Compiler(tts) => tts.is_empty(),
                        TokenStream::Fallback(tts) => tts.is_empty(),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::TokenStream
                {
                    match self {
                        TokenStream::Compiler(s) => s.into_token_stream(),
                        TokenStream::Fallback(_) => mismatch(line!()),
                    }
                }

                fn unwrap_stable( self ) -> fallback::TokenStream           
                {
                    match self {
                        TokenStream::Compiler(_) => mismatch(line!()),
                        TokenStream::Fallback(s) => s,
                    }
                }
            }

            impl Display for TokenStream                  
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        TokenStream::Compiler(tts) => Display::fmt(&tts.clone().into_token_stream(), f),
                        TokenStream::Fallback(tts) => Display::fmt(tts, f),
                    }
                }
            }

            impl From<proc_macro::TokenStream> for TokenStream           
            {
                fn from(inner: proc_macro::TokenStream) -> Self
                {
                    TokenStream::Compiler(DeferredTokenStream::new(inner))
                }
            }

            impl From<TokenStream> for proc_macro::TokenStream           
            {
                fn from(inner: TokenStream) -> Self
                {
                    match inner {
                        TokenStream::Compiler(inner) => inner.into_token_stream(),
                        TokenStream::Fallback(inner) =>
                    {
                            proc_macro::TokenStream::from_str_unchecked(&inner.to_string())
                        }
                    }
                }
            }

            impl From<fallback::TokenStream> for TokenStream           
            {
                fn from(inner: fallback::TokenStream) -> Self
                {
                    TokenStream::Fallback(inner)
                }
            }
            
            fn into_compiler_token(token: TokenTree) -> proc_macro::TokenTree
            {
                match token {
                    TokenTree::Group(tt) => proc_macro::TokenTree::Group(tt.inner.unwrap_nightly()),
                    TokenTree::Punct(tt) =>
                    {
                        let spacing = match tt.spacing() {
                            Spacing::Joint => proc_macro::Spacing::Joint,
                            Spacing::Alone => proc_macro::Spacing::Alone,
                        };
                        let mut punct = proc_macro::Punct::new(tt.as_char(), spacing);
                        punct.set_span(tt.span().inner.unwrap_nightly());
                        proc_macro::TokenTree::Punct(punct)
                    }
                    TokenTree::Ident(tt) => proc_macro::TokenTree::Ident(tt.inner.unwrap_nightly()),
                    TokenTree::Literal(tt) => proc_macro::TokenTree::Literal(tt.inner.unwrap_nightly()),
                }
            }

            impl From<TokenTree> for TokenStream           
            {
                fn from(token: TokenTree) -> Self
                {
                    if inside_proc_macro() {
                        TokenStream::Compiler(DeferredTokenStream::new(proc_macro::TokenStream::from(
                            into_compiler_token(token),
                        )))
                    } else {
                        TokenStream::Fallback(fallback::TokenStream::from(token))
                    }
                }
            }

            impl iter::FromIterator<TokenTree> for TokenStream           
            {
                fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self
                {
                    if inside_proc_macro() {
                        TokenStream::Compiler(DeferredTokenStream::new(
                            trees.into_iter().map(into_compiler_token).collect(),
                        ))
                    } else {
                        TokenStream::Fallback(trees.into_iter().collect())
                    }
                }
            }

            impl iter::FromIterator<TokenStream> for TokenStream
            {
                fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self
               
                {
                    let mut streams = streams.into_iter();
                    match streams.next() {
                        Some(TokenStream::Compiler(mut first)) =>
                    {
                            first.evaluate_now();
                            first.stream.extend(streams.map(|s| match s {
                                TokenStream::Compiler(s) => s.into_token_stream(),
                                TokenStream::Fallback(_) => mismatch(line!()),
                            }));
                            TokenStream::Compiler(first)
                        }
                        Some(TokenStream::Fallback(mut first)) =>
                    {
                            first.extend(streams.map(|s| match s {
                                TokenStream::Fallback(s) => s,
                                TokenStream::Compiler(_) => mismatch(line!()),
                            }));
                            TokenStream::Fallback(first)
                        }
                        None => TokenStream::new(),
                    }
                }
            }

            impl Extend<TokenTree> for TokenStream           
            {
                fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, stream: I)
                {
                    match self {
                        TokenStream::Compiler(tts) =>
                    {
                           
                            for token in stream {
                                tts.extra.push(into_compiler_token(token));
                            }
                        }
                        TokenStream::Fallback(tts) => tts.extend(stream),
                    }
                }
            }

            impl Extend<TokenStream> for TokenStream           
            {
                fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I)
                {
                    match self {
                        TokenStream::Compiler(tts) =>
                    {
                            tts.evaluate_now();
                            tts.stream
                                .extend(streams.into_iter().map(TokenStream::unwrap_nightly));
                        }
                        TokenStream::Fallback(tts) =>
                    {
                            tts.extend(streams.into_iter().map(TokenStream::unwrap_stable));
                        }
                    }
                }
            }

            impl Debug for TokenStream           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        TokenStream::Compiler(tts) => Debug::fmt(&tts.clone().into_token_stream(), f),
                        TokenStream::Fallback(tts) => Debug::fmt(tts, f),
                    }
                }
            }

            impl LexError
            {
                pub fn span( &self ) -> Span
                {
                    match self {
                        LexError::Compiler(_) | LexError::CompilerPanic => Span::call_site(),
                        LexError::Fallback(e) => Span::Fallback(e.span()),
                    }
                }
            }

            impl From<proc_macro::LexError> for LexError           
            {
                fn from(e: proc_macro::LexError) -> Self
                {
                    LexError::Compiler(e)
                }
            }

            impl From<fallback::LexError> for LexError           
            {
                fn from(e: fallback::LexError) -> Self
                {
                    LexError::Fallback(e)
                }
            }

            impl Debug for LexError           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        LexError::Compiler(e) => Debug::fmt(e, f),
                        LexError::Fallback(e) => Debug::fmt(e, f),
                        LexError::CompilerPanic =>
                    {
                            let fallback = fallback::LexError::call_site();
                            Debug::fmt(&fallback, f)
                        }
                    }
                }
            }

            impl Display for LexError           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        LexError::Compiler(e) => Display::fmt(e, f),
                        LexError::Fallback(e) => Display::fmt(e, f),
                        LexError::CompilerPanic =>
                    {
                            let fallback = fallback::LexError::call_site();
                            Display::fmt(&fallback, f)
                        }
                    }
                }
            }

            #[derive(Clone)]
            pub enum TokenTreeIter 
            {
                Compiler(proc_macro::token_stream::IntoIter),
                Fallback(fallback::TokenTreeIter),
            }

            impl IntoIterator for TokenStream
            {
                type Item = TokenTree;
                type IntoIter = TokenTreeIter;
                fn into_iter( self ) -> TokenTreeIter
                {
                    match self {
                        TokenStream::Compiler(tts) =>
                    {
                            TokenTreeIter::Compiler(tts.into_token_stream().into_iter())
                        }
                        TokenStream::Fallback(tts) => TokenTreeIter::Fallback(tts.into_iter()),
                    }
                }
            }

            impl Iterator for TokenTreeIter
            {
                type Item = TokenTree;
                fn next( &mut self ) -> Option<TokenTree>
                {
                    let token = match self {
                        TokenTreeIter::Compiler(iter) => iter.next()?,
                        TokenTreeIter::Fallback(iter) => return iter.next(),
                    };
                    Some(match token {
                        proc_macro::TokenTree::Group(tt) =>
                    {
                            TokenTree::Group(::process::macros::Group::_new(Group::Compiler(tt)))
                        }
                        proc_macro::TokenTree::Punct(tt) =>
                    {
                            let spacing = match tt.spacing() {
                                proc_macro::Spacing::Joint => Spacing::Joint,
                                proc_macro::Spacing::Alone => Spacing::Alone,
                            };
                            let mut o = Punct::new(tt.as_char(), spacing);
                            o.set_span(::process::macros::Span::_new(Span::Compiler(tt.span())));
                            TokenTree::Punct(o)
                        }
                        proc_macro::TokenTree::Ident(s) =>
                    {
                            TokenTree::Ident(::process::macros::Ident::_new(Ident::Compiler(s)))
                        }
                        proc_macro::TokenTree::Literal(l) =>
                    {
                            TokenTree::Literal(::process::macros::Literal::_new(Literal::Compiler(l)))
                        }
                    })
                }

                fn size_hint( &self ) -> (usize, Option<usize>)
                {
                    match self {
                        TokenTreeIter::Compiler(tts) => tts.size_hint(),
                        TokenTreeIter::Fallback(tts) => tts.size_hint(),
                    }
                }
            }

            #[derive(Copy, Clone)]
            pub enum Span
            {
                Compiler(proc_macro::Span),
                Fallback(fallback::Span),
            }

            impl Span           
            {
                pub fn call_site() -> Self
                {
                    if inside_proc_macro() {
                        Span::Compiler(proc_macro::Span::call_site())
                    } else {
                        Span::Fallback(fallback::Span::call_site())
                    }
                }

                pub fn mixed_site() -> Self
                {
                    if inside_proc_macro() {
                        Span::Compiler(proc_macro::Span::mixed_site())
                    } else {
                        Span::Fallback(fallback::Span::mixed_site())
                    }
                }
                
                pub fn def_site() -> Self
                {
                    Span::Fallback(fallback::Span::def_site())
                    /*
                    if inside_proc_macro() {
                        Span::Compiler(proc_macro::Span::def_site())
                    } else {
                        Span::Fallback(fallback::Span::def_site())
                    } */
                }

                pub fn resolved_at( &self, other: Span) -> Span 
                {
                    match (self, other) {
                        (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.resolved_at(b)),
                        (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.resolved_at(b)),
                        (Span::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Span::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                pub fn located_at( &self, other: Span) -> Span 
                {
                    match (self, other) {
                        (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.located_at(b)),
                        (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.located_at(b)),
                        (Span::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Span::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                pub fn unwrap( self ) -> proc_macro::Span
                {
                    match self {
                        Span::Compiler(s) => s,
                        Span::Fallback(_) => panic!("proc_macro::Span is only available in procedural macros"),
                    }
                }

                pub fn byte_range( &self ) -> Range<usize>
                {
                    match self {
                        #[cfg(proc_macro_span)]
                        Span::Compiler(s) => proc_macro_span::byte_range(s),
                        #[cfg(not(proc_macro_span))]
                        Span::Compiler(_) => 0..0,
                        Span::Fallback(s) => s.byte_range(),
                    }
                }

                pub fn start( &self ) -> LineColumn
                {
                    match self {
                        #[cfg(proc_macro_span_location)]
                        Span::Compiler(s) => LineColumn {
                            line: proc_macro_span_location::line(s),
                            column: proc_macro_span_location::column(s).saturating_sub(1),
                        },
                        #[cfg(not(proc_macro_span_location))]
                        Span::Compiler(_) => LineColumn { line: 0, column: 0 },
                        Span::Fallback(s) => s.start(),
                    }
                }

                pub fn end( &self ) -> LineColumn
                {
                    match self {
                        #[cfg(proc_macro_span_location)]
                        Span::Compiler(s) =>
                    {
                            let end = proc_macro_span_location::end(s);
                            LineColumn {
                                line: proc_macro_span_location::line(&end),
                                column: proc_macro_span_location::column(&end).saturating_sub(1),
                            }
                        }
                        #[cfg(not(proc_macro_span_location))]
                        Span::Compiler(_) => LineColumn { line: 0, column: 0 },
                        Span::Fallback(s) => s.end(),
                    }
                }

                pub fn file( &self ) -> String
                {
                    match self {
                        #[cfg(proc_macro_span_file)]
                        Span::Compiler(s) => proc_macro_span_file::file(s),
                        #[cfg(not(proc_macro_span_file))]
                        Span::Compiler(_) => "<token stream>".to_owned(),
                        Span::Fallback(s) => s.file(),
                    }
                }

                pub fn local_file( &self ) -> Option<PathBuf>
                {
                    match self {
                        #[cfg(proc_macro_span_file)]
                        Span::Compiler(s) => proc_macro_span_file::local_file(s),
                        #[cfg(not(proc_macro_span_file))]
                        Span::Compiler(_) => None,
                        Span::Fallback(s) => s.local_file(),
                    }
                }

                pub fn join( &self, other: Span) -> Option<Span> 
               
                {
                    let ret = match (self, other) {
                        #[cfg(proc_macro_span)]
                        (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(proc_macro_span::join(a, b)?),
                        (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.join(b)?),
                        _ => return None,
                    };
                    Some(ret)
                }
                
                pub fn eq( &self, other: &Span) -> bool 
                {
                    match (self, other)
                    {
                        //(Span::Compiler(a), Span::Compiler(b)) => a.eq(b),
                        (Span::Fallback(a), Span::Fallback(b)) => a.eq(b),
                        _ => false,
                    }
                }

                pub fn source_text( &self ) -> Option<String>
                {
                    match self {
                        #[cfg(not(no_source_text))]
                        Span::Compiler(s) => s.source_text(),
                        #[cfg(no_source_text)]
                        Span::Compiler(_) => None,
                        Span::Fallback(s) => s.source_text(),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Span
                {
                    match self {
                        Span::Compiler(s) => s,
                        Span::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<proc_macro::Span> for ::process::macros::Span           
            {
                fn from(proc_span: proc_macro::Span) -> Self
                {
                    ::process::macros::Span::_new(Span::Compiler(proc_span))
                }
            }

            impl From<fallback::Span> for Span           
            {
                fn from(inner: fallback::Span) -> Self
                {
                    Span::Fallback(inner)
                }
            }

            impl Debug for Span           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Span::Compiler(s) => Debug::fmt(s, f),
                        Span::Fallback(s) => Debug::fmt(s, f),
                    }
                }
            }

            pub fn debug_span_field_if_nontrivial(debug: &mut fmt::DebugStruct, span: Span)
            {
                match span {
                    Span::Compiler(s) =>
                    {
                        debug.field("span", &s);
                    }
                    Span::Fallback(s) => fallback::debug_span_field_if_nontrivial(debug, s),
                }
            }

            #[derive(Clone)]
            pub enum Group
            {
                Compiler(proc_macro::Group),
                Fallback(fallback::Group),
            }

            impl Group           
            {
                pub fn new(delimiter: Delimiter, stream: TokenStream) -> Self
                {
                    match stream {
                        TokenStream::Compiler(tts) =>
                    {
                            let delimiter = match delimiter {
                                Delimiter::Parenthesis => proc_macro::Delimiter::Parenthesis,
                                Delimiter::Bracket => proc_macro::Delimiter::Bracket,
                                Delimiter::Brace => proc_macro::Delimiter::Brace,
                                Delimiter::None => proc_macro::Delimiter::None,
                            };
                            Group::Compiler(proc_macro::Group::new(delimiter, tts.into_token_stream()))
                        }
                        TokenStream::Fallback(stream) =>
                    {
                            Group::Fallback(fallback::Group::new(delimiter, stream))
                        }
                    }
                }

                pub fn delimiter( &self ) -> Delimiter
                {
                    match self {
                        Group::Compiler(g) => match g.delimiter() {
                            proc_macro::Delimiter::Parenthesis => Delimiter::Parenthesis,
                            proc_macro::Delimiter::Bracket => Delimiter::Bracket,
                            proc_macro::Delimiter::Brace => Delimiter::Brace,
                            proc_macro::Delimiter::None => Delimiter::None,
                        },
                        Group::Fallback(g) => g.delimiter(),
                    }
                }

                pub fn stream( &self ) -> TokenStream
                {
                    match self {
                        Group::Compiler(g) => TokenStream::Compiler(DeferredTokenStream::new(g.stream())),
                        Group::Fallback(g) => TokenStream::Fallback(g.stream()),
                    }
                }

                pub fn span( &self ) -> Span
                {
                    match self {
                        Group::Compiler(g) => Span::Compiler(g.span()),
                        Group::Fallback(g) => Span::Fallback(g.span()),
                    }
                }

                pub fn span_open( &self ) -> Span
                {
                    match self {
                        Group::Compiler(g) => Span::Compiler(g.span_open()),
                        Group::Fallback(g) => Span::Fallback(g.span_open()),
                    }
                }

                pub fn span_close( &self ) -> Span
                {
                    match self {
                        Group::Compiler(g) => Span::Compiler(g.span_close()),
                        Group::Fallback(g) => Span::Fallback(g.span_close()),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match (self, span) {
                        (Group::Compiler(g), Span::Compiler(s)) => g.set_span(s),
                        (Group::Fallback(g), Span::Fallback(s)) => g.set_span(s),
                        (Group::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Group::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Group
                {
                    match self {
                        Group::Compiler(g) => g,
                        Group::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<fallback::Group> for Group           
            {
                fn from(g: fallback::Group) -> Self
                {
                    Group::Fallback(g)
                }
            }

            impl Display for Group           
            {
                fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Group::Compiler(group) => Display::fmt(group, formatter),
                        Group::Fallback(group) => Display::fmt(group, formatter),
                    }
                }
            }

            impl Debug for Group           
            {
                fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Group::Compiler(group) => Debug::fmt(group, formatter),
                        Group::Fallback(group) => Debug::fmt(group, formatter),
                    }
                }
            }

            #[derive(Clone)]
            pub enum Ident
            {
                Compiler(proc_macro::Ident),
                Fallback(fallback::Ident),
            }

            impl Ident 
            {
                #[track_caller]
                pub fn new_checked(string: &str, span: Span) -> Self
                {
                    match span {
                        Span::Compiler(s) => Ident::Compiler(proc_macro::Ident::new(string, s)),
                        Span::Fallback(s) => Ident::Fallback(fallback::Ident::new_checked(string, s)),
                    }
                }

                #[track_caller]
                pub fn new_raw_checked(string: &str, span: Span) -> Self
                {
                    match span {
                        Span::Compiler(s) => Ident::Compiler(proc_macro::Ident::new_raw(string, s)),
                        Span::Fallback(s) => Ident::Fallback(fallback::Ident::new_raw_checked(string, s)),
                    }
                }

                pub fn span( &self ) -> Span
                {
                    match self {
                        Ident::Compiler(t) => Span::Compiler(t.span()),
                        Ident::Fallback(t) => Span::Fallback(t.span()),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match (self, span) {
                        (Ident::Compiler(t), Span::Compiler(s)) => t.set_span(s),
                        (Ident::Fallback(t), Span::Fallback(s)) => t.set_span(s),
                        (Ident::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Ident::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Ident
                {
                    match self {
                        Ident::Compiler(s) => s,
                        Ident::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<fallback::Ident> for Ident           
            {
                fn from(inner: fallback::Ident) -> Self
                {
                    Ident::Fallback(inner)
                }
            }

            impl PartialEq for Ident           
            {
                fn eq( &self, other: &Ident) -> bool
        {
                    match (self, other) {
                        (Ident::Compiler(t), Ident::Compiler(o)) => t.to_string() == o.to_string(),
                        (Ident::Fallback(t), Ident::Fallback(o)) => t == o,
                        (Ident::Compiler(_), Ident::Fallback(_)) => mismatch(line!()),
                        (Ident::Fallback(_), Ident::Compiler(_)) => mismatch(line!()),
                    }
                }
            }

            impl<T> PartialEq<T> for Ident where
            T: ?Sized + AsRef<str>
            {
                fn eq( &self, other: &T) -> bool
                {
                    let other = other.as_ref();
                    match self {
                        Ident::Compiler(t) => t.to_string() == other,
                        Ident::Fallback(t) => t == other,
                    }
                }
            }

            impl Display for Ident           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Ident::Compiler(t) => Display::fmt(t, f),
                        Ident::Fallback(t) => Display::fmt(t, f),
                    }
                }
            }

            impl Debug for Ident           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Ident::Compiler(t) => Debug::fmt(t, f),
                        Ident::Fallback(t) => Debug::fmt(t, f),
                    }
                }
            }

            #[derive(Clone)]
            pub enum Literal 
            {
                Compiler(proc_macro::Literal),
                Fallback(fallback::Literal),
            }

            macro_rules! suffixed_numbers 
            {
                ($($name:ident => $kind:ident,)*) => ($(
                    pub fn $name(n: $kind) -> Literal {
                        if inside_proc_macro() {
                            Literal::Compiler(proc_macro::Literal::$name(n))
                        } else {
                            Literal::Fallback(fallback::Literal::$name(n))
                        }
                    }
                )*)
            }

            macro_rules! unsuffixed_integers 
            {
                ($($name:ident => $kind:ident,)*) => ($(
                    pub fn $name(n: $kind) -> Literal {
                        if inside_proc_macro() {
                            Literal::Compiler(proc_macro::Literal::$name(n))
                        } else {
                            Literal::Fallback(fallback::Literal::$name(n))
                        }
                    }
                )*)
            }

            impl Literal
            {
                pub fn from_str_checked(repr: &str) -> Result<Self, LexError>
                    {
                    if inside_proc_macro() {
                        let literal = proc_macro::Literal::from_str_checked(repr)?;
                        Ok(Literal::Compiler(literal))
                    } else {
                        let literal = fallback::Literal::from_str_checked(repr)?;
                        Ok(Literal::Fallback(literal))
                    }
                }

                pub unsafe fn from_str_unchecked(repr: &str) -> Self
                {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::from_str_unchecked(repr))
                    } else {
                        Literal::Fallback(unsafe { fallback::Literal::from_str_unchecked(repr) })
                    }
                }

                suffixed_numbers! {
                    u8_suffixed => u8,
                    u16_suffixed => u16,
                    u32_suffixed => u32,
                    u64_suffixed => u64,
                    u128_suffixed => u128,
                    usize_suffixed => usize,
                    i8_suffixed => i8,
                    i16_suffixed => i16,
                    i32_suffixed => i32,
                    i64_suffixed => i64,
                    i128_suffixed => i128,
                    isize_suffixed => isize,

                    f32_suffixed => f32,
                    f64_suffixed => f64,
                }

                unsuffixed_integers! {
                    u8_unsuffixed => u8,
                    u16_unsuffixed => u16,
                    u32_unsuffixed => u32,
                    u64_unsuffixed => u64,
                    u128_unsuffixed => u128,
                    usize_unsuffixed => usize,
                    i8_unsuffixed => i8,
                    i16_unsuffixed => i16,
                    i32_unsuffixed => i32,
                    i64_unsuffixed => i64,
                    i128_unsuffixed => i128,
                    isize_unsuffixed => isize,
                }

                pub fn f32_unsuffixed(f: f32) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::f32_unsuffixed(f))
                    } else {
                        Literal::Fallback(fallback::Literal::f32_unsuffixed(f))
                    }
                }

                pub fn f64_unsuffixed(f: f64) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::f64_unsuffixed(f))
                    } else {
                        Literal::Fallback(fallback::Literal::f64_unsuffixed(f))
                    }
                }

                pub fn string(string: &str) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::string(string))
                    } else {
                        Literal::Fallback(fallback::Literal::string(string))
                    }
                }

                pub fn character(ch: char) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::character(ch))
                    } else {
                        Literal::Fallback(fallback::Literal::character(ch))
                    }
                }

                pub fn byte_character(byte: u8) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler({
                            #[cfg(not(no_literal_byte_character))]
                            {
                                proc_macro::Literal::byte_character(byte)
                            }

                            #[cfg(no_literal_byte_character)]
                            {
                                let fallback = fallback::Literal::byte_character(byte);
                                proc_macro::Literal::from_str_unchecked(&fallback.repr)
                            }
                        })
                    } else {
                        Literal::Fallback(fallback::Literal::byte_character(byte))
                    }
                }

                pub fn byte_string(bytes: &[u8]) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::byte_string(bytes))
                    } else {
                        Literal::Fallback(fallback::Literal::byte_string(bytes))
                    }
                }

                pub fn c_string(string: &CStr) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler({
                            #[cfg(not(no_literal_c_string))]
                            {
                                proc_macro::Literal::c_string(string)
                            }

                            #[cfg(no_literal_c_string)]
                            {
                                let fallback = fallback::Literal::c_string(string);
                                proc_macro::Literal::from_str_unchecked(&fallback.repr)
                            }
                        })
                    } else {
                        Literal::Fallback(fallback::Literal::c_string(string))
                    }
                }

                pub fn span( &self ) -> Span
                {
                    match self {
                        Literal::Compiler(lit) => Span::Compiler(lit.span()),
                        Literal::Fallback(lit) => Span::Fallback(lit.span()),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match (self, span) {
                        (Literal::Compiler(lit), Span::Compiler(s)) => lit.set_span(s),
                        (Literal::Fallback(lit), Span::Fallback(s)) => lit.set_span(s),
                        (Literal::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Literal::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                pub fn subspan<R: RangeBounds<usize>>( &self, range: R) -> Option<Span>
                {
                    match self {
                        #[cfg(proc_macro_span)]
                        Literal::Compiler(lit) => proc_macro_span::subspan(lit, range).map(Span::Compiler),
                        #[cfg(not(proc_macro_span))]
                        Literal::Compiler(_lit) => None,
                        Literal::Fallback(lit) => lit.subspan(range).map(Span::Fallback),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Literal
                {
                    match self {
                        Literal::Compiler(s) => s,
                        Literal::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<fallback::Literal> for Literal           
            {
                fn from(s: fallback::Literal) -> Self
                {
                    Literal::Fallback(s)
                }
            }

            impl Display for Literal           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Literal::Compiler(t) => Display::fmt(t, f),
                        Literal::Fallback(t) => Display::fmt(t, f),
                    }
                }
            }

            impl Debug for Literal           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Literal::Compiler(t) => Debug::fmt(t, f),
                        Literal::Fallback(t) => Debug::fmt(t, f),
                    }
                }
            }
            
            pub fn invalidate_current_thread_spans()
            {
                if inside_proc_macro()
                {
                    panic!
                    (
                        "process::macros::extra::invalidate_current_thread_spans is not available in procedural macros"
                    );
                }
                
                else
                {
                    ::process::macros::fallback::invalidate_current_thread_spans();
                }
            }
        }
        
        pub mod location
        {
            use ::
            {
                cmp::{ Ordering },
                *,
            };
            /*
            */
            /// A line-column pair representing the start or end of a `Span`.
            #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
            pub struct LineColumn 
            {
                /// The 1-indexed line in the source file on which the span starts or ends (inclusive).
                pub line: usize,
                /// The 0-indexed column (in UT8) in the source file on which the span starts or ends (inclusive).
                pub column: usize,
            }

            impl Ord for LineColumn
            {
                fn cmp( &self, other: &Self) -> Ordering
                {
                    self.line
                    .cmp(&other.line)
                    .then(self.column.cmp(&other.column))
                }
            }

            impl PartialOrd for LineColumn
            {
                fn partial_cmp( &self, other: &Self) -> Option<Ordering>
                {
                    Some(self.cmp(other))
                }
            }
        }
        /**
        A wrapper around the procedural macro API of the compiler's [`proc_macro`] crate.*/
        pub mod parse
        {
            use ::
            {
                process::
                {
                    macros::
                    {
                        fallback::
                        {
                            self, Group, Ident, LexError, Literal, Span, TokenStream, TokenStreamBuilder,
                        },
                        Delimiter, Punct, Spacing, TokenTree,
                    },
                },
                str::{ Bytes, CharIndices, Chars },
                *,
            };
            /*
            */
            /// Rustc's representation of a macro expansion error in expression position or type position.
            pub const ERROR: &str = "(/*ERROR*/)";

            pub type PResult<'a, O> = Result<(Cursor<'a>, O), Reject>;

            #[derive(Copy, Clone, Eq, PartialEq)]
            pub struct Cursor<'a> 
            {
                pub rest: &'a str,
                    pub off: u32,
            }

            impl<'a> Cursor<'a>
            {
                pub fn advance( &self, bytes: usize) -> Cursor<'a>
                {
                    let (_front, rest) = self.rest.split_at(bytes);
                    Cursor {
                        rest,
                                    off: self.off + _front.chars().count() as u32,
                    }
                }

                pub fn starts_with( &self, s: &str) -> bool
        {
                    self.rest.starts_with(s)
                }

                pub fn starts_with_char( &self, ch: char) -> bool
        {
                    self.rest.starts_with(ch)
                }

                pub fn starts_with_fn<Pattern>( &self, f: Pattern) -> bool
                where
                    Pattern: FnMut(char) -> bool,
                {
                    self.rest.starts_with(f)
                }

                pub fn is_empty( &self ) -> bool
        {
                    self.rest.is_empty()
                }

                fn len( &self ) -> usize {
                    self.rest.len()
                }

                fn as_bytes( &self ) -> &'a [u8] {
                    self.rest.as_bytes()
                }

                fn bytes( &self ) -> Bytes<'a>
                    {
                    self.rest.bytes()
                }

                fn chars( &self ) -> Chars<'a>
                    {
                    self.rest.chars()
                }

                fn char_indices( &self ) -> CharIndices<'a>
                    {
                    self.rest.char_indices()
                }

                fn parse( &self, tag: &str) -> Result<Cursor<'a>, Reject>
                    {
                    if self.starts_with(tag) {
                        Ok(self.advance(tag.len()))
                    } else {
                        Err(Reject)
                    }
                }
            }

            pub struct Reject;
            
            fn skip_whitespace(input: Cursor) -> Cursor
            {
                let mut s = input;

                while !s.is_empty()
               
                {
                    let byte = s.as_bytes()[0];
                    
                    if byte == b'/'
                    {
                        if s.starts_with("//")
                            && (!s.starts_with("///") || s.starts_with("////"))
                            && !s.starts_with("//!")
                        {
                            let (cursor, _) = take_until_newline_or_eof(s);
                            s = cursor;
                            continue;
                        } else if s.starts_with("/**/") {
                            s = s.advance(4);
                            continue;
                        } else if s.starts_with("/*")
                            && (!s.starts_with("/**") || s.starts_with("/***"))
                            && !s.starts_with("/*!")
                        {
                            match block_comment(s) {
                                Ok((rest, _)) =>
                    {
                                    s = rest;
                                    continue;
                                }
                                Err(Reject) => return s,
                            }
                        }
                    }
                    
                    match byte
                    {
                        b' ' | 0x09..=0x0d =>
                        {
                            s = s.advance(1);
                            continue;
                        }

                        b if b.is_ascii() =>
                    {}
                        _ =>
                        {
                            let ch = s.chars().next().unwrap();

                            if is::whitespace(ch)
                            {
                                s = s.advance(ch.len_utf8());
                                continue;
                            }
                        }
                    }
                    return s;
                }
                s
            }

            fn block_comment(input: Cursor<'_>) -> PResult<'_, &str>
            {
                if !input.starts_with("/*") {
                    return Err(Reject);
                }

                let mut depth = 0usize;
                let bytes = input.as_bytes();
                let mut i = 0usize;
                let upper = bytes.len() - 1;

                while i < upper {
                    if bytes[i] == b'/' && bytes[i + 1] == b'*' {
                        depth += 1;
                        i += 1;
                    } else if bytes[i] == b'*' && bytes[i + 1] == b'/' {
                        depth -= 1;
                        if depth == 0 {
                            return Ok((input.advance(i + 2), &input.rest[..i + 2]));
                        }
                        i += 1;
                    }
                    i += 1;
                }

                Err(Reject)
            }

            fn word_break(input: Cursor) -> Result<Cursor, Reject>
            {
                match input.chars().next() {
                    Some(ch) if is::ident_continue(ch) => Err(Reject),
                    Some(_) | None => Ok(input),
                }
            }

            pub fn token_stream(mut input: Cursor) -> Result<TokenStream, LexError>
            {
                let mut trees = TokenStreamBuilder::new();
                let mut stack = Vec::new();

                loop {
                    input = skip_whitespace(input);

                    if let Ok((rest, ())) = doc_comment(input, &mut trees) {
                        input = rest;
                        continue;
                    }

                            let lo = input.off;

                    let first = match input.bytes().next() {
                        Some(first) => first,
                        None => match stack.last() {
                            None => return Ok(trees.build()),
                                            Some((lo, _frame)) =>
                    {
                                return Err(LexError {
                                    span: Span { lo: *lo, hi: *lo },
                                })
                            }
                        },
                    };

                    if let Some(open_delimiter) = match first {
                        b'(' if !input.starts_with(ERROR) => Some(Delimiter::Parenthesis),
                        b'[' => Some(Delimiter::Bracket),
                        b'{' => Some(Delimiter::Brace),
                        _ => None,
                    } {
                        input = input.advance(1);
                        let frame = (open_delimiter, trees);
                                    let frame = (lo, frame);
                        stack.push(frame);
                        trees = TokenStreamBuilder::new();
                    } else if let Some(close_delimiter) = match first {
                        b')' => Some(Delimiter::Parenthesis),
                        b']' => Some(Delimiter::Bracket),
                        b'}' => Some(Delimiter::Brace),
                        _ => None,
                    } {
                        let frame = match stack.pop() {
                            Some(frame) => frame,
                            None => return Err(lex_error(input)),
                        };
                                    let (lo, frame) = frame;
                        let (open_delimiter, outer) = frame;
                        if open_delimiter != close_delimiter {
                            return Err(lex_error(input));
                        }
                        input = input.advance(1);
                        let mut g = Group::new(open_delimiter, trees.build());
                        g.set_span(Span {
                                            lo,
                                            hi: input.off,
                        });
                        trees = outer;
                        trees.push_token_from_parser(TokenTree::Group(::process::macros::Group::_new_fallback(g)));
                    } else {
                        let (rest, mut tt) = match leaf_token(input) {
                            Ok((rest, tt)) => (rest, tt),
                            Err(Reject) => return Err(lex_error(input)),
                        };
                        tt.set_span(::process::macros::Span::_new_fallback(Span {
                                            lo,
                                            hi: rest.off,
                        }));
                        trees.push_token_from_parser(tt);
                        input = rest;
                    }
                }
            }

            fn lex_error(cursor: Cursor) -> LexError
            {
                LexError
                {
                    span: Span
                    {
                        lo:cursor.off,
                        hi:cursor.off,
                    },
                }
            }

            fn leaf_token(input: Cursor) -> PResult<TokenTree>
            {
                if let Ok((input, l)) = literal(input) {
                   
                    Ok((input, TokenTree::Literal(::process::macros::Literal::_new_fallback(l))))
                } else if let Ok((input, p)) = punct(input) {
                    Ok((input, TokenTree::Punct(p)))
                } else if let Ok((input, i)) = ident(input) {
                    Ok((input, TokenTree::Ident(i)))
                } else if input.starts_with(ERROR)
                {
                    let rest = input.advance(ERROR.len());
                    let repr = ::process::macros::Literal::_new_fallback(Literal::_new(ERROR.to_owned()));
                    Ok((rest, TokenTree::Literal(repr)))
                } else {
                    Err(Reject)
                }
            }

            fn ident(input: Cursor) -> PResult<::process::macros::Ident>
            {
                if [
                    "r\"", "r#\"", "r##", "b\"", "b\'", "br\"", "br#", "c\"", "cr\"", "cr#",
                ]
                .iter()
                .any(|prefix| input.starts_with(prefix))
                {
                    Err(Reject)
                } else {
                    ident_any(input)
                }
            }

            fn ident_any(input: Cursor) -> PResult<::process::macros::Ident>
            {
                let raw = input.starts_with("r#");
                let rest = input.advance((raw as usize) << 1);

                let (rest, sym) = ident_not_raw(rest)?;

                if !raw
                {
                    let ident =
                        ::process::macros::Ident::_new_fallback(Ident::new_unchecked(sym, fallback::Span::call_site()));
                    return Ok((rest, ident));
                }

                match sym {
                    "_" | "super" | "self" | "Self" | "crate" => return Err(Reject),
                    _ =>
                    {}
                }

                let ident =
                    ::process::macros::Ident::_new_fallback(Ident::new_raw_unchecked(sym, fallback::Span::call_site()));
                Ok((rest, ident))
            }

            fn ident_not_raw(input: Cursor<'_>) -> PResult<'_, &str>
            {
                let mut chars = input.char_indices();

                match chars.next() {
                    Some((_, ch)) if is::ident_start(ch) =>
                    {}
                    _ => return Err(Reject),
                }

                let mut end = input.len();
                for (i, ch) in chars {
                    if !is::ident_continue(ch) {
                        end = i;
                        break;
                    }
                }

                Ok((input.advance(end), &input.rest[..end]))
            }

            pub fn literal(input: Cursor) -> PResult<Literal>
            {
                let rest = literal_nocapture(input)?;
                let end = input.len() - rest.len();
                Ok((rest, Literal::_new(input.rest[..end].to_string())))
            }

            fn literal_nocapture(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(ok) = string(input) {
                    Ok(ok)
                } else if let Ok(ok) = byte_string(input) {
                    Ok(ok)
                } else if let Ok(ok) = c_string(input) {
                    Ok(ok)
                } else if let Ok(ok) = byte(input) {
                    Ok(ok)
                } else if let Ok(ok) = character(input) {
                    Ok(ok)
                } else if let Ok(ok) = float(input) {
                    Ok(ok)
                } else if let Ok(ok) = int(input) {
                    Ok(ok)
                } else {
                    Err(Reject)
                }
            }

            fn literal_suffix(input: Cursor) -> Cursor
            {
                match ident_not_raw(input) {
                    Ok((input, _)) => input,
                    Err(Reject) => input,
                }
            }

            fn string(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(input) = input.parse("\"") {
                    cooked_string(input)
                } else if let Ok(input) = input.parse("r") {
                    raw_string(input)
                } else {
                    Err(Reject)
                }
            }

            fn cooked_string(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let mut chars = input.char_indices();

                while let Some((i, ch)) = chars.next( )
                {
                    match ch {
                        '"' =>
                    {
                            let input = input.advance(i + 1);
                            return Ok(literal_suffix(input));
                        }
                        '\r' => match chars.next() {
                            Some((_, '\n')) =>
                    {}
                            _ => break,
                        },
                        '\\' => match chars.next() {
                            Some((_, 'x')) =>
                    {
                                backslash_x_char(&mut chars)?;
                            }
                            Some((_, 'n' | 'r' | 't' | '\\' | '\'' | '"' | '0')) =>
                    {}
                            Some((_, 'u')) =>
                    {
                                backslash_u(&mut chars)?;
                            }
                            Some((newline, ch @ ('\n' | '\r'))) =>
                    {
                                input = input.advance(newline + 1);
                                trailing_backslash(&mut input, ch as u8)?;
                                chars = input.char_indices();
                            }
                            _ => break,
                        },
                        _ch =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn raw_string(input: Cursor) -> Result<Cursor, Reject>
            {
                let (input, delimiter) = delimiter_of_raw_string(input)?;
                let mut bytes = input.bytes().enumerate();
                while let Some((i, byte)) = bytes.next( )
                {
                    match byte {
                        b'"' if input.rest[i + 1..].starts_with(delimiter) =>
                    {
                            let rest = input.advance(i + 1 + delimiter.len());
                            return Ok(literal_suffix(rest));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        _ =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn byte_string(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(input) = input.parse("b\"") {
                    cooked_byte_string(input)
                } else if let Ok(input) = input.parse("br") {
                    raw_byte_string(input)
                } else {
                    Err(Reject)
                }
            }

            fn cooked_byte_string(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let mut bytes = input.bytes().enumerate();
                while let Some((offset, b)) = bytes.next( )
                {
                    match b {
                        b'"' =>
                    {
                            let input = input.advance(offset + 1);
                            return Ok(literal_suffix(input));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        b'\\' => match bytes.next() {
                            Some((_, b'x')) =>
                    {
                                backslash_x_byte(&mut bytes)?;
                            }
                            Some((_, b'n' | b'r' | b't' | b'\\' | b'0' | b'\'' | b'"')) =>
                    {}
                            Some((newline, b @ (b'\n' | b'\r'))) =>
                    {
                                input = input.advance(newline + 1);
                                trailing_backslash(&mut input, b)?;
                                bytes = input.bytes().enumerate();
                            }
                            _ => break,
                        },
                        b if b.is_ascii() =>
                    {}
                        _ => break,
                    }
                }
                Err(Reject)
            }

            fn delimiter_of_raw_string(input: Cursor<'_>) -> PResult<'_, &str>
            {
                for (i, byte) in input.bytes().enumerate( )
                {
                    match byte {
                        b'"' =>
                    {
                            if i > 255 {
                               
                                return Err(Reject);
                            }
                            return Ok((input.advance(i + 1), &input.rest[..i]));
                        }
                        b'#' =>
                    {}
                        _ => break,
                    }
                }
                Err(Reject)
            }

            fn raw_byte_string(input: Cursor) -> Result<Cursor, Reject>
            {
                let (input, delimiter) = delimiter_of_raw_string(input)?;
                let mut bytes = input.bytes().enumerate();
                while let Some((i, byte)) = bytes.next( )
                {
                    match byte {
                        b'"' if input.rest[i + 1..].starts_with(delimiter) =>
                    {
                            let rest = input.advance(i + 1 + delimiter.len());
                            return Ok(literal_suffix(rest));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        other =>
                    {
                            if !other.is_ascii() {
                                break;
                            }
                        }
                    }
                }
                Err(Reject)
            }

            fn c_string(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(input) = input.parse("c\"") {
                    cooked_c_string(input)
                } else if let Ok(input) = input.parse("cr") {
                    raw_c_string(input)
                } else {
                    Err(Reject)
                }
            }

            fn raw_c_string(input: Cursor) -> Result<Cursor, Reject>
            {
                let (input, delimiter) = delimiter_of_raw_string(input)?;
                let mut bytes = input.bytes().enumerate();
                while let Some((i, byte)) = bytes.next( )
                {
                    match byte {
                        b'"' if input.rest[i + 1..].starts_with(delimiter) =>
                    {
                            let rest = input.advance(i + 1 + delimiter.len());
                            return Ok(literal_suffix(rest));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        b'\0' => break,
                        _ =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn cooked_c_string(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let mut chars = input.char_indices();

                while let Some((i, ch)) = chars.next( )
                {
                    match ch {
                        '"' =>
                    {
                            let input = input.advance(i + 1);
                            return Ok(literal_suffix(input));
                        }
                        '\r' => match chars.next() {
                            Some((_, '\n')) =>
                    {}
                            _ => break,
                        },
                        '\\' => match chars.next() {
                            Some((_, 'x')) =>
                    {
                                backslash_x_nonzero(&mut chars)?;
                            }
                            Some((_, 'n' | 'r' | 't' | '\\' | '\'' | '"')) =>
                    {}
                            Some((_, 'u')) =>
                    {
                                if backslash_u(&mut chars)? == '\0' {
                                    break;
                                }
                            }
                            Some((newline, ch @ ('\n' | '\r'))) =>
                    {
                                input = input.advance(newline + 1);
                                trailing_backslash(&mut input, ch as u8)?;
                                chars = input.char_indices();
                            }
                            _ => break,
                        },
                        '\0' => break,
                        _ch =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn byte(input: Cursor) -> Result<Cursor, Reject>
            {
                let input = input.parse("b'")?;
                let mut bytes = input.bytes().enumerate();
                let ok = match bytes.next().map(|(_, b)| b) {
                    Some(b'\\') => match bytes.next().map(|(_, b)| b) {
                        Some(b'x') => backslash_x_byte(&mut bytes).is_ok(),
                        Some(b'n' | b'r' | b't' | b'\\' | b'0' | b'\'' | b'"') => true,
                        _ => false,
                    },
                    b => b.is_some(),
                };
                if !ok {
                    return Err(Reject);
                }
                let (offset, _) = bytes.next().ok_or(Reject)?;
                if !input.chars().as_str().is_char_boundary(offset) {
                    return Err(Reject);
                }
                let input = input.advance(offset).parse("'")?;
                Ok(literal_suffix(input))
            }

            fn character(input: Cursor) -> Result<Cursor, Reject>
            {
                let input = input.parse("'")?;
                let mut chars = input.char_indices();
                let ok = match chars.next().map(|(_, ch)| ch) {
                    Some('\\') => match chars.next().map(|(_, ch)| ch) {
                        Some('x') => backslash_x_char(&mut chars).is_ok(),
                        Some('u') => backslash_u(&mut chars).is_ok(),
                        Some('n' | 'r' | 't' | '\\' | '0' | '\'' | '"') => true,
                        _ => false,
                    },
                    ch => ch.is_some(),
                };
                if !ok {
                    return Err(Reject);
                }
                let (idx, _) = chars.next().ok_or(Reject)?;
                let input = input.advance(idx).parse("'")?;
                Ok(literal_suffix(input))
            }
            
            fn backslash_x_char<I>(chars: &mut I) -> Result<(), Reject> where
            I: Iterator<Item = (usize, char)>,
            {
                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='7' => ch,
                        _ => return Err(Reject),
                    },
                    None => todo!(),
                };

                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='9' | 'a'..='f' | 'A'..='F' => ch,
                        _ => return Err(Reject),
                    },
                    None => todo!(),
                };

                Ok(())
            } 

            fn backslash_x_byte<I>(chars: &mut I) -> Result<(), Reject> where
            I: Iterator<Item = (usize, u8)>,
            {
                /*
                ($chars:ident @ $pat:pat) =>
                {
                    match $chars.next()
                    {
                        Some((_, ch)) => match ch
                        {
                            $pat => ch,
                            _ => return Err(Reject),
                        },
                        None => return Err(Reject),
                    }
                };
                */
                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };

                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };

                Ok(())
            }

            fn backslash_x_nonzero<I>(chars: &mut I) -> Result<(), Reject> where
            I: Iterator<Item = (usize, char)>,
            {
                let first = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='9' | 'a'..='f' | 'A'..='F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };
                
                let second = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='9' | 'a'..='f' | 'A'..='F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };
                
                if first == '0' && second == '0' {
                    Err(Reject)
                } else {
                    Ok(())
                }
            }

            fn backslash_u<I>(chars: &mut I) -> Result<char, Reject> where
            I: Iterator<Item = (usize, char)>,
            {
                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '{' => ch,
                        _ => return Err(Reject),
                    },
                    None => todo!(),
                };

                let mut value = 0;
                let mut len = 0;
                for (_, ch) in chars
                {
                    let digit = match ch {
                        '0'..='9' => ch as u8 - b'0',
                        'a'..='f' => 10 + ch as u8 - b'a',
                        'A'..='F' => 10 + ch as u8 - b'A',
                        '_' if len > 0 => continue,
                        '}' if len > 0 => return char::from_u32(value).ok_or(Reject),
                        _ => break,
                    };
                    if len == 6 {
                        break;
                    }
                    value *= 0x10;
                    value += u32::from(digit);
                    len += 1;
                }
                Err(Reject)
            }

            fn trailing_backslash(input: &mut Cursor, mut last: u8) -> Result<(), Reject>
            {
                let mut whitespace = input.bytes().enumerate();
                loop {
                    if last == b'\r' && whitespace.next().map_or(true, |(_, b)| b != b'\n') {
                        return Err(Reject);
                    }
                    match whitespace.next() {
                        Some((_, b @ (b' ' | b'\t' | b'\n' | b'\r'))) =>
                    {
                            last = b;
                        }
                        Some((offset, _)) =>
                    {
                            *input = input.advance(offset);
                            return Ok(());
                        }
                        None => return Err(Reject),
                    }
                }
            }

            fn float(input: Cursor) -> Result<Cursor, Reject>
            {
                let mut rest = float_digits(input)?;
                if let Some(ch) = rest.chars().next() {
                    if is::ident_start(ch) {
                        rest = ident_not_raw(rest)?.0;
                    }
                }
                word_break(rest)
            }

            fn float_digits(input: Cursor) -> Result<Cursor, Reject>
            {
                let mut chars = input.chars().peekable();
                match chars.next() {
                    Some(ch) if '0' <= ch && ch <= '9' =>
                    {}
                    _ => return Err(Reject),
                }

                let mut len = 1;
                let mut has_dot = false;
                let mut has_exp = false;
                while let Some(&ch) = chars.peek( )
                {
                    match ch {
                        '0'..='9' | '_' =>
                    {
                            chars.next();
                            len += 1;
                        }
                        '.' =>
                    {
                            if has_dot {
                                break;
                            }
                            chars.next();
                            if chars
                                .peek()
                                .map_or(false, |&ch| ch == '.' || is::ident_start(ch))
                            {
                                return Err(Reject);
                            }
                            len += 1;
                            has_dot = true;
                        }
                        'e' | 'E' =>
                    {
                            chars.next();
                            len += 1;
                            has_exp = true;
                            break;
                        }
                        _ => break,
                    }
                }

                if !(has_dot || has_exp) {
                    return Err(Reject);
                }

                if has_exp
                {
                    let token_before_exp = if has_dot {
                        Ok(input.advance(len - 1))
                    } else {
                        Err(Reject)
                    };
                    let mut has_sign = false;
                    let mut has_exp_value = false;
                    while let Some(&ch) = chars.peek() {
                        match ch {
                            '+' | '-' =>
                    {
                                if has_exp_value {
                                    break;
                                }
                                if has_sign {
                                    return token_before_exp;
                                }
                                chars.next();
                                len += 1;
                                has_sign = true;
                            }
                            '0'..='9' =>
                    {
                                chars.next();
                                len += 1;
                                has_exp_value = true;
                            }
                            '_' =>
                    {
                                chars.next();
                                len += 1;
                            }
                            _ => break,
                        }
                    }
                    if !has_exp_value {
                        return token_before_exp;
                    }
                }

                Ok(input.advance(len))
            }

            fn int(input: Cursor) -> Result<Cursor, Reject>
            {
                let mut rest = digits(input)?;
                if let Some(ch) = rest.chars().next() {
                    if is::ident_start(ch) {
                        rest = ident_not_raw(rest)?.0;
                    }
                }
                word_break(rest)
            }

            fn digits(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let base = if input.starts_with("0x") {
                    input = input.advance(2);
                    16
                } else if input.starts_with("0o") {
                    input = input.advance(2);
                    8
                } else if input.starts_with("0b") {
                    input = input.advance(2);
                    2
                } else {
                    10
                };

                let mut len = 0;
                let mut empty = true;
                for b in input.bytes( )
                {
                    match b {
                        b'0'..=b'9' =>
                    {
                            let digit = (b - b'0') as u64;
                            if digit >= base {
                                return Err(Reject);
                            }
                        }
                        b'a'..=b'f' =>
                    {
                            let digit = 10 + (b - b'a') as u64;
                            if digit >= base {
                                break;
                            }
                        }
                        b'A'..=b'F' =>
                    {
                            let digit = 10 + (b - b'A') as u64;
                            if digit >= base {
                                break;
                            }
                        }
                        b'_' =>
                    {
                            if empty && base == 10 {
                                return Err(Reject);
                            }
                            len += 1;
                            continue;
                        }
                        _ => break,
                    }
                    len += 1;
                    empty = false;
                }
                if empty {
                    Err(Reject)
                } else {
                    Ok(input.advance(len))
                }
            }

            fn punct(input: Cursor) -> PResult<Punct>
            {
                let (rest, ch) = punct_char(input)?;
                if ch == '\''
                {
                    let (after_lifetime, _ident) = ident_any(rest)?;
                    if after_lifetime.starts_with_char('\'')
                        || (after_lifetime.starts_with_char('#') && !rest.starts_with("r#"))
                    {
                        Err(Reject)
                    } else {
                        Ok((rest, Punct::new('\'', Spacing::Joint)))
                    }
                } else
                {
                    let kind = match punct_char(rest) {
                        Ok(_) => Spacing::Joint,
                        Err(Reject) => Spacing::Alone,
                    };
                    Ok((rest, Punct::new(ch, kind)))
                }
            }

            fn punct_char(input: Cursor) -> PResult<char>
            {
                if input.starts_with("//") || input.starts_with("/*") {
                   
                    return Err(Reject);
                }

                let mut chars = input.chars();
                let first = match chars.next() {
                    Some(ch) => ch,
                    None =>
                    {
                        return Err(Reject);
                    }
                };
                let recognized = "~!@#$%^&*-=+|;:,<.>/?'";
                if recognized.contains(first) {
                    Ok((input.advance(first.len_utf8()), first))
                } else {
                    Err(Reject)
                }
            }

            fn doc_comment<'a>(input: Cursor<'a>, trees: &mut TokenStreamBuilder) -> PResult<'a, ()>
            {
                let lo = input.off;
                let (rest, (comment, inner)) = doc_comment_contents(input)?;
                let fallback_span = Span {
                            lo,
                            hi: rest.off,
                };
                let span = ::process::macros::Span::_new_fallback(fallback_span);

                let mut scan_for_bare_cr = comment;
                while let Some(cr) = scan_for_bare_cr.find('\r')
                {
                    let rest = &scan_for_bare_cr[cr + 1..];
                    if !rest.starts_with('\n') {
                        return Err(Reject);
                    }
                    scan_for_bare_cr = rest;
                }

                let mut pound = Punct::new('#', Spacing::Alone);
                pound.set_span(span);
                trees.push_token_from_parser(TokenTree::Punct(pound));

                if inner
                {
                    let mut bang = Punct::new('!', Spacing::Alone);
                    bang.set_span(span);
                    trees.push_token_from_parser(TokenTree::Punct(bang));
                }

                let doc_ident = ::process::macros::Ident::_new_fallback(Ident::new_unchecked("doc", fallback_span));
                let mut equal = Punct::new('=', Spacing::Alone);
                equal.set_span(span);
                let mut literal = ::process::macros::Literal::_new_fallback(Literal::string(comment));
                literal.set_span(span);
                let mut bracketed = TokenStreamBuilder::with_capacity(3);
                bracketed.push_token_from_parser(TokenTree::Ident(doc_ident));
                bracketed.push_token_from_parser(TokenTree::Punct(equal));
                bracketed.push_token_from_parser(TokenTree::Literal(literal));
                let group = Group::new(Delimiter::Bracket, bracketed.build());
                let mut group = ::process::macros::Group::_new_fallback(group);
                group.set_span(span);
                trees.push_token_from_parser(TokenTree::Group(group));

                Ok((rest, ()))
            }

            fn doc_comment_contents(input: Cursor<'_>) -> PResult<'_, (&str, bool)>
            {
                if input.starts_with("//!")
                {
                    let input = input.advance(3);
                    let (input, s) = take_until_newline_or_eof(input);
                    Ok((input, (s, true)))
                } else if input.starts_with("/*!")
                {
                    let (input, s) = block_comment(input)?;
                    Ok((input, (&s[3..s.len() - 2], true)))
                } else if input.starts_with("///")
                {
                    let input = input.advance(3);
                    if input.starts_with_char('/') {
                        return Err(Reject);
                    }
                    let (input, s) = take_until_newline_or_eof(input);
                    Ok((input, (s, false)))
                } else if input.starts_with("/**") && !input.rest[3..].starts_with('*')
                {
                    let (input, s) = block_comment(input)?;
                    Ok((input, (&s[3..s.len() - 2], false)))
                } else {
                    Err(Reject)
                }
            }

            fn take_until_newline_or_eof(input: Cursor<'_>) -> (Cursor<'_>, &str) 
            {
                let chars = input.char_indices();

                for (i, ch) in chars {
                    if ch == '\n' {
                        return (input.advance(i), &input.rest[..i]);
                    } else if ch == '\r' && input.rest[i + 1..].starts_with('\n') {
                        return (input.advance(i + 1), &input.rest[..i]);
                    }
                }

                (input.advance(input.len()), input.rest)
            }
        }

        pub mod probe
        {
            use ::
            {
                *,
            };
            /*
            */
            pub mod proc_macro_span
            {
                use ::
                {
                    ops::{ Range, RangeBounds },
                    path::{ PathBuf },
                    proc_macro::{ Literal, Span },
                    *,
                };
                /*
                */
                pub fn byte_range(this: &Span) -> Range<usize>
                {
                    //this.byte_range()
                    Range { start: 0, end: 0 }
                }
                pub fn start(this: &Span) -> Span { this.start() }
                pub fn end(this: &Span) -> Span { this.end() }
                pub fn line(this: &Span) -> usize { this.line() }
                pub fn column(this: &Span) -> usize { this.column() }
                pub fn file(this: &Span) -> String { this.file() }
                pub fn local_file(this: &Span) -> Option<PathBuf>
                    { this.local_file() }
                pub fn join(this: &Span, other: Span) -> Option<Span> 
                {
                    //this.join(other)
                    None
                }
                pub fn subspan<R:RangeBounds<usize>>( this:&Literal, range:R ) -> Option<Span>
                {
                    //this.subspan( range )
                    None
                }
                /*
               
                #[cfg(procmacro2_build_probe)] */
                const _: Option<&str> = option_env!("RUSTC_BOOTSTRAP");
            }
            
            pub mod proc_macro_span_file
            {
                use ::
                {
                    path::PathBuf,
                    proc_macro::Span,
                    *,
                };
                /*
                */
                pub fn file(this: &Span) -> String {
                    this.file()
                }

                pub fn local_file(this: &Span) -> Option<PathBuf>
                    {
                    this.local_file()
                }
            }
            
            pub mod proc_macro_span_location
            {
                use ::
                {
                    proc_macro::Span,
                    *,
                };
                /*
                */
                pub fn start(this: &Span) -> Span { this.start() }
                pub fn end(this: &Span) -> Span { this.end() }
                pub fn line(this: &Span) -> usize { this.line() }
                pub fn column(this: &Span) -> usize { this.column() }
            }
            
        }

        pub mod rcvec
        {
            use ::
            {
                rc::{ Rc },
                panic::{ RefUnwindSafe },
                *,
            };
            /*
            use alloc::rc::Rc;
            use alloc::vec;
            use core::mem;
            use core::panic::RefUnwindSafe;
            use core::slice;
            */
            pub struct RcVec<T>
            {
                inner: rc::Rc<Vec<T>>,
            }

            pub struct RcVecBuilder<T>
            {
                inner: Vec<T>,
            }

            pub struct RcVecMut<'a, T>
            {
                inner: &'a mut Vec<T>,
            }

            #[derive(Clone)]
            pub struct RcVecIntoIter<T>
            {
                inner: vec::IntoIter<T>,
            }

            impl<T> RcVec<T>
            {
                pub fn is_empty( &self ) -> bool 
                {
                    self.inner.is_empty()
                }

                pub fn len( &self ) -> usize 
                {
                    self.inner.len()
                }

                pub fn iter( &self ) -> slice::Iter<'_, T>
                {
                    self.inner.iter()
                }

                pub fn make_mut( &mut self ) -> RcVecMut<'_, T> where
                T: Clone,
                {
                    RcVecMut {
                        inner: rc::Rc::make_mut(&mut self.inner),
                    }
                }

                pub fn get_mut( &mut self ) -> Option<RcVecMut<'_, T>>
               
                {
                    let inner = rc::Rc::get_mut(&mut self.inner)?;
                    Some(RcVecMut { inner })
                }

                pub fn make_owned(mut self) -> RcVecBuilder<T> where
                T: Clone,
               
                {
                    let vec = if let Some(owned) = rc::Rc::get_mut(&mut self.inner) {
                        mem::take(owned)
                    } else {
                        Vec::clone(&self.inner)
                    };
                    RcVecBuilder { inner: vec }
                }
            }

            impl<T> RcVecBuilder<T>
            {
                pub fn new() -> Self {
                    RcVecBuilder { inner: Vec::new() }
                }

                pub fn with_capacity(cap: usize) -> Self {
                    RcVecBuilder {
                        inner: Vec::with_capacity(cap),
                    }
                }

                pub fn push(&mut self, element: T) {
                    self.inner.push(element);
                }

                pub fn extend(&mut self, iter: impl IntoIterator<Item = T>) {
                    self.inner.extend(iter);
                }

                pub fn as_mut( &mut self ) -> RcVecMut<'_, T>
                {
                    RcVecMut {
                        inner: &mut self.inner,
                    }
                }

                pub fn build( self ) -> RcVec<T>
                    {
                    RcVec {
                        inner: rc::Rc::new(self.inner),
                    }
                }
            }

            impl<'a, T> RcVecMut<'a, T>
            {
                pub fn push(&mut self, element: T) {
                    self.inner.push(element);
                }

                pub fn extend(&mut self, iter: impl IntoIterator<Item = T>) {
                    self.inner.extend(iter);
                }

                pub fn as_mut( &mut self ) -> RcVecMut<'_, T> 
                {
                    RcVecMut { inner: self.inner }
                }

                pub fn take( self ) -> RcVecBuilder<T>
                {
                    let vec = mem::take(self.inner);
                    RcVecBuilder { inner: vec }
                }
            }

            impl<T> Clone for RcVec<T>           
            {
                fn clone( &self ) -> Self
                {
                    RcVec {
                        inner: rc::Rc::clone(&self.inner),
                    }
                }
            }

            impl<T> IntoIterator for RcVecBuilder<T>
            {
                type Item = T;
                type IntoIter = RcVecIntoIter<T>;
                fn into_iter( self ) -> Self::IntoIter
                {
                    RcVecIntoIter
                    {
                        inner: self.inner.into_iter(),
                    }
                }
            }

            impl<T> Iterator for RcVecIntoIter<T>
            {
                type Item = T;
                fn next( &mut self ) -> Option<Self::Item>
                    { self.inner.next() }
                
                fn size_hint( &self ) -> (usize, Option<usize>) { self.inner.size_hint() }
            }

            impl<T> RefUnwindSafe for RcVec<T> where
            T:RefUnwindSafe
            {}
        }
        /// Public implementation details for the `TokenStream` type, such as iterators.
        pub mod token_stream 
        {
            use ::
            {
                fmt::{ self, Debug },
                marker::{ ProcMacroAutoTraits, MARKER },
                process::macros::
                {
                    imp, TokenStream, TokenTree
                },
                *,
            };
            /// An iterator over `TokenStream`'s `TokenTree`s.
            #[derive(Clone)]
            pub struct IntoIter
            {
                inner: imp::TokenTreeIter,
                _marker: ProcMacroAutoTraits,
            }

            impl Iterator for IntoIter
            {
                type Item = TokenTree;
                fn next( &mut self ) -> Option<TokenTree>
                {
                    self.inner.next()
                }

                fn size_hint( &self ) -> (usize, Option<usize>)
                {
                    self.inner.size_hint()
                }
            }

            impl Debug for IntoIter
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    f.write_str("TokenStream ")?;
                    f.debug_list().entries(self.clone()).finish()
                }
            }

            impl IntoIterator for TokenStream
            {
                type Item = TokenTree;
                type IntoIter = IntoIter;
                fn into_iter( self ) -> IntoIter
                {
                    IntoIter {
                        inner: self.inner.into_iter(),
                        _marker: ::marker::MARKER,
                    }
                }
            }
        }
        /// An abstract stream of tokens, or more concretely a sequence of token trees
        #[derive(Clone)]
        pub struct TokenStream
        {
            inner: imp::TokenStream,
            _marker: ::marker::ProcMacroAutoTraits,
        }
        /// Error returned from `TokenStream::from_str`.
        pub struct LexError
        {
            inner: imp::LexError,
            _marker: ::marker::ProcMacroAutoTraits,
        }

        impl TokenStream       
        {
            fn _new(inner: imp::TokenStream) -> Self {
                TokenStream {
                    inner,
                    _marker: marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::TokenStream) -> Self {
                TokenStream {
                    inner: imp::TokenStream::from(inner),
                    _marker: marker::MARKER,
                }
            }
            /// Returns an empty `TokenStream` containing no token trees.
            pub fn new() -> Self {
                TokenStream::_new(imp::TokenStream::new())
            }
            /// Checks if this `TokenStream` is empty.
            pub fn is_empty( &self ) -> bool           
            {
                self.inner.is_empty()
            }
        }
        /// `TokenStream::default()` returns an empty stream, equivalent with `TokenStream::new()`.
        impl Default for TokenStream       
        {
            fn default() -> Self {
                TokenStream::new()
            }
        }
        /// Attempts to break the string into tokens and parse those tokens into a token stream.
        impl str::FromStr for TokenStream
        {
            type Err = LexError;
            fn from_str(src: &str) -> Result<TokenStream, LexError>
            {
                match imp::TokenStream::from_str_checked(src) {
                    Ok(tokens) => Ok(TokenStream::_new(tokens)),
                    Err(lex) => Err(LexError {
                        inner: lex,
                        _marker: marker::MARKER,
                    }),
                }
            }
        }
        
        impl From<proc_macro::TokenStream> for TokenStream       
        {
            fn from(inner: proc_macro::TokenStream) -> Self {
                TokenStream::_new(imp::TokenStream::from(inner))
            }
        }
        
        impl From<TokenStream> for proc_macro::TokenStream       
        {
            fn from(inner: TokenStream) -> Self {
                proc_macro::TokenStream::from(inner.inner)
            }
        }

        impl From<TokenTree> for TokenStream       
        {
            fn from(token: TokenTree) -> Self {
                TokenStream::_new(imp::TokenStream::from(token))
            }
        }

        impl Extend<TokenTree> for TokenStream       
        {
            fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, streams: I)
            {
                self.inner.extend(streams);
            }
        }

        impl Extend<TokenStream> for TokenStream       
        {
            fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I)
            {
                self.inner
                    .extend(streams.into_iter().map(|stream| stream.inner));
            }
        }
        /// Collects a number of token trees into a single stream.
        impl iter::FromIterator<TokenTree> for TokenStream       
        {
            fn from_iter<I: IntoIterator<Item = TokenTree>>(streams: I) -> Self {
                TokenStream::_new(streams.into_iter().collect())
            }
        }
        impl iter::FromIterator<TokenStream> for TokenStream       
        {
            fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {
                TokenStream::_new(streams.into_iter().map(|i| i.inner).collect())
            }
        }
        /// Prints the token stream as a string that is supposed to be losslessly
        /// convertible back into the same token stream (modulo spans), except for
        /// possibly `TokenTree::Group`s with `Delimiter::None` delimiters and negative
        /// numeric literals.
        impl Display for TokenStream       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, f)
            }
        }
        /// Prints token in a form convenient for debugging.
        impl Debug for TokenStream       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }

        impl LexError 
        {
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
        }

        impl Debug for LexError
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }

        impl Display for LexError
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, f)
            }
        }

        impl Error for LexError {}
        /// A region of source code, along with macro expansion information.
        #[derive(Copy, Clone)]
        pub struct Span
        {
            inner: imp::Span,
            _marker: marker::ProcMacroAutoTraits,
        }

        impl Span
        {
            fn _new(inner: imp::Span) -> Self {
                Span {
                    inner,
                    _marker: marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::Span) -> Self 
            {
                Span {
                    inner: imp::Span::from(inner),
                    _marker: marker::MARKER,
                }
            }
            /// The span of the invocation of the current procedural macro
            pub fn call_site() -> Self 
            {
                Span::_new(imp::Span::call_site())
            }
            /// The span located at the invocation of the procedural macro,
            /// but with local variables, labels, and `$crate` resolved at the definition site of the macro.
            pub fn mixed_site() -> Self 
            {
                Span::_new(imp::Span::mixed_site())
            }
            /// A span that resolves at the macro definition site.
            pub fn def_site() -> Self 
            {
                Span::_new(imp::Span::def_site())
            }
            /// Creates a new span with the same line/column information as `self` but
            /// that resolves symbols as though it were at `other`.
            pub fn resolved_at( &self, other: Span) -> Span 
            {
                Span::_new(self.inner.resolved_at(other.inner))
            }
            /// Creates a new span with the same name resolution behavior as `self` but
            /// with the line/column information of `other`.
            pub fn located_at( &self, other: Span) -> Span 
            {
                Span::_new(self.inner.located_at(other.inner))
            }
            /// Convert `process::macros::Span` to `proc_macro::Span`
            pub fn unwrap( self ) -> proc_macro::Span 
           
            {
                self.inner.unwrap()
            }
           
            pub fn unstable( self ) -> proc_macro::Span
           
            {
                self.unwrap()
            }
            /// Returns the span's byte position range in the source file
            pub fn byte_range( &self ) -> Range<usize>
           
            {
                self.inner.byte_range()
            }
            /// Get the starting line/column in the source file for this span
            pub fn start( &self ) -> location::LineColumn
           
            {
                self.inner.start()
            }
            /// Get the ending line/column in the source file for this span
            pub fn end( &self ) -> location::LineColumn
           
            {
                self.inner.end()
            }
            /// The path to the source file in which this span occurs, for display purposes
            pub fn file( &self ) -> String
           
            {
                self.inner.file()
            }
            /// The path to the source file in which this span occurs on disk.
            pub fn local_file( &self ) -> Option<PathBuf>
           
            {
                self.inner.local_file()
            }
            /// Create a new span encompassing `self` and `other`.
            pub fn join( &self, other: Span) -> Option<Span>
           
            {
                self.inner.join(other.inner).map(Span::_new)
            }
            /// Compares two spans to see if they're equal.
            pub fn eq( &self, other: &Span) -> bool
            {
                self.inner.eq(&other.inner)
            }
            /// Returns the source text behind a span.
            pub fn source_text( &self ) -> Option<String>
           
            {
                self.inner.source_text()
            }
        }
        /// Prints a span in a form convenient for debugging.
        impl Debug for Span
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }
        /// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).
        #[derive(Clone)]
        pub enum TokenTree 
        {
            /// A token stream surrounded by bracket delimiters.
            Group(Group),
            /// An identifier.
            Ident(Ident),
            /// A single punctuation character (`+`, `,`, `$`, etc.).
            Punct(Punct),
            /// A literal character (`'a'`), string (`"hello"`), number (`2.3`), etc.
            Literal(Literal),
        }

        impl TokenTree 
        {
            /// Returns the span of this tree, 
            /// delegating to the `span` method of the contained token or a delimited stream.
            pub fn span( &self ) -> Span {
                match self {
                    TokenTree::Group(t) => t.span(),
                    TokenTree::Ident(t) => t.span(),
                    TokenTree::Punct(t) => t.span(),
                    TokenTree::Literal(t) => t.span(),
                }
            }
            /// Configures the span for *only this token*
            pub fn set_span(&mut self, span: Span) {
                match self {
                    TokenTree::Group(t) => t.set_span(span),
                    TokenTree::Ident(t) => t.set_span(span),
                    TokenTree::Punct(t) => t.set_span(span),
                    TokenTree::Literal(t) => t.set_span(span),
                }
            }
        }

        impl From<Group> for TokenTree
        {
            fn from(g: Group) -> Self {
                TokenTree::Group(g)
            }
        }

        impl From<Ident> for TokenTree
        {
            fn from(g: Ident) -> Self {
                TokenTree::Ident(g)
            }
        }

        impl From<Punct> for TokenTree
        {
            fn from(g: Punct) -> Self {
                TokenTree::Punct(g)
            }
        }

        impl From<Literal> for TokenTree
        {
            fn from(g: Literal) -> Self {
                TokenTree::Literal(g)
            }
        }
        /**
            Prints the token tree as a string that is losslessly convertible back into the same tree (modulo spans),
            except for `TokenTree::Group`s with `Delimiter::None` delimiters and negative numeric literals. */
        impl Display for TokenTree       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                match self {
                    TokenTree::Group(t) => Display::fmt(t, f),
                    TokenTree::Ident(t) => Display::fmt(t, f),
                    TokenTree::Punct(t) => Display::fmt(t, f),
                    TokenTree::Literal(t) => Display::fmt(t, f),
                }
            }
        }
        /// Prints token tree in a form convenient for debugging.
        impl Debug for TokenTree
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
               
               
                match self {
                    TokenTree::Group(t) => Debug::fmt(t, f),
                    TokenTree::Ident(t) =>
                    {
                        let mut debug = f.debug_struct("Ident");
                        debug.field("sym", &format_args!("{}", t));
                        imp::debug_span_field_if_nontrivial(&mut debug, t.span().inner);
                        debug.finish()
                    }
                    TokenTree::Punct(t) => Debug::fmt(t, f),
                    TokenTree::Literal(t) => Debug::fmt(t, f),
                }
            }
        }
        /// A delimited token stream.
        #[derive(Clone)]
        pub struct Group {
            inner: imp::Group,
        }
        /// Describes how a sequence of token trees is delimited.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Delimiter 
        {
            /// `( ... )`
            Parenthesis,
            /// `{ ... }`
            Brace,
            /// `[ ... ]`
            Bracket,
            /// `∅ ... ∅
            /// Invisible delimiters may not survive roundtrip of a token stream through a string instead in this context.
            None,
        }

        impl Group
        {
            fn _new(inner: imp::Group) -> Self {
                Group { inner }
            }

            fn _new_fallback(inner: fallback::Group) -> Self {
                Group {
                    inner: imp::Group::from(inner),
                }
            }
            /// Creates a new `Group` with the given delimiter and token stream
            pub fn new(delimiter: Delimiter, stream: TokenStream) -> Self {
                Group {
                    inner: imp::Group::new(delimiter, stream.inner),
                }
            }
            /// Returns the punctuation used as the delimiter for this group: a set of
            /// parentheses, square brackets, or curly braces.
            pub fn delimiter( &self ) -> Delimiter
            {
                self.inner.delimiter()
            }
            /// Returns the `TokenStream` of tokens that are delimited in this `Group`
            pub fn stream( &self ) -> TokenStream {
                TokenStream::_new(self.inner.stream())
            }
            /// Returns the span for the delimiters of this token stream, spanning the entire `Group`
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
            /// Returns the span pointing to the opening delimiter of this group
            pub fn span_open( &self ) -> Span {
                Span::_new(self.inner.span_open())
            }
            /// Returns the span pointing to the closing delimiter of this group
            pub fn span_close( &self ) -> Span {
                Span::_new(self.inner.span_close())
            }
            /// Returns an object that holds this group's `span_open()` and `span_close()` together.
            pub fn delim_span( &self ) -> ::process::macros::extra::DelimSpan
            {
                ::process::macros::extra::DelimSpan::new(&self.inner)
            }
            /// Configures the span for this `Group`'s delimiters, but not its internal
            /// tokens
            pub fn set_span(&mut self, span: Span)
            {
                self.inner.set_span(span.inner);
            }
        }
        /// Prints the group as a string that should be losslessly convertible back
        /// into the same group (modulo spans), except for possibly `TokenTree::Group`s
        /// with `Delimiter::None` delimiters.
        impl Display for Group
        {
            fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, formatter)
            }
        }

        impl Debug for Group
        {
            fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, formatter)
            }
        }
        /// A `Punct` is a single punctuation character like `+`, `-` or `#`.
        #[derive(Clone)]
        pub struct Punct 
        {
            ch: char,
            spacing: Spacing,
            span: Span,
        }
        /// Whether a `Punct` is followed immediately by another `Punct` or followed by another token or whitespace.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Spacing 
        {
            /// E.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.
            Alone,
            /// E.g. `+` is `Joint` in `+=` or `'` is `Joint` in `'#`
            Joint,
        }

        impl Punct
        {
            /// Creates a new `Punct` from the given character and spacing
            /// which can be further configured with the `set_span` method below.
            pub fn new(ch: char, spacing: Spacing) -> Self {
                if let '!' | '#' | '$' | '%' | '&' | '\'' | '*' | '+' | ',' | '-' | '.' | '/' | ':' | ';'
                | '<' | '=' | '>' | '?' | '@' | '^' | '|' | '~' = ch
                {
                    Punct {
                        ch,
                        spacing,
                        span: Span::call_site(),
                    }
                } else {
                    panic!("unsupported proc macro punctuation character {:?}", ch);
                }
            }
            /// Returns the value of this punctuation character as `char`.
            pub fn as_char( &self ) -> char
            {
                self.ch
            }
            /// Returns the spacing of this punctuation character, indicating whether
            /// it's immediately followed by another `Punct` in the token stream, so
            /// they can potentially be combined into a multicharacter operator
            /// (`Joint`), or it's followed by some other token or whitespace (`Alone`)
            /// so the operator has certainly ended.
            pub fn spacing( &self ) -> Spacing
            {
                self.spacing
            }
            /// Returns the span for this punctuation character.
            pub fn span( &self ) -> Span
            {
                self.span
            }
            /// Configure the span for this punctuation character.
            pub fn set_span(&mut self, span: Span)
            {
                self.span = span;
            }
        }
        /// Prints the punctuation character as a string that is losslessly convertible back into the same character.
        impl Display for Punct
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.ch, f)
            }
        }

        impl Debug for Punct       
        {
            fn fmt( &self, fmt: &mut fmt::Formatter) -> fmt::Result
            {
                let mut debug = fmt.debug_struct("Punct");
                debug.field("char", &self.ch);
                debug.field("spacing", &self.spacing);
                imp::debug_span_field_if_nontrivial(&mut debug, self.span.inner);
                debug.finish()
            }
        }
        /// A word of Rust code, which may be a keyword or legal variable name.
        #[derive(Clone)]
        pub struct Ident
        {
            inner: imp::Ident,
            _marker: marker::ProcMacroAutoTraits,
        }

        impl Ident       
        {
            fn _new(inner: imp::Ident) -> Self {
                Ident {
                    inner,
                    _marker: marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::Ident) -> Self {
                Ident {
                    inner: imp::Ident::from(inner),
                    _marker: marker::MARKER,
                }
            }
            /// Creates a new `Ident` with the given `string` as well as the specified `span`
            #[track_caller] pub fn new(string: &str, span: Span) -> Self {
                Ident::_new(imp::Ident::new_checked(string, span.inner))
            }
            /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).
            #[track_caller] pub fn new_raw(string: &str, span: Span) -> Self {
                Ident::_new(imp::Ident::new_raw_checked(string, span.inner))
            }
            /// Returns the span of this `Ident`.
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
            /// Configures the span of this `Ident`, possibly changing its hygiene context.
            pub fn set_span(&mut self, span: Span)
            {
                self.inner.set_span(span.inner);
            }
        }

        impl PartialEq for Ident       
        {
            fn eq( &self, other: &Ident) -> bool
            {
                self.inner == other.inner
            }
        }

        impl<T> PartialEq<T> for Ident where
        T: ?Sized + AsRef<str>       
        {
            fn eq( &self, other: &T) -> bool
            {
                self.inner == other
            }
        }

        impl Eq for Ident {}

        impl PartialOrd for Ident       
        {
            fn partial_cmp( &self, other: &Ident) -> Option<Ordering>
                    {
                Some(self.cmp(other))
            }
        }

        impl Ord for Ident 
       
        {
            fn cmp( &self, other: &Ident) -> Ordering
            {
                self.to_string().cmp(&other.to_string())
            }
        }

        impl Hash for Ident       
        {
            fn hash<H: Hasher>( &self, hasher: &mut H)
            {
                self.to_string().hash(hasher);
            }
        }
        /// Prints the identifier as a string that should be losslessly convertible back into the same identifier.
        impl Display for Ident        
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, f)
            }
        }

        impl Debug for Ident       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }
        /// A literal string (`"hello"`), byte string (`b"hello"`), character (`'a'`),
        /// byte character (`b'a'`), an integer or floating point number with or without
        /// a suffix (`1`, `1u8`, `2.3`, `2.3f32`).
        #[derive(Clone)]
        pub struct Literal
        {
            inner: imp::Literal,
            _marker: marker::ProcMacroAutoTraits,
        }

        macro_rules! suffixed_int_literals
        {
            ($($name:ident => $kind:ident,)*) => 
            ($(
                /// Creates a new suffixed integer literal with the specified value.
                pub fn $name(n: $kind) -> Literal 
                {
                    Literal::_new(imp::Literal::$name(n))
                }
            )*);
        }

        macro_rules! unsuffixed_int_literals 
        {
            ($($name:ident => $kind:ident,)*) => ($(
                /// Creates a new unsuffixed integer literal with the specified value.
                pub fn $name(n: $kind) -> Literal {
                    Literal::_new(imp::Literal::$name(n))
                }
            )*)
        }

        impl Literal        
        {
            fn _new(inner: imp::Literal) -> Self 
            {
                Literal {
                    inner,
                    _marker: ::marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::Literal) -> Self 
            {
                Literal {
                    inner: imp::Literal::from(inner),
                    _marker: ::marker::MARKER,
                }
            }

            suffixed_int_literals! 
            {
                u8_suffixed => u8,
                u16_suffixed => u16,
                u32_suffixed => u32,
                u64_suffixed => u64,
                u128_suffixed => u128,
                usize_suffixed => usize,
                i8_suffixed => i8,
                i16_suffixed => i16,
                i32_suffixed => i32,
                i64_suffixed => i64,
                i128_suffixed => i128,
                isize_suffixed => isize,
            }

            unsuffixed_int_literals! 
            {
                u8_unsuffixed => u8,
                u16_unsuffixed => u16,
                u32_unsuffixed => u32,
                u64_unsuffixed => u64,
                u128_unsuffixed => u128,
                usize_unsuffixed => usize,
                i8_unsuffixed => i8,
                i16_unsuffixed => i16,
                i32_unsuffixed => i32,
                i64_unsuffixed => i64,
                i128_unsuffixed => i128,
                isize_unsuffixed => isize,
            }
            /// Creates a new unsuffixed floating-point literal
            pub fn f64_unsuffixed(f: f64) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f64_unsuffixed(f))
            }
            /// Creates a new suffixed floating-point literal

            pub fn f64_suffixed(f: f64) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f64_suffixed(f))
            }
            /// Creates a new unsuffixed floating-point literal
            pub fn f32_unsuffixed(f: f32) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f32_unsuffixed(f))
            }
            /// Creates a new suffixed floating-point literal
            pub fn f32_suffixed(f: f32) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f32_suffixed(f))
            }
            /// String literal.
            pub fn string(string: &str) -> Literal 
            {
                Literal::_new(imp::Literal::string(string))
            }
            /// Character literal.
            pub fn character(ch: char) -> Literal 
            {
                Literal::_new(imp::Literal::character(ch))
            }
            /// Byte character literal.
            pub fn byte_character(byte: u8) -> Literal 
            {
                Literal::_new(imp::Literal::byte_character(byte))
            }
            /// Byte string literal.
            pub fn byte_string(bytes: &[u8]) -> Literal 
            {
                Literal::_new(imp::Literal::byte_string(bytes))
            }
            /// C string literal.
            pub fn c_string( string:&::ffi::CStr ) -> Literal 
            {
                Literal::_new(imp::Literal::c_string(string))
            }
            /// Returns the span encompassing this literal.
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
            /// Configures the span associated for this literal.
            pub fn set_span(&mut self, span: Span)
            {
                self.inner.set_span(span.inner);
            }
            /// Returns a `Span` that is a subset of `self.span()` containing only
            /// the source bytes in range `range`.
            pub fn subspan<R: RangeBounds<usize>>( &self, range: R) -> Option<Span> 
           
            {
                self.inner.subspan(range).map(Span::_new)
            }

            pub unsafe fn from_str_unchecked(repr: &str) -> Self 
            {
                Literal::_new(unsafe { imp::Literal::from_str_unchecked(repr) })
            }
        }

        impl ::str::FromStr for Literal 
        {
            type Err = LexError;
            fn from_str(repr: &str) -> Result<Self, LexError>
            {
                match imp::Literal::from_str_checked(repr) {
                    Ok(lit) => Ok(Literal::_new(lit)),
                    Err(lex) => Err(LexError {
                        inner: lex,
                        _marker: ::marker::MARKER,
                    }),
                }
            }
        }

        impl Debug for Literal       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }

        impl Display for Literal       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, f)
            }
        }
    }
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod quote
{
    /*!
    Provides the [`quote!`] macro for turning Rust syntax tree data structures into tokens of source code. */
    use ::
    {
        *,
    };
    /*
    */
    pub mod ext
    {
        use ::
        {
            process::macros::{ TokenStream, TokenTree },
            quote::{ ToTokens },
            *,
        };
        /*
        */
        /// TokenStream extension trait with methods for appending tokens.
        pub trait TokenStreamExt: private::Sealed
        {
            /// For use by `ToTokens` implementations.
            fn append<U>(&mut self, token: U) where U: Into<TokenTree>;
            /// For use by `ToTokens` implementations.
            fn append_all<I>(&mut self, iter: I) where
            I: IntoIterator,
            I::Item: ToTokens;
            /// For use by `ToTokens` implementations.
            fn append_separated<I, U>(&mut self, iter: I, op: U) where
            I: IntoIterator,
            I::Item: ToTokens,
            U: ToTokens;
            /// For use by `ToTokens` implementations.
            fn append_terminated<I, U>(&mut self, iter: I, term: U) where
            I: IntoIterator,
            I::Item: ToTokens,
            U: ToTokens;
        }

        impl TokenStreamExt for TokenStream
        {
            fn append<U>(&mut self, token: U) where
                U: Into<TokenTree>,
           
            {
                self.extend(iter::once(token.into()));
            }

            fn append_all<I>(&mut self, iter: I) where
                I: IntoIterator,
                I::Item: ToTokens,
            {
                for token in iter {
                    token.to_tokens(self);
                }
            }

            fn append_separated<I, U>(&mut self, iter: I, op: U) where
                I: IntoIterator,
                I::Item: ToTokens,
                U: ToTokens,
            {
                for (i, token) in iter.into_iter().enumerate() {
                    if i > 0 {
                        op.to_tokens(self);
                    }
                    token.to_tokens(self);
                }
            }

            fn append_terminated<I, U>(&mut self, iter: I, term: U) where
                I: IntoIterator,
                I::Item: ToTokens,
                U: ToTokens,
            {
                for token in iter {
                    token.to_tokens(self);
                    term.to_tokens(self);
                }
            }
        }

        mod private 
        {
            use ::process::macros::TokenStream;

            pub trait Sealed {}

            impl Sealed for TokenStream {}
        }
    } pub use self::ext::TokenStreamExt;
    
    pub mod ident_fragment
    {
        use ::
        {
            borrow::{ Cow },
            process::macros::{ Ident, Span },
            *,
        };
        /*
        */
        /// Specialized formatting trait used by `format_ident!`.
        pub trait IdentFragment
        {
            /// Format this value as an identifier fragment.
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result;
            /// Span associated with this `IdentFragment`.
            fn span(&self) -> Option<Span> {
                None
            }
        }

        impl<T: IdentFragment + ?Sized> IdentFragment for &T 
        {
            fn span(&self) -> Option<Span> {
                <T as IdentFragment>::span(*self)
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                IdentFragment::fmt(*self, f)
            }
        }

        impl<T: IdentFragment + ?Sized> IdentFragment for &mut T 
        {
            fn span(&self) -> Option<Span> {
                <T as IdentFragment>::span(*self)
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                IdentFragment::fmt(*self, f)
            }
        }

        impl IdentFragment for Ident 
        {
            fn span(&self) -> Option<Span> {
                Some(self.span())
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                let id = self.to_string();
                if let Some(id) = id.strip_prefix("r#") {
                    fmt::Display::fmt(id, f)
                } else {
                    fmt::Display::fmt(&id[..], f)
                }
            }
        }

        impl<T> IdentFragment for Cow<'_, T> where
        T: IdentFragment + ToOwned + ?Sized,
        {
            fn span(&self) -> Option<Span> {
                T::span(self)
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                T::fmt(self, f)
            }
        }
        
        macro_rules! ident_fragment_display
        {
            ($($T:ty),*) => {
                $(
                    impl IdentFragment for $T {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                            fmt::Display::fmt(self, f)
                        }
                    }
                )*
            };
        }

        ident_fragment_display!(bool, str, String, char);
        ident_fragment_display!(u8, u16, u32, u64, u128, usize);
    } pub use self::ident_fragment::IdentFragment;
    
    pub mod to_tokens
    {
        use ::
        {
            borrow::{ Cow },
            process::macros::{ Group, Ident, Literal, Punct, Span, TokenStream, TokenTree },
            quote::{ TokenStreamExt },
            rc::{ Rc },
            *,
        };
        /*
        */
        /// Types that can be interpolated inside a `quote!` invocation.
        pub trait ToTokens {
            /// Write `self` to the given `TokenStream`.
            fn to_tokens(&self, tokens: &mut TokenStream);
            /// Convert `self` directly into a `TokenStream` object.
            fn to_token_stream(&self) -> TokenStream
            {
                let mut tokens = TokenStream::new();
                self.to_tokens(&mut tokens);
                tokens
            }
            /// Convert `self` directly into a `TokenStream` object.
            fn into_token_stream(self) -> TokenStream where
            Self: Sized,
           
            {
                self.to_token_stream()
            }
        }

        impl<'a, T: ?Sized + ToTokens> ToTokens for &'a T {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<'a, T: ?Sized + ToTokens> ToTokens for &'a mut T {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<'a, T: ?Sized + ToOwned + ToTokens> ToTokens for Cow<'a, T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<T: ?Sized + ToTokens> ToTokens for Box<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<T: ?Sized + ToTokens> ToTokens for Rc<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<T: ToTokens> ToTokens for Option<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                if let Some(ref t) = *self {
                    t.to_tokens(tokens);
                }
            }
        }

        impl ToTokens for str 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(Literal::string(self));
            }
        }

        impl ToTokens for String 
        {
            fn to_tokens(&self, tokens: &mut TokenStream)
            {
                self.as_str().to_tokens(tokens);
            }
        }

        macro_rules! primitive 
        {
            ($($t:ident => $name:ident)*) => {
                $(
                    impl ToTokens for $t {
                        fn to_tokens(&self, tokens: &mut TokenStream) {
                            tokens.append(Literal::$name(*self));
                        }
                    }
                )*
            };
        }

        primitive! 
        {
            i8 => i8_suffixed
            i16 => i16_suffixed
            i32 => i32_suffixed
            i64 => i64_suffixed
            i128 => i128_suffixed
            isize => isize_suffixed

            u8 => u8_suffixed
            u16 => u16_suffixed
            u32 => u32_suffixed
            u64 => u64_suffixed
            u128 => u128_suffixed
            usize => usize_suffixed

            f32 => f32_suffixed
            f64 => f64_suffixed
        }

        impl ToTokens for char 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(Literal::character(*self));
            }
        }

        impl ToTokens for bool 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                let word = if *self { "true" } else { "false" };
                tokens.append(Ident::new(word, Span::call_site()));
            }
        }

        impl ToTokens for Group 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for Ident 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for Punct 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for Literal 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for TokenTree 
        {
            fn to_tokens(&self, dst: &mut TokenStream) {
                dst.append(self.clone());
            }
        }

        impl ToTokens for TokenStream 
        {
            fn to_tokens(&self, dst: &mut TokenStream) {
                dst.extend(iter::once(self.clone()));
            }

            fn into_token_stream(self) -> TokenStream { self }
        }
    } pub use self::to_tokens::ToTokens;
    
    pub mod __private
    {
        use ::
        {
            ops::{ BitOr },
            process::macros::{ Group, Ident, Punct, Spacing, TokenTree },
            quote::{ IdentFragment, ToTokens, TokenStreamExt },
            *,
        }; use self::get_span::{GetSpan, GetSpanBase, GetSpanInner};
        /*
        */
        pub type Delimiter = process::macros::Delimiter;
        pub type Span = process::macros::Span;
        pub type TokenStream = process::macros::TokenStream;
        
        macro_rules! push_punct
        {
            ($name:ident $spanned:ident $char1:tt) => {
                    pub fn $name(tokens: &mut TokenStream)
                {
                    tokens.append(Punct::new($char1, Spacing::Alone));
                }
                    pub fn $spanned(tokens: &mut TokenStream, span: Span) {
                    let mut punct = Punct::new($char1, Spacing::Alone);
                    punct.set_span(span);
                    tokens.append(punct);
                }
            };
            ($name:ident $spanned:ident $char1:tt $char2:tt) => {
                    pub fn $name(tokens: &mut TokenStream)
                {
                    tokens.append(Punct::new($char1, Spacing::Joint));
                    tokens.append(Punct::new($char2, Spacing::Alone));
                }
                    pub fn $spanned(tokens: &mut TokenStream, span: Span) {
                    let mut punct = Punct::new($char1, Spacing::Joint);
                    punct.set_span(span);
                    tokens.append(punct);
                    let mut punct = Punct::new($char2, Spacing::Alone);
                    punct.set_span(span);
                    tokens.append(punct);
                }
            };
            ($name:ident $spanned:ident $char1:tt $char2:tt $char3:tt) => {
                    pub fn $name(tokens: &mut TokenStream)
                {
                    tokens.append(Punct::new($char1, Spacing::Joint));
                    tokens.append(Punct::new($char2, Spacing::Joint));
                    tokens.append(Punct::new($char3, Spacing::Alone));
                }
                    pub fn $spanned(tokens: &mut TokenStream, span: Span) {
                    let mut punct = Punct::new($char1, Spacing::Joint);
                    punct.set_span(span);
                    tokens.append(punct);
                    let mut punct = Punct::new($char2, Spacing::Joint);
                    punct.set_span(span);
                    tokens.append(punct);
                    let mut punct = Punct::new($char3, Spacing::Alone);
                    punct.set_span(span);
                    tokens.append(punct);
                }
            };
        }

        pub struct HasIterator;
        pub struct ThereIsNoIteratorInRepetition;

        impl BitOr<ThereIsNoIteratorInRepetition> for ThereIsNoIteratorInRepetition {
            type Output = ThereIsNoIteratorInRepetition;
            fn bitor(self, _rhs: ThereIsNoIteratorInRepetition) -> ThereIsNoIteratorInRepetition {
                ThereIsNoIteratorInRepetition
            }
        }

        impl BitOr<ThereIsNoIteratorInRepetition> for HasIterator {
            type Output = HasIterator;
            fn bitor(self, _rhs: ThereIsNoIteratorInRepetition) -> HasIterator {
                HasIterator
            }
        }

        impl BitOr<HasIterator> for ThereIsNoIteratorInRepetition {
            type Output = HasIterator;
            fn bitor(self, _rhs: HasIterator) -> HasIterator {
                HasIterator
            }
        }

        impl BitOr<HasIterator> for HasIterator {
            type Output = HasIterator;
            fn bitor(self, _rhs: HasIterator) -> HasIterator {
                HasIterator
            }
        }
        /// Extension traits used by the implementation of `quote!`.
        pub mod ext
        {
            use ::
            {
                collections::btree_set::{ self, BTreeSet },
                quote::{ ToTokens },
                *,
            };
            /**/
            use super::RepInterp;
            use super::{HasIterator as HasIter, ThereIsNoIteratorInRepetition as DoesNotHaveIter};
            /// Extension trait providing the `quote_into_iter` method on iterators.
            pub trait RepIteratorExt: Iterator + Sized {
                fn quote_into_iter(self) -> (Self, HasIter) {
                    (self, HasIter)
                }
            }

            impl<T: Iterator> RepIteratorExt for T {}
            /// Extension trait providing the `quote_into_iter` method for non-iterable types.
            pub trait RepToTokensExt {
                /// Pretend to be an iterator for the purposes of `quote_into_iter`.
                /// This allows repeated calls to `quote_into_iter` to continue
                /// correctly returning DoesNotHaveIter.
                fn next(&self) -> Option<&Self> {
                    Some(self)
                }

                fn quote_into_iter(&self) -> (&Self, DoesNotHaveIter) {
                    (self, DoesNotHaveIter)
                }
            }

            impl<T: ToTokens + ?Sized> RepToTokensExt for T {}
            /// Extension trait providing the `quote_into_iter` method for types that can be referenced as an iterator.
            pub trait RepAsIteratorExt<'q>
            {
                type Iter: Iterator;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter);
            }

            impl<'q, 'a, T: RepAsIteratorExt<'q> + ?Sized> RepAsIteratorExt<'q> for &'a T
            {
                type Iter = T::Iter;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    <T as RepAsIteratorExt>::quote_into_iter(*self)
                }
            }

            impl<'q, 'a, T: RepAsIteratorExt<'q> + ?Sized> RepAsIteratorExt<'q> for &'a mut T {
                type Iter = T::Iter;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    <T as RepAsIteratorExt>::quote_into_iter(*self)
                }
            }

            impl<'q, T: 'q> RepAsIteratorExt<'q> for [T] {
                type Iter = slice::Iter<'q, T>;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    (self.iter(), HasIter)
                }
            }

            impl<'q, T: 'q> RepAsIteratorExt<'q> for Vec<T>
            {
                type Iter = slice::Iter<'q, T>;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    (self.iter(), HasIter)
                }
            }

            impl<'q, T: 'q> RepAsIteratorExt<'q> for BTreeSet<T>
            {
                type Iter = btree_set::Iter<'q, T>;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    (self.iter(), HasIter)
                }
            }

            impl<'q, T: RepAsIteratorExt<'q>> RepAsIteratorExt<'q> for RepInterp<T>
            {
                type Iter = T::Iter;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    self.0.quote_into_iter()
                }
            }
        }

        #[derive(Copy, Clone)]
        pub struct RepInterp<T>(pub T);

        impl<T> RepInterp<T>
        {
            pub fn next(self) -> Option<T>
            {
                Some(self.0)
            }
        }

        impl<T: Iterator> Iterator for RepInterp<T>
        {
            type Item = T::Item;
            fn next(&mut self) -> Option<Self::Item>
            {
                self.0.next()
            }
        }

        impl<T: ToTokens> ToTokens for RepInterp<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream)
            {
                self.0.to_tokens(tokens);
            }
        }
        
        #[inline] pub fn get_span<T>(span: T) -> GetSpan<T> 
        {
            GetSpan(GetSpanInner(GetSpanBase(span)))
        }

        mod get_span
        {
            use ::
            {
                ops::{ Deref },
                process::macros::
                {
                    extra::DelimSpan, Span
                },
                *,
            };
            /*
            */
            pub struct GetSpan<T>(pub GetSpanInner<T>);

            pub struct GetSpanInner<T>(pub GetSpanBase<T>);

            pub struct GetSpanBase<T>(pub T);

            impl GetSpan<Span> {
                #[inline]
                pub fn __into_span(self) -> Span {
                    ((self.0).0).0
                }
            }

            impl GetSpanInner<DelimSpan> {
                #[inline]
                pub fn __into_span(&self) -> Span {
                    (self.0).0.join()
                }
            }

            impl<T> GetSpanBase<T> {
                #[allow(clippy::unused_self)]
                pub fn __into_span(&self) -> T {
                    unreachable!()
                }
            }

            impl<T> Deref for GetSpan<T>
            {
                type Target = GetSpanInner<T>;

                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }

            impl<T> Deref for GetSpanInner<T>
            {
                type Target = GetSpanBase<T>;

                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
        }

        pub fn push_group(tokens: &mut TokenStream, delimiter: Delimiter, inner: TokenStream) 
        {
            tokens.append(Group::new(delimiter, inner));
        }

        pub fn push_group_spanned
        (
            tokens: &mut TokenStream,
            span: Span,
            delimiter: Delimiter,
            inner: TokenStream,
        ) 
        {
            let mut g = Group::new(delimiter, inner);
            g.set_span(span);
            tokens.append(g);
        }

        pub fn parse(tokens: &mut TokenStream, s: &str)
        {
            let s: TokenStream = s.parse().expect("invalid token stream");
            tokens.extend(iter::once(s));
        }

        pub fn parse_spanned(tokens: &mut TokenStream, span: Span, s: &str)
        {
            let s: TokenStream = s.parse().expect("invalid token stream");
            tokens.extend(s.into_iter().map(|t| respan_token_tree(t, span)));
        }
        
        fn respan_token_tree(mut token: TokenTree, span: Span) -> TokenTree
        {
            match &mut token {
                TokenTree::Group(g) => {
                    let stream = g
                        .stream()
                        .into_iter()
                        .map(|token| respan_token_tree(token, span))
                        .collect();
                    *g = Group::new(g.delimiter(), stream);
                    g.set_span(span);
                }
                other => other.set_span(span),
            }
            token
        }

        pub fn push_ident(tokens: &mut TokenStream, s: &str)
        {
            let span = Span::call_site();
            push_ident_spanned(tokens, span, s);
        }

        pub fn push_ident_spanned(tokens: &mut TokenStream, span: Span, s: &str)
        {
            tokens.append(ident_maybe_raw(s, span));
        }

        pub fn push_lifetime(tokens: &mut TokenStream, lifetime: &str)
        {
            struct Lifetime<'a> {
                name: &'a str,
                state: u8,
            }

            impl<'a> Iterator for Lifetime<'a>
            {
                type Item = TokenTree;
                fn next(&mut self) -> Option<Self::Item> {
                    match self.state {
                        0 => {
                            self.state = 1;
                            Some(TokenTree::Punct(Punct::new('\'', Spacing::Joint)))
                        }
                        1 => {
                            self.state = 2;
                            Some(TokenTree::Ident(Ident::new(self.name, Span::call_site())))
                        }
                        _ => None,
                    }
                }
            }

            tokens.extend(Lifetime {
                name: &lifetime[1..],
                state: 0,
            });
        }

        pub fn push_lifetime_spanned(tokens: &mut TokenStream, span: Span, lifetime: &str)
        {
            struct Lifetime<'a> {
                name: &'a str,
                span: Span,
                state: u8,
            }

            impl<'a> Iterator for Lifetime<'a>
            {
                type Item = TokenTree;
                fn next(&mut self) -> Option<Self::Item> {
                    match self.state {
                        0 => {
                            self.state = 1;
                            let mut apostrophe = Punct::new('\'', Spacing::Joint);
                            apostrophe.set_span(self.span);
                            Some(TokenTree::Punct(apostrophe))
                        }
                        1 => {
                            self.state = 2;
                            Some(TokenTree::Ident(Ident::new(self.name, self.span)))
                        }
                        _ => None,
                    }
                }
            }

            tokens.extend(Lifetime {
                name: &lifetime[1..],
                span,
                state: 0,
            });
        }

        push_punct!(push_add push_add_spanned '+');
        push_punct!(push_add_eq push_add_eq_spanned '+' '=');
        push_punct!(push_and push_and_spanned '&');
        push_punct!(push_and_and push_and_and_spanned '&' '&');
        push_punct!(push_and_eq push_and_eq_spanned '&' '=');
        push_punct!(push_at push_at_spanned '@');
        push_punct!(push_bang push_bang_spanned '!');
        push_punct!(push_caret push_caret_spanned '^');
        push_punct!(push_caret_eq push_caret_eq_spanned '^' '=');
        push_punct!(push_colon push_colon_spanned ':');
        push_punct!(push_colon2 push_colon2_spanned ':' ':');
        push_punct!(push_comma push_comma_spanned ',');
        push_punct!(push_div push_div_spanned '/');
        push_punct!(push_div_eq push_div_eq_spanned '/' '=');
        push_punct!(push_dot push_dot_spanned '.');
        push_punct!(push_dot2 push_dot2_spanned '.' '.');
        push_punct!(push_dot3 push_dot3_spanned '.' '.' '.');
        push_punct!(push_dot_dot_eq push_dot_dot_eq_spanned '.' '.' '=');
        push_punct!(push_eq push_eq_spanned '=');
        push_punct!(push_eq_eq push_eq_eq_spanned '=' '=');
        push_punct!(push_ge push_ge_spanned '>' '=');
        push_punct!(push_gt push_gt_spanned '>');
        push_punct!(push_le push_le_spanned '<' '=');
        push_punct!(push_lt push_lt_spanned '<');
        push_punct!(push_mul_eq push_mul_eq_spanned '*' '=');
        push_punct!(push_ne push_ne_spanned '!' '=');
        push_punct!(push_or push_or_spanned '|');
        push_punct!(push_or_eq push_or_eq_spanned '|' '=');
        push_punct!(push_or_or push_or_or_spanned '|' '|');
        push_punct!(push_pound push_pound_spanned '#');
        push_punct!(push_question push_question_spanned '?');
        push_punct!(push_rarrow push_rarrow_spanned '-' '>');
        push_punct!(push_larrow push_larrow_spanned '<' '-');
        push_punct!(push_rem push_rem_spanned '%');
        push_punct!(push_rem_eq push_rem_eq_spanned '%' '=');
        push_punct!(push_fat_arrow push_fat_arrow_spanned '=' '>');
        push_punct!(push_semi push_semi_spanned ';');
        push_punct!(push_shl push_shl_spanned '<' '<');
        push_punct!(push_shl_eq push_shl_eq_spanned '<' '<' '=');
        push_punct!(push_shr push_shr_spanned '>' '>');
        push_punct!(push_shr_eq push_shr_eq_spanned '>' '>' '=');
        push_punct!(push_star push_star_spanned '*');
        push_punct!(push_sub push_sub_spanned '-');
        push_punct!(push_sub_eq push_sub_eq_spanned '-' '=');

        pub fn push_underscore(tokens: &mut TokenStream)
        {
            push_underscore_spanned(tokens, Span::call_site());
        }

        pub fn push_underscore_spanned(tokens: &mut TokenStream, span: Span)
        {
            tokens.append(Ident::new("_", span));
        }
       
        pub fn mk_ident(id: &str, span: Option<Span>) -> Ident
        {
            let span = span.unwrap_or_else(Span::call_site);
            ident_maybe_raw(id, span)
        }

        fn ident_maybe_raw(id: &str, span: Span) -> Ident       
        {
            if let Some(id) = id.strip_prefix("r#") {
                Ident::new_raw(id, span)
            } else {
                Ident::new(id, span)
            }
        }
        
        #[derive(Copy, Clone)]
        pub struct IdentFragmentAdapter<T: IdentFragment>(pub T);

        impl<T: IdentFragment> IdentFragmentAdapter<T>
        {
            pub fn span(&self) -> Option<Span> { self.0.span() }
        }

        impl<T: IdentFragment> fmt::Display for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { IdentFragment::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::Octal> fmt::Octal for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Octal::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::LowerHex> fmt::LowerHex for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::LowerHex::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::UpperHex> fmt::UpperHex for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::UpperHex::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::Binary> fmt::Binary for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Binary::fmt(&self.0, f) }
        }
    }
    
    pub mod spanned
    {
        use ::
        {
            process::macros::{ extra::DelimSpan, Span, TokenStream },
            quote::ToTokens,
            *,
        };
        /*
        */
       
        pub trait Spanned: private::Sealed {
            fn __span(&self) -> Span;
        }

        impl Spanned for Span {
            fn __span(&self) -> Span {
                *self
            }
        }

        impl Spanned for DelimSpan {
            fn __span(&self) -> Span
            {
                self.join()
            }
        }

        impl<T: ?Sized + ToTokens> Spanned for T {
            fn __span(&self) -> Span {
                join_spans(self.into_token_stream())
            }
        }

        fn join_spans(tokens: TokenStream) -> Span
        {
            let mut iter = tokens.into_iter().map(|tt| tt.span());

            let first = match iter.next() {
                Some(span) => span,
                None => return Span::call_site(),
            };

            iter.fold(None, |_prev, next| Some(next))
                .and_then(|last| first.join(last))
                .unwrap_or(first)
        }

        mod private
        {
            use ::
            {
                process::macros::
                {
                    extra::DelimSpan, Span
                },
                quote::{ ToTokens },
                *,
            };
            /*
            */
            pub trait Sealed {}
            impl Sealed for Span {}
            impl Sealed for DelimSpan {}
            impl<T: ?Sized + ToTokens> Sealed for T {}
        }
    }
    
}

pub mod rc
{
    pub use std::rc::{ * };
}

pub mod result
{
    pub use std::result::{ * };
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod str
{
    pub use std::str::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };
}
/*
syn v2.0.106 */
pub mod syntax
{
    /*!
    Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. */
    use ::
    {
        *,
    };
    /*    
        #![doc(html_root_url = "https://docs.rs/syn/2.0.106")]
        #![cfg_attr(docsrs, feature(doc_cfg))]
        #![deny(unsafe_op_in_unsafe_fn)]
        #![allow(non_camel_case_types)]
        #![cfg_attr(not(check_cfg), allow(unexpected_cfgs))]
        #![allow(
            clippy::bool_to_int_with_if,
            clippy::cast_lossless,
            clippy::cast_possible_truncation,
            clippy::cast_possible_wrap,
            clippy::cast_ptr_alignment,
            clippy::default_trait_access,
            clippy::derivable_impls,
            clippy::diverging_sub_expression,
            clippy::doc_markdown,
            clippy::elidable_lifetime_names,
            clippy::enum_glob_use,
            clippy::expl_impl_clone_on_copy,
            clippy::explicit_auto_deref,
            clippy::fn_params_excessive_bools,
            clippy::if_not_else,
            clippy::inherent_to_string,
            clippy::into_iter_without_iter,
            clippy::items_after_statements,
            clippy::large_enum_variant,
            clippy::let_underscore_untyped,
            clippy::manual_assert,
            clippy::manual_let_else,
            clippy::manual_map,
            clippy::match_like_matches_macro,
            clippy::match_same_arms,
            clippy::match_wildcard_for_single_variants,
            clippy::missing_errors_doc,
            clippy::missing_panics_doc,
            clippy::module_name_repetitions,
            clippy::must_use_candidate,
            clippy::needless_doctest_main,
            clippy::needless_lifetimes,
            clippy::needless_pass_by_value,
            clippy::needless_update,
            clippy::never_loop,
            clippy::range_plus_one,
            clippy::redundant_else,
            clippy::ref_option,
            clippy::return_self_not_must_use,
            clippy::similar_names,
            clippy::single_match_else,
            clippy::struct_excessive_bools,
            clippy::too_many_arguments,
            clippy::too_many_lines,
            clippy::trivially_copy_pass_by_ref,
            clippy::unconditional_recursion,
            clippy::uninhabited_references,
            clippy::uninlined_format_args,
            clippy::unnecessary_box_returns,
            clippy::unnecessary_unwrap,
            clippy::used_underscore_binding,
            clippy::wildcard_imports,
        )]
        #![allow(unknown_lints, mismatched_lifetime_syntaxes)]
    */
    pub mod attr
    {
        use ::
        {
            process::macros::TokenStream,
            syntax::
            {
                error::{ Error, Result },
                expr::{ Expr },
                mac::{ MacroDelimiter },
                meta::{ self, ParseNestedMeta },
                parse::{ Parse, ParseStream, Parser },
                path::{ Path },
                token, 
            },
            *,
        };
        /*
        */
        ast_struct!
        {
            /// An attribute, like `#[repr(transparent)]`.
            pub struct Attribute
            {
                pub pound_token: Token![#],
                pub style: AttrStyle,
                pub bracket_token: token::Bracket,
                pub meta: Meta,
            }
        }

        impl Attribute
        {
            /// Returns the path that identifies the interpretation of this attribute.
            pub fn path(&self) -> &Path
            {
                self.meta.path()
            }
            /// Parse the arguments to the attribute as a syntax tree.
            pub fn parse_args<T: Parse>(&self) -> Result<T>
            {
                self.parse_args_with(T::parse)
            }
            /// Parse the arguments to the attribute using the given parser.
            pub fn parse_args_with<F: Parser>(&self, parser: F) -> Result<F::Output>
            {
                match &self.meta {
                    Meta::Path(path) => Err(::syntax::error::new2(
                        path.segments.first().unwrap().ident.span(),
                        path.segments.last().unwrap().ident.span(),
                        format!(
                            "expected attribute arguments in parentheses: {}[{}(...)]",
                            parsing::DisplayAttrStyle(&self.style),
                            parsing::DisplayPath(path),
                        ),
                    )),
                    Meta::NameValue(meta) => Err(Error::new(
                        meta.eq_token.span,
                        format_args!(
                            "expected parentheses: {}[{}(...)]",
                            parsing::DisplayAttrStyle(&self.style),
                            parsing::DisplayPath(&meta.path),
                        ),
                    )),
                    Meta::List(meta) => meta.parse_args_with(parser),
                }
            }
            /// Parse the arguments to the attribute, expecting it to follow the
            /// conventional structure used by most of Rust's built-in attributes.
            pub fn parse_nested_meta(
                &self,
                logic: impl FnMut(ParseNestedMeta) -> Result<()>,
            ) -> Result<()>
            {
                self.parse_args_with(meta::parser(logic))
            }
            /// Parses zero or more outer attributes from the stream.
             
            pub fn parse_outer(input: ParseStream) -> Result<Vec<Self>>
            {
                let mut attrs = Vec::new();
                while input.peek(Token![#]) {
                    attrs.push(input.call(parsing::single_parse_outer)?);
                }
                Ok(attrs)
            }
            /// Parses zero or more inner attributes from the stream.
            pub fn parse_inner(input: ParseStream) -> Result<Vec<Self>>
            {
                let mut attrs = Vec::new();
                parsing::parse_inner(input, &mut attrs)?;
                Ok(attrs)
            }
        }

        ast_enum!
        {
            /// Distinguishes between attributes that decorate an item and those that are contained within an item.
            pub enum AttrStyle {
                Outer,
                Inner(Token![!]),
            }
        }

        ast_enum!        
        {
            /// Content of a compile-time structured attribute.
            pub enum Meta
            {
                Path(Path),
                /// A structured list within an attribute, like `derive(Copy, Clone)`.
                List(MetaList),
                /// A name-value pair within an attribute, like `feature = "nightly"`.
                NameValue(MetaNameValue),
            }
        }

        ast_struct! 
        {
            /// A structured list within an attribute, like `derive(Copy, Clone)`.
            pub struct MetaList {
                pub path: Path,
                pub delimiter: MacroDelimiter,
                pub tokens: TokenStream,
            }
        }

        ast_struct! 
        {
            /// A name-value pair within an attribute, like `feature = "nightly"`.
            pub struct MetaNameValue {
                pub path: Path,
                pub eq_token: Token![=],
                pub value: Expr,
            }
        }

        impl Meta 
        {
            /// Returns the path that begins this structured meta item.
            pub fn path(&self) -> &Path {
                match self {
                    Meta::Path(path) => path,
                    Meta::List(meta) => &meta.path,
                    Meta::NameValue(meta) => &meta.path,
                }
            }
            /// Error if this is a `Meta::List` or `Meta::NameValue`.
             
                pub fn require_path_only(&self) -> Result<&Path>
            {
                let error_span = match self {
                    Meta::Path(path) => return Ok(path),
                    Meta::List(meta) => meta.delimiter.span().open(),
                    Meta::NameValue(meta) => meta.eq_token.span,
                };
                Err(Error::new(error_span, "unexpected token in attribute"))
            }
            /// Error if this is a `Meta::Path` or `Meta::NameValue`.
            pub fn require_list(&self) -> Result<&MetaList>
            {
                match self {
                    Meta::List(meta) => Ok(meta),
                    Meta::Path(path) => Err(::syntax::error::new2(
                        path.segments.first().unwrap().ident.span(),
                        path.segments.last().unwrap().ident.span(),
                        format!(
                            "expected attribute arguments in parentheses: `{}(...)`",
                            parsing::DisplayPath(path),
                        ),
                    )),
                    Meta::NameValue(meta) => Err(Error::new(meta.eq_token.span, "expected `(`")),
                }
            }
            /// Error if this is a `Meta::Path` or `Meta::List`.
             
                pub fn require_name_value(&self) -> Result<&MetaNameValue>
            {
                match self {
                    Meta::NameValue(meta) => Ok(meta),
                    Meta::Path(path) => Err(::syntax::error::new2(
                        path.segments.first().unwrap().ident.span(),
                        path.segments.last().unwrap().ident.span(),
                        format!(
                            "expected a value for this attribute: `{} = ...`",
                            parsing::DisplayPath(path),
                        ),
                    )),
                    Meta::List(meta) => Err(Error::new(meta.delimiter.span().open(), "expected `=`")),
                }
            }
        }

        impl MetaList 
        {
            /// See [`Attribute::parse_args`].
             
                pub fn parse_args<T: Parse>(&self) -> Result<T>
            {
                self.parse_args_with(T::parse)
            }
            /// See [`Attribute::parse_args_with`].
             
                pub fn parse_args_with<F: Parser>(&self, parser: F) -> Result<F::Output>
            {
                let scope = self.delimiter.span().close();
                ::syntax::parse::parse_scoped(parser, scope, self.tokens.clone())
            }
            /// See [`Attribute::parse_nested_meta`].
             
                pub fn parse_nested_meta(
                &self,
                logic: impl FnMut(ParseNestedMeta) -> Result<()>,
            ) -> Result<()>
            {
                self.parse_args_with(meta::parser(logic))
            }
        }
        
        pub trait FilterAttrs<'a>
        {
            type Ret: Iterator<Item = &'a Attribute>;
            fn outer(self) -> Self::Ret;
            fn inner(self) -> Self::Ret;
        }
        
        impl<'a> FilterAttrs<'a> for &'a [Attribute]
        {
            type Ret = iter::Filter<slice::Iter<'a, Attribute>, fn(&&Attribute) -> bool>;

            fn outer(self) -> Self::Ret
            {
                fn is_outer(attr: &&Attribute) -> bool
                {
                    match attr.style
                    {
                        AttrStyle::Outer => true,
                        AttrStyle::Inner(_) => false,
                    }
                }
                self.iter().filter(is_outer)
            }

                fn inner(self) -> Self::Ret {
                fn is_inner(attr: &&Attribute) -> bool
                {
                    match attr.style {
                        AttrStyle::Inner(_) => true,
                        AttrStyle::Outer => false,
                    }
                }
                self.iter().filter(is_inner)
            }
        }

        impl From<Path> for Meta 
        {
            fn from(meta: Path) -> Meta {
                Meta::Path(meta)
            }
        }

        impl From<MetaList> for Meta 
        {
            fn from(meta: MetaList) -> Meta {
                Meta::List(meta)
            }
        }

        impl From<MetaNameValue> for Meta 
        {
            fn from(meta: MetaNameValue) -> Meta {
                Meta::NameValue(meta)
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                fmt::{self, Display},
                process::macros::{ Ident },
                syntax::
                {
                    attr::{AttrStyle, Attribute, Meta, MetaList, MetaNameValue},
                    error::Result,
                    expr::{Expr, ExprLit},
                    lit::Lit,
                    parse::discouraged::Speculative as _,
                    parse::{Parse, ParseStream},
                    path::Path,
                    mac, token,
                },
                *
            };          

            pub fn parse_inner(input: ParseStream, attrs: &mut Vec<Attribute>) -> Result<()> {
                while input.peek(Token![#]) && input.peek2(Token![!]) {
                    attrs.push(input.call(single_parse_inner)?);
                }
                Ok(())
            }

            pub fn single_parse_inner(input: ParseStream) -> Result<Attribute>
            {
                let content;
                Ok(Attribute {
                    pound_token: input.parse()?,
                    style: AttrStyle::Inner(input.parse()?),
                    bracket_token: bracketed!(content in input),
                    meta: content.parse()?,
                })
            }

            pub fn single_parse_outer(input: ParseStream) -> Result<Attribute>
            {
                let content;
                Ok(Attribute {
                    pound_token: input.parse()?,
                    style: AttrStyle::Outer,
                    bracket_token: bracketed!(content in input),
                    meta: content.parse()?,
                })
            }

            impl Parse for Meta
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let path = parse_outermost_meta_path(input)?;
                    parse_meta_after_path(path, input)
                }
            }

            impl Parse for MetaList
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let path = parse_outermost_meta_path(input)?;
                    parse_meta_list_after_path(path, input)
                }
            }

            impl Parse for MetaNameValue
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let path = parse_outermost_meta_path(input)?;
                    parse_meta_name_value_after_path(path, input)
                }
            }
            
            fn parse_outermost_meta_path(input: ParseStream) -> Result<Path> {
                if input.peek(Token![unsafe]) {
                    let unsafe_token: Token![unsafe] = input.parse()?;
                    Ok(Path::from(Ident::new("unsafe", unsafe_token.span)))
                } else {
                    Path::parse_mod_style(input)
                }
            }

            pub fn parse_meta_after_path(path: Path, input: ParseStream) -> Result<Meta> {
                if input.peek(token::Paren) || input.peek(token::Bracket) || input.peek(token::Brace) {
                    parse_meta_list_after_path(path, input).map(Meta::List)
                } else if input.peek(Token![=]) {
                    parse_meta_name_value_after_path(path, input).map(Meta::NameValue)
                } else {
                    Ok(Meta::Path(path))
                }
            }

            fn parse_meta_list_after_path(path: Path, input: ParseStream) -> Result<MetaList>
            {
                let (delimiter, tokens) = mac::parse_delimiter(input)?;
                Ok(MetaList {
                    path,
                    delimiter,
                    tokens,
                })
            }

            fn parse_meta_name_value_after_path(path: Path, input: ParseStream) -> Result<MetaNameValue>
            {
                let eq_token: Token![=] = input.parse()?;
                let ahead = input.fork();
                let lit: Option<Lit> = ahead.parse()?;
                let value = if let (Some(lit), true) = (lit, ahead.is_empty()) {
                    input.advance_to(&ahead);
                    Expr::Lit(ExprLit {
                        attrs: Vec::new(),
                        lit,
                    })
                } else if input.peek(Token![#]) && input.peek2(token::Bracket) {
                    return Err(input.error("unexpected attribute inside of attribute"));
                } else {
                    input.parse()?
                };
                Ok(MetaNameValue {
                    path,
                    eq_token,
                    value,
                })
            }

            pub struct DisplayAttrStyle<'a>(pub &'a AttrStyle);

            impl<'a> Display for DisplayAttrStyle<'a> {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str(match self.0 {
                        AttrStyle::Outer => "#",
                        AttrStyle::Inner(_) => "#!",
                    })
                }
            }

            pub struct DisplayPath<'a>(pub &'a Path);

            impl<'a> Display for DisplayPath<'a> {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    for (i, segment) in self.0.segments.iter().enumerate() {
                        if i > 0 || self.0.leading_colon.is_some() {
                            formatter.write_str("::")?;
                        }
                        write!(formatter, "{}", segment.ident)?;
                    }
                    Ok(())
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::ToTokens,                
                syntax::
                {
                    attr::{AttrStyle, Attribute, Meta, MetaList, MetaNameValue},
                    path,
                    path::printing::PathStyle,
                },
                *,
            };
            
            impl ToTokens for Attribute 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.pound_token.to_tokens(tokens);
                    if let AttrStyle::Inner(b) = &self.style {
                        b.to_tokens(tokens);
                    }
                    self.bracket_token.surround(tokens, |tokens| {
                        self.meta.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for Meta 
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        Meta::Path(path) => path::printing::print_path(tokens, path, PathStyle::Mod),
                        Meta::List(meta_list) => meta_list.to_tokens(tokens),
                        Meta::NameValue(meta_name_value) => meta_name_value.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for MetaList 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    path::printing::print_path(tokens, &self.path, PathStyle::Mod);
                    self.delimiter.surround(tokens, self.tokens.clone());
                }
            }

            impl ToTokens for MetaNameValue 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    path::printing::print_path(tokens, &self.path, PathStyle::Mod);
                    self.eq_token.to_tokens(tokens);
                    self.value.to_tokens(tokens);
                }
            }
        }
    } pub use self::attr::
    {
        AttrStyle, Attribute, Meta, MetaList, MetaNameValue
    };

    pub mod group
    {
        use ::
        {
            process::macros::
            {
                extra::DelimSpan, Delimiter
            },
            syntax::
            {
                error::{ Result },
                parse::{ ParseBuffer },
                token
            },
            *,
        };
        /*
        */
        pub struct Parens<'a> 
        {
                pub token: token::Paren,
                pub content: ParseBuffer<'a>,
        }
        
        pub struct Braces<'a> {
                pub token: token::Brace,
                pub content: ParseBuffer<'a>,
        }
        
        pub struct Brackets<'a> {
                pub token: token::Bracket,
                pub content: ParseBuffer<'a>,
        }
        
        pub struct Group<'a> {
                pub token: token::Group,
                pub content: ParseBuffer<'a>,
        }
        
        pub fn parse_parens<'a>(input: &ParseBuffer<'a>) -> Result<Parens<'a>> {
            parse_delimited(input, Delimiter::Parenthesis).map(|(span, content)| Parens {
                token: token::Paren(span),
                content,
            })
        }
        
        pub fn parse_braces<'a>(input: &ParseBuffer<'a>) -> Result<Braces<'a>> {
            parse_delimited(input, Delimiter::Brace).map(|(span, content)| Braces {
                token: token::Brace(span),
                content,
            })
        }
        
        pub fn parse_brackets<'a>(input: &ParseBuffer<'a>) -> Result<Brackets<'a>> {
            parse_delimited(input, Delimiter::Bracket).map(|(span, content)| Brackets {
                token: token::Bracket(span),
                content,
            })
        }
        
        pub fn parse_group<'a>(input: &ParseBuffer<'a>) -> Result<Group<'a>> {
            parse_delimited(input, Delimiter::None).map(|(span, content)| Group {
                token: token::Group(span.join()),
                content,
            })
        }

        fn parse_delimited<'a>(
            input: &ParseBuffer<'a>,
            delimiter: Delimiter,
        ) -> Result<(DelimSpan, ParseBuffer<'a>)> {
            input.step(|cursor| {
                if let Some((content, span, rest)) = cursor.group(delimiter) {
                    let scope = span.close();
                    let nested = ::syntax::parse::advance_step_cursor(cursor, content);
                    let unexpected = ::syntax::parse::get_unexpected(input);
                    let content = ::syntax::parse::new_parse_buffer(scope, nested, unexpected);
                    Ok(((span, content), rest))
                } else {
                    let message = match delimiter {
                        Delimiter::Parenthesis => "expected parentheses",
                        Delimiter::Brace => "expected curly braces",
                        Delimiter::Bracket => "expected square brackets",
                        Delimiter::None => "expected invisible group",
                    };
                    Err(cursor.error(message))
                }
            })
        }
    }

    pub mod token
    {
        //! Tokens representing Rust punctuation, keywords, and delimiters.
        use ::
        {
            fmt::{ self, Debug },
            hash::{ Hash, Hasher },
            ops::{ Deref, DerefMut },
            process::macros::
            {
                extra::{ DelimSpan },
                Delimiter, Ident, Literal, Punct, Span, TokenStream, TokenTree
            },
            quote::{ ToTokens, TokenStreamExt },
            syntax::
            {
                buffer::Cursor,
                error::Result,
                lifetime::Lifetime,
                parse::{Parse, ParseStream},
                span::IntoSpans,
            },
            *,
        };
        /*
        */
        pub use self::private::{ CustomToken, WithSpan };

        macro_rules! impl_low_level_token
        {
            ($display:literal $($path:ident)::+ $get:ident) =>
            {
                impl Token for $($path)::+
                {
                    fn peek(cursor: Cursor) -> bool { cursor.$get().is_some() }
                    fn display() -> &'static str { $display }
                }
                
                impl private::Sealed for $($path)::+ {}
            };
        }

        macro_rules! define_keywords
        {
            ($($token:literal pub struct $name:ident)*) => 
            {
                $
                (
                    pub struct $name 
                    {
                        pub span: Span,
                    }
            
                    pub fn $name<S: IntoSpans<Span>>(span: S) -> $name
                    {
                        $name
                        {
                            span: span.into_spans(),
                        }
                    }

                    impl ::default::Default for $name
                    {
                        fn default() -> Self
                        {
                            $name
                            {
                                span: Span::call_site(),
                            }
                        }
                    }
                    
                    impl Copy for $name {}
                    
                    impl Clone for $name
                    {
                        fn clone(&self) -> Self { *self }
                    }

                    impl Debug for $name
                    {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { f.write_str(stringify!($name)) }
                    }

                    impl cmp::Eq for $name {}

                    impl PartialEq for $name
                    {
                        fn eq(&self, _other: &$name) -> bool { true }
                    }

                    impl Hash for $name
                    {
                        fn hash<H: Hasher>(&self, _state: &mut H) {}
                    }
                   
                    impl ToTokens for $name
                    {
                        fn to_tokens(&self, tokens: &mut TokenStream)
                        { printing::keyword($token, self.span, tokens); }
                    }
                    
                    impl Parse for $name
                    {
                        fn parse(input: ParseStream) -> Result<Self>
                        {
                            Ok($name
                            {
                                span: parsing::keyword(input, $token)?,
                            })
                        }
                    }
                    
                    impl Token for $name
                    {
                        fn peek(cursor: Cursor) -> bool { parsing::peek_keyword(cursor, $token) }
                        fn display() -> &'static str { concat!("`", $token, "`") }
                    }
                    
                    impl private::Sealed for $name {}
                )*
            };
        }

        macro_rules! impl_deref_if_len_is_1 
        {
            ($name:ident/1) =>
            {
                impl Deref for $name
                {
                    type Target = WithSpan;

                    fn deref(&self) -> &Self::Target
                    {
                        unsafe { &*(self as *const Self).cast::<WithSpan>() }
                    }
                }
            
            impl DerefMut for $name
                {
                    fn deref_mut(&mut self) -> &mut Self::Target
                    {
                        unsafe { &mut *(self as *mut Self).cast::<WithSpan>() }
                    }
                }
            };

            ($name:ident/$len:literal) => {};
        }

        macro_rules! define_punctuation_structs 
        {
            ($($token:literal pub struct $name:ident/$len:tt #[doc = $usage:literal])*) =>
            {
                $
                (
                    pub struct $name
                    {
                        pub spans: [Span; $len],
                    }
            
                    pub fn $name<S: IntoSpans<[Span; $len]>>(spans: S) -> $name
                    {
                        $name
                        {
                            spans: spans.into_spans(),
                        }
                    }

                    impl ::default::Default for $name
                    {
                        fn default() -> Self
                        {
                            $name
                            {
                                spans: [Span::call_site(); $len],
                            }
                        }
                    }
                    
                    impl Copy for $name {}
                    
                    impl Clone for $name
                    {
                        fn clone(&self) -> Self { *self }
                    }

                    impl Debug for $name
                    {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { f.write_str(stringify!($name)) }
                    }

                    impl cmp::Eq for $name {}

                    impl PartialEq for $name
                    {
                        fn eq(&self, _other: &$name) -> bool { true }
                    }

                    impl Hash for $name
                    {
                        fn hash<H: Hasher>(&self, _state: &mut H) {}
                    }

                    impl_deref_if_len_is_1!($name/$len);
                )*
            };
        }

        macro_rules! define_punctuation 
        {
            ($($token:literal pub struct $name:ident/$len:tt #[doc = $usage:literal])*) =>
            {
                $
                (
                    define_punctuation_structs!
                    {
                        $token pub struct $name/$len #[doc = $usage]
                    }
                   
                    impl ToTokens for $name
                    {
                        fn to_tokens(&self, tokens: &mut TokenStream)
                        { printing::punct($token, &self.spans, tokens); }
                    }
                    
                    impl Parse for $name
                    {
                        fn parse(input: ParseStream) -> Result<Self>
                        {
                            Ok
                            (
                                $name
                                {
                                    spans: parsing::punct(input, $token)?,
                                }
                            )
                        }
                    }
                     
                    impl Token for $name
                    {
                        fn peek(cursor: Cursor) -> bool { parsing::peek_punct(cursor, $token) }
                        fn display() -> &'static str { concat!("`", $token, "`") }
                    }
                     
                    impl private::Sealed for $name {}
                )*
            };
        }

        macro_rules! define_delimiters 
        {
            ($($delim:ident pub struct $name:ident #[$doc:meta])*) =>
            {
                $
                (
                    #[$doc]
                    pub struct $name
                    {
                        pub span: DelimSpan,
                    }
            
                    pub fn $name<S: IntoSpans<DelimSpan>>(span: S) -> $name
                    {
                        $name
                        {
                            span: span.into_spans(),
                        }
                    }

                    impl std::default::Default for $name
                    {
                        fn default() -> Self { $name(Span::call_site()) }
                    }
                    
                    impl Copy for $name {}
                    
                    impl Clone for $name
                    {
                        fn clone(&self) -> Self { *self }
                    }

                    impl Debug for $name
                    {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                        { f.write_str(stringify!($name)) }
                    }

                    impl cmp::Eq for $name {}

                    impl PartialEq for $name
                    {
                        fn eq(&self, _other: &$name) -> bool { true }
                    }

                    impl Hash for $name
                    {
                        fn hash<H: Hasher>(&self, _state: &mut H) {}
                    }

                    impl $name
                    {
                        pub fn surround<F>( &self, tokens:&mut TokenStream, f:F ) where
                        F: FnOnce( &mut TokenStream )
                        {
                            let mut inner = TokenStream::new();
                            f( &mut inner );
                            printing::delim( Delimiter::$delim, self.span.join(), tokens, inner );
                        }
                    }
                    
                    impl private::Sealed for $name {}
                )*
            };
        }
        /// Marker trait for types that represent single tokens.
        pub trait Token: private::Sealed
        {
            fn peek(cursor: Cursor) -> bool;
            fn display() -> &'static str;
        }

        pub mod private
        {
            use ::
            {
                process::macros::Span,
                syntax::buffer::Cursor,
                *,
            };
            
            pub trait Sealed {}
            /// Support writing `token.span` rather than `token.spans[0]` on tokens that hold a single span.
            #[repr(transparent)]
            pub struct WithSpan
            {
                pub span: Span,
            }
            
            pub trait CustomToken
            {
                fn peek(cursor: Cursor) -> bool;
                fn display() -> &'static str;
            }
        }
        
        impl private::Sealed for Ident {}

        impl_low_level_token!("punctuation token" Punct punct);
        impl_low_level_token!("literal" Literal literal);
        impl_low_level_token!("token" TokenTree token_tree);
        impl_low_level_token!("group token" process::macros::Group any_group);
        impl_low_level_token!("lifetime" Lifetime lifetime);
        
        impl<T: CustomToken> private::Sealed for T {}
        impl<T: CustomToken> Token for T
        {
            fn peek(cursor: Cursor) -> bool { <Self as CustomToken>::peek(cursor) }
            fn display() -> &'static str { <Self as CustomToken>::display() }
        }

        define_punctuation_structs! 
        {
            "_" pub struct Underscore/1 /// wildcard patterns, inferred types, unnamed items in constants, extern crates, use declarations, and destructuring assignment
        }
        
        impl ToTokens for Underscore {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(Ident::new("_", self.span));
            }
        }

         
            impl Parse for Underscore {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| {
                    if let Some((ident, rest)) = cursor.ident() {
                        if ident == "_" {
                            return Ok((Underscore(ident.span()), rest));
                        }
                    }
                    if let Some((punct, rest)) = cursor.punct() {
                        if punct.as_char() == '_' {
                            return Ok((Underscore(punct.span()), rest));
                        }
                    }
                    Err(cursor.error("expected `_`"))
                })
            }
        }

         
            impl Token for Underscore {
            fn peek(cursor: Cursor) -> bool
        {
                if let Some((ident, _rest)) = cursor.ident() {
                    return ident == "_";
                }
                if let Some((punct, _rest)) = cursor.punct() {
                    return punct.as_char() == '_';
                }
                false
            }

            fn display() -> &'static str {
                "`_`"
            }
        }

         
            impl private::Sealed for Underscore {}
        /// None-delimited group
        pub struct Group {
            pub span: Span,
        }

        pub fn Group<S: IntoSpans<Span>>(span: S) -> Group {
            Group {
                span: span.into_spans(),
            }
        }

        impl std::default::Default for Group {
            fn default() -> Self {
                Group {
                    span: Span::call_site(),
                }
            }
        }

        impl Copy for Group {}

        impl Clone for Group {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl Debug for Group {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_str("Group")
            }
        }

        impl cmp::Eq for Group {}

        impl PartialEq for Group {
            fn eq(&self, _other: &Group) -> bool
        {
                true
            }
        }

        impl Hash for Group {
            fn hash<H: Hasher>(&self, _state: &mut H) {}
        }

        impl Group
        {
            pub fn surround<F>(&self, tokens: &mut TokenStream, f: F) where
                F: FnOnce(&mut TokenStream),
            {
                let mut inner = TokenStream::new();
                f(&mut inner);
                printing::delim(Delimiter::None, self.span, tokens, inner);
            }
        }

         
            impl private::Sealed for Group {}

         
            impl Token for Paren {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.group(Delimiter::Parenthesis).is_some()
            }

            fn display() -> &'static str {
                "parentheses"
            }
        }

         
            impl Token for Brace {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.group(Delimiter::Brace).is_some()
            }

            fn display() -> &'static str {
                "curly braces"
            }
        }

         
            impl Token for Bracket {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.group(Delimiter::Bracket).is_some()
            }

            fn display() -> &'static str {
                "square brackets"
            }
        }

         
            impl Token for Group {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.group(Delimiter::None).is_some()
            }

            fn display() -> &'static str {
                "invisible group"
            }
        }

        define_keywords! {
            "abstract"    pub struct Abstract
            "as"          pub struct As
            "async"       pub struct Async
            "auto"        pub struct Auto
            "await"       pub struct Await
            "become"      pub struct Become
            "box"         pub struct Box
            "break"       pub struct Break
            "const"       pub struct Const
            "continue"    pub struct Continue
            "crate"       pub struct Crate
            "default"     pub struct Default
            "do"          pub struct Do
            "dyn"         pub struct Dyn
            "else"        pub struct Else
            "enum"        pub struct Enum
            "extern"      pub struct Extern
            "final"       pub struct Final
            "fn"          pub struct Fn
            "for"         pub struct For
            "if"          pub struct If
            "impl"        pub struct Impl
            "in"          pub struct In
            "let"         pub struct Let
            "loop"        pub struct Loop
            "macro"       pub struct Macro
            "match"       pub struct Match
            "mod"         pub struct Mod
            "move"        pub struct Move
            "mut"         pub struct Mut
            "override"    pub struct Override
            "priv"        pub struct Priv
            "pub"         pub struct Pub
            "raw"         pub struct Raw
            "ref"         pub struct Ref
            "return"      pub struct Return
            "Self"        pub struct SelfType
            "self"        pub struct SelfValue
            "static"      pub struct Static
            "struct"      pub struct Struct
            "super"       pub struct Super
            "trait"       pub struct Trait
            "try"         pub struct Try
            "type"        pub struct Type
            "typeof"      pub struct Typeof
            "union"       pub struct Union
            "unsafe"      pub struct Unsafe
            "unsized"     pub struct Unsized
            "use"         pub struct Use
            "virtual"     pub struct Virtual
            "where"       pub struct Where
            "while"       pub struct While
            "yield"       pub struct Yield
        }

        define_punctuation! {
            "&"           pub struct And/1        /// bitwise and logical AND, borrow, references, reference patterns
            "&&"          pub struct AndAnd/2     /// lazy AND, borrow, references, reference patterns
            "&="          pub struct AndEq/2      /// bitwise AND assignment
            "@"           pub struct At/1         /// subpattern binding
            "^"           pub struct Caret/1      /// bitwise and logical XOR
            "^="          pub struct CaretEq/2    /// bitwise XOR assignment
            ":"           pub struct Colon/1      /// various separators
            ","           pub struct Comma/1      /// various separators
            "$"           pub struct Dollar/1     /// macros
            "."           pub struct Dot/1        /// field access, tuple index
            ".."          pub struct DotDot/2     /// range, struct expressions, patterns, range patterns
            "..."         pub struct DotDotDot/3  /// variadic functions, range patterns
            "..="         pub struct DotDotEq/3   /// inclusive range, range patterns
            "="           pub struct Eq/1         /// assignment, attributes, various type definitions
            "=="          pub struct EqEq/2       /// equal
            "=>"          pub struct FatArrow/2   /// match arms, macros
            ">="          pub struct Ge/2         /// greater than or equal to, generics
            ">"           pub struct Gt/1         /// greater than, generics, paths
            "<-"          pub struct LArrow/2     /// unused
            "<="          pub struct Le/2         /// less than or equal to
            "<"           pub struct Lt/1         /// less than, generics, paths
            "-"           pub struct Minus/1      /// subtraction, negation
            "-="          pub struct MinusEq/2    /// subtraction assignment
            "!="          pub struct Ne/2         /// not equal
            "!"           pub struct Not/1        /// bitwise and logical NOT, macro calls, inner attributes, never type, negative impls
            "|"           pub struct Or/1         /// bitwise and logical OR, closures, patterns in match, if let, and while let
            "|="          pub struct OrEq/2       /// bitwise OR assignment
            "||"          pub struct OrOr/2       /// lazy OR, closures
            "::"          pub struct PathSep/2    /// path separator
            "%"           pub struct Percent/1    /// remainder
            "%="          pub struct PercentEq/2  /// remainder assignment
            "+"           pub struct Plus/1       /// addition, trait bounds, macro Kleene matcher
            "+="          pub struct PlusEq/2     /// addition assignment
            "#"           pub struct Pound/1      /// attributes
            "?"           pub struct Question/1   /// question mark operator, questionably sized, macro Kleene matcher
            "->"          pub struct RArrow/2     /// function return type, closure return type, function pointer type
            ";"           pub struct Semi/1       /// terminator for various items and statements, array types
            "<<"          pub struct Shl/2        /// shift left, nested generics
            "<<="         pub struct ShlEq/3      /// shift left assignment
            ">>"          pub struct Shr/2        /// shift right, nested generics
            ">>="         pub struct ShrEq/3      /// shift right assignment, nested generics
            "/"           pub struct Slash/1      /// division
            "/="          pub struct SlashEq/2    /// division assignment
            "*"           pub struct Star/1       /// multiplication, dereference, raw pointers, macro Kleene matcher, use wildcards
            "*="          pub struct StarEq/2     /// multiplication assignment
            "~"           pub struct Tilde/1      /// unused since before Rust 1.0
        }

        define_delimiters! {
            Brace         pub struct Brace        /// `{`&hellip;`}`
            Bracket       pub struct Bracket      /// `[`&hellip;`]`
            Parenthesis   pub struct Paren        /// `(`&hellip;`)`
        }
        /// A type-macro that expands to the name of the Rust type representation of a given token.
        #[macro_export]
        macro_rules! Token {
            [abstract]    => { ::syntax::token::Abstract };
            [as]          => { ::syntax::token::As };
            [async]       => { ::syntax::token::Async };
            [auto]        => { ::syntax::token::Auto };
            [await]       => { ::syntax::token::Await };
            [become]      => { ::syntax::token::Become };
            [box]         => { ::syntax::token::Box };
            [break]       => { ::syntax::token::Break };
            [const]       => { ::syntax::token::Const };
            [continue]    => { ::syntax::token::Continue };
            [crate]       => { ::syntax::token::Crate };
            [default]     => { ::syntax::token::Default };
            [do]          => { ::syntax::token::Do };
            [dyn]         => { ::syntax::token::Dyn };
            [else]        => { ::syntax::token::Else };
            [enum]        => { ::syntax::token::Enum };
            [extern]      => { ::syntax::token::Extern };
            [final]       => { ::syntax::token::Final };
            [fn]          => { ::syntax::token::Fn };
            [for]         => { ::syntax::token::For };
            [if]          => { ::syntax::token::If };
            [impl]        => { ::syntax::token::Impl };
            [in]          => { ::syntax::token::In };
            [let]         => { ::syntax::token::Let };
            [loop]        => { ::syntax::token::Loop };
            [macro]       => { ::syntax::token::Macro };
            [match]       => { ::syntax::token::Match };
            [mod]         => { ::syntax::token::Mod };
            [move]        => { ::syntax::token::Move };
            [mut]         => { ::syntax::token::Mut };
            [override]    => { ::syntax::token::Override };
            [priv]        => { ::syntax::token::Priv };
            [pub]         => { ::syntax::token::Pub };
            [raw]         => { ::syntax::token::Raw };
            [ref]         => { ::syntax::token::Ref };
            [return]      => { ::syntax::token::Return };
            [Self]        => { ::syntax::token::SelfType };
            [self]        => { ::syntax::token::SelfValue };
            [static]      => { ::syntax::token::Static };
            [struct]      => { ::syntax::token::Struct };
            [super]       => { ::syntax::token::Super };
            [trait]       => { ::syntax::token::Trait };
            [try]         => { ::syntax::token::Try };
            [type]        => { ::syntax::token::Type };
            [typeof]      => { ::syntax::token::Typeof };
            [union]       => { ::syntax::token::Union };
            [unsafe]      => { ::syntax::token::Unsafe };
            [unsized]     => { ::syntax::token::Unsized };
            [use]         => { ::syntax::token::Use };
            [virtual]     => { ::syntax::token::Virtual };
            [where]       => { ::syntax::token::Where };
            [while]       => { ::syntax::token::While };
            [yield]       => { ::syntax::token::Yield };
            [&]           => { ::syntax::token::And };
            [&&]          => { ::syntax::token::AndAnd };
            [&=]          => { ::syntax::token::AndEq };
            [@]           => { ::syntax::token::At };
            [^]           => { ::syntax::token::Caret };
            [^=]          => { ::syntax::token::CaretEq };
            [:]           => { ::syntax::token::Colon };
            [,]           => { ::syntax::token::Comma };
            [$]           => { ::syntax::token::Dollar };
            [.]           => { ::syntax::token::Dot };
            [..]          => { ::syntax::token::DotDot };
            [...]         => { ::syntax::token::DotDotDot };
            [..=]         => { ::syntax::token::DotDotEq };
            [=]           => { ::syntax::token::Eq };
            [==]          => { ::syntax::token::EqEq };
            [=>]          => { ::syntax::token::FatArrow };
            [>=]          => { ::syntax::token::Ge };
            [>]           => { ::syntax::token::Gt };
            [<-]          => { ::syntax::token::LArrow };
            [<=]          => { ::syntax::token::Le };
            [<]           => { ::syntax::token::Lt };
            [-]           => { ::syntax::token::Minus };
            [-=]          => { ::syntax::token::MinusEq };
            [!=]          => { ::syntax::token::Ne };
            [!]           => { ::syntax::token::Not };
            [|]           => { ::syntax::token::Or };
            [|=]          => { ::syntax::token::OrEq };
            [||]          => { ::syntax::token::OrOr };
            [::]          => { ::syntax::token::PathSep };
            [%]           => { ::syntax::token::Percent };
            [%=]          => { ::syntax::token::PercentEq };
            [+]           => { ::syntax::token::Plus };
            [+=]          => { ::syntax::token::PlusEq };
            [#]           => { ::syntax::token::Pound };
            [?]           => { ::syntax::token::Question };
            [->]          => { ::syntax::token::RArrow };
            [;]           => { ::syntax::token::Semi };
            [<<]          => { ::syntax::token::Shl };
            [<<=]         => { ::syntax::token::ShlEq };
            [>>]          => { ::syntax::token::Shr };
            [>>=]         => { ::syntax::token::ShrEq };
            [/]           => { ::syntax::token::Slash };
            [/=]          => { ::syntax::token::SlashEq };
            [*]           => { ::syntax::token::Star };
            [*=]          => { ::syntax::token::StarEq };
            [~]           => { ::syntax::token::Tilde };
            [_]           => { ::syntax::token::Underscore };
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::{Spacing, Span},
                syntax::
                {
                    buffer::Cursor,
                    error::{Error, Result},
                    parse::ParseStream,
                },
                *,
            };

            pub fn keyword(input: ParseStream, token: &str) -> Result<Span> {
                input.step(|cursor| {
                    if let Some((ident, rest)) = cursor.ident() {
                        if ident == token {
                            return Ok((ident.span(), rest));
                        }
                    }
                    Err(cursor.error(format!("expected `{}`", token)))
                })
            }

            pub fn peek_keyword(cursor: Cursor, token: &str) -> bool
        {
                if let Some((ident, _rest)) = cursor.ident() {
                    ident == token
                } else {
                    false
                }
            }

                pub fn punct<const N: usize>(input: ParseStream, token: &str) -> Result<[Span; N]>
            {
                let mut spans = [input.span(); N];
                punct_helper(input, token, &mut spans)?;
                Ok(spans)
            }

            fn punct_helper(input: ParseStream, token: &str, spans: &mut [Span]) -> Result<()> {
                input.step(|cursor| {
                    let mut cursor = *cursor;
                    assert_eq!(token.len(), spans.len());

                    for (i, ch) in token.chars().enumerate() {
                        match cursor.punct() {
                            Some((punct, rest)) => {
                                spans[i] = punct.span();
                                if punct.as_char() != ch {
                                    break;
                                } else if i == token.len() - 1 {
                                    return Ok(((), rest));
                                } else if punct.spacing() != Spacing::Joint {
                                    break;
                                }
                                cursor = rest;
                            }
                            None => break,
                        }
                    }

                    Err(Error::new(spans[0], format!("expected `{}`", token)))
                })
            }

                pub fn peek_punct(mut cursor: Cursor, token: &str) -> bool
        {
                for (i, ch) in token.chars().enumerate( )
                {
                    match cursor.punct() {
                        Some((punct, rest)) => {
                            if punct.as_char() != ch {
                                break;
                            } else if i == token.len() - 1 {
                                return true;
                            } else if punct.spacing() != Spacing::Joint {
                                break;
                            }
                            cursor = rest;
                        }
                        None => break,
                    }
                }
                false
            }
        }
        
        pub mod printing
        {
            use ::process::macros::{Delimiter, Group, Ident, Punct, Spacing, Span, TokenStream};
            use ::quote::TokenStreamExt;

                pub fn punct(s: &str, spans: &[Span], tokens: &mut TokenStream)
            {
                assert_eq!(s.len(), spans.len());

                let mut chars = s.chars();
                let mut spans = spans.iter();
                let ch = chars.next_back().unwrap();
                let span = spans.next_back().unwrap();
                for (ch, span) in chars.zip(spans) {
                    let mut op = Punct::new(ch, Spacing::Joint);
                    op.set_span(*span);
                    tokens.append(op);
                }

                let mut op = Punct::new(ch, Spacing::Alone);
                op.set_span(*span);
                tokens.append(op);
            }

            pub fn keyword(s: &str, span: Span, tokens: &mut TokenStream) {
                tokens.append(Ident::new(s, span));
            }

            pub fn delim(
                delim: Delimiter,
                span: Span,
                tokens: &mut TokenStream,
                inner: TokenStream,
            ) {
                let mut g = Group::new(delim, inner);
                g.set_span(span);
                tokens.append(g);
            }
        }
    }

    pub mod bigint
    {
        use ::
        {
            ops::{ AddAssign, MulAssign },
            *,
        };
        
        pub struct BigInt {
            digits: Vec<u8>,
        }

        impl BigInt {
            pub fn new() -> Self {
                BigInt { digits: Vec::new() }
            }

            pub fn to_string(&self) -> String {
                let mut repr = String::with_capacity(self.digits.len());

                let mut has_nonzero = false;
                for digit in self.digits.iter().rev() {
                    has_nonzero |= *digit != 0;
                    if has_nonzero {
                        repr.push((*digit + b'0') as char);
                    }
                }

                if repr.is_empty() {
                    repr.push('0');
                }

                repr
            }

            fn reserve_two_digits(&mut self) {
                let len = self.digits.len();
                let desired =
                    len + !self.digits.ends_with(&[0, 0]) as usize + !self.digits.ends_with(&[0]) as usize;
                self.digits.resize(desired, 0);
            }
        }

        impl AddAssign<u8> for BigInt {
           
            fn add_assign(&mut self, mut increment: u8)
            {
                self.reserve_two_digits();

                let mut i = 0;
                while increment > 0 {
                    let sum = self.digits[i] + increment;
                    self.digits[i] = sum % 10;
                    increment = sum / 10;
                    i += 1;
                }
            }
        }

        impl MulAssign<u8> for BigInt {
           
            fn mul_assign(&mut self, base: u8)
            {
                self.reserve_two_digits();

                let mut carry = 0;
                for digit in &mut self.digits {
                    let prod = *digit * base + carry;
                    *digit = prod % 10;
                    carry = prod / 10;
                }
            }
        }
    }
    
    pub mod buffer
    {
        //! A stably addressed token buffer supporting efficient traversal based on a cheaply copyable cursor.
        use ::
        {
            cmp::{ Ordering },
            marker::{ PhantomData },
            process::macros::
            {
                extra::DelimSpan,
                Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree,
            },
            *,
        };
        /*
        */
        /// Internal type which is used instead of `TokenTree` to represent a token tree within a `TokenBuffer`.
        enum Entry {
           
           
            Group(Group, usize),
            Ident(Ident),
            Punct(Punct),
            Literal(Literal),
           
           
            End(isize, isize),
        }
        /// A buffer that can be efficiently traversed multiple times, 
        /// unlike `TokenStream` which requires a deep copy in order to traverse more than once.
        pub struct TokenBuffer {
           
           
            entries: Box<[Entry]>,
        }

        impl TokenBuffer {
            fn recursive_new(entries: &mut Vec<Entry>, stream: TokenStream) {
                for tt in stream {
                    match tt {
                        TokenTree::Ident(ident) => entries.push(Entry::Ident(ident)),
                        TokenTree::Punct(punct) => entries.push(Entry::Punct(punct)),
                        TokenTree::Literal(literal) => entries.push(Entry::Literal(literal)),
                        TokenTree::Group(group) => {
                            let group_start_index = entries.len();
                            entries.push(Entry::End(0, 0));
                            Self::recursive_new(entries, group.stream());
                            let group_end_index = entries.len();
                            let group_offset = group_end_index - group_start_index;
                            entries.push(Entry::End(
                                -(group_end_index as isize),
                                -(group_offset as isize),
                            ));
                            entries[group_start_index] = Entry::Group(group, group_offset);
                        }
                    }
                }
            }
            /// Creates a `TokenBuffer` containing all the tokens from the input `proc_macro::TokenStream`.
            pub fn new(stream: proc_macro::TokenStream) -> Self {
                Self::new2(stream.into())
            }
            /// Creates a `TokenBuffer` containing all the tokens from the input
            /// `process::macros::TokenStream`.
            pub fn new2(stream: TokenStream) -> Self {
                let mut entries = Vec::new();
                Self::recursive_new(&mut entries, stream);
                entries.push(Entry::End(-(entries.len() as isize), 0));
                Self {
                    entries: entries.into_boxed_slice(),
                }
            }
            /// Creates a cursor referencing the first token in the buffer and able to
            /// traverse until the end of the buffer.
            pub fn begin(&self) -> Cursor {
                let ptr = self.entries.as_ptr();
                unsafe { Cursor::create(ptr, ptr.add(self.entries.len() - 1)) }
            }
        }
        /// A cheaply copyable cursor into a `TokenBuffer`.
        pub struct Cursor<'a> {
           
            ptr: *const Entry,
           
           
            scope: *const Entry,
           
           
            marker: PhantomData<&'a Entry>,
        }

        impl<'a> Cursor<'a> {
            /// Creates a cursor referencing a static empty TokenStream.
            pub fn empty() -> Self {
               
               
               
               
                //
               
               
                struct UnsafeSyncEntry(Entry);
                unsafe impl Sync for UnsafeSyncEntry {}
                static EMPTY_ENTRY: UnsafeSyncEntry = UnsafeSyncEntry(Entry::End(0, 0));

                Cursor {
                    ptr: &EMPTY_ENTRY.0,
                    scope: &EMPTY_ENTRY.0,
                    marker: PhantomData,
                }
            }
            /// This create method intelligently exits non-explicitly-entered
            /// `None`-delimited scopes when the cursor reaches the end of them,
            /// allowing for them to be treated transparently.
            unsafe fn create(mut ptr: *const Entry, scope: *const Entry) -> Self {
               
               
               
               
                while let Entry::End(..) = unsafe { &*ptr } {
                    if ptr::eq(ptr, scope) {
                        break;
                    }
                    ptr = unsafe { ptr.add(1) };
                }

                Cursor {
                    ptr,
                    scope,
                    marker: PhantomData,
                }
            }
            /// Get the current entry.
            fn entry(self) -> &'a Entry {
                unsafe { &*self.ptr }
            }
            /// Bump the cursor to point at the next token after the current one. This
            /// is undefined behavior if the cursor is currently looking at an
            /// `Entry::End`.
            unsafe fn bump_ignore_group(self) -> Cursor<'a> {
                unsafe { Cursor::create(self.ptr.offset(1), self.scope) }
            }
            /// While the cursor is looking at a `None`-delimited group, move it to look
            /// at the first token inside instead. If the group is empty, this will move
            /// the cursor past the `None`-delimited group.
            fn ignore_none(&mut self) {
                while let Entry::Group(group, _) = self.entry() {
                    if group.delimiter() == Delimiter::None {
                        unsafe { *self = self.bump_ignore_group() };
                    } else {
                        break;
                    }
                }
            }
            /// Checks whether the cursor is currently pointing at the end of its valid
            /// scope.
            pub fn eof(self) -> bool
            {
               
                ptr::eq(self.ptr, self.scope)
            }
            /// If the cursor is pointing at a `Ident`, returns it along with a cursor
            /// pointing at the next `TokenTree`.
            pub fn ident(mut self) -> Option<(Ident, Cursor<'a>)>
            {
                self.ignore_none();
                match self.entry() {
                    Entry::Ident(ident) => Some((ident.clone(), unsafe { self.bump_ignore_group() })),
                    _ => None,
                }
            }
            /// If the cursor is pointing at a `Punct`, returns it along with a cursor
            /// pointing at the next `TokenTree`.
            pub fn punct(mut self) -> Option<(Punct, Cursor<'a>)>
            {
                self.ignore_none();
                match self.entry() {
                    Entry::Punct(punct) if punct.as_char() != '\'' => {
                        Some((punct.clone(), unsafe { self.bump_ignore_group() }))
                    }
                    _ => None,
                }
            }
            /// If the cursor is pointing at a `Literal`, return it along with a cursor
            /// pointing at the next `TokenTree`.
            pub fn literal(mut self) -> Option<(Literal, Cursor<'a>)>
            {
                self.ignore_none();
                match self.entry() {
                    Entry::Literal(literal) => Some((literal.clone(), unsafe { self.bump_ignore_group() })),
                    _ => None,
                }
            }
            /// If the cursor is pointing at a `Lifetime`, returns it along with a
            /// cursor pointing at the next `TokenTree`.
            pub fn lifetime(mut self) -> Option<( ::syntax::Lifetime, Cursor<'a>)>
            {
                self.ignore_none();
                match self.entry() {
                    Entry::Punct(punct) if punct.as_char() == '\'' && punct.spacing() == Spacing::Joint => {
                        let next = unsafe { self.bump_ignore_group() };
                        let (ident, rest) = next.ident()?;
                        let lifetime = ::syntax::Lifetime {
                            apostrophe: punct.span(),
                            ident,
                        };
                        Some((lifetime, rest))
                    }
                    _ => None,
                }
            }
            /// If the cursor is pointing at a `Group` with the given delimiter, returns
            /// a cursor into that group and one pointing to the next `TokenTree`.
            pub fn group(mut self, delim: Delimiter) -> Option<(Cursor<'a>, DelimSpan, Cursor<'a>)> {
               
               
               
                if delim != Delimiter::None {
                    self.ignore_none();
                }

                if let Entry::Group(group, end_offset) = self.entry() {
                    if group.delimiter() == delim {
                        let span = group.delim_span();
                        let end_of_group = unsafe { self.ptr.add(*end_offset) };
                        let inside_of_group = unsafe { Cursor::create(self.ptr.add(1), end_of_group) };
                        let after_group = unsafe { Cursor::create(end_of_group, self.scope) };
                        return Some((inside_of_group, span, after_group));
                    }
                }

                None
            }
            /// If the cursor is pointing at a `Group`, returns a cursor into the group
            /// and one pointing to the next `TokenTree`.
            pub fn any_group(self) -> Option<(Cursor<'a>, Delimiter, DelimSpan, Cursor<'a>)> {
                if let Entry::Group(group, end_offset) = self.entry() {
                    let delimiter = group.delimiter();
                    let span = group.delim_span();
                    let end_of_group = unsafe { self.ptr.add(*end_offset) };
                    let inside_of_group = unsafe { Cursor::create(self.ptr.add(1), end_of_group) };
                    let after_group = unsafe { Cursor::create(end_of_group, self.scope) };
                    return Some((inside_of_group, delimiter, span, after_group));
                }

                None
            }

            pub fn any_group_token(self) -> Option<(Group, Cursor<'a>)> {
                if let Entry::Group(group, end_offset) = self.entry() {
                    let end_of_group = unsafe { self.ptr.add(*end_offset) };
                    let after_group = unsafe { Cursor::create(end_of_group, self.scope) };
                    return Some((group.clone(), after_group));
                }

                None
            }
            /// Copies all remaining tokens visible from this cursor into a
            /// `TokenStream`.
            pub fn token_stream(self) -> TokenStream {
                let mut tts = Vec::new();
                let mut cursor = self;
                while let Some((tt, rest)) = cursor.token_tree() {
                    tts.push(tt);
                    cursor = rest;
                }
                tts.into_iter().collect()
            }
            /// If the cursor is pointing at a `TokenTree`, returns it along with a
            /// cursor pointing at the next `TokenTree`.
            pub fn token_tree(self) -> Option<(TokenTree, Cursor<'a>)>
            {
                let (tree, len) = match self.entry() {
                    Entry::Group(group, end_offset) => (group.clone().into(), *end_offset),
                    Entry::Literal(literal) => (literal.clone().into(), 1),
                    Entry::Ident(ident) => (ident.clone().into(), 1),
                    Entry::Punct(punct) => (punct.clone().into(), 1),
                    Entry::End(..) => return None,
                };

                let rest = unsafe { Cursor::create(self.ptr.add(len), self.scope) };
                Some((tree, rest))
            }
            /// Returns the `Span` of the current token, or `Span::call_site()` if this
            /// cursor points to eof.
            pub fn span(mut self) -> Span {
                match self.entry() {
                    Entry::Group(group, _) => group.span(),
                    Entry::Literal(literal) => literal.span(),
                    Entry::Ident(ident) => ident.span(),
                    Entry::Punct(punct) => punct.span(),
                    Entry::End(_, offset) => {
                        self.ptr = unsafe { self.ptr.offset(*offset) };
                        if let Entry::Group(group, _) = self.entry() {
                            group.span_close()
                        } else {
                            Span::call_site()
                        }
                    }
                }
            }
            /// Returns the `Span` of the token immediately prior to the position of
            /// this cursor, or of the current token if there is no previous one.
                pub fn prev_span(mut self) -> Span {
                if start_of_buffer(self) < self.ptr {
                    self.ptr = unsafe { self.ptr.offset(-1) };
                }
                self.span()
            }
            /// Skip over the next token that is not a None-delimited group, without
            /// cloning it. Returns `None` if this cursor points to eof.
            pub fn skip(mut self) -> Option<Cursor<'a>>
            {
                self.ignore_none();

                let len = match self.entry() {
                    Entry::End(..) => return None,

                   
                    Entry::Punct(punct) if punct.as_char() == '\'' && punct.spacing() == Spacing::Joint => {
                        match unsafe { &*self.ptr.add(1) } {
                            Entry::Ident(_) => 2,
                            _ => 1,
                        }
                    }

                    Entry::Group(_, end_offset) => *end_offset,
                    _ => 1,
                };

                Some(unsafe { Cursor::create(self.ptr.add(len), self.scope) })
            }

            pub fn scope_delimiter(self) -> Delimiter {
                match unsafe { &*self.scope } {
                    Entry::End(_, offset) => match unsafe { &*self.scope.offset(*offset) } {
                        Entry::Group(group, _) => group.delimiter(),
                        _ => Delimiter::None,
                    },
                    _ => unreachable!(),
                }
            }
        }

        impl<'a> Copy for Cursor<'a> {}

        impl<'a> Clone for Cursor<'a> {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl<'a> Eq for Cursor<'a> {}

        impl<'a> PartialEq for Cursor<'a> {
            fn eq(&self, other: &Self) -> bool
        {
                ptr::eq(self.ptr, other.ptr)
            }
        }

        impl<'a> PartialOrd for Cursor<'a> {
            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
                if same_buffer(*self, *other) {
                    Some(cmp_assuming_same_buffer(*self, *other))
                } else {
                    None
                }
            }
        }

        pub fn same_scope(a: Cursor, b: Cursor) -> bool
        {
            ptr::eq(a.scope, b.scope)
        }

        pub fn same_buffer(a: Cursor, b: Cursor) -> bool
        {
            ptr::eq(start_of_buffer(a), start_of_buffer(b))
        }

        fn start_of_buffer(cursor: Cursor) -> *const Entry {
            unsafe {
                match &*cursor.scope {
                    Entry::End(offset, _) => cursor.scope.offset(*offset),
                    _ => unreachable!(),
                }
            }
        }

        pub fn cmp_assuming_same_buffer(a: Cursor, b: Cursor) -> Ordering {
            a.ptr.cmp(&b.ptr)
        }

        pub fn open_span_of_group(cursor: Cursor) -> Span {
            match cursor.entry() {
                Entry::Group(group, _) => group.span_open(),
                _ => cursor.span(),
            }
        }
    }
    
    pub mod classify
    {
        use ::
        {
            ops::{ ControlFlow },
            process::macros::{Delimiter, TokenStream, TokenTree},
            syntax::
            {
                expr::Expr,
                generics::TypeParamBound,
                path::{Path, PathArguments},
                punctuated::Punctuated,
                ty::{ReturnType, Type},
            },
            *,
        };
        /*
        
        */
        pub fn requires_semi_to_be_stmt(expr: &Expr) -> bool
        {
            match expr {
                Expr::Macro(expr) => !expr.mac.delimiter.is_brace(),
                _ => requires_comma_to_be_match_arm(expr),
            }
        }

        pub fn requires_comma_to_be_match_arm(expr: &Expr) -> bool
        {
            match expr {
                Expr::If(_)
                | Expr::Match(_)
                | Expr::Block(_) | Expr::Unsafe(_)
                | Expr::While(_)
                | Expr::Loop(_)
                | Expr::ForLoop(_)
                | Expr::TryBlock(_)
                | Expr::Const(_) => false,

                Expr::Array(_)
                | Expr::Assign(_)
                | Expr::Async(_)
                | Expr::Await(_)
                | Expr::Binary(_)
                | Expr::Break(_)
                | Expr::Call(_)
                | Expr::Cast(_)
                | Expr::Closure(_)
                | Expr::Continue(_)
                | Expr::Field(_)
                | Expr::Group(_)
                | Expr::Index(_)
                | Expr::Infer(_)
                | Expr::Let(_)
                | Expr::Lit(_)
                | Expr::Macro(_)
                | Expr::MethodCall(_)
                | Expr::Paren(_)
                | Expr::Path(_)
                | Expr::Range(_)
                | Expr::RawAddr(_)
                | Expr::Reference(_)
                | Expr::Repeat(_)
                | Expr::Return(_)
                | Expr::Struct(_)
                | Expr::Try(_)
                | Expr::Tuple(_)
                | Expr::Unary(_)
                | Expr::Yield(_)
                | Expr::Verbatim(_) => true,
            }
        }
        
        pub fn trailing_unparameterized_path(mut ty: &Type) -> bool
        {
            loop {
                match ty {
                    Type::BareFn(t) => match &t.output {
                        ReturnType::Default => return false,
                        ReturnType::Type(_, ret) => ty = ret,
                    },
                    Type::ImplTrait(t) => match last_type_in_bounds(&t.bounds) {
                        ControlFlow::Break(trailing_path) => return trailing_path,
                        ControlFlow::Continue(t) => ty = t,
                    },
                    Type::Path(t) => match last_type_in_path(&t.path) {
                        ControlFlow::Break(trailing_path) => return trailing_path,
                        ControlFlow::Continue(t) => ty = t,
                    },
                    Type::Ptr(t) => ty = &t.elem,
                    Type::Reference(t) => ty = &t.elem,
                    Type::TraitObject(t) => match last_type_in_bounds(&t.bounds) {
                        ControlFlow::Break(trailing_path) => return trailing_path,
                        ControlFlow::Continue(t) => ty = t,
                    },

                    Type::Array(_)
                    | Type::Group(_)
                    | Type::Infer(_)
                    | Type::Macro(_)
                    | Type::Never(_)
                    | Type::Paren(_)
                    | Type::Slice(_)
                    | Type::Tuple(_)
                    | Type::Verbatim(_) => return false,
                }
            }

            fn last_type_in_path(path: &Path) -> ControlFlow<bool, &Type>
            {
                match &path.segments.last().unwrap().arguments {
                    PathArguments::None => ControlFlow::Break(true),
                    PathArguments::AngleBracketed(_) => ControlFlow::Break(false),
                    PathArguments::Parenthesized(arg) => match &arg.output {
                        ReturnType::Default => ControlFlow::Break(false),
                        ReturnType::Type(_, ret) => ControlFlow::Continue(ret),
                    },
                }
            }

            fn last_type_in_bounds(
                bounds: &Punctuated<TypeParamBound, Token![+]>,
            ) -> ControlFlow<bool, &Type>
            {
                match bounds.last().unwrap() {
                    TypeParamBound::Trait(t) => last_type_in_path(&t.path),
                    TypeParamBound::Lifetime(_)
                    | TypeParamBound::PreciseCapture(_)
                    | TypeParamBound::Verbatim(_) => ControlFlow::Break(false),
                }
            }
        }
        /// Whether the expression's first token is the label of a loop/block.
        pub fn expr_leading_label(mut expr: &Expr) -> bool
        {
            loop {
                match expr {
                    Expr::Block(e) => return e.label.is_some(),
                    Expr::ForLoop(e) => return e.label.is_some(),
                    Expr::Loop(e) => return e.label.is_some(),
                    Expr::While(e) => return e.label.is_some(),

                    Expr::Assign(e) => expr = &e.left,
                    Expr::Await(e) => expr = &e.base,
                    Expr::Binary(e) => expr = &e.left,
                    Expr::Call(e) => expr = &e.func,
                    Expr::Cast(e) => expr = &e.expr,
                    Expr::Field(e) => expr = &e.base,
                    Expr::Index(e) => expr = &e.expr,
                    Expr::MethodCall(e) => expr = &e.receiver,
                    Expr::Range(e) => match &e.start {
                        Some(start) => expr = start,
                        None => return false,
                    },
                    Expr::Try(e) => expr = &e.expr,

                    Expr::Array(_)
                    | Expr::Async(_)
                    | Expr::Break(_)
                    | Expr::Closure(_)
                    | Expr::Const(_)
                    | Expr::Continue(_)
                    | Expr::Group(_)
                    | Expr::If(_)
                    | Expr::Infer(_)
                    | Expr::Let(_)
                    | Expr::Lit(_)
                    | Expr::Macro(_)
                    | Expr::Match(_)
                    | Expr::Paren(_)
                    | Expr::Path(_)
                    | Expr::RawAddr(_)
                    | Expr::Reference(_)
                    | Expr::Repeat(_)
                    | Expr::Return(_)
                    | Expr::Struct(_)
                    | Expr::TryBlock(_)
                    | Expr::Tuple(_)
                    | Expr::Unary(_)
                    | Expr::Unsafe(_)
                    | Expr::Verbatim(_)
                    | Expr::Yield(_) => return false,
                }
            }
        }
        /// Whether the expression's last token is `}`.
        pub fn expr_trailing_brace(mut expr: &Expr) -> bool
        {
            loop {
                match expr {
                    Expr::Async(_)
                    | Expr::Block(_)
                    | Expr::Const(_)
                    | Expr::ForLoop(_)
                    | Expr::If(_)
                    | Expr::Loop(_)
                    | Expr::Match(_)
                    | Expr::Struct(_)
                    | Expr::TryBlock(_)
                    | Expr::Unsafe(_)
                    | Expr::While(_) => return true,

                    Expr::Assign(e) => expr = &e.right,
                    Expr::Binary(e) => expr = &e.right,
                    Expr::Break(e) => match &e.expr {
                        Some(e) => expr = e,
                        None => return false,
                    },
                    Expr::Cast(e) => return type_trailing_brace(&e.ty),
                    Expr::Closure(e) => expr = &e.body,
                    Expr::Let(e) => expr = &e.expr,
                    Expr::Macro(e) => return e.mac.delimiter.is_brace(),
                    Expr::Range(e) => match &e.end {
                        Some(end) => expr = end,
                        None => return false,
                    },
                    Expr::RawAddr(e) => expr = &e.expr,
                    Expr::Reference(e) => expr = &e.expr,
                    Expr::Return(e) => match &e.expr {
                        Some(e) => expr = e,
                        None => return false,
                    },
                    Expr::Unary(e) => expr = &e.expr,
                    Expr::Verbatim(e) => return tokens_trailing_brace(e),
                    Expr::Yield(e) => match &e.expr {
                        Some(e) => expr = e,
                        None => return false,
                    },

                    Expr::Array(_)
                    | Expr::Await(_)
                    | Expr::Call(_)
                    | Expr::Continue(_)
                    | Expr::Field(_)
                    | Expr::Group(_)
                    | Expr::Index(_)
                    | Expr::Infer(_)
                    | Expr::Lit(_)
                    | Expr::MethodCall(_)
                    | Expr::Paren(_)
                    | Expr::Path(_)
                    | Expr::Repeat(_)
                    | Expr::Try(_)
                    | Expr::Tuple(_) => return false,
                }
            }

            fn type_trailing_brace(mut ty: &Type) -> bool
        {
                loop {
                    match ty {
                        Type::BareFn(t) => match &t.output {
                            ReturnType::Default => return false,
                            ReturnType::Type(_, ret) => ty = ret,
                        },
                        Type::ImplTrait(t) => match last_type_in_bounds(&t.bounds) {
                            ControlFlow::Break(trailing_brace) => return trailing_brace,
                            ControlFlow::Continue(t) => ty = t,
                        },
                        Type::Macro(t) => return t.mac.delimiter.is_brace(),
                        Type::Path(t) => match last_type_in_path(&t.path) {
                            Some(t) => ty = t,
                            None => return false,
                        },
                        Type::Ptr(t) => ty = &t.elem,
                        Type::Reference(t) => ty = &t.elem,
                        Type::TraitObject(t) => match last_type_in_bounds(&t.bounds) {
                            ControlFlow::Break(trailing_brace) => return trailing_brace,
                            ControlFlow::Continue(t) => ty = t,
                        },
                        Type::Verbatim(t) => return tokens_trailing_brace(t),

                        Type::Array(_)
                        | Type::Group(_)
                        | Type::Infer(_)
                        | Type::Never(_)
                        | Type::Paren(_)
                        | Type::Slice(_)
                        | Type::Tuple(_) => return false,
                    }
                }
            }

            fn last_type_in_path(path: &Path) -> Option<&Type>
            {
                match &path.segments.last().unwrap().arguments {
                    PathArguments::None | PathArguments::AngleBracketed(_) => None,
                    PathArguments::Parenthesized(arg) => match &arg.output {
                        ReturnType::Default => None,
                        ReturnType::Type(_, ret) => Some(ret),
                    },
                }
            }

            fn last_type_in_bounds(
                bounds: &Punctuated<TypeParamBound, Token![+]>,
            ) -> ControlFlow<bool, &Type>
            {
                match bounds.last().unwrap() {
                    TypeParamBound::Trait(t) => match last_type_in_path(&t.path) {
                        Some(t) => ControlFlow::Continue(t),
                        None => ControlFlow::Break(false),
                    },
                    TypeParamBound::Lifetime(_) | TypeParamBound::PreciseCapture(_) => {
                        ControlFlow::Break(false)
                    }
                    TypeParamBound::Verbatim(t) => ControlFlow::Break(tokens_trailing_brace(t)),
                }
            }

            fn tokens_trailing_brace(tokens: &TokenStream) -> bool
        {
                if let Some(TokenTree::Group(last)) = tokens.clone().into_iter().last() {
                    last.delimiter() == Delimiter::Brace
                } else {
                    false
                }
            }
        }
    }
        
    pub mod data
    {
        use ::
        {
            syntax::
            {
                attr::Attribute,
                expr::{Expr, Index, Member},
                ident::Ident,
                punctuated::{self, Punctuated},
                restriction::{FieldMutability, Visibility},
                token,
                ty::Type,
            },
            *,
        };
        /*
        */
        ast_struct! {
            /// An enum variant.
            pub struct Variant {
                pub attrs: Vec<Attribute>,
                /// Name of the variant.
                pub ident: Ident,
                /// Content stored in the variant.
                pub fields: Fields,
                /// Explicit discriminant: `Variant = 1`
                pub discriminant: Option<(Token![=], Expr)>,
            }
        }

        ast_enum_of_structs! {
            /// Data stored within an enum variant or struct.
            pub enum Fields {
                /// Named fields of a struct or struct variant such as `Point { x: f64,
                /// y: f64 }`.
                Named(FieldsNamed),
                /// Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.
                Unnamed(FieldsUnnamed),
                /// Unit struct or unit variant such as `None`.
                Unit,
            }
        }

        ast_struct! {
            /// Named fields of a struct or struct variant such as `Point { x: f64,
            /// y: f64 }`.
            pub struct FieldsNamed {
                pub brace_token: token::Brace,
                pub named: Punctuated<Field, Token![,]>,
            }
        }

        ast_struct! {
            /// Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.
            pub struct FieldsUnnamed {
                pub paren_token: token::Paren,
                pub unnamed: Punctuated<Field, Token![,]>,
            }
        }

        impl Fields
        {
            /// Get an iterator over the borrowed [`Field`] items in this object.
            pub fn iter(&self) -> punctuated::Iter<Field>
            {
                match self {
                    Fields::Unit => ::syntax::punctuated::empty_punctuated_iter(),
                    Fields::Named(f) => f.named.iter(),
                    Fields::Unnamed(f) => f.unnamed.iter(),
                }
            }
            /// Get an iterator over the mutably borrowed [`Field`] items in this object.
            pub fn iter_mut(&mut self) -> punctuated::IterMut<Field>
            {
                match self {
                    Fields::Unit => ::syntax::punctuated::empty_punctuated_iter_mut(),
                    Fields::Named(f) => f.named.iter_mut(),
                    Fields::Unnamed(f) => f.unnamed.iter_mut(),
                }
            }
            /// Returns the number of fields.
            pub fn len(&self) -> usize {
                match self {
                    Fields::Unit => 0,
                    Fields::Named(f) => f.named.len(),
                    Fields::Unnamed(f) => f.unnamed.len(),
                }
            }
            /// Returns `true` if there are zero fields.
            pub fn is_empty(&self) -> bool
            {
                match self {
                    Fields::Unit => true,
                    Fields::Named(f) => f.named.is_empty(),
                    Fields::Unnamed(f) => f.unnamed.is_empty(),
                }
            }

            return_impl_trait!
            {
                /// Get an iterator over the fields of a struct or variant as [`Member`]s.
                pub fn members(&self) -> impl Iterator<Item = Member> + Clone + '_ [Members] {
                    Members {
                        fields: self.iter(),
                        index: 0,
                    }
                }
            }
        }

        impl IntoIterator for Fields {
            type Item = Field;
            type IntoIter = punctuated::IntoIter<Field>;

            fn into_iter(self) -> Self::IntoIter {
                match self {
                    Fields::Unit => Punctuated::<Field, ()>::new().into_iter(),
                    Fields::Named(f) => f.named.into_iter(),
                    Fields::Unnamed(f) => f.unnamed.into_iter(),
                }
            }
        }

        impl<'a> IntoIterator for &'a Fields {
            type Item = &'a Field;
            type IntoIter = punctuated::Iter<'a, Field>;

            fn into_iter(self) -> Self::IntoIter
            {
                self.iter()
            }
        }

        impl<'a> IntoIterator for &'a mut Fields {
            type Item = &'a mut Field;
            type IntoIter = punctuated::IterMut<'a, Field>;

            fn into_iter(self) -> Self::IntoIter
            {
                self.iter_mut()
            }
        }

        ast_struct! {
            /// A field of a struct or enum variant.
            pub struct Field {
                pub attrs: Vec<Attribute>,

                pub vis: Visibility,

                pub mutability: FieldMutability,
                /// Name of the field, if any.
                pub ident: Option<Ident>,

                pub colon_token: Option<Token![:]>,

                pub ty: Type,
            }
        }

        pub struct Members<'a> {
            fields: punctuated::Iter<'a, Field>,
            index: u32,
        }

        impl<'a> Iterator for Members<'a> {
            type Item = Member;

            fn next(&mut self) -> Option<Self::Item>
            {
                let field = self.fields.next()?;
                let member = match &field.ident {
                    Some(ident) => Member::Named(ident.clone()),
                    None => {
                        #[cfg(all(feature = "parsing", feature = "printing"))]
                        let span = ::syntax::spanned::Spanned::span(&field.ty);
                        #[cfg(not(all(feature = "parsing", feature = "printing")))]
                        let span = process::macros::Span::call_site();
                        Member::Unnamed(Index {
                            index: self.index,
                            span,
                        })
                    }
                };
                self.index += 1;
                Some(member)
            }
        }

        impl<'a> Clone for Members<'a> {
            fn clone(&self) -> Self {
                Members {
                    fields: self.fields.clone(),
                    index: self.index,
                }
            }
        }

        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    attr::Attribute,
                    data::{Field, Fields, FieldsNamed, FieldsUnnamed, Variant},
                    error::Result,
                    expr::Expr,
                    ext::IdentExt as _,
                    ident::Ident,
                    parse::{Parse, ParseStream},
                    restriction::{FieldMutability, Visibility},
                    token,
                    ty::Type,
                    verbatim,
                },
                *,
            };
            
            impl Parse for Variant
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let _visibility: Visibility = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let fields = if input.peek(token::Brace) {
                        Fields::Named(input.parse()?)
                    } else if input.peek(token::Paren) {
                        Fields::Unnamed(input.parse()?)
                    } else {
                        Fields::Unit
                    };
                    let discriminant = if input.peek(Token![=]) {
                        let eq_token: Token![=] = input.parse()?;
                                        let discriminant: Expr = input.parse()?;
                        Some((eq_token, discriminant))
                    } else {
                        None
                    };
                    Ok(Variant {
                        attrs,
                        ident,
                        fields,
                        discriminant,
                    })
                }
            }

            impl Parse for FieldsNamed
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(FieldsNamed {
                        brace_token: braced!(content in input),
                        named: content.parse_terminated(Field::parse_named, Token![,])?,
                    })
                }
            }

            impl Parse for FieldsUnnamed
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(FieldsUnnamed {
                        paren_token: parenthesized!(content in input),
                        unnamed: content.parse_terminated(Field::parse_unnamed, Token![,])?,
                    })
                }
            }

            impl Field {
                /// Parses a named (braced struct) field.
                    pub fn parse_named(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;

                    let unnamed_field = cfg!(feature = "full") && input.peek(Token![_]);
                    let ident = if unnamed_field {
                        input.call(Ident::parse_any)
                    } else {
                        input.parse()
                    }?;

                    let colon_token: Token![:] = input.parse()?;

                    let ty: Type = if unnamed_field
                        && (input.peek(Token![struct])
                            || input.peek(Token![union]) && input.peek2(token::Brace))
                    {
                        let begin = input.fork();
                        input.call(Ident::parse_any)?;
                        input.parse::<FieldsNamed>()?;
                        Type::Verbatim(verbatim::between(&begin, input))
                    } else {
                        input.parse()?
                    };

                    Ok(Field {
                        attrs,
                        vis,
                        mutability: FieldMutability::None,
                        ident: Some(ident),
                        colon_token: Some(colon_token),
                        ty,
                    })
                }
                /// Parses an unnamed (tuple struct) field.
                    pub fn parse_unnamed(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (Field {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        mutability: FieldMutability::None,
                        ident: None,
                        colon_token: None,
                        ty: input.parse()?,
                    })
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    data::{Field, FieldsNamed, FieldsUnnamed, Variant},
                    print::TokensOrDefault,
                },
                *,
            };

            impl ToTokens for Variant {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(&self.attrs);
                    self.ident.to_tokens(tokens);
                    self.fields.to_tokens(tokens);
                    if let Some((eq_token, disc)) = &self.discriminant {
                        eq_token.to_tokens(tokens);
                        disc.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for FieldsNamed {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.brace_token.surround(tokens, |tokens| {
                        self.named.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for FieldsUnnamed {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.paren_token.surround(tokens, |tokens| {
                        self.unnamed.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for Field {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(&self.attrs);
                    self.vis.to_tokens(tokens);
                    if let Some(ident) = &self.ident {
                        ident.to_tokens(tokens);
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                    }
                    self.ty.to_tokens(tokens);
                }
            }
        }
    } pub use self::data::{Field, Fields, FieldsNamed, FieldsUnnamed, Variant};
    
    pub mod derive
    {
        use ::
        {
            syntax::
            {
                attr::Attribute,
                data::{ Fields, FieldsNamed, Variant },
                generics::Generics,
                ident::Ident,
                punctuated::Punctuated,
                restriction::Visibility,
                token,
            },
            *,
        };
        /*
        */
        ast_struct!
        {
            /// Data structure sent to a `proc_macro_derive` macro.
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub struct DeriveInput {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub ident: Ident,
                pub generics: Generics,
                pub data: Data,
            }
        }

        ast_enum! 
        {
            /// The storage of a struct, enum or union data structure.
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub enum Data {
                Struct(DataStruct),
                Enum(DataEnum),
                Union(DataUnion),
            }
        }

        ast_struct! 
        {
            /// A struct input to a `proc_macro_derive` macro.
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub struct DataStruct {
                pub struct_token: Token![struct],
                pub fields: Fields,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// An enum input to a `proc_macro_derive` macro.
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub struct DataEnum {
                pub enum_token: Token![enum],
                pub brace_token: token::Brace,
                pub variants: Punctuated<Variant, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// An untagged union input to a `proc_macro_derive` macro.
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub struct DataUnion {
                pub union_token: Token![union],
                pub fields: FieldsNamed,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    attr::Attribute,
                    data::{Fields, FieldsNamed, Variant},
                    derive::{Data, DataEnum, DataStruct, DataUnion, DeriveInput},
                    error::Result,
                    generics::{Generics, WhereClause},
                    ident::Ident,
                    parse::{Parse, ParseStream},
                    punctuated::Punctuated,
                    restriction::Visibility,
                    token,
                },
                *,
            };
            
            impl Parse for DeriveInput
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis = input.parse::<Visibility>()?;

                    let lookahead = input.lookahead1();
                    if lookahead.peek(Token![struct]) {
                        let struct_token = input.parse::<Token![struct]>()?;
                        let ident = input.parse::<Ident>()?;
                        let generics = input.parse::<Generics>()?;
                        let (where_clause, fields, semi) = data_struct(input)?;
                        Ok(DeriveInput {
                            attrs,
                            vis,
                            ident,
                            generics: Generics {
                                where_clause,
                                ..generics
                            },
                            data: Data::Struct(DataStruct {
                                struct_token,
                                fields,
                                semi_token: semi,
                            }),
                        })
                    } else if lookahead.peek(Token![enum]) {
                        let enum_token = input.parse::<Token![enum]>()?;
                        let ident = input.parse::<Ident>()?;
                        let generics = input.parse::<Generics>()?;
                        let (where_clause, brace, variants) = data_enum(input)?;
                        Ok(DeriveInput {
                            attrs,
                            vis,
                            ident,
                            generics: Generics {
                                where_clause,
                                ..generics
                            },
                            data: Data::Enum(DataEnum {
                                enum_token,
                                brace_token: brace,
                                variants,
                            }),
                        })
                    } else if lookahead.peek(Token![union]) {
                        let union_token = input.parse::<Token![union]>()?;
                        let ident = input.parse::<Ident>()?;
                        let generics = input.parse::<Generics>()?;
                        let (where_clause, fields) = data_union(input)?;
                        Ok(DeriveInput {
                            attrs,
                            vis,
                            ident,
                            generics: Generics {
                                where_clause,
                                ..generics
                            },
                            data: Data::Union(DataUnion {
                                union_token,
                                fields,
                            }),
                        })
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            pub fn data_struct(
                input: ParseStream,
            ) -> Result<(Option<WhereClause>, Fields, Option<Token![;]>)>
            {
                let mut lookahead = input.lookahead1();
                let mut where_clause = None;
                if lookahead.peek(Token![where]) {
                    where_clause = Some(input.parse()?);
                    lookahead = input.lookahead1();
                }

                if where_clause.is_none() && lookahead.peek(token::Paren) {
                    let fields = input.parse()?;

                    lookahead = input.lookahead1();
                    if lookahead.peek(Token![where]) {
                        where_clause = Some(input.parse()?);
                        lookahead = input.lookahead1();
                    }

                    if lookahead.peek(Token![;]) {
                        let semi = input.parse()?;
                        Ok((where_clause, Fields::Unnamed(fields), Some(semi)))
                    } else {
                        Err(lookahead.error())
                    }
                } else if lookahead.peek(token::Brace) {
                    let fields = input.parse()?;
                    Ok((where_clause, Fields::Named(fields), None))
                } else if lookahead.peek(Token![;]) {
                    let semi = input.parse()?;
                    Ok((where_clause, Fields::Unit, Some(semi)))
                } else {
                    Err(lookahead.error())
                }
            }

            pub fn data_enum(
                input: ParseStream,
            ) -> Result<(
                Option<WhereClause>,
                token::Brace,
                Punctuated<Variant, Token![,]>,
            )>
            {
                let where_clause = input.parse()?;

                let content;
                let brace = braced!(content in input);
                let variants = content.parse_terminated(Variant::parse, Token![,])?;

                Ok((where_clause, brace, variants))
            }

            pub fn data_union(input: ParseStream) -> Result<(Option<WhereClause>, FieldsNamed)>
            {
                let where_clause = input.parse()?;
                let fields = input.parse()?;
                Ok((where_clause, fields))
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::ToTokens,
                syntax::
                {
                    attr::FilterAttrs,
                    data::Fields,
                    derive::{Data, DeriveInput},
                    print::TokensOrDefault,
                },
                *,
            };
            
            impl ToTokens for DeriveInput {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    for attr in self.attrs.outer() {
                        attr.to_tokens(tokens);
                    }
                    self.vis.to_tokens(tokens);
                    match &self.data {
                        Data::Struct(d) => d.struct_token.to_tokens(tokens),
                        Data::Enum(d) => d.enum_token.to_tokens(tokens),
                        Data::Union(d) => d.union_token.to_tokens(tokens),
                    }
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    match &self.data {
                        Data::Struct(data) => match &data.fields {
                            Fields::Named(fields) => {
                                self.generics.where_clause.to_tokens(tokens);
                                fields.to_tokens(tokens);
                            }
                            Fields::Unnamed(fields) => {
                                fields.to_tokens(tokens);
                                self.generics.where_clause.to_tokens(tokens);
                                TokensOrDefault(&data.semi_token).to_tokens(tokens);
                            }
                            Fields::Unit => {
                                self.generics.where_clause.to_tokens(tokens);
                                TokensOrDefault(&data.semi_token).to_tokens(tokens);
                            }
                        },
                        Data::Enum(data) => {
                            self.generics.where_clause.to_tokens(tokens);
                            data.brace_token.surround(tokens, |tokens| {
                                data.variants.to_tokens(tokens);
                            });
                        }
                        Data::Union(data) => {
                            self.generics.where_clause.to_tokens(tokens);
                            data.fields.to_tokens(tokens);
                        }
                    }
                }
            }
        }
    } pub use self::derive::{Data, DataEnum, DataStruct, DataUnion, DeriveInput};

    pub mod drops
    {
        use ::
        {
            mem::{ ManuallyDrop },
            ops::{ Deref, DerefMut },
            *,
        };
        /*
        */
        #[repr(transparent)]
        pub struct NoDrop<T: ?Sized>(ManuallyDrop<T>);

        impl<T> NoDrop<T>
        {
            pub fn new(value: T) -> Self
            where
                T: TrivialDrop,
            {
                NoDrop(ManuallyDrop::new(value))
            }
        }

        impl<T: ?Sized> Deref for NoDrop<T> {
            type Target = T;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }

        impl<T: ?Sized> DerefMut for NoDrop<T> {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }

        pub trait TrivialDrop {}

        impl<T> TrivialDrop for iter::Empty<T> {}
        impl<T> TrivialDrop for slice::Iter<'_, T> {}
        impl<T> TrivialDrop for slice::IterMut<'_, T> {}
        impl<T> TrivialDrop for option::IntoIter<&T> {}
        impl<T> TrivialDrop for option::IntoIter<&mut T> {}
    }

    pub mod error
    {
        use ::
        {
            fmt::{ self, Debug, Display },
            iter::{ FromIterator },
            process::macros::
            {
                Delimiter, Group, Ident, LexError, Literal, Punct, Spacing, Span, TokenStream, TokenTree
            },
            quote::{ ToTokens },
            syntax::
            {
                buffer::Cursor,
                thread::ThreadBound,
            },
            *,
        };
        /*
        */
        /// The result of a Syn parser.
        pub type Result<T> = ::result::Result<T, Error>;

        /// Error returned when a Syn parser cannot parse the input tokens.
        pub struct Error {
            messages: Vec<ErrorMessage>,
        }

        struct ErrorMessage
        {
            span: ThreadBound<SpanRange>,
            message: String,
        }

       
       
       
        struct SpanRange {
            start: Span,
            end: Span,
        }
        

        impl Error {
            /// Usually the [`ParseStream::error`] method will be used instead, which
            /// automatically uses the correct span from the current position of the
            /// parse stream.
            pub fn new<T: Display>(span: Span, message: T) -> Self {
                return new(span, message.to_string());

                fn new(span: Span, message: String) -> Error {
                    Error {
                        messages: vec![ErrorMessage {
                            span: ThreadBound::new(SpanRange {
                                start: span,
                                end: span,
                            }),
                            message,
                        }],
                    }
                }
            }
            /// Creates an error with the specified message spanning the given syntax
            /// tree node.
            pub fn new_spanned<T: ToTokens, U: Display>(tokens: T, message: U) -> Self {
                return new_spanned(tokens.into_token_stream(), message.to_string());

                fn new_spanned(tokens: TokenStream, message: String) -> Error {
                    let mut iter = tokens.into_iter();
                    let start = iter.next().map_or_else(Span::call_site, |t| t.span());
                    let end = iter.last().map_or(start, |t| t.span());
                    Error {
                        messages: vec![ErrorMessage {
                            span: ThreadBound::new(SpanRange { start, end }),
                            message,
                        }],
                    }
                }
            }
            /// The source location of the error.
            pub fn span(&self) -> Span {
                let SpanRange { start, end } = match self.messages[0].span.get() {
                    Some(span) => *span,
                    None => return Span::call_site(),
                };
                start.join(end).unwrap_or(start)
            }
            /// Render the error as an invocation of [`compile_error!`].
            pub fn to_compile_error(&self) -> TokenStream
            {
                self.messages
                    .iter()
                    .map(ErrorMessage::to_compile_error)
                    .collect()
            }
            /// Render the error as an invocation of [`compile_error!`].
            pub fn into_compile_error(self) -> TokenStream
            {
                self.to_compile_error()
            }
            /// Add another error message to self such that when `to_compile_error()` is
            /// called, both errors will be emitted together.
            pub fn combine(&mut self, another: Error)
            {
                self.messages.extend(another.messages);
            }
        }

        impl ErrorMessage {
            fn to_compile_error(&self) -> TokenStream {
                let (start, end) = match self.span.get() {
                    Some(range) => (range.start, range.end),
                    None => (Span::call_site(), Span::call_site()),
                };

               
                TokenStream::from_iter([
                    TokenTree::Punct({
                        let mut punct = Punct::new(':', Spacing::Joint);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Punct({
                        let mut punct = Punct::new(':', Spacing::Alone);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Ident(Ident::new("core", start)),
                    TokenTree::Punct({
                        let mut punct = Punct::new(':', Spacing::Joint);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Punct({
                        let mut punct = Punct::new(':', Spacing::Alone);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Ident(Ident::new("compile_error", start)),
                    TokenTree::Punct({
                        let mut punct = Punct::new('!', Spacing::Alone);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Group({
                        let mut group = Group::new(Delimiter::Brace, {
                            TokenStream::from_iter([TokenTree::Literal({
                                let mut string = Literal::string(&self.message);
                                string.set_span(end);
                                string
                            })])
                        });
                        group.set_span(end);
                        group
                    }),
                ])
            }
        }

         
            pub fn new_at<T: Display>(scope: Span, cursor: Cursor, message: T) -> Error {
            if cursor.eof() {
                Error::new(scope, format!("unexpected end of input, {}", message))
            } else {
                let span = ::syntax::buffer::open_span_of_group(cursor);
                Error::new(span, message)
            }
        }
        
        pub fn new2<T: Display>(start: Span, end: Span, message: T) -> Error
        {
            return new2(start, end, message.to_string());

            fn new2(start: Span, end: Span, message: String) -> Error
            {
                Error {
                    messages: vec![ErrorMessage {
                        span: ThreadBound::new(SpanRange { start, end }),
                        message,
                    }],
                }
            }
        }

        impl Debug for Error {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                if self.messages.len() == 1 {
                    formatter
                        .debug_tuple("Error")
                        .field(&self.messages[0])
                        .finish()
                } else {
                    formatter
                        .debug_tuple("Error")
                        .field(&self.messages)
                        .finish()
                }
            }
        }

        impl Debug for ErrorMessage {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.message, formatter)
            }
        }

        impl Display for Error {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str(&self.messages[0].message)
            }
        }

        impl Clone for Error {
            fn clone(&self) -> Self {
                Error {
                    messages: self.messages.clone(),
                }
            }
        }

        impl Clone for ErrorMessage {
            fn clone(&self) -> Self {
                ErrorMessage {
                    span: self.span,
                    message: self.message.clone(),
                }
            }
        }

        impl Clone for SpanRange {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl Copy for SpanRange {}

        impl std::error::Error for Error {}

        impl From<LexError> for Error {
            fn from(err: LexError) -> Self {
                Error::new(err.span(), err)
            }
        }

        impl IntoIterator for Error {
            type Item = Error;
            type IntoIter = IntoIter;

            fn into_iter(self) -> Self::IntoIter {
                IntoIter {
                    messages: self.messages.into_iter(),
                }
            }
        }

        pub struct IntoIter {
            messages: vec::IntoIter<ErrorMessage>,
        }

        impl Iterator for IntoIter {
            type Item = Error;

            fn next(&mut self) -> Option<Self::Item> {
                Some(Error {
                    messages: vec![self.messages.next()?],
                })
            }
        }

        impl<'a> IntoIterator for &'a Error {
            type Item = Error;
            type IntoIter = Iter<'a>;

            fn into_iter(self) -> Self::IntoIter {
                Iter {
                    messages: self.messages.iter(),
                }
            }
        }

        pub struct Iter<'a> {
            messages: slice::Iter<'a, ErrorMessage>,
        }

        impl<'a> Iterator for Iter<'a> {
            type Item = Error;

            fn next(&mut self) -> Option<Self::Item> {
                Some(Error {
                    messages: vec![self.messages.next()?.clone()],
                })
            }
        }

        impl Extend<Error> for Error {
            fn extend<T: IntoIterator<Item = Error>>(&mut self, iter: T) {
                for err in iter {
                    self.combine(err);
                }
            }
        }
    } pub use self::error::{Error, Result};
    
    pub mod expr
    {
        use ::
        {
            fmt::{ self, Display },
            hash::{ Hash, Hasher },
            process::macros::{ Span, TokenStream },
            quote::{ IdentFragment },
            syntax::
            {
                attr::Attribute,
                error::Result,
                ext::IdentExt as _,
                generics::BoundLifetimes,
                ident::Ident,
                lifetime::Lifetime,
                lit::Lit,
                mac::Macro,
                op::{BinOp, UnOp},
                parse::ParseStream,
                pat::Pat,
                path::{AngleBracketedGenericArguments, Path, QSelf},
                punctuated::Punctuated,
                stmt::Block,
                token,
                ty::ReturnType,
                ty::Type,
            },
            *,
        };
        /*        
        */
        ast_enum_of_structs!
        {
            /// A Rust expression.
            #[non_exhaustive]
            pub enum Expr {
                /// A slice literal expression: `[a, b, c, d]`.
                Array(ExprArray),
                /// An assignment expression: `a = compute()`.
                Assign(ExprAssign),
                /// An async block: `async { ... }`.
                Async(ExprAsync),
                /// An await expression: `fut.await`.
                Await(ExprAwait),
                /// A binary operation: `a + b`, `a += b`.
                Binary(ExprBinary),
                /// A blocked scope: `{ ... }`.
                Block(ExprBlock),
                /// A `break`, with an optional label to break and an optional
                /// expression.
                Break(ExprBreak),
                /// A function call expression: `invoke(a, b)`.
                Call(ExprCall),
                /// A cast expression: `foo as f64`.
                Cast(ExprCast),
                /// A closure expression: `|a, b| a + b`.
                Closure(ExprClosure),
                /// A const block: `const { ... }`.
                Const(ExprConst),
                /// A `continue`, with an optional label.
                Continue(ExprContinue),
                /// Access of a named struct field (`obj.k`) or unnamed tuple struct
                /// field (`obj.0`).
                Field(ExprField),
                /// A for loop: `for pat in expr { ... }`.
                ForLoop(ExprForLoop),
                /// An expression contained within invisible delimiters.
                /// `TokenStream`.
                Group(ExprGroup),
                /// An `if` expression with an optional `else` block: `if expr { ... }
                /// else { ... }`.
                If(ExprIf),
                /// A square bracketed indexing expression: `vector[2]`.
                Index(ExprIndex),
                /// The inferred value of a const generic argument, denoted `_`.
                Infer(ExprInfer),
                /// A `let` guard: `let Some(x) = opt`.
                Let(ExprLet),
                /// A literal in place of an expression: `1`, `"foo"`.
                Lit(ExprLit),
                /// Conditionless loop: `loop { ... }`.
                Loop(ExprLoop),
                /// A macro invocation expression: `format!("{}", q)`.
                Macro(ExprMacro),
                /// A `match` expression: `match n { Some(n) => {}, None => {} }`.
                Match(ExprMatch),
                /// A method call expression: `x.foo::<T>(a, b)`.
                MethodCall(ExprMethodCall),
                /// A parenthesized expression: `(a + b)`.
                Paren(ExprParen),
                /// A path like `std::mem::replace` possibly containing generic
                /// parameters and a qualified self-type.
                Path(ExprPath),
                /// A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.
                Range(ExprRange),
                /// Address-of operation: `&raw const place` or `&raw mut place`.
                RawAddr(ExprRawAddr),
                /// A referencing operation: `&a` or `&mut a`.
                Reference(ExprReference),
                /// An array literal constructed from one repeated element: `[0u8; N]`.
                Repeat(ExprRepeat),
                /// A `return`, with an optional value to be returned.
                Return(ExprReturn),
                /// A struct literal expression: `Point { x: 1, y: 1 }`.
                Struct(ExprStruct),
                /// A try-expression: `expr?`.
                Try(ExprTry),
                /// A try block: `try { ... }`.
                TryBlock(ExprTryBlock),
                /// A tuple expression: `(a, b, c, d)`.
                Tuple(ExprTuple),
                /// A unary operation: `!x`, `*x`.
                Unary(ExprUnary),
                /// An unsafe block: `unsafe { ... }`.
                Unsafe(ExprUnsafe),
                /// Tokens in expression position not interpreted by Syn.
                Verbatim(TokenStream),
                /// A while loop: `while expr { ... }`.
                While(ExprWhile),
                /// A yield expression: `yield expr`.
                Yield(ExprYield),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// A slice literal expression: `[a, b, c, d]`.
            pub struct ExprArray #full {
                pub attrs: Vec<Attribute>,
                pub bracket_token: token::Bracket,
                pub elems: Punctuated<Expr, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// An assignment expression: `a = compute()`.
            pub struct ExprAssign #full {
                pub attrs: Vec<Attribute>,
                pub left: Box<Expr>,
                pub eq_token: Token![=],
                pub right: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// An async block: `async { ... }`.
            pub struct ExprAsync #full {
                pub attrs: Vec<Attribute>,
                pub async_token: Token![async],
                pub capture: Option<Token![move]>,
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// An await expression: `fut.await`.
            pub struct ExprAwait #full {
                pub attrs: Vec<Attribute>,
                pub base: Box<Expr>,
                pub dot_token: Token![.],
                pub await_token: Token![await],
            }
        }

        ast_struct! 
        {
            /// A binary operation: `a + b`, `a += b`.
            pub struct ExprBinary {
                pub attrs: Vec<Attribute>,
                pub left: Box<Expr>,
                pub op: BinOp,
                pub right: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A blocked scope: `{ ... }`.
            pub struct ExprBlock #full {
                pub attrs: Vec<Attribute>,
                pub label: Option<Label>,
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// A `break`, with an optional label to break and an optional
            /// expression.
            pub struct ExprBreak #full {
                pub attrs: Vec<Attribute>,
                pub break_token: Token![break],
                pub label: Option<Lifetime>,
                pub expr: Option<Box<Expr>>,
            }
        }

        ast_struct! 
        {
            /// A function call expression: `invoke(a, b)`.
            pub struct ExprCall {
                pub attrs: Vec<Attribute>,
                pub func: Box<Expr>,
                pub paren_token: token::Paren,
                pub args: Punctuated<Expr, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A cast expression: `foo as f64`.
            pub struct ExprCast {
                pub attrs: Vec<Attribute>,
                pub expr: Box<Expr>,
                pub as_token: Token![as],
                pub ty: Box<Type>,
            }
        }

        ast_struct! 
        {
            /// A closure expression: `|a, b| a + b`.
            pub struct ExprClosure #full {
                pub attrs: Vec<Attribute>,
                pub lifetimes: Option<BoundLifetimes>,
                pub constness: Option<Token![const]>,
                pub movability: Option<Token![static]>,
                pub asyncness: Option<Token![async]>,
                pub capture: Option<Token![move]>,
                pub or1_token: Token![|],
                pub inputs: Punctuated<Pat, Token![,]>,
                pub or2_token: Token![|],
                pub output: ReturnType,
                pub body: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A const block: `const { ... }`.
            pub struct ExprConst #full {
                pub attrs: Vec<Attribute>,
                pub const_token: Token![const],
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// A `continue`, with an optional label.
            pub struct ExprContinue #full {
                pub attrs: Vec<Attribute>,
                pub continue_token: Token![continue],
                pub label: Option<Lifetime>,
            }
        }

        ast_struct! 
        {
            /// Access of a named struct field (`obj.k`) or unnamed tuple struct
            /// field (`obj.0`).
            pub struct ExprField {
                pub attrs: Vec<Attribute>,
                pub base: Box<Expr>,
                pub dot_token: Token![.],
                pub member: Member,
            }
        }

        ast_struct! 
        {
            /// A for loop: `for pat in expr { ... }`.
            pub struct ExprForLoop #full {
                pub attrs: Vec<Attribute>,
                pub label: Option<Label>,
                pub for_token: Token![for],
                pub pat: Box<Pat>,
                pub in_token: Token![in],
                pub expr: Box<Expr>,
                pub body: Block,
            }
        }

        ast_struct! 
        {
            /// An expression contained within invisible delimiters.
            /// `TokenStream`.
            pub struct ExprGroup {
                pub attrs: Vec<Attribute>,
                pub group_token: token::Group,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// An `if` expression with an optional `else` block: `if expr { ... }
            /// else { ... }`.
            pub struct ExprIf #full {
                pub attrs: Vec<Attribute>,
                pub if_token: Token![if],
                pub cond: Box<Expr>,
                pub then_branch: Block,
                pub else_branch: Option<(Token![else], Box<Expr>)>,
            }
        }

        ast_struct! 
        {
            /// A square bracketed indexing expression: `vector[2]`.
            pub struct ExprIndex {
                pub attrs: Vec<Attribute>,
                pub expr: Box<Expr>,
                pub bracket_token: token::Bracket,
                pub index: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// The inferred value of a const generic argument, denoted `_`.
            pub struct ExprInfer #full {
                pub attrs: Vec<Attribute>,
                pub underscore_token: Token![_],
            }
        }

        ast_struct! 
        {
            /// A `let` guard: `let Some(x) = opt`.
            pub struct ExprLet #full {
                pub attrs: Vec<Attribute>,
                pub let_token: Token![let],
                pub pat: Box<Pat>,
                pub eq_token: Token![=],
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A literal in place of an expression: `1`, `"foo"`.
            pub struct ExprLit {
                pub attrs: Vec<Attribute>,
                pub lit: Lit,
            }
        }

        ast_struct! 
        {
            /// Conditionless loop: `loop { ... }`.
            pub struct ExprLoop #full {
                pub attrs: Vec<Attribute>,
                pub label: Option<Label>,
                pub loop_token: Token![loop],
                pub body: Block,
            }
        }

        ast_struct! 
        {
            /// A macro invocation expression: `format!("{}", q)`.
            pub struct ExprMacro {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
            }
        }

        ast_struct! 
        {
            /// A `match` expression: `match n { Some(n) => {}, None => {} }`.
            pub struct ExprMatch #full {
                pub attrs: Vec<Attribute>,
                pub match_token: Token![match],
                pub expr: Box<Expr>,
                pub brace_token: token::Brace,
                pub arms: Vec<Arm>,
            }
        }

        ast_struct! 
        {
            /// A method call expression: `x.foo::<T>(a, b)`.
            pub struct ExprMethodCall {
                pub attrs: Vec<Attribute>,
                pub receiver: Box<Expr>,
                pub dot_token: Token![.],
                pub method: Ident,
                pub turbofish: Option<AngleBracketedGenericArguments>,
                pub paren_token: token::Paren,
                pub args: Punctuated<Expr, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A parenthesized expression: `(a + b)`.
            pub struct ExprParen {
                pub attrs: Vec<Attribute>,
                pub paren_token: token::Paren,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A path like `std::mem::replace` possibly containing generic
            /// parameters and a qualified self-type.
            pub struct ExprPath {
                pub attrs: Vec<Attribute>,
                pub qself: Option<QSelf>,
                pub path: Path,
            }
        }

        ast_struct! 
        {
            /// A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.
            pub struct ExprRange #full {
                pub attrs: Vec<Attribute>,
                pub start: Option<Box<Expr>>,
                pub limits: RangeLimits,
                pub end: Option<Box<Expr>>,
            }
        }

        ast_struct! 
        {
            /// Address-of operation: `&raw const place` or `&raw mut place`.
            pub struct ExprRawAddr #full {
                pub attrs: Vec<Attribute>,
                pub and_token: Token![&],
                pub raw: Token![raw],
                pub mutability: PointerMutability,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A referencing operation: `&a` or `&mut a`.
            pub struct ExprReference {
                pub attrs: Vec<Attribute>,
                pub and_token: Token![&],
                pub mutability: Option<Token![mut]>,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// An array literal constructed from one repeated element: `[0u8; N]`.
            pub struct ExprRepeat #full {
                pub attrs: Vec<Attribute>,
                pub bracket_token: token::Bracket,
                pub expr: Box<Expr>,
                pub semi_token: Token![;],
                pub len: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A `return`, with an optional value to be returned.
            pub struct ExprReturn #full {
                pub attrs: Vec<Attribute>,
                pub return_token: Token![return],
                pub expr: Option<Box<Expr>>,
            }
        }

        ast_struct! {
            /// A struct literal expression: `Point { x: 1, y: 1 }`.
            pub struct ExprStruct {
                pub attrs: Vec<Attribute>,
                pub qself: Option<QSelf>,
                pub path: Path,
                pub brace_token: token::Brace,
                pub fields: Punctuated<FieldValue, Token![,]>,
                pub dot2_token: Option<Token![..]>,
                pub rest: Option<Box<Expr>>,
            }
        }

        ast_struct! 
        {
            /// A try-expression: `expr?`.
            pub struct ExprTry #full {
                pub attrs: Vec<Attribute>,
                pub expr: Box<Expr>,
                pub question_token: Token![?],
            }
        }

        ast_struct! 
        {
            /// A try block: `try { ... }`.
            pub struct ExprTryBlock #full {
                pub attrs: Vec<Attribute>,
                pub try_token: Token![try],
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// A tuple expression: `(a, b, c, d)`.
            pub struct ExprTuple {
                pub attrs: Vec<Attribute>,
                pub paren_token: token::Paren,
                pub elems: Punctuated<Expr, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A unary operation: `!x`, `*x`.
            pub struct ExprUnary {
                pub attrs: Vec<Attribute>,
                pub op: UnOp,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// An unsafe block: `unsafe { ... }`.
            pub struct ExprUnsafe #full {
                pub attrs: Vec<Attribute>,
                pub unsafe_token: Token![unsafe],
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// A while loop: `while expr { ... }`.
            pub struct ExprWhile #full {
                pub attrs: Vec<Attribute>,
                pub label: Option<Label>,
                pub while_token: Token![while],
                pub cond: Box<Expr>,
                pub body: Block,
            }
        }

        ast_struct! 
        {
            /// A yield expression: `yield expr`.
            pub struct ExprYield #full {
                pub attrs: Vec<Attribute>,
                pub yield_token: Token![yield],
                pub expr: Option<Box<Expr>>,
            }
        }

        impl Expr 
        {
            /// An unspecified invalid expression.
            pub const PLACEHOLDER: Self = Expr::Path(ExprPath {
                attrs: Vec::new(),
                qself: None,
                path: Path {
                    leading_colon: None,
                    segments: Punctuated::new(),
                },
            });
            /// An alternative to the primary `Expr::parse` parser (from the [`Parse`]
            /// trait) for ambiguous syntactic positions in which a trailing brace
            /// should not be taken as part of the expression.
            pub fn parse_without_eager_brace(input: ParseStream) -> Result<Expr> {
                parsing::ambiguous_expr(input, parsing::AllowStruct(false))
            }
            /// An alternative to the primary `Expr::parse` parser (from the [`Parse`]
            /// trait) for syntactic positions in which expression boundaries are placed
            /// more eagerly than done by the typical expression grammar.
            pub fn parse_with_earlier_boundary_rule(input: ParseStream) -> Result<Expr> {
                parsing::parse_with_earlier_boundary_rule(input)
            }
            /// Returns whether the next token in the parsing might possibly form the beginning of an expr.
            pub fn peek(input: ParseStream) -> bool
            {
                    input.peek(Ident::peek_any) && !input.peek(Token![as])
                    || input.peek(token::Paren)
                    || input.peek(token::Bracket)
                    || input.peek(token::Brace)
                    || input.peek(Lit)
                    || input.peek(Token![!]) && !input.peek(Token![!=])
                    || input.peek(Token![-]) && !input.peek(Token![-=]) && !input.peek(Token![->])
                    || input.peek(Token![*]) && !input.peek(Token![*=])
                    || input.peek(Token![|]) && !input.peek(Token![|=])
                    || input.peek(Token![&]) && !input.peek(Token![&=])
                    || input.peek(Token![..])
                    || input.peek(Token![<]) && !input.peek(Token![<=]) && !input.peek(Token![<<=])
                    || input.peek(Token![::])
                    || input.peek(Lifetime)
                    || input.peek(Token![#])
                }
            
            pub fn replace_attrs(&mut self, new: Vec<Attribute>) -> Vec<Attribute>
            {
                match self {
                    Expr::Array(ExprArray { attrs, .. })
                    | Expr::Assign(ExprAssign { attrs, .. })
                    | Expr::Async(ExprAsync { attrs, .. })
                    | Expr::Await(ExprAwait { attrs, .. })
                    | Expr::Binary(ExprBinary { attrs, .. })
                    | Expr::Block(ExprBlock { attrs, .. })
                    | Expr::Break(ExprBreak { attrs, .. })
                    | Expr::Call(ExprCall { attrs, .. })
                    | Expr::Cast(ExprCast { attrs, .. })
                    | Expr::Closure(ExprClosure { attrs, .. })
                    | Expr::Const(ExprConst { attrs, .. })
                    | Expr::Continue(ExprContinue { attrs, .. })
                    | Expr::Field(ExprField { attrs, .. })
                    | Expr::ForLoop(ExprForLoop { attrs, .. })
                    | Expr::Group(ExprGroup { attrs, .. })
                    | Expr::If(ExprIf { attrs, .. })
                    | Expr::Index(ExprIndex { attrs, .. })
                    | Expr::Infer(ExprInfer { attrs, .. })
                    | Expr::Let(ExprLet { attrs, .. })
                    | Expr::Lit(ExprLit { attrs, .. })
                    | Expr::Loop(ExprLoop { attrs, .. })
                    | Expr::Macro(ExprMacro { attrs, .. })
                    | Expr::Match(ExprMatch { attrs, .. })
                    | Expr::MethodCall(ExprMethodCall { attrs, .. })
                    | Expr::Paren(ExprParen { attrs, .. })
                    | Expr::Path(ExprPath { attrs, .. })
                    | Expr::Range(ExprRange { attrs, .. })
                    | Expr::RawAddr(ExprRawAddr { attrs, .. })
                    | Expr::Reference(ExprReference { attrs, .. })
                    | Expr::Repeat(ExprRepeat { attrs, .. })
                    | Expr::Return(ExprReturn { attrs, .. })
                    | Expr::Struct(ExprStruct { attrs, .. })
                    | Expr::Try(ExprTry { attrs, .. })
                    | Expr::TryBlock(ExprTryBlock { attrs, .. })
                    | Expr::Tuple(ExprTuple { attrs, .. })
                    | Expr::Unary(ExprUnary { attrs, .. })
                    | Expr::Unsafe(ExprUnsafe { attrs, .. })
                    | Expr::While(ExprWhile { attrs, .. })
                    | Expr::Yield(ExprYield { attrs, .. }) => mem::replace(attrs, new),
                    Expr::Verbatim(_) => Vec::new(),
                }
            }
        }

        ast_enum! 
        {
            /// A struct or tuple struct field accessed in a struct literal or field
            /// expression.
            pub enum Member {
                /// A named field like `self.x`.
                Named(Ident),
                /// An unnamed field like `self.0`.
                Unnamed(Index),
            }
        }

        impl From<Ident> for Member 
        {
            fn from(ident: Ident) -> Member {
                Member::Named(ident)
            }
        }

        impl From<Index> for Member 
        {
            fn from(index: Index) -> Member {
                Member::Unnamed(index)
            }
        }

        impl From<usize> for Member 
        {
            fn from(index: usize) -> Member {
                Member::Unnamed(Index::from(index))
            }
        }

        impl Eq for Member {

        }

        impl PartialEq for Member 
        {
            fn eq(&self, other: &Self) -> bool
        {
                match (self, other) {
                    (Member::Named(this), Member::Named(other)) => this == other,
                    (Member::Unnamed(this), Member::Unnamed(other)) => this == other,
                    _ => false,
                }
            }
        }

        impl Hash for Member 
        {
            fn hash<H: Hasher>(&self, state: &mut H) {
                match self {
                    Member::Named(m) => m.hash(state),
                    Member::Unnamed(m) => m.hash(state),
                }
            }
        }
        
        impl IdentFragment for Member

        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                match self {
                    Member::Named(m) => Display::fmt(m, formatter),
                    Member::Unnamed(m) => Display::fmt(&m.index, formatter),
                }
            }

            fn span(&self) -> Option<Span>
            {
                match self {
                    Member::Named(m) => Some(m.span()),
                    Member::Unnamed(m) => Some(m.span),
                }
            }
        }

        impl Member 
        {
            pub fn is_named(&self) -> bool
        {
                match self {
                    Member::Named(_) => true,
                    Member::Unnamed(_) => false,
                }
            }
        }

        ast_struct! 
        {
            /// The index of an unnamed tuple struct field.
            pub struct Index {
                pub index: u32,
                pub span: Span,
            }
        }

        impl From<usize> for Index 
        {
            fn from(index: usize) -> Index {
                assert!(index < u32::MAX as usize);
                Index {
                    index: index as u32,
                    span: Span::call_site(),
                }
            }
        }

        impl Eq for Index {

        }

        impl PartialEq for Index 
        {
            fn eq(&self, other: &Self) -> bool
            {
                self.index == other.index
            }
        }

        impl Hash for Index 
        {
            fn hash<H: Hasher>(&self, state: &mut H)
            {
                self.index.hash(state);
            }
        }
        
        impl IdentFragment for Index
        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.index, formatter)
            }

            fn span(&self) -> Option<Span> {
                Some(self.span)
            }
        }

        ast_struct! 
        {
            /// A field-value pair in a struct literal.
            pub struct FieldValue {
                pub attrs: Vec<Attribute>,
                pub member: Member,
                /// The colon in `Struct { x: x }`. If written in shorthand like
                /// `Struct { x }`, there is no colon.
                pub colon_token: Option<Token![:]>,

                pub expr: Expr,
            }
        }

        ast_struct! 
        {
            /// A lifetime labeling a `for`, `while`, or `loop`.
            pub struct Label {
                pub name: Lifetime,
                pub colon_token: Token![:],
            }
        }

        ast_struct! 
        {
            /// One arm of a `match` expression: `0..=10 => { return true; }`.
            pub struct Arm {
                pub attrs: Vec<Attribute>,
                pub pat: Pat,
                pub guard: Option<(Token![if], Box<Expr>)>,
                pub fat_arrow_token: Token![=>],
                pub body: Box<Expr>,
                pub comma: Option<Token![,]>,
            }
        }

        ast_enum! 
        {
            /// Limit types of a range, inclusive or exclusive.
            pub enum RangeLimits {
                /// Inclusive at the beginning, exclusive at the end.
                HalfOpen(Token![..]),
                /// Inclusive at the beginning and end.
                Closed(Token![..=]),
            }
        }

        ast_enum!
        {
            /// Mutability of a raw pointer (`*const T`, `*mut T`), in which non-mutable
            /// isn't the implicit default.
            pub enum PointerMutability {
                Const(Token![const]),
                Mut(Token![mut]),
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::{Span, TokenStream},
                syntax::
                {
                    attr,
                    attr::Attribute,
                    classify,
                    error::{Error, Result},
                    expr::
                    {
                        Arm, ExprArray, ExprAssign, ExprAsync, ExprAwait, ExprBlock, ExprBreak, ExprClosure,
                        ExprConst, ExprContinue, ExprForLoop, ExprIf, ExprInfer, ExprLet, ExprLoop, ExprMatch,
                        ExprRange, ExprRawAddr, ExprRepeat, ExprReturn, ExprTry, ExprTryBlock, ExprUnsafe,
                        ExprWhile, ExprYield, Label, PointerMutability, RangeLimits, Expr, ExprBinary, ExprCall, 
                        ExprCast, ExprField, ExprGroup, ExprIndex, ExprLit, ExprMacro, ExprMethodCall, ExprParen, 
                        ExprPath, ExprReference, ExprStruct, ExprTuple, ExprUnary, FieldValue, Index, Member,
                    },
                    generics::{self, BoundLifetimes},
                    ident::Ident,
                    lifetime::Lifetime,
                    lit::{Lit, LitFloat, LitInt},
                    mac::{self, Macro},
                    op::BinOp,
                    parse::discouraged::Speculative as _,
                    parse::ParseBuffer,
                    parse::{Parse, ParseStream},
                    pat::{Pat, PatType},
                    path::{self, AngleBracketedGenericArguments, Path, QSelf},
                    precedence::Precedence,
                    punctuated::Punctuated,
                    stmt::Block,
                    token,
                    ty::{self, ReturnType, Type},
                    verbatim,
                },
                *,
            };
            
            pub struct AllowStruct(pub bool);

            impl Parse for Expr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    ambiguous_expr(
                        input,
                                        AllowStruct(true),
                    )
                }
            }
            
            pub fn parse_with_earlier_boundary_rule(input: ParseStream) -> Result<Expr>
            {
                let mut attrs = input.call(expr_attrs)?;
                let mut expr = if input.peek(token::Group) {
                    let allow_struct = AllowStruct(true);
                    let atom = expr_group(input, allow_struct)?;
                    if continue_parsing_early(&atom) {
                        trailer_helper(input, atom)?
                    } else {
                        atom
                    }
                } else if input.peek(Token![if]) {
                    Expr::If(input.parse()?)
                } else if input.peek(Token![while]) {
                    Expr::While(input.parse()?)
                } else if input.peek(Token![for])
                    && !generics::parsing::choose_generics_over_qpath_after_keyword(input)
                {
                    Expr::ForLoop(input.parse()?)
                } else if input.peek(Token![loop]) {
                    Expr::Loop(input.parse()?)
                } else if input.peek(Token![match]) {
                    Expr::Match(input.parse()?)
                } else if input.peek(Token![try]) && input.peek2(token::Brace) {
                    Expr::TryBlock(input.parse()?)
                } else if input.peek(Token![unsafe]) {
                    Expr::Unsafe(input.parse()?)
                } else if input.peek(Token![const]) && input.peek2(token::Brace) {
                    Expr::Const(input.parse()?)
                } else if input.peek(token::Brace) {
                    Expr::Block(input.parse()?)
                } else if input.peek(Lifetime) {
                    atom_labeled(input)?
                } else {
                    let allow_struct = AllowStruct(true);
                    unary_expr(input, allow_struct)?
                };

                if continue_parsing_early(&expr) {
                    attrs.extend(expr.replace_attrs(Vec::new()));
                    expr.replace_attrs(attrs);

                    let allow_struct = AllowStruct(true);
                    return parse_expr(input, expr, allow_struct, Precedence::MIN);
                }

                if input.peek(Token![.]) && !input.peek(Token![..]) || input.peek(Token![?]) {
                    expr = trailer_helper(input, expr)?;

                    attrs.extend(expr.replace_attrs(Vec::new()));
                    expr.replace_attrs(attrs);

                    let allow_struct = AllowStruct(true);
                    return parse_expr(input, expr, allow_struct, Precedence::MIN);
                }

                attrs.extend(expr.replace_attrs(Vec::new()));
                expr.replace_attrs(attrs);
                Ok(expr)
            }
            
            impl Copy for AllowStruct {}
            
            impl Clone for AllowStruct {
                fn clone(&self) -> Self {
                    *self
                }
            }

            fn parse_expr
            (
                input: ParseStream,
                mut lhs: Expr,
                allow_struct: AllowStruct,
                base: Precedence,
            ) -> Result<Expr> 
            {
                loop {
                    let ahead = input.fork();
                    if let Expr::Range(_) = lhs {
                       
                        break;
                    } else if let Ok(op) = ahead.parse::<BinOp>() {
                        let precedence = Precedence::of_binop(&op);
                        if precedence < base {
                            break;
                        }
                        if precedence == Precedence::Assign {
                            if let Expr::Range(_) = lhs {
                                break;
                            }
                        }
                        if precedence == Precedence::Compare {
                            if let Expr::Binary(lhs) = &lhs {
                                if Precedence::of_binop(&lhs.op) == Precedence::Compare {
                                    return Err(input.error("comparison operators cannot be chained"));
                                }
                            }
                        }
                        input.advance_to(&ahead);
                        let right = parse_binop_rhs(input, allow_struct, precedence)?;
                        lhs = Expr::Binary(ExprBinary {
                            attrs: Vec::new(),
                            left: Box::new(lhs),
                            op,
                            right,
                        });
                    } else if Precedence::Assign >= base
                        && input.peek(Token![=])
                        && !input.peek(Token![=>])
                        && match lhs {
                            Expr::Range(_) => false,
                            _ => true,
                        }
                    {
                        let eq_token: Token![=] = input.parse()?;
                        let right = parse_binop_rhs(input, allow_struct, Precedence::Assign)?;
                        lhs = Expr::Assign(ExprAssign {
                            attrs: Vec::new(),
                            left: Box::new(lhs),
                            eq_token,
                            right,
                        });
                    } else if Precedence::Range >= base && input.peek(Token![..]) {
                        let limits: RangeLimits = input.parse()?;
                        let end = parse_range_end(input, &limits, allow_struct)?;
                        lhs = Expr::Range(ExprRange {
                            attrs: Vec::new(),
                            start: Some(Box::new(lhs)),
                            limits,
                            end,
                        });
                    } else if Precedence::Cast >= base && input.peek(Token![as]) {
                        let as_token: Token![as] = input.parse()?;
                        let allow_plus = false;
                        let allow_group_generic = false;
                        let ty = ty::parsing::ambig_ty(input, allow_plus, allow_group_generic)?;
                        check_cast(input)?;
                        lhs = Expr::Cast(ExprCast {
                            attrs: Vec::new(),
                            expr: Box::new(lhs),
                            as_token,
                            ty: Box::new(ty),
                        });
                    } else {
                        break;
                    }
                }
                Ok(lhs)
            }
            
            fn parse_binop_rhs
            (
                input: ParseStream,
                allow_struct: AllowStruct,
                precedence: Precedence,
            ) -> Result<Box<Expr>>
            {
                let mut rhs = unary_expr(
                    input,
                                allow_struct,
                )?;
                loop {
                    let next = peek_precedence(input);
                    if next > precedence || next == precedence && precedence == Precedence::Assign {
                        let cursor = input.cursor();
                        rhs = parse_expr(
                            input,
                            rhs,
                                                allow_struct,
                            next,
                        )?;
                        if cursor == input.cursor() {
                           
                           
                           
                           
                            break;
                        }
                    } else {
                        break;
                    }
                }
                Ok(Box::new(rhs))
            }

            fn peek_precedence(input: ParseStream) -> Precedence {
                if let Ok(op) = input.fork().parse() {
                    Precedence::of_binop(&op)
                } else if input.peek(Token![=]) && !input.peek(Token![=>]) {
                    Precedence::Assign
                } else if input.peek(Token![..]) {
                    Precedence::Range
                } else if input.peek(Token![as]) {
                    Precedence::Cast
                } else {
                    Precedence::MIN
                }
            }

            pub fn ambiguous_expr(
                input: ParseStream,
                allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                let lhs = unary_expr(
                    input,
                                allow_struct,
                )?;
                parse_expr(
                    input,
                    lhs,
                                allow_struct,
                    Precedence::MIN,
                )
            }

                fn expr_attrs(input: ParseStream) -> Result<Vec<Attribute>>
            {
                let mut attrs = Vec::new();
                while !input.peek(token::Group) && input.peek(Token![#]) {
                    attrs.push(input.call(attr::parsing::single_parse_outer)?);
                }
                Ok(attrs)
            }

           
           
           
           
                fn unary_expr(input: ParseStream, allow_struct: AllowStruct) -> Result<Expr>
            {
                let begin = input.fork();
                let attrs = input.call(expr_attrs)?;
                if input.peek(token::Group) {
                    return trailer_expr(begin, attrs, input, allow_struct);
                }

                if input.peek(Token![&]) {
                    let and_token: Token![&] = input.parse()?;
                    let raw: Option<Token![raw]> = if input.peek(Token![raw])
                        && (input.peek2(Token![mut]) || input.peek2(Token![const]))
                    {
                        Some(input.parse()?)
                    } else {
                        None
                    };
                    let mutability: Option<Token![mut]> = input.parse()?;
                    let const_token: Option<Token![const]> = if raw.is_some() && mutability.is_none() {
                        Some(input.parse()?)
                    } else {
                        None
                    };
                    let expr = Box::new(unary_expr(input, allow_struct)?);
                    if let Some(raw) = raw {
                        Ok(Expr::RawAddr(ExprRawAddr {
                            attrs,
                            and_token,
                            raw,
                            mutability: match mutability {
                                Some(mut_token) => PointerMutability::Mut(mut_token),
                                None => PointerMutability::Const(const_token.unwrap()),
                            },
                            expr,
                        }))
                    } else {
                        Ok(Expr::Reference(ExprReference {
                            attrs,
                            and_token,
                            mutability,
                            expr,
                        }))
                    }
                } else if input.peek(Token![*]) || input.peek(Token![!]) || input.peek(Token![-]) {
                    expr_unary(input, attrs, allow_struct).map(Expr::Unary)
                } else {
                    trailer_expr(begin, attrs, input, allow_struct)
                }
            }
            
            fn trailer_expr
            (
                begin: ParseBuffer,
                mut attrs: Vec<Attribute>,
                input: ParseStream,
                allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                let atom = atom_expr(input, allow_struct)?;
                let mut e = trailer_helper(input, atom)?;

                if let Expr::Verbatim(tokens) = &mut e {
                    *tokens = verbatim::between(&begin, input);
                } else if !attrs.is_empty() {
                    if let Expr::Range(range) = e {
                        let spans: &[Span] = match &range.limits {
                            RangeLimits::HalfOpen(limits) => &limits.spans,
                            RangeLimits::Closed(limits) => &limits.spans,
                        };
                        return Err(::syntax::error::new2(
                            spans[0],
                            *spans.last().unwrap(),
                            "attributes are not allowed on range expressions starting with `..`",
                        ));
                    }
                    let inner_attrs = e.replace_attrs(Vec::new());
                    attrs.extend(inner_attrs);
                    e.replace_attrs(attrs);
                }

                Ok(e)
            }
            
            fn trailer_helper(input: ParseStream, mut e: Expr) -> Result<Expr>
            {
                loop {
                    if input.peek(token::Paren) {
                        let content;
                        e = Expr::Call(ExprCall {
                            attrs: Vec::new(),
                            func: Box::new(e),
                            paren_token: parenthesized!(content in input),
                            args: content.parse_terminated(Expr::parse, Token![,])?,
                        });
                    } else if input.peek(Token![.])
                        && !input.peek(Token![..])
                        && match e {
                            Expr::Range(_) => false,
                            _ => true,
                        }
                    {
                        let mut dot_token: Token![.] = input.parse()?;

                        let float_token: Option<LitFloat> = input.parse()?;
                        if let Some(float_token) = float_token {
                            if multi_index(&mut e, &mut dot_token, float_token)? {
                                continue;
                            }
                        }

                        let await_token: Option<Token![await]> = input.parse()?;
                        if let Some(await_token) = await_token {
                            e = Expr::Await(ExprAwait {
                                attrs: Vec::new(),
                                base: Box::new(e),
                                dot_token,
                                await_token,
                            });
                            continue;
                        }

                        let member: Member = input.parse()?;
                        let turbofish = if member.is_named() && input.peek(Token![::]) {
                            Some(AngleBracketedGenericArguments::parse_turbofish(input)?)
                        } else {
                            None
                        };

                        if turbofish.is_some() || input.peek(token::Paren) {
                            if let Member::Named(method) = member {
                                let content;
                                e = Expr::MethodCall(ExprMethodCall {
                                    attrs: Vec::new(),
                                    receiver: Box::new(e),
                                    dot_token,
                                    method,
                                    turbofish,
                                    paren_token: parenthesized!(content in input),
                                    args: content.parse_terminated(Expr::parse, Token![,])?,
                                });
                                continue;
                            }
                        }

                        e = Expr::Field(ExprField {
                            attrs: Vec::new(),
                            base: Box::new(e),
                            dot_token,
                            member,
                        });
                    } else if input.peek(token::Bracket) {
                        let content;
                        e = Expr::Index(ExprIndex {
                            attrs: Vec::new(),
                            expr: Box::new(e),
                            bracket_token: bracketed!(content in input),
                            index: content.parse()?,
                        });
                    } else if input.peek(Token![?])
                        && match e {
                            Expr::Range(_) => false,
                            _ => true,
                        }
                    {
                        e = Expr::Try(ExprTry {
                            attrs: Vec::new(),
                            expr: Box::new(e),
                            question_token: input.parse()?,
                        });
                    } else {
                        break;
                    }
                }
                Ok(e)
            }
            
            fn atom_expr(input: ParseStream, allow_struct: AllowStruct) -> Result<Expr>
            {
                if input.peek(token::Group) {
                    expr_group(input, allow_struct)
                } else if input.peek(Lit) {
                    input.parse().map(Expr::Lit)
                } else if input.peek(Token![async])
                    && (input.peek2(token::Brace) || input.peek2(Token![move]) && input.peek3(token::Brace))
                {
                    input.parse().map(Expr::Async)
                } else if input.peek(Token![try]) && input.peek2(token::Brace) {
                    input.parse().map(Expr::TryBlock)
                } else if input.peek(Token![|])
                    || input.peek(Token![move])
                    || input.peek(Token![for])
                        && generics::parsing::choose_generics_over_qpath_after_keyword(input)
                    || input.peek(Token![const]) && !input.peek2(token::Brace)
                    || input.peek(Token![static])
                    || input.peek(Token![async]) && (input.peek2(Token![|]) || input.peek2(Token![move]))
                {
                    expr_closure(input, allow_struct).map(Expr::Closure)
                } else if token::parsing::peek_keyword(input.cursor(), "builtin") && input.peek2(Token![#])
                {
                    expr_builtin(input)
                } else if input.peek(Ident)
                    || input.peek(Token![::])
                    || input.peek(Token![<])
                    || input.peek(Token![self])
                    || input.peek(Token![Self])
                    || input.peek(Token![super])
                    || input.peek(Token![crate])
                    || input.peek(Token![try]) && (input.peek2(Token![!]) || input.peek2(Token![::]))
                {
                    path_or_macro_or_struct(input, allow_struct)
                } else if input.peek(token::Paren) {
                    paren_or_tuple(input)
                } else if input.peek(Token![break]) {
                    expr_break(input, allow_struct).map(Expr::Break)
                } else if input.peek(Token![continue]) {
                    input.parse().map(Expr::Continue)
                } else if input.peek(Token![return]) {
                    input.parse().map(Expr::Return)
                } else if input.peek(Token![become]) {
                    expr_become(input)
                } else if input.peek(token::Bracket) {
                    array_or_repeat(input)
                } else if input.peek(Token![let]) {
                    expr_let(input, allow_struct).map(Expr::Let)
                } else if input.peek(Token![if]) {
                    input.parse().map(Expr::If)
                } else if input.peek(Token![while]) {
                    input.parse().map(Expr::While)
                } else if input.peek(Token![for]) {
                    input.parse().map(Expr::ForLoop)
                } else if input.peek(Token![loop]) {
                    input.parse().map(Expr::Loop)
                } else if input.peek(Token![match]) {
                    input.parse().map(Expr::Match)
                } else if input.peek(Token![yield]) {
                    input.parse().map(Expr::Yield)
                } else if input.peek(Token![unsafe]) {
                    input.parse().map(Expr::Unsafe)
                } else if input.peek(Token![const]) {
                    input.parse().map(Expr::Const)
                } else if input.peek(token::Brace) {
                    input.parse().map(Expr::Block)
                } else if input.peek(Token![..]) {
                    expr_range(input, allow_struct).map(Expr::Range)
                } else if input.peek(Token![_]) {
                    input.parse().map(Expr::Infer)
                } else if input.peek(Lifetime) {
                    atom_labeled(input)
                } else {
                    Err(input.error("expected an expression"))
                }
            }
            
            fn atom_labeled(input: ParseStream) -> Result<Expr>
            {
                let the_label: Label = input.parse()?;
                let mut expr = if input.peek(Token![while]) {
                    Expr::While(input.parse()?)
                } else if input.peek(Token![for]) {
                    Expr::ForLoop(input.parse()?)
                } else if input.peek(Token![loop]) {
                    Expr::Loop(input.parse()?)
                } else if input.peek(token::Brace) {
                    Expr::Block(input.parse()?)
                } else {
                    return Err(input.error("expected loop or block expression"));
                };
                match &mut expr {
                    Expr::While(ExprWhile { label, .. })
                    | Expr::ForLoop(ExprForLoop { label, .. })
                    | Expr::Loop(ExprLoop { label, .. })
                    | Expr::Block(ExprBlock { label, .. }) => *label = Some(the_label),
                    _ => unreachable!(),
                }
                Ok(expr)
            }
            
            fn expr_builtin(input: ParseStream) -> Result<Expr>
            {
                let begin = input.fork();

                token::parsing::keyword(input, "builtin")?;
                input.parse::<Token![#]>()?;
                input.parse::<Ident>()?;

                let args;
                parenthesized!(args in input);
                args.parse::<TokenStream>()?;

                Ok(Expr::Verbatim(verbatim::between(&begin, input)))
            }

            fn path_or_macro_or_struct(
                input: ParseStream,
                allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                let expr_style = true;
                let (qself, path) = path::parsing::qpath(input, expr_style)?;
                rest_of_path_or_macro_or_struct(
                    qself,
                    path,
                    input,
                                allow_struct,
                )
            }

            fn rest_of_path_or_macro_or_struct
            (
                qself: Option<QSelf>,
                path: Path,
                input: ParseStream,
                allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                if qself.is_none()
                && input.peek(Token![!])
                && !input.peek(Token![!=])
                && path.is_mod_style()
                {
                    let bang_token: Token![!] = input.parse()?;
                    let (delimiter, tokens) = mac::parse_delimiter(input)?;
                    return Ok
                    (
                        Expr::Macro
                        (
                            ExprMacro
                            {
                                attrs: Vec::new(),
                                mac: Macro
                                {
                                    path,
                                    bang_token,
                                    delimiter,
                                    tokens,
                                },
                            }
                        )
                    );
                }
                
                if allow_struct.0 && input.peek(token::Brace)
                {
                    return expr_struct_helper(input, qself, path).map(Expr::Struct);
                }

                Ok
                (
                    Expr::Path
                    (
                        ExprPath
                        {
                            attrs: Vec::new(),
                            qself,
                            path,
                        }
                    )
                )
            }

            impl Parse for ExprMacro
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprMacro {
                        attrs: Vec::new(),
                        mac: input.parse()?,
                    })
                }
            }

            fn paren_or_tuple(input: ParseStream) -> Result<Expr>
            {
                let content;
                let paren_token = parenthesized!(content in input);
                if content.is_empty() {
                    return Ok(Expr::Tuple(ExprTuple {
                        attrs: Vec::new(),
                        paren_token,
                        elems: Punctuated::new(),
                    }));
                }

                let first: Expr = content.parse()?;
                if content.is_empty() {
                    return Ok(Expr::Paren(ExprParen {
                        attrs: Vec::new(),
                        paren_token,
                        expr: Box::new(first),
                    }));
                }

                let mut elems = Punctuated::new();
                elems.push_value(first);
                while !content.is_empty() {
                    let punct = content.parse()?;
                    elems.push_punct(punct);
                    if content.is_empty() {
                        break;
                    }
                    let value = content.parse()?;
                    elems.push_value(value);
                }
                Ok(Expr::Tuple(ExprTuple {
                    attrs: Vec::new(),
                    paren_token,
                    elems,
                }))
            }

                fn array_or_repeat(input: ParseStream) -> Result<Expr>
            {
                let content;
                let bracket_token = bracketed!(content in input);
                if content.is_empty() {
                    return Ok(Expr::Array(ExprArray {
                        attrs: Vec::new(),
                        bracket_token,
                        elems: Punctuated::new(),
                    }));
                }

                let first: Expr = content.parse()?;
                if content.is_empty() || content.peek(Token![,]) {
                    let mut elems = Punctuated::new();
                    elems.push_value(first);
                    while !content.is_empty() {
                        let punct = content.parse()?;
                        elems.push_punct(punct);
                        if content.is_empty() {
                            break;
                        }
                        let value = content.parse()?;
                        elems.push_value(value);
                    }
                    Ok(Expr::Array(ExprArray {
                        attrs: Vec::new(),
                        bracket_token,
                        elems,
                    }))
                } else if content.peek(Token![;]) {
                    let semi_token: Token![;] = content.parse()?;
                    let len: Expr = content.parse()?;
                    Ok(Expr::Repeat(ExprRepeat {
                        attrs: Vec::new(),
                        bracket_token,
                        expr: Box::new(first),
                        semi_token,
                        len: Box::new(len),
                    }))
                } else {
                    Err(content.error("expected `,` or `;`"))
                }
            }
            
            impl Parse for ExprArray
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    let bracket_token = bracketed!(content in input);
                    let mut elems = Punctuated::new();

                    while !content.is_empty() {
                        let first: Expr = content.parse()?;
                        elems.push_value(first);
                        if content.is_empty() {
                            break;
                        }
                        let punct = content.parse()?;
                        elems.push_punct(punct);
                    }

                    Ok(ExprArray {
                        attrs: Vec::new(),
                        bracket_token,
                        elems,
                    })
                }
            }
            
            impl Parse for ExprRepeat
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(ExprRepeat {
                        bracket_token: bracketed!(content in input),
                        attrs: Vec::new(),
                        expr: content.parse()?,
                        semi_token: content.parse()?,
                        len: content.parse()?,
                    })
                }
            }

                fn continue_parsing_early(mut expr: &Expr) -> bool
        {
                while let Expr::Group(group) = expr {
                    expr = &group.expr;
                }
                match expr {
                    Expr::If(_)
                    | Expr::While(_)
                    | Expr::ForLoop(_)
                    | Expr::Loop(_)
                    | Expr::Match(_)
                    | Expr::TryBlock(_)
                    | Expr::Unsafe(_)
                    | Expr::Const(_)
                    | Expr::Block(_) => false,
                    _ => true,
                }
            }

            impl Parse for ExprLit
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprLit {
                        attrs: Vec::new(),
                        lit: input.parse()?,
                    })
                }
            }

            fn expr_group(
                input: ParseStream,
                allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                let group = ::syntax::group::parse_group(input)?;
                let mut inner: Expr = group.content.parse()?;

                match inner {
                    Expr::Path(mut expr) if expr.attrs.is_empty() => {
                        let grouped_len = expr.path.segments.len();
                        Path::parse_rest(input, &mut expr.path, true)?;
                        match rest_of_path_or_macro_or_struct(
                            expr.qself,
                            expr.path,
                            input,
                                                allow_struct,
                        )? {
                            Expr::Path(expr) if expr.path.segments.len() == grouped_len => {
                                inner = Expr::Path(expr);
                            }
                            extended => return Ok(extended),
                        }
                    }
                    _ => {}
                }

                Ok(Expr::Group(ExprGroup {
                    attrs: Vec::new(),
                    group_token: group.token,
                    expr: Box::new(inner),
                }))
            }
            
            impl Parse for ExprParen
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(ExprParen {
                        attrs: Vec::new(),
                        paren_token: parenthesized!(content in input),
                        expr: content.parse()?,
                    })
                }
            }
            
            impl Parse for ExprLet
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    expr_let(input, allow_struct)
                }
            }

                fn expr_let(input: ParseStream, allow_struct: AllowStruct) -> Result<ExprLet>
            {
                Ok
                (ExprLet {
                    attrs: Vec::new(),
                    let_token: input.parse()?,
                    pat: Box::new(Pat::parse_multi_with_leading_vert(input)?),
                    eq_token: input.parse()?,
                    expr: Box::new({
                        let lhs = unary_expr(input, allow_struct)?;
                        parse_expr(input, lhs, allow_struct, Precedence::Compare)?
                    }),
                })
            }
            
            impl Parse for ExprIf
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;

                    let mut clauses = Vec::new();
                    let mut expr;
                    loop {
                        let if_token: Token![if] = input.parse()?;
                        let cond = input.call(Expr::parse_without_eager_brace)?;
                        let then_branch: Block = input.parse()?;

                        expr = ExprIf {
                            attrs: Vec::new(),
                            if_token,
                            cond: Box::new(cond),
                            then_branch,
                            else_branch: None,
                        };

                        if !input.peek(Token![else]) {
                            break;
                        }

                        let else_token: Token![else] = input.parse()?;
                        let lookahead = input.lookahead1();
                        if lookahead.peek(Token![if]) {
                            expr.else_branch = Some((else_token, Box::new(Expr::PLACEHOLDER)));
                            clauses.push(expr);
                        } else if lookahead.peek(token::Brace) {
                            expr.else_branch = Some((
                                else_token,
                                Box::new(Expr::Block(ExprBlock {
                                    attrs: Vec::new(),
                                    label: None,
                                    block: input.parse()?,
                                })),
                            ));
                            break;
                        } else {
                            return Err(lookahead.error());
                        }
                    }

                    while let Some(mut prev) = clauses.pop() {
                        *prev.else_branch.as_mut().unwrap().1 = Expr::If(expr);
                        expr = prev;
                    }
                    expr.attrs = attrs;
                    Ok(expr)
                }
            }
            
            impl Parse for ExprInfer
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprInfer {
                        attrs: input.call(Attribute::parse_outer)?,
                        underscore_token: input.parse()?,
                    })
                }
            }
            
            impl Parse for ExprForLoop
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let label: Option<Label> = input.parse()?;
                    let for_token: Token![for] = input.parse()?;

                    let pat = Pat::parse_multi_with_leading_vert(input)?;

                    let in_token: Token![in] = input.parse()?;
                    let expr: Expr = input.call(Expr::parse_without_eager_brace)?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprForLoop {
                        attrs,
                        label,
                        for_token,
                        pat: Box::new(pat),
                        in_token,
                        expr: Box::new(expr),
                        body: Block { brace_token, stmts },
                    })
                }
            }
            
            impl Parse for ExprLoop
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let label: Option<Label> = input.parse()?;
                    let loop_token: Token![loop] = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprLoop {
                        attrs,
                        label,
                        loop_token,
                        body: Block { brace_token, stmts },
                    })
                }
            }
            
            impl Parse for ExprMatch
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let match_token: Token![match] = input.parse()?;
                    let expr = Expr::parse_without_eager_brace(input)?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;

                    let arms = Arm::parse_multiple(&content)?;

                    Ok(ExprMatch {
                        attrs,
                        match_token,
                        expr: Box::new(expr),
                        brace_token,
                        arms,
                    })
                }
            }

            macro_rules! impl_by_parsing_expr {
                (
                    $(
                        $expr_type:ty, $variant:ident, $msg:expr,
                    )*
                ) => {
                    $(
                        #[cfg(all(feature = "full", feature = "printing"))]
                                    impl Parse for $expr_type {
                            fn parse(input: ParseStream) -> Result<Self> {
                                let mut expr: Expr = input.parse()?;
                                loop {
                                    match expr {
                                        Expr::$variant(inner) => return Ok(inner),
                                        Expr::Group(next) => expr = *next.expr,
                                        _ => return Err(Error::new_spanned(expr, $msg)),
                                    }
                                }
                            }
                        }
                    )*
                };
            }

            impl_by_parsing_expr! {
                ExprAssign, Assign, "expected assignment expression",
                ExprAwait, Await, "expected await expression",
                ExprBinary, Binary, "expected binary operation",
                ExprCall, Call, "expected function call expression",
                ExprCast, Cast, "expected cast expression",
                ExprField, Field, "expected struct field access",
                ExprIndex, Index, "expected indexing expression",
                ExprMethodCall, MethodCall, "expected method call expression",
                ExprRange, Range, "expected range expression",
                ExprTry, Try, "expected try expression",
                ExprTuple, Tuple, "expected tuple expression",
            }
            
            impl Parse for ExprUnary
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = Vec::new();
                    let allow_struct = AllowStruct(true);
                    expr_unary(input, attrs, allow_struct)
                }
            }

                fn expr_unary(
                input: ParseStream,
                attrs: Vec<Attribute>,
                allow_struct: AllowStruct,
            ) -> Result<ExprUnary>
            {
                Ok
                (ExprUnary {
                    attrs,
                    op: input.parse()?,
                    expr: Box::new(unary_expr(input, allow_struct)?),
                })
            }
            
            impl Parse for ExprClosure
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    expr_closure(input, allow_struct)
                }
            }
            
            impl Parse for ExprRawAddr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    Ok(ExprRawAddr {
                        attrs: Vec::new(),
                        and_token: input.parse()?,
                        raw: input.parse()?,
                        mutability: input.parse()?,
                        expr: Box::new(unary_expr(input, allow_struct)?),
                    })
                }
            }
            
            impl Parse for ExprReference
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    Ok(ExprReference {
                        attrs: Vec::new(),
                        and_token: input.parse()?,
                        mutability: input.parse()?,
                        expr: Box::new(unary_expr(input, allow_struct)?),
                    })
                }
            }
            
            impl Parse for ExprBreak
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    expr_break(input, allow_struct)
                }
            }
            
            impl Parse for ExprReturn
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprReturn {
                        attrs: Vec::new(),
                        return_token: input.parse()?,
                        expr: {
                            if Expr::peek(input) {
                                Some(input.parse()?)
                            } else {
                                None
                            }
                        },
                    })
                }
            }

                fn expr_become(input: ParseStream) -> Result<Expr>
            {
                let begin = input.fork();
                input.parse::<Token![become]>()?;
                input.parse::<Expr>()?;
                Ok(Expr::Verbatim(verbatim::between(&begin, input)))
            }
            
            impl Parse for ExprTryBlock
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprTryBlock {
                        attrs: Vec::new(),
                        try_token: input.parse()?,
                        block: input.parse()?,
                    })
                }
            }
            
            impl Parse for ExprYield
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprYield {
                        attrs: Vec::new(),
                        yield_token: input.parse()?,
                        expr: {
                            if Expr::peek(input) {
                                Some(input.parse()?)
                            } else {
                                None
                            }
                        },
                    })
                }
            }

                fn expr_closure(input: ParseStream, allow_struct: AllowStruct) -> Result<ExprClosure>
            {
                let lifetimes: Option<BoundLifetimes> = input.parse()?;
                let constness: Option<Token![const]> = input.parse()?;
                let movability: Option<Token![static]> = input.parse()?;
                let asyncness: Option<Token![async]> = input.parse()?;
                let capture: Option<Token![move]> = input.parse()?;
                let or1_token: Token![|] = input.parse()?;

                let mut inputs = Punctuated::new();
                loop {
                    if input.peek(Token![|]) {
                        break;
                    }
                    let value = closure_arg(input)?;
                    inputs.push_value(value);
                    if input.peek(Token![|]) {
                        break;
                    }
                    let punct: Token![,] = input.parse()?;
                    inputs.push_punct(punct);
                }

                let or2_token: Token![|] = input.parse()?;

                let (output, body) = if input.peek(Token![->]) {
                    let arrow_token: Token![->] = input.parse()?;
                    let ty: Type = input.parse()?;
                    let body: Block = input.parse()?;
                    let output = ReturnType::Type(arrow_token, Box::new(ty));
                    let block = Expr::Block(ExprBlock {
                        attrs: Vec::new(),
                        label: None,
                        block: body,
                    });
                    (output, block)
                } else {
                    let body = ambiguous_expr(input, allow_struct)?;
                    (ReturnType::Default, body)
                };

                Ok(ExprClosure {
                    attrs: Vec::new(),
                    lifetimes,
                    constness,
                    movability,
                    asyncness,
                    capture,
                    or1_token,
                    inputs,
                    or2_token,
                    output,
                    body: Box::new(body),
                })
            }
            
            impl Parse for ExprAsync
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprAsync {
                        attrs: Vec::new(),
                        async_token: input.parse()?,
                        capture: input.parse()?,
                        block: input.parse()?,
                    })
                }
            }

                fn closure_arg(input: ParseStream) -> Result<Pat>
            {
                let attrs = input.call(Attribute::parse_outer)?;
                let mut pat = Pat::parse_single(input)?;

                if input.peek(Token![:]) {
                    Ok(Pat::Type(PatType {
                        attrs,
                        pat: Box::new(pat),
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                    }))
                } else {
                    match &mut pat {
                        Pat::Const(pat) => pat.attrs = attrs,
                        Pat::Ident(pat) => pat.attrs = attrs,
                        Pat::Lit(pat) => pat.attrs = attrs,
                        Pat::Macro(pat) => pat.attrs = attrs,
                        Pat::Or(pat) => pat.attrs = attrs,
                        Pat::Paren(pat) => pat.attrs = attrs,
                        Pat::Path(pat) => pat.attrs = attrs,
                        Pat::Range(pat) => pat.attrs = attrs,
                        Pat::Reference(pat) => pat.attrs = attrs,
                        Pat::Rest(pat) => pat.attrs = attrs,
                        Pat::Slice(pat) => pat.attrs = attrs,
                        Pat::Struct(pat) => pat.attrs = attrs,
                        Pat::Tuple(pat) => pat.attrs = attrs,
                        Pat::TupleStruct(pat) => pat.attrs = attrs,
                        Pat::Type(_) => unreachable!(),
                        Pat::Verbatim(_) => {}
                        Pat::Wild(pat) => pat.attrs = attrs,
                    }
                    Ok(pat)
                }
            }
            
            impl Parse for ExprWhile
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let label: Option<Label> = input.parse()?;
                    let while_token: Token![while] = input.parse()?;
                    let cond = Expr::parse_without_eager_brace(input)?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprWhile {
                        attrs,
                        label,
                        while_token,
                        cond: Box::new(cond),
                        body: Block { brace_token, stmts },
                    })
                }
            }
            
            impl Parse for ExprConst
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let const_token: Token![const] = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    let inner_attrs = content.call(Attribute::parse_inner)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprConst {
                        attrs: inner_attrs,
                        const_token,
                        block: Block { brace_token, stmts },
                    })
                }
            }
            
            impl Parse for Label
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (Label {
                        name: input.parse()?,
                        colon_token: input.parse()?,
                    })
                }
            }
            
            impl Parse for Option<Label>
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Lifetime) {
                        input.parse().map(Some)
                    } else {
                        Ok(None)
                    }
                }
            }
            
            impl Parse for ExprContinue
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprContinue {
                        attrs: Vec::new(),
                        continue_token: input.parse()?,
                        label: input.parse()?,
                    })
                }
            }

                fn expr_break(input: ParseStream, allow_struct: AllowStruct) -> Result<ExprBreak>
            {
                let break_token: Token![break] = input.parse()?;

                let ahead = input.fork();
                let label: Option<Lifetime> = ahead.parse()?;
                if label.is_some() && ahead.peek(Token![:]) {
                   
                   
                    let _: Expr = input.parse()?;
                    let start_span = label.unwrap().apostrophe;
                    let end_span = input.cursor().prev_span();
                    return Err(::syntax::error::new2(
                        start_span,
                        end_span,
                        "parentheses required",
                    ));
                }

                input.advance_to(&ahead);
                let expr = if Expr::peek(input) && (allow_struct.0 || !input.peek(token::Brace)) {
                    Some(input.parse()?)
                } else {
                    None
                };

                Ok(ExprBreak {
                    attrs: Vec::new(),
                    break_token,
                    label,
                    expr,
                })
            }

            impl Parse for FieldValue
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let member: Member = input.parse()?;
                    let (colon_token, value) = if input.peek(Token![:]) || !member.is_named() {
                        let colon_token: Token![:] = input.parse()?;
                        let value: Expr = input.parse()?;
                        (Some(colon_token), value)
                    } else if let Member::Named(ident) = &member {
                        let value = Expr::Path(ExprPath {
                            attrs: Vec::new(),
                            qself: None,
                            path: Path::from(ident.clone()),
                        });
                        (None, value)
                    } else {
                        unreachable!()
                    };

                    Ok(FieldValue {
                        attrs,
                        member,
                        colon_token,
                        expr: value,
                    })
                }
            }

            impl Parse for ExprStruct
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let expr_style = true;
                    let (qself, path) = path::parsing::qpath(input, expr_style)?;
                    expr_struct_helper(input, qself, path)
                }
            }

            fn expr_struct_helper(
                input: ParseStream,
                qself: Option<QSelf>,
                path: Path,
            ) -> Result<ExprStruct>
            {
                let content;
                let brace_token = braced!(content in input);

                let mut fields = Punctuated::new();
                while !content.is_empty() {
                    if content.peek(Token![..]) {
                        return Ok(ExprStruct {
                            attrs: Vec::new(),
                            qself,
                            path,
                            brace_token,
                            fields,
                            dot2_token: Some(content.parse()?),
                            rest: if content.is_empty() {
                                None
                            } else {
                                Some(Box::new(content.parse()?))
                            },
                        });
                    }

                    fields.push(content.parse()?);
                    if content.is_empty() {
                        break;
                    }
                    let punct: Token![,] = content.parse()?;
                    fields.push_punct(punct);
                }

                Ok(ExprStruct {
                    attrs: Vec::new(),
                    qself,
                    path,
                    brace_token,
                    fields,
                    dot2_token: None,
                    rest: None,
                })
            }
            
            impl Parse for ExprUnsafe
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let unsafe_token: Token![unsafe] = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    let inner_attrs = content.call(Attribute::parse_inner)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprUnsafe {
                        attrs: inner_attrs,
                        unsafe_token,
                        block: Block { brace_token, stmts },
                    })
                }
            }
            
            impl Parse for ExprBlock
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let label: Option<Label> = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprBlock {
                        attrs,
                        label,
                        block: Block { brace_token, stmts },
                    })
                }
            }

                fn expr_range(input: ParseStream, allow_struct: AllowStruct) -> Result<ExprRange>
            {
                let limits: RangeLimits = input.parse()?;
                let end = parse_range_end(input, &limits, allow_struct)?;
                Ok(ExprRange {
                    attrs: Vec::new(),
                    start: None,
                    limits,
                    end,
                })
            }

                fn parse_range_end(
                input: ParseStream,
                limits: &RangeLimits,
                allow_struct: AllowStruct,
            ) -> Result<Option<Box<Expr>>> {
                if matches!(limits, RangeLimits::HalfOpen(_))
                    && (input.is_empty()
                        || input.peek(Token![,])
                        || input.peek(Token![;])
                        || input.peek(Token![.]) && !input.peek(Token![..])
                        || input.peek(Token![?])
                        || input.peek(Token![=>])
                        || !allow_struct.0 && input.peek(token::Brace)
                        || input.peek(Token![=])
                        || input.peek(Token![+])
                        || input.peek(Token![/])
                        || input.peek(Token![%])
                        || input.peek(Token![^])
                        || input.peek(Token![>])
                        || input.peek(Token![<=])
                        || input.peek(Token![!=])
                        || input.peek(Token![-=])
                        || input.peek(Token![*=])
                        || input.peek(Token![&=])
                        || input.peek(Token![|=])
                        || input.peek(Token![<<=])
                        || input.peek(Token![as]))
                {
                    Ok(None)
                } else {
                    let end = parse_binop_rhs(input, allow_struct, Precedence::Range)?;
                    Ok(Some(end))
                }
            }
            
            impl Parse for RangeLimits
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    let dot_dot = lookahead.peek(Token![..]);
                    let dot_dot_eq = dot_dot && lookahead.peek(Token![..=]);
                    let dot_dot_dot = dot_dot && input.peek(Token![...]);
                    if dot_dot_eq {
                        input.parse().map(RangeLimits::Closed)
                    } else if dot_dot && !dot_dot_dot {
                        input.parse().map(RangeLimits::HalfOpen)
                    } else {
                        Err(lookahead.error())
                    }
                }
            }
            
            impl RangeLimits {
                pub fn parse_obsolete(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    let dot_dot = lookahead.peek(Token![..]);
                    let dot_dot_eq = dot_dot && lookahead.peek(Token![..=]);
                    let dot_dot_dot = dot_dot && input.peek(Token![...]);
                    if dot_dot_eq {
                        input.parse().map(RangeLimits::Closed)
                    } else if dot_dot_dot {
                        let dot3: Token![...] = input.parse()?;
                        Ok(RangeLimits::Closed(Token![..=](dot3.spans)))
                    } else if dot_dot {
                        input.parse().map(RangeLimits::HalfOpen)
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            impl Parse for ExprPath
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let expr_style = true;
                    let (qself, path) = path::parsing::qpath(input, expr_style)?;
                    Ok(ExprPath { attrs, qself, path })
                }
            }

            impl Parse for Member
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Ident) {
                        input.parse().map(Member::Named)
                    } else if input.peek(LitInt) {
                        input.parse().map(Member::Unnamed)
                    } else {
                        Err(input.error("expected identifier or integer"))
                    }
                }
            }
            
            impl Arm {
                pub fn parse_multiple(input: ParseStream) -> Result<Vec<Self>> {
                    let mut arms = Vec::new();
                    while !input.is_empty() {
                        arms.push(input.call(Arm::parse)?);
                    }
                    Ok(arms)
                }
            }
            
            impl Parse for Arm
            {
                fn parse(input: ParseStream) -> Result<Arm> {
                    let requires_comma;
                    Ok(Arm {
                        attrs: input.call(Attribute::parse_outer)?,
                        pat: Pat::parse_multi_with_leading_vert(input)?,
                        guard: {
                            if input.peek(Token![if]) {
                                let if_token: Token![if] = input.parse()?;
                                let guard: Expr = input.parse()?;
                                Some((if_token, Box::new(guard)))
                            } else {
                                None
                            }
                        },
                        fat_arrow_token: input.parse()?,
                        body: {
                            let body = Expr::parse_with_earlier_boundary_rule(input)?;
                            requires_comma = classify::requires_comma_to_be_match_arm(&body);
                            Box::new(body)
                        },
                        comma: {
                            if requires_comma && !input.is_empty() {
                                Some(input.parse()?)
                            } else {
                                input.parse()?
                            }
                        },
                    })
                }
            }

            impl Parse for Index
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lit: LitInt = input.parse()?;
                    if lit.suffix().is_empty() {
                        Ok(Index {
                            index: lit
                                .base10_digits()
                                .parse()
                                .map_err(|err| Error::new(lit.span(), err))?,
                            span: lit.span(),
                        })
                    } else {
                        Err(Error::new(lit.span(), "expected unsuffixed integer"))
                    }
                }
            }

            fn multi_index(e: &mut Expr, dot_token: &mut Token![.], float: LitFloat) -> Result<bool>
            {
                let float_token = float.token();
                let float_span = float_token.span();
                let mut float_repr = float_token.to_string();
                let trailing_dot = float_repr.ends_with('.');
                if trailing_dot {
                    float_repr.truncate(float_repr.len() - 1);
                }

                let mut offset = 0;
                for part in float_repr.split('.') {
                    let mut index: Index =
                        ::syntax::parse_str(part).map_err(|err| Error::new(float_span, err))?;
                    let part_end = offset + part.len();
                    index.span = float_token.subspan(offset..part_end).unwrap_or(float_span);

                    let base = mem::replace(e, Expr::PLACEHOLDER);
                    *e = Expr::Field(ExprField {
                        attrs: Vec::new(),
                        base: Box::new(base),
                        dot_token: Token![.](dot_token.span),
                        member: Member::Unnamed(index),
                    });

                    let dot_span = float_token
                        .subspan(part_end..part_end + 1)
                        .unwrap_or(float_span);
                    *dot_token = Token![.](dot_span);
                    offset = part_end + 1;
                }

                Ok(!trailing_dot)
            }
            
            impl Parse for PointerMutability
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    if lookahead.peek(Token![const]) {
                        Ok(PointerMutability::Const(input.parse()?))
                    } else if lookahead.peek(Token![mut]) {
                        Ok(PointerMutability::Mut(input.parse()?))
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            fn check_cast(input: ParseStream) -> Result<()>
            {
                let kind = if input.peek(Token![.]) && !input.peek(Token![..]) {
                    if input.peek2(Token![await]) {
                        "`.await`"
                    } else if input.peek2(Ident) && (input.peek3(token::Paren) || input.peek3(Token![::])) {
                        "a method call"
                    } else {
                        "a field access"
                    }
                } else if input.peek(Token![?]) {
                    "`?`"
                } else if input.peek(token::Bracket) {
                    "indexing"
                } else if input.peek(token::Paren) {
                    "a function call"
                } else {
                    return Ok(());
                };
                let msg = format!("casts cannot be followed by {}", kind);
                Err(input.error(msg))
            }
        }
        
        pub mod printing
        {
            use ::
            {
                process::macros::{Literal, Span, TokenStream},
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    attr::Attribute,
                    attr::FilterAttrs,
                    classify,
                    expr::
                    {
                        Arm, ExprArray, ExprAssign, ExprAsync, ExprAwait, ExprBlock, ExprBreak, ExprClosure, 
                        ExprConst, ExprContinue, ExprForLoop, ExprIf, ExprInfer, ExprLet, ExprLoop, ExprMatch,
                        ExprRange, ExprRawAddr, ExprRepeat, ExprReturn, ExprTry, ExprTryBlock, ExprUnsafe,
                        ExprWhile, ExprYield, Label, PointerMutability, RangeLimits, Expr, ExprBinary, ExprCall,
                        ExprCast, ExprField, ExprGroup, ExprIndex, ExprLit, ExprMacro, ExprMethodCall, ExprParen,
                        ExprPath, ExprReference, ExprStruct, ExprTuple, ExprUnary, FieldValue, Index, Member,
                    },
                    fixup::FixupContext,
                    op::BinOp,
                    path,
                    path::printing::PathStyle,
                    precedence::Precedence,
                    token,
                    ty::ReturnType,
                },
                *,
            };
            
            pub fn outer_attrs_to_tokens(attrs: &[Attribute], tokens: &mut TokenStream) {
                tokens.append_all(attrs.outer());
            }

                fn inner_attrs_to_tokens(attrs: &[Attribute], tokens: &mut TokenStream) {
                tokens.append_all(attrs.inner());
            }
            
            pub fn print_subexpression
            (
                expr: &Expr,
                needs_group: bool,
                tokens: &mut TokenStream,
                mut fixup: FixupContext,
            )
            {
                if needs_group {


                   
                   
                   


                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| print_expr(expr, tokens, fixup);

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }

            pub fn print_expr(expr: &Expr, tokens: &mut TokenStream, mut fixup: FixupContext)
            {
                let needs_group = fixup.parenthesize(expr);

                if needs_group { fixup = FixupContext::NONE; }

                let do_print_expr = |tokens: &mut TokenStream| match expr
                {
                    Expr::Array(e) => e.to_tokens(tokens),
                    Expr::Assign(e) => print_expr_assign(e, tokens, fixup),
                    Expr::Async(e) => e.to_tokens(tokens),
                    Expr::Await(e) => print_expr_await(e, tokens, fixup),
                    Expr::Binary(e) => print_expr_binary(e, tokens, fixup),
                    Expr::Block(e) => e.to_tokens(tokens),
                    Expr::Break(e) => print_expr_break(e, tokens, fixup),
                    Expr::Call(e) => print_expr_call(e, tokens, fixup),
                    Expr::Cast(e) => print_expr_cast(e, tokens, fixup),
                    Expr::Closure(e) => print_expr_closure(e, tokens, fixup),
                    Expr::Const(e) => e.to_tokens(tokens),
                    Expr::Continue(e) => e.to_tokens(tokens),
                    Expr::Field(e) => print_expr_field(e, tokens, fixup),
                    Expr::ForLoop(e) => e.to_tokens(tokens),
                    Expr::Group(e) => e.to_tokens(tokens),
                    Expr::If(e) => e.to_tokens(tokens),
                    Expr::Index(e) => print_expr_index(e, tokens, fixup),
                    Expr::Infer(e) => e.to_tokens(tokens),
                    Expr::Let(e) => print_expr_let(e, tokens, fixup),
                    Expr::Lit(e) => e.to_tokens(tokens),
                    Expr::Loop(e) => e.to_tokens(tokens),
                    Expr::Macro(e) => e.to_tokens(tokens),
                    Expr::Match(e) => e.to_tokens(tokens),
                    Expr::MethodCall(e) => print_expr_method_call(e, tokens, fixup),
                    Expr::Paren(e) => e.to_tokens(tokens),
                    Expr::Path(e) => e.to_tokens(tokens),
                    Expr::Range(e) => print_expr_range(e, tokens, fixup),
                    Expr::RawAddr(e) => print_expr_raw_addr(e, tokens, fixup),
                    Expr::Reference(e) => print_expr_reference(e, tokens, fixup),
                    Expr::Repeat(e) => e.to_tokens(tokens),
                    Expr::Return(e) => print_expr_return(e, tokens, fixup),
                    Expr::Struct(e) => e.to_tokens(tokens),
                    Expr::Try(e) => print_expr_try(e, tokens, fixup),
                    Expr::TryBlock(e) => e.to_tokens(tokens),
                    Expr::Tuple(e) => e.to_tokens(tokens),
                    Expr::Unary(e) => print_expr_unary(e, tokens, fixup),
                    Expr::Unsafe(e) => e.to_tokens(tokens),
                    Expr::Verbatim(e) => e.to_tokens(tokens),
                    Expr::While(e) => e.to_tokens(tokens),
                    Expr::Yield(e) => print_expr_yield(e, tokens, fixup),
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }
            
            impl ToTokens for ExprArray {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.bracket_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                    });
                }
            }
            
            impl ToTokens for ExprAssign {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_assign(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_assign(e: &ExprAssign, tokens: &mut TokenStream, mut fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let needs_group = !e.attrs.is_empty();
                if needs_group {
                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| {
                    let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                        &e.left,
                        false,
                        false,
                        Precedence::Assign,
                    );
                    print_subexpression(&e.left, left_prec <= Precedence::Range, tokens, left_fixup);
                    e.eq_token.to_tokens(tokens);
                    print_expr(
                        &e.right,
                        tokens,
                        fixup.rightmost_subexpression_fixup(false, false, Precedence::Assign),
                    );
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }
            
            impl ToTokens for ExprAsync {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.async_token.to_tokens(tokens);
                    self.capture.to_tokens(tokens);
                    self.block.to_tokens(tokens);
                }
            }
            
            impl ToTokens for ExprAwait {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_await(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_await(e: &ExprAwait, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_dot(&e.base);
                print_subexpression(
                    &e.base,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.dot_token.to_tokens(tokens);
                e.await_token.to_tokens(tokens);
            }

            impl ToTokens for ExprBinary {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_binary(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_binary(e: &ExprBinary, tokens: &mut TokenStream, mut fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let needs_group = !e.attrs.is_empty();
                if needs_group {
                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| {
                    let binop_prec = Precedence::of_binop(&e.op);
                    let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                        &e.left,
                                        match &e.op {
                            BinOp::Sub(_)
                            | BinOp::Mul(_)
                            | BinOp::And(_)
                            | BinOp::Or(_)
                            | BinOp::BitAnd(_)
                            | BinOp::BitOr(_)
                            | BinOp::Shl(_)
                            | BinOp::Lt(_) => true,
                            _ => false,
                        },
                        match &e.op {
                            BinOp::Shl(_) | BinOp::Lt(_) => true,
                            _ => false,
                        },
                                        binop_prec,
                    );
                    let left_needs_group = match binop_prec {
                        Precedence::Assign => left_prec <= Precedence::Range,
                        Precedence::Compare => left_prec <= binop_prec,
                        _ => left_prec < binop_prec,
                    };

                    let right_fixup = fixup.rightmost_subexpression_fixup(
                                        false,
                                        false,
                                        binop_prec,
                    );
                    let right_needs_group = binop_prec != Precedence::Assign
                        && right_fixup.rightmost_subexpression_precedence(&e.right) <= binop_prec;

                    print_subexpression(&e.left, left_needs_group, tokens, left_fixup);
                    e.op.to_tokens(tokens);
                    print_subexpression(&e.right, right_needs_group, tokens, right_fixup);
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }
            
            impl ToTokens for ExprBlock {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.label.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }
            
            impl ToTokens for ExprBreak {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_break(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_break(e: &ExprBreak, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.break_token.to_tokens(tokens);
                e.label.to_tokens(tokens);
                if let Some(value) = &e.expr {
                    print_subexpression(
                        value,
                       
                       
                        e.label.is_none() && classify::expr_leading_label(value),
                        tokens,
                        fixup.rightmost_subexpression_fixup(true, true, Precedence::Jump),
                    );
                }
            }

            impl ToTokens for ExprCall {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_call(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_call(e: &ExprCall, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                    &e.func,
                                true,
                    false,
                                Precedence::Unambiguous,
                );
                let needs_group = if let Expr::Field(func) = &*e.func {
                    func.member.is_named()
                } else {
                    left_prec < Precedence::Unambiguous
                };
                print_subexpression(&e.func, needs_group, tokens, left_fixup);

                e.paren_token.surround(tokens, |tokens| {
                    e.args.to_tokens(tokens);
                });
            }

            impl ToTokens for ExprCast {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_cast(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_cast(e: &ExprCast, tokens: &mut TokenStream, mut fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let needs_group = !e.attrs.is_empty();
                if needs_group {
                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| {
                    let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                        &e.expr,
                                        false,
                        false,
                                        Precedence::Cast,
                    );
                    print_subexpression(&e.expr, left_prec < Precedence::Cast, tokens, left_fixup);
                    e.as_token.to_tokens(tokens);
                    e.ty.to_tokens(tokens);
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }
            
            impl ToTokens for ExprClosure {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_closure(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_closure(e: &ExprClosure, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.lifetimes.to_tokens(tokens);
                e.constness.to_tokens(tokens);
                e.movability.to_tokens(tokens);
                e.asyncness.to_tokens(tokens);
                e.capture.to_tokens(tokens);
                e.or1_token.to_tokens(tokens);
                e.inputs.to_tokens(tokens);
                e.or2_token.to_tokens(tokens);
                e.output.to_tokens(tokens);
                if matches!(e.output, ReturnType::Default)
                    || matches!(&*e.body, Expr::Block(body) if body.attrs.is_empty() && body.label.is_none())
                {
                    print_expr(
                        &e.body,
                        tokens,
                        fixup.rightmost_subexpression_fixup(false, false, Precedence::Jump),
                    );
                } else {
                    token::Brace::default().surround(tokens, |tokens| {
                        print_expr(&e.body, tokens, FixupContext::new_stmt());
                    });
                }
            }
            
            impl ToTokens for ExprConst {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.const_token.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }
            
            impl ToTokens for ExprContinue {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.continue_token.to_tokens(tokens);
                    self.label.to_tokens(tokens);
                }
            }

            impl ToTokens for ExprField {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_field(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_field(e: &ExprField, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_dot(&e.base);
                print_subexpression(
                    &e.base,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.dot_token.to_tokens(tokens);
                e.member.to_tokens(tokens);
            }
            
            impl ToTokens for ExprForLoop {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.label.to_tokens(tokens);
                    self.for_token.to_tokens(tokens);
                    self.pat.to_tokens(tokens);
                    self.in_token.to_tokens(tokens);
                    print_expr(&self.expr, tokens, FixupContext::new_condition());
                    self.body.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.body.stmts);
                    });
                }
            }

            impl ToTokens for ExprGroup {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.group_token.surround(tokens, |tokens| {
                        self.expr.to_tokens(tokens);
                    });
                }
            }
            
            impl ToTokens for ExprIf {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);

                    let mut expr = self;
                    loop {
                        expr.if_token.to_tokens(tokens);
                        print_expr(&expr.cond, tokens, FixupContext::new_condition());
                        expr.then_branch.to_tokens(tokens);

                        let (else_token, else_) = match &expr.else_branch {
                            Some(else_branch) => else_branch,
                            None => break,
                        };

                        else_token.to_tokens(tokens);
                        match &**else_ {
                            Expr::If(next) => {
                                expr = next;
                            }
                            Expr::Block(last) => {
                                last.to_tokens(tokens);
                                break;
                            }
                           
                           
                            other => {
                                token::Brace::default().surround(tokens, |tokens| {
                                    print_expr(other, tokens, FixupContext::new_stmt());
                                });
                                break;
                            }
                        }
                    }
                }
            }

            impl ToTokens for ExprIndex {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_index(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_index(e: &ExprIndex, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                    &e.expr,
                                true,
                    false,
                                Precedence::Unambiguous,
                );
                print_subexpression(
                    &e.expr,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.bracket_token.surround(tokens, |tokens| {
                    e.index.to_tokens(tokens);
                });
            }
            
            impl ToTokens for ExprInfer {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.underscore_token.to_tokens(tokens);
                }
            }
            
            impl ToTokens for ExprLet {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_let(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_let(e: &ExprLet, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.let_token.to_tokens(tokens);
                e.pat.to_tokens(tokens);
                e.eq_token.to_tokens(tokens);
                let (right_prec, right_fixup) = fixup.rightmost_subexpression(&e.expr, Precedence::Let);
                print_subexpression(&e.expr, right_prec < Precedence::Let, tokens, right_fixup);
            }

            impl ToTokens for ExprLit {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.lit.to_tokens(tokens);
                }
            }
            
            impl ToTokens for ExprLoop {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.label.to_tokens(tokens);
                    self.loop_token.to_tokens(tokens);
                    self.body.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.body.stmts);
                    });
                }
            }

            impl ToTokens for ExprMacro {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.mac.to_tokens(tokens);
                }
            }
            
            impl ToTokens for ExprMatch {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.match_token.to_tokens(tokens);
                    print_expr(&self.expr, tokens, FixupContext::new_condition());
                    self.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        for (i, arm) in self.arms.iter().enumerate() {
                            arm.to_tokens(tokens);
                           
                           
                            let is_last = i == self.arms.len() - 1;
                            if !is_last
                                && classify::requires_comma_to_be_match_arm(&arm.body)
                                && arm.comma.is_none()
                            {
                                <Token![,]>::default().to_tokens(tokens);
                            }
                        }
                    });
                }
            }

            impl ToTokens for ExprMethodCall {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_method_call(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_method_call(e: &ExprMethodCall, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_dot(&e.receiver);
                print_subexpression(
                    &e.receiver,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.dot_token.to_tokens(tokens);
                e.method.to_tokens(tokens);
                if let Some(turbofish) = &e.turbofish {
                    path::printing::print_angle_bracketed_generic_arguments(
                        tokens,
                        turbofish,
                        PathStyle::Expr,
                    );
                }
                e.paren_token.surround(tokens, |tokens| {
                    e.args.to_tokens(tokens);
                });
            }

            impl ToTokens for ExprParen {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.paren_token.surround(tokens, |tokens| {
                        self.expr.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for ExprPath {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::Expr);
                }
            }
            
            impl ToTokens for ExprRange {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_range(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_range(e: &ExprRange, tokens: &mut TokenStream, mut fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let needs_group = !e.attrs.is_empty();
                if needs_group {
                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| {
                    if let Some(start) = &e.start {
                        let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                            start,
                            true,
                            false,
                            Precedence::Range,
                        );
                        print_subexpression(start, left_prec <= Precedence::Range, tokens, left_fixup);
                    }
                    e.limits.to_tokens(tokens);
                    if let Some(end) = &e.end {
                        let right_fixup =
                            fixup.rightmost_subexpression_fixup(false, true, Precedence::Range);
                        let right_prec = right_fixup.rightmost_subexpression_precedence(end);
                        print_subexpression(end, right_prec <= Precedence::Range, tokens, right_fixup);
                    }
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }
            
            impl ToTokens for ExprRawAddr {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_raw_addr(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_raw_addr(e: &ExprRawAddr, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.and_token.to_tokens(tokens);
                e.raw.to_tokens(tokens);
                e.mutability.to_tokens(tokens);
                let (right_prec, right_fixup) = fixup.rightmost_subexpression(&e.expr, Precedence::Prefix);
                print_subexpression(
                    &e.expr,
                    right_prec < Precedence::Prefix,
                    tokens,
                    right_fixup,
                );
            }

            impl ToTokens for ExprReference {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_reference(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_reference(e: &ExprReference, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.and_token.to_tokens(tokens);
                e.mutability.to_tokens(tokens);
                let (right_prec, right_fixup) = fixup.rightmost_subexpression(
                    &e.expr,
                                Precedence::Prefix,
                );
                print_subexpression(
                    &e.expr,
                    right_prec < Precedence::Prefix,
                    tokens,
                    right_fixup,
                );
            }
            
            impl ToTokens for ExprRepeat {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.bracket_token.surround(tokens, |tokens| {
                        self.expr.to_tokens(tokens);
                        self.semi_token.to_tokens(tokens);
                        self.len.to_tokens(tokens);
                    });
                }
            }
            
            impl ToTokens for ExprReturn {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_return(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_return(e: &ExprReturn, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.return_token.to_tokens(tokens);
                if let Some(expr) = &e.expr {
                    print_expr(
                        expr,
                        tokens,
                        fixup.rightmost_subexpression_fixup(true, false, Precedence::Jump),
                    );
                }
            }

            impl ToTokens for ExprStruct {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::Expr);
                    self.brace_token.surround(tokens, |tokens| {
                        self.fields.to_tokens(tokens);
                        if let Some(dot2_token) = &self.dot2_token {
                            dot2_token.to_tokens(tokens);
                        } else if self.rest.is_some() {
                            Token![..](Span::call_site()).to_tokens(tokens);
                        }
                        self.rest.to_tokens(tokens);
                    });
                }
            }
            
            impl ToTokens for ExprTry {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_try(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_try(e: &ExprTry, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_dot(&e.expr);
                print_subexpression(
                    &e.expr,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.question_token.to_tokens(tokens);
            }
            
            impl ToTokens for ExprTryBlock {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.try_token.to_tokens(tokens);
                    self.block.to_tokens(tokens);
                }
            }

            impl ToTokens for ExprTuple {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.paren_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                       
                       
                        if self.elems.len() == 1 && !self.elems.trailing_punct() {
                            <Token![,]>::default().to_tokens(tokens);
                        }
                    });
                }
            }

            impl ToTokens for ExprUnary {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_unary(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_unary(e: &ExprUnary, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.op.to_tokens(tokens);
                let (right_prec, right_fixup) = fixup.rightmost_subexpression(
                    &e.expr,
                                Precedence::Prefix,
                );
                print_subexpression(
                    &e.expr,
                    right_prec < Precedence::Prefix,
                    tokens,
                    right_fixup,
                );
            }
            
            impl ToTokens for ExprUnsafe {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.unsafe_token.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }
            
            impl ToTokens for ExprWhile {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.label.to_tokens(tokens);
                    self.while_token.to_tokens(tokens);
                    print_expr(&self.cond, tokens, FixupContext::new_condition());
                    self.body.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.body.stmts);
                    });
                }
            }
            
            impl ToTokens for ExprYield {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_yield(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_yield(e: &ExprYield, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.yield_token.to_tokens(tokens);
                if let Some(expr) = &e.expr {
                    print_expr(
                        expr,
                        tokens,
                        fixup.rightmost_subexpression_fixup(true, false, Precedence::Jump),
                    );
                }
            }
            
            impl ToTokens for Arm {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(&self.attrs);
                    self.pat.to_tokens(tokens);
                    if let Some((if_token, guard)) = &self.guard {
                        if_token.to_tokens(tokens);
                        guard.to_tokens(tokens);
                    }
                    self.fat_arrow_token.to_tokens(tokens);
                    print_expr(&self.body, tokens, FixupContext::new_match_arm());
                    self.comma.to_tokens(tokens);
                }
            }

            impl ToTokens for FieldValue {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.member.to_tokens(tokens);
                    if let Some(colon_token) = &self.colon_token {
                        colon_token.to_tokens(tokens);
                        self.expr.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for Index {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    let mut lit = Literal::i64_unsuffixed(i64::from(self.index));
                    lit.set_span(self.span);
                    tokens.append(lit);
                }
            }
            
            impl ToTokens for Label {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.name.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                }
            }

            impl ToTokens for Member {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        Member::Named(ident) => ident.to_tokens(tokens),
                        Member::Unnamed(index) => index.to_tokens(tokens),
                    }
                }
            }
            
            impl ToTokens for RangeLimits {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        RangeLimits::HalfOpen(t) => t.to_tokens(tokens),
                        RangeLimits::Closed(t) => t.to_tokens(tokens),
                    }
                }
            }
            
            impl ToTokens for PointerMutability {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        PointerMutability::Const(const_token) => const_token.to_tokens(tokens),
                        PointerMutability::Mut(mut_token) => mut_token.to_tokens(tokens),
                    }
                }
            }
        }
    }
    
    pub use ::syntax::expr::
    {
        Arm, Label, PointerMutability, RangeLimits, Expr, ExprBinary, ExprCall, ExprCast, ExprField, ExprIndex, 
        ExprLit, ExprMacro, ExprMethodCall, ExprParen, ExprPath, ExprReference, ExprStruct, ExprUnary, FieldValue, 
        Index, Member, ExprArray, ExprAssign, ExprAsync, ExprAwait, ExprBlock, ExprBreak, ExprClosure, ExprConst,
        ExprContinue, ExprForLoop, ExprGroup, ExprIf, ExprInfer, ExprLet, ExprLoop, ExprMatch, ExprRange,
        ExprRawAddr, ExprRepeat, ExprReturn, ExprTry, ExprTryBlock, ExprTuple, ExprUnsafe, ExprWhile, ExprYield,
    };
    
    pub mod ext
    {
        //! Extension traits to provide parsing methods on foreign types.
        use ::
        {
            process::macros::Ident,
            syntax::
            {
                buffer::Cursor,
                error::Result,
                parse::ParseStream,
                parse::Peek,
                sealed::lookahead,
                token::CustomToken,
            },
            *,
        };
        /*
        */
        /// Additional methods for `Ident` not provided by proc-macro2 or libproc_macro.
        pub trait IdentExt: Sized + private::Sealed
        {
            /// Parses any identifier including keywords.
            fn parse_any(input: ParseStream) -> Result<Self>;
            /// Peeks any identifier including keywords.
            const peek_any: private::PeekFn = private::PeekFn;
            /// Strips the raw marker `r#`, if any, from the beginning of an ident.
            fn unraw(&self) -> Ident;
        }

        impl IdentExt for Ident {
            fn parse_any(input: ParseStream) -> Result<Self> {
                input.step(|cursor| match cursor.ident() {
                    Some((ident, rest)) => Ok((ident, rest)),
                    None => Err(cursor.error("expected ident")),
                })
            }

            fn unraw(&self) -> Ident {
                let string = self.to_string();
                if let Some(string) = string.strip_prefix("r#") {
                    Ident::new(string, self.span())
                } else {
                    self.clone()
                }
            }
        }

        impl Peek for private::PeekFn {
            type Token = private::IdentAny;
        }

        impl CustomToken for private::IdentAny {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.ident().is_some()
            }

            fn display() -> &'static str {
                "identifier"
            }
        }

        impl lookahead::Sealed for private::PeekFn {}

        mod private {
            use ::process::macros::Ident;

            pub trait Sealed {}

            impl Sealed for Ident {}

            pub struct PeekFn;
            pub struct IdentAny;

            impl Copy for PeekFn {}
            impl Clone for PeekFn {
                fn clone(&self) -> Self {
                    *self
                }
            }
        }
    }
    
    pub mod file
    {
        use ::
        {
            syntax::
            {
                attr::{ Attribute },
                item::{ Item },
            },
            *,
        };
        /*
        */
        ast_struct!
        {
            /// A complete file of Rust source code.
            pub struct File {
                pub shebang: Option<String>,
                pub attrs: Vec<Attribute>,
                pub items: Vec<Item>,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    attr::Attribute,
                    error::Result,
                    file::File,
                    parse::{Parse, ParseStream},
                },
                *,
            };
            
            impl Parse for File
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (File {
                        shebang: None,
                        attrs: input.call(Attribute::parse_inner)?,
                        items: {
                            let mut items = Vec::new();
                            while !input.is_empty() {
                                items.push(input.parse()?);
                            }
                            items
                        },
                    })
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    attr::FilterAttrs,
                    file::File,
                },
                *,
            };
            
            impl ToTokens for File {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.inner());
                    tokens.append_all(&self.items);
                }
            }
        }
    } pub use self::file::{ File };
    
    pub mod fixup
    {
        use ::
        {
            syntax::
            {
                expr::{ Expr, ExprBreak, ExprRange, ExprRawAddr, ExprReference, ExprReturn, ExprUnary, ExprYield },
                precedence::{ Precedence },
                ty::{ ReturnType },
                classify
            },
            *,
        };
        /*
        */
        pub struct FixupContext
        {
                previous_operator: Precedence,
                next_operator: Precedence,

           
           
            //
           
           
            //
           
            //
           
            //
                stmt: bool,

           
            //
           
            //
           
            //
           
           
           
            //
           
            //
           
            //
           
            //
           
            //
           
            //
           
           
           
            //
           
            //
           
            //
           
                leftmost_subexpression_in_stmt: bool,

           
            //
           
           
           
           
            //
           
            //
           
           
           
            //
                match_arm: bool,

           
           
            //
           
           
           
            //
           
            //
           
           
           
            //
                leftmost_subexpression_in_match_arm: bool,

           
            //
           
            //
           
           
           
            //
                condition: bool,

           
            //
           
            //
           
            //
                rightmost_subexpression_in_condition: bool,

           
            //
           
            //
           
            //
                leftmost_subexpression_in_optional_operand: bool,

           
            //
           
            //
           
            //
                next_operator_can_begin_expr: bool,

           
            //
           
            //
           
            //
                next_operator_can_continue_expr: bool,

           
            //
           
            //
           
            //
           
            next_operator_can_begin_generics: bool,
        }

        impl FixupContext 
        {
            /// The default amount of fixing is minimal fixing. Fixups should be turned
            /// on in a targeted fashion where needed.
            pub const NONE: Self = FixupContext {
                        previous_operator: Precedence::MIN,
                        next_operator: Precedence::MIN,
                        stmt: false,
                        leftmost_subexpression_in_stmt: false,
                        match_arm: false,
                        leftmost_subexpression_in_match_arm: false,
                        condition: false,
                        rightmost_subexpression_in_condition: false,
                        leftmost_subexpression_in_optional_operand: false,
                        next_operator_can_begin_expr: false,
                        next_operator_can_continue_expr: false,
                next_operator_can_begin_generics: false,
            };

            /// Create the initial fixup for printing an expression in statement
            /// position.
                pub fn new_stmt() -> Self {
                FixupContext {
                    stmt: true,
                    ..FixupContext::NONE
                }
            }
            /// Create the initial fixup for printing an expression as the right-hand
            /// side of a match arm.
                pub fn new_match_arm() -> Self {
                FixupContext {
                    match_arm: true,
                    ..FixupContext::NONE
                }
            }
            /// Create the initial fixup for printing an expression as the "condition"
            /// of an `if` or `while`. There are a few other positions which are
            /// grammatically equivalent and also use this, such as the iterator
            /// expression in `for` and the scrutinee in `match`.
                pub fn new_condition() -> Self {
                FixupContext {
                    condition: true,
                    rightmost_subexpression_in_condition: true,
                    ..FixupContext::NONE
                }
            }
            /// Transform this fixup into the one that should apply when printing the
            /// leftmost subexpression of the current expression.
            /// leftmost subexpression.
            pub fn leftmost_subexpression_with_operator(
                self,
                expr: &Expr,
                next_operator_can_begin_expr: bool,
                next_operator_can_begin_generics: bool,
                precedence: Precedence,
            ) -> (Precedence, Self) {
                let fixup = FixupContext {
                                next_operator: precedence,
                                stmt: false,
                                leftmost_subexpression_in_stmt: self.stmt || self.leftmost_subexpression_in_stmt,
                                match_arm: false,
                                leftmost_subexpression_in_match_arm: self.match_arm
                        || self.leftmost_subexpression_in_match_arm,
                                rightmost_subexpression_in_condition: false,
                                next_operator_can_begin_expr,
                                next_operator_can_continue_expr: true,
                    next_operator_can_begin_generics,
                    ..self
                };

                (fixup.leftmost_subexpression_precedence(expr), fixup)
            }
            /// Transform this fixup into the one that should apply when printing a
            /// leftmost subexpression followed by a `.` or `?` token, which confer
            /// different statement boundary rules compared to other leftmost
            /// subexpressions.
            pub fn leftmost_subexpression_with_dot(self, expr: &Expr) -> (Precedence, Self) {
                let fixup = FixupContext {
                                next_operator: Precedence::Unambiguous,
                                stmt: self.stmt || self.leftmost_subexpression_in_stmt,
                                leftmost_subexpression_in_stmt: false,
                                match_arm: self.match_arm || self.leftmost_subexpression_in_match_arm,
                                leftmost_subexpression_in_match_arm: false,
                                rightmost_subexpression_in_condition: false,
                                next_operator_can_begin_expr: false,
                                next_operator_can_continue_expr: true,
                    next_operator_can_begin_generics: false,
                    ..self
                };

                (fixup.leftmost_subexpression_precedence(expr), fixup)
            }

            fn leftmost_subexpression_precedence(self, expr: &Expr) -> Precedence {
                        if !self.next_operator_can_begin_expr || self.next_operator == Precedence::Range {
                    if let Scan::Bailout = scan_right(expr, self, Precedence::MIN, 0, 0) {
                        if scan_left(expr, self) {
                            return Precedence::Unambiguous;
                        }
                    }
                }

                self.precedence(expr)
            }
            /// Transform this fixup into the one that should apply when printing the
            /// rightmost subexpression of the current expression.
            /// rightmost subexpression.
            pub fn rightmost_subexpression(
                self,
                expr: &Expr,
                precedence: Precedence,
            ) -> (Precedence, Self) {
                let fixup = self.rightmost_subexpression_fixup(
                                false,
                                false,
                                precedence,
                );
                (fixup.rightmost_subexpression_precedence(expr), fixup)
            }

            pub fn rightmost_subexpression_fixup(
                self,
                reset_allow_struct: bool,
                optional_operand: bool,
                precedence: Precedence,
            ) -> Self {
                FixupContext {
                                previous_operator: precedence,
                                stmt: false,
                                leftmost_subexpression_in_stmt: false,
                                match_arm: false,
                                leftmost_subexpression_in_match_arm: false,
                                condition: self.condition && !reset_allow_struct,
                                leftmost_subexpression_in_optional_operand: self.condition && optional_operand,
                    ..self
                }
            }

            pub fn rightmost_subexpression_precedence(self, expr: &Expr) -> Precedence {
                let default_prec = self.precedence(expr);

                        if match self.previous_operator {
                    Precedence::Assign | Precedence::Let | Precedence::Prefix => {
                        default_prec < self.previous_operator
                    }
                    _ => default_prec <= self.previous_operator,
                } && match self.next_operator {
                    Precedence::Range | Precedence::Or | Precedence::And => true,
                    _ => !self.next_operator_can_begin_expr,
                } {
                    if let Scan::Bailout | Scan::Fail = scan_right(expr, self, self.previous_operator, 1, 0)
                    {
                        if scan_left(expr, self) {
                            return Precedence::Prefix;
                        }
                    }
                }

                default_prec
            }
            /// Determine whether parentheses are needed around the given expression to
            /// head off the early termination of a statement or condition.
                pub fn parenthesize(self, expr: &Expr) -> bool
        {
                (self.leftmost_subexpression_in_stmt && !classify::requires_semi_to_be_stmt(expr))
                    || ((self.stmt || self.leftmost_subexpression_in_stmt) && matches!(expr, Expr::Let(_)))
                    || (self.leftmost_subexpression_in_match_arm
                        && !classify::requires_comma_to_be_match_arm(expr))
                    || (self.condition && matches!(expr, Expr::Struct(_)))
                    || (self.rightmost_subexpression_in_condition
                        && matches!(
                            expr,
                            Expr::Return(ExprReturn { expr: None, .. })
                                | Expr::Yield(ExprYield { expr: None, .. })
                        ))
                    || (self.rightmost_subexpression_in_condition
                        && !self.condition
                        && matches!(
                            expr,
                            Expr::Break(ExprBreak { expr: None, .. })
                                | Expr::Path(_)
                                | Expr::Range(ExprRange { end: None, .. })
                        ))
                    || (self.leftmost_subexpression_in_optional_operand
                        && matches!(expr, Expr::Block(expr) if expr.attrs.is_empty() && expr.label.is_none()))
            }
            /// Determines the effective precedence of a subexpression. Some expressions
            /// have higher or lower precedence when adjacent to particular operators.
            fn precedence(self, expr: &Expr) -> Precedence {
                        if self.next_operator_can_begin_expr {
                   
                   
                   
                    if let Expr::Break(ExprBreak { expr: None, .. })
                    | Expr::Return(ExprReturn { expr: None, .. })
                    | Expr::Yield(ExprYield { expr: None, .. }) = expr
                    {
                        return Precedence::Jump;
                    }
                }

                        if !self.next_operator_can_continue_expr {
                    match expr {
                       
                       
                        Expr::Break(_)
                        | Expr::Closure(_)
                        | Expr::Let(_)
                        | Expr::Return(_)
                        | Expr::Yield(_) => {
                            return Precedence::Prefix;
                        }
                        Expr::Range(e) if e.start.is_none() => return Precedence::Prefix,
                        _ => {}
                    }
                }

                if self.next_operator_can_begin_generics {
                    if let Expr::Cast(cast) = expr {
                        if classify::trailing_unparameterized_path(&cast.ty) {
                            return Precedence::MIN;
                        }
                    }
                }

                Precedence::of(expr)
            }
        }

        impl Copy for FixupContext {}

        impl Clone for FixupContext 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        enum Scan 
        {
            Fail,
            Bailout,
            Consume,
        }

        impl Copy for Scan {}

        impl Clone for Scan 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl PartialEq for Scan 
        {
            fn eq(&self, other: &Self) -> bool
        {
                *self as u8 == *other as u8
            }
        }

        fn scan_left(expr: &Expr, fixup: FixupContext) -> bool 
        {
            match expr {
                Expr::Assign(_) => fixup.previous_operator <= Precedence::Assign,
                Expr::Binary(e) => match Precedence::of_binop(&e.op) {
                    Precedence::Assign => fixup.previous_operator <= Precedence::Assign,
                    binop_prec => fixup.previous_operator < binop_prec,
                },
                Expr::Cast(_) => fixup.previous_operator < Precedence::Cast,
                Expr::Range(e) => e.start.is_none() || fixup.previous_operator < Precedence::Assign,
                _ => true,
            }
        }

        fn scan_right
        (
            expr: &Expr,
            fixup: FixupContext,
            precedence: Precedence,
            fail_offset: u8,
            bailout_offset: u8,
        ) -> Scan 
        {
            let consume_by_precedence = if match precedence {
                Precedence::Assign | Precedence::Compare => precedence <= fixup.next_operator,
                _ => precedence < fixup.next_operator,
            } || fixup.next_operator == Precedence::MIN
            {
                Scan::Consume
            } else {
                Scan::Bailout
            };
            if fixup.parenthesize(expr) {
                return consume_by_precedence;
            }
            match expr {
                Expr::Assign(e) if e.attrs.is_empty() =>
                {
                    if match fixup.next_operator {
                        Precedence::Unambiguous => fail_offset >= 2,
                        _ => bailout_offset >= 1,
                    } {
                        return Scan::Consume;
                    }
                    let right_fixup = fixup.rightmost_subexpression_fixup(false, false, Precedence::Assign);
                    let scan = scan_right(
                        &e.right,
                        right_fixup,
                        Precedence::Assign,
                        match fixup.next_operator {
                            Precedence::Unambiguous => fail_offset,
                            _ => 1,
                        },
                        1,
                    );
                    if let Scan::Bailout | Scan::Consume = scan {
                        Scan::Consume
                    } else if let Precedence::Unambiguous = fixup.next_operator {
                        Scan::Fail
                    } else {
                        Scan::Bailout
                    }
                }
                Expr::Binary(e) if e.attrs.is_empty() =>
                {
                    if match fixup.next_operator {
                        Precedence::Unambiguous => {
                            fail_offset >= 2
                                && (consume_by_precedence == Scan::Consume || bailout_offset >= 1)
                        }
                        _ => bailout_offset >= 1,
                    } {
                        return Scan::Consume;
                    }
                    let binop_prec = Precedence::of_binop(&e.op);
                    if binop_prec == Precedence::Compare && fixup.next_operator == Precedence::Compare {
                        return Scan::Consume;
                    }
                    let right_fixup = fixup.rightmost_subexpression_fixup(false, false, binop_prec);
                    let scan = scan_right(
                        &e.right,
                        right_fixup,
                        binop_prec,
                        match fixup.next_operator {
                            Precedence::Unambiguous => fail_offset,
                            _ => 1,
                        },
                        consume_by_precedence as u8 - Scan::Bailout as u8,
                    );
                    match scan {
                        Scan::Fail => {}
                        Scan::Bailout => return consume_by_precedence,
                        Scan::Consume => return Scan::Consume,
                    }
                    let right_needs_group = binop_prec != Precedence::Assign
                        && right_fixup.rightmost_subexpression_precedence(&e.right) <= binop_prec;
                    if right_needs_group {
                        consume_by_precedence
                    } else if let (Scan::Fail, Precedence::Unambiguous) = (scan, fixup.next_operator) {
                        Scan::Fail
                    } else {
                        Scan::Bailout
                    }
                }
                Expr::RawAddr(ExprRawAddr { expr, .. })
                | Expr::Reference(ExprReference { expr, .. })
                | Expr::Unary(ExprUnary { expr, .. }) =>
                {
                    if match fixup.next_operator {
                        Precedence::Unambiguous => {
                            fail_offset >= 2
                                && (consume_by_precedence == Scan::Consume || bailout_offset >= 1)
                        }
                        _ => bailout_offset >= 1,
                    } {
                        return Scan::Consume;
                    }
                    let right_fixup = fixup.rightmost_subexpression_fixup(false, false, Precedence::Prefix);
                    let scan = scan_right(
                        expr,
                        right_fixup,
                        precedence,
                        match fixup.next_operator {
                            Precedence::Unambiguous => fail_offset,
                            _ => 1,
                        },
                        consume_by_precedence as u8 - Scan::Bailout as u8,
                    );
                    match scan {
                        Scan::Fail => {}
                        Scan::Bailout => return consume_by_precedence,
                        Scan::Consume => return Scan::Consume,
                    }
                    if right_fixup.rightmost_subexpression_precedence(expr) < Precedence::Prefix {
                        consume_by_precedence
                    } else if let (Scan::Fail, Precedence::Unambiguous) = (scan, fixup.next_operator) {
                        Scan::Fail
                    } else {
                        Scan::Bailout
                    }
                }
                Expr::Range(e) if e.attrs.is_empty() => match &e.end {
                    Some(end) => {
                        if fail_offset >= 2 {
                            return Scan::Consume;
                        }
                        let right_fixup =
                            fixup.rightmost_subexpression_fixup(false, true, Precedence::Range);
                        let scan = scan_right(
                            end,
                            right_fixup,
                            Precedence::Range,
                            fail_offset,
                            match fixup.next_operator {
                                Precedence::Assign | Precedence::Range => 0,
                                _ => 1,
                            },
                        );
                        if match (scan, fixup.next_operator) {
                            (Scan::Fail, _) => false,
                            (Scan::Bailout, Precedence::Assign | Precedence::Range) => false,
                            (Scan::Bailout | Scan::Consume, _) => true,
                        } {
                            return Scan::Consume;
                        }
                        if right_fixup.rightmost_subexpression_precedence(end) <= Precedence::Range {
                            Scan::Consume
                        } else {
                            Scan::Fail
                        }
                    }
                    None => {
                        if fixup.next_operator_can_begin_expr {
                            Scan::Consume
                        } else {
                            Scan::Fail
                        }
                    }
                },
                Expr::Break(e) => match &e.expr {
                    Some(value) => {
                        if bailout_offset >= 1 || e.label.is_none() && classify::expr_leading_label(value) {
                            return Scan::Consume;
                        }
                        let right_fixup = fixup.rightmost_subexpression_fixup(true, true, Precedence::Jump);
                        match scan_right(value, right_fixup, Precedence::Jump, 1, 1) {
                            Scan::Fail => Scan::Bailout,
                            Scan::Bailout | Scan::Consume => Scan::Consume,
                        }
                    }
                    None => match fixup.next_operator {
                        Precedence::Assign if precedence > Precedence::Assign => Scan::Fail,
                        _ => Scan::Consume,
                    },
                },
                Expr::Return(ExprReturn { expr, .. }) | Expr::Yield(ExprYield { expr, .. }) => match expr {
                    Some(e) => {
                        if bailout_offset >= 1 {
                            return Scan::Consume;
                        }
                        let right_fixup =
                            fixup.rightmost_subexpression_fixup(true, false, Precedence::Jump);
                        match scan_right(e, right_fixup, Precedence::Jump, 1, 1) {
                            Scan::Fail => Scan::Bailout,
                            Scan::Bailout | Scan::Consume => Scan::Consume,
                        }
                    }
                    None => match fixup.next_operator {
                        Precedence::Assign if precedence > Precedence::Assign => Scan::Fail,
                        _ => Scan::Consume,
                    },
                },
                Expr::Closure(e) =>
                {
                    if matches!(e.output, ReturnType::Default)
                        || matches!(&*e.body, Expr::Block(body) if body.attrs.is_empty() && body.label.is_none())
                    {
                        if bailout_offset >= 1 {
                            return Scan::Consume;
                        }
                        let right_fixup =
                            fixup.rightmost_subexpression_fixup(false, false, Precedence::Jump);
                        match scan_right(&e.body, right_fixup, Precedence::Jump, 1, 1) {
                            Scan::Fail => Scan::Bailout,
                            Scan::Bailout | Scan::Consume => Scan::Consume,
                        }
                    } else {
                        Scan::Consume
                    }
                }
                Expr::Let(e) =>
                {
                    if bailout_offset >= 1 {
                        return Scan::Consume;
                    }
                    let right_fixup = fixup.rightmost_subexpression_fixup(false, false, Precedence::Let);
                    let scan = scan_right(
                        &e.expr,
                        right_fixup,
                        Precedence::Let,
                        1,
                        if fixup.next_operator < Precedence::Let {
                            0
                        } else {
                            1
                        },
                    );
                    match scan {
                        Scan::Fail | Scan::Bailout if fixup.next_operator < Precedence::Let => {
                            return Scan::Bailout;
                        }
                        Scan::Consume => return Scan::Consume,
                        _ => {}
                    }
                    if right_fixup.rightmost_subexpression_precedence(&e.expr) < Precedence::Let {
                        Scan::Consume
                    } else if let Scan::Fail = scan {
                        Scan::Bailout
                    } else {
                        Scan::Consume
                    }
                }
                Expr::Array(_)
                | Expr::Assign(_)
                | Expr::Async(_)
                | Expr::Await(_)
                | Expr::Binary(_)
                | Expr::Block(_)
                | Expr::Call(_)
                | Expr::Cast(_)
                | Expr::Const(_)
                | Expr::Continue(_)
                | Expr::Field(_)
                | Expr::ForLoop(_)
                | Expr::Group(_)
                | Expr::If(_)
                | Expr::Index(_)
                | Expr::Infer(_)
                | Expr::Lit(_)
                | Expr::Loop(_)
                | Expr::Macro(_)
                | Expr::Match(_)
                | Expr::MethodCall(_)
                | Expr::Paren(_)
                | Expr::Path(_)
                | Expr::Range(_)
                | Expr::Repeat(_)
                | Expr::Struct(_)
                | Expr::Try(_)
                | Expr::TryBlock(_)
                | Expr::Tuple(_)
                | Expr::Unsafe(_)
                | Expr::Verbatim(_)
                | Expr::While(_) => match fixup.next_operator {
                    Precedence::Assign | Precedence::Range if precedence == Precedence::Range => Scan::Fail,
                    _ if precedence == Precedence::Let && fixup.next_operator < Precedence::Let => {
                        Scan::Fail
                    }
                    _ => consume_by_precedence,
                },
            }
        }
    }
    
    pub mod generics
    {
        use ::
        {
            fmt::{self, Debug},
            hash::{Hash, Hasher},
            process::macros::{ TokenStream },
            syntax::
            {
                attr::Attribute,
                expr::Expr,
                ident::Ident,
                lifetime::Lifetime,
                path::Path,
                punctuated::{ Iter, IterMut, Punctuated },
                token,
                ty::Type,
            },
            *,
        };
        /*        
        */
        ast_struct! 
        {
            /// Lifetimes and type parameters attached to a declaration of a function,
            /// enum, trait, etc.
            /// grammar, there may be other tokens in between these two things.
            pub struct Generics {
                pub lt_token: Option<Token![<]>,
                pub params: Punctuated<GenericParam, Token![,]>,
                pub gt_token: Option<Token![>]>,
                pub where_clause: Option<WhereClause>,
            }
        }

        ast_enum_of_structs! 
        {
            /// A generic type parameter, lifetime, or const generic: `T: Into<String>`,
            /// `'a: 'b`, `const LEN: usize`.
            pub enum GenericParam {
                /// A lifetime parameter: `'a: 'b + 'c + 'd`.
                Lifetime(LifetimeParam),
                /// A generic type parameter: `T: Into<String>`.
                Type(TypeParam),
                /// A const generic parameter: `const LENGTH: usize`.
                Const(ConstParam),
            }
        }

        ast_struct! 
        {
            /// A lifetime definition: `'a: 'b + 'c + 'd`.
            pub struct LifetimeParam {
                pub attrs: Vec<Attribute>,
                pub lifetime: Lifetime,
                pub colon_token: Option<Token![:]>,
                pub bounds: Punctuated<Lifetime, Token![+]>,
            }
        }

        ast_struct! 
        {
            /// A generic type parameter: `T: Into<String>`.
            pub struct TypeParam {
                pub attrs: Vec<Attribute>,
                pub ident: Ident,
                pub colon_token: Option<Token![:]>,
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
                pub eq_token: Option<Token![=]>,
                pub default: Option<Type>,
            }
        }

        ast_struct! 
        {
            /// A const generic parameter: `const LENGTH: usize`.
            pub struct ConstParam {
                pub attrs: Vec<Attribute>,
                pub const_token: Token![const],
                pub ident: Ident,
                pub colon_token: Token![:],
                pub ty: Type,
                pub eq_token: Option<Token![=]>,
                pub default: Option<Expr>,
            }
        }

        impl Default for Generics
        {
            fn default() -> Self {
                Generics {
                    lt_token: None,
                    params: Punctuated::new(),
                    gt_token: None,
                    where_clause: None,
                }
            }
        }

        impl Generics
        {
            return_impl_trait! 
            {
                /// Iterator over the lifetime parameters in `self.params`.
                pub fn lifetimes(&self) -> impl Iterator<Item = &LifetimeParam> [Lifetimes] {
                    Lifetimes(self.params.iter())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the lifetime parameters in `self.params`.
                pub fn lifetimes_mut(&mut self) -> impl Iterator<Item = &mut LifetimeParam> [LifetimesMut] {
                    LifetimesMut(self.params.iter_mut())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the type parameters in `self.params`.
                pub fn type_params(&self) -> impl Iterator<Item = &TypeParam> [TypeParams] {
                    TypeParams(self.params.iter())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the type parameters in `self.params`.
                pub fn type_params_mut(&mut self) -> impl Iterator<Item = &mut TypeParam> [TypeParamsMut] {
                    TypeParamsMut(self.params.iter_mut())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the constant parameters in `self.params`.
                pub fn const_params(&self) -> impl Iterator<Item = &ConstParam> [ConstParams] {
                    ConstParams(self.params.iter())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the constant parameters in `self.params`.
                pub fn const_params_mut(&mut self) -> impl Iterator<Item = &mut ConstParam> [ConstParamsMut] {
                    ConstParamsMut(self.params.iter_mut())
                }
            }
            /// Initializes an empty `where`-clause if there is not one present already.
            pub fn make_where_clause(&mut self) -> &mut WhereClause
            {
                self.where_clause.get_or_insert_with(|| WhereClause {
                    where_token: <Token![where]>::default(),
                    predicates: Punctuated::new(),
                })
            }
            /// Split a type's generics into the pieces required for impl'ing a trait for that type.
            pub fn split_for_impl(&self) -> (ImplGenerics, TypeGenerics, Option<&WhereClause>) {
                (
                    ImplGenerics(self),
                    TypeGenerics(self),
                    self.where_clause.as_ref(),
                )
            }
        }

        pub struct Lifetimes<'a>(Iter<'a, GenericParam>);

        impl<'a> Iterator for Lifetimes<'a> {
            type Item = &'a LifetimeParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Lifetime(lifetime) = self.0.next()? {
                    Some(lifetime)
                } else {
                    self.next()
                }
            }
        }

        pub struct LifetimesMut<'a>(IterMut<'a, GenericParam>);

        impl<'a> Iterator for LifetimesMut<'a> {
            type Item = &'a mut LifetimeParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Lifetime(lifetime) = self.0.next()? {
                    Some(lifetime)
                } else {
                    self.next()
                }
            }
        }

        pub struct TypeParams<'a>(Iter<'a, GenericParam>);

        impl<'a> Iterator for TypeParams<'a> {
            type Item = &'a TypeParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Type(type_param) = self.0.next()? {
                    Some(type_param)
                } else {
                    self.next()
                }
            }
        }

        pub struct TypeParamsMut<'a>(IterMut<'a, GenericParam>);

        impl<'a> Iterator for TypeParamsMut<'a> {
            type Item = &'a mut TypeParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Type(type_param) = self.0.next()? {
                    Some(type_param)
                } else {
                    self.next()
                }
            }
        }

        pub struct ConstParams<'a>(Iter<'a, GenericParam>);

        impl<'a> Iterator for ConstParams<'a> {
            type Item = &'a ConstParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Const(const_param) = self.0.next()? {
                    Some(const_param)
                } else {
                    self.next()
                }
            }
        }

        pub struct ConstParamsMut<'a>(IterMut<'a, GenericParam>);

        impl<'a> Iterator for ConstParamsMut<'a> {
            type Item = &'a mut ConstParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Const(const_param) = self.0.next()? {
                    Some(const_param)
                } else {
                    self.next()
                }
            }
        }
        /// Returned by `Generics::split_for_impl`.
        pub struct ImplGenerics<'a>(&'a Generics);

        /// Returned by `Generics::split_for_impl`.
        pub struct TypeGenerics<'a>(&'a Generics);

        /// Returned by `TypeGenerics::as_turbofish`.
        pub struct Turbofish<'a>(&'a Generics);
        
        macro_rules! generics_wrapper_impls {
            ($ty:ident) => {
                impl<'a> Clone for $ty<'a> {
                    fn clone(&self) -> Self {
                        $ty(self.0)
                    }
                }

                        impl<'a> Debug for $ty<'a> {
                    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                        formatter
                            .debug_tuple(stringify!($ty))
                            .field(self.0)
                            .finish()
                    }
                }

                        impl<'a> Eq for $ty<'a> {}

                        impl<'a> PartialEq for $ty<'a> {
                    fn eq(&self, other: &Self) -> bool
        {
                        self.0 == other.0
                    }
                }

                        impl<'a> Hash for $ty<'a> {
                    fn hash<H: Hasher>(&self, state: &mut H) {
                        self.0.hash(state);
                    }
                }
            };
        }

        
        generics_wrapper_impls!(ImplGenerics);
                
        generics_wrapper_impls!(TypeGenerics);
                
        generics_wrapper_impls!(Turbofish);
        
        impl<'a> TypeGenerics<'a>
        {
            /// Turn a type's generics like `<X, Y>` into a turbofish like `::<X, Y>`.
            pub fn as_turbofish(&self) -> Turbofish<'a> {
                Turbofish(self.0)
            }
        }

        ast_struct! {
            /// A set of bound lifetimes: `for<'a, 'b, 'c>`.
            pub struct BoundLifetimes {
                pub for_token: Token![for],
                pub lt_token: Token![<],
                pub lifetimes: Punctuated<GenericParam, Token![,]>,
                pub gt_token: Token![>],
            }
        }

        impl Default for BoundLifetimes {
            fn default() -> Self {
                BoundLifetimes {
                    for_token: Default::default(),
                    lt_token: Default::default(),
                    lifetimes: Punctuated::new(),
                    gt_token: Default::default(),
                }
            }
        }

        impl LifetimeParam {
            pub fn new(lifetime: Lifetime) -> Self {
                LifetimeParam {
                    attrs: Vec::new(),
                    lifetime,
                    colon_token: None,
                    bounds: Punctuated::new(),
                }
            }
        }

        impl From<Ident> for TypeParam {
            fn from(ident: Ident) -> Self {
                TypeParam {
                    attrs: vec![],
                    ident,
                    colon_token: None,
                    bounds: Punctuated::new(),
                    eq_token: None,
                    default: None,
                }
            }
        }

        ast_enum_of_structs! {
            /// A trait or lifetime used as a bound on a type parameter.
            #[non_exhaustive]
            pub enum TypeParamBound {
                Trait(TraitBound),
                Lifetime(Lifetime),
                PreciseCapture(PreciseCapture),
                Verbatim(TokenStream),
            }
        }

        ast_struct! {
            /// A trait used as a bound on a type parameter.
            pub struct TraitBound {
                pub paren_token: Option<token::Paren>,
                pub modifier: TraitBoundModifier,
                /// The `for<'a>` in `for<'a> Foo<&'a T>`
                pub lifetimes: Option<BoundLifetimes>,
                /// The `Foo<&'a T>` in `for<'a> Foo<&'a T>`
                pub path: Path,
            }
        }

        ast_enum! {
            /// A modifier on a trait bound, currently only used for the `?` in
            /// `?Sized`.
            pub enum TraitBoundModifier {
                None,
                Maybe(Token![?]),
            }
        }

        ast_struct! {
            /// Precise capturing bound: the 'use&lt;&hellip;&gt;' in `impl Trait +
            /// use<'a, T>`.
            pub struct PreciseCapture #full {
                pub use_token: Token![use],
                pub lt_token: Token![<],
                pub params: Punctuated<CapturedParam, Token![,]>,
                pub gt_token: Token![>],
            }
        }

        ast_enum! {
            /// Single parameter in a precise capturing bound.
            #[non_exhaustive]
            pub enum CapturedParam {
                /// A lifetime parameter in precise capturing bound: `fn f<'a>() -> impl
                /// Trait + use<'a>`.
                Lifetime(Lifetime),
                /// A type parameter or const generic parameter in precise capturing
                /// bound: `fn f<T>() -> impl Trait + use<T>` or `fn f<const K: T>() ->
                /// impl Trait + use<K>`.
                Ident(Ident),
            }
        }

        ast_struct! {
            /// A `where` clause in a definition: `where T: Deserialize<'de>, D:
            /// 'static`.
            pub struct WhereClause {
                pub where_token: Token![where],
                pub predicates: Punctuated<WherePredicate, Token![,]>,
            }
        }

        ast_enum_of_structs! {
            /// A single predicate in a `where` clause: `T: Deserialize<'de>`.
            #[non_exhaustive]
            pub enum WherePredicate {
                /// A lifetime predicate in a `where` clause: `'a: 'b + 'c`.
                Lifetime(PredicateLifetime),
                /// A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.
                Type(PredicateType),
            }
        }

        ast_struct! {
            /// A lifetime predicate in a `where` clause: `'a: 'b + 'c`.
            pub struct PredicateLifetime {
                pub lifetime: Lifetime,
                pub colon_token: Token![:],
                pub bounds: Punctuated<Lifetime, Token![+]>,
            }
        }

        ast_struct! {
            /// A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.
            pub struct PredicateType {
                /// Any lifetimes from a `for` binding
                pub lifetimes: Option<BoundLifetimes>,
                /// The type being bounded
                pub bounded_ty: Type,
                pub colon_token: Token![:],
                /// Trait and lifetime bounds (`Clone+Send+'static`)
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    attr::{ Attribute },
                    error::{ self, Error, Result },
                    ext::{ IdentExt as _ },
                    generics::
                    {
                        BoundLifetimes, ConstParam, GenericParam, Generics, LifetimeParam, PredicateLifetime, 
                        PredicateType, TraitBound, TraitBoundModifier, TypeParam, TypeParamBound, WhereClause, 
                        WherePredicate,
                    },
                    ident::{ Ident },
                    lifetime::{ Lifetime },
                    parse::{ Parse, ParseStream },
                    path::{ self, ParenthesizedGenericArguments, Path, PathArguments },
                    punctuated::{ Punctuated },
                    ty::{ Type },
                    *,

                },
                *,
            };
            /*
            */
            impl Parse for Generics
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if !input.peek(Token![<]) {
                        return Ok(Generics::default());
                    }

                    let lt_token: Token![<] = input.parse()?;

                    let mut params = Punctuated::new();
                    loop {
                        if input.peek(Token![>]) {
                            break;
                        }

                        let attrs = input.call(Attribute::parse_outer)?;
                        let lookahead = input.lookahead1();
                        if lookahead.peek(Lifetime) {
                            params.push_value(GenericParam::Lifetime(LifetimeParam {
                                attrs,
                                ..input.parse()?
                            }));
                        } else if lookahead.peek(Ident) {
                            params.push_value(GenericParam::Type(TypeParam {
                                attrs,
                                ..input.parse()?
                            }));
                        } else if lookahead.peek(Token![const]) {
                            params.push_value(GenericParam::Const(ConstParam {
                                attrs,
                                ..input.parse()?
                            }));
                        } else if input.peek(Token![_]) {
                            params.push_value(GenericParam::Type(TypeParam {
                                attrs,
                                ident: input.call(Ident::parse_any)?,
                                colon_token: None,
                                bounds: Punctuated::new(),
                                eq_token: None,
                                default: None,
                            }));
                        } else {
                            return Err(lookahead.error());
                        }

                        if input.peek(Token![>]) {
                            break;
                        }
                        let punct = input.parse()?;
                        params.push_punct(punct);
                    }

                    let gt_token: Token![>] = input.parse()?;

                    Ok(Generics {
                        lt_token: Some(lt_token),
                        params,
                        gt_token: Some(gt_token),
                        where_clause: None,
                    })
                }
            }

            impl Parse for GenericParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;

                    let lookahead = input.lookahead1();
                    if lookahead.peek(Ident) {
                        Ok(GenericParam::Type(TypeParam {
                            attrs,
                            ..input.parse()?
                        }))
                    } else if lookahead.peek(Lifetime) {
                        Ok(GenericParam::Lifetime(LifetimeParam {
                            attrs,
                            ..input.parse()?
                        }))
                    } else if lookahead.peek(Token![const]) {
                        Ok(GenericParam::Const(ConstParam {
                            attrs,
                            ..input.parse()?
                        }))
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            impl Parse for LifetimeParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let has_colon;
                    Ok(LifetimeParam {
                        attrs: input.call(Attribute::parse_outer)?,
                        lifetime: input.parse()?,
                        colon_token: {
                            if input.peek(Token![:]) {
                                has_colon = true;
                                Some(input.parse()?)
                            } else {
                                has_colon = false;
                                None
                            }
                        },
                        bounds: {
                            let mut bounds = Punctuated::new();
                            if has_colon {
                                loop {
                                    if input.peek(Token![,]) || input.peek(Token![>]) {
                                        break;
                                    }
                                    let value = input.parse()?;
                                    bounds.push_value(value);
                                    if !input.peek(Token![+]) {
                                        break;
                                    }
                                    let punct = input.parse()?;
                                    bounds.push_punct(punct);
                                }
                            }
                            bounds
                        },
                    })
                }
            }

            impl Parse for BoundLifetimes
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (BoundLifetimes {
                        for_token: input.parse()?,
                        lt_token: input.parse()?,
                        lifetimes: {
                            let mut lifetimes = Punctuated::new();
                            while !input.peek(Token![>]) {
                                lifetimes.push_value(input.parse()?);
                                if input.peek(Token![>]) {
                                    break;
                                }
                                lifetimes.push_punct(input.parse()?);
                            }
                            lifetimes
                        },
                        gt_token: input.parse()?,
                    })
                }
            }

            impl Parse for Option<BoundLifetimes>
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![for]) {
                        input.parse().map(Some)
                    } else {
                        Ok(None)
                    }
                }
            }

            impl Parse for TypeParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let ident: Ident = input.parse()?;
                    let colon_token: Option<Token![:]> = input.parse()?;

                    let mut bounds = Punctuated::new();
                    if colon_token.is_some() {
                        loop {
                            if input.peek(Token![,]) || input.peek(Token![>]) || input.peek(Token![=]) {
                                break;
                            }
                            bounds.push_value({
                                let allow_precise_capture = false;
                                let allow_const = true;
                                TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                            });
                            if !input.peek(Token![+]) {
                                break;
                            }
                            let punct: Token![+] = input.parse()?;
                            bounds.push_punct(punct);
                        }
                    }

                    let eq_token: Option<Token![=]> = input.parse()?;
                    let default = if eq_token.is_some() {
                        Some(input.parse::<Type>()?)
                    } else {
                        None
                    };

                    Ok(TypeParam {
                        attrs,
                        ident,
                        colon_token,
                        bounds,
                        eq_token,
                        default,
                    })
                }
            }

            impl Parse for TypeParamBound
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_precise_capture = true;
                    let allow_const = true;
                    Self::parse_single(input, allow_precise_capture, allow_const)
                }
            }

            impl TypeParamBound 
            {
                pub fn parse_single(
                    input: ParseStream,
                    #[cfg_attr(not(feature = "full"), allow(unused_variables))] allow_precise_capture: bool,
                    allow_const: bool,
                ) -> Result<Self>
                {
                    if input.peek(Lifetime) {
                        return input.parse().map(TypeParamBound::Lifetime);
                    }

                                {
                        if input.peek(Token![use]) {
                            let precise_capture: PreciseCapture = input.parse()?;
                            return if allow_precise_capture {
                                Ok(TypeParamBound::PreciseCapture(precise_capture))
                            } else {
                                let msg = "`use<...>` precise capturing syntax is not allowed here";
                                Err(error::new2(
                                    precise_capture.use_token.span,
                                    precise_capture.gt_token.span,
                                    msg,
                                ))
                            };
                        }
                    }

                    let begin = input.fork();

                    let content;
                    let (paren_token, content) = if input.peek(token::Paren) {
                        (Some(parenthesized!(content in input)), &content)
                    } else {
                        (None, input)
                    };

                    if let Some(mut bound) = TraitBound::do_parse(content, allow_const)? {
                        bound.paren_token = paren_token;
                        Ok(TypeParamBound::Trait(bound))
                    } else {
                        Ok(TypeParamBound::Verbatim(verbatim::between(&begin, input)))
                    }
                }

                pub fn parse_multiple(
                    input: ParseStream,
                    allow_plus: bool,
                    allow_precise_capture: bool,
                    allow_const: bool,
                ) -> Result<Punctuated<Self, Token![+]>> {
                    let mut bounds = Punctuated::new();
                    loop {
                        let bound = Self::parse_single(input, allow_precise_capture, allow_const)?;
                        bounds.push_value(bound);
                        if !(allow_plus && input.peek(Token![+])) {
                            break;
                        }
                        bounds.push_punct(input.parse()?);
                        if !(input.peek(Ident::peek_any)
                            || input.peek(Token![::])
                            || input.peek(Token![?])
                            || input.peek(Lifetime)
                            || input.peek(token::Paren)
                            || (allow_const && (input.peek(token::Bracket) || input.peek(Token![const]))))
                        {
                            break;
                        }
                    }
                    Ok(bounds)
                }
            }

            impl Parse for TraitBound
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_const = false;
                    Self::do_parse(input, allow_const).map(Option::unwrap)
                }
            }

            impl TraitBound 
            {
                fn do_parse(input: ParseStream, allow_const: bool) -> Result<Option<Self>> {
                    let mut lifetimes: Option<BoundLifetimes> = input.parse()?;

                    let is_conditionally_const = cfg!(feature = "full") && input.peek(token::Bracket);
                    let is_unconditionally_const = cfg!(feature = "full") && input.peek(Token![const]);
                    if is_conditionally_const {
                        let conditionally_const;
                        let bracket_token = bracketed!(conditionally_const in input);
                        conditionally_const.parse::<Token![const]>()?;
                        if !allow_const {
                            let msg = "`[const]` is not allowed here";
                            return Err(Error::new(bracket_token.span.join(), msg));
                        }
                    } else if is_unconditionally_const {
                        let const_token: Token![const] = input.parse()?;
                        if !allow_const {
                            let msg = "`const` is not allowed here";
                            return Err(Error::new(const_token.span, msg));
                        }
                    }

                    let modifier: TraitBoundModifier = input.parse()?;
                    if lifetimes.is_none() && matches!(modifier, TraitBoundModifier::Maybe(_)) {
                        lifetimes = input.parse()?;
                    }

                    let mut path: Path = input.parse()?;
                    if path.segments.last().unwrap().arguments.is_empty()
                        && (input.peek(token::Paren) || input.peek(Token![::]) && input.peek3(token::Paren))
                    {
                        input.parse::<Option<Token![::]>>()?;
                        let args: ParenthesizedGenericArguments = input.parse()?;
                        let parenthesized = PathArguments::Parenthesized(args);
                        path.segments.last_mut().unwrap().arguments = parenthesized;
                    }

                    if lifetimes.is_some() {
                        match modifier {
                            TraitBoundModifier::None => {}
                            TraitBoundModifier::Maybe(maybe) => {
                                let msg = "`for<...>` binder not allowed with `?` trait polarity modifier";
                                return Err(Error::new(maybe.span, msg));
                            }
                        }
                    }

                    if is_conditionally_const || is_unconditionally_const {
                        Ok(None)
                    } else {
                        Ok(Some(TraitBound {
                            paren_token: None,
                            modifier,
                            lifetimes,
                            path,
                        }))
                    }
                }
            }

            impl Parse for TraitBoundModifier
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![?]) {
                        input.parse().map(TraitBoundModifier::Maybe)
                    } else {
                        Ok(TraitBoundModifier::None)
                    }
                }
            }

            impl Parse for ConstParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut default = None;
                    Ok(ConstParam {
                        attrs: input.call(Attribute::parse_outer)?,
                        const_token: input.parse()?,
                        ident: input.parse()?,
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                        eq_token: {
                            if input.peek(Token![=]) {
                                let eq_token = input.parse()?;
                                default = Some(path::parsing::const_argument(input)?);
                                Some(eq_token)
                            } else {
                                None
                            }
                        },
                        default,
                    })
                }
            }

            impl Parse for WhereClause
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let where_token: Token![where] = input.parse()?;

                    if choose_generics_over_qpath(input) {
                        return Err(input
                            .error("generic parameters on `where` clauses are reserved for future use"));
                    }

                    Ok(WhereClause {
                        where_token,
                        predicates: {
                            let mut predicates = Punctuated::new();
                            loop {
                                if input.is_empty()
                                    || input.peek(token::Brace)
                                    || input.peek(Token![,])
                                    || input.peek(Token![;])
                                    || input.peek(Token![:]) && !input.peek(Token![::])
                                    || input.peek(Token![=])
                                {
                                    break;
                                }
                                let value = input.parse()?;
                                predicates.push_value(value);
                                if !input.peek(Token![,]) {
                                    break;
                                }
                                let punct = input.parse()?;
                                predicates.push_punct(punct);
                            }
                            predicates
                        },
                    })
                }
            }

            impl Parse for Option<WhereClause>
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![where]) {
                        input.parse().map(Some)
                    } else {
                        Ok(None)
                    }
                }
            }

            impl Parse for WherePredicate
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Lifetime) && input.peek2(Token![:])
                    {
                        Ok(WherePredicate::Lifetime
                        (
                            PredicateLifetime
                            {
                                lifetime: input.parse()?,
                                colon_token: input.parse()?,
                                bounds:
                                {
                                    let mut bounds = Punctuated::new();
                                    loop {
                                        if input.is_empty()
                                            || input.peek(token::Brace)
                                            || input.peek(Token![,])
                                            || input.peek(Token![;])
                                            || input.peek(Token![:])
                                            || input.peek(Token![=])
                                        {
                                            break;
                                        }
                                        let value = input.parse()?;
                                        bounds.push_value(value);
                                        if !input.peek(Token![+]) {
                                            break;
                                        }
                                        let punct = input.parse()?;
                                        bounds.push_punct(punct);
                                    }
                                    bounds
                                },
                            } ) )
                    }
                    else
                    {
                        Ok
                        (
                            WherePredicate::Type
                            (
                                PredicateType
                                {
                                    lifetimes: input.parse()?,
                                    bounded_ty: input.parse()?,
                                    colon_token: input.parse()?,
                                    bounds:
                                    {
                                        let mut bounds = Punctuated::new();
                                        loop
                                        {
                                            if input.is_empty()
                                            || input.peek(token::Brace)
                                            || input.peek(Token![,])
                                            || input.peek(Token![;])
                                            || input.peek(Token![:]) && !input.peek(Token![::])
                                            || input.peek(Token![=])
                                            { break; }

                                            bounds.push_value({
                                                let allow_precise_capture = false;
                                                let allow_const = true;
                                                TypeParamBound::parse_single(
                                                    input,
                                                    allow_precise_capture,
                                                    allow_const,
                                                )?
                                            });
                                            if !input.peek(Token![+]) {
                                                break;
                                            }
                                            let punct = input.parse()?;
                                            bounds.push_punct(punct);
                                        }
                                        bounds
                                    },
                                }
                            )
                        )
                    }
                }
            }
            
            impl Parse for PreciseCapture
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let use_token: Token![use] = input.parse()?;
                    let lt_token: Token![<] = input.parse()?;
                    let mut params = Punctuated::new();
                    loop {
                        let lookahead = input.lookahead1();
                        params.push_value(
                            if lookahead.peek(Lifetime) || lookahead.peek(Ident) || input.peek(Token![Self])
                            {
                                input.parse::<CapturedParam>()?
                            } else if lookahead.peek(Token![>]) {
                                break;
                            } else {
                                return Err(lookahead.error());
                            },
                        );
                        let lookahead = input.lookahead1();
                        params.push_punct(if lookahead.peek(Token![,]) {
                            input.parse::<Token![,]>()?
                        } else if lookahead.peek(Token![>]) {
                            break;
                        } else {
                            return Err(lookahead.error());
                        });
                    }
                    let gt_token: Token![>] = input.parse()?;
                    Ok(PreciseCapture {
                        use_token,
                        lt_token,
                        params,
                        gt_token,
                    })
                }
            }
            
            impl Parse for CapturedParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    if lookahead.peek(Lifetime) {
                        input.parse().map(CapturedParam::Lifetime)
                    } else if lookahead.peek(Ident) || input.peek(Token![Self]) {
                        input.call(Ident::parse_any).map(CapturedParam::Ident)
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            pub fn choose_generics_over_qpath(input: ParseStream) -> bool
            {
                input.peek(Token![<])
                        && (input.peek2(Token![>])
                            || input.peek2(Token![#])
                            || (input.peek2(Lifetime) || input.peek2(Ident))
                                && (input.peek3(Token![>])
                                    || input.peek3(Token![,])
                                    || input.peek3(Token![:]) && !input.peek3(Token![::])
                                    || input.peek3(Token![=]))
                            || input.peek2(Token![const]))
            }
            
            pub fn choose_generics_over_qpath_after_keyword(input: ParseStream) -> bool
            {
                let input = input.fork();
                input.call(Ident::parse_any).unwrap();
                choose_generics_over_qpath(&input)
            }
        }
        
        pub mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    attr::FilterAttrs,
                    expr,
                    expr::Expr,
                    fixup::FixupContext,
                    generics::
                    {
                        BoundLifetimes, ConstParam, GenericParam, Generics, ImplGenerics, LifetimeParam,
                        PredicateLifetime, PredicateType, TraitBound, TraitBoundModifier, Turbofish, TypeGenerics,
                        TypeParam, WhereClause, CapturedParam, PreciseCapture
                    },
                    print::TokensOrDefault,
                    token,
                },
                *,
            };
            
            impl ToTokens for Generics {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if self.params.is_empty() {
                        return;
                    }

                    TokensOrDefault(&self.lt_token).to_tokens(tokens);

                   
                   
                    let mut trailing_or_empty = true;
                    for param in self.params.pairs() {
                        if let GenericParam::Lifetime(_) = **param.value() {
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                    }
                    for param in self.params.pairs() {
                        match param.value() {
                            GenericParam::Type(_) | GenericParam::Const(_) => {
                                if !trailing_or_empty {
                                    <Token![,]>::default().to_tokens(tokens);
                                    trailing_or_empty = true;
                                }
                                param.to_tokens(tokens);
                            }
                            GenericParam::Lifetime(_) => {}
                        }
                    }

                    TokensOrDefault(&self.gt_token).to_tokens(tokens);
                }
            }

            impl<'a> ToTokens for ImplGenerics<'a> {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if self.0.params.is_empty() {
                        return;
                    }

                    TokensOrDefault(&self.0.lt_token).to_tokens(tokens);

                   
                   
                    let mut trailing_or_empty = true;
                    for param in self.0.params.pairs() {
                        if let GenericParam::Lifetime(_) = **param.value() {
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                    }
                    for param in self.0.params.pairs() {
                        if let GenericParam::Lifetime(_) = **param.value() {
                            continue;
                        }
                        if !trailing_or_empty {
                            <Token![,]>::default().to_tokens(tokens);
                            trailing_or_empty = true;
                        }
                        match param.value() {
                            GenericParam::Lifetime(_) => unreachable!(),
                            GenericParam::Type(param) => {
                               
                                tokens.append_all(param.attrs.outer());
                                param.ident.to_tokens(tokens);
                                if !param.bounds.is_empty() {
                                    TokensOrDefault(&param.colon_token).to_tokens(tokens);
                                    param.bounds.to_tokens(tokens);
                                }
                            }
                            GenericParam::Const(param) => {
                               
                                tokens.append_all(param.attrs.outer());
                                param.const_token.to_tokens(tokens);
                                param.ident.to_tokens(tokens);
                                param.colon_token.to_tokens(tokens);
                                param.ty.to_tokens(tokens);
                            }
                        }
                        param.punct().to_tokens(tokens);
                    }

                    TokensOrDefault(&self.0.gt_token).to_tokens(tokens);
                }
            }

            impl<'a> ToTokens for TypeGenerics<'a> {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if self.0.params.is_empty() {
                        return;
                    }

                    TokensOrDefault(&self.0.lt_token).to_tokens(tokens);

                   
                   
                    let mut trailing_or_empty = true;
                    for param in self.0.params.pairs() {
                        if let GenericParam::Lifetime(def) = *param.value() {
                           
                            def.lifetime.to_tokens(tokens);
                            param.punct().to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                    }
                    for param in self.0.params.pairs() {
                        if let GenericParam::Lifetime(_) = **param.value() {
                            continue;
                        }
                        if !trailing_or_empty {
                            <Token![,]>::default().to_tokens(tokens);
                            trailing_or_empty = true;
                        }
                        match param.value() {
                            GenericParam::Lifetime(_) => unreachable!(),
                            GenericParam::Type(param) => {
                               
                                param.ident.to_tokens(tokens);
                            }
                            GenericParam::Const(param) => {
                               
                                param.ident.to_tokens(tokens);
                            }
                        }
                        param.punct().to_tokens(tokens);
                    }

                    TokensOrDefault(&self.0.gt_token).to_tokens(tokens);
                }
            }

            impl<'a> ToTokens for Turbofish<'a> {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if !self.0.params.is_empty() {
                        <Token![::]>::default().to_tokens(tokens);
                        TypeGenerics(self.0).to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for BoundLifetimes {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.for_token.to_tokens(tokens);
                    self.lt_token.to_tokens(tokens);
                    self.lifetimes.to_tokens(tokens);
                    self.gt_token.to_tokens(tokens);
                }
            }

            impl ToTokens for LifetimeParam {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.lifetime.to_tokens(tokens);
                    if !self.bounds.is_empty() {
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                        self.bounds.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for TypeParam {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.ident.to_tokens(tokens);
                    if !self.bounds.is_empty() {
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                        self.bounds.to_tokens(tokens);
                    }
                    if let Some(default) = &self.default {
                        TokensOrDefault(&self.eq_token).to_tokens(tokens);
                        default.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for TraitBound {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    let to_tokens = |tokens: &mut TokenStream| {
                        self.modifier.to_tokens(tokens);
                        self.lifetimes.to_tokens(tokens);
                        self.path.to_tokens(tokens);
                    };
                    match &self.paren_token {
                        Some(paren) => paren.surround(tokens, to_tokens),
                        None => to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for TraitBoundModifier {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        TraitBoundModifier::None => {}
                        TraitBoundModifier::Maybe(t) => t.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for ConstParam {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.const_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    if let Some(default) = &self.default {
                        TokensOrDefault(&self.eq_token).to_tokens(tokens);
                        print_const_argument(default, tokens);
                    }
                }
            }

            impl ToTokens for WhereClause {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if !self.predicates.is_empty() {
                        self.where_token.to_tokens(tokens);
                        self.predicates.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for PredicateLifetime {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.lifetime.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }

            impl ToTokens for PredicateType {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.lifetimes.to_tokens(tokens);
                    self.bounded_ty.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }
            
            impl ToTokens for PreciseCapture {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.use_token.to_tokens(tokens);
                    self.lt_token.to_tokens(tokens);

                   
                   
                    let mut trailing_or_empty = true;
                    for param in self.params.pairs() {
                        if let CapturedParam::Lifetime(_) = **param.value() {
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                    }
                    for param in self.params.pairs() {
                        if let CapturedParam::Ident(_) = **param.value() {
                            if !trailing_or_empty {
                                <Token![,]>::default().to_tokens(tokens);
                                trailing_or_empty = true;
                            }
                            param.to_tokens(tokens);
                        }
                    }

                    self.gt_token.to_tokens(tokens);
                }
            }
            
            impl ToTokens for CapturedParam {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        CapturedParam::Lifetime(lifetime) => lifetime.to_tokens(tokens),
                        CapturedParam::Ident(ident) => ident.to_tokens(tokens),
                    }
                }
            }

            pub fn print_const_argument(expr: &Expr, tokens: &mut TokenStream) {
                match expr {
                    Expr::Lit(expr) => expr.to_tokens(tokens),

                    Expr::Path(expr)
                        if expr.attrs.is_empty()
                            && expr.qself.is_none()
                            && expr.path.get_ident().is_some() =>
                    {
                        expr.to_tokens(tokens);
                    }
                    
                    Expr::Block(expr) => expr.to_tokens(tokens),
                    
                   
                    _ => token::Brace::default().surround(tokens, |tokens|
                    {
                        expr::printing::print_expr(expr, tokens, FixupContext::new_stmt());
                    }),
                }
            }
        }
    } pub use self::generics::
    {
        BoundLifetimes, CapturedParam, ImplGenerics, Turbofish, TypeGenerics, PreciseCapture, ConstParam,
        GenericParam, Generics, LifetimeParam,  PredicateLifetime, PredicateType, TraitBound, TraitBoundModifier, 
        TypeParam, TypeParamBound,  WhereClause, WherePredicate,
    };

    pub mod ident
    {
        use ::
        {
            syntax::{ lookahead },
            *,
        };

        pub use process::macros::Ident;
        /*
        */
        macro_rules! ident_from_token
        {
            ($token:ident) =>
            {
                impl From<Token![$token]> for Ident
                {
                    fn from(token: Token![$token]) -> Ident
                    {
                        Ident::new(stringify!($token), token.span)
                    }
                }
            };
        }

        pub_if_not_doc!
        {
            pub fn Ident(marker: lookahead::TokenMarker) -> Ident
            {
                match marker {}
            }
        }

        ident_from_token!(self);
        ident_from_token!(Self);
        ident_from_token!(super);
        ident_from_token!(crate);
        ident_from_token!(extern);

        impl From<Token![_]> for Ident 
        {
            fn from(token: Token![_]) -> Ident {
                Ident::new("_", token.span)
            }
        }

        pub fn xid_ok(symbol: &str) -> bool 
        {
            let mut chars = symbol.chars();
            let first = chars.next().unwrap();
            if !(first == '_' || is::xid_start(first)) {
                return false;
            }
            for ch in chars {
                if !is::xid_continue(ch) {
                    return false;
                }
            }
            true
        }
        
        mod parsing
        {
            use ::
            {
                process::macros::Ident,
                syntax::
                {
                    buffer::Cursor,
                    error::Result,
                    parse::{Parse, ParseStream},
                    token::Token,
                },
                *,
            };

            fn accept_as_ident(ident: &Ident) -> bool
        {
                match ident.to_string().as_str() {
                    "_" |
                   
                    "abstract" | "as" | "async" | "await" | "become" | "box" | "break" |
                    "const" | "continue" | "crate" | "do" | "dyn" | "else" | "enum" |
                    "extern" | "false" | "final" | "fn" | "for" | "if" | "impl" | "in" |
                    "let" | "loop" | "macro" | "match" | "mod" | "move" | "mut" |
                    "override" | "priv" | "pub" | "ref" | "return" | "Self" | "self" |
                    "static" | "struct" | "super" | "trait" | "true" | "try" | "type" |
                    "typeof" | "unsafe" | "unsized" | "use" | "virtual" | "where" |
                    "while" | "yield" => false,
                    _ => true,
                }
            }

            impl Parse for Ident
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    input.step(|cursor| {
                        if let Some((ident, rest)) = cursor.ident() {
                            if accept_as_ident(&ident) {
                                Ok((ident, rest))
                            } else {
                                Err(cursor.error(format_args!(
                                    "expected identifier, found keyword `{}`",
                                    ident,
                                )))
                            }
                        } else {
                            Err(cursor.error("expected identifier"))
                        }
                    })
                }
            }

            impl Token for Ident {
                fn peek(cursor: Cursor) -> bool
        {
                    if let Some((ident, _rest)) = cursor.ident() {
                        accept_as_ident(&ident)
                    } else {
                        false
                    }
                }

                fn display() -> &'static str {
                    "identifier"
                }
            }
        }
    } pub use self::ident::Ident;
    
    pub mod item
    {
        use ::
        {
            process::macros::{ TokenStream },
            syntax::
            {
                attr::Attribute,
                data::{Fields, FieldsNamed, Variant},
                derive::{Data, DataEnum, DataStruct, DataUnion, DeriveInput},
                expr::Expr,
                generics::{Generics, TypeParamBound},
                ident::Ident,
                lifetime::Lifetime,
                mac::Macro,
                pat::{Pat, PatType},
                path::Path,
                punctuated::Punctuated,
                restriction::Visibility,
                stmt::Block,
                token,
                ty::{Abi, ReturnType, Type},
            },
            *,
        };
        /*
        */
        ast_enum_of_structs!
        {
            /// Things that can appear directly inside of a module or scope.
            #[non_exhaustive]
            pub enum Item {
                /// A constant item: `const MAX: u16 = 65535`.
                Const(ItemConst),
                /// An enum definition: `enum Foo<A, B> { A(A), B(B) }`.
                Enum(ItemEnum),
                /// An `extern crate` item: `extern crate serde`.
                ExternCrate(ItemExternCrate),
                /// A free-standing function: `fn process(n: usize) -> Result<()> { ...
                /// }`.
                Fn(ItemFn),
                /// A block of foreign items: `extern "C" { ... }`.
                ForeignMod(ItemForeignMod),
                /// An impl block providing trait or associated items: `impl<A> Trait
                /// for Data<A> { ... }`.
                Impl(ItemImpl),
                /// A macro invocation, which includes `macro_rules!` definitions.
                Macro(ItemMacro),
                /// A module or module declaration: `mod m` or `mod m { ... }`.
                Mod(ItemMod),
                /// A static item: `static BIKE: Shed = Shed(42)`.
                Static(ItemStatic),
                /// A struct definition: `struct Foo<A> { x: A }`.
                Struct(ItemStruct),
                /// A trait definition: `pub trait Iterator { ... }`.
                Trait(ItemTrait),
                /// A trait alias: `pub trait SharableIterator = Iterator + Sync`.
                TraitAlias(ItemTraitAlias),
                /// A type alias: `type Result<T> = std::result::Result<T, MyError>`.
                Type(ItemType),
                /// A union definition: `union Foo<A, B> { x: A, y: B }`.
                Union(ItemUnion),
                /// A use declaration: `use std::collections::HashMap`.
                Use(ItemUse),
                /// Tokens forming an item not interpreted by Syn.
                Verbatim(TokenStream),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// A constant item: `const MAX: u16 = 65535`.
            pub struct ItemConst {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub const_token: Token![const],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Token![:],
                pub ty: Box<Type>,
                pub eq_token: Token![=],
                pub expr: Box<Expr>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// An enum definition: `enum Foo<A, B> { A(A), B(B) }`.
            pub struct ItemEnum {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub enum_token: Token![enum],
                pub ident: Ident,
                pub generics: Generics,
                pub brace_token: token::Brace,
                pub variants: Punctuated<Variant, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// An `extern crate` item: `extern crate serde`.
            pub struct ItemExternCrate {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub extern_token: Token![extern],
                pub crate_token: Token![crate],
                pub ident: Ident,
                pub rename: Option<(Token![as], Ident)>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A free-standing function: `fn process(n: usize) -> Result<()> { ... }`.
            pub struct ItemFn {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub sig: Signature,
                pub block: Box<Block>,
            }
        }

        ast_struct! 
        {
            /// A block of foreign items: `extern "C" { ... }`.
            pub struct ItemForeignMod {
                pub attrs: Vec<Attribute>,
                pub unsafety: Option<Token![unsafe]>,
                pub abi: Abi,
                pub brace_token: token::Brace,
                pub items: Vec<ForeignItem>,
            }
        }

        ast_struct! 
        {
            /// An impl block providing trait or associated items: `impl<A> Trait
            /// for Data<A> { ... }`.
            pub struct ItemImpl {
                pub attrs: Vec<Attribute>,
                pub defaultness: Option<Token![default]>,
                pub unsafety: Option<Token![unsafe]>,
                pub impl_token: Token![impl],
                pub generics: Generics,
                /// Trait this impl implements.
                pub trait_: Option<(Option<Token![!]>, Path, Token![for])>,
                /// The Self type of the impl.
                pub self_ty: Box<Type>,
                pub brace_token: token::Brace,
                pub items: Vec<ImplItem>,
            }
        }

        ast_struct! 
        {
            /// A macro invocation, which includes `macro_rules!` definitions.
            pub struct ItemMacro {
                pub attrs: Vec<Attribute>,
                /// The `example` in `macro_rules! example { ... }`.
                pub ident: Option<Ident>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// A module or module declaration: `mod m` or `mod m { ... }`.
            pub struct ItemMod {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub unsafety: Option<Token![unsafe]>,
                pub mod_token: Token![mod],
                pub ident: Ident,
                pub content: Option<(token::Brace, Vec<Item>)>,
                pub semi: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// A static item: `static BIKE: Shed = Shed(42)`.
            pub struct ItemStatic {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub static_token: Token![static],
                pub mutability: StaticMutability,
                pub ident: Ident,
                pub colon_token: Token![:],
                pub ty: Box<Type>,
                pub eq_token: Token![=],
                pub expr: Box<Expr>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A struct definition: `struct Foo<A> { x: A }`.
            pub struct ItemStruct {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub struct_token: Token![struct],
                pub ident: Ident,
                pub generics: Generics,
                pub fields: Fields,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// A trait definition: `pub trait Iterator { ... }`.
            pub struct ItemTrait {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub unsafety: Option<Token![unsafe]>,
                pub auto_token: Option<Token![auto]>,
                pub restriction: Option<ImplRestriction>,
                pub trait_token: Token![trait],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Option<Token![:]>,
                pub supertraits: Punctuated<TypeParamBound, Token![+]>,
                pub brace_token: token::Brace,
                pub items: Vec<TraitItem>,
            }
        }

        ast_struct! 
        {
            /// A trait alias: `pub trait SharableIterator = Iterator + Sync`.
            pub struct ItemTraitAlias {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub trait_token: Token![trait],
                pub ident: Ident,
                pub generics: Generics,
                pub eq_token: Token![=],
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A type alias: `type Result<T> = std::result::Result<T, MyError>`.
            pub struct ItemType {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub type_token: Token![type],
                pub ident: Ident,
                pub generics: Generics,
                pub eq_token: Token![=],
                pub ty: Box<Type>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A union definition: `union Foo<A, B> { x: A, y: B }`.
            pub struct ItemUnion {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub union_token: Token![union],
                pub ident: Ident,
                pub generics: Generics,
                pub fields: FieldsNamed,
            }
        }

        ast_struct! 
        {
            /// A use declaration: `use std::collections::HashMap`.
            pub struct ItemUse {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub use_token: Token![use],
                pub leading_colon: Option<Token![::]>,
                pub tree: UseTree,
                pub semi_token: Token![;],
            }
        }

        impl Item 
        {
             
                pub fn replace_attrs(&mut self, new: Vec<Attribute>) -> Vec<Attribute>
            {
                match self {
                    Item::Const(ItemConst { attrs, .. })
                    | Item::Enum(ItemEnum { attrs, .. })
                    | Item::ExternCrate(ItemExternCrate { attrs, .. })
                    | Item::Fn(ItemFn { attrs, .. })
                    | Item::ForeignMod(ItemForeignMod { attrs, .. })
                    | Item::Impl(ItemImpl { attrs, .. })
                    | Item::Macro(ItemMacro { attrs, .. })
                    | Item::Mod(ItemMod { attrs, .. })
                    | Item::Static(ItemStatic { attrs, .. })
                    | Item::Struct(ItemStruct { attrs, .. })
                    | Item::Trait(ItemTrait { attrs, .. })
                    | Item::TraitAlias(ItemTraitAlias { attrs, .. })
                    | Item::Type(ItemType { attrs, .. })
                    | Item::Union(ItemUnion { attrs, .. })
                    | Item::Use(ItemUse { attrs, .. }) => mem::replace(attrs, new),
                    Item::Verbatim(_) => Vec::new(),
                }
            }
        }

        impl From<DeriveInput> for Item 
        {
            fn from(input: DeriveInput) -> Item {
                match input.data {
                    Data::Struct(data) => Item::Struct(ItemStruct {
                        attrs: input.attrs,
                        vis: input.vis,
                        struct_token: data.struct_token,
                        ident: input.ident,
                        generics: input.generics,
                        fields: data.fields,
                        semi_token: data.semi_token,
                    }),
                    Data::Enum(data) => Item::Enum(ItemEnum {
                        attrs: input.attrs,
                        vis: input.vis,
                        enum_token: data.enum_token,
                        ident: input.ident,
                        generics: input.generics,
                        brace_token: data.brace_token,
                        variants: data.variants,
                    }),
                    Data::Union(data) => Item::Union(ItemUnion {
                        attrs: input.attrs,
                        vis: input.vis,
                        union_token: data.union_token,
                        ident: input.ident,
                        generics: input.generics,
                        fields: data.fields,
                    }),
                }
            }
        }

        impl From<ItemStruct> for DeriveInput 
        {
            fn from(input: ItemStruct) -> DeriveInput {
                DeriveInput {
                    attrs: input.attrs,
                    vis: input.vis,
                    ident: input.ident,
                    generics: input.generics,
                    data: Data::Struct(DataStruct {
                        struct_token: input.struct_token,
                        fields: input.fields,
                        semi_token: input.semi_token,
                    }),
                }
            }
        }

        impl From<ItemEnum> for DeriveInput 
        {
            fn from(input: ItemEnum) -> DeriveInput {
                DeriveInput {
                    attrs: input.attrs,
                    vis: input.vis,
                    ident: input.ident,
                    generics: input.generics,
                    data: Data::Enum(DataEnum {
                        enum_token: input.enum_token,
                        brace_token: input.brace_token,
                        variants: input.variants,
                    }),
                }
            }
        }

        impl From<ItemUnion> for DeriveInput 
        {
            fn from(input: ItemUnion) -> DeriveInput {
                DeriveInput {
                    attrs: input.attrs,
                    vis: input.vis,
                    ident: input.ident,
                    generics: input.generics,
                    data: Data::Union(DataUnion {
                        union_token: input.union_token,
                        fields: input.fields,
                    }),
                }
            }
        }

        ast_enum_of_structs! 
        {
            /// A suffix of an import tree in a `use` item: `Type as Renamed` or `*`.
            pub enum UseTree {
                /// A path prefix of imports in a `use` item: `std::...`.
                Path(UsePath),
                /// An identifier imported by a `use` item: `HashMap`.
                Name(UseName),
                /// An renamed identifier imported by a `use` item: `HashMap as Map`.
                Rename(UseRename),
                /// A glob import in a `use` item: `*`.
                Glob(UseGlob),
                /// A braced group of imports in a `use` item: `{A, B, C}`.
                Group(UseGroup),
            }
        }

        ast_struct! 
        {
            /// A path prefix of imports in a `use` item: `std::...`.
            pub struct UsePath {
                pub ident: Ident,
                pub colon2_token: Token![::],
                pub tree: Box<UseTree>,
            }
        }

        ast_struct! 
        {
            /// An identifier imported by a `use` item: `HashMap`.
            pub struct UseName {
                pub ident: Ident,
            }
        }

        ast_struct! 
        {
            /// An renamed identifier imported by a `use` item: `HashMap as Map`.
            pub struct UseRename {
                pub ident: Ident,
                pub as_token: Token![as],
                pub rename: Ident,
            }
        }

        ast_struct! 
        {
            /// A glob import in a `use` item: `*`.
            pub struct UseGlob {
                pub star_token: Token![*],
            }
        }

        ast_struct! 
        {
            /// A braced group of imports in a `use` item: `{A, B, C}`.
            pub struct UseGroup {
                pub brace_token: token::Brace,
                pub items: Punctuated<UseTree, Token![,]>,
            }
        }

        ast_enum_of_structs! 
        {
            /// An item within an `extern` block.
            #[non_exhaustive]
            pub enum ForeignItem {
                /// A foreign function in an `extern` block.
                Fn(ForeignItemFn),
                /// A foreign static item in an `extern` block: `static ext: u8`.
                Static(ForeignItemStatic),
                /// A foreign type in an `extern` block: `type void`.
                Type(ForeignItemType),
                /// A macro invocation within an extern block.
                Macro(ForeignItemMacro),
                /// Tokens in an `extern` block not interpreted by Syn.
                Verbatim(TokenStream),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// A foreign function in an `extern` block.
            pub struct ForeignItemFn {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub sig: Signature,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A foreign static item in an `extern` block: `static ext: u8`.
            pub struct ForeignItemStatic {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub static_token: Token![static],
                pub mutability: StaticMutability,
                pub ident: Ident,
                pub colon_token: Token![:],
                pub ty: Box<Type>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A foreign type in an `extern` block: `type void`.
            pub struct ForeignItemType {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub type_token: Token![type],
                pub ident: Ident,
                pub generics: Generics,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A macro invocation within an extern block.
            pub struct ForeignItemMacro {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_enum_of_structs! 
        {
            /// An item declaration within the definition of a trait.
            #[non_exhaustive]
            pub enum TraitItem {
                /// An associated constant within the definition of a trait.
                Const(TraitItemConst),
                /// An associated function within the definition of a trait.
                Fn(TraitItemFn),
                /// An associated type within the definition of a trait.
                Type(TraitItemType),
                /// A macro invocation within the definition of a trait.
                Macro(TraitItemMacro),
                /// Tokens within the definition of a trait not interpreted by Syn.
                Verbatim(TokenStream),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// An associated constant within the definition of a trait.
            pub struct TraitItemConst {
                pub attrs: Vec<Attribute>,
                pub const_token: Token![const],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Token![:],
                pub ty: Type,
                pub default: Option<(Token![=], Expr)>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// An associated function within the definition of a trait.
            pub struct TraitItemFn {
                pub attrs: Vec<Attribute>,
                pub sig: Signature,
                pub default: Option<Block>,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// An associated type within the definition of a trait.
            pub struct TraitItemType {
                pub attrs: Vec<Attribute>,
                pub type_token: Token![type],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Option<Token![:]>,
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
                pub default: Option<(Token![=], Type)>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A macro invocation within the definition of a trait.
            pub struct TraitItemMacro {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_enum_of_structs! 
        {
            /// An item within an impl block.
            #[non_exhaustive]
            pub enum ImplItem {
                /// An associated constant within an impl block.
                Const(ImplItemConst),
                /// An associated function within an impl block.
                Fn(ImplItemFn),
                /// An associated type within an impl block.
                Type(ImplItemType),
                /// A macro invocation within an impl block.
                Macro(ImplItemMacro),
                /// Tokens within an impl block not interpreted by Syn.
                Verbatim(TokenStream),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// An associated constant within an impl block.
            pub struct ImplItemConst {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub defaultness: Option<Token![default]>,
                pub const_token: Token![const],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Token![:],
                pub ty: Type,
                pub eq_token: Token![=],
                pub expr: Expr,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// An associated function within an impl block.
            pub struct ImplItemFn {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub defaultness: Option<Token![default]>,
                pub sig: Signature,
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// An associated type within an impl block.
            pub struct ImplItemType {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub defaultness: Option<Token![default]>,
                pub type_token: Token![type],
                pub ident: Ident,
                pub generics: Generics,
                pub eq_token: Token![=],
                pub ty: Type,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A macro invocation within an impl block.
            pub struct ImplItemMacro {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// A function signature in a trait or implementation: `unsafe fn
            /// initialize(&self)`.
            pub struct Signature {
                pub constness: Option<Token![const]>,
                pub asyncness: Option<Token![async]>,
                pub unsafety: Option<Token![unsafe]>,
                pub abi: Option<Abi>,
                pub fn_token: Token![fn],
                pub ident: Ident,
                pub generics: Generics,
                pub paren_token: token::Paren,
                pub inputs: Punctuated<FnArg, Token![,]>,
                pub variadic: Option<Variadic>,
                pub output: ReturnType,
            }
        }

        impl Signature 
        {
            /// A method's `self` receiver, such as `&self` or `self: Box<Self>`.
            pub fn receiver(&self) -> Option<&Receiver>
            {
                let arg = self.inputs.first()?;
                match arg {
                    FnArg::Receiver(receiver) => Some(receiver),
                    FnArg::Typed(_) => None,
                }
            }
        }

        ast_enum_of_structs! 
        {
            /// An argument in a function signature: the `n: usize` in `fn f(n: usize)`.
            pub enum FnArg {
                /// The `self` argument of an associated method.
                Receiver(Receiver),
                /// A function argument accepted by pattern and type.
                Typed(PatType),
            }
        }

        ast_struct! 
        {
            /// The `self` argument of an associated method.
            /// is written in shorthand such as `self` or `&self` or `&mut self`. In the
            /// shorthand case, the type in `ty` is reconstructed as one of `Self`,
            /// `&Self`, or `&mut Self`.
            pub struct Receiver {
                pub attrs: Vec<Attribute>,
                pub reference: Option<(Token![&], Option<Lifetime>)>,
                pub mutability: Option<Token![mut]>,
                pub self_token: Token![self],
                pub colon_token: Option<Token![:]>,
                pub ty: Box<Type>,
            }
        }

        impl Receiver 
        {
            pub fn lifetime(&self) -> Option<&Lifetime>
            {
                self.reference.as_ref()?.1.as_ref()
            }
        }

        ast_struct! 
        {
            /// The variadic argument of a foreign function.
            pub struct Variadic {
                pub attrs: Vec<Attribute>,
                pub pat: Option<(Box<Pat>, Token![:])>,
                pub dots: Token![...],
                pub comma: Option<Token![,]>,
            }
        }

        ast_enum! 
        {
            /// The mutability of an `Item::Static` or `ForeignItem::Static`.
            #[non_exhaustive]
            pub enum StaticMutability {
                Mut(Token![mut]),
                None,
            }
        }

        ast_enum! 
        {
            /// Unused, but reserved for RFC 3323 restrictions.
            #[non_exhaustive]
            pub enum ImplRestriction {}


           
            //
           
           
           
           
           
           
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::{ TokenStream },
                syntax::
                {
                    attr::{self, Attribute},
                    derive,
                    error::{Error, Result},
                    expr::Expr,
                    ext::IdentExt as _,
                    generics::{self, Generics, TypeParamBound},
                    ident::Ident,
                    item::
                    {
                        FnArg, ForeignItem, ForeignItemFn, ForeignItemMacro, ForeignItemStatic, ForeignItemType,
                        ImplItem, ImplItemConst, ImplItemFn, ImplItemMacro, ImplItemType, Item, ItemConst, ItemEnum,
                        ItemExternCrate, ItemFn, ItemForeignMod, ItemImpl, ItemMacro, ItemMod, ItemStatic, ItemStruct,
                        ItemTrait, ItemTraitAlias, ItemType, ItemUnion, ItemUse, Receiver, Signature, 
                        StaticMutability, TraitItem, TraitItemConst, TraitItemFn, TraitItemMacro, TraitItemType, 
                        UseGlob, UseGroup, UseName, UsePath, UseRename, UseTree, Variadic,
                    },
                    lifetime::Lifetime,
                    lit::LitStr,
                    mac::{self, Macro},
                    parse::discouraged::Speculative as _,
                    parse::{Parse, ParseBuffer, ParseStream},
                    pat::{Pat, PatType, PatWild},
                    path::Path,
                    punctuated::Punctuated,
                    restriction::Visibility,
                    stmt::Block,
                    token,
                    ty::{Abi, ReturnType, Type, TypePath, TypeReference},
                    verbatim,
                },
                *,
            };

            impl Parse for Item
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let attrs = input.call(Attribute::parse_outer)?;
                    parse_rest_of_item(begin, attrs, input)
                }
            }

            pub fn parse_rest_of_item
            (
                begin: ParseBuffer,
                mut attrs: Vec<Attribute>,
                input: ParseStream,
            ) -> Result<Item>
            {
                let ahead = input.fork();
                let vis: Visibility = ahead.parse()?;

                let lookahead = ahead.lookahead1();
                let allow_safe = false;
                let mut item = if lookahead.peek(Token![fn]) || peek_signature(&ahead, allow_safe) {
                    let vis: Visibility = input.parse()?;
                    let sig: Signature = input.parse()?;
                    if input.peek(Token![;]) {
                        input.parse::<Token![;]>()?;
                        Ok(Item::Verbatim(verbatim::between(&begin, input)))
                    } else {
                        parse_rest_of_fn(input, Vec::new(), vis, sig).map(Item::Fn)
                    }
                } else if lookahead.peek(Token![extern]) {
                    ahead.parse::<Token![extern]>()?;
                    let lookahead = ahead.lookahead1();
                    if lookahead.peek(Token![crate]) {
                        input.parse().map(Item::ExternCrate)
                    } else if lookahead.peek(token::Brace) {
                        input.parse().map(Item::ForeignMod)
                    } else if lookahead.peek(LitStr) {
                        ahead.parse::<LitStr>()?;
                        let lookahead = ahead.lookahead1();
                        if lookahead.peek(token::Brace) {
                            input.parse().map(Item::ForeignMod)
                        } else {
                            Err(lookahead.error())
                        }
                    } else {
                        Err(lookahead.error())
                    }
                } else if lookahead.peek(Token![use]) {
                    let allow_crate_root_in_path = true;
                    match parse_item_use(input, allow_crate_root_in_path)? {
                        Some(item_use) => Ok(Item::Use(item_use)),
                        None => Ok(Item::Verbatim(verbatim::between(&begin, input))),
                    }
                } else if lookahead.peek(Token![static]) {
                    let vis = input.parse()?;
                    let static_token = input.parse()?;
                    let mutability = input.parse()?;
                    let ident = input.parse()?;
                    if input.peek(Token![=]) {
                        input.parse::<Token![=]>()?;
                        input.parse::<Expr>()?;
                        input.parse::<Token![;]>()?;
                        Ok(Item::Verbatim(verbatim::between(&begin, input)))
                    } else {
                        let colon_token = input.parse()?;
                        let ty = input.parse()?;
                        if input.peek(Token![;]) {
                            input.parse::<Token![;]>()?;
                            Ok(Item::Verbatim(verbatim::between(&begin, input)))
                        } else {
                            Ok(Item::Static(ItemStatic {
                                attrs: Vec::new(),
                                vis,
                                static_token,
                                mutability,
                                ident,
                                colon_token,
                                ty,
                                eq_token: input.parse()?,
                                expr: input.parse()?,
                                semi_token: input.parse()?,
                            }))
                        }
                    }
                } else if lookahead.peek(Token![const]) {
                    let vis = input.parse()?;
                    let const_token: Token![const] = input.parse()?;
                    let lookahead = input.lookahead1();
                    let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                        input.call(Ident::parse_any)?
                    } else {
                        return Err(lookahead.error());
                    };
                    let mut generics: Generics = input.parse()?;
                    let colon_token = input.parse()?;
                    let ty = input.parse()?;
                    let value = if let Some(eq_token) = input.parse::<Option<Token![=]>>()? {
                        let expr: Expr = input.parse()?;
                        Some((eq_token, expr))
                    } else {
                        None
                    };
                    generics.where_clause = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;
                    match value {
                        Some((eq_token, expr))
                            if generics.lt_token.is_none() && generics.where_clause.is_none() =>
                        {
                            Ok(Item::Const(ItemConst {
                                attrs: Vec::new(),
                                vis,
                                const_token,
                                ident,
                                generics,
                                colon_token,
                                ty,
                                eq_token,
                                expr: Box::new(expr),
                                semi_token,
                            }))
                        }
                        _ => Ok(Item::Verbatim(verbatim::between(&begin, input))),
                    }
                } else if lookahead.peek(Token![unsafe]) {
                    ahead.parse::<Token![unsafe]>()?;
                    let lookahead = ahead.lookahead1();
                    if lookahead.peek(Token![trait])
                        || lookahead.peek(Token![auto]) && ahead.peek2(Token![trait])
                    {
                        input.parse().map(Item::Trait)
                    } else if lookahead.peek(Token![impl]) {
                        let allow_verbatim_impl = true;
                        if let Some(item) = parse_impl(input, allow_verbatim_impl)? {
                            Ok(Item::Impl(item))
                        } else {
                            Ok(Item::Verbatim(verbatim::between(&begin, input)))
                        }
                    } else if lookahead.peek(Token![extern]) {
                        input.parse().map(Item::ForeignMod)
                    } else if lookahead.peek(Token![mod]) {
                        input.parse().map(Item::Mod)
                    } else {
                        Err(lookahead.error())
                    }
                } else if lookahead.peek(Token![mod]) {
                    input.parse().map(Item::Mod)
                } else if lookahead.peek(Token![type]) {
                    parse_item_type(begin, input)
                } else if lookahead.peek(Token![struct]) {
                    input.parse().map(Item::Struct)
                } else if lookahead.peek(Token![enum]) {
                    input.parse().map(Item::Enum)
                } else if lookahead.peek(Token![union]) && ahead.peek2(Ident) {
                    input.parse().map(Item::Union)
                } else if lookahead.peek(Token![trait]) {
                    input.call(parse_trait_or_trait_alias)
                } else if lookahead.peek(Token![auto]) && ahead.peek2(Token![trait]) {
                    input.parse().map(Item::Trait)
                } else if lookahead.peek(Token![impl])
                    || lookahead.peek(Token![default]) && !ahead.peek2(Token![!])
                {
                    let allow_verbatim_impl = true;
                    if let Some(item) = parse_impl(input, allow_verbatim_impl)? {
                        Ok(Item::Impl(item))
                    } else {
                        Ok(Item::Verbatim(verbatim::between(&begin, input)))
                    }
                } else if lookahead.peek(Token![macro]) {
                    input.advance_to(&ahead);
                    parse_macro2(begin, vis, input)
                } else if vis.is_inherited()
                    && (lookahead.peek(Ident)
                        || lookahead.peek(Token![self])
                        || lookahead.peek(Token![super])
                        || lookahead.peek(Token![crate])
                        || lookahead.peek(Token![::]))
                {
                    input.parse().map(Item::Macro)
                } else {
                    Err(lookahead.error())
                }?;

                attrs.extend(item.replace_attrs(Vec::new()));
                item.replace_attrs(attrs);
                Ok(item)
            }

            struct FlexibleItemType 
            {
                vis: Visibility,
                defaultness: Option<Token![default]>,
                type_token: Token![type],
                ident: Ident,
                generics: Generics,
                colon_token: Option<Token![:]>,
                bounds: Punctuated<TypeParamBound, Token![+]>,
                ty: Option<(Token![=], Type)>,
                semi_token: Token![;],
            }

            enum TypeDefaultness 
            {
                Optional,
                Disallowed,
            }

            enum WhereClauseLocation 
            {
               
                BeforeEq,
               
                AfterEq,
               
                Both,
            }

            impl FlexibleItemType
            {
                fn parse(
                    input: ParseStream,
                    allow_defaultness: TypeDefaultness,
                    where_clause_location: WhereClauseLocation,
                ) -> Result<Self> {
                    let vis: Visibility = input.parse()?;
                    let defaultness: Option<Token![default]> = match allow_defaultness {
                        TypeDefaultness::Optional => input.parse()?,
                        TypeDefaultness::Disallowed => None,
                    };
                    let type_token: Token![type] = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let mut generics: Generics = input.parse()?;
                    let (colon_token, bounds) = Self::parse_optional_bounds(input)?;

                    match where_clause_location {
                        WhereClauseLocation::BeforeEq | WhereClauseLocation::Both => {
                            generics.where_clause = input.parse()?;
                        }
                        WhereClauseLocation::AfterEq => {}
                    }

                    let ty = Self::parse_optional_definition(input)?;

                    match where_clause_location {
                        WhereClauseLocation::AfterEq | WhereClauseLocation::Both
                            if generics.where_clause.is_none() =>
                        {
                            generics.where_clause = input.parse()?;
                        }
                        _ => {}
                    }

                    let semi_token: Token![;] = input.parse()?;

                    Ok(FlexibleItemType {
                        vis,
                        defaultness,
                        type_token,
                        ident,
                        generics,
                        colon_token,
                        bounds,
                        ty,
                        semi_token,
                    })
                }

                fn parse_optional_bounds(
                    input: ParseStream,
                ) -> Result<(Option<Token![:]>, Punctuated<TypeParamBound, Token![+]>)> {
                    let colon_token: Option<Token![:]> = input.parse()?;

                    let mut bounds = Punctuated::new();
                    if colon_token.is_some() {
                        loop {
                            if input.peek(Token![where]) || input.peek(Token![=]) || input.peek(Token![;]) {
                                break;
                            }
                            bounds.push_value({
                                let allow_precise_capture = false;
                                let allow_const = true;
                                TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                            });
                            if input.peek(Token![where]) || input.peek(Token![=]) || input.peek(Token![;]) {
                                break;
                            }
                            bounds.push_punct(input.parse::<Token![+]>()?);
                        }
                    }

                    Ok((colon_token, bounds))
                }

                fn parse_optional_definition(input: ParseStream) -> Result<Option<(Token![=], Type)>> {
                    let eq_token: Option<Token![=]> = input.parse()?;
                    if let Some(eq_token) = eq_token {
                        let definition: Type = input.parse()?;
                        Ok(Some((eq_token, definition)))
                    } else {
                        Ok(None)
                    }
                }
            }

            impl Parse for ItemMacro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let path = input.call(Path::parse_mod_style)?;
                    let bang_token: Token![!] = input.parse()?;
                    let ident: Option<Ident> = if input.peek(Token![try]) {
                        input.call(Ident::parse_any).map(Some)
                    } else {
                        input.parse()
                    }?;
                    let (delimiter, tokens) = input.call(mac::parse_delimiter)?;
                    let semi_token: Option<Token![;]> = if !delimiter.is_brace() {
                        Some(input.parse()?)
                    } else {
                        None
                    };
                    Ok(ItemMacro {
                        attrs,
                        ident,
                        mac: Macro {
                            path,
                            bang_token,
                            delimiter,
                            tokens,
                        },
                        semi_token,
                    })
                }
            }

            fn parse_macro2(begin: ParseBuffer, _vis: Visibility, input: ParseStream) -> Result<Item> 
            {
                input.parse::<Token![macro]>()?;
                input.parse::<Ident>()?;

                let mut lookahead = input.lookahead1();
                if lookahead.peek(token::Paren) {
                    let paren_content;
                    parenthesized!(paren_content in input);
                    paren_content.parse::<TokenStream>()?;
                    lookahead = input.lookahead1();
                }

                if lookahead.peek(token::Brace) {
                    let brace_content;
                    braced!(brace_content in input);
                    brace_content.parse::<TokenStream>()?;
                } else {
                    return Err(lookahead.error());
                }

                Ok(Item::Verbatim(verbatim::between(&begin, input)))
            }

            impl Parse for ItemExternCrate
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ItemExternCrate {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        extern_token: input.parse()?,
                        crate_token: input.parse()?,
                        ident: {
                            if input.peek(Token![self]) {
                                input.call(Ident::parse_any)?
                            } else {
                                input.parse()?
                            }
                        },
                        rename: {
                            if input.peek(Token![as]) {
                                let as_token: Token![as] = input.parse()?;
                                let rename: Ident = if input.peek(Token![_]) {
                                    Ident::from(input.parse::<Token![_]>()?)
                                } else {
                                    input.parse()?
                                };
                                Some((as_token, rename))
                            } else {
                                None
                            }
                        },
                        semi_token: input.parse()?,
                    })
                }
            }

            impl Parse for ItemUse
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_crate_root_in_path = false;
                    parse_item_use(input, allow_crate_root_in_path).map(Option::unwrap)
                }
            }

            fn parse_item_use
            (
                input: ParseStream,
                allow_crate_root_in_path: bool,
            ) -> Result<Option<ItemUse>>
            {
                let attrs = input.call(Attribute::parse_outer)?;
                let vis: Visibility = input.parse()?;
                let use_token: Token![use] = input.parse()?;
                let leading_colon: Option<Token![::]> = input.parse()?;
                let tree = parse_use_tree(input, allow_crate_root_in_path && leading_colon.is_none())?;
                let semi_token: Token![;] = input.parse()?;

                let tree = match tree {
                    Some(tree) => tree,
                    None => return Ok(None),
                };

                Ok(Some(ItemUse {
                    attrs,
                    vis,
                    use_token,
                    leading_colon,
                    tree,
                    semi_token,
                }))
            }

            impl Parse for UseTree
            {
                fn parse(input: ParseStream) -> Result<UseTree> {
                    let allow_crate_root_in_path = false;
                    parse_use_tree(input, allow_crate_root_in_path).map(Option::unwrap)
                }
            }

            fn parse_use_tree
            (
                input: ParseStream,
                allow_crate_root_in_path: bool,
            ) -> Result<Option<UseTree>>
            {
                let lookahead = input.lookahead1();
                if lookahead.peek(Ident)
                    || lookahead.peek(Token![self])
                    || lookahead.peek(Token![super])
                    || lookahead.peek(Token![crate])
                    || lookahead.peek(Token![try])
                {
                    let ident = input.call(Ident::parse_any)?;
                    if input.peek(Token![::]) {
                        Ok(Some(UseTree::Path(UsePath {
                            ident,
                            colon2_token: input.parse()?,
                            tree: Box::new(input.parse()?),
                        })))
                    } else if input.peek(Token![as]) {
                        Ok(Some(UseTree::Rename(UseRename {
                            ident,
                            as_token: input.parse()?,
                            rename: {
                                if input.peek(Ident) {
                                    input.parse()?
                                } else if input.peek(Token![_]) {
                                    Ident::from(input.parse::<Token![_]>()?)
                                } else {
                                    return Err(input.error("expected identifier or underscore"));
                                }
                            },
                        })))
                    } else {
                        Ok(Some(UseTree::Name(UseName { ident })))
                    }
                } else if lookahead.peek(Token![*]) {
                    Ok(Some(UseTree::Glob(UseGlob {
                        star_token: input.parse()?,
                    })))
                } else if lookahead.peek(token::Brace) {
                    let content;
                    let brace_token = braced!(content in input);
                    let mut items = Punctuated::new();
                    let mut has_any_crate_root_in_path = false;
                    loop {
                        if content.is_empty() {
                            break;
                        }
                        let this_tree_starts_with_crate_root =
                            allow_crate_root_in_path && content.parse::<Option<Token![::]>>()?.is_some();
                        has_any_crate_root_in_path |= this_tree_starts_with_crate_root;
                        match parse_use_tree(
                            &content,
                            allow_crate_root_in_path && !this_tree_starts_with_crate_root,
                        )? {
                            Some(tree) if !has_any_crate_root_in_path => items.push_value(tree),
                            _ => has_any_crate_root_in_path = true,
                        }
                        if content.is_empty() {
                            break;
                        }
                        let comma: Token![,] = content.parse()?;
                        if !has_any_crate_root_in_path {
                            items.push_punct(comma);
                        }
                    }
                    if has_any_crate_root_in_path {
                        Ok(None)
                    } else {
                        Ok(Some(UseTree::Group(UseGroup { brace_token, items })))
                    }
                } else {
                    Err(lookahead.error())
                }
            }

            impl Parse for ItemStatic
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ItemStatic {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        static_token: input.parse()?,
                        mutability: input.parse()?,
                        ident: input.parse()?,
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                        eq_token: input.parse()?,
                        expr: input.parse()?,
                        semi_token: input.parse()?,
                    })
                }
            }

            impl Parse for ItemConst
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let const_token: Token![const] = input.parse()?;

                    let lookahead = input.lookahead1();
                    let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                        input.call(Ident::parse_any)?
                    } else {
                        return Err(lookahead.error());
                    };

                    let colon_token: Token![:] = input.parse()?;
                    let ty: Type = input.parse()?;
                    let eq_token: Token![=] = input.parse()?;
                    let expr: Expr = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;

                    Ok(ItemConst {
                        attrs,
                        vis,
                        const_token,
                        ident,
                        generics: Generics::default(),
                        colon_token,
                        ty: Box::new(ty),
                        eq_token,
                        expr: Box::new(expr),
                        semi_token,
                    })
                }
            }

            fn peek_signature(input: ParseStream, allow_safe: bool) -> bool
            {
                let fork = input.fork();
                fork.parse::<Option<Token![const]>>().is_ok()
                    && fork.parse::<Option<Token![async]>>().is_ok()
                    && ((allow_safe
                        && token::parsing::peek_keyword(fork.cursor(), "safe")
                        && token::parsing::keyword(&fork, "safe").is_ok())
                        || fork.parse::<Option<Token![unsafe]>>().is_ok())
                    && fork.parse::<Option<Abi>>().is_ok()
                    && fork.peek(Token![fn])
            }

            impl Parse for Signature
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_safe = false;
                    parse_signature(input, allow_safe).map(Option::unwrap)
                }
            }

            fn parse_signature(input: ParseStream, allow_safe: bool) -> Result<Option<Signature>>
            {
                let constness: Option<Token![const]> = input.parse()?;
                let asyncness: Option<Token![async]> = input.parse()?;
                let unsafety: Option<Token![unsafe]> = input.parse()?;
                let safe = allow_safe
                    && unsafety.is_none()
                    && token::parsing::peek_keyword(input.cursor(), "safe");
                if safe {
                    token::parsing::keyword(input, "safe")?;
                }
                let abi: Option<Abi> = input.parse()?;
                let fn_token: Token![fn] = input.parse()?;
                let ident: Ident = input.parse()?;
                let mut generics: Generics = input.parse()?;

                let content;
                let paren_token = parenthesized!(content in input);
                let (inputs, variadic) = parse_fn_args(&content)?;

                let output: ReturnType = input.parse()?;
                generics.where_clause = input.parse()?;

                Ok(if safe {
                    None
                } else {
                    Some(Signature {
                        constness,
                        asyncness,
                        unsafety,
                        abi,
                        fn_token,
                        ident,
                        generics,
                        paren_token,
                        inputs,
                        variadic,
                        output,
                    })
                })
            }

            impl Parse for ItemFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let outer_attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let sig: Signature = input.parse()?;
                    parse_rest_of_fn(input, outer_attrs, vis, sig)
                }
            }

            fn parse_rest_of_fn
            (
                input: ParseStream,
                mut attrs: Vec<Attribute>,
                vis: Visibility,
                sig: Signature,
            ) -> Result<ItemFn>
            {
                let content;
                let brace_token = braced!(content in input);
                attr::parsing::parse_inner(&content, &mut attrs)?;
                let stmts = content.call(Block::parse_within)?;

                Ok(ItemFn {
                    attrs,
                    vis,
                    sig,
                    block: Box::new(Block { brace_token, stmts }),
                })
            }

            impl Parse for FnArg
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_variadic = false;
                    let attrs = input.call(Attribute::parse_outer)?;
                    match parse_fn_arg_or_variadic(input, attrs, allow_variadic)? {
                        FnArgOrVariadic::FnArg(arg) => Ok(arg),
                        FnArgOrVariadic::Variadic(_) => unreachable!(),
                    }
                }
            }

            enum FnArgOrVariadic
            {
                FnArg(FnArg),
                Variadic(Variadic),
            }

            fn parse_fn_arg_or_variadic
            (
                input: ParseStream,
                attrs: Vec<Attribute>,
                allow_variadic: bool,
            ) -> Result<FnArgOrVariadic>
            {
                let ahead = input.fork();
                if let Ok(mut receiver) = ahead.parse::<Receiver>() {
                    input.advance_to(&ahead);
                    receiver.attrs = attrs;
                    return Ok(FnArgOrVariadic::FnArg(FnArg::Receiver(receiver)));
                }

               
               
               
                if input.peek(Ident) && input.peek2(Token![<]) {
                    let span = input.span();
                    return Ok(FnArgOrVariadic::FnArg(FnArg::Typed(PatType {
                        attrs,
                        pat: Box::new(Pat::Wild(PatWild {
                            attrs: Vec::new(),
                            underscore_token: Token![_](span),
                        })),
                        colon_token: Token![:](span),
                        ty: input.parse()?,
                    })));
                }

                let pat = Box::new(Pat::parse_single(input)?);
                let colon_token: Token![:] = input.parse()?;

                if allow_variadic {
                    if let Some(dots) = input.parse::<Option<Token![...]>>()? {
                        return Ok(FnArgOrVariadic::Variadic(Variadic {
                            attrs,
                            pat: Some((pat, colon_token)),
                            dots,
                            comma: None,
                        }));
                    }
                }

                Ok(FnArgOrVariadic::FnArg(FnArg::Typed(PatType {
                    attrs,
                    pat,
                    colon_token,
                    ty: input.parse()?,
                })))
            }

            impl Parse for Receiver
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let reference = if input.peek(Token![&]) {
                        let ampersand: Token![&] = input.parse()?;
                        let lifetime: Option<Lifetime> = input.parse()?;
                        Some((ampersand, lifetime))
                    } else {
                        None
                    };
                    let mutability: Option<Token![mut]> = input.parse()?;
                    let self_token: Token![self] = input.parse()?;
                    let colon_token: Option<Token![:]> = if reference.is_some() {
                        None
                    } else {
                        input.parse()?
                    };
                    let ty: Type = if colon_token.is_some() {
                        input.parse()?
                    } else {
                        let mut ty = Type::Path(TypePath {
                            qself: None,
                            path: Path::from(Ident::new("Self", self_token.span)),
                        });
                        if let Some((ampersand, lifetime)) = reference.as_ref() {
                            ty = Type::Reference(TypeReference {
                                and_token: Token![&](ampersand.span),
                                lifetime: lifetime.clone(),
                                mutability: mutability.as_ref().map(|m| Token![mut](m.span)),
                                elem: Box::new(ty),
                            });
                        }
                        ty
                    };
                    Ok(Receiver {
                        attrs: Vec::new(),
                        reference,
                        mutability,
                        self_token,
                        colon_token,
                        ty: Box::new(ty),
                    })
                }
            }

            fn parse_fn_args
            (
                input: ParseStream,
            ) -> Result<(Punctuated<FnArg, Token![,]>, Option<Variadic>)>
            {
                let mut args = Punctuated::new();
                let mut variadic = None;
                let mut has_receiver = false;

                while !input.is_empty() {
                    let attrs = input.call(Attribute::parse_outer)?;

                    if let Some(dots) = input.parse::<Option<Token![...]>>()? {
                        variadic = Some(Variadic {
                            attrs,
                            pat: None,
                            dots,
                            comma: if input.is_empty() {
                                None
                            } else {
                                Some(input.parse()?)
                            },
                        });
                        break;
                    }

                    let allow_variadic = true;
                    let arg = match parse_fn_arg_or_variadic(input, attrs, allow_variadic)? {
                        FnArgOrVariadic::FnArg(arg) => arg,
                        FnArgOrVariadic::Variadic(arg) => {
                            variadic = Some(Variadic {
                                comma: if input.is_empty() {
                                    None
                                } else {
                                    Some(input.parse()?)
                                },
                                ..arg
                            });
                            break;
                        }
                    };

                    match &arg {
                        FnArg::Receiver(receiver) if has_receiver => {
                            return Err(Error::new(
                                receiver.self_token.span,
                                "unexpected second method receiver",
                            ));
                        }
                        FnArg::Receiver(receiver) if !args.is_empty() => {
                            return Err(Error::new(
                                receiver.self_token.span,
                                "unexpected method receiver",
                            ));
                        }
                        FnArg::Receiver(_) => has_receiver = true,
                        FnArg::Typed(_) => {}
                    }
                    args.push_value(arg);

                    if input.is_empty() {
                        break;
                    }

                    let comma: Token![,] = input.parse()?;
                    args.push_punct(comma);
                }

                Ok((args, variadic))
            }

            impl Parse for ItemMod
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let unsafety: Option<Token![unsafe]> = input.parse()?;
                    let mod_token: Token![mod] = input.parse()?;
                    let ident: Ident = if input.peek(Token![try]) {
                        input.call(Ident::parse_any)
                    } else {
                        input.parse()
                    }?;

                    let lookahead = input.lookahead1();
                    if lookahead.peek(Token![;]) {
                        Ok(ItemMod {
                            attrs,
                            vis,
                            unsafety,
                            mod_token,
                            ident,
                            content: None,
                            semi: Some(input.parse()?),
                        })
                    } else if lookahead.peek(token::Brace) {
                        let content;
                        let brace_token = braced!(content in input);
                        attr::parsing::parse_inner(&content, &mut attrs)?;

                        let mut items = Vec::new();
                        while !content.is_empty() {
                            items.push(content.parse()?);
                        }

                        Ok(ItemMod {
                            attrs,
                            vis,
                            unsafety,
                            mod_token,
                            ident,
                            content: Some((brace_token, items)),
                            semi: None,
                        })
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            impl Parse for ItemForeignMod
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let unsafety: Option<Token![unsafe]> = input.parse()?;
                    let abi: Abi = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let mut items = Vec::new();
                    while !content.is_empty() {
                        items.push(content.parse()?);
                    }

                    Ok(ItemForeignMod {
                        attrs,
                        unsafety,
                        abi,
                        brace_token,
                        items,
                    })
                }
            }

            impl Parse for ForeignItem
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let ahead = input.fork();
                    let vis: Visibility = ahead.parse()?;

                    let lookahead = ahead.lookahead1();
                    let allow_safe = true;
                    let mut item = if lookahead.peek(Token![fn]) || peek_signature(&ahead, allow_safe) {
                        let vis: Visibility = input.parse()?;
                        let sig = parse_signature(input, allow_safe)?;
                        let has_safe = sig.is_none();
                        let has_body = input.peek(token::Brace);
                        let semi_token: Option<Token![;]> = if has_body {
                            let content;
                            braced!(content in input);
                            content.call(Attribute::parse_inner)?;
                            content.call(Block::parse_within)?;
                            None
                        } else {
                            Some(input.parse()?)
                        };
                        if has_safe || has_body {
                            Ok(ForeignItem::Verbatim(verbatim::between(&begin, input)))
                        } else {
                            Ok(ForeignItem::Fn(ForeignItemFn {
                                attrs: Vec::new(),
                                vis,
                                sig: sig.unwrap(),
                                semi_token: semi_token.unwrap(),
                            }))
                        }
                    } else if lookahead.peek(Token![static])
                        || ((ahead.peek(Token![unsafe])
                            || token::parsing::peek_keyword(ahead.cursor(), "safe"))
                            && ahead.peek2(Token![static]))
                    {
                        let vis = input.parse()?;
                        let unsafety: Option<Token![unsafe]> = input.parse()?;
                        let safe =
                            unsafety.is_none() && token::parsing::peek_keyword(input.cursor(), "safe");
                        if safe {
                            token::parsing::keyword(input, "safe")?;
                        }
                        let static_token = input.parse()?;
                        let mutability = input.parse()?;
                        let ident = input.parse()?;
                        let colon_token = input.parse()?;
                        let ty = input.parse()?;
                        let has_value = input.peek(Token![=]);
                        if has_value {
                            input.parse::<Token![=]>()?;
                            input.parse::<Expr>()?;
                        }
                        let semi_token: Token![;] = input.parse()?;
                        if unsafety.is_some() || safe || has_value {
                            Ok(ForeignItem::Verbatim(verbatim::between(&begin, input)))
                        } else {
                            Ok(ForeignItem::Static(ForeignItemStatic {
                                attrs: Vec::new(),
                                vis,
                                static_token,
                                mutability,
                                ident,
                                colon_token,
                                ty,
                                semi_token,
                            }))
                        }
                    } else if lookahead.peek(Token![type]) {
                        parse_foreign_item_type(begin, input)
                    } else if vis.is_inherited()
                        && (lookahead.peek(Ident)
                            || lookahead.peek(Token![self])
                            || lookahead.peek(Token![super])
                            || lookahead.peek(Token![crate])
                            || lookahead.peek(Token![::]))
                    {
                        input.parse().map(ForeignItem::Macro)
                    } else {
                        Err(lookahead.error())
                    }?;

                    let item_attrs = match &mut item {
                        ForeignItem::Fn(item) => &mut item.attrs,
                        ForeignItem::Static(item) => &mut item.attrs,
                        ForeignItem::Type(item) => &mut item.attrs,
                        ForeignItem::Macro(item) => &mut item.attrs,
                        ForeignItem::Verbatim(_) => return Ok(item),
                    };
                    attrs.append(item_attrs);
                    *item_attrs = attrs;

                    Ok(item)
                }
            }

            impl Parse for ForeignItemFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let sig: Signature = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;
                    Ok(ForeignItemFn {
                        attrs,
                        vis,
                        sig,
                        semi_token,
                    })
                }
            }

            impl Parse for ForeignItemStatic
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ForeignItemStatic {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        static_token: input.parse()?,
                        mutability: input.parse()?,
                        ident: input.parse()?,
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                        semi_token: input.parse()?,
                    })
                }
            }

            impl Parse for ForeignItemType
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ForeignItemType {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        type_token: input.parse()?,
                        ident: input.parse()?,
                        generics: {
                            let mut generics: Generics = input.parse()?;
                            generics.where_clause = input.parse()?;
                            generics
                        },
                        semi_token: input.parse()?,
                    })
                }
            }

            fn parse_foreign_item_type(begin: ParseBuffer, input: ParseStream) -> Result<ForeignItem>
            {
                let FlexibleItemType {
                    vis,
                    defaultness: _,
                    type_token,
                    ident,
                    generics,
                    colon_token,
                    bounds: _,
                    ty,
                    semi_token,
                } = FlexibleItemType::parse(
                    input,
                    TypeDefaultness::Disallowed,
                    WhereClauseLocation::Both,
                )?;

                if colon_token.is_some() || ty.is_some() {
                    Ok(ForeignItem::Verbatim(verbatim::between(&begin, input)))
                } else {
                    Ok(ForeignItem::Type(ForeignItemType {
                        attrs: Vec::new(),
                        vis,
                        type_token,
                        ident,
                        generics,
                        semi_token,
                    }))
                }
            }

            impl Parse for ForeignItemMacro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let mac: Macro = input.parse()?;
                    let semi_token: Option<Token![;]> = if mac.delimiter.is_brace() {
                        None
                    } else {
                        Some(input.parse()?)
                    };
                    Ok(ForeignItemMacro {
                        attrs,
                        mac,
                        semi_token,
                    })
                }
            }

            impl Parse for ItemType
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ItemType {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        type_token: input.parse()?,
                        ident: input.parse()?,
                        generics: {
                            let mut generics: Generics = input.parse()?;
                            generics.where_clause = input.parse()?;
                            generics
                        },
                        eq_token: input.parse()?,
                        ty: input.parse()?,
                        semi_token: input.parse()?,
                    })
                }
            }

            fn parse_item_type(begin: ParseBuffer, input: ParseStream) -> Result<Item>
            {
                let FlexibleItemType {
                    vis,
                    defaultness: _,
                    type_token,
                    ident,
                    generics,
                    colon_token,
                    bounds: _,
                    ty,
                    semi_token,
                } = FlexibleItemType::parse(
                    input,
                    TypeDefaultness::Disallowed,
                    WhereClauseLocation::BeforeEq,
                )?;

                let (eq_token, ty) = match ty {
                    Some(ty) if colon_token.is_none() => ty,
                    _ => return Ok(Item::Verbatim(verbatim::between(&begin, input))),
                };

                Ok(Item::Type(ItemType {
                    attrs: Vec::new(),
                    vis,
                    type_token,
                    ident,
                    generics,
                    eq_token,
                    ty: Box::new(ty),
                    semi_token,
                }))
            }

            impl Parse for ItemStruct
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis = input.parse::<Visibility>()?;
                    let struct_token = input.parse::<Token![struct]>()?;
                    let ident = input.parse::<Ident>()?;
                    let generics = input.parse::<Generics>()?;
                    let (where_clause, fields, semi_token) = derive::parsing::data_struct(input)?;
                    Ok(ItemStruct {
                        attrs,
                        vis,
                        struct_token,
                        ident,
                        generics: Generics {
                            where_clause,
                            ..generics
                        },
                        fields,
                        semi_token,
                    })
                }
            }

            impl Parse for ItemEnum
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis = input.parse::<Visibility>()?;
                    let enum_token = input.parse::<Token![enum]>()?;
                    let ident = input.parse::<Ident>()?;
                    let generics = input.parse::<Generics>()?;
                    let (where_clause, brace_token, variants) = derive::parsing::data_enum(input)?;
                    Ok(ItemEnum {
                        attrs,
                        vis,
                        enum_token,
                        ident,
                        generics: Generics {
                            where_clause,
                            ..generics
                        },
                        brace_token,
                        variants,
                    })
                }
            }

            impl Parse for ItemUnion
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis = input.parse::<Visibility>()?;
                    let union_token = input.parse::<Token![union]>()?;
                    let ident = input.parse::<Ident>()?;
                    let generics = input.parse::<Generics>()?;
                    let (where_clause, fields) = derive::parsing::data_union(input)?;
                    Ok(ItemUnion {
                        attrs,
                        vis,
                        union_token,
                        ident,
                        generics: Generics {
                            where_clause,
                            ..generics
                        },
                        fields,
                    })
                }
            }

            fn parse_trait_or_trait_alias(input: ParseStream) -> Result<Item>
            {
                let (attrs, vis, trait_token, ident, generics) = parse_start_of_trait_alias(input)?;
                let lookahead = input.lookahead1();
                if lookahead.peek(token::Brace)
                    || lookahead.peek(Token![:])
                    || lookahead.peek(Token![where])
                {
                    let unsafety = None;
                    let auto_token = None;
                    parse_rest_of_trait(
                        input,
                        attrs,
                        vis,
                        unsafety,
                        auto_token,
                        trait_token,
                        ident,
                        generics,
                    )
                    .map(Item::Trait)
                } else if lookahead.peek(Token![=]) {
                    parse_rest_of_trait_alias(input, attrs, vis, trait_token, ident, generics)
                        .map(Item::TraitAlias)
                } else {
                    Err(lookahead.error())
                }
            }

            impl Parse for ItemTrait
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let outer_attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let unsafety: Option<Token![unsafe]> = input.parse()?;
                    let auto_token: Option<Token![auto]> = input.parse()?;
                    let trait_token: Token![trait] = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let generics: Generics = input.parse()?;
                    parse_rest_of_trait(
                        input,
                        outer_attrs,
                        vis,
                        unsafety,
                        auto_token,
                        trait_token,
                        ident,
                        generics,
                    )
                }
            }

            fn parse_rest_of_trait
            (
                input: ParseStream,
                mut attrs: Vec<Attribute>,
                vis: Visibility,
                unsafety: Option<Token![unsafe]>,
                auto_token: Option<Token![auto]>,
                trait_token: Token![trait],
                ident: Ident,
                mut generics: Generics,
            ) -> Result<ItemTrait>
            {
                let colon_token: Option<Token![:]> = input.parse()?;

                let mut supertraits = Punctuated::new();
                if colon_token.is_some() {
                    loop {
                        if input.peek(Token![where]) || input.peek(token::Brace) {
                            break;
                        }
                        supertraits.push_value({
                            let allow_precise_capture = false;
                            let allow_const = true;
                            TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                        });
                        if input.peek(Token![where]) || input.peek(token::Brace) {
                            break;
                        }
                        supertraits.push_punct(input.parse()?);
                    }
                }

                generics.where_clause = input.parse()?;

                let content;
                let brace_token = braced!(content in input);
                attr::parsing::parse_inner(&content, &mut attrs)?;
                let mut items = Vec::new();
                while !content.is_empty() {
                    items.push(content.parse()?);
                }

                Ok(ItemTrait {
                    attrs,
                    vis,
                    unsafety,
                    auto_token,
                    restriction: None,
                    trait_token,
                    ident,
                    generics,
                    colon_token,
                    supertraits,
                    brace_token,
                    items,
                })
            }

            impl Parse for ItemTraitAlias
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let (attrs, vis, trait_token, ident, generics) = parse_start_of_trait_alias(input)?;
                    parse_rest_of_trait_alias(input, attrs, vis, trait_token, ident, generics)
                }
            }

            fn parse_start_of_trait_alias
            (
                input: ParseStream,
            ) -> Result<(Vec<Attribute>, Visibility, Token![trait], Ident, Generics)>
            {
                let attrs = input.call(Attribute::parse_outer)?;
                let vis: Visibility = input.parse()?;
                let trait_token: Token![trait] = input.parse()?;
                let ident: Ident = input.parse()?;
                let generics: Generics = input.parse()?;
                Ok((attrs, vis, trait_token, ident, generics))
            }

            fn parse_rest_of_trait_alias
            (
                input: ParseStream,
                attrs: Vec<Attribute>,
                vis: Visibility,
                trait_token: Token![trait],
                ident: Ident,
                mut generics: Generics,
            ) -> Result<ItemTraitAlias>
            {
                let eq_token: Token![=] = input.parse()?;

                let mut bounds = Punctuated::new();
                loop {
                    if input.peek(Token![where]) || input.peek(Token![;]) {
                        break;
                    }
                    bounds.push_value({
                        let allow_precise_capture = false;
                        let allow_const = false;
                        TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                    });
                    if input.peek(Token![where]) || input.peek(Token![;]) {
                        break;
                    }
                    bounds.push_punct(input.parse()?);
                }

                generics.where_clause = input.parse()?;
                let semi_token: Token![;] = input.parse()?;

                Ok(ItemTraitAlias {
                    attrs,
                    vis,
                    trait_token,
                    ident,
                    generics,
                    eq_token,
                    bounds,
                    semi_token,
                })
            }

            impl Parse for TraitItem
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let defaultness: Option<Token![default]> = input.parse()?;
                    let ahead = input.fork();

                    let lookahead = ahead.lookahead1();
                    let allow_safe = false;
                    let mut item = if lookahead.peek(Token![fn]) || peek_signature(&ahead, allow_safe) {
                        input.parse().map(TraitItem::Fn)
                    } else if lookahead.peek(Token![const]) {
                        let const_token: Token![const] = ahead.parse()?;
                        let lookahead = ahead.lookahead1();
                        if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                            input.advance_to(&ahead);
                            let ident = input.call(Ident::parse_any)?;
                            let mut generics: Generics = input.parse()?;
                            let colon_token: Token![:] = input.parse()?;
                            let ty: Type = input.parse()?;
                            let default = if let Some(eq_token) = input.parse::<Option<Token![=]>>()? {
                                let expr: Expr = input.parse()?;
                                Some((eq_token, expr))
                            } else {
                                None
                            };
                            generics.where_clause = input.parse()?;
                            let semi_token: Token![;] = input.parse()?;
                            if generics.lt_token.is_none() && generics.where_clause.is_none() {
                                Ok(TraitItem::Const(TraitItemConst {
                                    attrs: Vec::new(),
                                    const_token,
                                    ident,
                                    generics,
                                    colon_token,
                                    ty,
                                    default,
                                    semi_token,
                                }))
                            } else {
                                return Ok(TraitItem::Verbatim(verbatim::between(&begin, input)));
                            }
                        } else if lookahead.peek(Token![async])
                            || lookahead.peek(Token![unsafe])
                            || lookahead.peek(Token![extern])
                            || lookahead.peek(Token![fn])
                        {
                            input.parse().map(TraitItem::Fn)
                        } else {
                            Err(lookahead.error())
                        }
                    } else if lookahead.peek(Token![type]) {
                        parse_trait_item_type(begin.fork(), input)
                    } else if vis.is_inherited()
                        && defaultness.is_none()
                        && (lookahead.peek(Ident)
                            || lookahead.peek(Token![self])
                            || lookahead.peek(Token![super])
                            || lookahead.peek(Token![crate])
                            || lookahead.peek(Token![::]))
                    {
                        input.parse().map(TraitItem::Macro)
                    } else {
                        Err(lookahead.error())
                    }?;

                    match (vis, defaultness) {
                        (Visibility::Inherited, None) => {}
                        _ => return Ok(TraitItem::Verbatim(verbatim::between(&begin, input))),
                    }

                    let item_attrs = match &mut item {
                        TraitItem::Const(item) => &mut item.attrs,
                        TraitItem::Fn(item) => &mut item.attrs,
                        TraitItem::Type(item) => &mut item.attrs,
                        TraitItem::Macro(item) => &mut item.attrs,
                        TraitItem::Verbatim(_) => unreachable!(),
                    };
                    attrs.append(item_attrs);
                    *item_attrs = attrs;
                    Ok(item)
                }
            }

            impl Parse for TraitItemConst
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let const_token: Token![const] = input.parse()?;

                    let lookahead = input.lookahead1();
                    let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                        input.call(Ident::parse_any)?
                    } else {
                        return Err(lookahead.error());
                    };

                    let colon_token: Token![:] = input.parse()?;
                    let ty: Type = input.parse()?;
                    let default = if input.peek(Token![=]) {
                        let eq_token: Token![=] = input.parse()?;
                        let default: Expr = input.parse()?;
                        Some((eq_token, default))
                    } else {
                        None
                    };
                    let semi_token: Token![;] = input.parse()?;

                    Ok(TraitItemConst {
                        attrs,
                        const_token,
                        ident,
                        generics: Generics::default(),
                        colon_token,
                        ty,
                        default,
                        semi_token,
                    })
                }
            }

            impl Parse for TraitItemFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let sig: Signature = input.parse()?;

                    let lookahead = input.lookahead1();
                    let (brace_token, stmts, semi_token) = if lookahead.peek(token::Brace) {
                        let content;
                        let brace_token = braced!(content in input);
                        attr::parsing::parse_inner(&content, &mut attrs)?;
                        let stmts = content.call(Block::parse_within)?;
                        (Some(brace_token), stmts, None)
                    } else if lookahead.peek(Token![;]) {
                        let semi_token: Token![;] = input.parse()?;
                        (None, Vec::new(), Some(semi_token))
                    } else {
                        return Err(lookahead.error());
                    };

                    Ok(TraitItemFn {
                        attrs,
                        sig,
                        default: brace_token.map(|brace_token| Block { brace_token, stmts }),
                        semi_token,
                    })
                }
            }

            impl Parse for TraitItemType
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let type_token: Token![type] = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let mut generics: Generics = input.parse()?;
                    let (colon_token, bounds) = FlexibleItemType::parse_optional_bounds(input)?;
                    let default = FlexibleItemType::parse_optional_definition(input)?;
                    generics.where_clause = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;
                    Ok(TraitItemType {
                        attrs,
                        type_token,
                        ident,
                        generics,
                        colon_token,
                        bounds,
                        default,
                        semi_token,
                    })
                }
            }

            fn parse_trait_item_type(begin: ParseBuffer, input: ParseStream) -> Result<TraitItem>
            {
                let FlexibleItemType {
                    vis,
                    defaultness: _,
                    type_token,
                    ident,
                    generics,
                    colon_token,
                    bounds,
                    ty,
                    semi_token,
                } = FlexibleItemType::parse(
                    input,
                    TypeDefaultness::Disallowed,
                    WhereClauseLocation::AfterEq,
                )?;

                if vis.is_some() {
                    Ok(TraitItem::Verbatim(verbatim::between(&begin, input)))
                } else {
                    Ok(TraitItem::Type(TraitItemType {
                        attrs: Vec::new(),
                        type_token,
                        ident,
                        generics,
                        colon_token,
                        bounds,
                        default: ty,
                        semi_token,
                    }))
                }
            }

            impl Parse for TraitItemMacro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let mac: Macro = input.parse()?;
                    let semi_token: Option<Token![;]> = if mac.delimiter.is_brace() {
                        None
                    } else {
                        Some(input.parse()?)
                    };
                    Ok(TraitItemMacro {
                        attrs,
                        mac,
                        semi_token,
                    })
                }
            }

            impl Parse for ItemImpl
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_verbatim_impl = false;
                    parse_impl(input, allow_verbatim_impl).map(Option::unwrap)
                }
            }

            fn parse_impl(input: ParseStream, allow_verbatim_impl: bool) -> Result<Option<ItemImpl>>
            {
                let mut attrs = input.call(Attribute::parse_outer)?;
                let has_visibility = allow_verbatim_impl && input.parse::<Visibility>()?.is_some();
                let defaultness: Option<Token![default]> = input.parse()?;
                let unsafety: Option<Token![unsafe]> = input.parse()?;
                let impl_token: Token![impl] = input.parse()?;

                let has_generics = generics::parsing::choose_generics_over_qpath(input);
                let mut generics: Generics = if has_generics {
                    input.parse()?
                } else {
                    Generics::default()
                };

                let is_const_impl = allow_verbatim_impl
                    && (input.peek(Token![const]) || input.peek(Token![?]) && input.peek2(Token![const]));
                if is_const_impl {
                    input.parse::<Option<Token![?]>>()?;
                    input.parse::<Token![const]>()?;
                }

                let polarity = if input.peek(Token![!]) && !input.peek2(token::Brace) {
                    Some(input.parse::<Token![!]>()?)
                } else {
                    None
                };
                
                let mut first_ty: Type = input.parse()?;
                let self_ty: Type;
                let trait_;

                let is_impl_for = input.peek(Token![for]);
                if is_impl_for {
                    let for_token: Token![for] = input.parse()?;
                    let mut first_ty_ref = &first_ty;
                    while let Type::Group(ty) = first_ty_ref {
                        first_ty_ref = &ty.elem;
                    }
                    if let Type::Path(TypePath { qself: None, .. }) = first_ty_ref {
                        while let Type::Group(ty) = first_ty {
                            first_ty = *ty.elem;
                        }
                        if let Type::Path(TypePath { qself: None, path }) = first_ty {
                            trait_ = Some((polarity, path, for_token));
                        } else {
                            unreachable!();
                        }
                    } else if !allow_verbatim_impl {
                        
                return Err(Error::new_spanned(first_ty_ref, "expected trait path"));
                    } else {
                        trait_ = None;
                    }
                    self_ty = input.parse()?;
                } else if let Some(polarity) = polarity {
                    return Err(Error::new(
                        polarity.span,
                        "inherent impls cannot be negative",
                    ));
                } else {
                    trait_ = None;
                    self_ty = first_ty;
                }

                generics.where_clause = input.parse()?;

                let content;
                let brace_token = braced!(content in input);
                attr::parsing::parse_inner(&content, &mut attrs)?;

                let mut items = Vec::new();
                while !content.is_empty() {
                    items.push(content.parse()?);
                }

                if has_visibility || is_const_impl || is_impl_for && trait_.is_none() {
                    Ok(None)
                } else {
                    Ok(Some(ItemImpl {
                        attrs,
                        defaultness,
                        unsafety,
                        impl_token,
                        generics,
                        trait_,
                        self_ty: Box::new(self_ty),
                        brace_token,
                        items,
                    }))
                }
            }

            impl Parse for ImplItem
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let ahead = input.fork();
                    let vis: Visibility = ahead.parse()?;

                    let mut lookahead = ahead.lookahead1();
                    let defaultness = if lookahead.peek(Token![default]) && !ahead.peek2(Token![!]) {
                        let defaultness: Token![default] = ahead.parse()?;
                        lookahead = ahead.lookahead1();
                        Some(defaultness)
                    } else {
                        None
                    };

                    let allow_safe = false;
                    let mut item = if lookahead.peek(Token![fn]) || peek_signature(&ahead, allow_safe) {
                        let allow_omitted_body = true;
                        if let Some(item) = parse_impl_item_fn(input, allow_omitted_body)? {
                            Ok(ImplItem::Fn(item))
                        } else {
                            Ok(ImplItem::Verbatim(verbatim::between(&begin, input)))
                        }
                    } else if lookahead.peek(Token![const]) {
                        input.advance_to(&ahead);
                        let const_token: Token![const] = input.parse()?;
                        let lookahead = input.lookahead1();
                        let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                            input.call(Ident::parse_any)?
                        } else {
                            return Err(lookahead.error());
                        };
                        let mut generics: Generics = input.parse()?;
                        let colon_token: Token![:] = input.parse()?;
                        let ty: Type = input.parse()?;
                        let value = if let Some(eq_token) = input.parse::<Option<Token![=]>>()? {
                            let expr: Expr = input.parse()?;
                            Some((eq_token, expr))
                        } else {
                            None
                        };
                        generics.where_clause = input.parse()?;
                        let semi_token: Token![;] = input.parse()?;
                        return match value {
                            Some((eq_token, expr))
                                if generics.lt_token.is_none() && generics.where_clause.is_none() =>
                            {
                                Ok(ImplItem::Const(ImplItemConst {
                                    attrs,
                                    vis,
                                    defaultness,
                                    const_token,
                                    ident,
                                    generics,
                                    colon_token,
                                    ty,
                                    eq_token,
                                    expr,
                                    semi_token,
                                }))
                            }
                            _ => Ok(ImplItem::Verbatim(verbatim::between(&begin, input))),
                        };
                    } else if lookahead.peek(Token![type]) {
                        parse_impl_item_type(begin, input)
                    } else if vis.is_inherited()
                        && defaultness.is_none()
                        && (lookahead.peek(Ident)
                            || lookahead.peek(Token![self])
                            || lookahead.peek(Token![super])
                            || lookahead.peek(Token![crate])
                            || lookahead.peek(Token![::]))
                    {
                        input.parse().map(ImplItem::Macro)
                    } else {
                        Err(lookahead.error())
                    }?;

                    {
                        let item_attrs = match &mut item {
                            ImplItem::Const(item) => &mut item.attrs,
                            ImplItem::Fn(item) => &mut item.attrs,
                            ImplItem::Type(item) => &mut item.attrs,
                            ImplItem::Macro(item) => &mut item.attrs,
                            ImplItem::Verbatim(_) => return Ok(item),
                        };
                        attrs.append(item_attrs);
                        *item_attrs = attrs;
                    }

                    Ok(item)
                }
            }

            impl Parse for ImplItemConst
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let defaultness: Option<Token![default]> = input.parse()?;
                    let const_token: Token![const] = input.parse()?;

                    let lookahead = input.lookahead1();
                    let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                        input.call(Ident::parse_any)?
                    } else {
                        return Err(lookahead.error());
                    };

                    let colon_token: Token![:] = input.parse()?;
                    let ty: Type = input.parse()?;
                    let eq_token: Token![=] = input.parse()?;
                    let expr: Expr = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;

                    Ok(ImplItemConst {
                        attrs,
                        vis,
                        defaultness,
                        const_token,
                        ident,
                        generics: Generics::default(),
                        colon_token,
                        ty,
                        eq_token,
                        expr,
                        semi_token,
                    })
                }
            }

            impl Parse for ImplItemFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_omitted_body = false;
                    parse_impl_item_fn(input, allow_omitted_body).map(Option::unwrap)
                }
            }

            fn parse_impl_item_fn
            (
                input: ParseStream,
                allow_omitted_body: bool,
            ) -> Result<Option<ImplItemFn>>
            {
                let mut attrs = input.call(Attribute::parse_outer)?;
                let vis: Visibility = input.parse()?;
                let defaultness: Option<Token![default]> = input.parse()?;
                let sig: Signature = input.parse()?;

               
               
               
                if allow_omitted_body && input.parse::<Option<Token![;]>>()?.is_some() {
                    return Ok(None);
                }

                let content;
                let brace_token = braced!(content in input);
                attrs.extend(content.call(Attribute::parse_inner)?);
                let block = Block {
                    brace_token,
                    stmts: content.call(Block::parse_within)?,
                };

                Ok(Some(ImplItemFn {
                    attrs,
                    vis,
                    defaultness,
                    sig,
                    block,
                }))
            }

            impl Parse for ImplItemType
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let defaultness: Option<Token![default]> = input.parse()?;
                    let type_token: Token![type] = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let mut generics: Generics = input.parse()?;
                    let eq_token: Token![=] = input.parse()?;
                    let ty: Type = input.parse()?;
                    generics.where_clause = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;
                    Ok(ImplItemType {
                        attrs,
                        vis,
                        defaultness,
                        type_token,
                        ident,
                        generics,
                        eq_token,
                        ty,
                        semi_token,
                    })
                }
            }

            fn parse_impl_item_type(begin: ParseBuffer, input: ParseStream) -> Result<ImplItem>
            {
                let FlexibleItemType {
                    vis,
                    defaultness,
                    type_token,
                    ident,
                    generics,
                    colon_token,
                    bounds: _,
                    ty,
                    semi_token,
                } = FlexibleItemType::parse(
                    input,
                    TypeDefaultness::Optional,
                    WhereClauseLocation::AfterEq,
                )?;

                let (eq_token, ty) = match ty {
                    Some(ty) if colon_token.is_none() => ty,
                    _ => return Ok(ImplItem::Verbatim(verbatim::between(&begin, input))),
                };

                Ok(ImplItem::Type(ImplItemType {
                    attrs: Vec::new(),
                    vis,
                    defaultness,
                    type_token,
                    ident,
                    generics,
                    eq_token,
                    ty,
                    semi_token,
                }))
            }

            impl Parse for ImplItemMacro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let mac: Macro = input.parse()?;
                    let semi_token: Option<Token![;]> = if mac.delimiter.is_brace() {
                        None
                    } else {
                        Some(input.parse()?)
                    };
                    Ok(ImplItemMacro {
                        attrs,
                        mac,
                        semi_token,
                    })
                }
            }

            impl Visibility
            {
                fn is_inherited(&self) -> bool
        {
                    match self {
                        Visibility::Inherited => true,
                        _ => false,
                    }
                }
            }

            impl Parse for StaticMutability
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut_token: Option<Token![mut]> = input.parse()?;
                    Ok(mut_token.map_or(StaticMutability::None, StaticMutability::Mut))
                }
            }
        }
        
        pub mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    attr::FilterAttrs,
                    data::Fields,
                    item::
                    {
                        ForeignItemFn, ForeignItemMacro, ForeignItemStatic, ForeignItemType, ImplItemConst,
                        ImplItemFn, ImplItemMacro, ImplItemType, ItemConst, ItemEnum, ItemExternCrate, ItemFn,
                        ItemForeignMod, ItemImpl, ItemMacro, ItemMod, ItemStatic, ItemStruct, ItemTrait,
                        ItemTraitAlias, ItemType, ItemUnion, ItemUse, Receiver, Signature, StaticMutability,
                        TraitItemConst, TraitItemFn, TraitItemMacro, TraitItemType, UseGlob, UseGroup, UseName,
                        UsePath, UseRename, Variadic,
                    },
                    mac::MacroDelimiter,
                    path,
                    path::printing::PathStyle,
                    print::TokensOrDefault,
                    ty::Type,
                },
                *,
            };
            
            impl ToTokens for ItemExternCrate {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.extern_token.to_tokens(tokens);
                    self.crate_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    if let Some((as_token, rename)) = &self.rename {
                        as_token.to_tokens(tokens);
                        rename.to_tokens(tokens);
                    }
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemUse {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.use_token.to_tokens(tokens);
                    self.leading_colon.to_tokens(tokens);
                    self.tree.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemStatic {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.static_token.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.expr.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemConst {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.const_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.expr.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemFn {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.sig.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }

            impl ToTokens for ItemMod {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.mod_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    if let Some((brace, items)) = &self.content {
                        brace.surround(tokens, |tokens| {
                            tokens.append_all(self.attrs.inner());
                            tokens.append_all(items);
                        });
                    } else {
                        TokensOrDefault(&self.semi).to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for ItemForeignMod {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.unsafety.to_tokens(tokens);
                    self.abi.to_tokens(tokens);
                    self.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.items);
                    });
                }
            }

            impl ToTokens for ItemType {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.type_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemEnum {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.enum_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.brace_token.surround(tokens, |tokens| {
                        self.variants.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for ItemStruct {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.struct_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    match &self.fields {
                        Fields::Named(fields) => {
                            self.generics.where_clause.to_tokens(tokens);
                            fields.to_tokens(tokens);
                        }
                        Fields::Unnamed(fields) => {
                            fields.to_tokens(tokens);
                            self.generics.where_clause.to_tokens(tokens);
                            TokensOrDefault(&self.semi_token).to_tokens(tokens);
                        }
                        Fields::Unit => {
                            self.generics.where_clause.to_tokens(tokens);
                            TokensOrDefault(&self.semi_token).to_tokens(tokens);
                        }
                    }
                }
            }

            impl ToTokens for ItemUnion {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.union_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.fields.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemTrait {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.auto_token.to_tokens(tokens);
                    self.trait_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    if !self.supertraits.is_empty() {
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                        self.supertraits.to_tokens(tokens);
                    }
                    self.generics.where_clause.to_tokens(tokens);
                    self.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.items);
                    });
                }
            }

            impl ToTokens for ItemTraitAlias {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.trait_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemImpl {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.defaultness.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.impl_token.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    if let Some((polarity, path, for_token)) = &self.trait_ {
                        polarity.to_tokens(tokens);
                        path.to_tokens(tokens);
                        for_token.to_tokens(tokens);
                    }
                    self.self_ty.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.items);
                    });
                }
            }

            impl ToTokens for ItemMacro {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    path::printing::print_path(tokens, &self.mac.path, PathStyle::Mod);
                    self.mac.bang_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    match &self.mac.delimiter {
                        MacroDelimiter::Paren(paren) => {
                            paren.surround(tokens, |tokens| self.mac.tokens.to_tokens(tokens));
                        }
                        MacroDelimiter::Brace(brace) => {
                            brace.surround(tokens, |tokens| self.mac.tokens.to_tokens(tokens));
                        }
                        MacroDelimiter::Bracket(bracket) => {
                            bracket.surround(tokens, |tokens| self.mac.tokens.to_tokens(tokens));
                        }
                    }
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for UsePath {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.colon2_token.to_tokens(tokens);
                    self.tree.to_tokens(tokens);
                }
            }

            impl ToTokens for UseName {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                }
            }

            impl ToTokens for UseRename {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.as_token.to_tokens(tokens);
                    self.rename.to_tokens(tokens);
                }
            }

            impl ToTokens for UseGlob {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.star_token.to_tokens(tokens);
                }
            }

            impl ToTokens for UseGroup {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.brace_token.surround(tokens, |tokens| {
                        self.items.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TraitItemConst {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.const_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    if let Some((eq_token, default)) = &self.default {
                        eq_token.to_tokens(tokens);
                        default.to_tokens(tokens);
                    }
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for TraitItemFn {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.sig.to_tokens(tokens);
                    match &self.default {
                        Some(block) => {
                            block.brace_token.surround(tokens, |tokens| {
                                tokens.append_all(self.attrs.inner());
                                tokens.append_all(&block.stmts);
                            });
                        }
                        None => {
                            TokensOrDefault(&self.semi_token).to_tokens(tokens);
                        }
                    }
                }
            }

            impl ToTokens for TraitItemType {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.type_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    if !self.bounds.is_empty() {
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                        self.bounds.to_tokens(tokens);
                    }
                    if let Some((eq_token, default)) = &self.default {
                        eq_token.to_tokens(tokens);
                        default.to_tokens(tokens);
                    }
                    self.generics.where_clause.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for TraitItemMacro {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.mac.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ImplItemConst {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.defaultness.to_tokens(tokens);
                    self.const_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.expr.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ImplItemFn {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.defaultness.to_tokens(tokens);
                    self.sig.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }

            impl ToTokens for ImplItemType {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.defaultness.to_tokens(tokens);
                    self.type_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ImplItemMacro {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.mac.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ForeignItemFn {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.sig.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ForeignItemStatic {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.static_token.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ForeignItemType {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.type_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ForeignItemMacro {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.mac.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for Signature {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.constness.to_tokens(tokens);
                    self.asyncness.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.abi.to_tokens(tokens);
                    self.fn_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.paren_token.surround(tokens, |tokens| {
                        self.inputs.to_tokens(tokens);
                        if let Some(variadic) = &self.variadic {
                            if !self.inputs.empty_or_trailing() {
                                <Token![,]>::default().to_tokens(tokens);
                            }
                            variadic.to_tokens(tokens);
                        }
                    });
                    self.output.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                }
            }

            impl ToTokens for Receiver {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some((ampersand, lifetime)) = &self.reference {
                        ampersand.to_tokens(tokens);
                        lifetime.to_tokens(tokens);
                    }
                    self.mutability.to_tokens(tokens);
                    self.self_token.to_tokens(tokens);
                    if let Some(colon_token) = &self.colon_token {
                        colon_token.to_tokens(tokens);
                        self.ty.to_tokens(tokens);
                    } else {
                        let consistent = match (&self.reference, &self.mutability, &*self.ty) {
                            (Some(_), mutability, Type::Reference(ty)) => {
                                mutability.is_some() == ty.mutability.is_some()
                                    && match &*ty.elem {
                                        Type::Path(ty) => ty.qself.is_none() && ty.path.is_ident("Self"),
                                        _ => false,
                                    }
                            }
                            (None, _, Type::Path(ty)) => ty.qself.is_none() && ty.path.is_ident("Self"),
                            _ => false,
                        };
                        if !consistent {
                            <Token![:]>::default().to_tokens(tokens);
                            self.ty.to_tokens(tokens);
                        }
                    }
                }
            }

            impl ToTokens for Variadic {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some((pat, colon)) = &self.pat {
                        pat.to_tokens(tokens);
                        colon.to_tokens(tokens);
                    }
                    self.dots.to_tokens(tokens);
                    self.comma.to_tokens(tokens);
                }
            }

            impl ToTokens for StaticMutability {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        StaticMutability::None => {}
                        StaticMutability::Mut(mut_token) => mut_token.to_tokens(tokens),
                    }
                }
            }
        }
    } pub use self::item::
    {
        FnArg, ForeignItem, ForeignItemFn, ForeignItemMacro, ForeignItemStatic, ForeignItemType, ImplItem,
        ImplItemConst, ImplItemFn, ImplItemMacro, ImplItemType, ImplRestriction, Item, ItemConst, ItemEnum,
        ItemExternCrate, ItemFn, ItemForeignMod, ItemImpl, ItemMacro, ItemMod, ItemStatic, ItemStruct, ItemTrait,
        ItemTraitAlias, ItemType, ItemUnion, ItemUse, Receiver, Signature, StaticMutability, TraitItem,
        TraitItemConst, TraitItemFn, TraitItemMacro, TraitItemType, UseGlob, UseGroup, UseName, UsePath,
        UseRename, UseTree, Variadic,
    };

    pub mod lifetime
    {
        use ::
        {
            cmp::{ Ordering },
            fmt::{ self, Display },
            hash::{ Hash, Hasher },
            process::macros::{ Ident, Span },
            syntax::{ lookahead },
            *,
        };
        /*
        */
        /// A Rust lifetime: `'a`.
        pub struct Lifetime 
        {
            pub apostrophe: Span,
            pub ident: Ident,
        }

        impl Lifetime 
        {
            pub fn new(symbol: &str, span: Span) -> Self {
                if !symbol.starts_with('\'') {
                    panic!(
                        "lifetime name must start with apostrophe as in \"'a\", got {:?}",
                        symbol
                    );
                }

                if symbol == "'" {
                    panic!("lifetime name must not be empty");
                }

                if !::syntax::ident::xid_ok(&symbol[1..]) {
                    panic!("{:?} is not a valid lifetime name", symbol);
                }

                Lifetime {
                    apostrophe: span,
                    ident: Ident::new(&symbol[1..], span),
                }
            }

            pub fn span(&self) -> Span
            {
                self.apostrophe
                    .join(self.ident.span())
                    .unwrap_or(self.apostrophe)
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.apostrophe = span;
                self.ident.set_span(span);
            }
        }

        impl Display for Lifetime 
        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                "'".fmt(formatter)?;
                self.ident.fmt(formatter)
            }
        }

        impl Clone for Lifetime 
        {
            fn clone(&self) -> Self {
                Lifetime {
                    apostrophe: self.apostrophe,
                    ident: self.ident.clone(),
                }
            }
        }

        impl PartialEq for Lifetime 
        {
            fn eq(&self, other: &Lifetime) -> bool
            {
                self.ident.eq(&other.ident)
            }
        }

        impl Eq for Lifetime {}

        impl PartialOrd for Lifetime 
        {
            fn partial_cmp(&self, other: &Lifetime) -> Option<Ordering> {
                Some(self.cmp(other))
            }
        }

        impl Ord for Lifetime 
        {
            fn cmp(&self, other: &Lifetime) -> Ordering
            {
                self.ident.cmp(&other.ident)
            }
        }

        impl Hash for Lifetime 
        {
            fn hash<H: Hasher>(&self, h: &mut H)
            {
                self.ident.hash(h);
            }
        }
        
        pub_if_not_doc!
        {
            pub fn Lifetime(marker: lookahead::TokenMarker) -> Lifetime
            {
                match marker {}
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    error::Result,
                    lifetime::Lifetime,
                    parse::{Parse, ParseStream},
                },
                *,
            };
            
            impl Parse for Lifetime
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    input.step(|cursor| {
                        cursor
                            .lifetime()
                            .ok_or_else(|| cursor.error("expected lifetime"))
                    })
                }
            }
        }

        mod printing
        {
            use ::
            {
                process::macros::{Punct, Spacing, TokenStream},
                quote::{ToTokens, TokenStreamExt},
                syntax::lifetime::Lifetime,
                *,
            };
            
            impl ToTokens for Lifetime {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    let mut apostrophe = Punct::new('\'', Spacing::Joint);
                    apostrophe.set_span(self.apostrophe);
                    tokens.append(apostrophe);
                    self.ident.to_tokens(tokens);
                }
            }
        }
    } pub use self::lifetime::{ Lifetime };

    pub mod lit
    {
        use ::
        {
            ffi::{ CStr, CString },
            fmt::{ self, Display },
            hash::{ Hash, Hasher },
            process::macros::
            {
                Ident, Literal, Span, TokenStream, TokenTree
            },
            syntax::
            {
                parse::{ Parse, Parser },
                lookahead, Error, Result
            },
            str::{ self, FromStr },
            *,
        };
        /*
        */
        ast_enum_of_structs!
        {
            /// A Rust literal such as a string or integer or boolean.
            #[non_exhaustive]
            pub enum Lit {
                /// A UTF-8 string literal: `"foo"`.
                Str(LitStr),
                /// A byte string literal: `b"foo"`.
                ByteStr(LitByteStr),
                /// A nul-terminated C-string literal: `c"foo"`.
                CStr(LitCStr),
                /// A byte literal: `b'f'`.
                Byte(LitByte),
                /// A character literal: `'a'`.
                Char(LitChar),
                /// An integer literal: `1` or `1u16`.
                Int(LitInt),
                /// A floating point literal: `1f64` or `1.0e10f64`.
                Float(LitFloat),
                /// A boolean literal: `true` or `false`.
                Bool(LitBool),
                /// A raw token literal not interpreted by Syn.
                Verbatim(Literal),
            }
        }

        ast_struct! {
            /// A UTF-8 string literal: `"foo"`.
            pub struct LitStr {
                repr: Box<LitRepr>,
            }
        }

        ast_struct! {
            /// A byte string literal: `b"foo"`.
            pub struct LitByteStr {
                repr: Box<LitRepr>,
            }
        }

        ast_struct! {
            /// A nul-terminated C-string literal: `c"foo"`.
            pub struct LitCStr {
                repr: Box<LitRepr>,
            }
        }

        ast_struct! {
            /// A byte literal: `b'f'`.
            pub struct LitByte {
                repr: Box<LitRepr>,
            }
        }

        ast_struct! {
            /// A character literal: `'a'`.
            pub struct LitChar {
                repr: Box<LitRepr>,
            }
        }

        struct LitRepr {
            token: Literal,
            suffix: Box<str>,
        }

        ast_struct! {
            /// An integer literal: `1` or `1u16`.
            pub struct LitInt {
                repr: Box<LitIntRepr>,
            }
        }

        struct LitIntRepr {
            token: Literal,
            digits: Box<str>,
            suffix: Box<str>,
        }

        ast_struct! {
            /// A floating point literal: `1f64` or `1.0e10f64`.
            pub struct LitFloat {
                repr: Box<LitFloatRepr>,
            }
        }

        struct LitFloatRepr {
            token: Literal,
            digits: Box<str>,
            suffix: Box<str>,
        }

        ast_struct! {
            /// A boolean literal: `true` or `false`.
            pub struct LitBool {
                pub value: bool,
                pub span: Span,
            }
        }

        impl LitStr {
            pub fn new(value: &str, span: Span) -> Self {
                let mut token = Literal::string(value);
                token.set_span(span);
                LitStr {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> String {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_str(&repr);
                String::from(value)
            }
            /// Parse a syntax tree node from the content of this string literal.
            pub fn parse_with<F: Parser>(&self, parser: F) -> Result<F::Output> {
                use ::process::macros::Group;

               
                fn respan_token_stream(stream: TokenStream, span: Span) -> TokenStream {
                    stream
                        .into_iter()
                        .map(|token| respan_token_tree(token, span))
                        .collect()
                }

               
                fn respan_token_tree(mut token: TokenTree, span: Span) -> TokenTree {
                    match &mut token {
                        TokenTree::Group(g) => {
                            let stream = respan_token_stream(g.stream(), span);
                            *g = Group::new(g.delimiter(), stream);
                            g.set_span(span);
                        }
                        other => other.set_span(span),
                    }
                    token
                }

               
               
                let span = self.span();
                let mut tokens = TokenStream::from_str(&self.value())?;
                tokens = respan_token_stream(tokens, span);

                let result = ::syntax::parse::parse_scoped(parser, span, tokens)?;

                let suffix = self.suffix();
                if !suffix.is_empty() {
                    return Err(Error::new(
                        self.span(),
                        format!("unexpected suffix `{}` on string literal", suffix),
                    ));
                }

                Ok(result)
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitByteStr {
            pub fn new(value: &[u8], span: Span) -> Self {
                let mut token = Literal::byte_string(value);
                token.set_span(span);
                LitByteStr {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> Vec<u8>
            {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_byte_str(&repr);
                value
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitCStr {
            pub fn new(value: &CStr, span: Span) -> Self {
                let mut token = Literal::c_string(value);
                token.set_span(span);
                LitCStr {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> CString {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_c_str(&repr);
                value
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitByte {
            pub fn new(value: u8, span: Span) -> Self {
                let mut token = Literal::u8_suffixed(value);
                token.set_span(span);
                LitByte {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> u8 {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_byte(&repr);
                value
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitChar {
            pub fn new(value: char, span: Span) -> Self {
                let mut token = Literal::character(value);
                token.set_span(span);
                LitChar {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> char {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_char(&repr);
                value
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitInt {
            #[track_caller]
            pub fn new(repr: &str, span: Span) -> Self {
                let (digits, suffix) = match value::parse_lit_int(repr) {
                    Some(parse) => parse,
                    None => panic!("not an integer literal: `{}`", repr),
                };

                let mut token: Literal = repr.parse().unwrap();
                token.set_span(span);
                LitInt {
                    repr: Box::new(LitIntRepr {
                        token,
                        digits,
                        suffix,
                    }),
                }
            }

            pub fn base10_digits(&self) -> &str {
                &self.repr.digits
            }
            /// Parses the literal into a selected number type.
            pub fn base10_parse<N>(&self) -> Result<N> where
                N: FromStr,
                N::Err: Display,
           
            {
                self.base10_digits()
                    .parse()
                    .map_err(|err| Error::new(self.span(), err))
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl From<Literal> for LitInt {
            #[track_caller]
            fn from(token: Literal) -> Self {
                let repr = token.to_string();
                if let Some((digits, suffix)) = value::parse_lit_int(&repr) {
                    LitInt {
                        repr: Box::new(LitIntRepr {
                            token,
                            digits,
                            suffix,
                        }),
                    }
                } else {
                    panic!("not an integer literal: `{}`", repr);
                }
            }
        }

        impl Display for LitInt {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result
            {
                self.repr.token.fmt(formatter)
            }
        }

        impl LitFloat {
            #[track_caller]
            pub fn new(repr: &str, span: Span) -> Self {
                let (digits, suffix) = match value::parse_lit_float(repr) {
                    Some(parse) => parse,
                    None => panic!("not a float literal: `{}`", repr),
                };

                let mut token: Literal = repr.parse().unwrap();
                token.set_span(span);
                LitFloat {
                    repr: Box::new(LitFloatRepr {
                        token,
                        digits,
                        suffix,
                    }),
                }
            }

            pub fn base10_digits(&self) -> &str {
                &self.repr.digits
            }

            pub fn base10_parse<N>(&self) -> Result<N> where
                N: FromStr,
                N::Err: Display,
           
            {
                self.base10_digits()
                    .parse()
                    .map_err(|err| Error::new(self.span(), err))
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl From<Literal> for LitFloat {
            #[track_caller]
            fn from(token: Literal) -> Self {
                let repr = token.to_string();
                if let Some((digits, suffix)) = value::parse_lit_float(&repr) {
                    LitFloat {
                        repr: Box::new(LitFloatRepr {
                            token,
                            digits,
                            suffix,
                        }),
                    }
                } else {
                    panic!("not a float literal: `{}`", repr);
                }
            }
        }

        impl Display for LitFloat {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result
            {
                self.repr.token.fmt(formatter)
            }
        }

        impl LitBool {
            pub fn new(value: bool, span: Span) -> Self {
                LitBool { value, span }
            }

            pub fn value(&self) -> bool
            {
                self.value
            }

            pub fn span(&self) -> Span
            {
                self.span
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.span = span;
            }

            pub fn token(&self) -> Ident {
                let s = if self.value { "true" } else { "false" };
                Ident::new(s, self.span)
            }
        }

        mod debug_impls
        {
            use ::
            {
                fmt::{ self, Debug },
                syntax::lit::{ LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitInt, LitStr },
                *,
            };

            impl  Debug for LitStr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitStr")
                }
            }

            impl LitStr {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitByteStr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitByteStr")
                }
            }

            impl LitByteStr {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitCStr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitCStr")
                }
            }

            impl LitCStr {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitByte {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitByte")
                }
            }

            impl LitByte {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitChar {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitChar")
                }
            }

            impl LitChar {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitInt {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitInt")
                }
            }

            impl LitInt {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitFloat {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitFloat")
                }
            }

            impl LitFloat {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitBool {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitBool")
                }
            }

            impl LitBool {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("value", &self.value)
                        .finish()
                }
            }
        }

        impl Clone for LitRepr {
            fn clone(&self) -> Self {
                LitRepr {
                    token: self.token.clone(),
                    suffix: self.suffix.clone(),
                }
            }
        }

        impl Clone for LitIntRepr {
            fn clone(&self) -> Self {
                LitIntRepr {
                    token: self.token.clone(),
                    digits: self.digits.clone(),
                    suffix: self.suffix.clone(),
                }
            }
        }

        impl Clone for LitFloatRepr {
            fn clone(&self) -> Self {
                LitFloatRepr {
                    token: self.token.clone(),
                    digits: self.digits.clone(),
                    suffix: self.suffix.clone(),
                }
            }
        }

        macro_rules! lit_extra_traits {
            ($ty:ident) => {
                impl Clone for $ty {
                    fn clone(&self) -> Self {
                        $ty {
                            repr: self.repr.clone(),
                        }
                    }
                }

                        impl PartialEq for $ty {
                    fn eq(&self, other: &Self) -> bool
        {
                        self.repr.token.to_string() == other.repr.token.to_string()
                    }
                }

                        impl Hash for $ty {
                    fn hash<H>(&self, state: &mut H)
                    where
                        H: Hasher,
                    {
                        self.repr.token.to_string().hash(state);
                    }
                }

                 
                    pub_if_not_doc! {
                                
                    pub fn $ty(marker: lookahead::TokenMarker) -> $ty {
                        match marker {}
                    }
                }
            };
        }

        lit_extra_traits!(LitStr);
        lit_extra_traits!(LitByteStr);
        lit_extra_traits!(LitCStr);
        lit_extra_traits!(LitByte);
        lit_extra_traits!(LitChar);
        lit_extra_traits!(LitInt);
        lit_extra_traits!(LitFloat);

         
            pub_if_not_doc! {
                
            pub fn LitBool(marker: lookahead::TokenMarker) -> LitBool {
                match marker {}
            }
        }
        /// The style of a string literal, either plain quoted or a raw string like `r##"data"##`.
        pub enum StrStyle {
            /// An ordinary string like `"data"`.
            Cooked,
            /// A raw string like `r##"data"##`.
            Raw(usize),
        }

         
            pub_if_not_doc! {
                
            pub fn Lit(marker: lookahead::TokenMarker) -> Lit {
                match marker {}
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                cell::{ Cell },
                process::macros::{ Literal, Punct, Span },
                rc::{ Rc },
                syntax::
                {
                    buffer::Cursor,
                    error::Result,
                    lit::
                    {
                        value, Lit, LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitFloatRepr, LitInt,
                        LitIntRepr, LitStr,
                    },
                    parse::{Parse, ParseStream, Unexpected},
                    token::{self, Token},
                },
            };

            impl Parse for Lit
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    input.step(|cursor| {
                        if let Some((lit, rest)) = cursor.literal() {
                            return Ok((Lit::new(lit), rest));
                        }

                        if let Some((ident, rest)) = cursor.ident() {
                            let value = ident == "true";
                            if value || ident == "false" {
                                let lit_bool = LitBool {
                                    value,
                                    span: ident.span(),
                                };
                                return Ok((Lit::Bool(lit_bool), rest));
                            }
                        }

                        if let Some((punct, rest)) = cursor.punct() {
                            if punct.as_char() == '-' {
                                if let Some((lit, rest)) = parse_negative_lit(punct, rest) {
                                    return Ok((lit, rest));
                                }
                            }
                        }

                        Err(cursor.error("expected literal"))
                    })
                }
            }

            fn parse_negative_lit(neg: Punct, cursor: Cursor) -> Option<(Lit, Cursor)>
            {
                let (lit, rest) = cursor.literal()?;

                let mut span = neg.span();
                span = span.join(lit.span()).unwrap_or(span);

                let mut repr = lit.to_string();
                repr.insert(0, '-');

                if let Some((digits, suffix)) = value::parse_lit_int(&repr) {
                    let mut token: Literal = repr.parse().unwrap();
                    token.set_span(span);
                    return Some((
                        Lit::Int(LitInt {
                            repr: Box::new(LitIntRepr {
                                token,
                                digits,
                                suffix,
                            }),
                        }),
                        rest,
                    ));
                }

                let (digits, suffix) = value::parse_lit_float(&repr)?;
                let mut token: Literal = repr.parse().unwrap();
                token.set_span(span);
                Some((
                    Lit::Float(LitFloat {
                        repr: Box::new(LitFloatRepr {
                            token,
                            digits,
                            suffix,
                        }),
                    }),
                    rest,
                ))
            }

            impl Parse for LitStr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Str(lit)) => Ok(lit),
                        _ => Err(head.error("expected string literal")),
                    }
                }
            }

            impl Parse for LitByteStr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::ByteStr(lit)) => Ok(lit),
                        _ => Err(head.error("expected byte string literal")),
                    }
                }
            }

            impl Parse for LitCStr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::CStr(lit)) => Ok(lit),
                        _ => Err(head.error("expected C string literal")),
                    }
                }
            }

            impl Parse for LitByte
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Byte(lit)) => Ok(lit),
                        _ => Err(head.error("expected byte literal")),
                    }
                }
            }

            impl Parse for LitChar
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Char(lit)) => Ok(lit),
                        _ => Err(head.error("expected character literal")),
                    }
                }
            }

            impl Parse for LitInt
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Int(lit)) => Ok(lit),
                        _ => Err(head.error("expected integer literal")),
                    }
                }
            }

            impl Parse for LitFloat
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Float(lit)) => Ok(lit),
                        _ => Err(head.error("expected floating point literal")),
                    }
                }
            }

            impl Parse for LitBool
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Bool(lit)) => Ok(lit),
                        _ => Err(head.error("expected boolean literal")),
                    }
                }
            }

            fn peek_impl(cursor: Cursor, peek: fn(ParseStream) -> bool) -> bool
        {
                let scope = Span::call_site();
                let unexpected = Rc::new(Cell::new(Unexpected::None));
                let buffer = ::syntax::parse::new_parse_buffer(scope, cursor, unexpected);
                peek(&buffer)
            }

            macro_rules! impl_token {
                ($display:literal $name:ty) => {
                    impl Token for $name {
                        fn peek(cursor: Cursor) -> bool
        {
                            fn peek(input: ParseStream) -> bool
        {
                                <$name as Parse>::parse(input).is_ok()
                            }
                            peek_impl(cursor, peek)
                        }

                        fn display() -> &'static str {
                            $display
                        }
                    }

                    impl token::private::Sealed for $name {}
                };
            }

            impl_token!("literal" Lit);
            impl_token!("string literal" LitStr);
            impl_token!("byte string literal" LitByteStr);
            impl_token!("C-string literal" LitCStr);
            impl_token!("byte literal" LitByte);
            impl_token!("character literal" LitChar);
            impl_token!("integer literal" LitInt);
            impl_token!("floating point literal" LitFloat);
            impl_token!("boolean literal" LitBool);
        }

        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::lit::{LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitInt, LitStr},
                *,
            };
            
            impl ToTokens for LitStr
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitByteStr {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitCStr {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitByte {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitChar {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitInt {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitFloat {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitBool {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append(self.token());
                }
            }
        }

        mod value
        {
            use ::
            {
                ffi::{ CString },
                ops::{ Index, RangeFrom },
                process::macros::{ Literal, Span },
                syntax::
                {
                    bigint::BigInt,
                    lit::
                    {
                        Lit, LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitFloatRepr, LitInt, 
                        LitIntRepr, LitRepr, LitStr,
                    },
                },
                *,
            };
            
            impl Lit {
                /// Interpret a Syn literal from a proc-macro2 literal.
                #[track_caller]
                pub fn new(token: Literal) -> Self {
                    let repr = token.to_string();

                    match byte(&repr, 0) {
                       
                        b'"' | b'r' => {
                            let (_, suffix) = parse_lit_str(&repr);
                            return Lit::Str(LitStr {
                                repr: Box::new(LitRepr { token, suffix }),
                            });
                        }
                        b'b' => match byte(&repr, 1) {
                           
                            b'"' | b'r' => {
                                let (_, suffix) = parse_lit_byte_str(&repr);
                                return Lit::ByteStr(LitByteStr {
                                    repr: Box::new(LitRepr { token, suffix }),
                                });
                            }
                           
                            b'\'' => {
                                let (_, suffix) = parse_lit_byte(&repr);
                                return Lit::Byte(LitByte {
                                    repr: Box::new(LitRepr { token, suffix }),
                                });
                            }
                            _ => {}
                        },
                       
                        b'c' => {
                            let (_, suffix) = parse_lit_c_str(&repr);
                            return Lit::CStr(LitCStr {
                                repr: Box::new(LitRepr { token, suffix }),
                            });
                        }
                       
                        b'\'' => {
                            let (_, suffix) = parse_lit_char(&repr);
                            return Lit::Char(LitChar {
                                repr: Box::new(LitRepr { token, suffix }),
                            });
                        }
                        b'0'..=b'9' | b'-' => {
                           
                            if let Some((digits, suffix)) = parse_lit_int(&repr) {
                                return Lit::Int(LitInt {
                                    repr: Box::new(LitIntRepr {
                                        token,
                                        digits,
                                        suffix,
                                    }),
                                });
                            }
                           
                            if let Some((digits, suffix)) = parse_lit_float(&repr) {
                                return Lit::Float(LitFloat {
                                    repr: Box::new(LitFloatRepr {
                                        token,
                                        digits,
                                        suffix,
                                    }),
                                });
                            }
                        }
                       
                        b't' | b'f' => {
                            if repr == "true" || repr == "false" {
                                return Lit::Bool(LitBool {
                                    value: repr == "true",
                                    span: token.span(),
                                });
                            }
                        }
                        b'(' if repr == "(/*ERROR*/)" => return Lit::Verbatim(token),
                        _ => {}
                    }

                    panic!("unrecognized literal: `{}`", repr);
                }

                pub fn suffix(&self) -> &str {
                    match self {
                        Lit::Str(lit) => lit.suffix(),
                        Lit::ByteStr(lit) => lit.suffix(),
                        Lit::CStr(lit) => lit.suffix(),
                        Lit::Byte(lit) => lit.suffix(),
                        Lit::Char(lit) => lit.suffix(),
                        Lit::Int(lit) => lit.suffix(),
                        Lit::Float(lit) => lit.suffix(),
                        Lit::Bool(_) | Lit::Verbatim(_) => "",
                    }
                }

                pub fn span(&self) -> Span {
                    match self {
                        Lit::Str(lit) => lit.span(),
                        Lit::ByteStr(lit) => lit.span(),
                        Lit::CStr(lit) => lit.span(),
                        Lit::Byte(lit) => lit.span(),
                        Lit::Char(lit) => lit.span(),
                        Lit::Int(lit) => lit.span(),
                        Lit::Float(lit) => lit.span(),
                        Lit::Bool(lit) => lit.span,
                        Lit::Verbatim(lit) => lit.span(),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match self {
                        Lit::Str(lit) => lit.set_span(span),
                        Lit::ByteStr(lit) => lit.set_span(span),
                        Lit::CStr(lit) => lit.set_span(span),
                        Lit::Byte(lit) => lit.set_span(span),
                        Lit::Char(lit) => lit.set_span(span),
                        Lit::Int(lit) => lit.set_span(span),
                        Lit::Float(lit) => lit.set_span(span),
                        Lit::Bool(lit) => lit.span = span,
                        Lit::Verbatim(lit) => lit.set_span(span),
                    }
                }
            }
            /// Get a byte at offset idx, or a default of `b'\0'` if we're looking past the end of the input buffer.
            pub fn byte<S: AsRef<[u8]> + ?Sized>(s: &S, idx: usize) -> u8 {
                let s = s.as_ref();
                if idx < s.len() {
                    s[idx]
                } else {
                    0
                }
            }

            fn next_chr(s: &str) -> char {
                s.chars().next().unwrap_or('\0')
            }

            pub fn parse_lit_str(s: &str) -> (Box<str>, Box<str>) {
                match byte(s, 0) {
                    b'"' => parse_lit_str_cooked(s),
                    b'r' => parse_lit_str_raw(s),
                    _ => unreachable!(),
                }
            }

            fn parse_lit_str_cooked(mut s: &str) -> (Box<str>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'"');
                s = &s[1..];

                let mut content = String::new();
                'outer: loop {
                    let ch = match byte(s, 0) {
                        b'"' => break,
                        b'\\' => {
                            let b = byte(s, 1);
                            s = &s[2..];
                            match b {
                                b'x' => {
                                    let (byte, rest) = backslash_x(s);
                                    s = rest;
                                    assert!(byte <= 0x7F, "invalid \\x byte in string literal");
                                    char::from(byte)
                                }
                                b'u' => {
                                    let (ch, rest) = backslash_u(s);
                                    s = rest;
                                    ch
                                }
                                b'n' => '\n',
                                b'r' => '\r',
                                b't' => '\t',
                                b'\\' => '\\',
                                b'0' => '\0',
                                b'\'' => '\'',
                                b'"' => '"',
                                b'\r' | b'\n' => loop {
                                    let b = byte(s, 0);
                                    match b {
                                        b' ' | b'\t' | b'\n' | b'\r' => s = &s[1..],
                                        _ => continue 'outer,
                                    }
                                },
                                b => panic!(
                                    "unexpected byte '{}' after \\ character in string literal",
                                    ascii::escape_default(b),
                                ),
                            }
                        }
                        b'\r' => {
                            assert_eq!(byte(s, 1), b'\n', "bare CR not allowed in string");
                            s = &s[2..];
                            '\n'
                        }
                        _ => {
                            let ch = next_chr(s);
                            s = &s[ch.len_utf8()..];
                            ch
                        }
                    };
                    content.push(ch);
                }

                assert!(s.starts_with('"'));
                let content = content.into_boxed_str();
                let suffix = s[1..].to_owned().into_boxed_str();
                (content, suffix)
            }

            fn parse_lit_str_raw(mut s: &str) -> (Box<str>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'r');
                s = &s[1..];

                let mut pounds = 0;
                while byte(s, pounds) == b'#' {
                    pounds += 1;
                }
                assert_eq!(byte(s, pounds), b'"');
                let close = s.rfind('"').unwrap();
                for end in s[close + 1..close + 1 + pounds].bytes() {
                    assert_eq!(end, b'#');
                }

                let content = s[pounds + 1..close].to_owned().into_boxed_str();
                let suffix = s[close + 1 + pounds..].to_owned().into_boxed_str();
                (content, suffix)
            }

            pub fn parse_lit_byte_str(s: &str) -> (Vec<u8>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'b');
                match byte(s, 1) {
                    b'"' => parse_lit_byte_str_cooked(s),
                    b'r' => parse_lit_byte_str_raw(s),
                    _ => unreachable!(),
                }
            }

            fn parse_lit_byte_str_cooked(mut s: &str) -> (Vec<u8>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'b');
                assert_eq!(byte(s, 1), b'"');
                s = &s[2..];

               
                let mut v = s.as_bytes();

                let mut out = Vec::new();
                'outer: loop {
                    let byte = match byte(v, 0) {
                        b'"' => break,
                        b'\\' => {
                            let b = byte(v, 1);
                            v = &v[2..];
                            match b {
                                b'x' => {
                                    let (b, rest) = backslash_x(v);
                                    v = rest;
                                    b
                                }
                                b'n' => b'\n',
                                b'r' => b'\r',
                                b't' => b'\t',
                                b'\\' => b'\\',
                                b'0' => b'\0',
                                b'\'' => b'\'',
                                b'"' => b'"',
                                b'\r' | b'\n' => loop {
                                    let byte = byte(v, 0);
                                    if matches!(byte, b' ' | b'\t' | b'\n' | b'\r') {
                                        v = &v[1..];
                                    } else {
                                        continue 'outer;
                                    }
                                },
                                b => panic!(
                                    "unexpected byte '{}' after \\ character in byte-string literal",
                                    ascii::escape_default(b),
                                ),
                            }
                        }
                        b'\r' => {
                            assert_eq!(byte(v, 1), b'\n', "bare CR not allowed in string");
                            v = &v[2..];
                            b'\n'
                        }
                        b => {
                            v = &v[1..];
                            b
                        }
                    };
                    out.push(byte);
                }

                assert_eq!(byte(v, 0), b'"');
                let suffix = s[s.len() - v.len() + 1..].to_owned().into_boxed_str();
                (out, suffix)
            }

            fn parse_lit_byte_str_raw(s: &str) -> (Vec<u8>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'b');
                let (value, suffix) = parse_lit_str_raw(&s[1..]);
                (String::from(value).into_bytes(), suffix)
            }

            pub fn parse_lit_c_str(s: &str) -> (CString, Box<str>)
            {
                assert_eq!(byte(s, 0), b'c');
                match byte(s, 1) {
                    b'"' => parse_lit_c_str_cooked(s),
                    b'r' => parse_lit_c_str_raw(s),
                    _ => unreachable!(),
                }
            }

            fn parse_lit_c_str_cooked(mut s: &str) -> (CString, Box<str>)
            {
                assert_eq!(byte(s, 0), b'c');
                assert_eq!(byte(s, 1), b'"');
                s = &s[2..];

               
                let mut v = s.as_bytes();

                let mut out = Vec::new();
                'outer: loop {
                    let byte = match byte(v, 0) {
                        b'"' => break,
                        b'\\' => {
                            let b = byte(v, 1);
                            v = &v[2..];
                            match b {
                                b'x' => {
                                    let (b, rest) = backslash_x(v);
                                    assert!(b != 0, "\\x00 is not allowed in C-string literal");
                                    v = rest;
                                    b
                                }
                                b'u' => {
                                    let (ch, rest) = backslash_u(v);
                                    assert!(ch != '\0', "\\u{{0}} is not allowed in C-string literal");
                                    v = rest;
                                    out.extend_from_slice(ch.encode_utf8(&mut [0u8; 4]).as_bytes());
                                    continue 'outer;
                                }
                                b'n' => b'\n',
                                b'r' => b'\r',
                                b't' => b'\t',
                                b'\\' => b'\\',
                                b'\'' => b'\'',
                                b'"' => b'"',
                                b'\r' | b'\n' => loop {
                                    let byte = byte(v, 0);
                                    if matches!(byte, b' ' | b'\t' | b'\n' | b'\r') {
                                        v = &v[1..];
                                    } else {
                                        continue 'outer;
                                    }
                                },
                                b => panic!(
                                    "unexpected byte '{}' after \\ character in byte literal",
                                    ascii::escape_default(b),
                                ),
                            }
                        }
                        b'\r' => {
                            assert_eq!(byte(v, 1), b'\n', "bare CR not allowed in string");
                            v = &v[2..];
                            b'\n'
                        }
                        b => {
                            v = &v[1..];
                            b
                        }
                    };
                    out.push(byte);
                }

                assert_eq!(byte(v, 0), b'"');
                let suffix = s[s.len() - v.len() + 1..].to_owned().into_boxed_str();
                (CString::new(out).unwrap(), suffix)
            }

            fn parse_lit_c_str_raw(s: &str) -> (CString, Box<str>)
            {
                assert_eq!(byte(s, 0), b'c');
                let (value, suffix) = parse_lit_str_raw(&s[1..]);
                (CString::new(String::from(value)).unwrap(), suffix)
            }

            pub fn parse_lit_byte(s: &str) -> (u8, Box<str>)
            {
                assert_eq!(byte(s, 0), b'b');
                assert_eq!(byte(s, 1), b'\'');

               
                let mut v = &s.as_bytes()[2..];

                let b = match byte(v, 0) {
                    b'\\' => {
                        let b = byte(v, 1);
                        v = &v[2..];
                        match b {
                            b'x' => {
                                let (b, rest) = backslash_x(v);
                                v = rest;
                                b
                            }
                            b'n' => b'\n',
                            b'r' => b'\r',
                            b't' => b'\t',
                            b'\\' => b'\\',
                            b'0' => b'\0',
                            b'\'' => b'\'',
                            b'"' => b'"',
                            b => panic!(
                                "unexpected byte '{}' after \\ character in byte literal",
                                ascii::escape_default(b),
                            ),
                        }
                    }
                    b => {
                        v = &v[1..];
                        b
                    }
                };

                assert_eq!(byte(v, 0), b'\'');
                let suffix = s[s.len() - v.len() + 1..].to_owned().into_boxed_str();
                (b, suffix)
            }

            pub fn parse_lit_char(mut s: &str) -> (char, Box<str>)
            {
                assert_eq!(byte(s, 0), b'\'');
                s = &s[1..];

                let ch = match byte(s, 0) {
                    b'\\' => {
                        let b = byte(s, 1);
                        s = &s[2..];
                        match b {
                            b'x' => {
                                let (byte, rest) = backslash_x(s);
                                s = rest;
                                assert!(byte <= 0x7F, "invalid \\x byte in character literal");
                                char::from(byte)
                            }
                            b'u' => {
                                let (ch, rest) = backslash_u(s);
                                s = rest;
                                ch
                            }
                            b'n' => '\n',
                            b'r' => '\r',
                            b't' => '\t',
                            b'\\' => '\\',
                            b'0' => '\0',
                            b'\'' => '\'',
                            b'"' => '"',
                            b => panic!(
                                "unexpected byte '{}' after \\ character in character literal",
                                ascii::escape_default(b),
                            ),
                        }
                    }
                    _ => {
                        let ch = next_chr(s);
                        s = &s[ch.len_utf8()..];
                        ch
                    }
                };
                assert_eq!(byte(s, 0), b'\'');
                let suffix = s[1..].to_owned().into_boxed_str();
                (ch, suffix)
            }

            fn backslash_x<S>(s: &S) -> (u8, &S) where
                S: Index<RangeFrom<usize>, Output = S> + AsRef<[u8]> + ?Sized,
            {
                let mut ch = 0;
                let b0 = byte(s, 0);
                let b1 = byte(s, 1);
                ch += 0x10
                    * match b0 {
                        b'0'..=b'9' => b0 - b'0',
                        b'a'..=b'f' => 10 + (b0 - b'a'),
                        b'A'..=b'F' => 10 + (b0 - b'A'),
                        _ => panic!("unexpected non-hex character after \\x"),
                    };
                ch += match b1 {
                    b'0'..=b'9' => b1 - b'0',
                    b'a'..=b'f' => 10 + (b1 - b'a'),
                    b'A'..=b'F' => 10 + (b1 - b'A'),
                    _ => panic!("unexpected non-hex character after \\x"),
                };
                (ch, &s[2..])
            }

            fn backslash_u<S>(mut s: &S) -> (char, &S) where
                S: Index<RangeFrom<usize>, Output = S> + AsRef<[u8]> + ?Sized,
            {
                if byte(s, 0) != b'{' {
                    panic!("{}", "expected { after \\u");
                }
                s = &s[1..];

                let mut ch = 0;
                let mut digits = 0;
                loop {
                    let b = byte(s, 0);
                    let digit = match b {
                        b'0'..=b'9' => b - b'0',
                        b'a'..=b'f' => 10 + b - b'a',
                        b'A'..=b'F' => 10 + b - b'A',
                        b'_' if digits > 0 => {
                            s = &s[1..];
                            continue;
                        }
                        b'}' if digits == 0 => panic!("invalid empty unicode escape"),
                        b'}' => break,
                        _ => panic!("unexpected non-hex character after \\u"),
                    };
                    if digits == 6 {
                        panic!("overlong unicode escape (must have at most 6 hex digits)");
                    }
                    ch *= 0x10;
                    ch += u32::from(digit);
                    digits += 1;
                    s = &s[1..];
                }
                assert!(byte(s, 0) == b'}');
                s = &s[1..];

                if let Some(ch) = char::from_u32(ch) {
                    (ch, s)
                } else {
                    panic!("character code {:x} is not a valid unicode character", ch);
                }
            }

            pub fn parse_lit_int(mut s: &str) -> Option<(Box<str>, Box<str>)>
            {
                let negative = byte(s, 0) == b'-';
                if negative {
                    s = &s[1..];
                }

                let base = match (byte(s, 0), byte(s, 1)) {
                    (b'0', b'x') => {
                        s = &s[2..];
                        16
                    }
                    (b'0', b'o') => {
                        s = &s[2..];
                        8
                    }
                    (b'0', b'b') => {
                        s = &s[2..];
                        2
                    }
                    (b'0'..=b'9', _) => 10,
                    _ => return None,
                };

                let mut value = BigInt::new();
                let mut has_digit = false;
                'outer: loop {
                    let b = byte(s, 0);
                    let digit = match b {
                        b'0'..=b'9' => b - b'0',
                        b'a'..=b'f' if base > 10 => b - b'a' + 10,
                        b'A'..=b'F' if base > 10 => b - b'A' + 10,
                        b'_' => {
                            s = &s[1..];
                            continue;
                        }
                       
                       
                        b'.' if base == 10 => return None,
                        b'e' | b'E' if base == 10 => {
                            let mut has_exp = false;
                            for (i, b) in s[1..].bytes().enumerate() {
                                match b {
                                    b'_' => {}
                                    b'-' | b'+' => return None,
                                    b'0'..=b'9' => has_exp = true,
                                    _ => {
                                        let suffix = &s[1 + i..];
                                        if has_exp && ::syntax::ident::xid_ok(suffix) {
                                            return None;
                                        } else {
                                            break 'outer;
                                        }
                                    }
                                }
                            }
                            if has_exp {
                                return None;
                            } else {
                                break;
                            }
                        }
                        _ => break,
                    };

                    if digit >= base {
                        return None;
                    }

                    has_digit = true;
                    value *= base;
                    value += digit;
                    s = &s[1..];
                }

                if !has_digit {
                    return None;
                }

                let suffix = s;
                if suffix.is_empty() || ::syntax::ident::xid_ok(suffix) {
                    let mut repr = value.to_string();
                    if negative {
                        repr.insert(0, '-');
                    }
                    Some((repr.into_boxed_str(), suffix.to_owned().into_boxed_str()))
                } else {
                    None
                }
            }

            pub fn parse_lit_float(input: &str) -> Option<(Box<str>, Box<str>)> {
               
               
               

                let mut bytes = input.to_owned().into_bytes();

                let start = (*bytes.first()? == b'-') as usize;
                match bytes.get(start)? {
                    b'0'..=b'9' => {}
                    _ => return None,
                }

                let mut read = start;
                let mut write = start;
                let mut has_dot = false;
                let mut has_e = false;
                let mut has_sign = false;
                let mut has_exponent = false;
                while read < bytes.len( )
                {
                    match bytes[read] {
                        b'_' => {
                           
                            read += 1;
                            continue;
                        }
                        b'0'..=b'9' => {
                            if has_e {
                                has_exponent = true;
                            }
                            bytes[write] = bytes[read];
                        }
                        b'.' => {
                            if has_e || has_dot {
                                return None;
                            }
                            has_dot = true;
                            bytes[write] = b'.';
                        }
                        b'e' | b'E' => {
                            match bytes[read + 1..]
                                .iter()
                                .find(|b| **b != b'_')
                                .unwrap_or(&b'\0')
                            {
                                b'-' | b'+' | b'0'..=b'9' => {}
                                _ => break,
                            }
                            if has_e {
                                if has_exponent {
                                    break;
                                } else {
                                    return None;
                                }
                            }
                            has_e = true;
                            bytes[write] = b'e';
                        }
                        b'-' | b'+' => {
                            if has_sign || has_exponent || !has_e {
                                return None;
                            }
                            has_sign = true;
                            if bytes[read] == b'-' {
                                bytes[write] = bytes[read];
                            } else {
                               
                                read += 1;
                                continue;
                            }
                        }
                        _ => break,
                    }
                    read += 1;
                    write += 1;
                }

                if has_e && !has_exponent {
                    return None;
                }

                let mut digits = String::from_utf8(bytes).unwrap();
                let suffix = digits.split_off(read);
                digits.truncate(write);
                if suffix.is_empty() || ::syntax::ident::xid_ok(&suffix) {
                    Some((digits.into_boxed_str(), suffix.into_boxed_str()))
                } else {
                    None
                }
            }
        }
    } pub use self::lit::
    {
        Lit, LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitInt, LitStr, StrStyle
    };

    pub mod lookahead
    {
        use ::
        {
            cell::{ RefCell },
            process::macros::{Delimiter, Span},
            syntax::
            {
                buffer::Cursor,
                error::{self, Error},
                sealed::lookahead::Sealed,
                span::IntoSpans,
                token::{CustomToken, Token},
            },
            *,
        };
        /*
        */
        /// Support for checking the next token in a stream to decide how to parse.
        pub struct Lookahead1<'a> {
            scope: Span,
            cursor: Cursor<'a>,
            comparisons: RefCell<Vec<&'static str>>,
        }

        pub fn new(scope: Span, cursor: Cursor) -> Lookahead1 {
            Lookahead1 {
                scope,
                cursor,
                comparisons: RefCell::new(Vec::new()),
            }
        }

        fn peek_impl(
            lookahead: &Lookahead1,
            peek: fn(Cursor) -> bool,
            display: fn() -> &'static str,
        ) -> bool
        {
            if peek(lookahead.cursor) {
                return true;
            }
            lookahead.comparisons.borrow_mut().push(display());
            false
        }

        impl<'a> Lookahead1<'a> {
            /// Looks at the next token in the parse stream to determine whether it
            /// matches the requested type of token.
            pub fn peek<T: Peek>(&self, token: T) -> bool
        {
                let _ = token;
                peek_impl(self, T::Token::peek, T::Token::display)
            }
            /// Triggers an error at the current position of the parse stream.
            pub fn error(self) -> Error {
                let mut comparisons = self.comparisons.clone().into_inner();
                comparisons.retain_mut(|display| {
                    if *display == "`)`" {
                        *display = match self.cursor.scope_delimiter() {
                            Delimiter::Parenthesis => "`)`",
                            Delimiter::Brace => "`}`",
                            Delimiter::Bracket => "`]`",
                            Delimiter::None => return false,
                        }
                    }
                    true
                });
                match comparisons.len() {
                    0 => {
                        if self.cursor.eof() {
                            Error::new(self.scope, "unexpected end of input")
                        } else {
                            Error::new(self.cursor.span(), "unexpected token")
                        }
                    }
                    1 => {
                        let message = format!("expected {}", comparisons[0]);
                        error::new_at(self.scope, self.cursor, message)
                    }
                    2 => {
                        let message = format!("expected {} or {}", comparisons[0], comparisons[1]);
                        error::new_at(self.scope, self.cursor, message)
                    }
                    _ => {
                        let join = comparisons.join(", ");
                        let message = format!("expected one of: {}", join);
                        error::new_at(self.scope, self.cursor, message)
                    }
                }
            }
        }
        /// Types that can be parsed by looking at just one token.
        pub trait Peek: Sealed {
           
                type Token: Token;
        }
        /// Pseudo-token used for peeking the end of a parse stream.
        pub struct End;

        impl Copy for End {}

        impl Clone for End {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl Peek for End {
            type Token = Self;
        }

        impl CustomToken for End {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.eof()
            }

            fn display() -> &'static str {
                "`)`"
            }
        }

        impl<F: Copy + FnOnce(TokenMarker) -> T, T: Token> Peek for F {
            type Token = T;
        }

        pub enum TokenMarker {}

        impl<S> IntoSpans<S> for TokenMarker {
            fn into_spans(self) -> S {
                match self {}
            }
        }

        impl<F: Copy + FnOnce(TokenMarker) -> T, T: Token> Sealed for F {}

        impl Sealed for End {}
    }
    
    pub mod mac
    {
        use ::
        {
            process::macros::
            {
                extra::DelimSpan, Delimiter, TokenStream, TokenTree
            },
            syntax::
            {
                error::Result,
                parse::{ Parse, ParseStream, Parser },
                path::Path,
                token::{ Brace, Bracket, Paren },
            },
            *,
        };
        /*
        */
        ast_struct! 
        {
            /// A macro invocation: `println!("{}", mac)`.
            pub struct Macro {
                pub path: Path,
                pub bang_token: Token![!],
                pub delimiter: MacroDelimiter,
                pub tokens: TokenStream,
            }
        }

        ast_enum! 
        {
            /// A grouping token that surrounds a macro body: `m!(...)` or `m!{...}` or `m![...]`.
            pub enum MacroDelimiter {
                Paren(Paren),
                Brace(Brace),
                Bracket(Bracket),
            }
        }

        impl MacroDelimiter 
        {
            pub fn span(&self) -> &DelimSpan
            {
                match self {
                    MacroDelimiter::Paren(token) => &token.span,
                    MacroDelimiter::Brace(token) => &token.span,
                    MacroDelimiter::Bracket(token) => &token.span,
                }
            }
            
            pub fn is_brace(&self) -> bool
            {
                match self
                {
                    MacroDelimiter::Brace(_) => true,
                    MacroDelimiter::Paren(_) | MacroDelimiter::Bracket(_) => false,
                }
            }
        }

        impl Macro 
        {
            /// Parse the tokens within the macro invocation's delimiters into a syntax tree.
            pub fn parse_body<T: Parse>(&self) -> Result<T>
            {
                self.parse_body_with(T::parse)
            }
            /// Parse the tokens within the macro invocation's delimiters using the
            /// given parser.
            pub fn parse_body_with<F: Parser>(&self, parser: F) -> Result<F::Output>
            {
                let scope = self.delimiter.span().close();
                ::syntax::parse::parse_scoped(parser, scope, self.tokens.clone())
            }
        }
        
        pub fn parse_delimiter(input: ParseStream) -> Result<(MacroDelimiter, TokenStream)>
        {
            input.step(|cursor| {
                if let Some((TokenTree::Group(g), rest)) = cursor.token_tree() {
                    let span = g.delim_span();
                    let delimiter = match g.delimiter() {
                        Delimiter::Parenthesis => MacroDelimiter::Paren(Paren(span)),
                        Delimiter::Brace => MacroDelimiter::Brace(Brace(span)),
                        Delimiter::Bracket => MacroDelimiter::Bracket(Bracket(span)),
                        Delimiter::None => {
                            return Err(cursor.error("expected delimiter"));
                        }
                    };
                    Ok(((delimiter, g.stream()), rest))
                } else {
                    Err(cursor.error("expected delimiter"))
                }
            })
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {    
                    error::Result,
                    mac::{parse_delimiter, Macro},
                    parse::{Parse, ParseStream},
                    path::Path,
                },
                *,
            };
            
            impl Parse for Macro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let tokens;
                    Ok(Macro {
                        path: input.call(Path::parse_mod_style)?,
                        bang_token: input.parse()?,
                        delimiter: {
                            let (delimiter, content) = parse_delimiter(input)?;
                            tokens = content;
                            delimiter
                        },
                        tokens,
                    })
                }
            }
        }

        mod printing
        {
            use ::
            {
                process::macros::{ Delimiter, TokenStream },
                quote::{ ToTokens },
                syntax::
                {
                    mac::{Macro, MacroDelimiter},
                    path,
                    path::printing::PathStyle,
                    token,
                },
                *,
            };
            
            impl MacroDelimiter {
                pub fn surround(&self, tokens: &mut TokenStream, inner: TokenStream) {
                    let (delim, span) = match self {
                        MacroDelimiter::Paren(paren) => (Delimiter::Parenthesis, paren.span),
                        MacroDelimiter::Brace(brace) => (Delimiter::Brace, brace.span),
                        MacroDelimiter::Bracket(bracket) => (Delimiter::Bracket, bracket.span),
                    };
                    token::printing::delim(delim, span.join(), tokens, inner);
                }
            }

            impl ToTokens for Macro {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    path::printing::print_path(tokens, &self.path, PathStyle::Mod);
                    self.bang_token.to_tokens(tokens);
                    self.delimiter.surround(tokens, self.tokens.clone());
                }
            }
        }
    } pub use self::mac::{Macro, MacroDelimiter};
    
    pub mod meta
    {
        //! Facility for interpreting structured content inside of an `Attribute`.
        use ::
        {
            fmt::{ Display },
            process::macros::{ Ident },
            syntax::
            {
                error::{Error, Result},
                ext::IdentExt as _,
                lit::Lit,
                parse::{ParseStream, Parser},
                path::{Path, PathSegment},
                punctuated::Punctuated,
            },
            *,
        };
        /*
        */
        /// Make a parser that is usable with `parse_macro_input!` in a `#[proc_macro_attribute]` macro.
        pub fn parser(logic: impl FnMut(ParseNestedMeta) -> Result<()>) -> impl Parser<Output = ()> {
            |input: ParseStream| {
                if input.is_empty() {
                    Ok(())
                } else {
                    parse_nested_meta(input, logic)
                }
            }
        }
        /// Context for parsing a single property in the conventional syntax for structured attributes.
        #[non_exhaustive]
        pub struct ParseNestedMeta<'a>
        {
            pub path: Path,
            pub input: ParseStream<'a>,
        }

        impl<'a> ParseNestedMeta<'a> {
            /// Used when parsing `key = "value"` syntax.
            pub fn value(&self) -> Result<ParseStream<'a>>
            {
                self.input.parse::<Token![=]>()?;
                Ok(self.input)
            }
            /// Used when parsing `list(...)` syntax **if** the content inside the
            /// nested parentheses is also expected to conform to Rust's structured
            /// attribute convention.
            pub fn parse_nested_meta(
                &self,
                logic: impl FnMut(ParseNestedMeta) -> Result<()>,
            ) -> Result<()>
            {
                let content;
                parenthesized!(content in self.input);
                parse_nested_meta(&content, logic)
            }
            /// Report that the attribute's content did not conform to expectations.
            pub fn error(&self, msg: impl Display) -> Error {
                let start_span = self.path.segments[0].ident.span();
                let end_span = self.input.cursor().prev_span();
                ::syntax::error::new2(start_span, end_span, msg)
            }
        }

        pub fn parse_nested_meta(
            input: ParseStream,
            mut logic: impl FnMut(ParseNestedMeta) -> Result<()>,
        ) -> Result<()> {
            loop {
                let path = input.call(parse_meta_path)?;
                logic(ParseNestedMeta { path, input })?;
                if input.is_empty() {
                    return Ok(());
                }
                input.parse::<Token![,]>()?;
                if input.is_empty() {
                    return Ok(());
                }
            }
        }
        
        fn parse_meta_path(input: ParseStream) -> Result<Path> {
            Ok(Path {
                leading_colon: input.parse()?,
                segments: {
                    let mut segments = Punctuated::new();
                    if input.peek(Ident::peek_any) {
                        let ident = Ident::parse_any(input)?;
                        segments.push_value(PathSegment::from(ident));
                    } else if input.is_empty() {
                        return Err(input.error("expected nested attribute"));
                    } else if input.peek(Lit) {
                        return Err(input.error("unexpected literal in nested attribute, expected ident"));
                    } else {
                        return Err(input.error("unexpected token in nested attribute, expected ident"));
                    }
                    while input.peek(Token![::]) {
                        let punct = input.parse()?;
                        segments.push_punct(punct);
                        let ident = Ident::parse_any(input)?;
                        segments.push_value(PathSegment::from(ident));
                    }
                    segments
                },
            })
        }
    }
    
    pub mod op
    {
        use ::
        {
            *,
        };
        /*
        */
        ast_enum!
        {
            /// A binary operator: `+`, `+=`, `&`.
            #[non_exhaustive]
            pub enum BinOp {
                /// The `+` operator (addition)
                Add(Token![+]),
                /// The `-` operator (subtraction)
                Sub(Token![-]),
                /// The `*` operator (multiplication)
                Mul(Token![*]),
                /// The `/` operator (division)
                Div(Token![/]),
                /// The `%` operator (modulus)
                Rem(Token![%]),
                /// The `&&` operator (logical and)
                And(Token![&&]),
                /// The `||` operator (logical or)
                Or(Token![||]),
                /// The `^` operator (bitwise xor)
                BitXor(Token![^]),
                /// The `&` operator (bitwise and)
                BitAnd(Token![&]),
                /// The `|` operator (bitwise or)
                BitOr(Token![|]),
                /// The `<<` operator (shift left)
                Shl(Token![<<]),
                /// The `>>` operator (shift right)
                Shr(Token![>>]),
                /// The `==` operator (equality)
                Eq(Token![==]),
                /// The `<` operator (less than)
                Lt(Token![<]),
                /// The `<=` operator (less than or equal to)
                Le(Token![<=]),
                /// The `!=` operator (not equal to)
                Ne(Token![!=]),
                /// The `>=` operator (greater than or equal to)
                Ge(Token![>=]),
                /// The `>` operator (greater than)
                Gt(Token![>]),
                /// The `+=` operator
                AddAssign(Token![+=]),
                /// The `-=` operator
                SubAssign(Token![-=]),
                /// The `*=` operator
                MulAssign(Token![*=]),
                /// The `/=` operator
                DivAssign(Token![/=]),
                /// The `%=` operator
                RemAssign(Token![%=]),
                /// The `^=` operator
                BitXorAssign(Token![^=]),
                /// The `&=` operator
                BitAndAssign(Token![&=]),
                /// The `|=` operator
                BitOrAssign(Token![|=]),
                /// The `<<=` operator
                ShlAssign(Token![<<=]),
                /// The `>>=` operator
                ShrAssign(Token![>>=]),
            }
        }

        ast_enum!
        {
            /// A unary operator: `*`, `!`, `-`.
            #[non_exhaustive]
            pub enum UnOp {
                /// The `*` operator for dereferencing
                Deref(Token![*]),
                /// The `!` operator for logical inversion
                Not(Token![!]),
                /// The `-` operator for negation
                Neg(Token![-]),
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    error::Result,
                    op::{BinOp, UnOp},
                    parse::{Parse, ParseStream},
                },
                *
            };
            
            impl Parse for BinOp
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![+=]) {
                        input.parse().map(BinOp::AddAssign)
                    } else if input.peek(Token![-=]) {
                        input.parse().map(BinOp::SubAssign)
                    } else if input.peek(Token![*=]) {
                        input.parse().map(BinOp::MulAssign)
                    } else if input.peek(Token![/=]) {
                        input.parse().map(BinOp::DivAssign)
                    } else if input.peek(Token![%=]) {
                        input.parse().map(BinOp::RemAssign)
                    } else if input.peek(Token![^=]) {
                        input.parse().map(BinOp::BitXorAssign)
                    } else if input.peek(Token![&=]) {
                        input.parse().map(BinOp::BitAndAssign)
                    } else if input.peek(Token![|=]) {
                        input.parse().map(BinOp::BitOrAssign)
                    } else if input.peek(Token![<<=]) {
                        input.parse().map(BinOp::ShlAssign)
                    } else if input.peek(Token![>>=]) {
                        input.parse().map(BinOp::ShrAssign)
                    } else if input.peek(Token![&&]) {
                        input.parse().map(BinOp::And)
                    } else if input.peek(Token![||]) {
                        input.parse().map(BinOp::Or)
                    } else if input.peek(Token![<<]) {
                        input.parse().map(BinOp::Shl)
                    } else if input.peek(Token![>>]) {
                        input.parse().map(BinOp::Shr)
                    } else if input.peek(Token![==]) {
                        input.parse().map(BinOp::Eq)
                    } else if input.peek(Token![<=]) {
                        input.parse().map(BinOp::Le)
                    } else if input.peek(Token![!=]) {
                        input.parse().map(BinOp::Ne)
                    } else if input.peek(Token![>=]) {
                        input.parse().map(BinOp::Ge)
                    } else if input.peek(Token![+]) {
                        input.parse().map(BinOp::Add)
                    } else if input.peek(Token![-]) {
                        input.parse().map(BinOp::Sub)
                    } else if input.peek(Token![*]) {
                        input.parse().map(BinOp::Mul)
                    } else if input.peek(Token![/]) {
                        input.parse().map(BinOp::Div)
                    } else if input.peek(Token![%]) {
                        input.parse().map(BinOp::Rem)
                    } else if input.peek(Token![^]) {
                        input.parse().map(BinOp::BitXor)
                    } else if input.peek(Token![&]) {
                        input.parse().map(BinOp::BitAnd)
                    } else if input.peek(Token![|]) {
                        input.parse().map(BinOp::BitOr)
                    } else if input.peek(Token![<]) {
                        input.parse().map(BinOp::Lt)
                    } else if input.peek(Token![>]) {
                        input.parse().map(BinOp::Gt)
                    } else {
                        Err(input.error("expected binary operator"))
                    }
                }
            }

            impl Parse for UnOp
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    if lookahead.peek(Token![*]) {
                        input.parse().map(UnOp::Deref)
                    } else if lookahead.peek(Token![!]) {
                        input.parse().map(UnOp::Not)
                    } else if lookahead.peek(Token![-]) {
                        input.parse().map(UnOp::Neg)
                    } else {
                        Err(lookahead.error())
                    }
                }
            }
        }
        
        pub mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::ToTokens,
                syntax::op::{BinOp, UnOp},
                *,
            };
            
            impl ToTokens for BinOp
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        BinOp::Add(t) => t.to_tokens(tokens),
                        BinOp::Sub(t) => t.to_tokens(tokens),
                        BinOp::Mul(t) => t.to_tokens(tokens),
                        BinOp::Div(t) => t.to_tokens(tokens),
                        BinOp::Rem(t) => t.to_tokens(tokens),
                        BinOp::And(t) => t.to_tokens(tokens),
                        BinOp::Or(t) => t.to_tokens(tokens),
                        BinOp::BitXor(t) => t.to_tokens(tokens),
                        BinOp::BitAnd(t) => t.to_tokens(tokens),
                        BinOp::BitOr(t) => t.to_tokens(tokens),
                        BinOp::Shl(t) => t.to_tokens(tokens),
                        BinOp::Shr(t) => t.to_tokens(tokens),
                        BinOp::Eq(t) => t.to_tokens(tokens),
                        BinOp::Lt(t) => t.to_tokens(tokens),
                        BinOp::Le(t) => t.to_tokens(tokens),
                        BinOp::Ne(t) => t.to_tokens(tokens),
                        BinOp::Ge(t) => t.to_tokens(tokens),
                        BinOp::Gt(t) => t.to_tokens(tokens),
                        BinOp::AddAssign(t) => t.to_tokens(tokens),
                        BinOp::SubAssign(t) => t.to_tokens(tokens),
                        BinOp::MulAssign(t) => t.to_tokens(tokens),
                        BinOp::DivAssign(t) => t.to_tokens(tokens),
                        BinOp::RemAssign(t) => t.to_tokens(tokens),
                        BinOp::BitXorAssign(t) => t.to_tokens(tokens),
                        BinOp::BitAndAssign(t) => t.to_tokens(tokens),
                        BinOp::BitOrAssign(t) => t.to_tokens(tokens),
                        BinOp::ShlAssign(t) => t.to_tokens(tokens),
                        BinOp::ShrAssign(t) => t.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for UnOp
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        UnOp::Deref(t) => t.to_tokens(tokens),
                        UnOp::Not(t) => t.to_tokens(tokens),
                        UnOp::Neg(t) => t.to_tokens(tokens),
                    }
                }
            }
        }
    } pub use self::op::{BinOp, UnOp};
    
    pub mod parse
    {
        //! Parsing interface for parsing a token stream into a syntax tree node.
        use ::
        {
            cell::{ Cell },
            fmt::{ self, Debug, Display },
            hash::{ Hash, Hasher },
            marker::{ PhantomData },
            ops::{ Deref },
            panic::{ RefUnwindSafe, UnwindSafe },
            process::macros::{ Delimiter, Group, Literal, Punct, Span, TokenStream, TokenTree },
            quote::{ ToTokens },
            rc::{ Rc },
            str::{ FromStr },
            syntax::
            {
                buffer::{ Cursor, TokenBuffer },
                error,
                lookahead,
                punctuated::Punctuated,
                token::Token,
            },
            *,
        };
        /*
        */
        pub use ::syntax::
        {
            error::{ Error, Result },
            lookahead::{ End, Lookahead1, Peek },
        };

        pub mod discouraged
        {
            //! Extensions to the parsing API with niche applicability.
            use ::
            {
                cell::{ Cell },
                process::macros::
                {
                    extra::DelimSpan, Delimiter,
                },
                rc::{ Rc },
                syntax::
                {
                    buffer::Cursor,
                    error::Result,
                    parse::{inner_unexpected, ParseBuffer, Unexpected},
                },
                *,
            };
            /*
            */
            /// Extensions to the `ParseStream` API to support speculative parsing.
            pub trait Speculative {
                /// Advance this parse stream to the position of a forked parse stream.
                fn advance_to(&self, fork: &Self);
            }

            impl<'a> Speculative for ParseBuffer<'a> {
                fn advance_to(&self, fork: &Self) {
                    if !::syntax::buffer::same_scope(self.cursor(), fork.cursor()) {
                        panic!("fork was not derived from the advancing parse stream");
                    }

                    let (self_unexp, self_sp) = inner_unexpected(self);
                    let (fork_unexp, fork_sp) = inner_unexpected(fork);
                    if !Rc::ptr_eq(&self_unexp, &fork_unexp) {
                        match (fork_sp, self_sp) {
                           
                            (Some((span, delimiter)), None) => {
                                self_unexp.set(Unexpected::Some(span, delimiter));
                            }
                           
                            (None, None) => {
                                fork_unexp.set(Unexpected::Chain(self_unexp));

                               
                               
                               
                               
                                fork.unexpected
                                    .set(Some(Rc::new(Cell::new(Unexpected::None))));
                            }
                           
                            (_, Some(_)) => {}
                        }
                    }

                   
                    self.cell
                        .set(unsafe { mem::transmute::<Cursor, Cursor<'static>>(fork.cursor()) });
                }
            }
            /// Extensions to the `ParseStream` API to support manipulating invisible
            /// delimiters the same as if they were visible.
            pub trait AnyDelimiter {
                /// Returns the delimiter, the span of the delimiter token, and the nested
                /// contents for further parsing.
                fn parse_any_delimiter(&self) -> Result<(Delimiter, DelimSpan, ParseBuffer)>;
            }

            impl<'a> AnyDelimiter for ParseBuffer<'a>
            {
                fn parse_any_delimiter(&self) -> Result<(Delimiter, DelimSpan, ParseBuffer)> {
                    self.step(|cursor| {
                        if let Some((content, delimiter, span, rest)) = cursor.any_group() {
                            let scope = span.close();
                            let nested = ::syntax::parse::advance_step_cursor(cursor, content);
                            let unexpected = ::syntax::parse::get_unexpected(self);
                            let content = ::syntax::parse::new_parse_buffer(scope, nested, unexpected);
                            Ok(((delimiter, span, content), rest))
                        } else {
                            Err(cursor.error("expected any delimiter"))
                        }
                    })
                }
            }
        }
        /// Parsing interface implemented by all types that can be parsed in a default
        /// way from a token stream.
        pub trait Parse: Sized {
            fn parse(input: ParseStream) -> Result<Self>;
        }
        /// Input to a Syn parser function.
        pub type ParseStream<'a> = &'a ParseBuffer<'a>;

        /// Cursor position within a buffered token stream.
        pub struct ParseBuffer<'a> {
            scope: Span,
           
            cell: Cell<Cursor<'static>>,
            marker: PhantomData<Cursor<'a>>,
            unexpected: Cell<Option<Rc<Cell<Unexpected>>>>,
        }

        impl<'a> Drop for ParseBuffer<'a> {
            fn drop(&mut self) {
                if let Some((unexpected_span, delimiter)) = span_of_unexpected_ignoring_nones(self.cursor())
                {
                    let (inner, old_span) = inner_unexpected(self);
                    if old_span.is_none() {
                        inner.set(Unexpected::Some(unexpected_span, delimiter));
                    }
                }
            }
        }

        impl<'a> Display for ParseBuffer<'a> {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.cursor().token_stream(), f)
            }
        }

        impl<'a> Debug for ParseBuffer<'a> {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.cursor().token_stream(), f)
            }
        }

        impl<'a> UnwindSafe for ParseBuffer<'a> {}
        impl<'a> RefUnwindSafe for ParseBuffer<'a> {}
        /// Cursor state associated with speculative parsing.
        pub struct StepCursor<'c, 'a> 
        {
            scope: Span,
           
            cursor: Cursor<'c>,
           
           
           
           
            //
           
           
           
            marker: PhantomData<fn(Cursor<'c>) -> Cursor<'a>>,
        }

        impl<'c, 'a> Deref for StepCursor<'c, 'a> 
        {
            type Target = Cursor<'c>;

            fn deref(&self) -> &Self::Target {
                &self.cursor
            }
        }

        impl<'c, 'a> Copy for StepCursor<'c, 'a> {}

        impl<'c, 'a> Clone for StepCursor<'c, 'a> 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl<'c, 'a> StepCursor<'c, 'a> 
        {
            /// Triggers an error at the current position of the parse stream.
            pub fn error<T: Display>(self, message: T) -> Error {
                error::new_at(self.scope, self.cursor, message)
            }
        }

        pub fn advance_step_cursor<'c, 'a>(proof: StepCursor<'c, 'a>, to: Cursor<'c>) -> Cursor<'a> 
        {
           
           
           
           
            let _ = proof;
            unsafe { mem::transmute::<Cursor<'c>, Cursor<'a>>(to) }
        }

        pub fn new_parse_buffer(
            scope: Span,
            cursor: Cursor,
            unexpected: Rc<Cell<Unexpected>>,
        ) -> ParseBuffer 
        {
            ParseBuffer {
                scope,
               
                cell: Cell::new(unsafe { mem::transmute::<Cursor, Cursor<'static>>(cursor) }),
                marker: PhantomData,
                unexpected: Cell::new(Some(unexpected)),
            }
        }

        pub enum Unexpected 
        {
            None,
            Some(Span, Delimiter),
            Chain(Rc<Cell<Unexpected>>),
        }

        impl Default for Unexpected 
        {
            fn default() -> Self {
                Unexpected::None
            }
        }

        impl Clone for Unexpected 
        {
            fn clone(&self) -> Self {
                match self {
                    Unexpected::None => Unexpected::None,
                    Unexpected::Some(span, delimiter) => Unexpected::Some(*span, *delimiter),
                    Unexpected::Chain(next) => Unexpected::Chain(next.clone()),
                }
            }
        }

        fn cell_clone<T: Default + Clone>(cell: &Cell<T>) -> T 
        {
            let prev = cell.take();
            let ret = prev.clone();
            cell.set(prev);
            ret
        }

        fn inner_unexpected(buffer: &ParseBuffer) -> (Rc<Cell<Unexpected>>, Option<(Span, Delimiter)>) 
        {
            let mut unexpected = get_unexpected(buffer);
            loop {
                match cell_clone(&unexpected) {
                    Unexpected::None => return (unexpected, None),
                    Unexpected::Some(span, delimiter) => return (unexpected, Some((span, delimiter))),
                    Unexpected::Chain(next) => unexpected = next,
                }
            }
        }

        pub fn get_unexpected(buffer: &ParseBuffer) -> Rc<Cell<Unexpected>> 
        {
            cell_clone(&buffer.unexpected).unwrap()
        }

        fn span_of_unexpected_ignoring_nones(mut cursor: Cursor) -> Option<(Span, Delimiter)> 
        {
            if cursor.eof() {
                return None;
            }
            while let Some((inner, _span, rest)) = cursor.group(Delimiter::None) {
                if let Some(unexpected) = span_of_unexpected_ignoring_nones(inner) {
                    return Some(unexpected);
                }
                cursor = rest;
            }
            if cursor.eof() {
                None
            } else {
                Some((cursor.span(), cursor.scope_delimiter()))
            }
        }

        impl<'a> ParseBuffer<'a> 
        {
            /// Parses a syntax tree node of type `T`, advancing the position of our
            /// parse stream past it.
            pub fn parse<T: Parse>(&self) -> Result<T> {
                T::parse(self)
            }
            /// Calls the given parser function to parse a syntax tree node of type `T`
            /// from this stream.
            pub fn call<T>(&'a self, function: fn(ParseStream<'a>) -> Result<T>) -> Result<T> {
                function(self)
            }
            /// Looks at the next token in the parse stream to determine whether it
            /// matches the requested type of token.
            pub fn peek<T: Peek>(&self, token: T) -> bool
        {
                let _ = token;
                T::Token::peek(self.cursor())
            }
            /// Looks at the second-next token in the parse stream.
            pub fn peek2<T: Peek>(&self, token: T) -> bool
        {
                fn peek2(buffer: &ParseBuffer, peek: fn(Cursor) -> bool) -> bool
        {
                    buffer.cursor().skip().map_or(false, peek)
                }

                let _ = token;
                peek2(self, T::Token::peek)
            }
            /// Looks at the third-next token in the parse stream.
            pub fn peek3<T: Peek>(&self, token: T) -> bool
        {
                fn peek3(buffer: &ParseBuffer, peek: fn(Cursor) -> bool) -> bool
        {
                    buffer
                        .cursor()
                        .skip()
                        .and_then(Cursor::skip)
                        .map_or(false, peek)
                }

                let _ = token;
                peek3(self, T::Token::peek)
            }
            /// Parses zero or more occurrences of `T` separated by punctuation of type
            /// `P`, with optional trailing punctuation.
            pub fn parse_terminated<T, P>(
                &'a self,
                parser: fn(ParseStream<'a>) -> Result<T>,
                separator: P,
            ) -> Result<Punctuated<T, P::Token>> where
                P: Peek,
                P::Token: Parse,
            {
                let _ = separator;
                Punctuated::parse_terminated_with(self, parser)
            }
            /// Returns whether there are no more tokens remaining to be parsed from
            /// this stream.
            pub fn is_empty(&self) -> bool
            {
                self.cursor().eof()
            }
            /// Constructs a helper for peeking at the next token in this stream and
            /// building an error message if it is not one of a set of expected tokens.
            pub fn lookahead1(&self) -> Lookahead1<'a> {
                lookahead::new(self.scope, self.cursor())
            }
            /// Forks a parse stream so that parsing tokens out of either the original
            /// or the fork does not advance the position of the other.
            pub fn fork(&self) -> Self {
                ParseBuffer {
                    scope: self.scope,
                    cell: self.cell.clone(),
                    marker: PhantomData,
                   
                   
                    unexpected: Cell::new(Some(Rc::new(Cell::new(Unexpected::None)))),
                }
            }
            /// Triggers an error at the current position of the parse stream.
            pub fn error<T: Display>(&self, message: T) -> Error {
                error::new_at(self.scope, self.cursor(), message)
            }
            /// Speculatively parses tokens from this parse stream, advancing the position of this stream only if parsing succeeds.
            pub fn step<F, R>(&self, function: F) -> Result<R> where
                F: for<'c> FnOnce(StepCursor<'c, 'a>) -> Result<(R, Cursor<'c>)>,
            {
               
               
               
                //
               
               
               
               
               
               
               
                //
               
               
               
               
               
                let (node, rest) = function(StepCursor {
                    scope: self.scope,
                    cursor: self.cell.get(),
                    marker: PhantomData,
                })?;
                self.cell.set(rest);
                Ok(node)
            }
            /// Returns the `Span` of the next token in the parse stream, or
            /// `Span::call_site()` if this parse stream has completely exhausted its
            /// input `TokenStream`.
            pub fn span(&self) -> Span {
                let cursor = self.cursor();
                if cursor.eof() {
                    self.scope
                } else {
                    ::syntax::buffer::open_span_of_group(cursor)
                }
            }
            /// Provides low-level access to the token representation underlying this parse stream.
            pub fn cursor(&self) -> Cursor<'a>
            {
                self.cell.get()
            }

            fn check_unexpected(&self) -> Result<()>
            {
                match inner_unexpected(self).1 {
                    Some((span, delimiter)) => Err(err_unexpected_token(span, delimiter)),
                    None => Ok(()),
                }
            }
        }

        impl<T: Parse> Parse for Box<T> 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.parse().map(Box::new)
            }
        }

        impl<T: Parse + Token> Parse for Option<T> 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                if T::peek(input.cursor()) {
                    Ok(Some(input.parse()?))
                } else {
                    Ok(None)
                }
            }
        }

        impl Parse for TokenStream 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| Ok((cursor.token_stream(), Cursor::empty())))
            }
        }

        impl Parse for TokenTree 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| match cursor.token_tree() {
                    Some((tt, rest)) => Ok((tt, rest)),
                    None => Err(cursor.error("expected token tree")),
                })
            }
        }

        impl Parse for Group 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| {
                    if let Some((group, rest)) = cursor.any_group_token() {
                        if group.delimiter() != Delimiter::None {
                            return Ok((group, rest));
                        }
                    }
                    Err(cursor.error("expected group token"))
                })
            }
        }

        impl Parse for Punct 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| match cursor.punct() {
                    Some((punct, rest)) => Ok((punct, rest)),
                    None => Err(cursor.error("expected punctuation token")),
                })
            }
        }

        impl Parse for Literal 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| match cursor.literal() {
                    Some((literal, rest)) => Ok((literal, rest)),
                    None => Err(cursor.error("expected literal token")),
                })
            }
        }
        /// Parser that can parse Rust tokens into a particular syntax tree node.
        pub trait Parser:Sized 
        {
            type Output;

            /// Parse a proc-macro2 token stream into the chosen syntax tree node.
            fn parse2(self, tokens: TokenStream) -> Result<Self::Output>;

            /// Parse tokens of source code into the chosen syntax tree node.
            fn parse(self, tokens: proc_macro::TokenStream) -> Result<Self::Output>
            {
                self.parse2(process::macros::TokenStream::from(tokens))
            }
            /// Parse a string of Rust code into the chosen syntax tree node.
            fn parse_str(self, s: &str) -> Result<Self::Output>
            {
                self.parse2(process::macros::TokenStream::from_str(s)?)
            }

           
                fn __parse_scoped(self, scope: Span, tokens: TokenStream) -> Result<Self::Output>
            {
                let _ = scope;
                self.parse2(tokens)
            }
        }

        fn tokens_to_parse_buffer(tokens: &TokenBuffer) -> ParseBuffer 
        {
            let scope = Span::call_site();
            let cursor = tokens.begin();
            let unexpected = Rc::new(Cell::new(Unexpected::None));
            new_parse_buffer(scope, cursor, unexpected)
        }

        impl<F, T> Parser for F
        where
            F: FnOnce(ParseStream) -> Result<T>,
        {
            type Output = T;

            fn parse2(self, tokens: TokenStream) -> Result<T>
            {
                let buf = TokenBuffer::new2(tokens);
                let state = tokens_to_parse_buffer(&buf);
                let node = self(&state)?;
                state.check_unexpected()?;
                if let Some((unexpected_span, delimiter)) =
                    span_of_unexpected_ignoring_nones(state.cursor())
                {
                    Err(err_unexpected_token(unexpected_span, delimiter))
                } else {
                    Ok(node)
                }
            }

            fn __parse_scoped(self, scope: Span, tokens: TokenStream) -> Result<Self::Output>
            {
                let buf = TokenBuffer::new2(tokens);
                let cursor = buf.begin();
                let unexpected = Rc::new(Cell::new(Unexpected::None));
                let state = new_parse_buffer(scope, cursor, unexpected);
                let node = self(&state)?;
                state.check_unexpected()?;
                if let Some((unexpected_span, delimiter)) =
                    span_of_unexpected_ignoring_nones(state.cursor())
                {
                    Err(err_unexpected_token(unexpected_span, delimiter))
                } else {
                    Ok(node)
                }
            }
        }

        pub fn parse_scoped<F: Parser>(f: F, scope: Span, tokens: TokenStream) -> Result<F::Output> 
        {
            f.__parse_scoped(scope, tokens)
        }

        fn err_unexpected_token(span: Span, delimiter: Delimiter) -> Error 
        {
            let msg = match delimiter {
                Delimiter::Parenthesis => "unexpected token, expected `)`",
                Delimiter::Brace => "unexpected token, expected `}`",
                Delimiter::Bracket => "unexpected token, expected `]`",
                Delimiter::None => "unexpected token",
            };
            Error::new(span, msg)
        }
        /// An empty syntax tree node that consumes no tokens when parsed.
        pub struct Nothing;

        impl Parse for Nothing 
        {
            fn parse(_input: ParseStream) -> Result<Self>
            {
                Ok
                (Nothing)
            }
        }
        
        impl ToTokens for Nothing
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                let _ = tokens;
            }
        }

        impl Clone for Nothing 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl Copy for Nothing {}

        impl Debug for Nothing 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_str("Nothing")
            }
        }

        impl Eq for Nothing {}

        impl PartialEq for Nothing 
        {
            fn eq(&self, _other: &Self) -> bool
        {
                true
            }
        }

        impl Hash for Nothing 
        {
            fn hash<H: Hasher>(&self, _state: &mut H) {}
        }
    } 
    
    pub mod parse_quote
    {
        /// type inference to figure out a return type for those tokens.
        use ::
        {
            process::macros::{ TokenStream },
            syntax::
            {
                error::Result,
                parse::{Parse, ParseStream, Parser},
                punctuated::Punctuated,
                Arm, Block, Pat, Stmt, attr, Attribute, Field, FieldMutability, Ident, Type, Visibility,
            },
            *,
        };
        /*
        Can parse any type that implements Parse. */       
        #[track_caller] pub fn parse<T: ParseQuote>(token_stream: TokenStream) -> T
        {
            let parser = T::parse;
            match parser.parse2(token_stream) {
                Ok(t) => t,
                Err(err) => panic!("{}", err),
            }
        }

        pub trait ParseQuote: Sized 
        {
            fn parse(input: ParseStream) -> Result<Self>;
        }

        impl<T: Parse> ParseQuote for T 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                <T as Parse>::parse(input)
            }
        }
        
        impl ParseQuote for Attribute 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                if input.peek(Token![#]) && input.peek2(Token![!]) {
                    attr::parsing::single_parse_inner(input)
                } else {
                    attr::parsing::single_parse_outer(input)
                }
            }
        }

        impl ParseQuote for Vec<Attribute> 
        {
            fn parse(input: ParseStream) -> Result<Self>
            {
                let mut attrs = Vec::new();
                while !input.is_empty() {
                    attrs.push(ParseQuote::parse(input)?);
                }
                Ok(attrs)
            }
        }

        impl ParseQuote for Field 
        {
            fn parse(input: ParseStream) -> Result<Self>
            {
                let attrs = input.call(Attribute::parse_outer)?;
                let vis: Visibility = input.parse()?;

                let ident: Option<Ident>;
                let colon_token: Option<Token![:]>;
                let is_named = input.peek(Ident) && input.peek2(Token![:]) && !input.peek2(Token![::]);
                if is_named {
                    ident = Some(input.parse()?);
                    colon_token = Some(input.parse()?);
                } else {
                    ident = None;
                    colon_token = None;
                }

                let ty: Type = input.parse()?;

                Ok(Field {
                    attrs,
                    vis,
                    mutability: FieldMutability::None,
                    ident,
                    colon_token,
                    ty,
                })
            }
        }

        impl ParseQuote for Pat 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                Pat::parse_multi_with_leading_vert(input)
            }
        }

        impl ParseQuote for Box<Pat> 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                <Pat as ParseQuote>::parse(input).map(Box::new)
            }
        }

        impl<T: Parse, P: Parse> ParseQuote for Punctuated<T, P> 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                Self::parse_terminated(input)
            }
        }

        impl ParseQuote for Vec<Stmt> 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                Block::parse_within(input)
            }
        }

        impl ParseQuote for Vec<Arm> 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                Arm::parse_multiple(input)
            }
        }
    }
    
    pub mod pat
    {
        use ::
        {
            process::macros::TokenStream,
            syntax::
            {
                attr::{ Attribute },
                expr::{ Member },
                ident::{ Ident },
                path::{ Path, QSelf },
                punctuated::{ Punctuated },
                ty::{ Type },
                token,
            },
            *,
        };
        
        pub use ::syntax::expr::
        {
            ExprConst as PatConst, 
            ExprLit as PatLit, 
            ExprMacro as PatMacro, 
            ExprPath as PatPath, 
            ExprRange as PatRange,
        };
        /*
        */
        ast_enum_of_structs!
        {
            /// A pattern in a local binding, function signature, match expression, or
            /// various other places.
            #[non_exhaustive]
            pub enum Pat {
                /// A const block: `const { ... }`.
                Const(PatConst),
                /// A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.
                Ident(PatIdent),
                /// A literal pattern: `0`.
                Lit(PatLit),
                /// A macro in pattern position.
                Macro(PatMacro),
                /// A pattern that matches any one of a set of cases.
                Or(PatOr),
                /// A parenthesized pattern: `(A | B)`.
                Paren(PatParen),
                /// A path pattern like `Color::Red`, optionally qualified with a
                /// self-type.
                /// `<A>::B::C` and `<A as Trait>::B::C` can only legally refer to
                /// associated constants.
                Path(PatPath),
                /// A range pattern: `1..=2`.
                Range(PatRange),
                /// A reference pattern: `&mut var`.
                Reference(PatReference),
                /// The dots in a tuple or slice pattern: `[0, 1, ..]`.
                Rest(PatRest),
                /// A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.
                Slice(PatSlice),
                /// A struct or struct variant pattern: `Variant { x, y, .. }`.
                Struct(PatStruct),
                /// A tuple pattern: `(a, b)`.
                Tuple(PatTuple),
                /// A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.
                TupleStruct(PatTupleStruct),
                /// A type ascription pattern: `foo: f64`.
                Type(PatType),
                /// Tokens in pattern position not interpreted by Syn.
                Verbatim(TokenStream),
                /// A pattern that matches any value: `_`.
                Wild(PatWild),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct!
        {
            /// A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.
            pub struct PatIdent {
                pub attrs: Vec<Attribute>,
                pub by_ref: Option<Token![ref]>,
                pub mutability: Option<Token![mut]>,
                pub ident: Ident,
                pub subpat: Option<(Token![@], Box<Pat>)>,
            }
        }

        ast_struct! 
        {
            /// A pattern that matches any one of a set of cases.
            pub struct PatOr {
                pub attrs: Vec<Attribute>,
                pub leading_vert: Option<Token![|]>,
                pub cases: Punctuated<Pat, Token![|]>,
            }
        }

        ast_struct! 
        {
            /// A parenthesized pattern: `(A | B)`.
            pub struct PatParen {
                pub attrs: Vec<Attribute>,
                pub paren_token: token::Paren,
                pub pat: Box<Pat>,
            }
        }

        ast_struct! 
        {
            /// A reference pattern: `&mut var`.
            pub struct PatReference {
                pub attrs: Vec<Attribute>,
                pub and_token: Token![&],
                pub mutability: Option<Token![mut]>,
                pub pat: Box<Pat>,
            }
        }

        ast_struct! 
        {
            /// The dots in a tuple or slice pattern: `[0, 1, ..]`.
            pub struct PatRest {
                pub attrs: Vec<Attribute>,
                pub dot2_token: Token![..],
            }
        }

        ast_struct! 
        {
            /// A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.
            pub struct PatSlice {
                pub attrs: Vec<Attribute>,
                pub bracket_token: token::Bracket,
                pub elems: Punctuated<Pat, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A struct or struct variant pattern: `Variant { x, y, .. }`.
            pub struct PatStruct {
                pub attrs: Vec<Attribute>,
                pub qself: Option<QSelf>,
                pub path: Path,
                pub brace_token: token::Brace,
                pub fields: Punctuated<FieldPat, Token![,]>,
                pub rest: Option<PatRest>,
            }
        }

        ast_struct! 
        {
            /// A tuple pattern: `(a, b)`.
            pub struct PatTuple {
                pub attrs: Vec<Attribute>,
                pub paren_token: token::Paren,
                pub elems: Punctuated<Pat, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.
            pub struct PatTupleStruct {
                pub attrs: Vec<Attribute>,
                pub qself: Option<QSelf>,
                pub path: Path,
                pub paren_token: token::Paren,
                pub elems: Punctuated<Pat, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A type ascription pattern: `foo: f64`.
            pub struct PatType {
                pub attrs: Vec<Attribute>,
                pub pat: Box<Pat>,
                pub colon_token: Token![:],
                pub ty: Box<Type>,
            }
        }

        ast_struct! 
        {
            /// A pattern that matches any value: `_`.
            pub struct PatWild {
                pub attrs: Vec<Attribute>,
                pub underscore_token: Token![_],
            }
        }

        ast_struct! 
        {
            /// A single field in a struct pattern.
            pub struct FieldPat {
                pub attrs: Vec<Attribute>,
                pub member: Member,
                pub colon_token: Option<Token![:]>,
                pub pat: Box<Pat>,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::TokenStream,
                syntax::
                {
                    attr::Attribute,
                    error::{self, Result},
                    expr::
                    {
                        Expr, ExprConst, ExprLit, ExprMacro, ExprPath, ExprRange, Member, RangeLimits,
                    },
                    ext::IdentExt as _,
                    ident::Ident,
                    lit::Lit,
                    mac::{self, Macro},
                    parse::{Parse, ParseBuffer, ParseStream},
                    pat::{
                        FieldPat, Pat, PatIdent, PatOr, PatParen, PatReference, PatRest, PatSlice, PatStruct,
                        PatTuple, PatTupleStruct, PatType, PatWild,
                    },
                    path::{self, Path, QSelf},
                    punctuated::Punctuated,
                    stmt::Block,
                    token,
                    verbatim,
                },
                *,
            };

            impl Pat {
                /// Parse a pattern that does _not_ involve `|` at the top level.
                pub fn parse_single(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let lookahead = input.lookahead1();
                    if lookahead.peek(Ident)
                        && (input.peek2(Token![::])
                            || input.peek2(Token![!])
                            || input.peek2(token::Brace)
                            || input.peek2(token::Paren)
                            || input.peek2(Token![..]))
                        || input.peek(Token![self]) && input.peek2(Token![::])
                        || lookahead.peek(Token![::])
                        || lookahead.peek(Token![<])
                        || input.peek(Token![Self])
                        || input.peek(Token![super])
                        || input.peek(Token![crate])
                    {
                        pat_path_or_macro_or_struct_or_range(input)
                    } else if lookahead.peek(Token![_]) {
                        input.call(pat_wild).map(Pat::Wild)
                    } else if input.peek(Token![box]) {
                        pat_box(begin, input)
                    } else if input.peek(Token![-]) || lookahead.peek(Lit) || lookahead.peek(Token![const])
                    {
                        pat_lit_or_range(input)
                    } else if lookahead.peek(Token![ref])
                        || lookahead.peek(Token![mut])
                        || input.peek(Token![self])
                        || input.peek(Ident)
                    {
                        input.call(pat_ident).map(Pat::Ident)
                    } else if lookahead.peek(Token![&]) {
                        input.call(pat_reference).map(Pat::Reference)
                    } else if lookahead.peek(token::Paren) {
                        input.call(pat_paren_or_tuple)
                    } else if lookahead.peek(token::Bracket) {
                        input.call(pat_slice).map(Pat::Slice)
                    } else if lookahead.peek(Token![..]) && !input.peek(Token![...]) {
                        pat_range_half_open(input)
                    } else if lookahead.peek(Token![const]) {
                        input.call(pat_const).map(Pat::Verbatim)
                    } else {
                        Err(lookahead.error())
                    }
                }
                /// Parse a pattern, possibly involving `|`, but not a leading `|`.
                pub fn parse_multi(input: ParseStream) -> Result<Self> {
                    multi_pat_impl(input, None)
                }
                /// Parse a pattern, possibly involving `|`, possibly including a leading `|`.
                pub fn parse_multi_with_leading_vert(input: ParseStream) -> Result<Self> {
                    let leading_vert: Option<Token![|]> = input.parse()?;
                    multi_pat_impl(input, leading_vert)
                }
            }

            impl Parse for PatType
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (PatType {
                        attrs: Vec::new(),
                        pat: Box::new(Pat::parse_single(input)?),
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                    })
                }
            }

            fn multi_pat_impl(input: ParseStream, leading_vert: Option<Token![|]>) -> Result<Pat>
            {
                let mut pat = Pat::parse_single(input)?;
                if leading_vert.is_some()
                    || input.peek(Token![|]) && !input.peek(Token![||]) && !input.peek(Token![|=])
                {
                    let mut cases = Punctuated::new();
                    cases.push_value(pat);
                    while input.peek(Token![|]) && !input.peek(Token![||]) && !input.peek(Token![|=]) {
                        let punct = input.parse()?;
                        cases.push_punct(punct);
                        let pat = Pat::parse_single(input)?;
                        cases.push_value(pat);
                    }
                    pat = Pat::Or(PatOr {
                        attrs: Vec::new(),
                        leading_vert,
                        cases,
                    });
                }
                Ok(pat)
            }

            fn pat_path_or_macro_or_struct_or_range(input: ParseStream) -> Result<Pat>
            {
                let expr_style = true;
                let (qself, path) = path::parsing::qpath(input, expr_style)?;

                if qself.is_none()
                    && input.peek(Token![!])
                    && !input.peek(Token![!=])
                    && path.is_mod_style()
                {
                    let bang_token: Token![!] = input.parse()?;
                    let (delimiter, tokens) = mac::parse_delimiter(input)?;
                    return Ok(Pat::Macro(ExprMacro {
                        attrs: Vec::new(),
                        mac: Macro {
                            path,
                            bang_token,
                            delimiter,
                            tokens,
                        },
                    }));
                }

                if input.peek(token::Brace) {
                    pat_struct(input, qself, path).map(Pat::Struct)
                } else if input.peek(token::Paren) {
                    pat_tuple_struct(input, qself, path).map(Pat::TupleStruct)
                } else if input.peek(Token![..]) {
                    pat_range(input, qself, path)
                } else {
                    Ok(Pat::Path(ExprPath {
                        attrs: Vec::new(),
                        qself,
                        path,
                    }))
                }
            }

            fn pat_wild(input: ParseStream) -> Result<PatWild>
            {
                Ok
                (PatWild {
                    attrs: Vec::new(),
                    underscore_token: input.parse()?,
                })
            }

            fn pat_box(begin: ParseBuffer, input: ParseStream) -> Result<Pat> {
                input.parse::<Token![box]>()?;
                Pat::parse_single(input)?;
                Ok(Pat::Verbatim(verbatim::between(&begin, input)))
            }

            fn pat_ident(input: ParseStream) -> Result<PatIdent>
            {
                Ok
                (PatIdent {
                    attrs: Vec::new(),
                    by_ref: input.parse()?,
                    mutability: input.parse()?,
                    ident: {
                        if input.peek(Token![self]) {
                            input.call(Ident::parse_any)?
                        } else {
                            input.parse()?
                        }
                    },
                    subpat: {
                        if input.peek(Token![@]) {
                            let at_token: Token![@] = input.parse()?;
                            let subpat = Pat::parse_single(input)?;
                            Some((at_token, Box::new(subpat)))
                        } else {
                            None
                        }
                    },
                })
            }

            fn pat_tuple_struct(
                input: ParseStream,
                qself: Option<QSelf>,
                path: Path,
            ) -> Result<PatTupleStruct>
            {
                let content;
                let paren_token = parenthesized!(content in input);

                let mut elems = Punctuated::new();
                while !content.is_empty() {
                    let value = Pat::parse_multi_with_leading_vert(&content)?;
                    elems.push_value(value);
                    if content.is_empty() {
                        break;
                    }
                    let punct = content.parse()?;
                    elems.push_punct(punct);
                }

                Ok(PatTupleStruct {
                    attrs: Vec::new(),
                    qself,
                    path,
                    paren_token,
                    elems,
                })
            }

            fn pat_struct(input: ParseStream, qself: Option<QSelf>, path: Path) -> Result<PatStruct>
            {
                let content;
                let brace_token = braced!(content in input);

                let mut fields = Punctuated::new();
                let mut rest = None;
                while !content.is_empty() {
                    let attrs = content.call(Attribute::parse_outer)?;
                    if content.peek(Token![..]) {
                        rest = Some(PatRest {
                            attrs,
                            dot2_token: content.parse()?,
                        });
                        break;
                    }
                    let mut value = content.call(field_pat)?;
                    value.attrs = attrs;
                    fields.push_value(value);
                    if content.is_empty() {
                        break;
                    }
                    let punct: Token![,] = content.parse()?;
                    fields.push_punct(punct);
                }

                Ok(PatStruct {
                    attrs: Vec::new(),
                    qself,
                    path,
                    brace_token,
                    fields,
                    rest,
                })
            }

            fn field_pat(input: ParseStream) -> Result<FieldPat>
            {
                let begin = input.fork();
                let boxed: Option<Token![box]> = input.parse()?;
                let by_ref: Option<Token![ref]> = input.parse()?;
                let mutability: Option<Token![mut]> = input.parse()?;

                let member = if boxed.is_some() || by_ref.is_some() || mutability.is_some() {
                    input.parse().map(Member::Named)
                } else {
                    input.parse()
                }?;

                if boxed.is_none() && by_ref.is_none() && mutability.is_none() && input.peek(Token![:])
                    || !member.is_named()
                {
                    return Ok(FieldPat {
                        attrs: Vec::new(),
                        member,
                        colon_token: Some(input.parse()?),
                        pat: Box::new(Pat::parse_multi_with_leading_vert(input)?),
                    });
                }

                let ident = match member {
                    Member::Named(ident) => ident,
                    Member::Unnamed(_) => unreachable!(),
                };

                let pat = if boxed.is_some() {
                    Pat::Verbatim(verbatim::between(&begin, input))
                } else {
                    Pat::Ident(PatIdent {
                        attrs: Vec::new(),
                        by_ref,
                        mutability,
                        ident: ident.clone(),
                        subpat: None,
                    })
                };

                Ok(FieldPat {
                    attrs: Vec::new(),
                    member: Member::Named(ident),
                    colon_token: None,
                    pat: Box::new(pat),
                })
            }

            fn pat_range(input: ParseStream, qself: Option<QSelf>, path: Path) -> Result<Pat>
            {
                let limits = RangeLimits::parse_obsolete(input)?;
                let end = input.call(pat_range_bound)?;
                if let (RangeLimits::Closed(_), None) = (&limits, &end) {
                    return Err(input.error("expected range upper bound"));
                }
                Ok(Pat::Range(ExprRange {
                    attrs: Vec::new(),
                    start: Some(Box::new(Expr::Path(ExprPath {
                        attrs: Vec::new(),
                        qself,
                        path,
                    }))),
                    limits,
                    end: end.map(PatRangeBound::into_expr),
                }))
            }

            fn pat_range_half_open(input: ParseStream) -> Result<Pat>
            {
                let limits: RangeLimits = input.parse()?;
                let end = input.call(pat_range_bound)?;
                if end.is_some() {
                    Ok(Pat::Range(ExprRange {
                        attrs: Vec::new(),
                        start: None,
                        limits,
                        end: end.map(PatRangeBound::into_expr),
                    }))
                } else {
                    match limits {
                        RangeLimits::HalfOpen(dot2_token) => Ok(Pat::Rest(PatRest {
                            attrs: Vec::new(),
                            dot2_token,
                        })),
                        RangeLimits::Closed(_) => Err(input.error("expected range upper bound")),
                    }
                }
            }

            fn pat_paren_or_tuple(input: ParseStream) -> Result<Pat>
            {
                let content;
                let paren_token = parenthesized!(content in input);

                let mut elems = Punctuated::new();
                while !content.is_empty() {
                    let value = Pat::parse_multi_with_leading_vert(&content)?;
                    if content.is_empty() {
                        if elems.is_empty() && !matches!(value, Pat::Rest(_)) {
                            return Ok(Pat::Paren(PatParen {
                                attrs: Vec::new(),
                                paren_token,
                                pat: Box::new(value),
                            }));
                        }
                        elems.push_value(value);
                        break;
                    }
                    elems.push_value(value);
                    let punct = content.parse()?;
                    elems.push_punct(punct);
                }

                Ok(Pat::Tuple(PatTuple {
                    attrs: Vec::new(),
                    paren_token,
                    elems,
                }))
            }

            fn pat_reference(input: ParseStream) -> Result<PatReference>
            {
                Ok
                (PatReference {
                    attrs: Vec::new(),
                    and_token: input.parse()?,
                    mutability: input.parse()?,
                    pat: Box::new(Pat::parse_single(input)?),
                })
            }

            fn pat_lit_or_range(input: ParseStream) -> Result<Pat>
            {
                let start = input.call(pat_range_bound)?.unwrap();
                if input.peek(Token![..]) {
                    let limits = RangeLimits::parse_obsolete(input)?;
                    let end = input.call(pat_range_bound)?;
                    if let (RangeLimits::Closed(_), None) = (&limits, &end) {
                        return Err(input.error("expected range upper bound"));
                    }
                    Ok(Pat::Range(ExprRange {
                        attrs: Vec::new(),
                        start: Some(start.into_expr()),
                        limits,
                        end: end.map(PatRangeBound::into_expr),
                    }))
                } else {
                    Ok(start.into_pat())
                }
            }

           
            enum PatRangeBound {
                Const(ExprConst),
                Lit(ExprLit),
                Path(ExprPath),
            }

            impl PatRangeBound {
                fn into_expr(self) -> Box<Expr> {
                    Box::new(match self {
                        PatRangeBound::Const(pat) => Expr::Const(pat),
                        PatRangeBound::Lit(pat) => Expr::Lit(pat),
                        PatRangeBound::Path(pat) => Expr::Path(pat),
                    })
                }

                fn into_pat(self) -> Pat {
                    match self {
                        PatRangeBound::Const(pat) => Pat::Const(pat),
                        PatRangeBound::Lit(pat) => Pat::Lit(pat),
                        PatRangeBound::Path(pat) => Pat::Path(pat),
                    }
                }
            }

            fn pat_range_bound(input: ParseStream) -> Result<Option<PatRangeBound>> {
                if input.is_empty()
                    || input.peek(Token![|])
                    || input.peek(Token![=])
                    || input.peek(Token![:]) && !input.peek(Token![::])
                    || input.peek(Token![,])
                    || input.peek(Token![;])
                    || input.peek(Token![if])
                {
                    return Ok(None);
                }

                let lookahead = input.lookahead1();
                let expr = if lookahead.peek(Lit) {
                    PatRangeBound::Lit(input.parse()?)
                } else if lookahead.peek(Ident)
                    || lookahead.peek(Token![::])
                    || lookahead.peek(Token![<])
                    || lookahead.peek(Token![self])
                    || lookahead.peek(Token![Self])
                    || lookahead.peek(Token![super])
                    || lookahead.peek(Token![crate])
                {
                    PatRangeBound::Path(input.parse()?)
                } else if lookahead.peek(Token![const]) {
                    PatRangeBound::Const(input.parse()?)
                } else {
                    return Err(lookahead.error());
                };

                Ok(Some(expr))
            }

            fn pat_slice(input: ParseStream) -> Result<PatSlice>
            {
                let content;
                let bracket_token = bracketed!(content in input);

                let mut elems = Punctuated::new();
                while !content.is_empty() {
                    let value = Pat::parse_multi_with_leading_vert(&content)?;
                    match value {
                        Pat::Range(pat) if pat.start.is_none() || pat.end.is_none() => {
                            let (start, end) = match pat.limits {
                                RangeLimits::HalfOpen(dot_dot) => (dot_dot.spans[0], dot_dot.spans[1]),
                                RangeLimits::Closed(dot_dot_eq) => {
                                    (dot_dot_eq.spans[0], dot_dot_eq.spans[2])
                                }
                            };
                            let msg = "range pattern is not allowed unparenthesized inside slice pattern";
                            return Err(error::new2(start, end, msg));
                        }
                        _ => {}
                    }
                    elems.push_value(value);
                    if content.is_empty() {
                        break;
                    }
                    let punct = content.parse()?;
                    elems.push_punct(punct);
                }

                Ok(PatSlice {
                    attrs: Vec::new(),
                    bracket_token,
                    elems,
                })
            }

            fn pat_const(input: ParseStream) -> Result<TokenStream>
            {
                let begin = input.fork();
                input.parse::<Token![const]>()?;

                let content;
                braced!(content in input);
                content.call(Attribute::parse_inner)?;
                content.call(Block::parse_within)?;

                Ok(verbatim::between(&begin, input))
            }
        }

        mod printing
        {
            use ::
            {
                process::macros::{ TokenStream },
                quote::{ ToTokens, TokenStreamExt },
                syntax::
                {
                    attr::{ FilterAttrs },
                    pat::
                    {
                        FieldPat, Pat, PatIdent, PatOr, PatParen, PatReference, PatRest, PatSlice, PatStruct,
                        PatTuple, PatTupleStruct, PatType, PatWild,
                    },
                    path::{ self, printing::{ PathStyle }, },
                },
                *,
            };
            /*
            */
            impl ToTokens for PatIdent 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.by_ref.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    if let Some((at_token, subpat)) = &self.subpat {
                        at_token.to_tokens(tokens);
                        subpat.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for PatOr 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.leading_vert.to_tokens(tokens);
                    self.cases.to_tokens(tokens);
                }
            }

            impl ToTokens for PatParen 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.paren_token.surround(tokens, |tokens| {
                        self.pat.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for PatReference 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.and_token.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.pat.to_tokens(tokens);
                }
            }

            impl ToTokens for PatRest 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.dot2_token.to_tokens(tokens);
                }
            }

            impl ToTokens for PatSlice 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.bracket_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for PatStruct 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::Expr);
                    self.brace_token.surround(tokens, |tokens| {
                        self.fields.to_tokens(tokens);
                       
                        if !self.fields.empty_or_trailing() && self.rest.is_some() {
                            <Token![,]>::default().to_tokens(tokens);
                        }
                        self.rest.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for PatTuple 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.paren_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                       
                       
                       
                        if self.elems.len() == 1
                            && !self.elems.trailing_punct()
                            && !matches!(self.elems[0], Pat::Rest { .. })
                        {
                            <Token![,]>::default().to_tokens(tokens);
                        }
                    });
                }
            }

            impl ToTokens for PatTupleStruct 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::Expr);
                    self.paren_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for PatType 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.pat.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                }
            }

            impl ToTokens for PatWild 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.underscore_token.to_tokens(tokens);
                }
            }

            impl ToTokens for FieldPat 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some(colon_token) = &self.colon_token {
                        self.member.to_tokens(tokens);
                        colon_token.to_tokens(tokens);
                    }
                    self.pat.to_tokens(tokens);
                }
            }
        }
    } pub use self::pat::
    {
        FieldPat, Pat, PatConst, PatIdent, PatLit, PatMacro, PatOr, PatParen, PatPath, PatRange,
        PatReference, PatRest, PatSlice, PatStruct, PatTuple, PatTupleStruct, PatType, PatWild,
    }; 
    
    pub mod path
    {
        use ::
        {
            syntax::
            {
                error::Result,
                expr::Expr,
                generics::TypeParamBound,
                ident::Ident,
                lifetime::Lifetime,
                punctuated::Punctuated,
                token,
                ty::{ReturnType, Type},
            },
            *,
        };
        /*
        */
        ast_struct! 
        {
            /// A path at which a named item is exported (e.g. `std::collections::HashMap`).
            pub struct Path {
                pub leading_colon: Option<Token![::]>,
                pub segments: Punctuated<PathSegment, Token![::]>,
            }
        }

        impl<T> From<T> for Path where
        T: Into<PathSegment>
        {
            fn from(segment: T) -> Self {
                let mut path = Path {
                    leading_colon: None,
                    segments: Punctuated::new(),
                };
                path.segments.push_value(segment.into());
                path
            }
        }

        impl Path 
        {
            /// Determines whether this is a path of length 1 equal to the given ident.
            pub fn is_ident<I>(&self, ident: &I) -> bool
            where
                I: ?Sized,
                Ident: PartialEq<I>,
            {
                match self.get_ident() {
                    Some(id) => id == ident,
                    None => false,
                }
            }
            /// If this path consists of a single ident, returns the ident.
            pub fn get_ident(&self) -> Option<&Ident> {
                if self.leading_colon.is_none()
                    && self.segments.len() == 1
                    && self.segments[0].arguments.is_none()
                {
                    Some(&self.segments[0].ident)
                } else {
                    None
                }
            }
            /// An error if this path is not a single ident, as defined in `get_ident`.
            pub fn require_ident(&self) -> Result<&Ident>
            {
                self.get_ident().ok_or_else(|| {
                    ::syntax::error::new2(
                        self.segments.first().unwrap().ident.span(),
                        self.segments.last().unwrap().ident.span(),
                        "expected this path to be an identifier",
                    )
                })
            }
        }

        ast_struct! 
        {
            /// A segment of a path together with any path arguments on that segment.
            pub struct PathSegment {
                pub ident: Ident,
                pub arguments: PathArguments,
            }
        }

        impl<T> From<T> for PathSegment where
        T: Into<Ident>,
        {
            fn from(ident: T) -> Self {
                PathSegment {
                    ident: ident.into(),
                    arguments: PathArguments::None,
                }
            }
        }

        ast_enum! 
        {
            /// Angle bracketed or parenthesized arguments of a path segment.
            ///
            /// The `(A, B) -> C` in `Fn(A, B) -> C`.
            pub enum PathArguments {
                None,
                /// The `<'a, T>` in `std::slice::iter<'a, T>`.
                AngleBracketed(AngleBracketedGenericArguments),
                /// The `(A, B) -> C` in `Fn(A, B) -> C`.
                Parenthesized(ParenthesizedGenericArguments),
            }
        }

        impl Default for PathArguments 
        {
            fn default() -> Self {
                PathArguments::None
            }
        }

        impl PathArguments 
        {
            pub fn is_empty(&self) -> bool
        {
                match self {
                    PathArguments::None => true,
                    PathArguments::AngleBracketed(bracketed) => bracketed.args.is_empty(),
                    PathArguments::Parenthesized(_) => false,
                }
            }

            pub fn is_none(&self) -> bool
        {
                match self {
                    PathArguments::None => true,
                    PathArguments::AngleBracketed(_) | PathArguments::Parenthesized(_) => false,
                }
            }
        }

        ast_enum! 
        {
            /// An individual generic argument, like `'a`, `T`, or `Item = T`.
            #[non_exhaustive]
            pub enum GenericArgument {
                /// A lifetime argument.
                Lifetime(Lifetime),
                /// A type argument.
                Type(Type),
                /// A const expression. Must be inside of a block.
                Const(Expr),
                /// A binding (equality constraint) on an associated type: the `Item =
                /// u8` in `Iterator<Item = u8>`.
                AssocType(AssocType),
                /// An equality constraint on an associated constant: the `PANIC =
                /// false` in `Trait<PANIC = false>`.
                AssocConst(AssocConst),
                /// An associated type bound: `Iterator<Item: Display>`.
                Constraint(Constraint),
            }
        }

        ast_struct! 
        {
            /// Angle bracketed arguments of a path segment: the `<K, V>` in `HashMap<K,
            /// V>`.
            pub struct AngleBracketedGenericArguments {
                pub colon2_token: Option<Token![::]>,
                pub lt_token: Token![<],
                pub args: Punctuated<GenericArgument, Token![,]>,
                pub gt_token: Token![>],
            }
        }

        ast_struct! 
        {
            /// A binding (equality constraint) on an associated type: the `Item = u8`
            /// in `Iterator<Item = u8>`.
            pub struct AssocType {
                pub ident: Ident,
                pub generics: Option<AngleBracketedGenericArguments>,
                pub eq_token: Token![=],
                pub ty: Type,
            }
        }

        ast_struct! 
        {
            /// An equality constraint on an associated constant: the `PANIC = false` in
            /// `Trait<PANIC = false>`.
            pub struct AssocConst {
                pub ident: Ident,
                pub generics: Option<AngleBracketedGenericArguments>,
                pub eq_token: Token![=],
                pub value: Expr,
            }
        }

        ast_struct! 
        {
            /// An associated type bound: `Iterator<Item: Display>`.
            pub struct Constraint {
                pub ident: Ident,
                pub generics: Option<AngleBracketedGenericArguments>,
                pub colon_token: Token![:],
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
            }
        }

        ast_struct! 
        {
            /// Arguments of a function path segment: the `(A, B) -> C` in `Fn(A,B) ->
            /// C`.
            pub struct ParenthesizedGenericArguments {
                pub paren_token: token::Paren,
                /// `(A, B)`
                pub inputs: Punctuated<Type, Token![,]>,
                /// `C`
                pub output: ReturnType,
            }
        }

        ast_struct! 
        {
            /// The explicit Self type in a qualified path: the `T` in `<T as Display>::fmt`.
            pub struct QSelf {
                pub lt_token: Token![<],
                pub ty: Box<Type>,
                pub position: usize,
                pub as_token: Option<Token![as]>,
                pub gt_token: Token![>],
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    error::Result,
                    expr::ExprBlock,
                    expr::{Expr, ExprPath},
                    ext::IdentExt as _,
                    generics::TypeParamBound,
                    ident::Ident,
                    lifetime::Lifetime,
                    lit::Lit,
                    parse::{Parse, ParseStream},
                    path::
                    {
                        AngleBracketedGenericArguments, AssocConst, AssocType, Constraint, GenericArgument, 
                        ParenthesizedGenericArguments, Path, PathArguments, PathSegment, QSelf,
                    },
                    punctuated::Punctuated,
                    token,
                    ty::{ReturnType, Type},
                },
                *,
            };

            impl Parse for Path
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    Self::parse_helper(input, false)
                }
            }

            impl Parse for GenericArgument
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Lifetime) && !input.peek2(Token![+]) {
                        return Ok(GenericArgument::Lifetime(input.parse()?));
                    }

                    if input.peek(Lit) || input.peek(token::Brace) {
                        return const_argument(input).map(GenericArgument::Const);
                    }

                    let mut argument: Type = input.parse()?;

                    match argument {
                        Type::Path(mut ty)
                            if ty.qself.is_none()
                                && ty.path.leading_colon.is_none()
                                && ty.path.segments.len() == 1
                                && match &ty.path.segments[0].arguments {
                                    PathArguments::None | PathArguments::AngleBracketed(_) => true,
                                    PathArguments::Parenthesized(_) => false,
                                } =>
                        {
                            if let Some(eq_token) = input.parse::<Option<Token![=]>>()? {
                                let segment = ty.path.segments.pop().unwrap().into_value();
                                let ident = segment.ident;
                                let generics = match segment.arguments {
                                    PathArguments::None => None,
                                    PathArguments::AngleBracketed(arguments) => Some(arguments),
                                    PathArguments::Parenthesized(_) => unreachable!(),
                                };
                                return if input.peek(Lit) || input.peek(token::Brace) {
                                    Ok(GenericArgument::AssocConst(AssocConst {
                                        ident,
                                        generics,
                                        eq_token,
                                        value: const_argument(input)?,
                                    }))
                                } else {
                                    Ok(GenericArgument::AssocType(AssocType {
                                        ident,
                                        generics,
                                        eq_token,
                                        ty: input.parse()?,
                                    }))
                                };
                            }

                                                if let Some(colon_token) = input.parse::<Option<Token![:]>>()? {
                                let segment = ty.path.segments.pop().unwrap().into_value();
                                return Ok(GenericArgument::Constraint(Constraint {
                                    ident: segment.ident,
                                    generics: match segment.arguments {
                                        PathArguments::None => None,
                                        PathArguments::AngleBracketed(arguments) => Some(arguments),
                                        PathArguments::Parenthesized(_) => unreachable!(),
                                    },
                                    colon_token,
                                    bounds: {
                                        let mut bounds = Punctuated::new();
                                        loop {
                                            if input.peek(Token![,]) || input.peek(Token![>]) {
                                                break;
                                            }
                                            bounds.push_value({
                                                let allow_precise_capture = false;
                                                let allow_const = true;
                                                TypeParamBound::parse_single(
                                                    input,
                                                    allow_precise_capture,
                                                    allow_const,
                                                )?
                                            });
                                            if !input.peek(Token![+]) {
                                                break;
                                            }
                                            let punct: Token![+] = input.parse()?;
                                            bounds.push_punct(punct);
                                        }
                                        bounds
                                    },
                                }));
                            }

                            argument = Type::Path(ty);
                        }
                        _ => {}
                    }

                    Ok(GenericArgument::Type(argument))
                }
            }

            pub fn const_argument(input: ParseStream) -> Result<Expr>
            {
                let lookahead = input.lookahead1();

                if input.peek(Lit) {
                    let lit = input.parse()?;
                    return Ok(Expr::Lit(lit));
                }

                if input.peek(Ident) {
                    let ident: Ident = input.parse()?;
                    return Ok(Expr::Path(ExprPath {
                        attrs: Vec::new(),
                        qself: None,
                        path: Path::from(ident),
                    }));
                }

                if input.peek(token::Brace)
                {
                    let block: ExprBlock = input.parse()?;
                    return Ok(Expr::Block(block));
                }

                Err(lookahead.error())
            }

            impl AngleBracketedGenericArguments {
                /// Parse `::<…>` with mandatory leading `::`.
                        #[cfg_attr(docsrs, doc(cfg(all(feature = "parsing", feature = "full"))))]
                pub fn parse_turbofish(input: ParseStream) -> Result<Self> {
                    let colon2_token: Token![::] = input.parse()?;
                    Self::do_parse(Some(colon2_token), input)
                }

                pub fn do_parse(
                    colon2_token: Option<Token![::]>,
                    input: ParseStream,
                ) -> Result<Self>
                {
                    Ok
                    (AngleBracketedGenericArguments {
                        colon2_token,
                        lt_token: input.parse()?,
                        args: {
                            let mut args = Punctuated::new();
                            loop {
                                if input.peek(Token![>]) {
                                    break;
                                }
                                let value: GenericArgument = input.parse()?;
                                args.push_value(value);
                                if input.peek(Token![>]) {
                                    break;
                                }
                                let punct: Token![,] = input.parse()?;
                                args.push_punct(punct);
                            }
                            args
                        },
                        gt_token: input.parse()?,
                    })
                }
            }

            impl Parse for AngleBracketedGenericArguments
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let colon2_token: Option<Token![::]> = input.parse()?;
                    Self::do_parse(colon2_token, input)
                }
            }

            impl Parse for ParenthesizedGenericArguments
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(ParenthesizedGenericArguments {
                        paren_token: parenthesized!(content in input),
                        inputs: content.parse_terminated(Type::parse, Token![,])?,
                        output: input.call(ReturnType::without_plus)?,
                    })
                }
            }

            impl Parse for PathSegment
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    Self::parse_helper(input, false)
                }
            }

            impl PathSegment
            {
                fn parse_helper(input: ParseStream, expr_style: bool) -> Result<Self>
                {
                    if input.peek(Token![super])
                        || input.peek(Token![self])
                        || input.peek(Token![crate])
                        || cfg!(feature = "full") && input.peek(Token![try])
                    {
                        let ident = input.call(Ident::parse_any)?;
                        return Ok(PathSegment::from(ident));
                    }

                    let ident = if input.peek(Token![Self]) {
                        input.call(Ident::parse_any)?
                    } else {
                        input.parse()?
                    };

                    if !expr_style
                        && input.peek(Token![<])
                        && !input.peek(Token![<=])
                        && !input.peek(Token![<<=])
                        || input.peek(Token![::]) && input.peek3(Token![<])
                    {
                        Ok(PathSegment {
                            ident,
                            arguments: PathArguments::AngleBracketed(input.parse()?),
                        })
                    } else {
                        Ok(PathSegment::from(ident))
                    }
                }
            }

            impl Path {
                /// Parse a `Path` containing no path arguments on any of its segments.
                pub fn parse_mod_style(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (Path {
                        leading_colon: input.parse()?,
                        segments: {
                            let mut segments = Punctuated::new();
                            loop {
                                if !input.peek(Ident)
                                    && !input.peek(Token![super])
                                    && !input.peek(Token![self])
                                    && !input.peek(Token![Self])
                                    && !input.peek(Token![crate])
                                {
                                    break;
                                }
                                let ident = Ident::parse_any(input)?;
                                segments.push_value(PathSegment::from(ident));
                                if !input.peek(Token![::]) {
                                    break;
                                }
                                let punct = input.parse()?;
                                segments.push_punct(punct);
                            }
                            if segments.is_empty() {
                                return Err(input.parse::<Ident>().unwrap_err());
                            } else if segments.trailing_punct() {
                                return Err(input.error("expected path segment after `::`"));
                            }
                            segments
                        },
                    })
                }

                pub fn parse_helper(input: ParseStream, expr_style: bool) -> Result<Self> {
                    let mut path = Path {
                        leading_colon: input.parse()?,
                        segments: {
                            let mut segments = Punctuated::new();
                            let value = PathSegment::parse_helper(input, expr_style)?;
                            segments.push_value(value);
                            segments
                        },
                    };
                    Path::parse_rest(input, &mut path, expr_style)?;
                    Ok(path)
                }

                pub fn parse_rest(
                    input: ParseStream,
                    path: &mut Self,
                    expr_style: bool,
                ) -> Result<()> {
                    while input.peek(Token![::]) && !input.peek3(token::Paren) {
                        let punct: Token![::] = input.parse()?;
                        path.segments.push_punct(punct);
                        let value = PathSegment::parse_helper(input, expr_style)?;
                        path.segments.push_value(value);
                    }
                    Ok(())
                }

                pub fn is_mod_style(&self) -> bool
        {
                    self.segments
                        .iter()
                        .all(|segment| segment.arguments.is_none())
                }
            }

            pub fn qpath(input: ParseStream, expr_style: bool) -> Result<(Option<QSelf>, Path)> {
                if input.peek(Token![<]) {
                    let lt_token: Token![<] = input.parse()?;
                    let this: Type = input.parse()?;
                    let path = if input.peek(Token![as]) {
                        let as_token: Token![as] = input.parse()?;
                        let path: Path = input.parse()?;
                        Some((as_token, path))
                    } else {
                        None
                    };
                    let gt_token: Token![>] = input.parse()?;
                    let colon2_token: Token![::] = input.parse()?;
                    let mut rest = Punctuated::new();
                    loop {
                        let path = PathSegment::parse_helper(input, expr_style)?;
                        rest.push_value(path);
                        if !input.peek(Token![::]) {
                            break;
                        }
                        let punct: Token![::] = input.parse()?;
                        rest.push_punct(punct);
                    }
                    let (position, as_token, path) = match path {
                        Some((as_token, mut path)) => {
                            let pos = path.segments.len();
                            path.segments.push_punct(colon2_token);
                            path.segments.extend(rest.into_pairs());
                            (pos, Some(as_token), path)
                        }
                        None => {
                            let path = Path {
                                leading_colon: Some(colon2_token),
                                segments: rest,
                            };
                            (0, None, path)
                        }
                    };
                    let qself = QSelf {
                        lt_token,
                        ty: Box::new(this),
                        position,
                        as_token,
                        gt_token,
                    };
                    Ok((Some(qself), path))
                } else {
                    let path = Path::parse_helper(input, expr_style)?;
                    Ok((None, path))
                }
            }
        }

        pub mod printing
        {
            use ::
            {
                process::macros::{ Span, TokenStream },
                quote::ToTokens,
                syntax::
                {
                    generics,
                    print::TokensOrDefault,
                    spanned::Spanned,
                    path::
                    {
                        AngleBracketedGenericArguments, AssocConst, AssocType, Constraint, GenericArgument,
                        ParenthesizedGenericArguments, Path, PathArguments, PathSegment, QSelf,
                    }
                },
                *,
            };

            pub enum PathStyle {
                Expr,
                Mod,
                AsWritten,
            }

            impl Copy for PathStyle {}

            impl Clone for PathStyle {
                fn clone(&self) -> Self {
                    *self
                }
            }

            impl ToTokens for Path {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_path(tokens, self, PathStyle::AsWritten);
                }
            }

            pub fn print_path(tokens: &mut TokenStream, path: &Path, style: PathStyle) {
                path.leading_colon.to_tokens(tokens);
                for segment in path.segments.pairs() {
                    print_path_segment(tokens, segment.value(), style);
                    segment.punct().to_tokens(tokens);
                }
            }

            impl ToTokens for PathSegment {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_path_segment(tokens, self, PathStyle::AsWritten);
                }
            }

            fn print_path_segment(tokens: &mut TokenStream, segment: &PathSegment, style: PathStyle) {
                segment.ident.to_tokens(tokens);
                print_path_arguments(tokens, &segment.arguments, style);
            }

            impl ToTokens for PathArguments {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_path_arguments(tokens, self, PathStyle::AsWritten);
                }
            }

            fn print_path_arguments(tokens: &mut TokenStream, arguments: &PathArguments, style: PathStyle) {
                match arguments {
                    PathArguments::None => {}
                    PathArguments::AngleBracketed(arguments) => {
                        print_angle_bracketed_generic_arguments(tokens, arguments, style);
                    }
                    PathArguments::Parenthesized(arguments) => {
                        print_parenthesized_generic_arguments(tokens, arguments, style);
                    }
                }
            }

            impl ToTokens for GenericArgument {
                #[allow(clippy::match_same_arms)]
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        GenericArgument::Lifetime(lt) => lt.to_tokens(tokens),
                        GenericArgument::Type(ty) => ty.to_tokens(tokens),
                        GenericArgument::Const(expr) => {
                            generics::printing::print_const_argument(expr, tokens);
                        }
                        GenericArgument::AssocType(assoc) => assoc.to_tokens(tokens),
                        GenericArgument::AssocConst(assoc) => assoc.to_tokens(tokens),
                        GenericArgument::Constraint(constraint) => constraint.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for AngleBracketedGenericArguments {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_angle_bracketed_generic_arguments(tokens, self, PathStyle::AsWritten);
                }
            }

            pub fn print_angle_bracketed_generic_arguments(
                tokens: &mut TokenStream,
                arguments: &AngleBracketedGenericArguments,
                style: PathStyle,
            ) {
                if let PathStyle::Mod = style {
                    return;
                }

                conditionally_print_turbofish(tokens, &arguments.colon2_token, style);
                arguments.lt_token.to_tokens(tokens);

               
               
                let mut trailing_or_empty = true;
                for param in arguments.args.pairs( )
                {
                    match param.value() {
                        GenericArgument::Lifetime(_) => {
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                        GenericArgument::Type(_)
                        | GenericArgument::Const(_)
                        | GenericArgument::AssocType(_)
                        | GenericArgument::AssocConst(_)
                        | GenericArgument::Constraint(_) => {}
                    }
                }
                for param in arguments.args.pairs( )
                {
                    match param.value() {
                        GenericArgument::Type(_)
                        | GenericArgument::Const(_)
                        | GenericArgument::AssocType(_)
                        | GenericArgument::AssocConst(_)
                        | GenericArgument::Constraint(_) => {
                            if !trailing_or_empty {
                                <Token![,]>::default().to_tokens(tokens);
                            }
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                        GenericArgument::Lifetime(_) => {}
                    }
                }

                arguments.gt_token.to_tokens(tokens);
            }

            impl ToTokens for AssocType {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                }
            }

            impl ToTokens for AssocConst {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    generics::printing::print_const_argument(&self.value, tokens);
                }
            }

            impl ToTokens for Constraint {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }

            impl ToTokens for ParenthesizedGenericArguments {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_parenthesized_generic_arguments(tokens, self, PathStyle::AsWritten);
                }
            }

            fn print_parenthesized_generic_arguments(
                tokens: &mut TokenStream,
                arguments: &ParenthesizedGenericArguments,
                style: PathStyle,
            ) {
                if let PathStyle::Mod = style {
                    return;
                }

                conditionally_print_turbofish(tokens, &None, style);
                arguments.paren_token.surround(tokens, |tokens| {
                    arguments.inputs.to_tokens(tokens);
                });
                arguments.output.to_tokens(tokens);
            }

            pub fn print_qpath(
                tokens: &mut TokenStream,
                qself: &Option<QSelf>,
                path: &Path,
                style: PathStyle,
            ) {
                let qself = match qself {
                    Some(qself) => qself,
                    None => {
                        print_path(tokens, path, style);
                        return;
                    }
                };
                qself.lt_token.to_tokens(tokens);
                qself.ty.to_tokens(tokens);

                let pos = cmp::min(qself.position, path.segments.len());
                let mut segments = path.segments.pairs();
                if pos > 0 {
                    TokensOrDefault(&qself.as_token).to_tokens(tokens);
                    path.leading_colon.to_tokens(tokens);
                    for (i, segment) in segments.by_ref().take(pos).enumerate() {
                        print_path_segment(tokens, segment.value(), PathStyle::AsWritten);
                        if i + 1 == pos {
                            qself.gt_token.to_tokens(tokens);
                        }
                        segment.punct().to_tokens(tokens);
                    }
                } else {
                    qself.gt_token.to_tokens(tokens);
                    path.leading_colon.to_tokens(tokens);
                }
                for segment in segments {
                    print_path_segment(tokens, segment.value(), style);
                    segment.punct().to_tokens(tokens);
                }
            }

            fn conditionally_print_turbofish(
                tokens: &mut TokenStream,
                colon2_token: &Option<Token![::]>,
                style: PathStyle,
            ) {
                match style {
                    PathStyle::Expr => TokensOrDefault(colon2_token).to_tokens(tokens),
                    PathStyle::Mod => unreachable!(),
                    PathStyle::AsWritten => colon2_token.to_tokens(tokens),
                }
            }
            
            impl Spanned for QSelf
            {
                fn span(&self) -> Span
                {
                    struct QSelfDelimiters<'a>(&'a QSelf);

                    impl<'a> ToTokens for QSelfDelimiters<'a> {
                        fn to_tokens(&self, tokens: &mut TokenStream) {
                            self.0.lt_token.to_tokens(tokens);
                            self.0.gt_token.to_tokens(tokens);
                        }
                    }

                    QSelfDelimiters(self).span()
                }
            }
        }
    }
    pub use self::path::
    {
        AngleBracketedGenericArguments, AssocConst, AssocType, Constraint, GenericArgument,
        ParenthesizedGenericArguments, Path, PathArguments, PathSegment, QSelf,
    };
    
    pub mod precedence
    {
        use ::
        {
            cmp::{ Ordering },
            syntax::
            {
                attr::{ AttrStyle, Attribute },
                expr::
                {
                    Expr, ExprArray, ExprAsync, ExprAwait, ExprBlock, ExprBreak, ExprCall, ExprConst, ExprContinue,
                    ExprField, ExprForLoop, ExprGroup, ExprIf, ExprIndex, ExprInfer, ExprLit, ExprLoop, ExprMacro,
                    ExprMatch, ExprMethodCall, ExprParen, ExprPath, ExprRepeat, ExprReturn, ExprStruct, ExprTry,
                    ExprTryBlock, ExprTuple, ExprUnsafe, ExprWhile, ExprYield,
                },
                op::{ BinOp },
                ty::{ ReturnType },
            },
            *,
        };
        /*
        */
        pub enum Precedence
        {
            Jump,
            Assign,
            Range,
            Or,
            And,
            Let,
            Compare,
            BitOr,
            BitXor,
            BitAnd,
            Shift,
            Sum,
            Product,
            Cast,
            Prefix,
            Unambiguous,
        }

        impl Precedence
        {
            pub const MIN: Self = Precedence::Jump;

            pub fn of_binop(op: &BinOp) -> Self
            {
                match op {
                    BinOp::Add(_) | BinOp::Sub(_) => Precedence::Sum,
                    BinOp::Mul(_) | BinOp::Div(_) | BinOp::Rem(_) => Precedence::Product,
                    BinOp::And(_) => Precedence::And,
                    BinOp::Or(_) => Precedence::Or,
                    BinOp::BitXor(_) => Precedence::BitXor,
                    BinOp::BitAnd(_) => Precedence::BitAnd,
                    BinOp::BitOr(_) => Precedence::BitOr,
                    BinOp::Shl(_) | BinOp::Shr(_) => Precedence::Shift,

                    BinOp::Eq(_)
                    | BinOp::Lt(_)
                    | BinOp::Le(_)
                    | BinOp::Ne(_)
                    | BinOp::Ge(_)
                    | BinOp::Gt(_) => Precedence::Compare,

                    BinOp::AddAssign(_)
                    | BinOp::SubAssign(_)
                    | BinOp::MulAssign(_)
                    | BinOp::DivAssign(_)
                    | BinOp::RemAssign(_)
                    | BinOp::BitXorAssign(_)
                    | BinOp::BitAndAssign(_)
                    | BinOp::BitOrAssign(_)
                    | BinOp::ShlAssign(_)
                    | BinOp::ShrAssign(_) => Precedence::Assign,
                }
            }
            
            pub fn of(e: &Expr) -> Self
            {
                fn prefix_attrs(attrs: &[Attribute]) -> Precedence
                {
                    for attr in attrs
                    {
                        if let AttrStyle::Outer = attr.style { return Precedence::Prefix; }
                    }

                    Precedence::Unambiguous
                }

                match e
                {
                    Expr::Closure(e) => match e.output
                    {
                        ReturnType::Default => Precedence::Jump,
                        ReturnType::Type(..) => prefix_attrs(&e.attrs),
                    },

                    Expr::Break(ExprBreak { expr, .. })
                    | Expr::Return(ExprReturn { expr, .. })
                    | Expr::Yield(ExprYield { expr, .. }) => match expr
                    {
                        Some(_) => Precedence::Jump,
                        None => Precedence::Unambiguous,
                    },

                    Expr::Assign(_) => Precedence::Assign,
                    Expr::Range(_) => Precedence::Range,
                    Expr::Binary(e) => Precedence::of_binop(&e.op),
                    Expr::Let(_) => Precedence::Let,
                    Expr::Cast(_) => Precedence::Cast,
                    Expr::RawAddr(_) | Expr::Reference(_) | Expr::Unary(_) => Precedence::Prefix,
                    
                    Expr::Array(ExprArray { attrs, .. })
                    | Expr::Async(ExprAsync { attrs, .. })
                    | Expr::Await(ExprAwait { attrs, .. })
                    | Expr::Block(ExprBlock { attrs, .. })
                    | Expr::Call(ExprCall { attrs, .. })
                    | Expr::Const(ExprConst { attrs, .. })
                    | Expr::Continue(ExprContinue { attrs, .. })
                    | Expr::Field(ExprField { attrs, .. })
                    | Expr::ForLoop(ExprForLoop { attrs, .. })
                    | Expr::Group(ExprGroup { attrs, .. })
                    | Expr::If(ExprIf { attrs, .. })
                    | Expr::Index(ExprIndex { attrs, .. })
                    | Expr::Infer(ExprInfer { attrs, .. })
                    | Expr::Lit(ExprLit { attrs, .. })
                    | Expr::Loop(ExprLoop { attrs, .. })
                    | Expr::Macro(ExprMacro { attrs, .. })
                    | Expr::Match(ExprMatch { attrs, .. })
                    | Expr::MethodCall(ExprMethodCall { attrs, .. })
                    | Expr::Paren(ExprParen { attrs, .. })
                    | Expr::Path(ExprPath { attrs, .. })
                    | Expr::Repeat(ExprRepeat { attrs, .. })
                    | Expr::Struct(ExprStruct { attrs, .. })
                    | Expr::Try(ExprTry { attrs, .. })
                    | Expr::TryBlock(ExprTryBlock { attrs, .. })
                    | Expr::Tuple(ExprTuple { attrs, .. })
                    | Expr::Unsafe(ExprUnsafe { attrs, .. })
                    | Expr::While(ExprWhile { attrs, .. }) => prefix_attrs(attrs),                    
                    
                    Expr::Verbatim(_) => Precedence::Unambiguous,
                }
            }
        }

        impl Copy for Precedence {}

        impl Clone for Precedence 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl PartialEq for Precedence 
        {
            fn eq(&self, other: &Self) -> bool
        {
                *self as u8 == *other as u8
            }
        }

        impl PartialOrd for Precedence 
        {
            fn partial_cmp(&self, other: &Self) -> Option<Ordering>
            {
                let this = *self as u8;
                let other = *other as u8;
                Some(this.cmp(&other))
            }
        }
    }
    
    pub mod print
    {
        use ::
        {
            process::macros::{ TokenStream },
            quote::{ ToTokens },
            *,
        };
        /*
        */
        pub struct TokensOrDefault<'a, T: 'a>(pub &'a Option<T>);

        impl<'a, T> ToTokens for TokensOrDefault<'a, T> where
            T: ToTokens + Default,
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                match self.0 {
                    Some(t) => t.to_tokens(tokens),
                    None => T::default().to_tokens(tokens),
                }
            }
        }
    }

    pub mod punctuated
    {
        //! A punctuated sequence of syntax tree nodes separated by punctuation.
        use ::
        {
            fmt::{ self, Debug },
            hash::{ Hash, Hasher },
            iter::{ FromIterator },
            ops::{ Index, IndexMut },
            syntax::
            {
                drops::{ NoDrop, TrivialDrop },
                error::{ Result },
                parse::{ Parse, ParseStream },
                token::{ Token },
            },
            *,
        };
        /*
        */
        /// A punctuated sequence of syntax tree nodes of type `T` separated by punctuation of type `P`.
        pub struct Punctuated<T, P> 
        {
            inner: Vec<(T, P)>,
            last: Option<Box<T>>,
        }

        impl<T, P> Punctuated<T, P> 
        {
            /// Creates an empty punctuated sequence.
            pub const fn new() -> Self {
                Punctuated {
                    inner: Vec::new(),
                    last: None,
                }
            }
            /// Determines whether this punctuated sequence is empty, meaning it
            /// contains no syntax tree nodes or punctuation.
            pub fn is_empty(&self) -> bool
            {
                self.inner.len() == 0 && self.last.is_none()
            }
            /// Returns the number of syntax tree nodes in this punctuated sequence.
            pub fn len(&self) -> usize
            {
                self.inner.len() + if self.last.is_some() { 1 } else { 0 }
            }
            /// Borrows the first element in this sequence.
            pub fn first(&self) -> Option<&T>
            {
                self.iter().next()
            }
            /// Mutably borrows the first element in this sequence.
            pub fn first_mut(&mut self) -> Option<&mut T>
            {
                self.iter_mut().next()
            }
            /// Borrows the last element in this sequence.
            pub fn last(&self) -> Option<&T>
            {
                self.iter().next_back()
            }
            /// Mutably borrows the last element in this sequence.
            pub fn last_mut(&mut self) -> Option<&mut T>
            {
                self.iter_mut().next_back()
            }
            /// Borrows the element at the given index.
            pub fn get(&self, index: usize) -> Option<&T> {
                if let Some((value, _punct)) = self.inner.get(index) {
                    Some(value)
                } else if index == self.inner.len() {
                    self.last.as_deref()
                } else {
                    None
                }
            }
            /// Mutably borrows the element at the given index.
            pub fn get_mut(&mut self, index: usize) -> Option<&mut T>
            {
                let inner_len = self.inner.len();
                if let Some((value, _punct)) = self.inner.get_mut(index) {
                    Some(value)
                } else if index == inner_len {
                    self.last.as_deref_mut()
                } else {
                    None
                }
            }
            /// Returns an iterator over borrowed syntax tree nodes of type `&T`.
            pub fn iter(&self) -> Iter<T> {
                Iter {
                    inner: Box::new(NoDrop::new(PrivateIter {
                        inner: self.inner.iter(),
                        last: self.last.as_ref().map(Box::as_ref).into_iter(),
                    })),
                }
            }
            /// Returns an iterator over mutably borrowed syntax tree nodes of type
            /// `&mut T`.
            pub fn iter_mut(&mut self) -> IterMut<T> {
                IterMut {
                    inner: Box::new(NoDrop::new(PrivateIterMut {
                        inner: self.inner.iter_mut(),
                        last: self.last.as_mut().map(Box::as_mut).into_iter(),
                    })),
                }
            }
            /// Returns an iterator over the contents of this sequence as borrowed
            /// punctuated pairs.
            pub fn pairs(&self) -> Pairs<T, P> {
                Pairs {
                    inner: self.inner.iter(),
                    last: self.last.as_ref().map(Box::as_ref).into_iter(),
                }
            }
            /// Returns an iterator over the contents of this sequence as mutably
            /// borrowed punctuated pairs.
            pub fn pairs_mut(&mut self) -> PairsMut<T, P> {
                PairsMut {
                    inner: self.inner.iter_mut(),
                    last: self.last.as_mut().map(Box::as_mut).into_iter(),
                }
            }
            /// Returns an iterator over the contents of this sequence as owned
            /// punctuated pairs.
            pub fn into_pairs(self) -> IntoPairs<T, P> {
                IntoPairs {
                    inner: self.inner.into_iter(),
                    last: self.last.map(|t| *t).into_iter(),
                }
            }
            /// Appends a syntax tree node onto the end of this punctuated sequence. The
            /// sequence must already have a trailing punctuation, or be empty.
            /// punctuation.
            pub fn push_value(&mut self, value: T) {
                assert!(
                    self.empty_or_trailing(),
                    "Punctuated::push_value: cannot push value if Punctuated is missing trailing punctuation",
                );

                self.last = Some(Box::new(value));
            }
            /// Appends a trailing punctuation onto the end of this punctuated sequence.
            /// The sequence must be non-empty and must not already have trailing
            /// punctuation.
            pub fn push_punct(&mut self, punctuation: P) {
                assert!(
                    self.last.is_some(),
                    "Punctuated::push_punct: cannot push punctuation if Punctuated is empty or already has trailing punctuation",
                );

                let last = self.last.take().unwrap();
                self.inner.push((*last, punctuation));
            }
            /// Removes the last punctuated pair from this sequence, or `None` if the
            /// sequence is empty.
            pub fn pop(&mut self) -> Option<Pair<T, P>> {
                if self.last.is_some() {
                    self.last.take().map(|t| Pair::End(*t))
                } else {
                    self.inner.pop().map(|(t, p)| Pair::Punctuated(t, p))
                }
            }
            /// Removes the trailing punctuation from this punctuated sequence, or
            /// `None` if there isn't any.
            pub fn pop_punct(&mut self) -> Option<P> {
                if self.last.is_some() {
                    None
                } else {
                    let (t, p) = self.inner.pop()?;
                    self.last = Some(Box::new(t));
                    Some(p)
                }
            }
            /// Determines whether this punctuated sequence ends with a trailing
            /// punctuation.
            pub fn trailing_punct(&self) -> bool
            {
                self.last.is_none() && !self.is_empty()
            }
            /// Returns true if either this `Punctuated` is empty, or it has a trailing
            /// punctuation.
            pub fn empty_or_trailing(&self) -> bool
            {
                self.last.is_none()
            }
            /// Appends a syntax tree node onto the end of this punctuated sequence.
            /// the given value of type `T`.
            pub fn push(&mut self, value: T) where
                P: Default,
            {
                if !self.empty_or_trailing() {
                    self.push_punct(Default::default());
                }
                self.push_value(value);
            }
            /// Inserts an element at position `index`.
            pub fn insert(&mut self, index: usize, value: T) where
                P: Default,
            {
                assert!(
                    index <= self.len(),
                    "Punctuated::insert: index out of range",
                );

                if index == self.len() {
                    self.push(value);
                } else {
                    self.inner.insert(index, (value, Default::default()));
                }
            }
            /// Clears the sequence of all values and punctuation, making it empty.
            pub fn clear(&mut self)
            {
                self.inner.clear();
                self.last = None;
            }
            /// Parses zero or more occurrences of `T` separated by punctuation of type
            /// `P`, with optional trailing punctuation.
             
                pub fn parse_terminated(input: ParseStream) -> Result<Self> where
                T: Parse,
                P: Parse,
            {
                Self::parse_terminated_with(input, T::parse)
            }
            /// Parses zero or more occurrences of `T` using the given parse function,
            /// separated by punctuation of type `P`, with optional trailing
            /// punctuation.
             
                pub fn parse_terminated_with<'a>(
                input: ParseStream<'a>,
                parser: fn(ParseStream<'a>) -> Result<T>,
            ) -> Result<Self> where
                P: Parse,
            {
                let mut punctuated = Punctuated::new();

                loop {
                    if input.is_empty() {
                        break;
                    }
                    let value = parser(input)?;
                    punctuated.push_value(value);
                    if input.is_empty() {
                        break;
                    }
                    let punct = input.parse()?;
                    punctuated.push_punct(punct);
                }

                Ok(punctuated)
            }
            /// Parses one or more occurrences of `T` separated by punctuation of type
            /// `P`, not accepting trailing punctuation.
            pub fn parse_separated_nonempty(input: ParseStream) -> Result<Self> where
                T: Parse,
                P: Token + Parse,
            {
                Self::parse_separated_nonempty_with(input, T::parse)
            }
            /// Parses one or more occurrences of `T` using the given parse function,
            /// separated by punctuation of type `P`, not accepting trailing
            /// punctuation.
            pub fn parse_separated_nonempty_with<'a>(
                input: ParseStream<'a>,
                parser: fn(ParseStream<'a>) -> Result<T>,
            ) -> Result<Self> where
                P: Token + Parse,
            {
                let mut punctuated = Punctuated::new();

                loop {
                    let value = parser(input)?;
                    punctuated.push_value(value);
                    if !P::peek(input.cursor()) {
                        break;
                    }
                    let punct = input.parse()?;
                    punctuated.push_punct(punct);
                }

                Ok(punctuated)
            }
        }

        impl<T, P> Clone for Punctuated<T, P> where
        T: Clone,
        P: Clone,
        {
            fn clone(&self) -> Self {
                Punctuated {
                    inner: self.inner.clone(),
                    last: self.last.clone(),
                }
            }

            fn clone_from(&mut self, other: &Self)
            {
                self.inner.clone_from(&other.inner);
                self.last.clone_from(&other.last);
            }
        }

        impl<T, P> Eq for Punctuated<T, P> where
        T: Eq,
        P: Eq,
        {
        }

        impl<T, P> PartialEq for Punctuated<T, P> where
        T: PartialEq,
        P: PartialEq,
        {
            fn eq(&self, other: &Self) -> bool
        {
                let Punctuated { inner, last } = self;
                *inner == other.inner && *last == other.last
            }
        }

        impl<T, P> Hash for Punctuated<T, P> where
        T: Hash,
        P: Hash,
        {
            fn hash<H: Hasher>(&self, state: &mut H) {
                let Punctuated { inner, last } = self;
                inner.hash(state);
                last.hash(state);
            }
        }

        impl<T: Debug, P: Debug> Debug for Punctuated<T, P> 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                let mut list = f.debug_list();
                for (t, p) in &self.inner {
                    list.entry(t);
                    list.entry(p);
                }
                if let Some(last) = &self.last {
                    list.entry(last);
                }
                list.finish()
            }
        }

        impl<T, P> FromIterator<T> for Punctuated<T, P> where
        P: Default,
        {
            fn from_iter<I: IntoIterator<Item = T>>(i: I) -> Self {
                let mut ret = Punctuated::new();
                ret.extend(i);
                ret
            }
        }

        impl<T, P> Extend<T> for Punctuated<T, P> where
        P: Default,
        {
            fn extend<I: IntoIterator<Item = T>>(&mut self, i: I) {
                for value in i {
                    self.push(value);
                }
            }
        }

        impl<T, P> FromIterator<Pair<T, P>> for Punctuated<T, P> 
        {
            fn from_iter<I: IntoIterator<Item = Pair<T, P>>>(i: I) -> Self {
                let mut ret = Punctuated::new();
                do_extend(&mut ret, i.into_iter());
                ret
            }
        }

        impl<T, P> Extend<Pair<T, P>> for Punctuated<T, P> where
        P: Default,
        {
            fn extend<I: IntoIterator<Item = Pair<T, P>>>(&mut self, i: I) {
                if !self.empty_or_trailing() {
                    self.push_punct(P::default());
                }
                do_extend(self, i.into_iter());
            }
        }

        fn do_extend<T, P, I>(punctuated: &mut Punctuated<T, P>, i: I) where
        I: Iterator<Item = Pair<T, P>>,
        {
            let mut nomore = false;
            for pair in i {
                if nomore {
                    panic!("punctuated extended with items after a Pair::End");
                }
                match pair {
                    Pair::Punctuated(a, b) => punctuated.inner.push((a, b)),
                    Pair::End(a) => {
                        punctuated.last = Some(Box::new(a));
                        nomore = true;
                    }
                }
            }
        }

        impl<T, P> IntoIterator for Punctuated<T, P> 
        {
            type Item = T;
            type IntoIter = IntoIter<T>;

            fn into_iter(self) -> Self::IntoIter {
                let mut elements = Vec::with_capacity(self.len());
                elements.extend(self.inner.into_iter().map(|pair| pair.0));
                elements.extend(self.last.map(|t| *t));

                IntoIter {
                    inner: elements.into_iter(),
                }
            }
        }

        impl<'a, T, P> IntoIterator for &'a Punctuated<T, P> 
        {
            type Item = &'a T;
            type IntoIter = Iter<'a, T>;

            fn into_iter(self) -> Self::IntoIter {
                Punctuated::iter(self)
            }
        }

        impl<'a, T, P> IntoIterator for &'a mut Punctuated<T, P> 
        {
            type Item = &'a mut T;
            type IntoIter = IterMut<'a, T>;

            fn into_iter(self) -> Self::IntoIter {
                Punctuated::iter_mut(self)
            }
        }

        impl<T, P> Default for Punctuated<T, P> 
        {
            fn default() -> Self {
                Punctuated::new()
            }
        }
        /// An iterator over borrowed pairs of type `Pair<&T, &P>`.
        pub struct Pairs<'a, T: 'a, P: 'a> 
        {
            inner: slice::Iter<'a, (T, P)>,
            last: option::IntoIter<&'a T>,
        }

        impl<'a, T, P> Iterator for Pairs<'a, T, P> 
        {
            type Item = Pair<&'a T, &'a P>;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|(t, p)| Pair::Punctuated(t, p))
                    .or_else(|| self.last.next().map(Pair::End))
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<'a, T, P> DoubleEndedIterator for Pairs<'a, T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .map(Pair::End)
                    .or_else(|| self.inner.next_back().map(|(t, p)| Pair::Punctuated(t, p)))
            }
        }

        impl<'a, T, P> ExactSizeIterator for Pairs<'a, T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }

        impl<'a, T, P> Clone for Pairs<'a, T, P> 
        {
            fn clone(&self) -> Self {
                Pairs {
                    inner: self.inner.clone(),
                    last: self.last.clone(),
                }
            }
        }
        /// An iterator over mutably borrowed pairs of type `Pair<&mut T, &mut P>`.
        pub struct PairsMut<'a, T: 'a, P: 'a> 
        {
            inner: slice::IterMut<'a, (T, P)>,
            last: option::IntoIter<&'a mut T>,
        }

        impl<'a, T, P> Iterator for PairsMut<'a, T, P> 
        {
            type Item = Pair<&'a mut T, &'a mut P>;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|(t, p)| Pair::Punctuated(t, p))
                    .or_else(|| self.last.next().map(Pair::End))
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<'a, T, P> DoubleEndedIterator for PairsMut<'a, T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .map(Pair::End)
                    .or_else(|| self.inner.next_back().map(|(t, p)| Pair::Punctuated(t, p)))
            }
        }

        impl<'a, T, P> ExactSizeIterator for PairsMut<'a, T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }
        /// An iterator over owned pairs of type `Pair<T, P>`.
        pub struct IntoPairs<T, P> 
        {
            inner: vec::IntoIter<(T, P)>,
            last: option::IntoIter<T>,
        }

        impl<T, P> Iterator for IntoPairs<T, P> 
        {
            type Item = Pair<T, P>;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|(t, p)| Pair::Punctuated(t, p))
                    .or_else(|| self.last.next().map(Pair::End))
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<T, P> DoubleEndedIterator for IntoPairs<T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .map(Pair::End)
                    .or_else(|| self.inner.next_back().map(|(t, p)| Pair::Punctuated(t, p)))
            }
        }

        impl<T, P> ExactSizeIterator for IntoPairs<T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }

        impl<T, P> Clone for IntoPairs<T, P> where
        T: Clone,
        P: Clone
        {
            fn clone(&self) -> Self {
                IntoPairs {
                    inner: self.inner.clone(),
                    last: self.last.clone(),
                }
            }
        }
        /// An iterator over owned values of type `T`.
        pub struct IntoIter<T> 
        {
            inner: vec::IntoIter<T>,
        }

        impl<T> Iterator for IntoIter<T> 
        {
            type Item = T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner.next()
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<T> DoubleEndedIterator for IntoIter<T> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.inner.next_back()
            }
        }

        impl<T> ExactSizeIterator for IntoIter<T> 
        {
            fn len(&self) -> usize
            {
                self.inner.len()
            }
        }

        impl<T> Clone for IntoIter<T> where
        T: Clone,
        {
            fn clone(&self) -> Self {
                IntoIter {
                    inner: self.inner.clone(),
                }
            }
        }
        /// An iterator over borrowed values of type `&T`.
        pub struct Iter<'a, T: 'a> 
        {
            inner: Box<NoDrop<dyn IterTrait<'a, T> + 'a>>,
        }

        trait IterTrait<'a, T: 'a>: Iterator<Item = &'a T> + DoubleEndedIterator + ExactSizeIterator 
        {
            fn clone_box(&self) -> Box<NoDrop<dyn IterTrait<'a, T> + 'a>>;
        }

        struct PrivateIter<'a, T: 'a, P: 'a> {
            inner: slice::Iter<'a, (T, P)>,
            last: option::IntoIter<&'a T>,
        }

        impl<'a, T, P> TrivialDrop for PrivateIter<'a, T, P> where
        slice::Iter<'a, (T, P)>: TrivialDrop,
        option::IntoIter<&'a T>: TrivialDrop,
        {}

        pub fn empty_punctuated_iter<'a, T>() -> Iter<'a, T> 
        {
            Iter {
                inner: Box::new(NoDrop::new(iter::empty())),
            }
        }

        impl<'a, T> Clone for Iter<'a, T> 
        {
            fn clone(&self) -> Self {
                Iter {
                    inner: self.inner.clone_box(),
                }
            }
        }

        impl<'a, T> Iterator for Iter<'a, T> 
        {
            type Item = &'a T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner.next()
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<'a, T> DoubleEndedIterator for Iter<'a, T> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.inner.next_back()
            }
        }

        impl<'a, T> ExactSizeIterator for Iter<'a, T> 
        {
            fn len(&self) -> usize
            {
                self.inner.len()
            }
        }

        impl<'a, T, P> Iterator for PrivateIter<'a, T, P> 
        {
            type Item = &'a T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|pair| &pair.0)
                    .or_else(|| self.last.next())
            }
        }

        impl<'a, T, P> DoubleEndedIterator for PrivateIter<'a, T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .or_else(|| self.inner.next_back().map(|pair| &pair.0))
            }
        }

        impl<'a, T, P> ExactSizeIterator for PrivateIter<'a, T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }

        impl<'a, T, P> Clone for PrivateIter<'a, T, P> 
        {
            fn clone(&self) -> Self {
                PrivateIter {
                    inner: self.inner.clone(),
                    last: self.last.clone(),
                }
            }
        }

        impl<'a, T, I> IterTrait<'a, T> for I where
        T: 'a,
        I: DoubleEndedIterator<Item = &'a T>
        + ExactSizeIterator<Item = &'a T>
        + Clone
        + TrivialDrop
        + 'a
        {
            fn clone_box(&self) -> Box<NoDrop<dyn IterTrait<'a, T> + 'a>> {
                Box::new(NoDrop::new(self.clone()))
            }
        }
        /// An iterator over mutably borrowed values of type `&mut T`.
        pub struct IterMut<'a, T: 'a>
        {
            inner: Box<NoDrop<dyn IterMutTrait<'a, T, Item = &'a mut T> + 'a>>,
        }

        trait IterMutTrait<'a, T: 'a>
        : DoubleEndedIterator<Item = &'a mut T> 
        + ExactSizeIterator<Item = &'a mut T>
        {
        }

        struct PrivateIterMut<'a, T: 'a, P: 'a>
        {
            inner: slice::IterMut<'a, (T, P)>,
            last: option::IntoIter<&'a mut T>,
        }

        impl<'a, T, P> TrivialDrop for PrivateIterMut<'a, T, P> where
        slice::IterMut<'a, (T, P)>: TrivialDrop,
        option::IntoIter<&'a mut T>: TrivialDrop
        {
        }

        pub fn empty_punctuated_iter_mut<'a, T>() -> IterMut<'a, T> 
        {
            IterMut {
                inner: Box::new(NoDrop::new(iter::empty())),
            }
        }

        impl<'a, T> Iterator for IterMut<'a, T> 
        {
            type Item = &'a mut T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner.next()
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<'a, T> DoubleEndedIterator for IterMut<'a, T> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.inner.next_back()
            }
        }

        impl<'a, T> ExactSizeIterator for IterMut<'a, T> 
        {
            fn len(&self) -> usize
            {
                self.inner.len()
            }
        }

        impl<'a, T, P> Iterator for PrivateIterMut<'a, T, P> 
        {
            type Item = &'a mut T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|pair| &mut pair.0)
                    .or_else(|| self.last.next())
            }
        }

        impl<'a, T, P> DoubleEndedIterator for PrivateIterMut<'a, T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .or_else(|| self.inner.next_back().map(|pair| &mut pair.0))
            }
        }

        impl<'a, T, P> ExactSizeIterator for PrivateIterMut<'a, T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }

        impl<'a, T, I> IterMutTrait<'a, T> for I where
        T: 'a,
        I: DoubleEndedIterator<Item = &'a mut T> 
        + ExactSizeIterator<Item = &'a mut T> + 'a
        {
        }
        /// A single syntax tree node of type `T` followed by its trailing punctuation of type `P` if any.
        pub enum Pair<T, P> 
        {
            Punctuated(T, P),
            End(T),
        }

        impl<T, P> Pair<T, P> 
        {
            /// Extracts the syntax tree node from this punctuated pair, discarding the
            /// following punctuation.
            pub fn into_value(self) -> T {
                match self {
                    Pair::Punctuated(t, _) | Pair::End(t) => t,
                }
            }
            /// Borrows the syntax tree node from this punctuated pair.
            pub fn value(&self) -> &T {
                match self {
                    Pair::Punctuated(t, _) | Pair::End(t) => t,
                }
            }
            /// Mutably borrows the syntax tree node from this punctuated pair.
            pub fn value_mut(&mut self) -> &mut T {
                match self {
                    Pair::Punctuated(t, _) | Pair::End(t) => t,
                }
            }
            /// Borrows the punctuation from this punctuated pair, unless this pair is
            /// the final one and there is no trailing punctuation.
            pub fn punct(&self) -> Option<&P>
            {
                match self {
                    Pair::Punctuated(_, p) => Some(p),
                    Pair::End(_) => None,
                }
            }
            /// Mutably borrows the punctuation from this punctuated pair, unless the
            /// pair is the final one and there is no trailing punctuation.
            pub fn punct_mut(&mut self) -> Option<&mut P>
            {
                match self {
                    Pair::Punctuated(_, p) => Some(p),
                    Pair::End(_) => None,
                }
            }
            /// Creates a punctuated pair out of a syntax tree node and an optional
            /// following punctuation.
            pub fn new(t: T, p: Option<P>) -> Self {
                match p {
                    Some(p) => Pair::Punctuated(t, p),
                    None => Pair::End(t),
                }
            }
            /// Produces this punctuated pair as a tuple of syntax tree node and
            /// optional following punctuation.
            pub fn into_tuple(self) -> (T, Option<P>) {
                match self {
                    Pair::Punctuated(t, p) => (t, Some(p)),
                    Pair::End(t) => (t, None),
                }
            }
        }

        impl<T, P> Pair<&T, &P> 
        {
            pub fn cloned(self) -> Pair<T, P> where
                T: Clone,
                P: Clone,
            {
                match self {
                    Pair::Punctuated(t, p) => Pair::Punctuated(t.clone(), p.clone()),
                    Pair::End(t) => Pair::End(t.clone()),
                }
            }
        }

        impl<T, P> Clone for Pair<T, P> where
        T: Clone,
        P: Clone
        {
            fn clone(&self) -> Self {
                match self {
                    Pair::Punctuated(t, p) => Pair::Punctuated(t.clone(), p.clone()),
                    Pair::End(t) => Pair::End(t.clone()),
                }
            }
        }

        impl<T, P> Copy for Pair<T, P> where
        T: Copy,
        P: Copy,
        {
        }

        impl<T, P> Index<usize> for Punctuated<T, P>
        {
            type Output = T;

            fn index(&self, index: usize) -> &Self::Output {
                if index == self.len() - 1 {
                    match &self.last {
                        Some(t) => t,
                        None => &self.inner[index].0,
                    }
                } else {
                    &self.inner[index].0
                }
            }
        }

        impl<T, P> IndexMut<usize> for Punctuated<T, P>
        {
            fn index_mut(&mut self, index: usize) -> &mut Self::Output {
                if index == self.len() - 1 {
                    match &mut self.last {
                        Some(t) => t,
                        None => &mut self.inner[index].0,
                    }
                } else {
                    &mut self.inner[index].0
                }
            }
        }
        
        pub fn fold<T, P, V, F>
        (
            punctuated: Punctuated<T, P>,
            fold: &mut V,
            mut f: F,
        ) -> Punctuated<T, P> where
        V: ?Sized,
        F: FnMut(&mut V, T) -> T,
        {
            Punctuated {
                inner: punctuated
                    .inner
                    .into_iter()
                    .map(|(t, p)| (f(fold, t), p))
                    .collect(),
                last: match punctuated.last {
                    Some(t) => Some(Box::new(f(fold, *t))),
                    None => None,
                },
            }
        }

        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::punctuated::{Pair, Punctuated},
                *,
            };
            
            impl<T, P> ToTokens for Punctuated<T, P> where
            T: ToTokens,
            P: ToTokens
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.pairs());
                }
            }

            impl<T, P> ToTokens for Pair<T, P> where
            T: ToTokens,
            P: ToTokens
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self
                    {
                        Pair::Punctuated(a, b) => {
                            a.to_tokens(tokens);
                            b.to_tokens(tokens);
                        }
                        Pair::End(a) => a.to_tokens(tokens),
                    }
                }
            }
        }
    }
    
    pub mod restriction
    {
        use ::
        {
            syntax::
            {
                path::{ Path },
                token,
            },
            *,
        };
        /*
        */
        ast_enum!
        {
            /// The visibility level of an item: inherited or `pub` or
            /// `pub(restricted)`.
            pub enum Visibility {
                /// A public visibility level: `pub`.
                Public(Token![pub]),
                /// A visibility level restricted to some path: `pub(self)` or
                /// `pub(super)` or `pub(crate)` or `pub(in some::module)`.
                Restricted(VisRestricted),
                /// An inherited visibility, which usually means private.
                Inherited,
            }
        }

        ast_struct!
        {
            /// A visibility level restricted to some path: `pub(self)` or
            /// `pub(super)` or `pub(crate)` or `pub(in some::module)`.
            pub struct VisRestricted {
                pub pub_token: Token![pub],
                pub paren_token: token::Paren,
                pub in_token: Option<Token![in]>,
                pub path: Box<Path>,
            }
        }

        ast_enum!
        {
            /// Unused, but reserved for RFC 3323 restrictions.
            #[non_exhaustive]
            pub enum FieldMutability {
                None,

               
                //
               
                //
               
               
               
               
               
               
            }
        }

        pub mod parsing 
        {
            use ::
            {
                syntax::
                {
                    error::Result,
                    ext::IdentExt as _,
                    ident::Ident,
                    parse::discouraged::Speculative as _,
                    parse::{Parse, ParseStream},
                    path::Path,
                    restriction::{VisRestricted, Visibility},
                    token,
                },
                *,
            };
            
            impl Parse for Visibility
            {
                fn parse(input: ParseStream) -> Result<Self> {
                   
                   
                    if input.peek(token::Group) {
                        let ahead = input.fork();
                        let group = ::syntax::group::parse_group(&ahead)?;
                        if group.content.is_empty() {
                            input.advance_to(&ahead);
                            return Ok(Visibility::Inherited);
                        }
                    }

                    if input.peek(Token![pub]) {
                        Self::parse_pub(input)
                    } else {
                        Ok(Visibility::Inherited)
                    }
                }
            }

            impl Visibility
            {
                fn parse_pub(input: ParseStream) -> Result<Self>
                {
                    let pub_token = input.parse::<Token![pub]>()?;

                    if input.peek(token::Paren) {
                        let ahead = input.fork();

                        let content;
                        let paren_token = parenthesized!(content in ahead);
                        if content.peek(Token![crate])
                            || content.peek(Token![self])
                            || content.peek(Token![super])
                        {
                            let path = content.call(Ident::parse_any)?;

                           
                           
                           
                           
                            if content.is_empty() {
                                input.advance_to(&ahead);
                                return Ok(Visibility::Restricted(VisRestricted {
                                    pub_token,
                                    paren_token,
                                    in_token: None,
                                    path: Box::new(Path::from(path)),
                                }));
                            }
                        } else if content.peek(Token![in]) {
                            let in_token: Token![in] = content.parse()?;
                            let path = content.call(Path::parse_mod_style)?;

                            input.advance_to(&ahead);
                            return Ok(Visibility::Restricted(VisRestricted {
                                pub_token,
                                paren_token,
                                in_token: Some(in_token),
                                path: Box::new(path),
                            }));
                        }
                    }

                    Ok(Visibility::Public(pub_token))
                }

                pub fn is_some(&self) -> bool
                {
                    match self
                    {
                        Visibility::Inherited => false,
                        _ => true,
                    }
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::ToTokens,
                syntax::
                {
                    path,
                    path::printing::PathStyle,
                    restriction::{VisRestricted, Visibility},
                },
                *,
            };
            
            impl ToTokens for Visibility
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    match self
                    {
                        Visibility::Public(pub_token) => pub_token.to_tokens(tokens),
                        Visibility::Restricted(vis_restricted) => vis_restricted.to_tokens(tokens),
                        Visibility::Inherited => {}
                    }
                }
            }

            impl ToTokens for VisRestricted
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    self.pub_token.to_tokens(tokens);
                    self.paren_token.surround(tokens, |tokens|
                    {
                        self.in_token.to_tokens(tokens);
                        path::printing::print_path(tokens, &self.path, PathStyle::Mod);
                    });
                }
            }
        }
    } pub use self::restriction::{ FieldMutability, VisRestricted, Visibility };

    mod sealed
    {
        use ::
        {
            *,
        };
        /*
        */        
        pub mod lookahead
        {
            pub trait Sealed: Copy {}
        }
    }
    
    pub mod scan_expr
    {
        use ::
        {
            process::macros::{ Delimiter, Ident, Spacing, TokenTree },
            syntax::
            {
                parse::{ParseStream, Result},
                Token, AngleBracketedGenericArguments, BinOp, Expr, ExprPath, Lifetime, Lit, Type,
            },
            *,
        };
        /*
        */
        enum Input
        {
            Keyword(&'static str),
            Punct(&'static str),
            ConsumeAny,
            ConsumeBinOp,
            ConsumeBrace,
            ConsumeDelimiter,
            ConsumeIdent,
            ConsumeLifetime,
            ConsumeLiteral,
            ConsumeNestedBrace,
            ExpectPath,
            ExpectTurbofish,
            ExpectType,
            CanBeginExpr,
            Otherwise,
            Empty,
        } use self::Input::{ * };

        enum Action {
            SetState(&'static [(Input, Action)]),
            IncDepth,
            DecDepth,
            Finish,
        } use self::Action::{ * };

        static INIT: [(Input, Action); 28] = 
        [
            (ConsumeDelimiter, SetState(&POSTFIX)),
            (Keyword("async"), SetState(&ASYNC)),
            (Keyword("break"), SetState(&BREAK_LABEL)),
            (Keyword("const"), SetState(&CONST)),
            (Keyword("continue"), SetState(&CONTINUE)),
            (Keyword("for"), SetState(&FOR)),
            (Keyword("if"), IncDepth),
            (Keyword("let"), SetState(&PATTERN)),
            (Keyword("loop"), SetState(&BLOCK)),
            (Keyword("match"), IncDepth),
            (Keyword("move"), SetState(&CLOSURE)),
            (Keyword("return"), SetState(&RETURN)),
            (Keyword("static"), SetState(&CLOSURE)),
            (Keyword("unsafe"), SetState(&BLOCK)),
            (Keyword("while"), IncDepth),
            (Keyword("yield"), SetState(&RETURN)),
            (Keyword("_"), SetState(&POSTFIX)),
            (Punct("!"), SetState(&INIT)),
            (Punct("#"), SetState(&[(ConsumeDelimiter, SetState(&INIT))])),
            (Punct("&"), SetState(&REFERENCE)),
            (Punct("*"), SetState(&INIT)),
            (Punct("-"), SetState(&INIT)),
            (Punct("..="), SetState(&INIT)),
            (Punct(".."), SetState(&RANGE)),
            (Punct("|"), SetState(&CLOSURE_ARGS)),
            (ConsumeLifetime, SetState(&[(Punct(":"), SetState(&INIT))])),
            (ConsumeLiteral, SetState(&POSTFIX)),
            (ExpectPath, SetState(&PATH)),
        ];

        static POSTFIX: [(Input, Action); 10] = 
        [
            (Keyword("as"), SetState(&[(ExpectType, SetState(&POSTFIX))])),
            (Punct("..="), SetState(&INIT)),
            (Punct(".."), SetState(&RANGE)),
            (Punct("."), SetState(&DOT)),
            (Punct("?"), SetState(&POSTFIX)),
            (ConsumeBinOp, SetState(&INIT)),
            (Punct("="), SetState(&INIT)),
            (ConsumeNestedBrace, SetState(&IF_THEN)),
            (ConsumeDelimiter, SetState(&POSTFIX)),
            (Empty, Finish),
        ];

        static ASYNC: [(Input, Action); 3] = 
        [
            (Keyword("move"), SetState(&ASYNC)),
            (Punct("|"), SetState(&CLOSURE_ARGS)),
            (ConsumeBrace, SetState(&POSTFIX)),
        ];

        static BLOCK: [(Input, Action); 1] = [(ConsumeBrace, SetState(&POSTFIX))];

        static BREAK_LABEL: [(Input, Action); 2] =
        [
            (ConsumeLifetime, SetState(&BREAK_VALUE)),
            (Otherwise, SetState(&BREAK_VALUE)),
        ];

        static BREAK_VALUE: [(Input, Action); 3] =
        [
            (ConsumeNestedBrace, SetState(&IF_THEN)),
            (CanBeginExpr, SetState(&INIT)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        static CLOSURE: [(Input, Action); 7] =
        [
            (Keyword("async"), SetState(&CLOSURE)),
            (Keyword("move"), SetState(&CLOSURE)),
            (Punct(","), SetState(&CLOSURE)),
            (Punct(">"), SetState(&CLOSURE)),
            (Punct("|"), SetState(&CLOSURE_ARGS)),
            (ConsumeLifetime, SetState(&CLOSURE)),
            (ConsumeIdent, SetState(&CLOSURE)),
        ];

        static CLOSURE_ARGS: [(Input, Action); 2] =
        [
            (Punct("|"), SetState(&CLOSURE_RET)),
            (ConsumeAny, SetState(&CLOSURE_ARGS)),
        ];

        static CLOSURE_RET: [(Input, Action); 2] =
        [
            (Punct("->"), SetState(&[(ExpectType, SetState(&BLOCK))])),
            (Otherwise, SetState(&INIT)),
        ];

        static CONST: [(Input, Action); 2] =
        [
            (Punct("|"), SetState(&CLOSURE_ARGS)),
            (ConsumeBrace, SetState(&POSTFIX)),
        ];

        static CONTINUE: [(Input, Action); 2] =
        [
            (ConsumeLifetime, SetState(&POSTFIX)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        static DOT: [(Input, Action); 3] =
        [
            (Keyword("await"), SetState(&POSTFIX)),
            (ConsumeIdent, SetState(&METHOD)),
            (ConsumeLiteral, SetState(&POSTFIX)),
        ];

        static FOR: [(Input, Action); 2] =
        [
            (Punct("<"), SetState(&CLOSURE)),
            (Otherwise, SetState(&PATTERN)),
        ];

        static IF_ELSE: [(Input, Action); 2] = [(Keyword("if"), SetState(&INIT)), (ConsumeBrace, DecDepth)];
        static IF_THEN: [(Input, Action); 2] = [(Keyword("else"), SetState(&IF_ELSE)), (Otherwise, DecDepth)];

        static METHOD: [(Input, Action); 1] = [(ExpectTurbofish, SetState(&POSTFIX))];

        static PATH: [(Input, Action); 4] =
        [
            (Punct("!="), SetState(&INIT)),
            (Punct("!"), SetState(&INIT)),
            (ConsumeNestedBrace, SetState(&IF_THEN)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        static PATTERN: [(Input, Action); 15] =
        [
            (ConsumeDelimiter, SetState(&PATTERN)),
            (Keyword("box"), SetState(&PATTERN)),
            (Keyword("in"), IncDepth),
            (Keyword("mut"), SetState(&PATTERN)),
            (Keyword("ref"), SetState(&PATTERN)),
            (Keyword("_"), SetState(&PATTERN)),
            (Punct("!"), SetState(&PATTERN)),
            (Punct("&"), SetState(&PATTERN)),
            (Punct("..="), SetState(&PATTERN)),
            (Punct(".."), SetState(&PATTERN)),
            (Punct("="), SetState(&INIT)),
            (Punct("@"), SetState(&PATTERN)),
            (Punct("|"), SetState(&PATTERN)),
            (ConsumeLiteral, SetState(&PATTERN)),
            (ExpectPath, SetState(&PATTERN)),
        ];

        static RANGE: [(Input, Action); 6] =
        [
            (Punct("..="), SetState(&INIT)),
            (Punct(".."), SetState(&RANGE)),
            (Punct("."), SetState(&DOT)),
            (ConsumeNestedBrace, SetState(&IF_THEN)),
            (Empty, Finish),
            (Otherwise, SetState(&INIT)),
        ];

        static RAW: [(Input, Action); 3] =
        [
            (Keyword("const"), SetState(&INIT)),
            (Keyword("mut"), SetState(&INIT)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        static REFERENCE: [(Input, Action); 3] = 
        [
            (Keyword("mut"), SetState(&INIT)),
            (Keyword("raw"), SetState(&RAW)),
            (Otherwise, SetState(&INIT)),
        ];

        static RETURN: [(Input, Action); 2] = 
        [
            (CanBeginExpr, SetState(&INIT)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        pub fn scan_expr(input: ParseStream) -> Result<()>
        {
            let mut state = INIT.as_slice();
            let mut depth = 0usize;
            'table: loop {
                for rule in state {
                    if match rule.0 {
                        Input::Keyword(expected) => input.step(|cursor| match cursor.ident() {
                            Some((ident, rest)) if ident == expected => Ok((true, rest)),
                            _ => Ok((false, *cursor)),
                        })?,
                        Input::Punct(expected) => input.step(|cursor| {
                            let begin = *cursor;
                            let mut cursor = begin;
                            for (i, ch) in expected.chars().enumerate() {
                                match cursor.punct() {
                                    Some((punct, _)) if punct.as_char() != ch => break,
                                    Some((_, rest)) if i == expected.len() - 1 => {
                                        return Ok((true, rest));
                                    }
                                    Some((punct, rest)) if punct.spacing() == Spacing::Joint => {
                                        cursor = rest;
                                    }
                                    _ => break,
                                }
                            }
                            Ok((false, begin))
                        })?,
                        Input::ConsumeAny => input.parse::<Option<TokenTree>>()?.is_some(),
                        Input::ConsumeBinOp => input.parse::<BinOp>().is_ok(),
                        Input::ConsumeBrace | Input::ConsumeNestedBrace => {
                            (matches!(rule.0, Input::ConsumeBrace) || depth > 0)
                                && input.step(|cursor| match cursor.group(Delimiter::Brace) {
                                    Some((_inside, _span, rest)) => Ok((true, rest)),
                                    None => Ok((false, *cursor)),
                                })?
                        }
                        Input::ConsumeDelimiter => input.step(|cursor| match cursor.any_group() {
                            Some((_inside, _delimiter, _span, rest)) => Ok((true, rest)),
                            None => Ok((false, *cursor)),
                        })?,
                        Input::ConsumeIdent => input.parse::<Option<Ident>>()?.is_some(),
                        Input::ConsumeLifetime => input.parse::<Option<Lifetime>>()?.is_some(),
                        Input::ConsumeLiteral => input.parse::<Option<Lit>>()?.is_some(),
                        Input::ExpectPath => {
                            input.parse::<ExprPath>()?;
                            true
                        }
                        Input::ExpectTurbofish => {
                            if input.peek(Token![::]) {
                                input.parse::<AngleBracketedGenericArguments>()?;
                            }
                            true
                        }
                        Input::ExpectType => {
                            Type::without_plus(input)?;
                            true
                        }
                        Input::CanBeginExpr => Expr::peek(input),
                        Input::Otherwise => true,
                        Input::Empty => input.is_empty() || input.peek(Token![,]),
                    } {
                        state = match rule.1 {
                            Action::SetState(next) => next,
                            Action::IncDepth => (depth += 1, &INIT).1,
                            Action::DecDepth => (depth -= 1, &POSTFIX).1,
                            Action::Finish => return if depth == 0 { Ok(()) } else { break },
                        };
                        continue 'table;
                    }
                }
                return Err(input.error("unsupported expression"));
            }
        }
    }

    pub mod span
    {
        use ::
        {
            process::macros::{ extra::DelimSpan, Delimiter, Group, Span, TokenStream },
            *,
        };
        /*
        */
        pub trait IntoSpans<S> 
        {
            fn into_spans(self) -> S;
        }

        impl IntoSpans<Span> for Span 
        {
            fn into_spans(self) -> Span { self }
        }

        impl IntoSpans<[Span; 1]> for Span 
        {
            fn into_spans(self) -> [Span; 1] { [self] }
        }

        impl IntoSpans<[Span; 2]> for Span 
        {
            fn into_spans(self) -> [Span; 2] { [self, self] }
        }

        impl IntoSpans<[Span; 3]> for Span 
        {
            fn into_spans(self) -> [Span; 3] { [self, self, self] }
        }

        impl IntoSpans<[Span; 1]> for [Span; 1] 
        {
            fn into_spans(self) -> [Span; 1] { self }
        }

        impl IntoSpans<[Span; 2]> for [Span; 2] 
        {
            fn into_spans(self) -> [Span; 2] { self }
        }

        impl IntoSpans<[Span; 3]> for [Span; 3] 
        {
            fn into_spans(self) -> [Span; 3] { self }
        }

        impl IntoSpans<DelimSpan> for Span 
        {
            fn into_spans(self) -> DelimSpan
            {
                let mut group = Group::new(Delimiter::None, TokenStream::new());
                group.set_span(self);
                group.delim_span()
            }
        }

        impl IntoSpans<DelimSpan> for DelimSpan 
        {
            fn into_spans(self) -> DelimSpan { self }
        }
    }
    
    pub mod spanned
    {
        /*!
        A trait that can provide the `Span` of the complete contents of a syntax tree nodes . */
        use ::
        {
            process::macros::Span,
            quote::spanned::{ Spanned as ToTokens },
            *,
        };
        /*
        */
        /// A trait that can provide the `Span` of the complete contents of a syntax tree node.
        pub trait Spanned: private::Sealed
        {
            /// Returns a `Span` covering the complete contents of this syntax tree node,
            /// or [`Span::call_site()`] if this node is empty.
            fn span(&self) -> Span;
        }

        impl<T: ?Sized + ToTokens> Spanned for T {
            fn span(&self) -> Span
            {
                self.__span()
            }
        }

        mod private
        {
            use ::
            {
                syntax::spanned::ToTokens,
                *,
            };
            
            pub trait Sealed {}
            impl<T: ?Sized + ToTokens> Sealed for T {}
            
            impl Sealed for ::syntax::QSelf {}
        }
    }
    
    pub mod stmt
    {
        use ::
        {
            syntax::
            {
                attr::Attribute,
                expr::Expr,
                item::Item,
                mac::Macro,
                pat::Pat,
                token,
            },
            *,
        };
        /*
        */
        ast_struct! 
        {
            /// A braced block containing Rust statements.
            pub struct Block
            {
                pub brace_token: token::Brace,
                /// Statements in a block
                pub stmts: Vec<Stmt>,
            }
        }

        ast_enum! 
        {
            /// A statement, usually ending in a semicolon.
            pub enum Stmt 
            {
                /// A local (let) binding.
                Local(Local),
                /// An item definition.
                Item(Item),
                /// Expression, with or without trailing semicolon.
                Expr(Expr, Option<Token![;]>),
                /// A macro invocation in statement position.
                Macro(StmtMacro),
            }
        }

        ast_struct! 
        {
            /// A local `let` binding: `let x: u64 = s.parse()?;`.
            pub struct Local
            {
                pub attrs: Vec<Attribute>,
                pub let_token: Token![let],
                pub pat: Pat,
                pub init: Option<LocalInit>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// The expression assigned in a local `let` binding, including optional diverging `else` block.
            pub struct LocalInit {
                pub eq_token: Token![=],
                pub expr: Box<Expr>,
                pub diverge: Option<(Token![else], Box<Expr>)>,
            }
        }

        ast_struct! 
        {
            /// A macro invocation in statement position.
            pub struct StmtMacro
            {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::TokenStream,
                syntax::
                {
                    attr::Attribute,
                    classify,
                    error::Result,
                    expr::{Expr, ExprBlock, ExprMacro},
                    ident::Ident,
                    item,
                    mac::{self, Macro},
                    parse::discouraged::Speculative as _,
                    parse::{Parse, ParseStream},
                    pat::{Pat, PatType},
                    path::Path,
                    stmt::{Block, Local, LocalInit, Stmt, StmtMacro},
                    token,
                    ty::Type,
                },
                *,
            };
            
            struct AllowNoSemi(bool);

            impl Block
            {
                /// Parse the body of a block as zero or more statements, possibly
                /// including one trailing expression.
                    pub fn parse_within(input: ParseStream) -> Result<Vec<Stmt>> {
                    let mut stmts = Vec::new();
                    loop {
                        while let semi @ Some(_) = input.parse()? {
                            stmts.push(Stmt::Expr(Expr::Verbatim(TokenStream::new()), semi));
                        }
                        if input.is_empty() {
                            break;
                        }
                        let stmt = parse_stmt(input, AllowNoSemi(true))?;
                        let requires_semicolon = match &stmt {
                            Stmt::Expr(stmt, None) => classify::requires_semi_to_be_stmt(stmt),
                            Stmt::Macro(stmt) => {
                                stmt.semi_token.is_none() && !stmt.mac.delimiter.is_brace()
                            }
                            Stmt::Local(_) | Stmt::Item(_) | Stmt::Expr(_, Some(_)) => false,
                        };
                        stmts.push(stmt);
                        if input.is_empty() {
                            break;
                        } else if requires_semicolon {
                            return Err(input.error("unexpected token, expected `;`"));
                        }
                    }
                    Ok(stmts)
                }
            }

            impl Parse for Block
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(Block {
                        brace_token: braced!(content in input),
                        stmts: content.call(Block::parse_within)?,
                    })
                }
            }

            impl Parse for Stmt
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_nosemi = AllowNoSemi(false);
                    parse_stmt(input, allow_nosemi)
                }
            }

            fn parse_stmt(input: ParseStream, allow_nosemi: AllowNoSemi) -> Result<Stmt>
            {
                let begin = input.fork();
                let attrs = input.call(Attribute::parse_outer)?;

               
               
                let ahead = input.fork();
                let mut is_item_macro = false;
                if let Ok(path) = ahead.call(Path::parse_mod_style) {
                    if ahead.peek(Token![!]) {
                        if ahead.peek2(Ident) || ahead.peek2(Token![try]) {
                            is_item_macro = true;
                        } else if ahead.peek2(token::Brace)
                            && !(ahead.peek3(Token![.]) && !ahead.peek3(Token![..])
                                || ahead.peek3(Token![?]))
                        {
                            input.advance_to(&ahead);
                            return stmt_mac(input, attrs, path).map(Stmt::Macro);
                        }
                    }
                }

                if input.peek(Token![let]) && !input.peek(token::Group) {
                    stmt_local(input, attrs).map(Stmt::Local)
                } else if input.peek(Token![pub])
                    || input.peek(Token![crate]) && !input.peek2(Token![::])
                    || input.peek(Token![extern])
                    || input.peek(Token![use])
                    || input.peek(Token![static])
                        && (input.peek2(Token![mut])
                            || input.peek2(Ident)
                                && !(input.peek2(Token![async])
                                    && (input.peek3(Token![move]) || input.peek3(Token![|]))))
                    || input.peek(Token![const])
                        && !(input.peek2(token::Brace)
                            || input.peek2(Token![static])
                            || input.peek2(Token![async])
                                && !(input.peek3(Token![unsafe])
                                    || input.peek3(Token![extern])
                                    || input.peek3(Token![fn]))
                            || input.peek2(Token![move])
                            || input.peek2(Token![|]))
                    || input.peek(Token![unsafe]) && !input.peek2(token::Brace)
                    || input.peek(Token![async])
                        && (input.peek2(Token![unsafe])
                            || input.peek2(Token![extern])
                            || input.peek2(Token![fn]))
                    || input.peek(Token![fn])
                    || input.peek(Token![mod])
                    || input.peek(Token![type])
                    || input.peek(Token![struct])
                    || input.peek(Token![enum])
                    || input.peek(Token![union]) && input.peek2(Ident)
                    || input.peek(Token![auto]) && input.peek2(Token![trait])
                    || input.peek(Token![trait])
                    || input.peek(Token![default])
                        && (input.peek2(Token![unsafe]) || input.peek2(Token![impl]))
                    || input.peek(Token![impl])
                    || input.peek(Token![macro])
                    || is_item_macro
                {
                    let item = item::parsing::parse_rest_of_item(begin, attrs, input)?;
                    Ok(Stmt::Item(item))
                } else {
                    stmt_expr(input, allow_nosemi, attrs)
                }
            }

            fn stmt_mac(input: ParseStream, attrs: Vec<Attribute>, path: Path) -> Result<StmtMacro>
            {
                let bang_token: Token![!] = input.parse()?;
                let (delimiter, tokens) = mac::parse_delimiter(input)?;
                let semi_token: Option<Token![;]> = input.parse()?;

                Ok(StmtMacro {
                    attrs,
                    mac: Macro {
                        path,
                        bang_token,
                        delimiter,
                        tokens,
                    },
                    semi_token,
                })
            }

            fn stmt_local(input: ParseStream, attrs: Vec<Attribute>) -> Result<Local>
            {
                let let_token: Token![let] = input.parse()?;

                let mut pat = Pat::parse_single(input)?;
                if input.peek(Token![:]) {
                    let colon_token: Token![:] = input.parse()?;
                    let ty: Type = input.parse()?;
                    pat = Pat::Type(PatType {
                        attrs: Vec::new(),
                        pat: Box::new(pat),
                        colon_token,
                        ty: Box::new(ty),
                    });
                }

                let init = if let Some(eq_token) = input.parse()? {
                    let eq_token: Token![=] = eq_token;
                    let expr: Expr = input.parse()?;

                    let diverge = if !classify::expr_trailing_brace(&expr) && input.peek(Token![else]) {
                        let else_token: Token![else] = input.parse()?;
                        let diverge = ExprBlock {
                            attrs: Vec::new(),
                            label: None,
                            block: input.parse()?,
                        };
                        Some((else_token, Box::new(Expr::Block(diverge))))
                    } else {
                        None
                    };

                    Some(LocalInit {
                        eq_token,
                        expr: Box::new(expr),
                        diverge,
                    })
                } else {
                    None
                };

                let semi_token: Token![;] = input.parse()?;

                Ok(Local {
                    attrs,
                    let_token,
                    pat,
                    init,
                    semi_token,
                })
            }

            fn stmt_expr
            (
                input: ParseStream,
                allow_nosemi: AllowNoSemi,
                mut attrs: Vec<Attribute>,
            ) -> Result<Stmt>
            {
                let mut e = Expr::parse_with_earlier_boundary_rule(input)?;

                let mut attr_target = &mut e;
                loop {
                    attr_target = match attr_target {
                        Expr::Assign(e) => &mut e.left,
                        Expr::Binary(e) => &mut e.left,
                        Expr::Cast(e) => &mut e.expr,
                        Expr::Array(_)
                        | Expr::Async(_)
                        | Expr::Await(_)
                        | Expr::Block(_)
                        | Expr::Break(_)
                        | Expr::Call(_)
                        | Expr::Closure(_)
                        | Expr::Const(_)
                        | Expr::Continue(_)
                        | Expr::Field(_)
                        | Expr::ForLoop(_)
                        | Expr::Group(_)
                        | Expr::If(_)
                        | Expr::Index(_)
                        | Expr::Infer(_)
                        | Expr::Let(_)
                        | Expr::Lit(_)
                        | Expr::Loop(_)
                        | Expr::Macro(_)
                        | Expr::Match(_)
                        | Expr::MethodCall(_)
                        | Expr::Paren(_)
                        | Expr::Path(_)
                        | Expr::Range(_)
                        | Expr::RawAddr(_)
                        | Expr::Reference(_)
                        | Expr::Repeat(_)
                        | Expr::Return(_)
                        | Expr::Struct(_)
                        | Expr::Try(_)
                        | Expr::TryBlock(_)
                        | Expr::Tuple(_)
                        | Expr::Unary(_)
                        | Expr::Unsafe(_)
                        | Expr::While(_)
                        | Expr::Yield(_)
                        | Expr::Verbatim(_) => break,
                    };
                }
                attrs.extend(attr_target.replace_attrs(Vec::new()));
                attr_target.replace_attrs(attrs);

                let semi_token: Option<Token![;]> = input.parse()?;

                match e {
                    Expr::Macro(ExprMacro { attrs, mac })
                        if semi_token.is_some() || mac.delimiter.is_brace() =>
                    {
                        return Ok(Stmt::Macro(StmtMacro {
                            attrs,
                            mac,
                            semi_token,
                        }));
                    }
                    _ => {}
                }

                if semi_token.is_some() {
                    Ok(Stmt::Expr(e, semi_token))
                } else if allow_nosemi.0 || !classify::requires_semi_to_be_stmt(&e) {
                    Ok(Stmt::Expr(e, None))
                } else {
                    Err(input.error("expected semicolon"))
                }
            }
        }
        
        pub mod printing 
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    classify,
                    expr::{self, Expr},
                    fixup::FixupContext,
                    stmt::{Block, Local, Stmt, StmtMacro},
                    token,
                },
                *,
            };

            impl ToTokens for Block
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(&self.stmts);
                    });
                }
            }

            impl ToTokens for Stmt
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        Stmt::Local(local) => local.to_tokens(tokens),
                        Stmt::Item(item) => item.to_tokens(tokens),
                        Stmt::Expr(expr, semi) => {
                            expr::printing::print_expr(expr, tokens, FixupContext::new_stmt());
                            semi.to_tokens(tokens);
                        }
                        Stmt::Macro(mac) => mac.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for Local
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    expr::printing::outer_attrs_to_tokens(&self.attrs, tokens);
                    self.let_token.to_tokens(tokens);
                    self.pat.to_tokens(tokens);
                    if let Some(init) = &self.init {
                        init.eq_token.to_tokens(tokens);
                        expr::printing::print_subexpression(
                            &init.expr,
                            init.diverge.is_some() && classify::expr_trailing_brace(&init.expr),
                            tokens,
                            FixupContext::NONE,
                        );
                        if let Some((else_token, diverge)) = &init.diverge {
                            else_token.to_tokens(tokens);
                            match &**diverge {
                                Expr::Block(diverge) => diverge.to_tokens(tokens),
                                _ => token::Brace::default().surround(tokens, |tokens| {
                                    expr::printing::print_expr(diverge, tokens, FixupContext::new_stmt());
                                }),
                            }
                        }
                    }
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for StmtMacro
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    expr::printing::outer_attrs_to_tokens(&self.attrs, tokens);
                    self.mac.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }
        }
    } pub use self::stmt::{Block, Local, LocalInit, Stmt, StmtMacro};

    pub mod thread
    {
        use ::
        {
            fmt::{ self, Debug },
            thread::{ self, ThreadId },
            *,
        };
        /*
        */
        /// ThreadBound is a Sync-maker and Send-maker that allows accessing a value of type T 
        /// only from the original thread on which the ThreadBound was constructed.
        pub struct ThreadBound<T>
        {
            value: T,
            thread_id: ThreadId,
        }

        unsafe impl<T> Sync for ThreadBound<T> {}
        
        unsafe impl<T: Copy> Send for ThreadBound<T> {}

        impl<T> ThreadBound<T> 
        {
            pub fn new(value: T) -> Self {
                ThreadBound {
                    value,
                    thread_id: thread::current().id(),
                }
            }

            pub fn get(&self) -> Option<&T> {
                if thread::current().id() == self.thread_id {
                    Some(&self.value)
                } else {
                    None
                }
            }
        }

        impl<T: Debug> Debug for ThreadBound<T> 
        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                match self.get() {
                    Some(value) => Debug::fmt(value, formatter),
                    None => formatter.write_str("unknown"),
                }
            }
        }
        
        impl<T: Copy> Copy for ThreadBound<T> {}

        impl<T: Copy> Clone for ThreadBound<T> 
        {
            fn clone(&self) -> Self {
                *self
            }
        }
    }
    
    pub mod tt    
    {
        use ::
        {
            hash::{ Hash, Hasher },
            process::macros::{ Delimiter, TokenStream, TokenTree },
            *,
        };
        /*
        */
        pub struct TokenTreeHelper<'a>(pub &'a TokenTree);

        impl<'a> PartialEq for TokenTreeHelper<'a>
        {
            fn eq(&self, other: &Self) -> bool
        {
                use ::process::macros::Spacing;

                match (self.0, other.0) {
                    (TokenTree::Group(g1), TokenTree::Group(g2)) => {
                        match (g1.delimiter(), g2.delimiter()) {
                            (Delimiter::Parenthesis, Delimiter::Parenthesis)
                            | (Delimiter::Brace, Delimiter::Brace)
                            | (Delimiter::Bracket, Delimiter::Bracket)
                            | (Delimiter::None, Delimiter::None) => {}
                            _ => return false,
                        }

                        let s1 = g1.stream().into_iter();
                        let mut s2 = g2.stream().into_iter();

                        for item1 in s1 {
                            let item2 = match s2.next() {
                                Some(item) => item,
                                None => return false,
                            };
                            if TokenTreeHelper(&item1) != TokenTreeHelper(&item2) {
                                return false;
                            }
                        }
                        s2.next().is_none()
                    }
                    (TokenTree::Punct(o1), TokenTree::Punct(o2)) => {
                        o1.as_char() == o2.as_char()
                            && match (o1.spacing(), o2.spacing()) {
                                (Spacing::Alone, Spacing::Alone) | (Spacing::Joint, Spacing::Joint) => true,
                                _ => false,
                            }
                    }
                    (TokenTree::Literal(l1), TokenTree::Literal(l2)) => l1.to_string() == l2.to_string(),
                    (TokenTree::Ident(s1), TokenTree::Ident(s2)) => s1 == s2,
                    _ => false,
                }
            }
        }

        impl<'a> Hash for TokenTreeHelper<'a>
        {
            fn hash<H: Hasher>(&self, h: &mut H) {
                use ::process::macros::Spacing;

                match self.0 {
                    TokenTree::Group(g) => {
                        0u8.hash(h);
                        match g.delimiter() {
                            Delimiter::Parenthesis => 0u8.hash(h),
                            Delimiter::Brace => 1u8.hash(h),
                            Delimiter::Bracket => 2u8.hash(h),
                            Delimiter::None => 3u8.hash(h),
                        }

                        for item in g.stream() {
                            TokenTreeHelper(&item).hash(h);
                        }
                        0xFFu8.hash(h);
                    }
                    TokenTree::Punct(op) => {
                        1u8.hash(h);
                        op.as_char().hash(h);
                        match op.spacing() {
                            Spacing::Alone => 0u8.hash(h),
                            Spacing::Joint => 1u8.hash(h),
                        }
                    }
                    TokenTree::Literal(lit) => (2u8, lit.to_string()).hash(h),
                    TokenTree::Ident(word) => (3u8, word).hash(h),
                }
            }
        }

        pub struct TokenStreamHelper<'a>(pub &'a TokenStream);

        impl<'a> PartialEq for TokenStreamHelper<'a>
        {
            fn eq(&self, other: &Self) -> bool
        {
                let left = self.0.clone().into_iter().collect::<Vec<_>>();
                let right = other.0.clone().into_iter().collect::<Vec<_>>();
                if left.len() != right.len() {
                    return false;
                }
                for (a, b) in left.into_iter().zip(right) {
                    if TokenTreeHelper(&a) != TokenTreeHelper(&b) {
                        return false;
                    }
                }
                true
            }
        }

        impl<'a> Hash for TokenStreamHelper<'a>
        {
            fn hash<H: Hasher>(&self, state: &mut H) {
                let tts = self.0.clone().into_iter().collect::<Vec<_>>();
                tts.len().hash(state);
                for tt in tts {
                    TokenTreeHelper(&tt).hash(state);
                }
            }
        }
    }
    
    pub mod ty
    {
        use ::
        {
            process::macros::{ TokenStream },
            syntax::
            {
                attr::Attribute,
                expr::Expr,
                generics::{BoundLifetimes, TypeParamBound},
                ident::Ident,
                lifetime::Lifetime,
                lit::LitStr,
                mac::Macro,
                path::{Path, QSelf},
                punctuated::Punctuated,
                token,
            },
            *,
        };
        /*
        */
        ast_enum_of_structs! 
        {
            /// The possible types that a Rust value could have.
            #[non_exhaustive]
            pub enum Type {
                /// A fixed size array type: `[T; n]`.
                Array(TypeArray),
                /// A bare function type: `fn(usize) -> bool`.
                BareFn(TypeBareFn),
                /// A type contained within invisible delimiters.
                Group(TypeGroup),
                /// An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or
                /// a lifetime.
                ImplTrait(TypeImplTrait),
                /// Indication that a type should be inferred by the compiler: `_`.
                Infer(TypeInfer),
                /// A macro in the type position.
                Macro(TypeMacro),
                /// The never type: `!`.
                Never(TypeNever),
                /// A parenthesized type equivalent to the inner type.
                Paren(TypeParen),
                /// A path like `std::slice::Iter`, optionally qualified with a
                /// self-type as in `<Vec<T> as SomeTrait>::Associated`.
                Path(TypePath),
                /// A raw pointer type: `*const T` or `*mut T`.
                Ptr(TypePtr),
                /// A reference type: `&'a T` or `&'a mut T`.
                Reference(TypeReference),
                /// A dynamically sized slice type: `[T]`.
                Slice(TypeSlice),
                /// A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a
                /// trait or a lifetime.
                TraitObject(TypeTraitObject),
                /// A tuple type: `(A, B, C, String)`.
                Tuple(TypeTuple),
                /// Tokens in type position not interpreted by Syn.
                Verbatim(TokenStream),
            }
        }

        ast_struct! {
            /// A fixed size array type: `[T; n]`.
            pub struct TypeArray {
                pub bracket_token: token::Bracket,
                pub elem: Box<Type>,
                pub semi_token: Token![;],
                pub len: Expr,
            }
        }

        ast_struct! {
            /// A bare function type: `fn(usize) -> bool`.
            pub struct TypeBareFn {
                pub lifetimes: Option<BoundLifetimes>,
                pub unsafety: Option<Token![unsafe]>,
                pub abi: Option<Abi>,
                pub fn_token: Token![fn],
                pub paren_token: token::Paren,
                pub inputs: Punctuated<BareFnArg, Token![,]>,
                pub variadic: Option<BareVariadic>,
                pub output: ReturnType,
            }
        }

        ast_struct! {
            /// A type contained within invisible delimiters.
            pub struct TypeGroup {
                pub group_token: token::Group,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or
            /// a lifetime.
            pub struct TypeImplTrait {
                pub impl_token: Token![impl],
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
            }
        }

        ast_struct! {
            /// Indication that a type should be inferred by the compiler: `_`.
            pub struct TypeInfer {
                pub underscore_token: Token![_],
            }
        }

        ast_struct! {
            /// A macro in the type position.
            pub struct TypeMacro {
                pub mac: Macro,
            }
        }

        ast_struct! {
            /// The never type: `!`.
            pub struct TypeNever {
                pub bang_token: Token![!],
            }
        }

        ast_struct! {
            /// A parenthesized type equivalent to the inner type.
            pub struct TypeParen {
                pub paren_token: token::Paren,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// A path like `std::slice::Iter`, optionally qualified with a
            /// self-type as in `<Vec<T> as SomeTrait>::Associated`.
            pub struct TypePath {
                pub qself: Option<QSelf>,
                pub path: Path,
            }
        }

        ast_struct! {
            /// A raw pointer type: `*const T` or `*mut T`.
            pub struct TypePtr {
                pub star_token: Token![*],
                pub const_token: Option<Token![const]>,
                pub mutability: Option<Token![mut]>,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// A reference type: `&'a T` or `&'a mut T`.
            pub struct TypeReference {
                pub and_token: Token![&],
                pub lifetime: Option<Lifetime>,
                pub mutability: Option<Token![mut]>,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// A dynamically sized slice type: `[T]`.
            pub struct TypeSlice {
                pub bracket_token: token::Bracket,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a
            /// trait or a lifetime.
            pub struct TypeTraitObject {
                pub dyn_token: Option<Token![dyn]>,
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
            }
        }

        ast_struct! {
            /// A tuple type: `(A, B, C, String)`.
            pub struct TypeTuple {
                pub paren_token: token::Paren,
                pub elems: Punctuated<Type, Token![,]>,
            }
        }

        ast_struct! {
            /// The binary interface of a function: `extern "C"`.
            pub struct Abi {
                pub extern_token: Token![extern],
                pub name: Option<LitStr>,
            }
        }

        ast_struct! {
            /// An argument in a function type: the `usize` in `fn(usize) -> bool`.
            pub struct BareFnArg {
                pub attrs: Vec<Attribute>,
                pub name: Option<(Ident, Token![:])>,
                pub ty: Type,
            }
        }

        ast_struct! {
            /// The variadic argument of a function pointer like `fn(usize, ...)`.
            pub struct BareVariadic {
                pub attrs: Vec<Attribute>,
                pub name: Option<(Ident, Token![:])>,
                pub dots: Token![...],
                pub comma: Option<Token![,]>,
            }
        }

        ast_enum!
        {
            /// Return type of a function signature.
            pub enum ReturnType
            {
                /// Return type is not specified.
                Default,
                /// A particular type is returned.
                Type(Token![->], Box<Type>),
            }
        }
         
        pub mod parsing
        {
            use ::
            {
                process::macros::Span,
                syntax::
                {
                    attr::{ Attribute },
                    error::{ self, Result },
                    ext::{ IdentExt as _ },
                    generics::{ BoundLifetimes, TraitBound, TraitBoundModifier, TypeParamBound },
                    ident::{ Ident },
                    lifetime::{ Lifetime },
                    mac::{ self, Macro },
                    parse::{ Parse, ParseStream },
                    path::{ self, Path, PathArguments, QSelf },
                    punctuated::{ Punctuated },
                    ty::
                    {
                        Abi, BareFnArg, BareVariadic, ReturnType, Type, TypeArray, TypeBareFn, TypeGroup,
                        TypeImplTrait, TypeInfer, TypeMacro, TypeNever, TypeParen, TypePath, TypePtr,
                        TypeReference, TypeSlice, TypeTraitObject, TypeTuple,
                    },
                    token, verbatim,
                },
                *,
            };
            /*
            */
            impl Parse for Type
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = true;
                    let allow_group_generic = true;
                    ambig_ty(input, allow_plus, allow_group_generic)
                }
            }

            impl Type
            {
                /// In some positions, types may not contain the `+` character, to disambiguate them.
                pub fn without_plus(input: ParseStream) -> Result<Self>
                {
                    let allow_plus = false;
                    let allow_group_generic = true;
                    ambig_ty(input, allow_plus, allow_group_generic)
                }
            }

            pub fn ambig_ty(
                input: ParseStream,
                allow_plus: bool,
                allow_group_generic: bool,
            ) -> Result<Type>
            {
                let begin = input.fork();

                if input.peek(token::Group) {
                    let mut group: TypeGroup = input.parse()?;
                    if input.peek(Token![::]) && input.peek3(Ident::peek_any) {
                        if let Type::Path(mut ty) = *group.elem {
                            Path::parse_rest(input, &mut ty.path, false)?;
                            return Ok(Type::Path(ty));
                        } else {
                            return Ok(Type::Path(TypePath {
                                qself: Some(QSelf {
                                    lt_token: Token![<](group.group_token.span),
                                    position: 0,
                                    as_token: None,
                                    gt_token: Token![>](group.group_token.span),
                                    ty: group.elem,
                                }),
                                path: Path::parse_helper(input, false)?,
                            }));
                        }
                    } else if input.peek(Token![<]) && allow_group_generic
                        || input.peek(Token![::]) && input.peek3(Token![<])
                    {
                        if let Type::Path(mut ty) = *group.elem {
                            let arguments = &mut ty.path.segments.last_mut().unwrap().arguments;
                            if arguments.is_none() {
                                *arguments = PathArguments::AngleBracketed(input.parse()?);
                                Path::parse_rest(input, &mut ty.path, false)?;
                                return Ok(Type::Path(ty));
                            } else {
                                group.elem = Box::new(Type::Path(ty));
                            }
                        }
                    }
                    return Ok(Type::Group(group));
                }

                let mut lifetimes = None::<BoundLifetimes>;
                let mut lookahead = input.lookahead1();
                if lookahead.peek(Token![for]) {
                    lifetimes = input.parse()?;
                    lookahead = input.lookahead1();
                    if !lookahead.peek(Ident)
                        && !lookahead.peek(Token![fn])
                        && !lookahead.peek(Token![unsafe])
                        && !lookahead.peek(Token![extern])
                        && !lookahead.peek(Token![super])
                        && !lookahead.peek(Token![self])
                        && !lookahead.peek(Token![Self])
                        && !lookahead.peek(Token![crate])
                        || input.peek(Token![dyn])
                    {
                        return Err(lookahead.error());
                    }
                }

                if lookahead.peek(token::Paren) {
                    let content;
                    let paren_token = parenthesized!(content in input);
                    if content.is_empty() {
                        return Ok(Type::Tuple(TypeTuple {
                            paren_token,
                            elems: Punctuated::new(),
                        }));
                    }
                    if content.peek(Lifetime) {
                        return Ok(Type::Paren(TypeParen {
                            paren_token,
                            elem: Box::new(Type::TraitObject(content.parse()?)),
                        }));
                    }
                    if content.peek(Token![?]) {
                        return Ok(Type::TraitObject(TypeTraitObject {
                            dyn_token: None,
                            bounds: {
                                let mut bounds = Punctuated::new();
                                bounds.push_value(TypeParamBound::Trait(TraitBound {
                                    paren_token: Some(paren_token),
                                    ..content.parse()?
                                }));
                                while let Some(plus) = input.parse()? {
                                    bounds.push_punct(plus);
                                    bounds.push_value({
                                        let allow_precise_capture = false;
                                        let allow_const = false;
                                        TypeParamBound::parse_single(
                                            input,
                                            allow_precise_capture,
                                            allow_const,
                                        )?
                                    });
                                }
                                bounds
                            },
                        }));
                    }
                    let mut first: Type = content.parse()?;
                    if content.peek(Token![,]) {
                        return Ok(Type::Tuple(TypeTuple {
                            paren_token,
                            elems: {
                                let mut elems = Punctuated::new();
                                elems.push_value(first);
                                elems.push_punct(content.parse()?);
                                while !content.is_empty() {
                                    elems.push_value(content.parse()?);
                                    if content.is_empty() {
                                        break;
                                    }
                                    elems.push_punct(content.parse()?);
                                }
                                elems
                            },
                        }));
                    }
                    if allow_plus && input.peek(Token![+]) {
                        loop {
                            let first = match first {
                                Type::Path(TypePath { qself: None, path }) => {
                                    TypeParamBound::Trait(TraitBound {
                                        paren_token: Some(paren_token),
                                        modifier: TraitBoundModifier::None,
                                        lifetimes: None,
                                        path,
                                    })
                                }
                                Type::TraitObject(TypeTraitObject {
                                    dyn_token: None,
                                    bounds,
                                }) => {
                                    if bounds.len() > 1 || bounds.trailing_punct() {
                                        first = Type::TraitObject(TypeTraitObject {
                                            dyn_token: None,
                                            bounds,
                                        });
                                        break;
                                    }
                                    match bounds.into_iter().next().unwrap() {
                                        TypeParamBound::Trait(trait_bound) => {
                                            TypeParamBound::Trait(TraitBound {
                                                paren_token: Some(paren_token),
                                                ..trait_bound
                                            })
                                        }
                                        other @ (TypeParamBound::Lifetime(_)
                                        | TypeParamBound::PreciseCapture(_)
                                        | TypeParamBound::Verbatim(_)) => other,
                                    }
                                }
                                _ => break,
                            };
                            return Ok(Type::TraitObject(TypeTraitObject {
                                dyn_token: None,
                                bounds: {
                                    let mut bounds = Punctuated::new();
                                    bounds.push_value(first);
                                    while let Some(plus) = input.parse()? {
                                        bounds.push_punct(plus);
                                        bounds.push_value({
                                            let allow_precise_capture = false;
                                            let allow_const = false;
                                            TypeParamBound::parse_single(
                                                input,
                                                allow_precise_capture,
                                                allow_const,
                                            )?
                                        });
                                    }
                                    bounds
                                },
                            }));
                        }
                    }
                    Ok(Type::Paren(TypeParen {
                        paren_token,
                        elem: Box::new(first),
                    }))
                } else if lookahead.peek(Token![fn])
                    || lookahead.peek(Token![unsafe])
                    || lookahead.peek(Token![extern])
                {
                    let mut bare_fn: TypeBareFn = input.parse()?;
                    bare_fn.lifetimes = lifetimes;
                    Ok(Type::BareFn(bare_fn))
                } else if lookahead.peek(Ident)
                    || input.peek(Token![super])
                    || input.peek(Token![self])
                    || input.peek(Token![Self])
                    || input.peek(Token![crate])
                    || lookahead.peek(Token![::])
                    || lookahead.peek(Token![<])
                {
                    let ty: TypePath = input.parse()?;
                    if ty.qself.is_some() {
                        return Ok(Type::Path(ty));
                    }

                    if input.peek(Token![!]) && !input.peek(Token![!=]) && ty.path.is_mod_style() {
                        let bang_token: Token![!] = input.parse()?;
                        let (delimiter, tokens) = mac::parse_delimiter(input)?;
                        return Ok(Type::Macro(TypeMacro {
                            mac: Macro {
                                path: ty.path,
                                bang_token,
                                delimiter,
                                tokens,
                            },
                        }));
                    }

                    if lifetimes.is_some() || allow_plus && input.peek(Token![+]) {
                        let mut bounds = Punctuated::new();
                        bounds.push_value(TypeParamBound::Trait(TraitBound {
                            paren_token: None,
                            modifier: TraitBoundModifier::None,
                            lifetimes,
                            path: ty.path,
                        }));
                        if allow_plus {
                            while input.peek(Token![+]) {
                                bounds.push_punct(input.parse()?);
                                if !(input.peek(Ident::peek_any)
                                    || input.peek(Token![::])
                                    || input.peek(Token![?])
                                    || input.peek(Lifetime)
                                    || input.peek(token::Paren))
                                {
                                    break;
                                }
                                bounds.push_value({
                                    let allow_precise_capture = false;
                                    let allow_const = false;
                                    TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                                });
                            }
                        }
                        return Ok(Type::TraitObject(TypeTraitObject {
                            dyn_token: None,
                            bounds,
                        }));
                    }

                    Ok(Type::Path(ty))
                } else if lookahead.peek(Token![dyn]) {
                    let dyn_token: Token![dyn] = input.parse()?;
                    let dyn_span = dyn_token.span;
                    let star_token: Option<Token![*]> = input.parse()?;
                    let bounds = TypeTraitObject::parse_bounds(dyn_span, input, allow_plus)?;
                    Ok(if star_token.is_some() {
                        Type::Verbatim(verbatim::between(&begin, input))
                    } else {
                        Type::TraitObject(TypeTraitObject {
                            dyn_token: Some(dyn_token),
                            bounds,
                        })
                    })
                } else if lookahead.peek(token::Bracket) {
                    let content;
                    let bracket_token = bracketed!(content in input);
                    let elem: Type = content.parse()?;
                    if content.peek(Token![;]) {
                        Ok(Type::Array(TypeArray {
                            bracket_token,
                            elem: Box::new(elem),
                            semi_token: content.parse()?,
                            len: content.parse()?,
                        }))
                    } else {
                        Ok(Type::Slice(TypeSlice {
                            bracket_token,
                            elem: Box::new(elem),
                        }))
                    }
                } else if lookahead.peek(Token![*]) {
                    input.parse().map(Type::Ptr)
                } else if lookahead.peek(Token![&]) {
                    input.parse().map(Type::Reference)
                } else if lookahead.peek(Token![!]) && !input.peek(Token![=]) {
                    input.parse().map(Type::Never)
                } else if lookahead.peek(Token![impl]) {
                    TypeImplTrait::parse(input, allow_plus).map(Type::ImplTrait)
                } else if lookahead.peek(Token![_]) {
                    input.parse().map(Type::Infer)
                } else if lookahead.peek(Lifetime) {
                    input.parse().map(Type::TraitObject)
                } else {
                    Err(lookahead.error())
                }
            }

            impl Parse for TypeSlice
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(TypeSlice {
                        bracket_token: bracketed!(content in input),
                        elem: content.parse()?,
                    })
                }
            }

            impl Parse for TypeArray
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(TypeArray {
                        bracket_token: bracketed!(content in input),
                        elem: content.parse()?,
                        semi_token: content.parse()?,
                        len: content.parse()?,
                    })
                }
            }

            impl Parse for TypePtr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let star_token: Token![*] = input.parse()?;

                    let lookahead = input.lookahead1();
                    let (const_token, mutability) = if lookahead.peek(Token![const]) {
                        (Some(input.parse()?), None)
                    } else if lookahead.peek(Token![mut]) {
                        (None, Some(input.parse()?))
                    } else {
                        return Err(lookahead.error());
                    };

                    Ok(TypePtr {
                        star_token,
                        const_token,
                        mutability,
                        elem: Box::new(input.call(Type::without_plus)?),
                    })
                }
            }

            impl Parse for TypeReference
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (TypeReference {
                        and_token: input.parse()?,
                        lifetime: input.parse()?,
                        mutability: input.parse()?,
                       
                        elem: Box::new(input.call(Type::without_plus)?),
                    })
                }
            }

            impl Parse for TypeBareFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let args;
                    let mut variadic = None;

                    Ok(TypeBareFn {
                        lifetimes: input.parse()?,
                        unsafety: input.parse()?,
                        abi: input.parse()?,
                        fn_token: input.parse()?,
                        paren_token: parenthesized!(args in input),
                        inputs: {
                            let mut inputs = Punctuated::new();

                            while !args.is_empty() {
                                let attrs = args.call(Attribute::parse_outer)?;

                                if inputs.empty_or_trailing()
                                    && (args.peek(Token![...])
                                        || (args.peek(Ident) || args.peek(Token![_]))
                                            && args.peek2(Token![:])
                                            && args.peek3(Token![...]))
                                {
                                    variadic = Some(parse_bare_variadic(&args, attrs)?);
                                    break;
                                }

                                let allow_self = inputs.is_empty();
                                let arg = parse_bare_fn_arg(&args, allow_self)?;
                                inputs.push_value(BareFnArg { attrs, ..arg });
                                if args.is_empty() {
                                    break;
                                }

                                let comma = args.parse()?;
                                inputs.push_punct(comma);
                            }

                            inputs
                        },
                        variadic,
                        output: input.call(ReturnType::without_plus)?,
                    })
                }
            }

            impl Parse for TypeNever
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (TypeNever {
                        bang_token: input.parse()?,
                    })
                }
            }

            impl Parse for TypeInfer
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (TypeInfer {
                        underscore_token: input.parse()?,
                    })
                }
            }

            impl Parse for TypeTuple
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    let paren_token = parenthesized!(content in input);

                    if content.is_empty() {
                        return Ok(TypeTuple {
                            paren_token,
                            elems: Punctuated::new(),
                        });
                    }

                    let first: Type = content.parse()?;
                    Ok(TypeTuple {
                        paren_token,
                        elems: {
                            let mut elems = Punctuated::new();
                            elems.push_value(first);
                            elems.push_punct(content.parse()?);
                            while !content.is_empty() {
                                elems.push_value(content.parse()?);
                                if content.is_empty() {
                                    break;
                                }
                                elems.push_punct(content.parse()?);
                            }
                            elems
                        },
                    })
                }
            }

            impl Parse for TypeMacro
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (TypeMacro {
                        mac: input.parse()?,
                    })
                }
            }

            impl Parse for TypePath
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let expr_style = false;
                    let (qself, path) = path::parsing::qpath(input, expr_style)?;
                    Ok(TypePath { qself, path })
                }
            }

            impl ReturnType {
                    pub fn without_plus(input: ParseStream) -> Result<Self> {
                    let allow_plus = false;
                    Self::parse(input, allow_plus)
                }

                pub fn parse(input: ParseStream, allow_plus: bool) -> Result<Self>
                {
                    if input.peek(Token![->]) {
                        let arrow = input.parse()?;
                        let allow_group_generic = true;
                        let ty = ambig_ty(input, allow_plus, allow_group_generic)?;
                        Ok(ReturnType::Type(arrow, Box::new(ty)))
                    } else {
                        Ok(ReturnType::Default)
                    }
                }
            }

            impl Parse for ReturnType
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = true;
                    Self::parse(input, allow_plus)
                }
            }

            impl Parse for TypeTraitObject
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = true;
                    Self::parse(input, allow_plus)
                }
            }

            impl TypeTraitObject {
                    pub fn without_plus(input: ParseStream) -> Result<Self> {
                    let allow_plus = false;
                    Self::parse(input, allow_plus)
                }

               
                pub fn parse(input: ParseStream, allow_plus: bool) -> Result<Self> {
                    let dyn_token: Option<Token![dyn]> = input.parse()?;
                    let dyn_span = match &dyn_token {
                        Some(token) => token.span,
                        None => input.span(),
                    };
                    let bounds = Self::parse_bounds(dyn_span, input, allow_plus)?;
                    Ok(TypeTraitObject { dyn_token, bounds })
                }

                fn parse_bounds(
                    dyn_span: Span,
                    input: ParseStream,
                    allow_plus: bool,
                ) -> Result<Punctuated<TypeParamBound, Token![+]>> {
                    let allow_precise_capture = false;
                    let allow_const = false;
                    let bounds = TypeParamBound::parse_multiple(
                        input,
                        allow_plus,
                        allow_precise_capture,
                        allow_const,
                    )?;
                    let mut last_lifetime_span = None;
                    let mut at_least_one_trait = false;
                    for bound in &bounds {
                        match bound {
                            TypeParamBound::Trait(_) => {
                                at_least_one_trait = true;
                                break;
                            }
                            TypeParamBound::Lifetime(lifetime) => {
                                last_lifetime_span = Some(lifetime.ident.span());
                            }
                            TypeParamBound::PreciseCapture(_) | TypeParamBound::Verbatim(_) => {
                                unreachable!()
                            }
                        }
                    }
                   
                    if !at_least_one_trait {
                        let msg = "at least one trait is required for an object type";
                        return Err(error::new2(dyn_span, last_lifetime_span.unwrap(), msg));
                    }
                    Ok(bounds)
                }
            }

            impl Parse for TypeImplTrait
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = true;
                    Self::parse(input, allow_plus)
                }
            }

            impl TypeImplTrait {
                    pub fn without_plus(input: ParseStream) -> Result<Self> {
                    let allow_plus = false;
                    Self::parse(input, allow_plus)
                }

                pub fn parse(input: ParseStream, allow_plus: bool) -> Result<Self> {
                    let impl_token: Token![impl] = input.parse()?;
                    let allow_precise_capture = true;
                    let allow_const = true;
                    let bounds = TypeParamBound::parse_multiple(
                        input,
                        allow_plus,
                        allow_precise_capture,
                        allow_const,
                    )?;
                    let mut last_nontrait_span = None;
                    let mut at_least_one_trait = false;
                    for bound in &bounds {
                        match bound {
                            TypeParamBound::Trait(_) => {
                                at_least_one_trait = true;
                                break;
                            }
                            TypeParamBound::Lifetime(lifetime) => {
                                last_nontrait_span = Some(lifetime.ident.span());
                            }
                            TypeParamBound::PreciseCapture(precise_capture) => { last_nontrait_span = Some(precise_capture.gt_token.span); }
                            TypeParamBound::Verbatim(_) => {
                               
                                at_least_one_trait = true;
                                break;
                            }
                        }
                    }
                    if !at_least_one_trait {
                        let msg = "at least one trait must be specified";
                        return Err(error::new2(
                            impl_token.span,
                            last_nontrait_span.unwrap(),
                            msg,
                        ));
                    }
                    Ok(TypeImplTrait { impl_token, bounds })
                }
            }

            impl Parse for TypeGroup
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let group = ::syntax::group::parse_group(input)?;
                    Ok(TypeGroup {
                        group_token: group.token,
                        elem: group.content.parse()?,
                    })
                }
            }

            impl Parse for TypeParen
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = false;
                    Self::parse(input, allow_plus)
                }
            }

            impl TypeParen
            {
                fn parse(input: ParseStream, allow_plus: bool) -> Result<Self> {
                    let content;
                    Ok(TypeParen {
                        paren_token: parenthesized!(content in input),
                        elem: Box::new({
                            let allow_group_generic = true;
                            ambig_ty(&content, allow_plus, allow_group_generic)?
                        }),
                    })
                }
            }

            impl Parse for BareFnArg
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_self = false;
                    parse_bare_fn_arg(input, allow_self)
                }
            }

            fn parse_bare_fn_arg(input: ParseStream, allow_self: bool) -> Result<BareFnArg>
            {
                let attrs = input.call(Attribute::parse_outer)?;

                let begin = input.fork();

                let has_mut_self = allow_self && input.peek(Token![mut]) && input.peek2(Token![self]);
                if has_mut_self {
                    input.parse::<Token![mut]>()?;
                }

                let mut has_self = false;
                let mut name = if (input.peek(Ident) || input.peek(Token![_]) || {
                    has_self = allow_self && input.peek(Token![self]);
                    has_self
                }) && input.peek2(Token![:])
                    && !input.peek2(Token![::])
                {
                    let name = input.call(Ident::parse_any)?;
                    let colon: Token![:] = input.parse()?;
                    Some((name, colon))
                } else {
                    has_self = false;
                    None
                };

                let ty = if allow_self && !has_self && input.peek(Token![mut]) && input.peek2(Token![self])
                {
                    input.parse::<Token![mut]>()?;
                    input.parse::<Token![self]>()?;
                    None
                } else if has_mut_self && name.is_none() {
                    input.parse::<Token![self]>()?;
                    None
                } else {
                    Some(input.parse()?)
                };

                let ty = match ty {
                    Some(ty) if !has_mut_self => ty,
                    _ => {
                        name = None;
                        Type::Verbatim(verbatim::between(&begin, input))
                    }
                };

                Ok(BareFnArg { attrs, name, ty })
            }

            fn parse_bare_variadic(input: ParseStream, attrs: Vec<Attribute>) -> Result<BareVariadic>
            {
                Ok
                (
                    BareVariadic 
                    {
                        attrs,
                        name: if input.peek(Ident) || input.peek(Token![_])
                        {
                            let name = input.call(Ident::parse_any)?;
                            let colon: Token![:] = input.parse()?;
                            Some((name, colon))
                        }
                        
                        else { None },
                        dots: input.parse()?,
                        comma: input.parse()?,
                    }
                )
            }

            impl Parse for Abi           
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (
                        Abi
                        {
                            extern_token: input.parse()?,
                            name: input.parse()?,
                        }
                    )
                }
            }

            impl Parse for Option<Abi>           
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![extern]) { input.parse().map(Some) }
                    else { Ok(None) }
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::{ TokenStream },
                quote::{ ToTokens, TokenStreamExt },
                syntax::
                {
                    attr::{ FilterAttrs },
                    path::{ self, printing::PathStyle },
                    print::{ TokensOrDefault },
                    ty::
                    {
                        Abi, BareFnArg, BareVariadic, ReturnType, TypeArray, TypeBareFn, TypeGroup, TypeImplTrait, 
                        TypeInfer, TypeMacro, TypeNever, TypeParen, TypePath, TypePtr, TypeReference, TypeSlice, 
                        TypeTraitObject, TypeTuple,
                    },
                },
                *,
            };
            /*
            */
            impl ToTokens for TypeSlice 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.bracket_token.surround(tokens, |tokens| {
                        self.elem.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TypeArray 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.bracket_token.surround(tokens, |tokens| {
                        self.elem.to_tokens(tokens);
                        self.semi_token.to_tokens(tokens);
                        self.len.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TypePtr 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.star_token.to_tokens(tokens);
                    match &self.mutability {
                        Some(tok) => tok.to_tokens(tokens),
                        None => {
                            TokensOrDefault(&self.const_token).to_tokens(tokens);
                        }
                    }
                    self.elem.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeReference 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.and_token.to_tokens(tokens);
                    self.lifetime.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.elem.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeBareFn 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.lifetimes.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.abi.to_tokens(tokens);
                    self.fn_token.to_tokens(tokens);
                    self.paren_token.surround(tokens, |tokens| {
                        self.inputs.to_tokens(tokens);
                        if let Some(variadic) = &self.variadic {
                            if !self.inputs.empty_or_trailing() {
                                let span = variadic.dots.spans[0];
                                Token![,](span).to_tokens(tokens);
                            }
                            variadic.to_tokens(tokens);
                        }
                    });
                    self.output.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeNever 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.bang_token.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeTuple 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.paren_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                       
                       
                        if self.elems.len() == 1 && !self.elems.trailing_punct() {
                            <Token![,]>::default().to_tokens(tokens);
                        }
                    });
                }
            }

            impl ToTokens for TypePath 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::AsWritten);
                }
            }

            impl ToTokens for TypeTraitObject 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.dyn_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeImplTrait 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.impl_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeGroup 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.group_token.surround(tokens, |tokens| {
                        self.elem.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TypeParen 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.paren_token.surround(tokens, |tokens| {
                        self.elem.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TypeInfer 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.underscore_token.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeMacro 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.mac.to_tokens(tokens);
                }
            }

            impl ToTokens for ReturnType 
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        ReturnType::Default => {}
                        ReturnType::Type(arrow, ty) => {
                            arrow.to_tokens(tokens);
                            ty.to_tokens(tokens);
                        }
                    }
                }
            }

            impl ToTokens for BareFnArg 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some((name, colon)) = &self.name {
                        name.to_tokens(tokens);
                        colon.to_tokens(tokens);
                    }
                    self.ty.to_tokens(tokens);
                }
            }

            impl ToTokens for BareVariadic 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some((name, colon)) = &self.name {
                        name.to_tokens(tokens);
                        colon.to_tokens(tokens);
                    }
                    self.dots.to_tokens(tokens);
                    self.comma.to_tokens(tokens);
                }
            }

            impl ToTokens for Abi 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.extern_token.to_tokens(tokens);
                    self.name.to_tokens(tokens);
                }
            }
        }
    } pub use self::ty::
    {
        Abi, BareFnArg, BareVariadic, ReturnType, Type, TypeArray, TypeBareFn, TypeGroup, TypeImplTrait, TypeInfer,
        TypeMacro, TypeNever, TypeParen, TypePath, TypePtr, TypeReference, TypeSlice, TypeTraitObject, TypeTuple,
    };
    
    pub mod verbatim
    {
        use ::
        {
            cmp::{ Ordering },
            syntax::parse::{ ParseStream },
            process::macros::{ Delimiter, TokenStream },
            *,
        };
        /*
        */
        pub fn between<'a>(begin: ParseStream<'a>, end: ParseStream<'a>) -> TokenStream
        {
            let end = end.cursor();
            let mut cursor = begin.cursor();
            assert!(::syntax::buffer::same_buffer(end, cursor));

            let mut tokens = TokenStream::new();
            while cursor != end {
                let (tt, next) = cursor.token_tree().unwrap();

                if ::syntax::buffer::cmp_assuming_same_buffer(end, next) == Ordering::Less {
                   
                   
                   
                   
                    if let Some((inside, _span, after)) = cursor.group(Delimiter::None) {
                        assert!(next == after);
                        cursor = inside;
                        continue;
                    } else {
                        panic!("verbatim end must not be inside a delimited group");
                    }
                }

                tokens.extend(iter::once(tt));
                cursor = next;
            }
            tokens
        }
    }
    
    pub mod whitespace
    {
        use ::
        {
            *,
        };
        /*
        */
        pub fn skip(mut s: &str) -> &str
        {
            'skip: while !s.is_empty() {
                let byte = s.as_bytes()[0];
                if byte == b'/' {
                    if s.starts_with("//")
                        && (!s.starts_with("///") || s.starts_with("////"))
                        && !s.starts_with("//!")
                    {
                        if let Some(i) = s.find('\n') {
                            s = &s[i + 1..];
                            continue;
                        } else {
                            return "";
                        }
                    } else if s.starts_with("/**/") {
                        s = &s[4..];
                        continue;
                    } else if s.starts_with("/*")
                        && (!s.starts_with("/**") || s.starts_with("/***"))
                        && !s.starts_with("/*!")
                    {
                        let mut depth = 0;
                        let bytes = s.as_bytes();
                        let mut i = 0;
                        let upper = bytes.len() - 1;
                        while i < upper {
                            if bytes[i] == b'/' && bytes[i + 1] == b'*' {
                                depth += 1;
                                i += 1;
                            } else if bytes[i] == b'*' && bytes[i + 1] == b'/' {
                                depth -= 1;
                                if depth == 0 {
                                    s = &s[i + 2..];
                                    continue 'skip;
                                }
                                i += 1;
                            }
                            i += 1;
                        }
                        return s;
                    }
                }
                match byte {
                    b' ' | 0x09..=0x0D => {
                        s = &s[1..];
                        continue;
                    }
                    b if b <= 0x7F => {}
                    _ => {
                        let ch = s.chars().next().unwrap();
                        if is_whitespace(ch) {
                            s = &s[ch.len_utf8()..];
                            continue;
                        }
                    }
                }
                return s;
            }
            s
        }

        fn is_whitespace(ch: char) -> bool {
           
            ch.is_whitespace() || ch == '\u{200e}' || ch == '\u{200f}'
        }
    }
    
    pub mod gen
    {
        /// Syntax tree traversal to transform the nodes of an owned syntax tree.
        pub mod fold
        {
            use ::
            {
                *,
            };
            /*
            */
            macro_rules! full {
                ($e:expr) => {
                    $e
                };
            }
            /// Syntax tree traversal to transform the nodes of an owned syntax tree.
            pub trait Fold {
                fn fold_abi(&mut self, i: ::syntax::Abi) -> ::syntax::Abi {
                    fold_abi(self, i)
                }
                
                fn fold_angle_bracketed_generic_arguments(
                    &mut self,
                    i: ::syntax::AngleBracketedGenericArguments,
                ) -> ::syntax::AngleBracketedGenericArguments {
                    fold_angle_bracketed_generic_arguments(self, i)
                }
                
                fn fold_arm(&mut self, i: ::syntax::Arm) -> ::syntax::Arm {
                    fold_arm(self, i)
                }
                
                fn fold_assoc_const(&mut self, i: ::syntax::AssocConst) -> ::syntax::AssocConst {
                    fold_assoc_const(self, i)
                }
                
                fn fold_assoc_type(&mut self, i: ::syntax::AssocType) -> ::syntax::AssocType {
                    fold_assoc_type(self, i)
                }
                
                fn fold_attr_style(&mut self, i: ::syntax::AttrStyle) -> ::syntax::AttrStyle {
                    fold_attr_style(self, i)
                }
                
                fn fold_attribute(&mut self, i: ::syntax::Attribute) -> ::syntax::Attribute {
                    fold_attribute(self, i)
                }
                
                fn fold_attributes(&mut self, i: Vec<::syntax::Attribute>) -> Vec<::syntax::Attribute> {
                    fold_vec(i, self, Self::fold_attribute)
                }
                
                fn fold_bare_fn_arg(&mut self, i: ::syntax::BareFnArg) -> ::syntax::BareFnArg {
                    fold_bare_fn_arg(self, i)
                }
                
                fn fold_bare_variadic(&mut self, i: ::syntax::BareVariadic) -> ::syntax::BareVariadic {
                    fold_bare_variadic(self, i)
                }
                
                fn fold_bin_op(&mut self, i: ::syntax::BinOp) -> ::syntax::BinOp {
                    fold_bin_op(self, i)
                }
                    fn fold_block(&mut self, i: ::syntax::Block) -> ::syntax::Block {
                    fold_block(self, i)
                }
                
                fn fold_bound_lifetimes(
                    &mut self,
                    i: ::syntax::BoundLifetimes,
                ) -> ::syntax::BoundLifetimes {
                    fold_bound_lifetimes(self, i)
                }
                    fn fold_captured_param(&mut self, i: ::syntax::CapturedParam) -> ::syntax::CapturedParam {
                    fold_captured_param(self, i)
                }
                
                fn fold_const_param(&mut self, i: ::syntax::ConstParam) -> ::syntax::ConstParam {
                    fold_const_param(self, i)
                }
                
                fn fold_constraint(&mut self, i: ::syntax::Constraint) -> ::syntax::Constraint {
                    fold_constraint(self, i)
                }
                
                fn fold_data(&mut self, i: ::syntax::Data) -> ::syntax::Data {
                    fold_data(self, i)
                }
                
                fn fold_data_enum(&mut self, i: ::syntax::DataEnum) -> ::syntax::DataEnum {
                    fold_data_enum(self, i)
                }
                
                fn fold_data_struct(&mut self, i: ::syntax::DataStruct) -> ::syntax::DataStruct {
                    fold_data_struct(self, i)
                }
                
                fn fold_data_union(&mut self, i: ::syntax::DataUnion) -> ::syntax::DataUnion {
                    fold_data_union(self, i)
                }
                
                fn fold_derive_input(&mut self, i: ::syntax::DeriveInput) -> ::syntax::DeriveInput {
                    fold_derive_input(self, i)
                }
                
                fn fold_expr(&mut self, i: ::syntax::Expr) -> ::syntax::Expr {
                    fold_expr(self, i)
                }
                    fn fold_expr_array(&mut self, i: ::syntax::ExprArray) -> ::syntax::ExprArray {
                    fold_expr_array(self, i)
                }
                    fn fold_expr_assign(&mut self, i: ::syntax::ExprAssign) -> ::syntax::ExprAssign {
                    fold_expr_assign(self, i)
                }
                    fn fold_expr_async(&mut self, i: ::syntax::ExprAsync) -> ::syntax::ExprAsync {
                    fold_expr_async(self, i)
                }
                    fn fold_expr_await(&mut self, i: ::syntax::ExprAwait) -> ::syntax::ExprAwait {
                    fold_expr_await(self, i)
                }
                
                fn fold_expr_binary(&mut self, i: ::syntax::ExprBinary) -> ::syntax::ExprBinary {
                    fold_expr_binary(self, i)
                }
                    fn fold_expr_block(&mut self, i: ::syntax::ExprBlock) -> ::syntax::ExprBlock {
                    fold_expr_block(self, i)
                }
                    fn fold_expr_break(&mut self, i: ::syntax::ExprBreak) -> ::syntax::ExprBreak {
                    fold_expr_break(self, i)
                }
                
                fn fold_expr_call(&mut self, i: ::syntax::ExprCall) -> ::syntax::ExprCall {
                    fold_expr_call(self, i)
                }
                
                fn fold_expr_cast(&mut self, i: ::syntax::ExprCast) -> ::syntax::ExprCast {
                    fold_expr_cast(self, i)
                }
                    fn fold_expr_closure(&mut self, i: ::syntax::ExprClosure) -> ::syntax::ExprClosure {
                    fold_expr_closure(self, i)
                }
                    fn fold_expr_const(&mut self, i: ::syntax::ExprConst) -> ::syntax::ExprConst {
                    fold_expr_const(self, i)
                }
                    fn fold_expr_continue(&mut self, i: ::syntax::ExprContinue) -> ::syntax::ExprContinue {
                    fold_expr_continue(self, i)
                }
                
                fn fold_expr_field(&mut self, i: ::syntax::ExprField) -> ::syntax::ExprField {
                    fold_expr_field(self, i)
                }
                    fn fold_expr_for_loop(&mut self, i: ::syntax::ExprForLoop) -> ::syntax::ExprForLoop {
                    fold_expr_for_loop(self, i)
                }
                
                fn fold_expr_group(&mut self, i: ::syntax::ExprGroup) -> ::syntax::ExprGroup {
                    fold_expr_group(self, i)
                }
                    fn fold_expr_if(&mut self, i: ::syntax::ExprIf) -> ::syntax::ExprIf {
                    fold_expr_if(self, i)
                }
                
                fn fold_expr_index(&mut self, i: ::syntax::ExprIndex) -> ::syntax::ExprIndex {
                    fold_expr_index(self, i)
                }
                    fn fold_expr_infer(&mut self, i: ::syntax::ExprInfer) -> ::syntax::ExprInfer {
                    fold_expr_infer(self, i)
                }
                    fn fold_expr_let(&mut self, i: ::syntax::ExprLet) -> ::syntax::ExprLet {
                    fold_expr_let(self, i)
                }
                
                fn fold_expr_lit(&mut self, i: ::syntax::ExprLit) -> ::syntax::ExprLit {
                    fold_expr_lit(self, i)
                }
                    fn fold_expr_loop(&mut self, i: ::syntax::ExprLoop) -> ::syntax::ExprLoop {
                    fold_expr_loop(self, i)
                }
                
                fn fold_expr_macro(&mut self, i: ::syntax::ExprMacro) -> ::syntax::ExprMacro {
                    fold_expr_macro(self, i)
                }
                    fn fold_expr_match(&mut self, i: ::syntax::ExprMatch) -> ::syntax::ExprMatch {
                    fold_expr_match(self, i)
                }
                
                fn fold_expr_method_call(
                    &mut self,
                    i: ::syntax::ExprMethodCall,
                ) -> ::syntax::ExprMethodCall {
                    fold_expr_method_call(self, i)
                }
                
                fn fold_expr_paren(&mut self, i: ::syntax::ExprParen) -> ::syntax::ExprParen {
                    fold_expr_paren(self, i)
                }
                
                fn fold_expr_path(&mut self, i: ::syntax::ExprPath) -> ::syntax::ExprPath {
                    fold_expr_path(self, i)
                }
                    fn fold_expr_range(&mut self, i: ::syntax::ExprRange) -> ::syntax::ExprRange {
                    fold_expr_range(self, i)
                }
                    fn fold_expr_raw_addr(&mut self, i: ::syntax::ExprRawAddr) -> ::syntax::ExprRawAddr {
                    fold_expr_raw_addr(self, i)
                }
                
                fn fold_expr_reference(&mut self, i: ::syntax::ExprReference) -> ::syntax::ExprReference {
                    fold_expr_reference(self, i)
                }
                    fn fold_expr_repeat(&mut self, i: ::syntax::ExprRepeat) -> ::syntax::ExprRepeat {
                    fold_expr_repeat(self, i)
                }
                    fn fold_expr_return(&mut self, i: ::syntax::ExprReturn) -> ::syntax::ExprReturn {
                    fold_expr_return(self, i)
                }
                
                fn fold_expr_struct(&mut self, i: ::syntax::ExprStruct) -> ::syntax::ExprStruct {
                    fold_expr_struct(self, i)
                }
                    fn fold_expr_try(&mut self, i: ::syntax::ExprTry) -> ::syntax::ExprTry {
                    fold_expr_try(self, i)
                }
                    fn fold_expr_try_block(&mut self, i: ::syntax::ExprTryBlock) -> ::syntax::ExprTryBlock {
                    fold_expr_try_block(self, i)
                }
                
                fn fold_expr_tuple(&mut self, i: ::syntax::ExprTuple) -> ::syntax::ExprTuple {
                    fold_expr_tuple(self, i)
                }
                
                fn fold_expr_unary(&mut self, i: ::syntax::ExprUnary) -> ::syntax::ExprUnary {
                    fold_expr_unary(self, i)
                }
                    fn fold_expr_unsafe(&mut self, i: ::syntax::ExprUnsafe) -> ::syntax::ExprUnsafe {
                    fold_expr_unsafe(self, i)
                }
                    fn fold_expr_while(&mut self, i: ::syntax::ExprWhile) -> ::syntax::ExprWhile {
                    fold_expr_while(self, i)
                }
                    fn fold_expr_yield(&mut self, i: ::syntax::ExprYield) -> ::syntax::ExprYield {
                    fold_expr_yield(self, i)
                }
                
                fn fold_field(&mut self, i: ::syntax::Field) -> ::syntax::Field {
                    fold_field(self, i)
                }
                
                fn fold_field_mutability(
                    &mut self,
                    i: ::syntax::FieldMutability,
                ) -> ::syntax::FieldMutability {
                    fold_field_mutability(self, i)
                }
                    fn fold_field_pat(&mut self, i: ::syntax::FieldPat) -> ::syntax::FieldPat {
                    fold_field_pat(self, i)
                }
                
                fn fold_field_value(&mut self, i: ::syntax::FieldValue) -> ::syntax::FieldValue {
                    fold_field_value(self, i)
                }
                
                fn fold_fields(&mut self, i: ::syntax::Fields) -> ::syntax::Fields {
                    fold_fields(self, i)
                }
                
                fn fold_fields_named(&mut self, i: ::syntax::FieldsNamed) -> ::syntax::FieldsNamed {
                    fold_fields_named(self, i)
                }
                
                fn fold_fields_unnamed(&mut self, i: ::syntax::FieldsUnnamed) -> ::syntax::FieldsUnnamed {
                    fold_fields_unnamed(self, i)
                }
                    fn fold_file(&mut self, i: ::syntax::File) -> ::syntax::File {
                    fold_file(self, i)
                }
                    fn fold_fn_arg(&mut self, i: ::syntax::FnArg) -> ::syntax::FnArg {
                    fold_fn_arg(self, i)
                }
                    fn fold_foreign_item(&mut self, i: ::syntax::ForeignItem) -> ::syntax::ForeignItem {
                    fold_foreign_item(self, i)
                }
                    fn fold_foreign_item_fn(&mut self, i: ::syntax::ForeignItemFn) -> ::syntax::ForeignItemFn {
                    fold_foreign_item_fn(self, i)
                }
                    fn fold_foreign_item_macro(
                    &mut self,
                    i: ::syntax::ForeignItemMacro,
                ) -> ::syntax::ForeignItemMacro {
                    fold_foreign_item_macro(self, i)
                }
                    fn fold_foreign_item_static(
                    &mut self,
                    i: ::syntax::ForeignItemStatic,
                ) -> ::syntax::ForeignItemStatic {
                    fold_foreign_item_static(self, i)
                }
                    fn fold_foreign_item_type(
                    &mut self,
                    i: ::syntax::ForeignItemType,
                ) -> ::syntax::ForeignItemType {
                    fold_foreign_item_type(self, i)
                }
                
                fn fold_generic_argument(
                    &mut self,
                    i: ::syntax::GenericArgument,
                ) -> ::syntax::GenericArgument {
                    fold_generic_argument(self, i)
                }
                
                fn fold_generic_param(&mut self, i: ::syntax::GenericParam) -> ::syntax::GenericParam {
                    fold_generic_param(self, i)
                }
                
                fn fold_generics(&mut self, i: ::syntax::Generics) -> ::syntax::Generics {
                    fold_generics(self, i)
                }
                
                fn fold_ident(&mut self, i: process::macros::Ident) -> process::macros::Ident {
                    fold_ident(self, i)
                }
                    fn fold_impl_item(&mut self, i: ::syntax::ImplItem) -> ::syntax::ImplItem {
                    fold_impl_item(self, i)
                }
                    fn fold_impl_item_const(&mut self, i: ::syntax::ImplItemConst) -> ::syntax::ImplItemConst {
                    fold_impl_item_const(self, i)
                }
                    fn fold_impl_item_fn(&mut self, i: ::syntax::ImplItemFn) -> ::syntax::ImplItemFn {
                    fold_impl_item_fn(self, i)
                }
                    fn fold_impl_item_macro(&mut self, i: ::syntax::ImplItemMacro) -> ::syntax::ImplItemMacro {
                    fold_impl_item_macro(self, i)
                }
                    fn fold_impl_item_type(&mut self, i: ::syntax::ImplItemType) -> ::syntax::ImplItemType {
                    fold_impl_item_type(self, i)
                }
                    fn fold_impl_restriction(
                    &mut self,
                    i: ::syntax::ImplRestriction,
                ) -> ::syntax::ImplRestriction {
                    fold_impl_restriction(self, i)
                }
                
                fn fold_index(&mut self, i: ::syntax::Index) -> ::syntax::Index {
                    fold_index(self, i)
                }
                    fn fold_item(&mut self, i: ::syntax::Item) -> ::syntax::Item {
                    fold_item(self, i)
                }
                    fn fold_item_const(&mut self, i: ::syntax::ItemConst) -> ::syntax::ItemConst {
                    fold_item_const(self, i)
                }
                    fn fold_item_enum(&mut self, i: ::syntax::ItemEnum) -> ::syntax::ItemEnum {
                    fold_item_enum(self, i)
                }
                    fn fold_item_extern_crate(
                    &mut self,
                    i: ::syntax::ItemExternCrate,
                ) -> ::syntax::ItemExternCrate {
                    fold_item_extern_crate(self, i)
                }
                    fn fold_item_fn(&mut self, i: ::syntax::ItemFn) -> ::syntax::ItemFn {
                    fold_item_fn(self, i)
                }
                    fn fold_item_foreign_mod(
                    &mut self,
                    i: ::syntax::ItemForeignMod,
                ) -> ::syntax::ItemForeignMod {
                    fold_item_foreign_mod(self, i)
                }
                    fn fold_item_impl(&mut self, i: ::syntax::ItemImpl) -> ::syntax::ItemImpl {
                    fold_item_impl(self, i)
                }
                    fn fold_item_macro(&mut self, i: ::syntax::ItemMacro) -> ::syntax::ItemMacro {
                    fold_item_macro(self, i)
                }
                    fn fold_item_mod(&mut self, i: ::syntax::ItemMod) -> ::syntax::ItemMod {
                    fold_item_mod(self, i)
                }
                    fn fold_item_static(&mut self, i: ::syntax::ItemStatic) -> ::syntax::ItemStatic {
                    fold_item_static(self, i)
                }
                    fn fold_item_struct(&mut self, i: ::syntax::ItemStruct) -> ::syntax::ItemStruct {
                    fold_item_struct(self, i)
                }
                    fn fold_item_trait(&mut self, i: ::syntax::ItemTrait) -> ::syntax::ItemTrait {
                    fold_item_trait(self, i)
                }
                    fn fold_item_trait_alias(
                    &mut self,
                    i: ::syntax::ItemTraitAlias,
                ) -> ::syntax::ItemTraitAlias {
                    fold_item_trait_alias(self, i)
                }
                    fn fold_item_type(&mut self, i: ::syntax::ItemType) -> ::syntax::ItemType {
                    fold_item_type(self, i)
                }
                    fn fold_item_union(&mut self, i: ::syntax::ItemUnion) -> ::syntax::ItemUnion {
                    fold_item_union(self, i)
                }
                    fn fold_item_use(&mut self, i: ::syntax::ItemUse) -> ::syntax::ItemUse {
                    fold_item_use(self, i)
                }
                    fn fold_label(&mut self, i: ::syntax::Label) -> ::syntax::Label {
                    fold_label(self, i)
                }
                
                fn fold_lifetime(&mut self, i: ::syntax::Lifetime) -> ::syntax::Lifetime {
                    fold_lifetime(self, i)
                }
                
                fn fold_lifetime_param(&mut self, i: ::syntax::LifetimeParam) -> ::syntax::LifetimeParam {
                    fold_lifetime_param(self, i)
                }
                
                fn fold_lit(&mut self, i: ::syntax::Lit) -> ::syntax::Lit {
                    fold_lit(self, i)
                }
                
                fn fold_lit_bool(&mut self, i: ::syntax::LitBool) -> ::syntax::LitBool {
                    fold_lit_bool(self, i)
                }
                
                fn fold_lit_byte(&mut self, i: ::syntax::LitByte) -> ::syntax::LitByte {
                    fold_lit_byte(self, i)
                }
                
                fn fold_lit_byte_str(&mut self, i: ::syntax::LitByteStr) -> ::syntax::LitByteStr {
                    fold_lit_byte_str(self, i)
                }
                
                fn fold_lit_cstr(&mut self, i: ::syntax::LitCStr) -> ::syntax::LitCStr {
                    fold_lit_cstr(self, i)
                }
                
                fn fold_lit_char(&mut self, i: ::syntax::LitChar) -> ::syntax::LitChar {
                    fold_lit_char(self, i)
                }
                
                fn fold_lit_float(&mut self, i: ::syntax::LitFloat) -> ::syntax::LitFloat {
                    fold_lit_float(self, i)
                }
                
                fn fold_lit_int(&mut self, i: ::syntax::LitInt) -> ::syntax::LitInt {
                    fold_lit_int(self, i)
                }
                
                fn fold_lit_str(&mut self, i: ::syntax::LitStr) -> ::syntax::LitStr {
                    fold_lit_str(self, i)
                }
                    fn fold_local(&mut self, i: ::syntax::Local) -> ::syntax::Local {
                    fold_local(self, i)
                }
                    fn fold_local_init(&mut self, i: ::syntax::LocalInit) -> ::syntax::LocalInit {
                    fold_local_init(self, i)
                }
                
                fn fold_macro(&mut self, i: ::syntax::Macro) -> ::syntax::Macro {
                    fold_macro(self, i)
                }
                
                fn fold_macro_delimiter(
                    &mut self,
                    i: ::syntax::MacroDelimiter,
                ) -> ::syntax::MacroDelimiter {
                    fold_macro_delimiter(self, i)
                }
                
                fn fold_member(&mut self, i: ::syntax::Member) -> ::syntax::Member {
                    fold_member(self, i)
                }
                
                fn fold_meta(&mut self, i: ::syntax::Meta) -> ::syntax::Meta {
                    fold_meta(self, i)
                }
                
                fn fold_meta_list(&mut self, i: ::syntax::MetaList) -> ::syntax::MetaList {
                    fold_meta_list(self, i)
                }
                
                fn fold_meta_name_value(&mut self, i: ::syntax::MetaNameValue) -> ::syntax::MetaNameValue {
                    fold_meta_name_value(self, i)
                }
                
                fn fold_parenthesized_generic_arguments(
                    &mut self,
                    i: ::syntax::ParenthesizedGenericArguments,
                ) -> ::syntax::ParenthesizedGenericArguments {
                    fold_parenthesized_generic_arguments(self, i)
                }
                    fn fold_pat(&mut self, i: ::syntax::Pat) -> ::syntax::Pat {
                    fold_pat(self, i)
                }
                    fn fold_pat_ident(&mut self, i: ::syntax::PatIdent) -> ::syntax::PatIdent {
                    fold_pat_ident(self, i)
                }
                    fn fold_pat_or(&mut self, i: ::syntax::PatOr) -> ::syntax::PatOr {
                    fold_pat_or(self, i)
                }
                    fn fold_pat_paren(&mut self, i: ::syntax::PatParen) -> ::syntax::PatParen {
                    fold_pat_paren(self, i)
                }
                    fn fold_pat_reference(&mut self, i: ::syntax::PatReference) -> ::syntax::PatReference {
                    fold_pat_reference(self, i)
                }
                    fn fold_pat_rest(&mut self, i: ::syntax::PatRest) -> ::syntax::PatRest {
                    fold_pat_rest(self, i)
                }
                    fn fold_pat_slice(&mut self, i: ::syntax::PatSlice) -> ::syntax::PatSlice {
                    fold_pat_slice(self, i)
                }
                    fn fold_pat_struct(&mut self, i: ::syntax::PatStruct) -> ::syntax::PatStruct {
                    fold_pat_struct(self, i)
                }
                    fn fold_pat_tuple(&mut self, i: ::syntax::PatTuple) -> ::syntax::PatTuple {
                    fold_pat_tuple(self, i)
                }
                    fn fold_pat_tuple_struct(
                    &mut self,
                    i: ::syntax::PatTupleStruct,
                ) -> ::syntax::PatTupleStruct {
                    fold_pat_tuple_struct(self, i)
                }
                    fn fold_pat_type(&mut self, i: ::syntax::PatType) -> ::syntax::PatType {
                    fold_pat_type(self, i)
                }
                    fn fold_pat_wild(&mut self, i: ::syntax::PatWild) -> ::syntax::PatWild {
                    fold_pat_wild(self, i)
                }
                
                fn fold_path(&mut self, i: ::syntax::Path) -> ::syntax::Path {
                    fold_path(self, i)
                }
                
                fn fold_path_arguments(&mut self, i: ::syntax::PathArguments) -> ::syntax::PathArguments {
                    fold_path_arguments(self, i)
                }
                
                fn fold_path_segment(&mut self, i: ::syntax::PathSegment) -> ::syntax::PathSegment {
                    fold_path_segment(self, i)
                }
                    fn fold_pointer_mutability(
                    &mut self,
                    i: ::syntax::PointerMutability,
                ) -> ::syntax::PointerMutability {
                    fold_pointer_mutability(self, i)
                }
                    fn fold_precise_capture(
                    &mut self,
                    i: ::syntax::PreciseCapture,
                ) -> ::syntax::PreciseCapture {
                    fold_precise_capture(self, i)
                }
                
                fn fold_predicate_lifetime(
                    &mut self,
                    i: ::syntax::PredicateLifetime,
                ) -> ::syntax::PredicateLifetime {
                    fold_predicate_lifetime(self, i)
                }
                
                fn fold_predicate_type(&mut self, i: ::syntax::PredicateType) -> ::syntax::PredicateType {
                    fold_predicate_type(self, i)
                }
                
                fn fold_qself(&mut self, i: ::syntax::QSelf) -> ::syntax::QSelf {
                    fold_qself(self, i)
                }
                    fn fold_range_limits(&mut self, i: ::syntax::RangeLimits) -> ::syntax::RangeLimits {
                    fold_range_limits(self, i)
                }
                    fn fold_receiver(&mut self, i: ::syntax::Receiver) -> ::syntax::Receiver {
                    fold_receiver(self, i)
                }
                
                fn fold_return_type(&mut self, i: ::syntax::ReturnType) -> ::syntax::ReturnType {
                    fold_return_type(self, i)
                }
                    fn fold_signature(&mut self, i: ::syntax::Signature) -> ::syntax::Signature {
                    fold_signature(self, i)
                }
                
                fn fold_span(&mut self, i: process::macros::Span) -> process::macros::Span {
                    i
                }
                    fn fold_static_mutability(
                    &mut self,
                    i: ::syntax::StaticMutability,
                ) -> ::syntax::StaticMutability {
                    fold_static_mutability(self, i)
                }
                    fn fold_stmt(&mut self, i: ::syntax::Stmt) -> ::syntax::Stmt {
                    fold_stmt(self, i)
                }
                    fn fold_stmt_macro(&mut self, i: ::syntax::StmtMacro) -> ::syntax::StmtMacro {
                    fold_stmt_macro(self, i)
                }
                
                fn fold_token_stream(
                    &mut self,
                    i: process::macros::TokenStream,
                ) -> process::macros::TokenStream {
                    i
                }
                
                fn fold_trait_bound(&mut self, i: ::syntax::TraitBound) -> ::syntax::TraitBound {
                    fold_trait_bound(self, i)
                }
                
                fn fold_trait_bound_modifier(
                    &mut self,
                    i: ::syntax::TraitBoundModifier,
                ) -> ::syntax::TraitBoundModifier {
                    fold_trait_bound_modifier(self, i)
                }
                    fn fold_trait_item(&mut self, i: ::syntax::TraitItem) -> ::syntax::TraitItem {
                    fold_trait_item(self, i)
                }
                    fn fold_trait_item_const(
                    &mut self,
                    i: ::syntax::TraitItemConst,
                ) -> ::syntax::TraitItemConst {
                    fold_trait_item_const(self, i)
                }
                    fn fold_trait_item_fn(&mut self, i: ::syntax::TraitItemFn) -> ::syntax::TraitItemFn {
                    fold_trait_item_fn(self, i)
                }
                    fn fold_trait_item_macro(
                    &mut self,
                    i: ::syntax::TraitItemMacro,
                ) -> ::syntax::TraitItemMacro {
                    fold_trait_item_macro(self, i)
                }
                    fn fold_trait_item_type(&mut self, i: ::syntax::TraitItemType) -> ::syntax::TraitItemType {
                    fold_trait_item_type(self, i)
                }
                
                fn fold_type(&mut self, i: ::syntax::Type) -> ::syntax::Type {
                    fold_type(self, i)
                }
                
                fn fold_type_array(&mut self, i: ::syntax::TypeArray) -> ::syntax::TypeArray {
                    fold_type_array(self, i)
                }
                
                fn fold_type_bare_fn(&mut self, i: ::syntax::TypeBareFn) -> ::syntax::TypeBareFn {
                    fold_type_bare_fn(self, i)
                }
                
                fn fold_type_group(&mut self, i: ::syntax::TypeGroup) -> ::syntax::TypeGroup {
                    fold_type_group(self, i)
                }
                
                fn fold_type_impl_trait(&mut self, i: ::syntax::TypeImplTrait) -> ::syntax::TypeImplTrait {
                    fold_type_impl_trait(self, i)
                }
                
                fn fold_type_infer(&mut self, i: ::syntax::TypeInfer) -> ::syntax::TypeInfer {
                    fold_type_infer(self, i)
                }
                
                fn fold_type_macro(&mut self, i: ::syntax::TypeMacro) -> ::syntax::TypeMacro {
                    fold_type_macro(self, i)
                }
                
                fn fold_type_never(&mut self, i: ::syntax::TypeNever) -> ::syntax::TypeNever {
                    fold_type_never(self, i)
                }
                
                fn fold_type_param(&mut self, i: ::syntax::TypeParam) -> ::syntax::TypeParam {
                    fold_type_param(self, i)
                }
                
                fn fold_type_param_bound(
                    &mut self,
                    i: ::syntax::TypeParamBound,
                ) -> ::syntax::TypeParamBound {
                    fold_type_param_bound(self, i)
                }
                
                fn fold_type_paren(&mut self, i: ::syntax::TypeParen) -> ::syntax::TypeParen {
                    fold_type_paren(self, i)
                }
                
                fn fold_type_path(&mut self, i: ::syntax::TypePath) -> ::syntax::TypePath {
                    fold_type_path(self, i)
                }
                
                fn fold_type_ptr(&mut self, i: ::syntax::TypePtr) -> ::syntax::TypePtr {
                    fold_type_ptr(self, i)
                }
                
                fn fold_type_reference(&mut self, i: ::syntax::TypeReference) -> ::syntax::TypeReference {
                    fold_type_reference(self, i)
                }
                
                fn fold_type_slice(&mut self, i: ::syntax::TypeSlice) -> ::syntax::TypeSlice {
                    fold_type_slice(self, i)
                }
                
                fn fold_type_trait_object(
                    &mut self,
                    i: ::syntax::TypeTraitObject,
                ) -> ::syntax::TypeTraitObject {
                    fold_type_trait_object(self, i)
                }
                
                fn fold_type_tuple(&mut self, i: ::syntax::TypeTuple) -> ::syntax::TypeTuple {
                    fold_type_tuple(self, i)
                }
                
                fn fold_un_op(&mut self, i: ::syntax::UnOp) -> ::syntax::UnOp {
                    fold_un_op(self, i)
                }
                    fn fold_use_glob(&mut self, i: ::syntax::UseGlob) -> ::syntax::UseGlob {
                    fold_use_glob(self, i)
                }
                    fn fold_use_group(&mut self, i: ::syntax::UseGroup) -> ::syntax::UseGroup {
                    fold_use_group(self, i)
                }
                    fn fold_use_name(&mut self, i: ::syntax::UseName) -> ::syntax::UseName {
                    fold_use_name(self, i)
                }
                    fn fold_use_path(&mut self, i: ::syntax::UsePath) -> ::syntax::UsePath {
                    fold_use_path(self, i)
                }
                    fn fold_use_rename(&mut self, i: ::syntax::UseRename) -> ::syntax::UseRename {
                    fold_use_rename(self, i)
                }
                    fn fold_use_tree(&mut self, i: ::syntax::UseTree) -> ::syntax::UseTree {
                    fold_use_tree(self, i)
                }
                    fn fold_variadic(&mut self, i: ::syntax::Variadic) -> ::syntax::Variadic {
                    fold_variadic(self, i)
                }
                
                fn fold_variant(&mut self, i: ::syntax::Variant) -> ::syntax::Variant {
                    fold_variant(self, i)
                }
                
                fn fold_vis_restricted(&mut self, i: ::syntax::VisRestricted) -> ::syntax::VisRestricted {
                    fold_vis_restricted(self, i)
                }
                
                fn fold_visibility(&mut self, i: ::syntax::Visibility) -> ::syntax::Visibility {
                    fold_visibility(self, i)
                }
                
                fn fold_where_clause(&mut self, i: ::syntax::WhereClause) -> ::syntax::WhereClause {
                    fold_where_clause(self, i)
                }
                
                fn fold_where_predicate(
                    &mut self,
                    i: ::syntax::WherePredicate,
                ) -> ::syntax::WherePredicate {
                    fold_where_predicate(self, i)
                }
            }
            pub fn fold_abi<F>(f: &mut F, node: ::syntax::Abi) -> ::syntax::Abi where
                F: Fold + ?Sized,
            {
                ::syntax::Abi {
                    extern_token: node.extern_token,
                    name: (node.name).map(|it| f.fold_lit_str(it)),
                }
            }
            pub fn fold_angle_bracketed_generic_arguments<F>(
                f: &mut F,
                node: ::syntax::AngleBracketedGenericArguments,
            ) -> ::syntax::AngleBracketedGenericArguments where
                F: Fold + ?Sized,
            {
                ::syntax::AngleBracketedGenericArguments {
                    colon2_token: node.colon2_token,
                    lt_token: node.lt_token,
                    args: ::syntax::punctuated::fold(node.args, f, F::fold_generic_argument),
                    gt_token: node.gt_token,
                }
            }
            pub fn fold_arm<F>(f: &mut F, node: ::syntax::Arm) -> ::syntax::Arm where
                F: Fold + ?Sized,
            {
                ::syntax::Arm {
                    attrs: f.fold_attributes(node.attrs),
                    pat: f.fold_pat(node.pat),
                    guard: (node.guard).map(|it| ((it).0, Box::new(f.fold_expr(*(it).1)))),
                    fat_arrow_token: node.fat_arrow_token,
                    body: Box::new(f.fold_expr(*node.body)),
                    comma: node.comma,
                }
            }
            pub fn fold_assoc_const<F>(f: &mut F, node: ::syntax::AssocConst) -> ::syntax::AssocConst where
                F: Fold + ?Sized,
            {
                ::syntax::AssocConst {
                    ident: f.fold_ident(node.ident),
                    generics: (node.generics).map(|it| f.fold_angle_bracketed_generic_arguments(it)),
                    eq_token: node.eq_token,
                    value: f.fold_expr(node.value),
                }
            }
            pub fn fold_assoc_type<F>(f: &mut F, node: ::syntax::AssocType) -> ::syntax::AssocType where
                F: Fold + ?Sized,
            {
                ::syntax::AssocType {
                    ident: f.fold_ident(node.ident),
                    generics: (node.generics).map(|it| f.fold_angle_bracketed_generic_arguments(it)),
                    eq_token: node.eq_token,
                    ty: f.fold_type(node.ty),
                }
            }
            pub fn fold_attr_style<F>(f: &mut F, node: ::syntax::AttrStyle) -> ::syntax::AttrStyle where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::AttrStyle::Outer => ::syntax::AttrStyle::Outer,
                    ::syntax::AttrStyle::Inner(_binding_0) => ::syntax::AttrStyle::Inner(_binding_0),
                }
            }
            pub fn fold_attribute<F>(f: &mut F, node: ::syntax::Attribute) -> ::syntax::Attribute where
                F: Fold + ?Sized,
            {
                ::syntax::Attribute {
                    pound_token: node.pound_token,
                    style: f.fold_attr_style(node.style),
                    bracket_token: node.bracket_token,
                    meta: f.fold_meta(node.meta),
                }
            }
            pub fn fold_bare_fn_arg<F>(f: &mut F, node: ::syntax::BareFnArg) -> ::syntax::BareFnArg where
                F: Fold + ?Sized,
            {
                ::syntax::BareFnArg {
                    attrs: f.fold_attributes(node.attrs),
                    name: (node.name).map(|it| (f.fold_ident((it).0), (it).1)),
                    ty: f.fold_type(node.ty),
                }
            }
            pub fn fold_bare_variadic<F>(f: &mut F, node: ::syntax::BareVariadic) -> ::syntax::BareVariadic where
                F: Fold + ?Sized,
            {
                ::syntax::BareVariadic {
                    attrs: f.fold_attributes(node.attrs),
                    name: (node.name).map(|it| (f.fold_ident((it).0), (it).1)),
                    dots: node.dots,
                    comma: node.comma,
                }
            }
            pub fn fold_bin_op<F>(f: &mut F, node: ::syntax::BinOp) -> ::syntax::BinOp where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::BinOp::Add(_binding_0) => ::syntax::BinOp::Add(_binding_0),
                    ::syntax::BinOp::Sub(_binding_0) => ::syntax::BinOp::Sub(_binding_0),
                    ::syntax::BinOp::Mul(_binding_0) => ::syntax::BinOp::Mul(_binding_0),
                    ::syntax::BinOp::Div(_binding_0) => ::syntax::BinOp::Div(_binding_0),
                    ::syntax::BinOp::Rem(_binding_0) => ::syntax::BinOp::Rem(_binding_0),
                    ::syntax::BinOp::And(_binding_0) => ::syntax::BinOp::And(_binding_0),
                    ::syntax::BinOp::Or(_binding_0) => ::syntax::BinOp::Or(_binding_0),
                    ::syntax::BinOp::BitXor(_binding_0) => ::syntax::BinOp::BitXor(_binding_0),
                    ::syntax::BinOp::BitAnd(_binding_0) => ::syntax::BinOp::BitAnd(_binding_0),
                    ::syntax::BinOp::BitOr(_binding_0) => ::syntax::BinOp::BitOr(_binding_0),
                    ::syntax::BinOp::Shl(_binding_0) => ::syntax::BinOp::Shl(_binding_0),
                    ::syntax::BinOp::Shr(_binding_0) => ::syntax::BinOp::Shr(_binding_0),
                    ::syntax::BinOp::Eq(_binding_0) => ::syntax::BinOp::Eq(_binding_0),
                    ::syntax::BinOp::Lt(_binding_0) => ::syntax::BinOp::Lt(_binding_0),
                    ::syntax::BinOp::Le(_binding_0) => ::syntax::BinOp::Le(_binding_0),
                    ::syntax::BinOp::Ne(_binding_0) => ::syntax::BinOp::Ne(_binding_0),
                    ::syntax::BinOp::Ge(_binding_0) => ::syntax::BinOp::Ge(_binding_0),
                    ::syntax::BinOp::Gt(_binding_0) => ::syntax::BinOp::Gt(_binding_0),
                    ::syntax::BinOp::AddAssign(_binding_0) => ::syntax::BinOp::AddAssign(_binding_0),
                    ::syntax::BinOp::SubAssign(_binding_0) => ::syntax::BinOp::SubAssign(_binding_0),
                    ::syntax::BinOp::MulAssign(_binding_0) => ::syntax::BinOp::MulAssign(_binding_0),
                    ::syntax::BinOp::DivAssign(_binding_0) => ::syntax::BinOp::DivAssign(_binding_0),
                    ::syntax::BinOp::RemAssign(_binding_0) => ::syntax::BinOp::RemAssign(_binding_0),
                    ::syntax::BinOp::BitXorAssign(_binding_0) => ::syntax::BinOp::BitXorAssign(_binding_0),
                    ::syntax::BinOp::BitAndAssign(_binding_0) => ::syntax::BinOp::BitAndAssign(_binding_0),
                    ::syntax::BinOp::BitOrAssign(_binding_0) => ::syntax::BinOp::BitOrAssign(_binding_0),
                    ::syntax::BinOp::ShlAssign(_binding_0) => ::syntax::BinOp::ShlAssign(_binding_0),
                    ::syntax::BinOp::ShrAssign(_binding_0) => ::syntax::BinOp::ShrAssign(_binding_0),
                }
            }
            pub fn fold_block<F>(f: &mut F, node: ::syntax::Block) -> ::syntax::Block where
                F: Fold + ?Sized,
            {
                ::syntax::Block {
                    brace_token: node.brace_token,
                    stmts: fold_vec(node.stmts, f, F::fold_stmt),
                }
            }
            pub fn fold_bound_lifetimes<F>(
                f: &mut F,
                node: ::syntax::BoundLifetimes,
            ) -> ::syntax::BoundLifetimes where
                F: Fold + ?Sized,
            {
                ::syntax::BoundLifetimes {
                    for_token: node.for_token,
                    lt_token: node.lt_token,
                    lifetimes: ::syntax::punctuated::fold(node.lifetimes, f, F::fold_generic_param),
                    gt_token: node.gt_token,
                }
            }
            pub fn fold_captured_param<F>(
                f: &mut F,
                node: ::syntax::CapturedParam,
            ) -> ::syntax::CapturedParam where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::CapturedParam::Lifetime(_binding_0) => {
                        ::syntax::CapturedParam::Lifetime(f.fold_lifetime(_binding_0))
                    }
                    ::syntax::CapturedParam::Ident(_binding_0) => {
                        ::syntax::CapturedParam::Ident(f.fold_ident(_binding_0))
                    }
                }
            }
            pub fn fold_const_param<F>(f: &mut F, node: ::syntax::ConstParam) -> ::syntax::ConstParam where
                F: Fold + ?Sized,
            {
                ::syntax::ConstParam {
                    attrs: f.fold_attributes(node.attrs),
                    const_token: node.const_token,
                    ident: f.fold_ident(node.ident),
                    colon_token: node.colon_token,
                    ty: f.fold_type(node.ty),
                    eq_token: node.eq_token,
                    default: (node.default).map(|it| f.fold_expr(it)),
                }
            }
            pub fn fold_constraint<F>(f: &mut F, node: ::syntax::Constraint) -> ::syntax::Constraint where
                F: Fold + ?Sized,
            {
                ::syntax::Constraint {
                    ident: f.fold_ident(node.ident),
                    generics: (node.generics).map(|it| f.fold_angle_bracketed_generic_arguments(it)),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                }
            }
            pub fn fold_data<F>(f: &mut F, node: ::syntax::Data) -> ::syntax::Data where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Data::Struct(_binding_0) => {
                        ::syntax::Data::Struct(f.fold_data_struct(_binding_0))
                    }
                    ::syntax::Data::Enum(_binding_0) => ::syntax::Data::Enum(f.fold_data_enum(_binding_0)),
                    ::syntax::Data::Union(_binding_0) => {
                        ::syntax::Data::Union(f.fold_data_union(_binding_0))
                    }
                }
            }
            pub fn fold_data_enum<F>(f: &mut F, node: ::syntax::DataEnum) -> ::syntax::DataEnum where
                F: Fold + ?Sized,
            {
                ::syntax::DataEnum {
                    enum_token: node.enum_token,
                    brace_token: node.brace_token,
                    variants: ::syntax::punctuated::fold(node.variants, f, F::fold_variant),
                }
            }
            pub fn fold_data_struct<F>(f: &mut F, node: ::syntax::DataStruct) -> ::syntax::DataStruct where
                F: Fold + ?Sized,
            {
                ::syntax::DataStruct {
                    struct_token: node.struct_token,
                    fields: f.fold_fields(node.fields),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_data_union<F>(f: &mut F, node: ::syntax::DataUnion) -> ::syntax::DataUnion where
                F: Fold + ?Sized,
            {
                ::syntax::DataUnion {
                    union_token: node.union_token,
                    fields: f.fold_fields_named(node.fields),
                }
            }
            pub fn fold_derive_input<F>(f: &mut F, node: ::syntax::DeriveInput) -> ::syntax::DeriveInput where
                F: Fold + ?Sized,
            {
                ::syntax::DeriveInput {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    data: f.fold_data(node.data),
                }
            }
            pub fn fold_expr<F>(f: &mut F, node: ::syntax::Expr) -> ::syntax::Expr where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Expr::Array(_binding_0) => {
                        ::syntax::Expr::Array(full!(f.fold_expr_array(_binding_0)))
                    }
                    ::syntax::Expr::Assign(_binding_0) => {
                        ::syntax::Expr::Assign(full!(f.fold_expr_assign(_binding_0)))
                    }
                    ::syntax::Expr::Async(_binding_0) => {
                        ::syntax::Expr::Async(full!(f.fold_expr_async(_binding_0)))
                    }
                    ::syntax::Expr::Await(_binding_0) => {
                        ::syntax::Expr::Await(full!(f.fold_expr_await(_binding_0)))
                    }
                    ::syntax::Expr::Binary(_binding_0) => {
                        ::syntax::Expr::Binary(f.fold_expr_binary(_binding_0))
                    }
                    ::syntax::Expr::Block(_binding_0) => {
                        ::syntax::Expr::Block(full!(f.fold_expr_block(_binding_0)))
                    }
                    ::syntax::Expr::Break(_binding_0) => {
                        ::syntax::Expr::Break(full!(f.fold_expr_break(_binding_0)))
                    }
                    ::syntax::Expr::Call(_binding_0) => ::syntax::Expr::Call(f.fold_expr_call(_binding_0)),
                    ::syntax::Expr::Cast(_binding_0) => ::syntax::Expr::Cast(f.fold_expr_cast(_binding_0)),
                    ::syntax::Expr::Closure(_binding_0) => {
                        ::syntax::Expr::Closure(full!(f.fold_expr_closure(_binding_0)))
                    }
                    ::syntax::Expr::Const(_binding_0) => {
                        ::syntax::Expr::Const(full!(f.fold_expr_const(_binding_0)))
                    }
                    ::syntax::Expr::Continue(_binding_0) => {
                        ::syntax::Expr::Continue(full!(f.fold_expr_continue(_binding_0)))
                    }
                    ::syntax::Expr::Field(_binding_0) => {
                        ::syntax::Expr::Field(f.fold_expr_field(_binding_0))
                    }
                    ::syntax::Expr::ForLoop(_binding_0) => {
                        ::syntax::Expr::ForLoop(full!(f.fold_expr_for_loop(_binding_0)))
                    }
                    ::syntax::Expr::Group(_binding_0) => {
                        ::syntax::Expr::Group(f.fold_expr_group(_binding_0))
                    }
                    ::syntax::Expr::If(_binding_0) => ::syntax::Expr::If(full!(f.fold_expr_if(_binding_0))),
                    ::syntax::Expr::Index(_binding_0) => {
                        ::syntax::Expr::Index(f.fold_expr_index(_binding_0))
                    }
                    ::syntax::Expr::Infer(_binding_0) => {
                        ::syntax::Expr::Infer(full!(f.fold_expr_infer(_binding_0)))
                    }
                    ::syntax::Expr::Let(_binding_0) => {
                        ::syntax::Expr::Let(full!(f.fold_expr_let(_binding_0)))
                    }
                    ::syntax::Expr::Lit(_binding_0) => ::syntax::Expr::Lit(f.fold_expr_lit(_binding_0)),
                    ::syntax::Expr::Loop(_binding_0) => {
                        ::syntax::Expr::Loop(full!(f.fold_expr_loop(_binding_0)))
                    }
                    ::syntax::Expr::Macro(_binding_0) => {
                        ::syntax::Expr::Macro(f.fold_expr_macro(_binding_0))
                    }
                    ::syntax::Expr::Match(_binding_0) => {
                        ::syntax::Expr::Match(full!(f.fold_expr_match(_binding_0)))
                    }
                    ::syntax::Expr::MethodCall(_binding_0) => {
                        ::syntax::Expr::MethodCall(f.fold_expr_method_call(_binding_0))
                    }
                    ::syntax::Expr::Paren(_binding_0) => {
                        ::syntax::Expr::Paren(f.fold_expr_paren(_binding_0))
                    }
                    ::syntax::Expr::Path(_binding_0) => ::syntax::Expr::Path(f.fold_expr_path(_binding_0)),
                    ::syntax::Expr::Range(_binding_0) => {
                        ::syntax::Expr::Range(full!(f.fold_expr_range(_binding_0)))
                    }
                    ::syntax::Expr::RawAddr(_binding_0) => {
                        ::syntax::Expr::RawAddr(full!(f.fold_expr_raw_addr(_binding_0)))
                    }
                    ::syntax::Expr::Reference(_binding_0) => {
                        ::syntax::Expr::Reference(f.fold_expr_reference(_binding_0))
                    }
                    ::syntax::Expr::Repeat(_binding_0) => {
                        ::syntax::Expr::Repeat(full!(f.fold_expr_repeat(_binding_0)))
                    }
                    ::syntax::Expr::Return(_binding_0) => {
                        ::syntax::Expr::Return(full!(f.fold_expr_return(_binding_0)))
                    }
                    ::syntax::Expr::Struct(_binding_0) => {
                        ::syntax::Expr::Struct(f.fold_expr_struct(_binding_0))
                    }
                    ::syntax::Expr::Try(_binding_0) => {
                        ::syntax::Expr::Try(full!(f.fold_expr_try(_binding_0)))
                    }
                    ::syntax::Expr::TryBlock(_binding_0) => {
                        ::syntax::Expr::TryBlock(full!(f.fold_expr_try_block(_binding_0)))
                    }
                    ::syntax::Expr::Tuple(_binding_0) => {
                        ::syntax::Expr::Tuple(f.fold_expr_tuple(_binding_0))
                    }
                    ::syntax::Expr::Unary(_binding_0) => {
                        ::syntax::Expr::Unary(f.fold_expr_unary(_binding_0))
                    }
                    ::syntax::Expr::Unsafe(_binding_0) => {
                        ::syntax::Expr::Unsafe(full!(f.fold_expr_unsafe(_binding_0)))
                    }
                    ::syntax::Expr::Verbatim(_binding_0) => {
                        ::syntax::Expr::Verbatim(f.fold_token_stream(_binding_0))
                    }
                    ::syntax::Expr::While(_binding_0) => {
                        ::syntax::Expr::While(full!(f.fold_expr_while(_binding_0)))
                    }
                    ::syntax::Expr::Yield(_binding_0) => {
                        ::syntax::Expr::Yield(full!(f.fold_expr_yield(_binding_0)))
                    }
                }
            }
            pub fn fold_expr_array<F>(f: &mut F, node: ::syntax::ExprArray) -> ::syntax::ExprArray where
                F: Fold + ?Sized,
            {
                ::syntax::ExprArray {
                    attrs: f.fold_attributes(node.attrs),
                    bracket_token: node.bracket_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_expr),
                }
            }
            pub fn fold_expr_assign<F>(f: &mut F, node: ::syntax::ExprAssign) -> ::syntax::ExprAssign where
                F: Fold + ?Sized,
            {
                ::syntax::ExprAssign {
                    attrs: f.fold_attributes(node.attrs),
                    left: Box::new(f.fold_expr(*node.left)),
                    eq_token: node.eq_token,
                    right: Box::new(f.fold_expr(*node.right)),
                }
            }
            pub fn fold_expr_async<F>(f: &mut F, node: ::syntax::ExprAsync) -> ::syntax::ExprAsync where
                F: Fold + ?Sized,
            {
                ::syntax::ExprAsync {
                    attrs: f.fold_attributes(node.attrs),
                    async_token: node.async_token,
                    capture: node.capture,
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_await<F>(f: &mut F, node: ::syntax::ExprAwait) -> ::syntax::ExprAwait where
                F: Fold + ?Sized,
            {
                ::syntax::ExprAwait {
                    attrs: f.fold_attributes(node.attrs),
                    base: Box::new(f.fold_expr(*node.base)),
                    dot_token: node.dot_token,
                    await_token: node.await_token,
                }
            }
            pub fn fold_expr_binary<F>(f: &mut F, node: ::syntax::ExprBinary) -> ::syntax::ExprBinary where
                F: Fold + ?Sized,
            {
                ::syntax::ExprBinary {
                    attrs: f.fold_attributes(node.attrs),
                    left: Box::new(f.fold_expr(*node.left)),
                    op: f.fold_bin_op(node.op),
                    right: Box::new(f.fold_expr(*node.right)),
                }
            }
            pub fn fold_expr_block<F>(f: &mut F, node: ::syntax::ExprBlock) -> ::syntax::ExprBlock where
                F: Fold + ?Sized,
            {
                ::syntax::ExprBlock {
                    attrs: f.fold_attributes(node.attrs),
                    label: (node.label).map(|it| f.fold_label(it)),
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_break<F>(f: &mut F, node: ::syntax::ExprBreak) -> ::syntax::ExprBreak where
                F: Fold + ?Sized,
            {
                ::syntax::ExprBreak {
                    attrs: f.fold_attributes(node.attrs),
                    break_token: node.break_token,
                    label: (node.label).map(|it| f.fold_lifetime(it)),
                    expr: (node.expr).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_expr_call<F>(f: &mut F, node: ::syntax::ExprCall) -> ::syntax::ExprCall where
                F: Fold + ?Sized,
            {
                ::syntax::ExprCall {
                    attrs: f.fold_attributes(node.attrs),
                    func: Box::new(f.fold_expr(*node.func)),
                    paren_token: node.paren_token,
                    args: ::syntax::punctuated::fold(node.args, f, F::fold_expr),
                }
            }
            pub fn fold_expr_cast<F>(f: &mut F, node: ::syntax::ExprCast) -> ::syntax::ExprCast where
                F: Fold + ?Sized,
            {
                ::syntax::ExprCast {
                    attrs: f.fold_attributes(node.attrs),
                    expr: Box::new(f.fold_expr(*node.expr)),
                    as_token: node.as_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                }
            }
            pub fn fold_expr_closure<F>(f: &mut F, node: ::syntax::ExprClosure) -> ::syntax::ExprClosure where
                F: Fold + ?Sized,
            {
                ::syntax::ExprClosure {
                    attrs: f.fold_attributes(node.attrs),
                    lifetimes: (node.lifetimes).map(|it| f.fold_bound_lifetimes(it)),
                    constness: node.constness,
                    movability: node.movability,
                    asyncness: node.asyncness,
                    capture: node.capture,
                    or1_token: node.or1_token,
                    inputs: ::syntax::punctuated::fold(node.inputs, f, F::fold_pat),
                    or2_token: node.or2_token,
                    output: f.fold_return_type(node.output),
                    body: Box::new(f.fold_expr(*node.body)),
                }
            }
            pub fn fold_expr_const<F>(f: &mut F, node: ::syntax::ExprConst) -> ::syntax::ExprConst where
                F: Fold + ?Sized,
            {
                ::syntax::ExprConst {
                    attrs: f.fold_attributes(node.attrs),
                    const_token: node.const_token,
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_continue<F>(f: &mut F, node: ::syntax::ExprContinue) -> ::syntax::ExprContinue where
                F: Fold + ?Sized,
            {
                ::syntax::ExprContinue {
                    attrs: f.fold_attributes(node.attrs),
                    continue_token: node.continue_token,
                    label: (node.label).map(|it| f.fold_lifetime(it)),
                }
            }
            pub fn fold_expr_field<F>(f: &mut F, node: ::syntax::ExprField) -> ::syntax::ExprField where
                F: Fold + ?Sized,
            {
                ::syntax::ExprField {
                    attrs: f.fold_attributes(node.attrs),
                    base: Box::new(f.fold_expr(*node.base)),
                    dot_token: node.dot_token,
                    member: f.fold_member(node.member),
                }
            }
            pub fn fold_expr_for_loop<F>(f: &mut F, node: ::syntax::ExprForLoop) -> ::syntax::ExprForLoop where
                F: Fold + ?Sized,
            {
                ::syntax::ExprForLoop {
                    attrs: f.fold_attributes(node.attrs),
                    label: (node.label).map(|it| f.fold_label(it)),
                    for_token: node.for_token,
                    pat: Box::new(f.fold_pat(*node.pat)),
                    in_token: node.in_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    body: f.fold_block(node.body),
                }
            }
            pub fn fold_expr_group<F>(f: &mut F, node: ::syntax::ExprGroup) -> ::syntax::ExprGroup where
                F: Fold + ?Sized,
            {
                ::syntax::ExprGroup {
                    attrs: f.fold_attributes(node.attrs),
                    group_token: node.group_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_if<F>(f: &mut F, node: ::syntax::ExprIf) -> ::syntax::ExprIf where
                F: Fold + ?Sized,
            {
                ::syntax::ExprIf {
                    attrs: f.fold_attributes(node.attrs),
                    if_token: node.if_token,
                    cond: Box::new(f.fold_expr(*node.cond)),
                    then_branch: f.fold_block(node.then_branch),
                    else_branch: (node.else_branch)
                        .map(|it| ((it).0, Box::new(f.fold_expr(*(it).1)))),
                }
            }
            pub fn fold_expr_index<F>(f: &mut F, node: ::syntax::ExprIndex) -> ::syntax::ExprIndex where
                F: Fold + ?Sized,
            {
                ::syntax::ExprIndex {
                    attrs: f.fold_attributes(node.attrs),
                    expr: Box::new(f.fold_expr(*node.expr)),
                    bracket_token: node.bracket_token,
                    index: Box::new(f.fold_expr(*node.index)),
                }
            }
            pub fn fold_expr_infer<F>(f: &mut F, node: ::syntax::ExprInfer) -> ::syntax::ExprInfer where
                F: Fold + ?Sized,
            {
                ::syntax::ExprInfer {
                    attrs: f.fold_attributes(node.attrs),
                    underscore_token: node.underscore_token,
                }
            }
            pub fn fold_expr_let<F>(f: &mut F, node: ::syntax::ExprLet) -> ::syntax::ExprLet where
                F: Fold + ?Sized,
            {
                ::syntax::ExprLet {
                    attrs: f.fold_attributes(node.attrs),
                    let_token: node.let_token,
                    pat: Box::new(f.fold_pat(*node.pat)),
                    eq_token: node.eq_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_lit<F>(f: &mut F, node: ::syntax::ExprLit) -> ::syntax::ExprLit where
                F: Fold + ?Sized,
            {
                ::syntax::ExprLit {
                    attrs: f.fold_attributes(node.attrs),
                    lit: f.fold_lit(node.lit),
                }
            }
            pub fn fold_expr_loop<F>(f: &mut F, node: ::syntax::ExprLoop) -> ::syntax::ExprLoop where
                F: Fold + ?Sized,
            {
                ::syntax::ExprLoop {
                    attrs: f.fold_attributes(node.attrs),
                    label: (node.label).map(|it| f.fold_label(it)),
                    loop_token: node.loop_token,
                    body: f.fold_block(node.body),
                }
            }
            pub fn fold_expr_macro<F>(f: &mut F, node: ::syntax::ExprMacro) -> ::syntax::ExprMacro where
                F: Fold + ?Sized,
            {
                ::syntax::ExprMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                }
            }
            pub fn fold_expr_match<F>(f: &mut F, node: ::syntax::ExprMatch) -> ::syntax::ExprMatch where
                F: Fold + ?Sized,
            {
                ::syntax::ExprMatch {
                    attrs: f.fold_attributes(node.attrs),
                    match_token: node.match_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    brace_token: node.brace_token,
                    arms: fold_vec(node.arms, f, F::fold_arm),
                }
            }
            pub fn fold_expr_method_call<F>(
                f: &mut F,
                node: ::syntax::ExprMethodCall,
            ) -> ::syntax::ExprMethodCall where
                F: Fold + ?Sized,
            {
                ::syntax::ExprMethodCall {
                    attrs: f.fold_attributes(node.attrs),
                    receiver: Box::new(f.fold_expr(*node.receiver)),
                    dot_token: node.dot_token,
                    method: f.fold_ident(node.method),
                    turbofish: (node.turbofish)
                        .map(|it| f.fold_angle_bracketed_generic_arguments(it)),
                    paren_token: node.paren_token,
                    args: ::syntax::punctuated::fold(node.args, f, F::fold_expr),
                }
            }
            pub fn fold_expr_paren<F>(f: &mut F, node: ::syntax::ExprParen) -> ::syntax::ExprParen where
                F: Fold + ?Sized,
            {
                ::syntax::ExprParen {
                    attrs: f.fold_attributes(node.attrs),
                    paren_token: node.paren_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_path<F>(f: &mut F, node: ::syntax::ExprPath) -> ::syntax::ExprPath where
                F: Fold + ?Sized,
            {
                ::syntax::ExprPath {
                    attrs: f.fold_attributes(node.attrs),
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                }
            }
            pub fn fold_expr_range<F>(f: &mut F, node: ::syntax::ExprRange) -> ::syntax::ExprRange where
                F: Fold + ?Sized,
            {
                ::syntax::ExprRange {
                    attrs: f.fold_attributes(node.attrs),
                    start: (node.start).map(|it| Box::new(f.fold_expr(*it))),
                    limits: f.fold_range_limits(node.limits),
                    end: (node.end).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_expr_raw_addr<F>(f: &mut F, node: ::syntax::ExprRawAddr) -> ::syntax::ExprRawAddr where
                F: Fold + ?Sized,
            {
                ::syntax::ExprRawAddr {
                    attrs: f.fold_attributes(node.attrs),
                    and_token: node.and_token,
                    raw: node.raw,
                    mutability: f.fold_pointer_mutability(node.mutability),
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_reference<F>(
                f: &mut F,
                node: ::syntax::ExprReference,
            ) -> ::syntax::ExprReference where
                F: Fold + ?Sized,
            {
                ::syntax::ExprReference {
                    attrs: f.fold_attributes(node.attrs),
                    and_token: node.and_token,
                    mutability: node.mutability,
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_repeat<F>(f: &mut F, node: ::syntax::ExprRepeat) -> ::syntax::ExprRepeat where
                F: Fold + ?Sized,
            {
                ::syntax::ExprRepeat {
                    attrs: f.fold_attributes(node.attrs),
                    bracket_token: node.bracket_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    semi_token: node.semi_token,
                    len: Box::new(f.fold_expr(*node.len)),
                }
            }
            pub fn fold_expr_return<F>(f: &mut F, node: ::syntax::ExprReturn) -> ::syntax::ExprReturn where
                F: Fold + ?Sized,
            {
                ::syntax::ExprReturn {
                    attrs: f.fold_attributes(node.attrs),
                    return_token: node.return_token,
                    expr: (node.expr).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_expr_struct<F>(f: &mut F, node: ::syntax::ExprStruct) -> ::syntax::ExprStruct where
                F: Fold + ?Sized,
            {
                ::syntax::ExprStruct {
                    attrs: f.fold_attributes(node.attrs),
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                    brace_token: node.brace_token,
                    fields: ::syntax::punctuated::fold(node.fields, f, F::fold_field_value),
                    dot2_token: node.dot2_token,
                    rest: (node.rest).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_expr_try<F>(f: &mut F, node: ::syntax::ExprTry) -> ::syntax::ExprTry where
                F: Fold + ?Sized,
            {
                ::syntax::ExprTry {
                    attrs: f.fold_attributes(node.attrs),
                    expr: Box::new(f.fold_expr(*node.expr)),
                    question_token: node.question_token,
                }
            }
            pub fn fold_expr_try_block<F>(
                f: &mut F,
                node: ::syntax::ExprTryBlock,
            ) -> ::syntax::ExprTryBlock where
                F: Fold + ?Sized,
            {
                ::syntax::ExprTryBlock {
                    attrs: f.fold_attributes(node.attrs),
                    try_token: node.try_token,
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_tuple<F>(f: &mut F, node: ::syntax::ExprTuple) -> ::syntax::ExprTuple where
                F: Fold + ?Sized,
            {
                ::syntax::ExprTuple {
                    attrs: f.fold_attributes(node.attrs),
                    paren_token: node.paren_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_expr),
                }
            }
            pub fn fold_expr_unary<F>(f: &mut F, node: ::syntax::ExprUnary) -> ::syntax::ExprUnary where
                F: Fold + ?Sized,
            {
                ::syntax::ExprUnary {
                    attrs: f.fold_attributes(node.attrs),
                    op: f.fold_un_op(node.op),
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_unsafe<F>(f: &mut F, node: ::syntax::ExprUnsafe) -> ::syntax::ExprUnsafe where
                F: Fold + ?Sized,
            {
                ::syntax::ExprUnsafe {
                    attrs: f.fold_attributes(node.attrs),
                    unsafe_token: node.unsafe_token,
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_while<F>(f: &mut F, node: ::syntax::ExprWhile) -> ::syntax::ExprWhile where
                F: Fold + ?Sized,
            {
                ::syntax::ExprWhile {
                    attrs: f.fold_attributes(node.attrs),
                    label: (node.label).map(|it| f.fold_label(it)),
                    while_token: node.while_token,
                    cond: Box::new(f.fold_expr(*node.cond)),
                    body: f.fold_block(node.body),
                }
            }
            pub fn fold_expr_yield<F>(f: &mut F, node: ::syntax::ExprYield) -> ::syntax::ExprYield where
                F: Fold + ?Sized,
            {
                ::syntax::ExprYield {
                    attrs: f.fold_attributes(node.attrs),
                    yield_token: node.yield_token,
                    expr: (node.expr).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_field<F>(f: &mut F, node: ::syntax::Field) -> ::syntax::Field where
                F: Fold + ?Sized,
            {
                ::syntax::Field {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    mutability: f.fold_field_mutability(node.mutability),
                    ident: (node.ident).map(|it| f.fold_ident(it)),
                    colon_token: node.colon_token,
                    ty: f.fold_type(node.ty),
                }
            }
            pub fn fold_field_mutability<F>(
                f: &mut F,
                node: ::syntax::FieldMutability,
            ) -> ::syntax::FieldMutability where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::FieldMutability::None => ::syntax::FieldMutability::None,
                }
            }
            pub fn fold_field_pat<F>(f: &mut F, node: ::syntax::FieldPat) -> ::syntax::FieldPat where
                F: Fold + ?Sized,
            {
                ::syntax::FieldPat {
                    attrs: f.fold_attributes(node.attrs),
                    member: f.fold_member(node.member),
                    colon_token: node.colon_token,
                    pat: Box::new(f.fold_pat(*node.pat)),
                }
            }
            pub fn fold_field_value<F>(f: &mut F, node: ::syntax::FieldValue) -> ::syntax::FieldValue where
                F: Fold + ?Sized,
            {
                ::syntax::FieldValue {
                    attrs: f.fold_attributes(node.attrs),
                    member: f.fold_member(node.member),
                    colon_token: node.colon_token,
                    expr: f.fold_expr(node.expr),
                }
            }
            pub fn fold_fields<F>(f: &mut F, node: ::syntax::Fields) -> ::syntax::Fields where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Fields::Named(_binding_0) => {
                        ::syntax::Fields::Named(f.fold_fields_named(_binding_0))
                    }
                    ::syntax::Fields::Unnamed(_binding_0) => {
                        ::syntax::Fields::Unnamed(f.fold_fields_unnamed(_binding_0))
                    }
                    ::syntax::Fields::Unit => ::syntax::Fields::Unit,
                }
            }
            pub fn fold_fields_named<F>(f: &mut F, node: ::syntax::FieldsNamed) -> ::syntax::FieldsNamed where
                F: Fold + ?Sized,
            {
                ::syntax::FieldsNamed {
                    brace_token: node.brace_token,
                    named: ::syntax::punctuated::fold(node.named, f, F::fold_field),
                }
            }
            pub fn fold_fields_unnamed<F>(
                f: &mut F,
                node: ::syntax::FieldsUnnamed,
            ) -> ::syntax::FieldsUnnamed where
                F: Fold + ?Sized,
            {
                ::syntax::FieldsUnnamed {
                    paren_token: node.paren_token,
                    unnamed: ::syntax::punctuated::fold(node.unnamed, f, F::fold_field),
                }
            }
            pub fn fold_file<F>(f: &mut F, node: ::syntax::File) -> ::syntax::File where
                F: Fold + ?Sized,
            {
                ::syntax::File {
                    shebang: node.shebang,
                    attrs: f.fold_attributes(node.attrs),
                    items: fold_vec(node.items, f, F::fold_item),
                }
            }
            pub fn fold_fn_arg<F>(f: &mut F, node: ::syntax::FnArg) -> ::syntax::FnArg where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::FnArg::Receiver(_binding_0) => {
                        ::syntax::FnArg::Receiver(f.fold_receiver(_binding_0))
                    }
                    ::syntax::FnArg::Typed(_binding_0) => {
                        ::syntax::FnArg::Typed(f.fold_pat_type(_binding_0))
                    }
                }
            }
            pub fn fold_foreign_item<F>(f: &mut F, node: ::syntax::ForeignItem) -> ::syntax::ForeignItem where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::ForeignItem::Fn(_binding_0) => {
                        ::syntax::ForeignItem::Fn(f.fold_foreign_item_fn(_binding_0))
                    }
                    ::syntax::ForeignItem::Static(_binding_0) => {
                        ::syntax::ForeignItem::Static(f.fold_foreign_item_static(_binding_0))
                    }
                    ::syntax::ForeignItem::Type(_binding_0) => {
                        ::syntax::ForeignItem::Type(f.fold_foreign_item_type(_binding_0))
                    }
                    ::syntax::ForeignItem::Macro(_binding_0) => {
                        ::syntax::ForeignItem::Macro(f.fold_foreign_item_macro(_binding_0))
                    }
                    ::syntax::ForeignItem::Verbatim(_binding_0) => {
                        ::syntax::ForeignItem::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_foreign_item_fn<F>(
                f: &mut F,
                node: ::syntax::ForeignItemFn,
            ) -> ::syntax::ForeignItemFn where
                F: Fold + ?Sized,
            {
                ::syntax::ForeignItemFn {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    sig: f.fold_signature(node.sig),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_foreign_item_macro<F>(
                f: &mut F,
                node: ::syntax::ForeignItemMacro,
            ) -> ::syntax::ForeignItemMacro where
                F: Fold + ?Sized,
            {
                ::syntax::ForeignItemMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_foreign_item_static<F>(
                f: &mut F,
                node: ::syntax::ForeignItemStatic,
            ) -> ::syntax::ForeignItemStatic where
                F: Fold + ?Sized,
            {
                ::syntax::ForeignItemStatic {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    static_token: node.static_token,
                    mutability: f.fold_static_mutability(node.mutability),
                    ident: f.fold_ident(node.ident),
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_foreign_item_type<F>(
                f: &mut F,
                node: ::syntax::ForeignItemType,
            ) -> ::syntax::ForeignItemType where
                F: Fold + ?Sized,
            {
                ::syntax::ForeignItemType {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    type_token: node.type_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_generic_argument<F>(
                f: &mut F,
                node: ::syntax::GenericArgument,
            ) -> ::syntax::GenericArgument where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::GenericArgument::Lifetime(_binding_0) => {
                        ::syntax::GenericArgument::Lifetime(f.fold_lifetime(_binding_0))
                    }
                    ::syntax::GenericArgument::Type(_binding_0) => {
                        ::syntax::GenericArgument::Type(f.fold_type(_binding_0))
                    }
                    ::syntax::GenericArgument::Const(_binding_0) => {
                        ::syntax::GenericArgument::Const(f.fold_expr(_binding_0))
                    }
                    ::syntax::GenericArgument::AssocType(_binding_0) => {
                        ::syntax::GenericArgument::AssocType(f.fold_assoc_type(_binding_0))
                    }
                    ::syntax::GenericArgument::AssocConst(_binding_0) => {
                        ::syntax::GenericArgument::AssocConst(f.fold_assoc_const(_binding_0))
                    }
                    ::syntax::GenericArgument::Constraint(_binding_0) => {
                        ::syntax::GenericArgument::Constraint(f.fold_constraint(_binding_0))
                    }
                }
            }
            pub fn fold_generic_param<F>(f: &mut F, node: ::syntax::GenericParam) -> ::syntax::GenericParam where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::GenericParam::Lifetime(_binding_0) => {
                        ::syntax::GenericParam::Lifetime(f.fold_lifetime_param(_binding_0))
                    }
                    ::syntax::GenericParam::Type(_binding_0) => {
                        ::syntax::GenericParam::Type(f.fold_type_param(_binding_0))
                    }
                    ::syntax::GenericParam::Const(_binding_0) => {
                        ::syntax::GenericParam::Const(f.fold_const_param(_binding_0))
                    }
                }
            }
            pub fn fold_generics<F>(f: &mut F, node: ::syntax::Generics) -> ::syntax::Generics where
                F: Fold + ?Sized,
            {
                ::syntax::Generics {
                    lt_token: node.lt_token,
                    params: ::syntax::punctuated::fold(node.params, f, F::fold_generic_param),
                    gt_token: node.gt_token,
                    where_clause: (node.where_clause).map(|it| f.fold_where_clause(it)),
                }
            }
            pub fn fold_ident<F>(f: &mut F, node: process::macros::Ident) -> process::macros::Ident where
                F: Fold + ?Sized,
            {
                let mut node = node;
                let span = f.fold_span(node.span());
                node.set_span(span);
                node
            }
            pub fn fold_impl_item<F>(f: &mut F, node: ::syntax::ImplItem) -> ::syntax::ImplItem where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::ImplItem::Const(_binding_0) => {
                        ::syntax::ImplItem::Const(f.fold_impl_item_const(_binding_0))
                    }
                    ::syntax::ImplItem::Fn(_binding_0) => {
                        ::syntax::ImplItem::Fn(f.fold_impl_item_fn(_binding_0))
                    }
                    ::syntax::ImplItem::Type(_binding_0) => {
                        ::syntax::ImplItem::Type(f.fold_impl_item_type(_binding_0))
                    }
                    ::syntax::ImplItem::Macro(_binding_0) => {
                        ::syntax::ImplItem::Macro(f.fold_impl_item_macro(_binding_0))
                    }
                    ::syntax::ImplItem::Verbatim(_binding_0) => {
                        ::syntax::ImplItem::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_impl_item_const<F>(
                f: &mut F,
                node: ::syntax::ImplItemConst,
            ) -> ::syntax::ImplItemConst where
                F: Fold + ?Sized,
            {
                ::syntax::ImplItemConst {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    defaultness: node.defaultness,
                    const_token: node.const_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    ty: f.fold_type(node.ty),
                    eq_token: node.eq_token,
                    expr: f.fold_expr(node.expr),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_impl_item_fn<F>(f: &mut F, node: ::syntax::ImplItemFn) -> ::syntax::ImplItemFn where
                F: Fold + ?Sized,
            {
                ::syntax::ImplItemFn {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    defaultness: node.defaultness,
                    sig: f.fold_signature(node.sig),
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_impl_item_macro<F>(
                f: &mut F,
                node: ::syntax::ImplItemMacro,
            ) -> ::syntax::ImplItemMacro where
                F: Fold + ?Sized,
            {
                ::syntax::ImplItemMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_impl_item_type<F>(
                f: &mut F,
                node: ::syntax::ImplItemType,
            ) -> ::syntax::ImplItemType where
                F: Fold + ?Sized,
            {
                ::syntax::ImplItemType {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    defaultness: node.defaultness,
                    type_token: node.type_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    eq_token: node.eq_token,
                    ty: f.fold_type(node.ty),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_impl_restriction<F>(
                f: &mut F,
                node: ::syntax::ImplRestriction,
            ) -> ::syntax::ImplRestriction where
                F: Fold + ?Sized,
            {
                match node {}
            }
            pub fn fold_index<F>(f: &mut F, node: ::syntax::Index) -> ::syntax::Index where
                F: Fold + ?Sized,
            {
                ::syntax::Index {
                    index: node.index,
                    span: f.fold_span(node.span),
                }
            }
            pub fn fold_item<F>(f: &mut F, node: ::syntax::Item) -> ::syntax::Item where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Item::Const(_binding_0) => {
                        ::syntax::Item::Const(f.fold_item_const(_binding_0))
                    }
                    ::syntax::Item::Enum(_binding_0) => ::syntax::Item::Enum(f.fold_item_enum(_binding_0)),
                    ::syntax::Item::ExternCrate(_binding_0) => {
                        ::syntax::Item::ExternCrate(f.fold_item_extern_crate(_binding_0))
                    }
                    ::syntax::Item::Fn(_binding_0) => ::syntax::Item::Fn(f.fold_item_fn(_binding_0)),
                    ::syntax::Item::ForeignMod(_binding_0) => {
                        ::syntax::Item::ForeignMod(f.fold_item_foreign_mod(_binding_0))
                    }
                    ::syntax::Item::Impl(_binding_0) => ::syntax::Item::Impl(f.fold_item_impl(_binding_0)),
                    ::syntax::Item::Macro(_binding_0) => {
                        ::syntax::Item::Macro(f.fold_item_macro(_binding_0))
                    }
                    ::syntax::Item::Mod(_binding_0) => ::syntax::Item::Mod(f.fold_item_mod(_binding_0)),
                    ::syntax::Item::Static(_binding_0) => {
                        ::syntax::Item::Static(f.fold_item_static(_binding_0))
                    }
                    ::syntax::Item::Struct(_binding_0) => {
                        ::syntax::Item::Struct(f.fold_item_struct(_binding_0))
                    }
                    ::syntax::Item::Trait(_binding_0) => {
                        ::syntax::Item::Trait(f.fold_item_trait(_binding_0))
                    }
                    ::syntax::Item::TraitAlias(_binding_0) => {
                        ::syntax::Item::TraitAlias(f.fold_item_trait_alias(_binding_0))
                    }
                    ::syntax::Item::Type(_binding_0) => ::syntax::Item::Type(f.fold_item_type(_binding_0)),
                    ::syntax::Item::Union(_binding_0) => {
                        ::syntax::Item::Union(f.fold_item_union(_binding_0))
                    }
                    ::syntax::Item::Use(_binding_0) => ::syntax::Item::Use(f.fold_item_use(_binding_0)),
                    ::syntax::Item::Verbatim(_binding_0) => {
                        ::syntax::Item::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_item_const<F>(f: &mut F, node: ::syntax::ItemConst) -> ::syntax::ItemConst where
                F: Fold + ?Sized,
            {
                ::syntax::ItemConst {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    const_token: node.const_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    eq_token: node.eq_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_enum<F>(f: &mut F, node: ::syntax::ItemEnum) -> ::syntax::ItemEnum where
                F: Fold + ?Sized,
            {
                ::syntax::ItemEnum {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    enum_token: node.enum_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    brace_token: node.brace_token,
                    variants: ::syntax::punctuated::fold(node.variants, f, F::fold_variant),
                }
            }
            pub fn fold_item_extern_crate<F>(
                f: &mut F,
                node: ::syntax::ItemExternCrate,
            ) -> ::syntax::ItemExternCrate where
                F: Fold + ?Sized,
            {
                ::syntax::ItemExternCrate {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    extern_token: node.extern_token,
                    crate_token: node.crate_token,
                    ident: f.fold_ident(node.ident),
                    rename: (node.rename).map(|it| ((it).0, f.fold_ident((it).1))),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_fn<F>(f: &mut F, node: ::syntax::ItemFn) -> ::syntax::ItemFn where
                F: Fold + ?Sized,
            {
                ::syntax::ItemFn {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    sig: f.fold_signature(node.sig),
                    block: Box::new(f.fold_block(*node.block)),
                }
            }
            pub fn fold_item_foreign_mod<F>(
                f: &mut F,
                node: ::syntax::ItemForeignMod,
            ) -> ::syntax::ItemForeignMod where
                F: Fold + ?Sized,
            {
                ::syntax::ItemForeignMod {
                    attrs: f.fold_attributes(node.attrs),
                    unsafety: node.unsafety,
                    abi: f.fold_abi(node.abi),
                    brace_token: node.brace_token,
                    items: fold_vec(node.items, f, F::fold_foreign_item),
                }
            }
            pub fn fold_item_impl<F>(f: &mut F, node: ::syntax::ItemImpl) -> ::syntax::ItemImpl where
                F: Fold + ?Sized,
            {
                ::syntax::ItemImpl {
                    attrs: f.fold_attributes(node.attrs),
                    defaultness: node.defaultness,
                    unsafety: node.unsafety,
                    impl_token: node.impl_token,
                    generics: f.fold_generics(node.generics),
                    trait_: (node.trait_).map(|it| ((it).0, f.fold_path((it).1), (it).2)),
                    self_ty: Box::new(f.fold_type(*node.self_ty)),
                    brace_token: node.brace_token,
                    items: fold_vec(node.items, f, F::fold_impl_item),
                }
            }
            pub fn fold_item_macro<F>(f: &mut F, node: ::syntax::ItemMacro) -> ::syntax::ItemMacro where
                F: Fold + ?Sized,
            {
                ::syntax::ItemMacro {
                    attrs: f.fold_attributes(node.attrs),
                    ident: (node.ident).map(|it| f.fold_ident(it)),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_mod<F>(f: &mut F, node: ::syntax::ItemMod) -> ::syntax::ItemMod where
                F: Fold + ?Sized,
            {
                ::syntax::ItemMod {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    unsafety: node.unsafety,
                    mod_token: node.mod_token,
                    ident: f.fold_ident(node.ident),
                    content: (node.content).map(|it| ((it).0, fold_vec((it).1, f, F::fold_item))),
                    semi: node.semi,
                }
            }
            pub fn fold_item_static<F>(f: &mut F, node: ::syntax::ItemStatic) -> ::syntax::ItemStatic where
                F: Fold + ?Sized,
            {
                ::syntax::ItemStatic {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    static_token: node.static_token,
                    mutability: f.fold_static_mutability(node.mutability),
                    ident: f.fold_ident(node.ident),
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    eq_token: node.eq_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_struct<F>(f: &mut F, node: ::syntax::ItemStruct) -> ::syntax::ItemStruct where
                F: Fold + ?Sized,
            {
                ::syntax::ItemStruct {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    struct_token: node.struct_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    fields: f.fold_fields(node.fields),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_trait<F>(f: &mut F, node: ::syntax::ItemTrait) -> ::syntax::ItemTrait where
                F: Fold + ?Sized,
            {
                ::syntax::ItemTrait {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    unsafety: node.unsafety,
                    auto_token: node.auto_token,
                    restriction: (node.restriction).map(|it| f.fold_impl_restriction(it)),
                    trait_token: node.trait_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    supertraits: ::syntax::punctuated::fold(
                        node.supertraits,
                        f,
                        F::fold_type_param_bound,
                    ),
                    brace_token: node.brace_token,
                    items: fold_vec(node.items, f, F::fold_trait_item),
                }
            }
            pub fn fold_item_trait_alias<F>(
                f: &mut F,
                node: ::syntax::ItemTraitAlias,
            ) -> ::syntax::ItemTraitAlias where
                F: Fold + ?Sized,
            {
                ::syntax::ItemTraitAlias {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    trait_token: node.trait_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    eq_token: node.eq_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_type<F>(f: &mut F, node: ::syntax::ItemType) -> ::syntax::ItemType where
                F: Fold + ?Sized,
            {
                ::syntax::ItemType {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    type_token: node.type_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    eq_token: node.eq_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_union<F>(f: &mut F, node: ::syntax::ItemUnion) -> ::syntax::ItemUnion where
                F: Fold + ?Sized,
            {
                ::syntax::ItemUnion {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    union_token: node.union_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    fields: f.fold_fields_named(node.fields),
                }
            }
            pub fn fold_item_use<F>(f: &mut F, node: ::syntax::ItemUse) -> ::syntax::ItemUse where
                F: Fold + ?Sized,
            {
                ::syntax::ItemUse {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    use_token: node.use_token,
                    leading_colon: node.leading_colon,
                    tree: f.fold_use_tree(node.tree),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_label<F>(f: &mut F, node: ::syntax::Label) -> ::syntax::Label where
                F: Fold + ?Sized,
            {
                ::syntax::Label {
                    name: f.fold_lifetime(node.name),
                    colon_token: node.colon_token,
                }
            }
            pub fn fold_lifetime<F>(f: &mut F, node: ::syntax::Lifetime) -> ::syntax::Lifetime where
                F: Fold + ?Sized,
            {
                ::syntax::Lifetime {
                    apostrophe: f.fold_span(node.apostrophe),
                    ident: f.fold_ident(node.ident),
                }
            }
            pub fn fold_lifetime_param<F>(
                f: &mut F,
                node: ::syntax::LifetimeParam,
            ) -> ::syntax::LifetimeParam where
                F: Fold + ?Sized,
            {
                ::syntax::LifetimeParam {
                    attrs: f.fold_attributes(node.attrs),
                    lifetime: f.fold_lifetime(node.lifetime),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_lifetime),
                }
            }
            pub fn fold_lit<F>(f: &mut F, node: ::syntax::Lit) -> ::syntax::Lit where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Lit::Str(_binding_0) => ::syntax::Lit::Str(f.fold_lit_str(_binding_0)),
                    ::syntax::Lit::ByteStr(_binding_0) => {
                        ::syntax::Lit::ByteStr(f.fold_lit_byte_str(_binding_0))
                    }
                    ::syntax::Lit::CStr(_binding_0) => ::syntax::Lit::CStr(f.fold_lit_cstr(_binding_0)),
                    ::syntax::Lit::Byte(_binding_0) => ::syntax::Lit::Byte(f.fold_lit_byte(_binding_0)),
                    ::syntax::Lit::Char(_binding_0) => ::syntax::Lit::Char(f.fold_lit_char(_binding_0)),
                    ::syntax::Lit::Int(_binding_0) => ::syntax::Lit::Int(f.fold_lit_int(_binding_0)),
                    ::syntax::Lit::Float(_binding_0) => ::syntax::Lit::Float(f.fold_lit_float(_binding_0)),
                    ::syntax::Lit::Bool(_binding_0) => ::syntax::Lit::Bool(f.fold_lit_bool(_binding_0)),
                    ::syntax::Lit::Verbatim(_binding_0) => ::syntax::Lit::Verbatim(_binding_0),
                }
            }
            pub fn fold_lit_bool<F>(f: &mut F, node: ::syntax::LitBool) -> ::syntax::LitBool where
                F: Fold + ?Sized,
            {
                ::syntax::LitBool {
                    value: node.value,
                    span: f.fold_span(node.span),
                }
            }
            pub fn fold_lit_byte<F>(f: &mut F, node: ::syntax::LitByte) -> ::syntax::LitByte where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_byte_str<F>(f: &mut F, node: ::syntax::LitByteStr) -> ::syntax::LitByteStr where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_cstr<F>(f: &mut F, node: ::syntax::LitCStr) -> ::syntax::LitCStr where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_char<F>(f: &mut F, node: ::syntax::LitChar) -> ::syntax::LitChar where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_float<F>(f: &mut F, node: ::syntax::LitFloat) -> ::syntax::LitFloat where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_int<F>(f: &mut F, node: ::syntax::LitInt) -> ::syntax::LitInt where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_str<F>(f: &mut F, node: ::syntax::LitStr) -> ::syntax::LitStr where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_local<F>(f: &mut F, node: ::syntax::Local) -> ::syntax::Local where
                F: Fold + ?Sized,
            {
                ::syntax::Local {
                    attrs: f.fold_attributes(node.attrs),
                    let_token: node.let_token,
                    pat: f.fold_pat(node.pat),
                    init: (node.init).map(|it| f.fold_local_init(it)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_local_init<F>(f: &mut F, node: ::syntax::LocalInit) -> ::syntax::LocalInit where
                F: Fold + ?Sized,
            {
                ::syntax::LocalInit {
                    eq_token: node.eq_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    diverge: (node.diverge).map(|it| ((it).0, Box::new(f.fold_expr(*(it).1)))),
                }
            }
            pub fn fold_macro<F>(f: &mut F, node: ::syntax::Macro) -> ::syntax::Macro where
                F: Fold + ?Sized,
            {
                ::syntax::Macro {
                    path: f.fold_path(node.path),
                    bang_token: node.bang_token,
                    delimiter: f.fold_macro_delimiter(node.delimiter),
                    tokens: f.fold_token_stream(node.tokens),
                }
            }
            pub fn fold_macro_delimiter<F>(
                f: &mut F,
                node: ::syntax::MacroDelimiter,
            ) -> ::syntax::MacroDelimiter where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::MacroDelimiter::Paren(_binding_0) => {
                        ::syntax::MacroDelimiter::Paren(_binding_0)
                    }
                    ::syntax::MacroDelimiter::Brace(_binding_0) => {
                        ::syntax::MacroDelimiter::Brace(_binding_0)
                    }
                    ::syntax::MacroDelimiter::Bracket(_binding_0) => {
                        ::syntax::MacroDelimiter::Bracket(_binding_0)
                    }
                }
            }
            pub fn fold_member<F>(f: &mut F, node: ::syntax::Member) -> ::syntax::Member where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Member::Named(_binding_0) => {
                        ::syntax::Member::Named(f.fold_ident(_binding_0))
                    }
                    ::syntax::Member::Unnamed(_binding_0) => {
                        ::syntax::Member::Unnamed(f.fold_index(_binding_0))
                    }
                }
            }
            pub fn fold_meta<F>(f: &mut F, node: ::syntax::Meta) -> ::syntax::Meta where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Meta::Path(_binding_0) => ::syntax::Meta::Path(f.fold_path(_binding_0)),
                    ::syntax::Meta::List(_binding_0) => ::syntax::Meta::List(f.fold_meta_list(_binding_0)),
                    ::syntax::Meta::NameValue(_binding_0) => {
                        ::syntax::Meta::NameValue(f.fold_meta_name_value(_binding_0))
                    }
                }
            }
            pub fn fold_meta_list<F>(f: &mut F, node: ::syntax::MetaList) -> ::syntax::MetaList where
                F: Fold + ?Sized,
            {
                ::syntax::MetaList {
                    path: f.fold_path(node.path),
                    delimiter: f.fold_macro_delimiter(node.delimiter),
                    tokens: f.fold_token_stream(node.tokens),
                }
            }
            pub fn fold_meta_name_value<F>(
                f: &mut F,
                node: ::syntax::MetaNameValue,
            ) -> ::syntax::MetaNameValue where
                F: Fold + ?Sized,
            {
                ::syntax::MetaNameValue {
                    path: f.fold_path(node.path),
                    eq_token: node.eq_token,
                    value: f.fold_expr(node.value),
                }
            }
            pub fn fold_parenthesized_generic_arguments<F>(
                f: &mut F,
                node: ::syntax::ParenthesizedGenericArguments,
            ) -> ::syntax::ParenthesizedGenericArguments where
                F: Fold + ?Sized,
            {
                ::syntax::ParenthesizedGenericArguments {
                    paren_token: node.paren_token,
                    inputs: ::syntax::punctuated::fold(node.inputs, f, F::fold_type),
                    output: f.fold_return_type(node.output),
                }
            }
            pub fn fold_pat<F>(f: &mut F, node: ::syntax::Pat) -> ::syntax::Pat where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Pat::Const(_binding_0) => ::syntax::Pat::Const(f.fold_expr_const(_binding_0)),
                    ::syntax::Pat::Ident(_binding_0) => ::syntax::Pat::Ident(f.fold_pat_ident(_binding_0)),
                    ::syntax::Pat::Lit(_binding_0) => ::syntax::Pat::Lit(f.fold_expr_lit(_binding_0)),
                    ::syntax::Pat::Macro(_binding_0) => ::syntax::Pat::Macro(f.fold_expr_macro(_binding_0)),
                    ::syntax::Pat::Or(_binding_0) => ::syntax::Pat::Or(f.fold_pat_or(_binding_0)),
                    ::syntax::Pat::Paren(_binding_0) => ::syntax::Pat::Paren(f.fold_pat_paren(_binding_0)),
                    ::syntax::Pat::Path(_binding_0) => ::syntax::Pat::Path(f.fold_expr_path(_binding_0)),
                    ::syntax::Pat::Range(_binding_0) => ::syntax::Pat::Range(f.fold_expr_range(_binding_0)),
                    ::syntax::Pat::Reference(_binding_0) => {
                        ::syntax::Pat::Reference(f.fold_pat_reference(_binding_0))
                    }
                    ::syntax::Pat::Rest(_binding_0) => ::syntax::Pat::Rest(f.fold_pat_rest(_binding_0)),
                    ::syntax::Pat::Slice(_binding_0) => ::syntax::Pat::Slice(f.fold_pat_slice(_binding_0)),
                    ::syntax::Pat::Struct(_binding_0) => {
                        ::syntax::Pat::Struct(f.fold_pat_struct(_binding_0))
                    }
                    ::syntax::Pat::Tuple(_binding_0) => ::syntax::Pat::Tuple(f.fold_pat_tuple(_binding_0)),
                    ::syntax::Pat::TupleStruct(_binding_0) => {
                        ::syntax::Pat::TupleStruct(f.fold_pat_tuple_struct(_binding_0))
                    }
                    ::syntax::Pat::Type(_binding_0) => ::syntax::Pat::Type(f.fold_pat_type(_binding_0)),
                    ::syntax::Pat::Verbatim(_binding_0) => {
                        ::syntax::Pat::Verbatim(f.fold_token_stream(_binding_0))
                    }
                    ::syntax::Pat::Wild(_binding_0) => ::syntax::Pat::Wild(f.fold_pat_wild(_binding_0)),
                }
            }
            pub fn fold_pat_ident<F>(f: &mut F, node: ::syntax::PatIdent) -> ::syntax::PatIdent where
                F: Fold + ?Sized,
            {
                ::syntax::PatIdent {
                    attrs: f.fold_attributes(node.attrs),
                    by_ref: node.by_ref,
                    mutability: node.mutability,
                    ident: f.fold_ident(node.ident),
                    subpat: (node.subpat).map(|it| ((it).0, Box::new(f.fold_pat(*(it).1)))),
                }
            }
            pub fn fold_pat_or<F>(f: &mut F, node: ::syntax::PatOr) -> ::syntax::PatOr where
                F: Fold + ?Sized,
            {
                ::syntax::PatOr {
                    attrs: f.fold_attributes(node.attrs),
                    leading_vert: node.leading_vert,
                    cases: ::syntax::punctuated::fold(node.cases, f, F::fold_pat),
                }
            }
            pub fn fold_pat_paren<F>(f: &mut F, node: ::syntax::PatParen) -> ::syntax::PatParen where
                F: Fold + ?Sized,
            {
                ::syntax::PatParen {
                    attrs: f.fold_attributes(node.attrs),
                    paren_token: node.paren_token,
                    pat: Box::new(f.fold_pat(*node.pat)),
                }
            }
            pub fn fold_pat_reference<F>(f: &mut F, node: ::syntax::PatReference) -> ::syntax::PatReference where
                F: Fold + ?Sized,
            {
                ::syntax::PatReference {
                    attrs: f.fold_attributes(node.attrs),
                    and_token: node.and_token,
                    mutability: node.mutability,
                    pat: Box::new(f.fold_pat(*node.pat)),
                }
            }
            pub fn fold_pat_rest<F>(f: &mut F, node: ::syntax::PatRest) -> ::syntax::PatRest where
                F: Fold + ?Sized,
            {
                ::syntax::PatRest {
                    attrs: f.fold_attributes(node.attrs),
                    dot2_token: node.dot2_token,
                }
            }
            pub fn fold_pat_slice<F>(f: &mut F, node: ::syntax::PatSlice) -> ::syntax::PatSlice where
                F: Fold + ?Sized,
            {
                ::syntax::PatSlice {
                    attrs: f.fold_attributes(node.attrs),
                    bracket_token: node.bracket_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_pat),
                }
            }
            pub fn fold_pat_struct<F>(f: &mut F, node: ::syntax::PatStruct) -> ::syntax::PatStruct where
                F: Fold + ?Sized,
            {
                ::syntax::PatStruct {
                    attrs: f.fold_attributes(node.attrs),
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                    brace_token: node.brace_token,
                    fields: ::syntax::punctuated::fold(node.fields, f, F::fold_field_pat),
                    rest: (node.rest).map(|it| f.fold_pat_rest(it)),
                }
            }
            pub fn fold_pat_tuple<F>(f: &mut F, node: ::syntax::PatTuple) -> ::syntax::PatTuple where
                F: Fold + ?Sized,
            {
                ::syntax::PatTuple {
                    attrs: f.fold_attributes(node.attrs),
                    paren_token: node.paren_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_pat),
                }
            }
            pub fn fold_pat_tuple_struct<F>(
                f: &mut F,
                node: ::syntax::PatTupleStruct,
            ) -> ::syntax::PatTupleStruct where
                F: Fold + ?Sized,
            {
                ::syntax::PatTupleStruct {
                    attrs: f.fold_attributes(node.attrs),
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                    paren_token: node.paren_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_pat),
                }
            }
            pub fn fold_pat_type<F>(f: &mut F, node: ::syntax::PatType) -> ::syntax::PatType where
                F: Fold + ?Sized,
            {
                ::syntax::PatType {
                    attrs: f.fold_attributes(node.attrs),
                    pat: Box::new(f.fold_pat(*node.pat)),
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                }
            }
            pub fn fold_pat_wild<F>(f: &mut F, node: ::syntax::PatWild) -> ::syntax::PatWild where
                F: Fold + ?Sized,
            {
                ::syntax::PatWild {
                    attrs: f.fold_attributes(node.attrs),
                    underscore_token: node.underscore_token,
                }
            }
            pub fn fold_path<F>(f: &mut F, node: ::syntax::Path) -> ::syntax::Path where
                F: Fold + ?Sized,
            {
                ::syntax::Path {
                    leading_colon: node.leading_colon,
                    segments: ::syntax::punctuated::fold(node.segments, f, F::fold_path_segment),
                }
            }
            pub fn fold_path_arguments<F>(
                f: &mut F,
                node: ::syntax::PathArguments,
            ) -> ::syntax::PathArguments where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::PathArguments::None => ::syntax::PathArguments::None,
                    ::syntax::PathArguments::AngleBracketed(_binding_0) => {
                        ::syntax::PathArguments::AngleBracketed(
                            f.fold_angle_bracketed_generic_arguments(_binding_0),
                        )
                    }
                    ::syntax::PathArguments::Parenthesized(_binding_0) => {
                        ::syntax::PathArguments::Parenthesized(
                            f.fold_parenthesized_generic_arguments(_binding_0),
                        )
                    }
                }
            }
            pub fn fold_path_segment<F>(f: &mut F, node: ::syntax::PathSegment) -> ::syntax::PathSegment where
                F: Fold + ?Sized,
            {
                ::syntax::PathSegment {
                    ident: f.fold_ident(node.ident),
                    arguments: f.fold_path_arguments(node.arguments),
                }
            }
            pub fn fold_pointer_mutability<F>(
                f: &mut F,
                node: ::syntax::PointerMutability,
            ) -> ::syntax::PointerMutability where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::PointerMutability::Const(_binding_0) => {
                        ::syntax::PointerMutability::Const(_binding_0)
                    }
                    ::syntax::PointerMutability::Mut(_binding_0) => {
                        ::syntax::PointerMutability::Mut(_binding_0)
                    }
                }
            }
            pub fn fold_precise_capture<F>(
                f: &mut F,
                node: ::syntax::PreciseCapture,
            ) -> ::syntax::PreciseCapture where
                F: Fold + ?Sized,
            {
                ::syntax::PreciseCapture {
                    use_token: node.use_token,
                    lt_token: node.lt_token,
                    params: ::syntax::punctuated::fold(node.params, f, F::fold_captured_param),
                    gt_token: node.gt_token,
                }
            }
            pub fn fold_predicate_lifetime<F>(
                f: &mut F,
                node: ::syntax::PredicateLifetime,
            ) -> ::syntax::PredicateLifetime where
                F: Fold + ?Sized,
            {
                ::syntax::PredicateLifetime {
                    lifetime: f.fold_lifetime(node.lifetime),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_lifetime),
                }
            }
            pub fn fold_predicate_type<F>(
                f: &mut F,
                node: ::syntax::PredicateType,
            ) -> ::syntax::PredicateType where
                F: Fold + ?Sized,
            {
                ::syntax::PredicateType {
                    lifetimes: (node.lifetimes).map(|it| f.fold_bound_lifetimes(it)),
                    bounded_ty: f.fold_type(node.bounded_ty),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                }
            }
            pub fn fold_qself<F>(f: &mut F, node: ::syntax::QSelf) -> ::syntax::QSelf where
                F: Fold + ?Sized,
            {
                ::syntax::QSelf {
                    lt_token: node.lt_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    position: node.position,
                    as_token: node.as_token,
                    gt_token: node.gt_token,
                }
            }
            pub fn fold_range_limits<F>(f: &mut F, node: ::syntax::RangeLimits) -> ::syntax::RangeLimits where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::RangeLimits::HalfOpen(_binding_0) => {
                        ::syntax::RangeLimits::HalfOpen(_binding_0)
                    }
                    ::syntax::RangeLimits::Closed(_binding_0) => ::syntax::RangeLimits::Closed(_binding_0),
                }
            }
            pub fn fold_receiver<F>(f: &mut F, node: ::syntax::Receiver) -> ::syntax::Receiver where
                F: Fold + ?Sized,
            {
                ::syntax::Receiver {
                    attrs: f.fold_attributes(node.attrs),
                    reference: (node.reference)
                        .map(|it| ((it).0, ((it).1).map(|it| f.fold_lifetime(it)))),
                    mutability: node.mutability,
                    self_token: node.self_token,
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                }
            }
            pub fn fold_return_type<F>(f: &mut F, node: ::syntax::ReturnType) -> ::syntax::ReturnType where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::ReturnType::Default => ::syntax::ReturnType::Default,
                    ::syntax::ReturnType::Type(_binding_0, _binding_1) => {
                        ::syntax::ReturnType::Type(_binding_0, Box::new(f.fold_type(*_binding_1)))
                    }
                }
            }
            pub fn fold_signature<F>(f: &mut F, node: ::syntax::Signature) -> ::syntax::Signature where
                F: Fold + ?Sized,
            {
                ::syntax::Signature {
                    constness: node.constness,
                    asyncness: node.asyncness,
                    unsafety: node.unsafety,
                    abi: (node.abi).map(|it| f.fold_abi(it)),
                    fn_token: node.fn_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    paren_token: node.paren_token,
                    inputs: ::syntax::punctuated::fold(node.inputs, f, F::fold_fn_arg),
                    variadic: (node.variadic).map(|it| f.fold_variadic(it)),
                    output: f.fold_return_type(node.output),
                }
            }
            pub fn fold_span<F>(f: &mut F, node: process::macros::Span) -> process::macros::Span where
                F: Fold + ?Sized,
            {
                node
            }
            pub fn fold_static_mutability<F>(
                f: &mut F,
                node: ::syntax::StaticMutability,
            ) -> ::syntax::StaticMutability where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::StaticMutability::Mut(_binding_0) => {
                        ::syntax::StaticMutability::Mut(_binding_0)
                    }
                    ::syntax::StaticMutability::None => ::syntax::StaticMutability::None,
                }
            }
            pub fn fold_stmt<F>(f: &mut F, node: ::syntax::Stmt) -> ::syntax::Stmt where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Stmt::Local(_binding_0) => ::syntax::Stmt::Local(f.fold_local(_binding_0)),
                    ::syntax::Stmt::Item(_binding_0) => ::syntax::Stmt::Item(f.fold_item(_binding_0)),
                    ::syntax::Stmt::Expr(_binding_0, _binding_1) => {
                        ::syntax::Stmt::Expr(f.fold_expr(_binding_0), _binding_1)
                    }
                    ::syntax::Stmt::Macro(_binding_0) => {
                        ::syntax::Stmt::Macro(f.fold_stmt_macro(_binding_0))
                    }
                }
            }
            pub fn fold_stmt_macro<F>(f: &mut F, node: ::syntax::StmtMacro) -> ::syntax::StmtMacro where
                F: Fold + ?Sized,
            {
                ::syntax::StmtMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_trait_bound<F>(f: &mut F, node: ::syntax::TraitBound) -> ::syntax::TraitBound where
                F: Fold + ?Sized,
            {
                ::syntax::TraitBound {
                    paren_token: node.paren_token,
                    modifier: f.fold_trait_bound_modifier(node.modifier),
                    lifetimes: (node.lifetimes).map(|it| f.fold_bound_lifetimes(it)),
                    path: f.fold_path(node.path),
                }
            }
            pub fn fold_trait_bound_modifier<F>(
                f: &mut F,
                node: ::syntax::TraitBoundModifier,
            ) -> ::syntax::TraitBoundModifier where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::TraitBoundModifier::None => ::syntax::TraitBoundModifier::None,
                    ::syntax::TraitBoundModifier::Maybe(_binding_0) => {
                        ::syntax::TraitBoundModifier::Maybe(_binding_0)
                    }
                }
            }
            pub fn fold_trait_item<F>(f: &mut F, node: ::syntax::TraitItem) -> ::syntax::TraitItem where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::TraitItem::Const(_binding_0) => {
                        ::syntax::TraitItem::Const(f.fold_trait_item_const(_binding_0))
                    }
                    ::syntax::TraitItem::Fn(_binding_0) => {
                        ::syntax::TraitItem::Fn(f.fold_trait_item_fn(_binding_0))
                    }
                    ::syntax::TraitItem::Type(_binding_0) => {
                        ::syntax::TraitItem::Type(f.fold_trait_item_type(_binding_0))
                    }
                    ::syntax::TraitItem::Macro(_binding_0) => {
                        ::syntax::TraitItem::Macro(f.fold_trait_item_macro(_binding_0))
                    }
                    ::syntax::TraitItem::Verbatim(_binding_0) => {
                        ::syntax::TraitItem::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_trait_item_const<F>(
                f: &mut F,
                node: ::syntax::TraitItemConst,
            ) -> ::syntax::TraitItemConst where
                F: Fold + ?Sized,
            {
                ::syntax::TraitItemConst {
                    attrs: f.fold_attributes(node.attrs),
                    const_token: node.const_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    ty: f.fold_type(node.ty),
                    default: (node.default).map(|it| ((it).0, f.fold_expr((it).1))),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_trait_item_fn<F>(f: &mut F, node: ::syntax::TraitItemFn) -> ::syntax::TraitItemFn where
                F: Fold + ?Sized,
            {
                ::syntax::TraitItemFn {
                    attrs: f.fold_attributes(node.attrs),
                    sig: f.fold_signature(node.sig),
                    default: (node.default).map(|it| f.fold_block(it)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_trait_item_macro<F>(
                f: &mut F,
                node: ::syntax::TraitItemMacro,
            ) -> ::syntax::TraitItemMacro where
                F: Fold + ?Sized,
            {
                ::syntax::TraitItemMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_trait_item_type<F>(
                f: &mut F,
                node: ::syntax::TraitItemType,
            ) -> ::syntax::TraitItemType where
                F: Fold + ?Sized,
            {
                ::syntax::TraitItemType {
                    attrs: f.fold_attributes(node.attrs),
                    type_token: node.type_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                    default: (node.default).map(|it| ((it).0, f.fold_type((it).1))),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_type<F>(f: &mut F, node: ::syntax::Type) -> ::syntax::Type where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Type::Array(_binding_0) => {
                        ::syntax::Type::Array(f.fold_type_array(_binding_0))
                    }
                    ::syntax::Type::BareFn(_binding_0) => {
                        ::syntax::Type::BareFn(f.fold_type_bare_fn(_binding_0))
                    }
                    ::syntax::Type::Group(_binding_0) => {
                        ::syntax::Type::Group(f.fold_type_group(_binding_0))
                    }
                    ::syntax::Type::ImplTrait(_binding_0) => {
                        ::syntax::Type::ImplTrait(f.fold_type_impl_trait(_binding_0))
                    }
                    ::syntax::Type::Infer(_binding_0) => {
                        ::syntax::Type::Infer(f.fold_type_infer(_binding_0))
                    }
                    ::syntax::Type::Macro(_binding_0) => {
                        ::syntax::Type::Macro(f.fold_type_macro(_binding_0))
                    }
                    ::syntax::Type::Never(_binding_0) => {
                        ::syntax::Type::Never(f.fold_type_never(_binding_0))
                    }
                    ::syntax::Type::Paren(_binding_0) => {
                        ::syntax::Type::Paren(f.fold_type_paren(_binding_0))
                    }
                    ::syntax::Type::Path(_binding_0) => ::syntax::Type::Path(f.fold_type_path(_binding_0)),
                    ::syntax::Type::Ptr(_binding_0) => ::syntax::Type::Ptr(f.fold_type_ptr(_binding_0)),
                    ::syntax::Type::Reference(_binding_0) => {
                        ::syntax::Type::Reference(f.fold_type_reference(_binding_0))
                    }
                    ::syntax::Type::Slice(_binding_0) => {
                        ::syntax::Type::Slice(f.fold_type_slice(_binding_0))
                    }
                    ::syntax::Type::TraitObject(_binding_0) => {
                        ::syntax::Type::TraitObject(f.fold_type_trait_object(_binding_0))
                    }
                    ::syntax::Type::Tuple(_binding_0) => {
                        ::syntax::Type::Tuple(f.fold_type_tuple(_binding_0))
                    }
                    ::syntax::Type::Verbatim(_binding_0) => {
                        ::syntax::Type::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_type_array<F>(f: &mut F, node: ::syntax::TypeArray) -> ::syntax::TypeArray where
                F: Fold + ?Sized,
            {
                ::syntax::TypeArray {
                    bracket_token: node.bracket_token,
                    elem: Box::new(f.fold_type(*node.elem)),
                    semi_token: node.semi_token,
                    len: f.fold_expr(node.len),
                }
            }
            pub fn fold_type_bare_fn<F>(f: &mut F, node: ::syntax::TypeBareFn) -> ::syntax::TypeBareFn where
                F: Fold + ?Sized,
            {
                ::syntax::TypeBareFn {
                    lifetimes: (node.lifetimes).map(|it| f.fold_bound_lifetimes(it)),
                    unsafety: node.unsafety,
                    abi: (node.abi).map(|it| f.fold_abi(it)),
                    fn_token: node.fn_token,
                    paren_token: node.paren_token,
                    inputs: ::syntax::punctuated::fold(node.inputs, f, F::fold_bare_fn_arg),
                    variadic: (node.variadic).map(|it| f.fold_bare_variadic(it)),
                    output: f.fold_return_type(node.output),
                }
            }
            pub fn fold_type_group<F>(f: &mut F, node: ::syntax::TypeGroup) -> ::syntax::TypeGroup where
                F: Fold + ?Sized,
            {
                ::syntax::TypeGroup {
                    group_token: node.group_token,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_impl_trait<F>(
                f: &mut F,
                node: ::syntax::TypeImplTrait,
            ) -> ::syntax::TypeImplTrait where
                F: Fold + ?Sized,
            {
                ::syntax::TypeImplTrait {
                    impl_token: node.impl_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                }
            }
            pub fn fold_type_infer<F>(f: &mut F, node: ::syntax::TypeInfer) -> ::syntax::TypeInfer where
                F: Fold + ?Sized,
            {
                ::syntax::TypeInfer {
                    underscore_token: node.underscore_token,
                }
            }
            pub fn fold_type_macro<F>(f: &mut F, node: ::syntax::TypeMacro) -> ::syntax::TypeMacro where
                F: Fold + ?Sized,
            {
                ::syntax::TypeMacro {
                    mac: f.fold_macro(node.mac),
                }
            }
            pub fn fold_type_never<F>(f: &mut F, node: ::syntax::TypeNever) -> ::syntax::TypeNever where
                F: Fold + ?Sized,
            {
                ::syntax::TypeNever {
                    bang_token: node.bang_token,
                }
            }
            pub fn fold_type_param<F>(f: &mut F, node: ::syntax::TypeParam) -> ::syntax::TypeParam where
                F: Fold + ?Sized,
            {
                ::syntax::TypeParam {
                    attrs: f.fold_attributes(node.attrs),
                    ident: f.fold_ident(node.ident),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                    eq_token: node.eq_token,
                    default: (node.default).map(|it| f.fold_type(it)),
                }
            }
            pub fn fold_type_param_bound<F>(
                f: &mut F,
                node: ::syntax::TypeParamBound,
            ) -> ::syntax::TypeParamBound where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::TypeParamBound::Trait(_binding_0) => {
                        ::syntax::TypeParamBound::Trait(f.fold_trait_bound(_binding_0))
                    }
                    ::syntax::TypeParamBound::Lifetime(_binding_0) => {
                        ::syntax::TypeParamBound::Lifetime(f.fold_lifetime(_binding_0))
                    }
                    ::syntax::TypeParamBound::PreciseCapture(_binding_0) => {
                        ::syntax::TypeParamBound::PreciseCapture(
                            full!(f.fold_precise_capture(_binding_0)),
                        )
                    }
                    ::syntax::TypeParamBound::Verbatim(_binding_0) => {
                        ::syntax::TypeParamBound::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_type_paren<F>(f: &mut F, node: ::syntax::TypeParen) -> ::syntax::TypeParen where
                F: Fold + ?Sized,
            {
                ::syntax::TypeParen {
                    paren_token: node.paren_token,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_path<F>(f: &mut F, node: ::syntax::TypePath) -> ::syntax::TypePath where
                F: Fold + ?Sized,
            {
                ::syntax::TypePath {
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                }
            }
            pub fn fold_type_ptr<F>(f: &mut F, node: ::syntax::TypePtr) -> ::syntax::TypePtr where
                F: Fold + ?Sized,
            {
                ::syntax::TypePtr {
                    star_token: node.star_token,
                    const_token: node.const_token,
                    mutability: node.mutability,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_reference<F>(
                f: &mut F,
                node: ::syntax::TypeReference,
            ) -> ::syntax::TypeReference where
                F: Fold + ?Sized,
            {
                ::syntax::TypeReference {
                    and_token: node.and_token,
                    lifetime: (node.lifetime).map(|it| f.fold_lifetime(it)),
                    mutability: node.mutability,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_slice<F>(f: &mut F, node: ::syntax::TypeSlice) -> ::syntax::TypeSlice where
                F: Fold + ?Sized,
            {
                ::syntax::TypeSlice {
                    bracket_token: node.bracket_token,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_trait_object<F>(
                f: &mut F,
                node: ::syntax::TypeTraitObject,
            ) -> ::syntax::TypeTraitObject where
                F: Fold + ?Sized,
            {
                ::syntax::TypeTraitObject {
                    dyn_token: node.dyn_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                }
            }
            pub fn fold_type_tuple<F>(f: &mut F, node: ::syntax::TypeTuple) -> ::syntax::TypeTuple where
                F: Fold + ?Sized,
            {
                ::syntax::TypeTuple {
                    paren_token: node.paren_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_type),
                }
            }
            pub fn fold_un_op<F>(f: &mut F, node: ::syntax::UnOp) -> ::syntax::UnOp where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::UnOp::Deref(_binding_0) => ::syntax::UnOp::Deref(_binding_0),
                    ::syntax::UnOp::Not(_binding_0) => ::syntax::UnOp::Not(_binding_0),
                    ::syntax::UnOp::Neg(_binding_0) => ::syntax::UnOp::Neg(_binding_0),
                }
            }
            pub fn fold_use_glob<F>(f: &mut F, node: ::syntax::UseGlob) -> ::syntax::UseGlob where
                F: Fold + ?Sized,
            {
                ::syntax::UseGlob {
                    star_token: node.star_token,
                }
            }
            pub fn fold_use_group<F>(f: &mut F, node: ::syntax::UseGroup) -> ::syntax::UseGroup where
                F: Fold + ?Sized,
            {
                ::syntax::UseGroup {
                    brace_token: node.brace_token,
                    items: ::syntax::punctuated::fold(node.items, f, F::fold_use_tree),
                }
            }
            pub fn fold_use_name<F>(f: &mut F, node: ::syntax::UseName) -> ::syntax::UseName where
                F: Fold + ?Sized,
            {
                ::syntax::UseName {
                    ident: f.fold_ident(node.ident),
                }
            }
            pub fn fold_use_path<F>(f: &mut F, node: ::syntax::UsePath) -> ::syntax::UsePath where
                F: Fold + ?Sized,
            {
                ::syntax::UsePath {
                    ident: f.fold_ident(node.ident),
                    colon2_token: node.colon2_token,
                    tree: Box::new(f.fold_use_tree(*node.tree)),
                }
            }
            pub fn fold_use_rename<F>(f: &mut F, node: ::syntax::UseRename) -> ::syntax::UseRename where
                F: Fold + ?Sized,
            {
                ::syntax::UseRename {
                    ident: f.fold_ident(node.ident),
                    as_token: node.as_token,
                    rename: f.fold_ident(node.rename),
                }
            }
            pub fn fold_use_tree<F>(f: &mut F, node: ::syntax::UseTree) -> ::syntax::UseTree where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::UseTree::Path(_binding_0) => {
                        ::syntax::UseTree::Path(f.fold_use_path(_binding_0))
                    }
                    ::syntax::UseTree::Name(_binding_0) => {
                        ::syntax::UseTree::Name(f.fold_use_name(_binding_0))
                    }
                    ::syntax::UseTree::Rename(_binding_0) => {
                        ::syntax::UseTree::Rename(f.fold_use_rename(_binding_0))
                    }
                    ::syntax::UseTree::Glob(_binding_0) => {
                        ::syntax::UseTree::Glob(f.fold_use_glob(_binding_0))
                    }
                    ::syntax::UseTree::Group(_binding_0) => {
                        ::syntax::UseTree::Group(f.fold_use_group(_binding_0))
                    }
                }
            }
            pub fn fold_variadic<F>(f: &mut F, node: ::syntax::Variadic) -> ::syntax::Variadic where
                F: Fold + ?Sized,
            {
                ::syntax::Variadic {
                    attrs: f.fold_attributes(node.attrs),
                    pat: (node.pat).map(|it| (Box::new(f.fold_pat(*(it).0)), (it).1)),
                    dots: node.dots,
                    comma: node.comma,
                }
            }
            pub fn fold_variant<F>(f: &mut F, node: ::syntax::Variant) -> ::syntax::Variant where
                F: Fold + ?Sized,
            {
                ::syntax::Variant {
                    attrs: f.fold_attributes(node.attrs),
                    ident: f.fold_ident(node.ident),
                    fields: f.fold_fields(node.fields),
                    discriminant: (node.discriminant).map(|it| ((it).0, f.fold_expr((it).1))),
                }
            }
            pub fn fold_vis_restricted<F>(
                f: &mut F,
                node: ::syntax::VisRestricted,
            ) -> ::syntax::VisRestricted where
                F: Fold + ?Sized,
            {
                ::syntax::VisRestricted {
                    pub_token: node.pub_token,
                    paren_token: node.paren_token,
                    in_token: node.in_token,
                    path: Box::new(f.fold_path(*node.path)),
                }
            }
            pub fn fold_visibility<F>(f: &mut F, node: ::syntax::Visibility) -> ::syntax::Visibility where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Visibility::Public(_binding_0) => ::syntax::Visibility::Public(_binding_0),
                    ::syntax::Visibility::Restricted(_binding_0) => {
                        ::syntax::Visibility::Restricted(f.fold_vis_restricted(_binding_0))
                    }
                    ::syntax::Visibility::Inherited => ::syntax::Visibility::Inherited,
                }
            }
            pub fn fold_where_clause<F>(f: &mut F, node: ::syntax::WhereClause) -> ::syntax::WhereClause where
                F: Fold + ?Sized,
            {
                ::syntax::WhereClause {
                    where_token: node.where_token,
                    predicates: ::syntax::punctuated::fold(node.predicates, f, F::fold_where_predicate),
                }
            }
            pub fn fold_where_predicate<F>(
                f: &mut F,
                node: ::syntax::WherePredicate,
            ) -> ::syntax::WherePredicate where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::WherePredicate::Lifetime(_binding_0) => {
                        ::syntax::WherePredicate::Lifetime(f.fold_predicate_lifetime(_binding_0))
                    }
                    ::syntax::WherePredicate::Type(_binding_0) => {
                        ::syntax::WherePredicate::Type(f.fold_predicate_type(_binding_0))
                    }
                }
            }
            fn fold_vec<T, V, F>(vec: Vec<T>, fold: &mut V, mut f: F) -> Vec<T> where
                V: ?Sized,
                F: FnMut(&mut V, T) -> T,
            {
                vec.into_iter().map(|it| f(fold, it)).collect()
            }
        }
        /// Syntax tree traversal to walk a shared borrow of a syntax tree.
        pub mod visit
        {
            use ::
            {
                syntax::punctuated::Punctuated,
                *,
            };
            /*
            */
            macro_rules! full {
                ($e:expr) => {
                    $e
                };
            }
            
            macro_rules! skip {
                ($($tt:tt)*) => {};
            }
            /// Syntax tree traversal to walk a shared borrow of a syntax tree.
            pub trait Visit<'ast> {
                        fn visit_abi(&mut self, i: &'ast ::syntax::Abi) {
                    visit_abi(self, i);
                }
                        fn visit_angle_bracketed_generic_arguments(
                    &mut self,
                    i: &'ast ::syntax::AngleBracketedGenericArguments,
                ) {
                    visit_angle_bracketed_generic_arguments(self, i);
                }
                            fn visit_arm(&mut self, i: &'ast ::syntax::Arm) {
                    visit_arm(self, i);
                }
                        fn visit_assoc_const(&mut self, i: &'ast ::syntax::AssocConst) {
                    visit_assoc_const(self, i);
                }
                        fn visit_assoc_type(&mut self, i: &'ast ::syntax::AssocType) {
                    visit_assoc_type(self, i);
                }
                        fn visit_attr_style(&mut self, i: &'ast ::syntax::AttrStyle) {
                    visit_attr_style(self, i);
                }
                        fn visit_attribute(&mut self, i: &'ast ::syntax::Attribute) {
                    visit_attribute(self, i);
                }
                        fn visit_bare_fn_arg(&mut self, i: &'ast ::syntax::BareFnArg) {
                    visit_bare_fn_arg(self, i);
                }
                        fn visit_bare_variadic(&mut self, i: &'ast ::syntax::BareVariadic) {
                    visit_bare_variadic(self, i);
                }
                        fn visit_bin_op(&mut self, i: &'ast ::syntax::BinOp) {
                    visit_bin_op(self, i);
                }
                            fn visit_block(&mut self, i: &'ast ::syntax::Block) {
                    visit_block(self, i);
                }
                        fn visit_bound_lifetimes(&mut self, i: &'ast ::syntax::BoundLifetimes) {
                    visit_bound_lifetimes(self, i);
                }
                            fn visit_captured_param(&mut self, i: &'ast ::syntax::CapturedParam) {
                    visit_captured_param(self, i);
                }
                        fn visit_const_param(&mut self, i: &'ast ::syntax::ConstParam) {
                    visit_const_param(self, i);
                }
                        fn visit_constraint(&mut self, i: &'ast ::syntax::Constraint) {
                    visit_constraint(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data(&mut self, i: &'ast ::syntax::Data) {
                    visit_data(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_enum(&mut self, i: &'ast ::syntax::DataEnum) {
                    visit_data_enum(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_struct(&mut self, i: &'ast ::syntax::DataStruct) {
                    visit_data_struct(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_union(&mut self, i: &'ast ::syntax::DataUnion) {
                    visit_data_union(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_derive_input(&mut self, i: &'ast ::syntax::DeriveInput) {
                    visit_derive_input(self, i);
                }
                        fn visit_expr(&mut self, i: &'ast ::syntax::Expr) {
                    visit_expr(self, i);
                }
                            fn visit_expr_array(&mut self, i: &'ast ::syntax::ExprArray) {
                    visit_expr_array(self, i);
                }
                            fn visit_expr_assign(&mut self, i: &'ast ::syntax::ExprAssign) {
                    visit_expr_assign(self, i);
                }
                            fn visit_expr_async(&mut self, i: &'ast ::syntax::ExprAsync) {
                    visit_expr_async(self, i);
                }
                            fn visit_expr_await(&mut self, i: &'ast ::syntax::ExprAwait) {
                    visit_expr_await(self, i);
                }
                        fn visit_expr_binary(&mut self, i: &'ast ::syntax::ExprBinary) {
                    visit_expr_binary(self, i);
                }
                            fn visit_expr_block(&mut self, i: &'ast ::syntax::ExprBlock) {
                    visit_expr_block(self, i);
                }
                            fn visit_expr_break(&mut self, i: &'ast ::syntax::ExprBreak) {
                    visit_expr_break(self, i);
                }
                        fn visit_expr_call(&mut self, i: &'ast ::syntax::ExprCall) {
                    visit_expr_call(self, i);
                }
                        fn visit_expr_cast(&mut self, i: &'ast ::syntax::ExprCast) {
                    visit_expr_cast(self, i);
                }
                            fn visit_expr_closure(&mut self, i: &'ast ::syntax::ExprClosure) {
                    visit_expr_closure(self, i);
                }
                            fn visit_expr_const(&mut self, i: &'ast ::syntax::ExprConst) {
                    visit_expr_const(self, i);
                }
                            fn visit_expr_continue(&mut self, i: &'ast ::syntax::ExprContinue) {
                    visit_expr_continue(self, i);
                }
                        fn visit_expr_field(&mut self, i: &'ast ::syntax::ExprField) {
                    visit_expr_field(self, i);
                }
                            fn visit_expr_for_loop(&mut self, i: &'ast ::syntax::ExprForLoop) {
                    visit_expr_for_loop(self, i);
                }
                        fn visit_expr_group(&mut self, i: &'ast ::syntax::ExprGroup) {
                    visit_expr_group(self, i);
                }
                            fn visit_expr_if(&mut self, i: &'ast ::syntax::ExprIf) {
                    visit_expr_if(self, i);
                }
                        fn visit_expr_index(&mut self, i: &'ast ::syntax::ExprIndex) {
                    visit_expr_index(self, i);
                }
                            fn visit_expr_infer(&mut self, i: &'ast ::syntax::ExprInfer) {
                    visit_expr_infer(self, i);
                }
                            fn visit_expr_let(&mut self, i: &'ast ::syntax::ExprLet) {
                    visit_expr_let(self, i);
                }
                        fn visit_expr_lit(&mut self, i: &'ast ::syntax::ExprLit) {
                    visit_expr_lit(self, i);
                }
                            fn visit_expr_loop(&mut self, i: &'ast ::syntax::ExprLoop) {
                    visit_expr_loop(self, i);
                }
                        fn visit_expr_macro(&mut self, i: &'ast ::syntax::ExprMacro) {
                    visit_expr_macro(self, i);
                }
                            fn visit_expr_match(&mut self, i: &'ast ::syntax::ExprMatch) {
                    visit_expr_match(self, i);
                }
                        fn visit_expr_method_call(&mut self, i: &'ast ::syntax::ExprMethodCall) {
                    visit_expr_method_call(self, i);
                }
                        fn visit_expr_paren(&mut self, i: &'ast ::syntax::ExprParen) {
                    visit_expr_paren(self, i);
                }
                        fn visit_expr_path(&mut self, i: &'ast ::syntax::ExprPath) {
                    visit_expr_path(self, i);
                }
                            fn visit_expr_range(&mut self, i: &'ast ::syntax::ExprRange) {
                    visit_expr_range(self, i);
                }
                            fn visit_expr_raw_addr(&mut self, i: &'ast ::syntax::ExprRawAddr) {
                    visit_expr_raw_addr(self, i);
                }
                        fn visit_expr_reference(&mut self, i: &'ast ::syntax::ExprReference) {
                    visit_expr_reference(self, i);
                }
                            fn visit_expr_repeat(&mut self, i: &'ast ::syntax::ExprRepeat) {
                    visit_expr_repeat(self, i);
                }
                            fn visit_expr_return(&mut self, i: &'ast ::syntax::ExprReturn) {
                    visit_expr_return(self, i);
                }
                        fn visit_expr_struct(&mut self, i: &'ast ::syntax::ExprStruct) {
                    visit_expr_struct(self, i);
                }
                            fn visit_expr_try(&mut self, i: &'ast ::syntax::ExprTry) {
                    visit_expr_try(self, i);
                }
                            fn visit_expr_try_block(&mut self, i: &'ast ::syntax::ExprTryBlock) {
                    visit_expr_try_block(self, i);
                }
                        fn visit_expr_tuple(&mut self, i: &'ast ::syntax::ExprTuple) {
                    visit_expr_tuple(self, i);
                }
                        fn visit_expr_unary(&mut self, i: &'ast ::syntax::ExprUnary) {
                    visit_expr_unary(self, i);
                }
                            fn visit_expr_unsafe(&mut self, i: &'ast ::syntax::ExprUnsafe) {
                    visit_expr_unsafe(self, i);
                }
                            fn visit_expr_while(&mut self, i: &'ast ::syntax::ExprWhile) {
                    visit_expr_while(self, i);
                }
                            fn visit_expr_yield(&mut self, i: &'ast ::syntax::ExprYield) {
                    visit_expr_yield(self, i);
                }
                        fn visit_field(&mut self, i: &'ast ::syntax::Field) {
                    visit_field(self, i);
                }
                        fn visit_field_mutability(&mut self, i: &'ast ::syntax::FieldMutability) {
                    visit_field_mutability(self, i);
                }
                            fn visit_field_pat(&mut self, i: &'ast ::syntax::FieldPat) {
                    visit_field_pat(self, i);
                }
                        fn visit_field_value(&mut self, i: &'ast ::syntax::FieldValue) {
                    visit_field_value(self, i);
                }
                        fn visit_fields(&mut self, i: &'ast ::syntax::Fields) {
                    visit_fields(self, i);
                }
                        fn visit_fields_named(&mut self, i: &'ast ::syntax::FieldsNamed) {
                    visit_fields_named(self, i);
                }
                        fn visit_fields_unnamed(&mut self, i: &'ast ::syntax::FieldsUnnamed) {
                    visit_fields_unnamed(self, i);
                }
                            fn visit_file(&mut self, i: &'ast ::syntax::File) {
                    visit_file(self, i);
                }
                            fn visit_fn_arg(&mut self, i: &'ast ::syntax::FnArg) {
                    visit_fn_arg(self, i);
                }
                            fn visit_foreign_item(&mut self, i: &'ast ::syntax::ForeignItem) {
                    visit_foreign_item(self, i);
                }
                            fn visit_foreign_item_fn(&mut self, i: &'ast ::syntax::ForeignItemFn) {
                    visit_foreign_item_fn(self, i);
                }
                            fn visit_foreign_item_macro(&mut self, i: &'ast ::syntax::ForeignItemMacro) {
                    visit_foreign_item_macro(self, i);
                }
                            fn visit_foreign_item_static(&mut self, i: &'ast ::syntax::ForeignItemStatic) {
                    visit_foreign_item_static(self, i);
                }
                            fn visit_foreign_item_type(&mut self, i: &'ast ::syntax::ForeignItemType) {
                    visit_foreign_item_type(self, i);
                }
                        fn visit_generic_argument(&mut self, i: &'ast ::syntax::GenericArgument) {
                    visit_generic_argument(self, i);
                }
                        fn visit_generic_param(&mut self, i: &'ast ::syntax::GenericParam) {
                    visit_generic_param(self, i);
                }
                        fn visit_generics(&mut self, i: &'ast ::syntax::Generics) {
                    visit_generics(self, i);
                }
                fn visit_ident(&mut self, i: &'ast process::macros::Ident) {
                    visit_ident(self, i);
                }
                            fn visit_impl_item(&mut self, i: &'ast ::syntax::ImplItem) {
                    visit_impl_item(self, i);
                }
                            fn visit_impl_item_const(&mut self, i: &'ast ::syntax::ImplItemConst) {
                    visit_impl_item_const(self, i);
                }
                            fn visit_impl_item_fn(&mut self, i: &'ast ::syntax::ImplItemFn) {
                    visit_impl_item_fn(self, i);
                }
                            fn visit_impl_item_macro(&mut self, i: &'ast ::syntax::ImplItemMacro) {
                    visit_impl_item_macro(self, i);
                }
                            fn visit_impl_item_type(&mut self, i: &'ast ::syntax::ImplItemType) {
                    visit_impl_item_type(self, i);
                }
                            fn visit_impl_restriction(&mut self, i: &'ast ::syntax::ImplRestriction) {
                    visit_impl_restriction(self, i);
                }
                        fn visit_index(&mut self, i: &'ast ::syntax::Index) {
                    visit_index(self, i);
                }
                            fn visit_item(&mut self, i: &'ast ::syntax::Item) {
                    visit_item(self, i);
                }
                            fn visit_item_const(&mut self, i: &'ast ::syntax::ItemConst) {
                    visit_item_const(self, i);
                }
                            fn visit_item_enum(&mut self, i: &'ast ::syntax::ItemEnum) {
                    visit_item_enum(self, i);
                }
                            fn visit_item_extern_crate(&mut self, i: &'ast ::syntax::ItemExternCrate) {
                    visit_item_extern_crate(self, i);
                }
                            fn visit_item_fn(&mut self, i: &'ast ::syntax::ItemFn) {
                    visit_item_fn(self, i);
                }
                            fn visit_item_foreign_mod(&mut self, i: &'ast ::syntax::ItemForeignMod) {
                    visit_item_foreign_mod(self, i);
                }
                            fn visit_item_impl(&mut self, i: &'ast ::syntax::ItemImpl) {
                    visit_item_impl(self, i);
                }
                            fn visit_item_macro(&mut self, i: &'ast ::syntax::ItemMacro) {
                    visit_item_macro(self, i);
                }
                            fn visit_item_mod(&mut self, i: &'ast ::syntax::ItemMod) {
                    visit_item_mod(self, i);
                }
                            fn visit_item_static(&mut self, i: &'ast ::syntax::ItemStatic) {
                    visit_item_static(self, i);
                }
                            fn visit_item_struct(&mut self, i: &'ast ::syntax::ItemStruct) {
                    visit_item_struct(self, i);
                }
                            fn visit_item_trait(&mut self, i: &'ast ::syntax::ItemTrait) {
                    visit_item_trait(self, i);
                }
                            fn visit_item_trait_alias(&mut self, i: &'ast ::syntax::ItemTraitAlias) {
                    visit_item_trait_alias(self, i);
                }
                            fn visit_item_type(&mut self, i: &'ast ::syntax::ItemType) {
                    visit_item_type(self, i);
                }
                            fn visit_item_union(&mut self, i: &'ast ::syntax::ItemUnion) {
                    visit_item_union(self, i);
                }
                            fn visit_item_use(&mut self, i: &'ast ::syntax::ItemUse) {
                    visit_item_use(self, i);
                }
                            fn visit_label(&mut self, i: &'ast ::syntax::Label) {
                    visit_label(self, i);
                }
                fn visit_lifetime(&mut self, i: &'ast ::syntax::Lifetime) {
                    visit_lifetime(self, i);
                }
                        fn visit_lifetime_param(&mut self, i: &'ast ::syntax::LifetimeParam) {
                    visit_lifetime_param(self, i);
                }
                fn visit_lit(&mut self, i: &'ast ::syntax::Lit) {
                    visit_lit(self, i);
                }
                fn visit_lit_bool(&mut self, i: &'ast ::syntax::LitBool) {
                    visit_lit_bool(self, i);
                }
                fn visit_lit_byte(&mut self, i: &'ast ::syntax::LitByte) {
                    visit_lit_byte(self, i);
                }
                fn visit_lit_byte_str(&mut self, i: &'ast ::syntax::LitByteStr) {
                    visit_lit_byte_str(self, i);
                }
                fn visit_lit_cstr(&mut self, i: &'ast ::syntax::LitCStr) {
                    visit_lit_cstr(self, i);
                }
                fn visit_lit_char(&mut self, i: &'ast ::syntax::LitChar) {
                    visit_lit_char(self, i);
                }
                fn visit_lit_float(&mut self, i: &'ast ::syntax::LitFloat) {
                    visit_lit_float(self, i);
                }
                fn visit_lit_int(&mut self, i: &'ast ::syntax::LitInt) {
                    visit_lit_int(self, i);
                }
                fn visit_lit_str(&mut self, i: &'ast ::syntax::LitStr) {
                    visit_lit_str(self, i);
                }
                            fn visit_local(&mut self, i: &'ast ::syntax::Local) {
                    visit_local(self, i);
                }
                            fn visit_local_init(&mut self, i: &'ast ::syntax::LocalInit) {
                    visit_local_init(self, i);
                }
                        fn visit_macro(&mut self, i: &'ast ::syntax::Macro) {
                    visit_macro(self, i);
                }
                        fn visit_macro_delimiter(&mut self, i: &'ast ::syntax::MacroDelimiter) {
                    visit_macro_delimiter(self, i);
                }
                        fn visit_member(&mut self, i: &'ast ::syntax::Member) {
                    visit_member(self, i);
                }
                        fn visit_meta(&mut self, i: &'ast ::syntax::Meta) {
                    visit_meta(self, i);
                }
                        fn visit_meta_list(&mut self, i: &'ast ::syntax::MetaList) {
                    visit_meta_list(self, i);
                }
                        fn visit_meta_name_value(&mut self, i: &'ast ::syntax::MetaNameValue) {
                    visit_meta_name_value(self, i);
                }
                        fn visit_parenthesized_generic_arguments(
                    &mut self,
                    i: &'ast ::syntax::ParenthesizedGenericArguments,
                ) {
                    visit_parenthesized_generic_arguments(self, i);
                }
                            fn visit_pat(&mut self, i: &'ast ::syntax::Pat) {
                    visit_pat(self, i);
                }
                            fn visit_pat_ident(&mut self, i: &'ast ::syntax::PatIdent) {
                    visit_pat_ident(self, i);
                }
                            fn visit_pat_or(&mut self, i: &'ast ::syntax::PatOr) {
                    visit_pat_or(self, i);
                }
                            fn visit_pat_paren(&mut self, i: &'ast ::syntax::PatParen) {
                    visit_pat_paren(self, i);
                }
                            fn visit_pat_reference(&mut self, i: &'ast ::syntax::PatReference) {
                    visit_pat_reference(self, i);
                }
                            fn visit_pat_rest(&mut self, i: &'ast ::syntax::PatRest) {
                    visit_pat_rest(self, i);
                }
                            fn visit_pat_slice(&mut self, i: &'ast ::syntax::PatSlice) {
                    visit_pat_slice(self, i);
                }
                            fn visit_pat_struct(&mut self, i: &'ast ::syntax::PatStruct) {
                    visit_pat_struct(self, i);
                }
                            fn visit_pat_tuple(&mut self, i: &'ast ::syntax::PatTuple) {
                    visit_pat_tuple(self, i);
                }
                            fn visit_pat_tuple_struct(&mut self, i: &'ast ::syntax::PatTupleStruct) {
                    visit_pat_tuple_struct(self, i);
                }
                            fn visit_pat_type(&mut self, i: &'ast ::syntax::PatType) {
                    visit_pat_type(self, i);
                }
                            fn visit_pat_wild(&mut self, i: &'ast ::syntax::PatWild) {
                    visit_pat_wild(self, i);
                }
                        fn visit_path(&mut self, i: &'ast ::syntax::Path) {
                    visit_path(self, i);
                }
                        fn visit_path_arguments(&mut self, i: &'ast ::syntax::PathArguments) {
                    visit_path_arguments(self, i);
                }
                        fn visit_path_segment(&mut self, i: &'ast ::syntax::PathSegment) {
                    visit_path_segment(self, i);
                }
                            fn visit_pointer_mutability(&mut self, i: &'ast ::syntax::PointerMutability) {
                    visit_pointer_mutability(self, i);
                }
                            fn visit_precise_capture(&mut self, i: &'ast ::syntax::PreciseCapture) {
                    visit_precise_capture(self, i);
                }
                        fn visit_predicate_lifetime(&mut self, i: &'ast ::syntax::PredicateLifetime) {
                    visit_predicate_lifetime(self, i);
                }
                        fn visit_predicate_type(&mut self, i: &'ast ::syntax::PredicateType) {
                    visit_predicate_type(self, i);
                }
                        fn visit_qself(&mut self, i: &'ast ::syntax::QSelf) {
                    visit_qself(self, i);
                }
                            fn visit_range_limits(&mut self, i: &'ast ::syntax::RangeLimits) {
                    visit_range_limits(self, i);
                }
                            fn visit_receiver(&mut self, i: &'ast ::syntax::Receiver) {
                    visit_receiver(self, i);
                }
                        fn visit_return_type(&mut self, i: &'ast ::syntax::ReturnType) {
                    visit_return_type(self, i);
                }
                            fn visit_signature(&mut self, i: &'ast ::syntax::Signature) {
                    visit_signature(self, i);
                }
                fn visit_span(&mut self, i: &process::macros::Span) {}
                            fn visit_static_mutability(&mut self, i: &'ast ::syntax::StaticMutability) {
                    visit_static_mutability(self, i);
                }
                            fn visit_stmt(&mut self, i: &'ast ::syntax::Stmt) {
                    visit_stmt(self, i);
                }
                            fn visit_stmt_macro(&mut self, i: &'ast ::syntax::StmtMacro) {
                    visit_stmt_macro(self, i);
                }
                fn visit_token_stream(&mut self, i: &'ast process::macros::TokenStream) {}
                        fn visit_trait_bound(&mut self, i: &'ast ::syntax::TraitBound) {
                    visit_trait_bound(self, i);
                }
                        fn visit_trait_bound_modifier(&mut self, i: &'ast ::syntax::TraitBoundModifier) {
                    visit_trait_bound_modifier(self, i);
                }
                            fn visit_trait_item(&mut self, i: &'ast ::syntax::TraitItem) {
                    visit_trait_item(self, i);
                }
                            fn visit_trait_item_const(&mut self, i: &'ast ::syntax::TraitItemConst) {
                    visit_trait_item_const(self, i);
                }
                            fn visit_trait_item_fn(&mut self, i: &'ast ::syntax::TraitItemFn) {
                    visit_trait_item_fn(self, i);
                }
                            fn visit_trait_item_macro(&mut self, i: &'ast ::syntax::TraitItemMacro) {
                    visit_trait_item_macro(self, i);
                }
                            fn visit_trait_item_type(&mut self, i: &'ast ::syntax::TraitItemType) {
                    visit_trait_item_type(self, i);
                }
                        fn visit_type(&mut self, i: &'ast ::syntax::Type) {
                    visit_type(self, i);
                }
                        fn visit_type_array(&mut self, i: &'ast ::syntax::TypeArray) {
                    visit_type_array(self, i);
                }
                        fn visit_type_bare_fn(&mut self, i: &'ast ::syntax::TypeBareFn) {
                    visit_type_bare_fn(self, i);
                }
                        fn visit_type_group(&mut self, i: &'ast ::syntax::TypeGroup) {
                    visit_type_group(self, i);
                }
                        fn visit_type_impl_trait(&mut self, i: &'ast ::syntax::TypeImplTrait) {
                    visit_type_impl_trait(self, i);
                }
                        fn visit_type_infer(&mut self, i: &'ast ::syntax::TypeInfer) {
                    visit_type_infer(self, i);
                }
                        fn visit_type_macro(&mut self, i: &'ast ::syntax::TypeMacro) {
                    visit_type_macro(self, i);
                }
                        fn visit_type_never(&mut self, i: &'ast ::syntax::TypeNever) {
                    visit_type_never(self, i);
                }
                        fn visit_type_param(&mut self, i: &'ast ::syntax::TypeParam) {
                    visit_type_param(self, i);
                }
                        fn visit_type_param_bound(&mut self, i: &'ast ::syntax::TypeParamBound) {
                    visit_type_param_bound(self, i);
                }
                        fn visit_type_paren(&mut self, i: &'ast ::syntax::TypeParen) {
                    visit_type_paren(self, i);
                }
                        fn visit_type_path(&mut self, i: &'ast ::syntax::TypePath) {
                    visit_type_path(self, i);
                }
                        fn visit_type_ptr(&mut self, i: &'ast ::syntax::TypePtr) {
                    visit_type_ptr(self, i);
                }
                        fn visit_type_reference(&mut self, i: &'ast ::syntax::TypeReference) {
                    visit_type_reference(self, i);
                }
                        fn visit_type_slice(&mut self, i: &'ast ::syntax::TypeSlice) {
                    visit_type_slice(self, i);
                }
                        fn visit_type_trait_object(&mut self, i: &'ast ::syntax::TypeTraitObject) {
                    visit_type_trait_object(self, i);
                }
                        fn visit_type_tuple(&mut self, i: &'ast ::syntax::TypeTuple) {
                    visit_type_tuple(self, i);
                }
                        fn visit_un_op(&mut self, i: &'ast ::syntax::UnOp) {
                    visit_un_op(self, i);
                }
                            fn visit_use_glob(&mut self, i: &'ast ::syntax::UseGlob) {
                    visit_use_glob(self, i);
                }
                            fn visit_use_group(&mut self, i: &'ast ::syntax::UseGroup) {
                    visit_use_group(self, i);
                }
                            fn visit_use_name(&mut self, i: &'ast ::syntax::UseName) {
                    visit_use_name(self, i);
                }
                            fn visit_use_path(&mut self, i: &'ast ::syntax::UsePath) {
                    visit_use_path(self, i);
                }
                            fn visit_use_rename(&mut self, i: &'ast ::syntax::UseRename) {
                    visit_use_rename(self, i);
                }
                            fn visit_use_tree(&mut self, i: &'ast ::syntax::UseTree) {
                    visit_use_tree(self, i);
                }
                            fn visit_variadic(&mut self, i: &'ast ::syntax::Variadic) {
                    visit_variadic(self, i);
                }
                        fn visit_variant(&mut self, i: &'ast ::syntax::Variant) {
                    visit_variant(self, i);
                }
                        fn visit_vis_restricted(&mut self, i: &'ast ::syntax::VisRestricted) {
                    visit_vis_restricted(self, i);
                }
                        fn visit_visibility(&mut self, i: &'ast ::syntax::Visibility) {
                    visit_visibility(self, i);
                }
                        fn visit_where_clause(&mut self, i: &'ast ::syntax::WhereClause) {
                    visit_where_clause(self, i);
                }
                        fn visit_where_predicate(&mut self, i: &'ast ::syntax::WherePredicate) {
                    visit_where_predicate(self, i);
                }
            }
            pub fn visit_abi<'ast, V>(v: &mut V, node: &'ast ::syntax::Abi) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.extern_token);
                if let Some(it) = &node.name {
                    v.visit_lit_str(it);
                }
            }
            pub fn visit_angle_bracketed_generic_arguments<'ast, V>(
                v: &mut V,
                node: &'ast ::syntax::AngleBracketedGenericArguments,
            ) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.colon2_token);
                skip!(node.lt_token);
                for el in Punctuated::pairs(&node.args) {
                    let it = el.value();
                    v.visit_generic_argument(it);
                }
                skip!(node.gt_token);
            }
                pub fn visit_arm<'ast, V>(v: &mut V, node: &'ast ::syntax::Arm) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_pat(&node.pat);
                if let Some(it) = &node.guard {
                    skip!((it).0);
                    v.visit_expr(&*(it).1);
                }
                skip!(node.fat_arrow_token);
                v.visit_expr(&*node.body);
                skip!(node.comma);
            }
            pub fn visit_assoc_const<'ast, V>(v: &mut V, node: &'ast ::syntax::AssocConst) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                if let Some(it) = &node.generics {
                    v.visit_angle_bracketed_generic_arguments(it);
                }
                skip!(node.eq_token);
                v.visit_expr(&node.value);
            }
            pub fn visit_assoc_type<'ast, V>(v: &mut V, node: &'ast ::syntax::AssocType) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                if let Some(it) = &node.generics {
                    v.visit_angle_bracketed_generic_arguments(it);
                }
                skip!(node.eq_token);
                v.visit_type(&node.ty);
            }
            pub fn visit_attr_style<'ast, V>(v: &mut V, node: &'ast ::syntax::AttrStyle) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::AttrStyle::Outer => {}
                    ::syntax::AttrStyle::Inner(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_attribute<'ast, V>(v: &mut V, node: &'ast ::syntax::Attribute) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.pound_token);
                v.visit_attr_style(&node.style);
                skip!(node.bracket_token);
                v.visit_meta(&node.meta);
            }
            pub fn visit_bare_fn_arg<'ast, V>(v: &mut V, node: &'ast ::syntax::BareFnArg) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.name {
                    v.visit_ident(&(it).0);
                    skip!((it).1);
                }
                v.visit_type(&node.ty);
            }
            pub fn visit_bare_variadic<'ast, V>(v: &mut V, node: &'ast ::syntax::BareVariadic) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.name {
                    v.visit_ident(&(it).0);
                    skip!((it).1);
                }
                skip!(node.dots);
                skip!(node.comma);
            }
            pub fn visit_bin_op<'ast, V>(v: &mut V, node: &'ast ::syntax::BinOp) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::BinOp::Add(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Sub(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Mul(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Div(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Rem(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::And(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Or(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitXor(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitAnd(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitOr(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Shl(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Shr(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Eq(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Lt(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Le(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Ne(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Ge(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Gt(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::AddAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::SubAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::MulAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::DivAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::RemAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitXorAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitAndAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitOrAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::ShlAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::ShrAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_block<'ast, V>(v: &mut V, node: &'ast ::syntax::Block) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.brace_token);
                for it in &node.stmts {
                    v.visit_stmt(it);
                }
            }
            pub fn visit_bound_lifetimes<'ast, V>(v: &mut V, node: &'ast ::syntax::BoundLifetimes) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.for_token);
                skip!(node.lt_token);
                for el in Punctuated::pairs(&node.lifetimes) {
                    let it = el.value();
                    v.visit_generic_param(it);
                }
                skip!(node.gt_token);
            }
                pub fn visit_captured_param<'ast, V>(v: &mut V, node: &'ast ::syntax::CapturedParam) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::CapturedParam::Lifetime(_binding_0) => {
                        v.visit_lifetime(_binding_0);
                    }
                    ::syntax::CapturedParam::Ident(_binding_0) => {
                        v.visit_ident(_binding_0);
                    }
                }
            }
            pub fn visit_const_param<'ast, V>(v: &mut V, node: &'ast ::syntax::ConstParam) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.const_token);
                v.visit_ident(&node.ident);
                skip!(node.colon_token);
                v.visit_type(&node.ty);
                skip!(node.eq_token);
                if let Some(it) = &node.default {
                    v.visit_expr(it);
                }
            }
            pub fn visit_constraint<'ast, V>(v: &mut V, node: &'ast ::syntax::Constraint) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                if let Some(it) = &node.generics {
                    v.visit_angle_bracketed_generic_arguments(it);
                }
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
            }
            pub fn visit_data<'ast, V>(v: &mut V, node: &'ast ::syntax::Data) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Data::Struct(_binding_0) => {
                        v.visit_data_struct(_binding_0);
                    }
                    ::syntax::Data::Enum(_binding_0) => {
                        v.visit_data_enum(_binding_0);
                    }
                    ::syntax::Data::Union(_binding_0) => {
                        v.visit_data_union(_binding_0);
                    }
                }
            }
            pub fn visit_data_enum<'ast, V>(v: &mut V, node: &'ast ::syntax::DataEnum) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.enum_token);
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.variants) {
                    let it = el.value();
                    v.visit_variant(it);
                }
            }
            pub fn visit_data_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::DataStruct) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.struct_token);
                v.visit_fields(&node.fields);
                skip!(node.semi_token);
            }
            pub fn visit_data_union<'ast, V>(v: &mut V, node: &'ast ::syntax::DataUnion) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.union_token);
                v.visit_fields_named(&node.fields);
            }
            pub fn visit_derive_input<'ast, V>(v: &mut V, node: &'ast ::syntax::DeriveInput) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                v.visit_data(&node.data);
            }
            pub fn visit_expr<'ast, V>(v: &mut V, node: &'ast ::syntax::Expr) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Expr::Array(_binding_0) => {
                        full!(v.visit_expr_array(_binding_0));
                    }
                    ::syntax::Expr::Assign(_binding_0) => {
                        full!(v.visit_expr_assign(_binding_0));
                    }
                    ::syntax::Expr::Async(_binding_0) => {
                        full!(v.visit_expr_async(_binding_0));
                    }
                    ::syntax::Expr::Await(_binding_0) => {
                        full!(v.visit_expr_await(_binding_0));
                    }
                    ::syntax::Expr::Binary(_binding_0) => {
                        v.visit_expr_binary(_binding_0);
                    }
                    ::syntax::Expr::Block(_binding_0) => {
                        full!(v.visit_expr_block(_binding_0));
                    }
                    ::syntax::Expr::Break(_binding_0) => {
                        full!(v.visit_expr_break(_binding_0));
                    }
                    ::syntax::Expr::Call(_binding_0) => {
                        v.visit_expr_call(_binding_0);
                    }
                    ::syntax::Expr::Cast(_binding_0) => {
                        v.visit_expr_cast(_binding_0);
                    }
                    ::syntax::Expr::Closure(_binding_0) => {
                        full!(v.visit_expr_closure(_binding_0));
                    }
                    ::syntax::Expr::Const(_binding_0) => {
                        full!(v.visit_expr_const(_binding_0));
                    }
                    ::syntax::Expr::Continue(_binding_0) => {
                        full!(v.visit_expr_continue(_binding_0));
                    }
                    ::syntax::Expr::Field(_binding_0) => {
                        v.visit_expr_field(_binding_0);
                    }
                    ::syntax::Expr::ForLoop(_binding_0) => {
                        full!(v.visit_expr_for_loop(_binding_0));
                    }
                    ::syntax::Expr::Group(_binding_0) => {
                        v.visit_expr_group(_binding_0);
                    }
                    ::syntax::Expr::If(_binding_0) => {
                        full!(v.visit_expr_if(_binding_0));
                    }
                    ::syntax::Expr::Index(_binding_0) => {
                        v.visit_expr_index(_binding_0);
                    }
                    ::syntax::Expr::Infer(_binding_0) => {
                        full!(v.visit_expr_infer(_binding_0));
                    }
                    ::syntax::Expr::Let(_binding_0) => {
                        full!(v.visit_expr_let(_binding_0));
                    }
                    ::syntax::Expr::Lit(_binding_0) => {
                        v.visit_expr_lit(_binding_0);
                    }
                    ::syntax::Expr::Loop(_binding_0) => {
                        full!(v.visit_expr_loop(_binding_0));
                    }
                    ::syntax::Expr::Macro(_binding_0) => {
                        v.visit_expr_macro(_binding_0);
                    }
                    ::syntax::Expr::Match(_binding_0) => {
                        full!(v.visit_expr_match(_binding_0));
                    }
                    ::syntax::Expr::MethodCall(_binding_0) => {
                        v.visit_expr_method_call(_binding_0);
                    }
                    ::syntax::Expr::Paren(_binding_0) => {
                        v.visit_expr_paren(_binding_0);
                    }
                    ::syntax::Expr::Path(_binding_0) => {
                        v.visit_expr_path(_binding_0);
                    }
                    ::syntax::Expr::Range(_binding_0) => {
                        full!(v.visit_expr_range(_binding_0));
                    }
                    ::syntax::Expr::RawAddr(_binding_0) => {
                        full!(v.visit_expr_raw_addr(_binding_0));
                    }
                    ::syntax::Expr::Reference(_binding_0) => {
                        v.visit_expr_reference(_binding_0);
                    }
                    ::syntax::Expr::Repeat(_binding_0) => {
                        full!(v.visit_expr_repeat(_binding_0));
                    }
                    ::syntax::Expr::Return(_binding_0) => {
                        full!(v.visit_expr_return(_binding_0));
                    }
                    ::syntax::Expr::Struct(_binding_0) => {
                        v.visit_expr_struct(_binding_0);
                    }
                    ::syntax::Expr::Try(_binding_0) => {
                        full!(v.visit_expr_try(_binding_0));
                    }
                    ::syntax::Expr::TryBlock(_binding_0) => {
                        full!(v.visit_expr_try_block(_binding_0));
                    }
                    ::syntax::Expr::Tuple(_binding_0) => {
                        v.visit_expr_tuple(_binding_0);
                    }
                    ::syntax::Expr::Unary(_binding_0) => {
                        v.visit_expr_unary(_binding_0);
                    }
                    ::syntax::Expr::Unsafe(_binding_0) => {
                        full!(v.visit_expr_unsafe(_binding_0));
                    }
                    ::syntax::Expr::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                    ::syntax::Expr::While(_binding_0) => {
                        full!(v.visit_expr_while(_binding_0));
                    }
                    ::syntax::Expr::Yield(_binding_0) => {
                        full!(v.visit_expr_yield(_binding_0));
                    }
                }
            }
                pub fn visit_expr_array<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprArray) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.bracket_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_expr(it);
                }
            }
                pub fn visit_expr_assign<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprAssign) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.left);
                skip!(node.eq_token);
                v.visit_expr(&*node.right);
            }
                pub fn visit_expr_async<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprAsync) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.async_token);
                skip!(node.capture);
                v.visit_block(&node.block);
            }
                pub fn visit_expr_await<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprAwait) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.base);
                skip!(node.dot_token);
                skip!(node.await_token);
            }
            pub fn visit_expr_binary<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprBinary) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.left);
                v.visit_bin_op(&node.op);
                v.visit_expr(&*node.right);
            }
                pub fn visit_expr_block<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprBlock) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.label {
                    v.visit_label(it);
                }
                v.visit_block(&node.block);
            }
                pub fn visit_expr_break<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprBreak) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.break_token);
                if let Some(it) = &node.label {
                    v.visit_lifetime(it);
                }
                if let Some(it) = &node.expr {
                    v.visit_expr(&**it);
                }
            }
            pub fn visit_expr_call<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprCall) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.func);
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.args) {
                    let it = el.value();
                    v.visit_expr(it);
                }
            }
            pub fn visit_expr_cast<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprCast) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.expr);
                skip!(node.as_token);
                v.visit_type(&*node.ty);
            }
                pub fn visit_expr_closure<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprClosure) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.lifetimes {
                    v.visit_bound_lifetimes(it);
                }
                skip!(node.constness);
                skip!(node.movability);
                skip!(node.asyncness);
                skip!(node.capture);
                skip!(node.or1_token);
                for el in Punctuated::pairs(&node.inputs) {
                    let it = el.value();
                    v.visit_pat(it);
                }
                skip!(node.or2_token);
                v.visit_return_type(&node.output);
                v.visit_expr(&*node.body);
            }
                pub fn visit_expr_const<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprConst) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.const_token);
                v.visit_block(&node.block);
            }
                pub fn visit_expr_continue<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprContinue) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.continue_token);
                if let Some(it) = &node.label {
                    v.visit_lifetime(it);
                }
            }
            pub fn visit_expr_field<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprField) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.base);
                skip!(node.dot_token);
                v.visit_member(&node.member);
            }
                pub fn visit_expr_for_loop<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprForLoop) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.label {
                    v.visit_label(it);
                }
                skip!(node.for_token);
                v.visit_pat(&*node.pat);
                skip!(node.in_token);
                v.visit_expr(&*node.expr);
                v.visit_block(&node.body);
            }
            pub fn visit_expr_group<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprGroup) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.group_token);
                v.visit_expr(&*node.expr);
            }
                pub fn visit_expr_if<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprIf) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.if_token);
                v.visit_expr(&*node.cond);
                v.visit_block(&node.then_branch);
                if let Some(it) = &node.else_branch {
                    skip!((it).0);
                    v.visit_expr(&*(it).1);
                }
            }
            pub fn visit_expr_index<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprIndex) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.expr);
                skip!(node.bracket_token);
                v.visit_expr(&*node.index);
            }
                pub fn visit_expr_infer<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprInfer) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.underscore_token);
            }
                pub fn visit_expr_let<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprLet) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.let_token);
                v.visit_pat(&*node.pat);
                skip!(node.eq_token);
                v.visit_expr(&*node.expr);
            }
            pub fn visit_expr_lit<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprLit) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_lit(&node.lit);
            }
                pub fn visit_expr_loop<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprLoop) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.label {
                    v.visit_label(it);
                }
                skip!(node.loop_token);
                v.visit_block(&node.body);
            }
            pub fn visit_expr_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
            }
                pub fn visit_expr_match<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprMatch) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.match_token);
                v.visit_expr(&*node.expr);
                skip!(node.brace_token);
                for it in &node.arms {
                    v.visit_arm(it);
                }
            }
            pub fn visit_expr_method_call<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprMethodCall) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.receiver);
                skip!(node.dot_token);
                v.visit_ident(&node.method);
                if let Some(it) = &node.turbofish {
                    v.visit_angle_bracketed_generic_arguments(it);
                }
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.args) {
                    let it = el.value();
                    v.visit_expr(it);
                }
            }
            pub fn visit_expr_paren<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprParen) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.paren_token);
                v.visit_expr(&*node.expr);
            }
            pub fn visit_expr_path<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprPath) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
            }
                pub fn visit_expr_range<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprRange) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.start {
                    v.visit_expr(&**it);
                }
                v.visit_range_limits(&node.limits);
                if let Some(it) = &node.end {
                    v.visit_expr(&**it);
                }
            }
                pub fn visit_expr_raw_addr<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprRawAddr) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.and_token);
                skip!(node.raw);
                v.visit_pointer_mutability(&node.mutability);
                v.visit_expr(&*node.expr);
            }
            pub fn visit_expr_reference<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprReference) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.and_token);
                skip!(node.mutability);
                v.visit_expr(&*node.expr);
            }
                pub fn visit_expr_repeat<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprRepeat) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.bracket_token);
                v.visit_expr(&*node.expr);
                skip!(node.semi_token);
                v.visit_expr(&*node.len);
            }
                pub fn visit_expr_return<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprReturn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.return_token);
                if let Some(it) = &node.expr {
                    v.visit_expr(&**it);
                }
            }
            pub fn visit_expr_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprStruct) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.fields) {
                    let it = el.value();
                    v.visit_field_value(it);
                }
                skip!(node.dot2_token);
                if let Some(it) = &node.rest {
                    v.visit_expr(&**it);
                }
            }
                pub fn visit_expr_try<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprTry) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.expr);
                skip!(node.question_token);
            }
                pub fn visit_expr_try_block<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprTryBlock) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.try_token);
                v.visit_block(&node.block);
            }
            pub fn visit_expr_tuple<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprTuple) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_expr(it);
                }
            }
            pub fn visit_expr_unary<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprUnary) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_un_op(&node.op);
                v.visit_expr(&*node.expr);
            }
                pub fn visit_expr_unsafe<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprUnsafe) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.unsafe_token);
                v.visit_block(&node.block);
            }
                pub fn visit_expr_while<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprWhile) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.label {
                    v.visit_label(it);
                }
                skip!(node.while_token);
                v.visit_expr(&*node.cond);
                v.visit_block(&node.body);
            }
                pub fn visit_expr_yield<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprYield) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.yield_token);
                if let Some(it) = &node.expr {
                    v.visit_expr(&**it);
                }
            }
            pub fn visit_field<'ast, V>(v: &mut V, node: &'ast ::syntax::Field) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                v.visit_field_mutability(&node.mutability);
                if let Some(it) = &node.ident {
                    v.visit_ident(it);
                }
                skip!(node.colon_token);
                v.visit_type(&node.ty);
            }
            pub fn visit_field_mutability<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldMutability) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::FieldMutability::None => {}
                }
            }
                pub fn visit_field_pat<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldPat) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_member(&node.member);
                skip!(node.colon_token);
                v.visit_pat(&*node.pat);
            }
            pub fn visit_field_value<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldValue) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_member(&node.member);
                skip!(node.colon_token);
                v.visit_expr(&node.expr);
            }
            pub fn visit_fields<'ast, V>(v: &mut V, node: &'ast ::syntax::Fields) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Fields::Named(_binding_0) => {
                        v.visit_fields_named(_binding_0);
                    }
                    ::syntax::Fields::Unnamed(_binding_0) => {
                        v.visit_fields_unnamed(_binding_0);
                    }
                    ::syntax::Fields::Unit => {}
                }
            }
            pub fn visit_fields_named<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldsNamed) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.named) {
                    let it = el.value();
                    v.visit_field(it);
                }
            }
            pub fn visit_fields_unnamed<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldsUnnamed) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.unnamed) {
                    let it = el.value();
                    v.visit_field(it);
                }
            }
                pub fn visit_file<'ast, V>(v: &mut V, node: &'ast ::syntax::File) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.shebang);
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                for it in &node.items {
                    v.visit_item(it);
                }
            }
                pub fn visit_fn_arg<'ast, V>(v: &mut V, node: &'ast ::syntax::FnArg) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::FnArg::Receiver(_binding_0) => {
                        v.visit_receiver(_binding_0);
                    }
                    ::syntax::FnArg::Typed(_binding_0) => {
                        v.visit_pat_type(_binding_0);
                    }
                }
            }
                pub fn visit_foreign_item<'ast, V>(v: &mut V, node: &'ast ::syntax::ForeignItem) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::ForeignItem::Fn(_binding_0) => {
                        v.visit_foreign_item_fn(_binding_0);
                    }
                    ::syntax::ForeignItem::Static(_binding_0) => {
                        v.visit_foreign_item_static(_binding_0);
                    }
                    ::syntax::ForeignItem::Type(_binding_0) => {
                        v.visit_foreign_item_type(_binding_0);
                    }
                    ::syntax::ForeignItem::Macro(_binding_0) => {
                        v.visit_foreign_item_macro(_binding_0);
                    }
                    ::syntax::ForeignItem::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
                pub fn visit_foreign_item_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::ForeignItemFn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                v.visit_signature(&node.sig);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::ForeignItemMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_static<'ast, V>(
                v: &mut V,
                node: &'ast ::syntax::ForeignItemStatic,
            ) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.static_token);
                v.visit_static_mutability(&node.mutability);
                v.visit_ident(&node.ident);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_type<'ast, V>(v: &mut V, node: &'ast ::syntax::ForeignItemType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.type_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.semi_token);
            }
            pub fn visit_generic_argument<'ast, V>(v: &mut V, node: &'ast ::syntax::GenericArgument) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::GenericArgument::Lifetime(_binding_0) => {
                        v.visit_lifetime(_binding_0);
                    }
                    ::syntax::GenericArgument::Type(_binding_0) => {
                        v.visit_type(_binding_0);
                    }
                    ::syntax::GenericArgument::Const(_binding_0) => {
                        v.visit_expr(_binding_0);
                    }
                    ::syntax::GenericArgument::AssocType(_binding_0) => {
                        v.visit_assoc_type(_binding_0);
                    }
                    ::syntax::GenericArgument::AssocConst(_binding_0) => {
                        v.visit_assoc_const(_binding_0);
                    }
                    ::syntax::GenericArgument::Constraint(_binding_0) => {
                        v.visit_constraint(_binding_0);
                    }
                }
            }
            pub fn visit_generic_param<'ast, V>(v: &mut V, node: &'ast ::syntax::GenericParam) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::GenericParam::Lifetime(_binding_0) => {
                        v.visit_lifetime_param(_binding_0);
                    }
                    ::syntax::GenericParam::Type(_binding_0) => {
                        v.visit_type_param(_binding_0);
                    }
                    ::syntax::GenericParam::Const(_binding_0) => {
                        v.visit_const_param(_binding_0);
                    }
                }
            }
            pub fn visit_generics<'ast, V>(v: &mut V, node: &'ast ::syntax::Generics) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.lt_token);
                for el in Punctuated::pairs(&node.params) {
                    let it = el.value();
                    v.visit_generic_param(it);
                }
                skip!(node.gt_token);
                if let Some(it) = &node.where_clause {
                    v.visit_where_clause(it);
                }
            }
            pub fn visit_ident<'ast, V>(v: &mut V, node: &'ast process::macros::Ident) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_span(&node.span());
            }
                pub fn visit_impl_item<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItem) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::ImplItem::Const(_binding_0) => {
                        v.visit_impl_item_const(_binding_0);
                    }
                    ::syntax::ImplItem::Fn(_binding_0) => {
                        v.visit_impl_item_fn(_binding_0);
                    }
                    ::syntax::ImplItem::Type(_binding_0) => {
                        v.visit_impl_item_type(_binding_0);
                    }
                    ::syntax::ImplItem::Macro(_binding_0) => {
                        v.visit_impl_item_macro(_binding_0);
                    }
                    ::syntax::ImplItem::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
                pub fn visit_impl_item_const<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItemConst) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.defaultness);
                skip!(node.const_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                v.visit_type(&node.ty);
                skip!(node.eq_token);
                v.visit_expr(&node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_impl_item_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItemFn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.defaultness);
                v.visit_signature(&node.sig);
                v.visit_block(&node.block);
            }
                pub fn visit_impl_item_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItemMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_impl_item_type<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItemType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.defaultness);
                skip!(node.type_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.eq_token);
                v.visit_type(&node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_impl_restriction<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplRestriction) where
                V: Visit<'ast> + ?Sized,
            {
                match *node {}
            }
            pub fn visit_index<'ast, V>(v: &mut V, node: &'ast ::syntax::Index) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.index);
                v.visit_span(&node.span);
            }
                pub fn visit_item<'ast, V>(v: &mut V, node: &'ast ::syntax::Item) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Item::Const(_binding_0) => {
                        v.visit_item_const(_binding_0);
                    }
                    ::syntax::Item::Enum(_binding_0) => {
                        v.visit_item_enum(_binding_0);
                    }
                    ::syntax::Item::ExternCrate(_binding_0) => {
                        v.visit_item_extern_crate(_binding_0);
                    }
                    ::syntax::Item::Fn(_binding_0) => {
                        v.visit_item_fn(_binding_0);
                    }
                    ::syntax::Item::ForeignMod(_binding_0) => {
                        v.visit_item_foreign_mod(_binding_0);
                    }
                    ::syntax::Item::Impl(_binding_0) => {
                        v.visit_item_impl(_binding_0);
                    }
                    ::syntax::Item::Macro(_binding_0) => {
                        v.visit_item_macro(_binding_0);
                    }
                    ::syntax::Item::Mod(_binding_0) => {
                        v.visit_item_mod(_binding_0);
                    }
                    ::syntax::Item::Static(_binding_0) => {
                        v.visit_item_static(_binding_0);
                    }
                    ::syntax::Item::Struct(_binding_0) => {
                        v.visit_item_struct(_binding_0);
                    }
                    ::syntax::Item::Trait(_binding_0) => {
                        v.visit_item_trait(_binding_0);
                    }
                    ::syntax::Item::TraitAlias(_binding_0) => {
                        v.visit_item_trait_alias(_binding_0);
                    }
                    ::syntax::Item::Type(_binding_0) => {
                        v.visit_item_type(_binding_0);
                    }
                    ::syntax::Item::Union(_binding_0) => {
                        v.visit_item_union(_binding_0);
                    }
                    ::syntax::Item::Use(_binding_0) => {
                        v.visit_item_use(_binding_0);
                    }
                    ::syntax::Item::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
                pub fn visit_item_const<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemConst) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.const_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
                skip!(node.eq_token);
                v.visit_expr(&*node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_item_enum<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemEnum) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.enum_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.variants) {
                    let it = el.value();
                    v.visit_variant(it);
                }
            }
                pub fn visit_item_extern_crate<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemExternCrate) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.extern_token);
                skip!(node.crate_token);
                v.visit_ident(&node.ident);
                if let Some(it) = &node.rename {
                    skip!((it).0);
                    v.visit_ident(&(it).1);
                }
                skip!(node.semi_token);
            }
                pub fn visit_item_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemFn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                v.visit_signature(&node.sig);
                v.visit_block(&*node.block);
            }
                pub fn visit_item_foreign_mod<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemForeignMod) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.unsafety);
                v.visit_abi(&node.abi);
                skip!(node.brace_token);
                for it in &node.items {
                    v.visit_foreign_item(it);
                }
            }
                pub fn visit_item_impl<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemImpl) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.defaultness);
                skip!(node.unsafety);
                skip!(node.impl_token);
                v.visit_generics(&node.generics);
                if let Some(it) = &node.trait_ {
                    skip!((it).0);
                    v.visit_path(&(it).1);
                    skip!((it).2);
                }
                v.visit_type(&*node.self_ty);
                skip!(node.brace_token);
                for it in &node.items {
                    v.visit_impl_item(it);
                }
            }
                pub fn visit_item_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.ident {
                    v.visit_ident(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_item_mod<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemMod) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.unsafety);
                skip!(node.mod_token);
                v.visit_ident(&node.ident);
                if let Some(it) = &node.content {
                    skip!((it).0);
                    for it in &(it).1 {
                        v.visit_item(it);
                    }
                }
                skip!(node.semi);
            }
                pub fn visit_item_static<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemStatic) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.static_token);
                v.visit_static_mutability(&node.mutability);
                v.visit_ident(&node.ident);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
                skip!(node.eq_token);
                v.visit_expr(&*node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_item_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemStruct) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.struct_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                v.visit_fields(&node.fields);
                skip!(node.semi_token);
            }
                pub fn visit_item_trait<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemTrait) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.unsafety);
                skip!(node.auto_token);
                if let Some(it) = &node.restriction {
                    v.visit_impl_restriction(it);
                }
                skip!(node.trait_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.supertraits) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
                skip!(node.brace_token);
                for it in &node.items {
                    v.visit_trait_item(it);
                }
            }
                pub fn visit_item_trait_alias<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemTraitAlias) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.trait_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.eq_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_item_type<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.type_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.eq_token);
                v.visit_type(&*node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_item_union<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemUnion) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.union_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                v.visit_fields_named(&node.fields);
            }
                pub fn visit_item_use<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemUse) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.use_token);
                skip!(node.leading_colon);
                v.visit_use_tree(&node.tree);
                skip!(node.semi_token);
            }
                pub fn visit_label<'ast, V>(v: &mut V, node: &'ast ::syntax::Label) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_lifetime(&node.name);
                skip!(node.colon_token);
            }
            pub fn visit_lifetime<'ast, V>(v: &mut V, node: &'ast ::syntax::Lifetime) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_span(&node.apostrophe);
                v.visit_ident(&node.ident);
            }
            pub fn visit_lifetime_param<'ast, V>(v: &mut V, node: &'ast ::syntax::LifetimeParam) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_lifetime(&node.lifetime);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_lifetime(it);
                }
            }
            pub fn visit_lit<'ast, V>(v: &mut V, node: &'ast ::syntax::Lit) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Lit::Str(_binding_0) => {
                        v.visit_lit_str(_binding_0);
                    }
                    ::syntax::Lit::ByteStr(_binding_0) => {
                        v.visit_lit_byte_str(_binding_0);
                    }
                    ::syntax::Lit::CStr(_binding_0) => {
                        v.visit_lit_cstr(_binding_0);
                    }
                    ::syntax::Lit::Byte(_binding_0) => {
                        v.visit_lit_byte(_binding_0);
                    }
                    ::syntax::Lit::Char(_binding_0) => {
                        v.visit_lit_char(_binding_0);
                    }
                    ::syntax::Lit::Int(_binding_0) => {
                        v.visit_lit_int(_binding_0);
                    }
                    ::syntax::Lit::Float(_binding_0) => {
                        v.visit_lit_float(_binding_0);
                    }
                    ::syntax::Lit::Bool(_binding_0) => {
                        v.visit_lit_bool(_binding_0);
                    }
                    ::syntax::Lit::Verbatim(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_lit_bool<'ast, V>(v: &mut V, node: &'ast ::syntax::LitBool) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.value);
                v.visit_span(&node.span);
            }
            pub fn visit_lit_byte<'ast, V>(v: &mut V, node: &'ast ::syntax::LitByte) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_byte_str<'ast, V>(v: &mut V, node: &'ast ::syntax::LitByteStr) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_cstr<'ast, V>(v: &mut V, node: &'ast ::syntax::LitCStr) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_char<'ast, V>(v: &mut V, node: &'ast ::syntax::LitChar) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_float<'ast, V>(v: &mut V, node: &'ast ::syntax::LitFloat) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_int<'ast, V>(v: &mut V, node: &'ast ::syntax::LitInt) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_str<'ast, V>(v: &mut V, node: &'ast ::syntax::LitStr) where
                V: Visit<'ast> + ?Sized,
            {}
                pub fn visit_local<'ast, V>(v: &mut V, node: &'ast ::syntax::Local) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.let_token);
                v.visit_pat(&node.pat);
                if let Some(it) = &node.init {
                    v.visit_local_init(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_local_init<'ast, V>(v: &mut V, node: &'ast ::syntax::LocalInit) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.eq_token);
                v.visit_expr(&*node.expr);
                if let Some(it) = &node.diverge {
                    skip!((it).0);
                    v.visit_expr(&*(it).1);
                }
            }
            pub fn visit_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::Macro) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_path(&node.path);
                skip!(node.bang_token);
                v.visit_macro_delimiter(&node.delimiter);
                v.visit_token_stream(&node.tokens);
            }
            pub fn visit_macro_delimiter<'ast, V>(v: &mut V, node: &'ast ::syntax::MacroDelimiter) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::MacroDelimiter::Paren(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::MacroDelimiter::Brace(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::MacroDelimiter::Bracket(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_member<'ast, V>(v: &mut V, node: &'ast ::syntax::Member) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Member::Named(_binding_0) => {
                        v.visit_ident(_binding_0);
                    }
                    ::syntax::Member::Unnamed(_binding_0) => {
                        v.visit_index(_binding_0);
                    }
                }
            }
            pub fn visit_meta<'ast, V>(v: &mut V, node: &'ast ::syntax::Meta) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Meta::Path(_binding_0) => {
                        v.visit_path(_binding_0);
                    }
                    ::syntax::Meta::List(_binding_0) => {
                        v.visit_meta_list(_binding_0);
                    }
                    ::syntax::Meta::NameValue(_binding_0) => {
                        v.visit_meta_name_value(_binding_0);
                    }
                }
            }
            pub fn visit_meta_list<'ast, V>(v: &mut V, node: &'ast ::syntax::MetaList) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_path(&node.path);
                v.visit_macro_delimiter(&node.delimiter);
                v.visit_token_stream(&node.tokens);
            }
            pub fn visit_meta_name_value<'ast, V>(v: &mut V, node: &'ast ::syntax::MetaNameValue) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_path(&node.path);
                skip!(node.eq_token);
                v.visit_expr(&node.value);
            }
            pub fn visit_parenthesized_generic_arguments<'ast, V>(
                v: &mut V,
                node: &'ast ::syntax::ParenthesizedGenericArguments,
            ) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.inputs) {
                    let it = el.value();
                    v.visit_type(it);
                }
                v.visit_return_type(&node.output);
            }
                pub fn visit_pat<'ast, V>(v: &mut V, node: &'ast ::syntax::Pat) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Pat::Const(_binding_0) => {
                        v.visit_expr_const(_binding_0);
                    }
                    ::syntax::Pat::Ident(_binding_0) => {
                        v.visit_pat_ident(_binding_0);
                    }
                    ::syntax::Pat::Lit(_binding_0) => {
                        v.visit_expr_lit(_binding_0);
                    }
                    ::syntax::Pat::Macro(_binding_0) => {
                        v.visit_expr_macro(_binding_0);
                    }
                    ::syntax::Pat::Or(_binding_0) => {
                        v.visit_pat_or(_binding_0);
                    }
                    ::syntax::Pat::Paren(_binding_0) => {
                        v.visit_pat_paren(_binding_0);
                    }
                    ::syntax::Pat::Path(_binding_0) => {
                        v.visit_expr_path(_binding_0);
                    }
                    ::syntax::Pat::Range(_binding_0) => {
                        v.visit_expr_range(_binding_0);
                    }
                    ::syntax::Pat::Reference(_binding_0) => {
                        v.visit_pat_reference(_binding_0);
                    }
                    ::syntax::Pat::Rest(_binding_0) => {
                        v.visit_pat_rest(_binding_0);
                    }
                    ::syntax::Pat::Slice(_binding_0) => {
                        v.visit_pat_slice(_binding_0);
                    }
                    ::syntax::Pat::Struct(_binding_0) => {
                        v.visit_pat_struct(_binding_0);
                    }
                    ::syntax::Pat::Tuple(_binding_0) => {
                        v.visit_pat_tuple(_binding_0);
                    }
                    ::syntax::Pat::TupleStruct(_binding_0) => {
                        v.visit_pat_tuple_struct(_binding_0);
                    }
                    ::syntax::Pat::Type(_binding_0) => {
                        v.visit_pat_type(_binding_0);
                    }
                    ::syntax::Pat::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                    ::syntax::Pat::Wild(_binding_0) => {
                        v.visit_pat_wild(_binding_0);
                    }
                }
            }
                pub fn visit_pat_ident<'ast, V>(v: &mut V, node: &'ast ::syntax::PatIdent) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.by_ref);
                skip!(node.mutability);
                v.visit_ident(&node.ident);
                if let Some(it) = &node.subpat {
                    skip!((it).0);
                    v.visit_pat(&*(it).1);
                }
            }
                pub fn visit_pat_or<'ast, V>(v: &mut V, node: &'ast ::syntax::PatOr) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.leading_vert);
                for el in Punctuated::pairs(&node.cases) {
                    let it = el.value();
                    v.visit_pat(it);
                }
            }
                pub fn visit_pat_paren<'ast, V>(v: &mut V, node: &'ast ::syntax::PatParen) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.paren_token);
                v.visit_pat(&*node.pat);
            }
                pub fn visit_pat_reference<'ast, V>(v: &mut V, node: &'ast ::syntax::PatReference) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.and_token);
                skip!(node.mutability);
                v.visit_pat(&*node.pat);
            }
                pub fn visit_pat_rest<'ast, V>(v: &mut V, node: &'ast ::syntax::PatRest) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.dot2_token);
            }
                pub fn visit_pat_slice<'ast, V>(v: &mut V, node: &'ast ::syntax::PatSlice) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.bracket_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_pat(it);
                }
            }
                pub fn visit_pat_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::PatStruct) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.fields) {
                    let it = el.value();
                    v.visit_field_pat(it);
                }
                if let Some(it) = &node.rest {
                    v.visit_pat_rest(it);
                }
            }
                pub fn visit_pat_tuple<'ast, V>(v: &mut V, node: &'ast ::syntax::PatTuple) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_pat(it);
                }
            }
                pub fn visit_pat_tuple_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::PatTupleStruct) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_pat(it);
                }
            }
                pub fn visit_pat_type<'ast, V>(v: &mut V, node: &'ast ::syntax::PatType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_pat(&*node.pat);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
            }
                pub fn visit_pat_wild<'ast, V>(v: &mut V, node: &'ast ::syntax::PatWild) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.underscore_token);
            }
            pub fn visit_path<'ast, V>(v: &mut V, node: &'ast ::syntax::Path) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.leading_colon);
                for el in Punctuated::pairs(&node.segments) {
                    let it = el.value();
                    v.visit_path_segment(it);
                }
            }
            pub fn visit_path_arguments<'ast, V>(v: &mut V, node: &'ast ::syntax::PathArguments) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::PathArguments::None => {}
                    ::syntax::PathArguments::AngleBracketed(_binding_0) => {
                        v.visit_angle_bracketed_generic_arguments(_binding_0);
                    }
                    ::syntax::PathArguments::Parenthesized(_binding_0) => {
                        v.visit_parenthesized_generic_arguments(_binding_0);
                    }
                }
            }
            pub fn visit_path_segment<'ast, V>(v: &mut V, node: &'ast ::syntax::PathSegment) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                v.visit_path_arguments(&node.arguments);
            }
                pub fn visit_pointer_mutability<'ast, V>(v: &mut V, node: &'ast ::syntax::PointerMutability) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::PointerMutability::Const(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::PointerMutability::Mut(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_precise_capture<'ast, V>(v: &mut V, node: &'ast ::syntax::PreciseCapture) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.use_token);
                skip!(node.lt_token);
                for el in Punctuated::pairs(&node.params) {
                    let it = el.value();
                    v.visit_captured_param(it);
                }
                skip!(node.gt_token);
            }
            pub fn visit_predicate_lifetime<'ast, V>(v: &mut V, node: &'ast ::syntax::PredicateLifetime) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_lifetime(&node.lifetime);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_lifetime(it);
                }
            }
            pub fn visit_predicate_type<'ast, V>(v: &mut V, node: &'ast ::syntax::PredicateType) where
                V: Visit<'ast> + ?Sized,
            {
                if let Some(it) = &node.lifetimes {
                    v.visit_bound_lifetimes(it);
                }
                v.visit_type(&node.bounded_ty);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
            }
            pub fn visit_qself<'ast, V>(v: &mut V, node: &'ast ::syntax::QSelf) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.lt_token);
                v.visit_type(&*node.ty);
                skip!(node.position);
                skip!(node.as_token);
                skip!(node.gt_token);
            }
                pub fn visit_range_limits<'ast, V>(v: &mut V, node: &'ast ::syntax::RangeLimits) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::RangeLimits::HalfOpen(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::RangeLimits::Closed(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_receiver<'ast, V>(v: &mut V, node: &'ast ::syntax::Receiver) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.reference {
                    skip!((it).0);
                    if let Some(it) = &(it).1 {
                        v.visit_lifetime(it);
                    }
                }
                skip!(node.mutability);
                skip!(node.self_token);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
            }
            pub fn visit_return_type<'ast, V>(v: &mut V, node: &'ast ::syntax::ReturnType) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::ReturnType::Default => {}
                    ::syntax::ReturnType::Type(_binding_0, _binding_1) => {
                        skip!(_binding_0);
                        v.visit_type(&**_binding_1);
                    }
                }
            }
                pub fn visit_signature<'ast, V>(v: &mut V, node: &'ast ::syntax::Signature) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.constness);
                skip!(node.asyncness);
                skip!(node.unsafety);
                if let Some(it) = &node.abi {
                    v.visit_abi(it);
                }
                skip!(node.fn_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.inputs) {
                    let it = el.value();
                    v.visit_fn_arg(it);
                }
                if let Some(it) = &node.variadic {
                    v.visit_variadic(it);
                }
                v.visit_return_type(&node.output);
            }
            pub fn visit_span<'ast, V>(v: &mut V, node: &process::macros::Span) where
                V: Visit<'ast> + ?Sized,
            {}
                pub fn visit_static_mutability<'ast, V>(v: &mut V, node: &'ast ::syntax::StaticMutability) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::StaticMutability::Mut(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::StaticMutability::None => {}
                }
            }
                pub fn visit_stmt<'ast, V>(v: &mut V, node: &'ast ::syntax::Stmt) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Stmt::Local(_binding_0) => {
                        v.visit_local(_binding_0);
                    }
                    ::syntax::Stmt::Item(_binding_0) => {
                        v.visit_item(_binding_0);
                    }
                    ::syntax::Stmt::Expr(_binding_0, _binding_1) => {
                        v.visit_expr(_binding_0);
                        skip!(_binding_1);
                    }
                    ::syntax::Stmt::Macro(_binding_0) => {
                        v.visit_stmt_macro(_binding_0);
                    }
                }
            }
                pub fn visit_stmt_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::StmtMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
            pub fn visit_trait_bound<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitBound) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                v.visit_trait_bound_modifier(&node.modifier);
                if let Some(it) = &node.lifetimes {
                    v.visit_bound_lifetimes(it);
                }
                v.visit_path(&node.path);
            }
            pub fn visit_trait_bound_modifier<'ast, V>(
                v: &mut V,
                node: &'ast ::syntax::TraitBoundModifier,
            ) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::TraitBoundModifier::None => {}
                    ::syntax::TraitBoundModifier::Maybe(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_trait_item<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItem) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::TraitItem::Const(_binding_0) => {
                        v.visit_trait_item_const(_binding_0);
                    }
                    ::syntax::TraitItem::Fn(_binding_0) => {
                        v.visit_trait_item_fn(_binding_0);
                    }
                    ::syntax::TraitItem::Type(_binding_0) => {
                        v.visit_trait_item_type(_binding_0);
                    }
                    ::syntax::TraitItem::Macro(_binding_0) => {
                        v.visit_trait_item_macro(_binding_0);
                    }
                    ::syntax::TraitItem::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
                pub fn visit_trait_item_const<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItemConst) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.const_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                v.visit_type(&node.ty);
                if let Some(it) = &node.default {
                    skip!((it).0);
                    v.visit_expr(&(it).1);
                }
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItemFn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_signature(&node.sig);
                if let Some(it) = &node.default {
                    v.visit_block(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItemMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_type<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItemType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.type_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
                if let Some(it) = &node.default {
                    skip!((it).0);
                    v.visit_type(&(it).1);
                }
                skip!(node.semi_token);
            }
            pub fn visit_type<'ast, V>(v: &mut V, node: &'ast ::syntax::Type) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Type::Array(_binding_0) => {
                        v.visit_type_array(_binding_0);
                    }
                    ::syntax::Type::BareFn(_binding_0) => {
                        v.visit_type_bare_fn(_binding_0);
                    }
                    ::syntax::Type::Group(_binding_0) => {
                        v.visit_type_group(_binding_0);
                    }
                    ::syntax::Type::ImplTrait(_binding_0) => {
                        v.visit_type_impl_trait(_binding_0);
                    }
                    ::syntax::Type::Infer(_binding_0) => {
                        v.visit_type_infer(_binding_0);
                    }
                    ::syntax::Type::Macro(_binding_0) => {
                        v.visit_type_macro(_binding_0);
                    }
                    ::syntax::Type::Never(_binding_0) => {
                        v.visit_type_never(_binding_0);
                    }
                    ::syntax::Type::Paren(_binding_0) => {
                        v.visit_type_paren(_binding_0);
                    }
                    ::syntax::Type::Path(_binding_0) => {
                        v.visit_type_path(_binding_0);
                    }
                    ::syntax::Type::Ptr(_binding_0) => {
                        v.visit_type_ptr(_binding_0);
                    }
                    ::syntax::Type::Reference(_binding_0) => {
                        v.visit_type_reference(_binding_0);
                    }
                    ::syntax::Type::Slice(_binding_0) => {
                        v.visit_type_slice(_binding_0);
                    }
                    ::syntax::Type::TraitObject(_binding_0) => {
                        v.visit_type_trait_object(_binding_0);
                    }
                    ::syntax::Type::Tuple(_binding_0) => {
                        v.visit_type_tuple(_binding_0);
                    }
                    ::syntax::Type::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
            pub fn visit_type_array<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeArray) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.bracket_token);
                v.visit_type(&*node.elem);
                skip!(node.semi_token);
                v.visit_expr(&node.len);
            }
            pub fn visit_type_bare_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeBareFn) where
                V: Visit<'ast> + ?Sized,
            {
                if let Some(it) = &node.lifetimes {
                    v.visit_bound_lifetimes(it);
                }
                skip!(node.unsafety);
                if let Some(it) = &node.abi {
                    v.visit_abi(it);
                }
                skip!(node.fn_token);
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.inputs) {
                    let it = el.value();
                    v.visit_bare_fn_arg(it);
                }
                if let Some(it) = &node.variadic {
                    v.visit_bare_variadic(it);
                }
                v.visit_return_type(&node.output);
            }
            pub fn visit_type_group<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeGroup) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.group_token);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_impl_trait<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeImplTrait) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.impl_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
            }
            pub fn visit_type_infer<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeInfer) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.underscore_token);
            }
            pub fn visit_type_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeMacro) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_macro(&node.mac);
            }
            pub fn visit_type_never<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeNever) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.bang_token);
            }
            pub fn visit_type_param<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeParam) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_ident(&node.ident);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
                skip!(node.eq_token);
                if let Some(it) = &node.default {
                    v.visit_type(it);
                }
            }
            pub fn visit_type_param_bound<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeParamBound) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::TypeParamBound::Trait(_binding_0) => {
                        v.visit_trait_bound(_binding_0);
                    }
                    ::syntax::TypeParamBound::Lifetime(_binding_0) => {
                        v.visit_lifetime(_binding_0);
                    }
                    ::syntax::TypeParamBound::PreciseCapture(_binding_0) => {
                        full!(v.visit_precise_capture(_binding_0));
                    }
                    ::syntax::TypeParamBound::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
            pub fn visit_type_paren<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeParen) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_path<'ast, V>(v: &mut V, node: &'ast ::syntax::TypePath) where
                V: Visit<'ast> + ?Sized,
            {
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
            }
            pub fn visit_type_ptr<'ast, V>(v: &mut V, node: &'ast ::syntax::TypePtr) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.star_token);
                skip!(node.const_token);
                skip!(node.mutability);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_reference<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeReference) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.and_token);
                if let Some(it) = &node.lifetime {
                    v.visit_lifetime(it);
                }
                skip!(node.mutability);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_slice<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeSlice) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.bracket_token);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_trait_object<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeTraitObject) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.dyn_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
            }
            pub fn visit_type_tuple<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeTuple) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_type(it);
                }
            }
            pub fn visit_un_op<'ast, V>(v: &mut V, node: &'ast ::syntax::UnOp) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::UnOp::Deref(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::UnOp::Not(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::UnOp::Neg(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_use_glob<'ast, V>(v: &mut V, node: &'ast ::syntax::UseGlob) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.star_token);
            }
                pub fn visit_use_group<'ast, V>(v: &mut V, node: &'ast ::syntax::UseGroup) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.items) {
                    let it = el.value();
                    v.visit_use_tree(it);
                }
            }
                pub fn visit_use_name<'ast, V>(v: &mut V, node: &'ast ::syntax::UseName) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
            }
                pub fn visit_use_path<'ast, V>(v: &mut V, node: &'ast ::syntax::UsePath) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                skip!(node.colon2_token);
                v.visit_use_tree(&*node.tree);
            }
                pub fn visit_use_rename<'ast, V>(v: &mut V, node: &'ast ::syntax::UseRename) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                skip!(node.as_token);
                v.visit_ident(&node.rename);
            }
                pub fn visit_use_tree<'ast, V>(v: &mut V, node: &'ast ::syntax::UseTree) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::UseTree::Path(_binding_0) => {
                        v.visit_use_path(_binding_0);
                    }
                    ::syntax::UseTree::Name(_binding_0) => {
                        v.visit_use_name(_binding_0);
                    }
                    ::syntax::UseTree::Rename(_binding_0) => {
                        v.visit_use_rename(_binding_0);
                    }
                    ::syntax::UseTree::Glob(_binding_0) => {
                        v.visit_use_glob(_binding_0);
                    }
                    ::syntax::UseTree::Group(_binding_0) => {
                        v.visit_use_group(_binding_0);
                    }
                }
            }
                pub fn visit_variadic<'ast, V>(v: &mut V, node: &'ast ::syntax::Variadic) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.pat {
                    v.visit_pat(&*(it).0);
                    skip!((it).1);
                }
                skip!(node.dots);
                skip!(node.comma);
            }
            pub fn visit_variant<'ast, V>(v: &mut V, node: &'ast ::syntax::Variant) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_ident(&node.ident);
                v.visit_fields(&node.fields);
                if let Some(it) = &node.discriminant {
                    skip!((it).0);
                    v.visit_expr(&(it).1);
                }
            }
            pub fn visit_vis_restricted<'ast, V>(v: &mut V, node: &'ast ::syntax::VisRestricted) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.pub_token);
                skip!(node.paren_token);
                skip!(node.in_token);
                v.visit_path(&*node.path);
            }
            pub fn visit_visibility<'ast, V>(v: &mut V, node: &'ast ::syntax::Visibility) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Visibility::Public(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::Visibility::Restricted(_binding_0) => {
                        v.visit_vis_restricted(_binding_0);
                    }
                    ::syntax::Visibility::Inherited => {}
                }
            }
            pub fn visit_where_clause<'ast, V>(v: &mut V, node: &'ast ::syntax::WhereClause) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.where_token);
                for el in Punctuated::pairs(&node.predicates) {
                    let it = el.value();
                    v.visit_where_predicate(it);
                }
            }
            pub fn visit_where_predicate<'ast, V>(v: &mut V, node: &'ast ::syntax::WherePredicate) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::WherePredicate::Lifetime(_binding_0) => {
                        v.visit_predicate_lifetime(_binding_0);
                    }
                    ::syntax::WherePredicate::Type(_binding_0) => {
                        v.visit_predicate_type(_binding_0);
                    }
                }
            }
        }
        /// Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.
        pub mod visit_mut
        {
            use ::
            {
                syntax::
                {
                    punctuated::{ Punctuated },
                },
                *,
            };
            /*
            */
            macro_rules! full
            {
                ($e:expr) => {
                    $e
                };
            }
            
            macro_rules! skip {
                ($($tt:tt)*) => {};
            }
            /// Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.
            pub trait VisitMut {
                        fn visit_abi_mut(&mut self, i: &mut ::syntax::Abi) {
                    visit_abi_mut(self, i);
                }
                        fn visit_angle_bracketed_generic_arguments_mut(
                    &mut self,
                    i: &mut ::syntax::AngleBracketedGenericArguments,
                ) {
                    visit_angle_bracketed_generic_arguments_mut(self, i);
                }
                            fn visit_arm_mut(&mut self, i: &mut ::syntax::Arm) {
                    visit_arm_mut(self, i);
                }
                        fn visit_assoc_const_mut(&mut self, i: &mut ::syntax::AssocConst) {
                    visit_assoc_const_mut(self, i);
                }
                        fn visit_assoc_type_mut(&mut self, i: &mut ::syntax::AssocType) {
                    visit_assoc_type_mut(self, i);
                }
                        fn visit_attr_style_mut(&mut self, i: &mut ::syntax::AttrStyle) {
                    visit_attr_style_mut(self, i);
                }
                        fn visit_attribute_mut(&mut self, i: &mut ::syntax::Attribute) {
                    visit_attribute_mut(self, i);
                }
                        fn visit_attributes_mut(&mut self, i: &mut Vec<::syntax::Attribute>) {
                    for attr in i {
                        self.visit_attribute_mut(attr);
                    }
                }
                        fn visit_bare_fn_arg_mut(&mut self, i: &mut ::syntax::BareFnArg) {
                    visit_bare_fn_arg_mut(self, i);
                }
                        fn visit_bare_variadic_mut(&mut self, i: &mut ::syntax::BareVariadic) {
                    visit_bare_variadic_mut(self, i);
                }
                        fn visit_bin_op_mut(&mut self, i: &mut ::syntax::BinOp) {
                    visit_bin_op_mut(self, i);
                }
                            fn visit_block_mut(&mut self, i: &mut ::syntax::Block) {
                    visit_block_mut(self, i);
                }
                        fn visit_bound_lifetimes_mut(&mut self, i: &mut ::syntax::BoundLifetimes) {
                    visit_bound_lifetimes_mut(self, i);
                }
                            fn visit_captured_param_mut(&mut self, i: &mut ::syntax::CapturedParam) {
                    visit_captured_param_mut(self, i);
                }
                        fn visit_const_param_mut(&mut self, i: &mut ::syntax::ConstParam) {
                    visit_const_param_mut(self, i);
                }
                        fn visit_constraint_mut(&mut self, i: &mut ::syntax::Constraint) {
                    visit_constraint_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_mut(&mut self, i: &mut ::syntax::Data) {
                    visit_data_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_enum_mut(&mut self, i: &mut ::syntax::DataEnum) {
                    visit_data_enum_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_struct_mut(&mut self, i: &mut ::syntax::DataStruct) {
                    visit_data_struct_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_union_mut(&mut self, i: &mut ::syntax::DataUnion) {
                    visit_data_union_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_derive_input_mut(&mut self, i: &mut ::syntax::DeriveInput) {
                    visit_derive_input_mut(self, i);
                }
                        fn visit_expr_mut(&mut self, i: &mut ::syntax::Expr) {
                    visit_expr_mut(self, i);
                }
                            fn visit_expr_array_mut(&mut self, i: &mut ::syntax::ExprArray) {
                    visit_expr_array_mut(self, i);
                }
                            fn visit_expr_assign_mut(&mut self, i: &mut ::syntax::ExprAssign) {
                    visit_expr_assign_mut(self, i);
                }
                            fn visit_expr_async_mut(&mut self, i: &mut ::syntax::ExprAsync) {
                    visit_expr_async_mut(self, i);
                }
                            fn visit_expr_await_mut(&mut self, i: &mut ::syntax::ExprAwait) {
                    visit_expr_await_mut(self, i);
                }
                        fn visit_expr_binary_mut(&mut self, i: &mut ::syntax::ExprBinary) {
                    visit_expr_binary_mut(self, i);
                }
                            fn visit_expr_block_mut(&mut self, i: &mut ::syntax::ExprBlock) {
                    visit_expr_block_mut(self, i);
                }
                            fn visit_expr_break_mut(&mut self, i: &mut ::syntax::ExprBreak) {
                    visit_expr_break_mut(self, i);
                }
                        fn visit_expr_call_mut(&mut self, i: &mut ::syntax::ExprCall) {
                    visit_expr_call_mut(self, i);
                }
                        fn visit_expr_cast_mut(&mut self, i: &mut ::syntax::ExprCast) {
                    visit_expr_cast_mut(self, i);
                }
                            fn visit_expr_closure_mut(&mut self, i: &mut ::syntax::ExprClosure) {
                    visit_expr_closure_mut(self, i);
                }
                            fn visit_expr_const_mut(&mut self, i: &mut ::syntax::ExprConst) {
                    visit_expr_const_mut(self, i);
                }
                            fn visit_expr_continue_mut(&mut self, i: &mut ::syntax::ExprContinue) {
                    visit_expr_continue_mut(self, i);
                }
                        fn visit_expr_field_mut(&mut self, i: &mut ::syntax::ExprField) {
                    visit_expr_field_mut(self, i);
                }
                            fn visit_expr_for_loop_mut(&mut self, i: &mut ::syntax::ExprForLoop) {
                    visit_expr_for_loop_mut(self, i);
                }
                        fn visit_expr_group_mut(&mut self, i: &mut ::syntax::ExprGroup) {
                    visit_expr_group_mut(self, i);
                }
                            fn visit_expr_if_mut(&mut self, i: &mut ::syntax::ExprIf) {
                    visit_expr_if_mut(self, i);
                }
                        fn visit_expr_index_mut(&mut self, i: &mut ::syntax::ExprIndex) {
                    visit_expr_index_mut(self, i);
                }
                            fn visit_expr_infer_mut(&mut self, i: &mut ::syntax::ExprInfer) {
                    visit_expr_infer_mut(self, i);
                }
                            fn visit_expr_let_mut(&mut self, i: &mut ::syntax::ExprLet) {
                    visit_expr_let_mut(self, i);
                }
                        fn visit_expr_lit_mut(&mut self, i: &mut ::syntax::ExprLit) {
                    visit_expr_lit_mut(self, i);
                }
                            fn visit_expr_loop_mut(&mut self, i: &mut ::syntax::ExprLoop) {
                    visit_expr_loop_mut(self, i);
                }
                        fn visit_expr_macro_mut(&mut self, i: &mut ::syntax::ExprMacro) {
                    visit_expr_macro_mut(self, i);
                }
                            fn visit_expr_match_mut(&mut self, i: &mut ::syntax::ExprMatch) {
                    visit_expr_match_mut(self, i);
                }
                        fn visit_expr_method_call_mut(&mut self, i: &mut ::syntax::ExprMethodCall) {
                    visit_expr_method_call_mut(self, i);
                }
                        fn visit_expr_paren_mut(&mut self, i: &mut ::syntax::ExprParen) {
                    visit_expr_paren_mut(self, i);
                }
                        fn visit_expr_path_mut(&mut self, i: &mut ::syntax::ExprPath) {
                    visit_expr_path_mut(self, i);
                }
                            fn visit_expr_range_mut(&mut self, i: &mut ::syntax::ExprRange) {
                    visit_expr_range_mut(self, i);
                }
                            fn visit_expr_raw_addr_mut(&mut self, i: &mut ::syntax::ExprRawAddr) {
                    visit_expr_raw_addr_mut(self, i);
                }
                        fn visit_expr_reference_mut(&mut self, i: &mut ::syntax::ExprReference) {
                    visit_expr_reference_mut(self, i);
                }
                            fn visit_expr_repeat_mut(&mut self, i: &mut ::syntax::ExprRepeat) {
                    visit_expr_repeat_mut(self, i);
                }
                            fn visit_expr_return_mut(&mut self, i: &mut ::syntax::ExprReturn) {
                    visit_expr_return_mut(self, i);
                }
                        fn visit_expr_struct_mut(&mut self, i: &mut ::syntax::ExprStruct) {
                    visit_expr_struct_mut(self, i);
                }
                            fn visit_expr_try_mut(&mut self, i: &mut ::syntax::ExprTry) {
                    visit_expr_try_mut(self, i);
                }
                            fn visit_expr_try_block_mut(&mut self, i: &mut ::syntax::ExprTryBlock) {
                    visit_expr_try_block_mut(self, i);
                }
                        fn visit_expr_tuple_mut(&mut self, i: &mut ::syntax::ExprTuple) {
                    visit_expr_tuple_mut(self, i);
                }
                        fn visit_expr_unary_mut(&mut self, i: &mut ::syntax::ExprUnary) {
                    visit_expr_unary_mut(self, i);
                }
                            fn visit_expr_unsafe_mut(&mut self, i: &mut ::syntax::ExprUnsafe) {
                    visit_expr_unsafe_mut(self, i);
                }
                            fn visit_expr_while_mut(&mut self, i: &mut ::syntax::ExprWhile) {
                    visit_expr_while_mut(self, i);
                }
                            fn visit_expr_yield_mut(&mut self, i: &mut ::syntax::ExprYield) {
                    visit_expr_yield_mut(self, i);
                }
                        fn visit_field_mut(&mut self, i: &mut ::syntax::Field) {
                    visit_field_mut(self, i);
                }
                        fn visit_field_mutability_mut(&mut self, i: &mut ::syntax::FieldMutability) {
                    visit_field_mutability_mut(self, i);
                }
                            fn visit_field_pat_mut(&mut self, i: &mut ::syntax::FieldPat) {
                    visit_field_pat_mut(self, i);
                }
                        fn visit_field_value_mut(&mut self, i: &mut ::syntax::FieldValue) {
                    visit_field_value_mut(self, i);
                }
                        fn visit_fields_mut(&mut self, i: &mut ::syntax::Fields) {
                    visit_fields_mut(self, i);
                }
                        fn visit_fields_named_mut(&mut self, i: &mut ::syntax::FieldsNamed) {
                    visit_fields_named_mut(self, i);
                }
                        fn visit_fields_unnamed_mut(&mut self, i: &mut ::syntax::FieldsUnnamed) {
                    visit_fields_unnamed_mut(self, i);
                }
                            fn visit_file_mut(&mut self, i: &mut ::syntax::File) {
                    visit_file_mut(self, i);
                }
                            fn visit_fn_arg_mut(&mut self, i: &mut ::syntax::FnArg) {
                    visit_fn_arg_mut(self, i);
                }
                            fn visit_foreign_item_mut(&mut self, i: &mut ::syntax::ForeignItem) {
                    visit_foreign_item_mut(self, i);
                }
                            fn visit_foreign_item_fn_mut(&mut self, i: &mut ::syntax::ForeignItemFn) {
                    visit_foreign_item_fn_mut(self, i);
                }
                            fn visit_foreign_item_macro_mut(&mut self, i: &mut ::syntax::ForeignItemMacro) {
                    visit_foreign_item_macro_mut(self, i);
                }
                            fn visit_foreign_item_static_mut(&mut self, i: &mut ::syntax::ForeignItemStatic) {
                    visit_foreign_item_static_mut(self, i);
                }
                            fn visit_foreign_item_type_mut(&mut self, i: &mut ::syntax::ForeignItemType) {
                    visit_foreign_item_type_mut(self, i);
                }
                        fn visit_generic_argument_mut(&mut self, i: &mut ::syntax::GenericArgument) {
                    visit_generic_argument_mut(self, i);
                }
                        fn visit_generic_param_mut(&mut self, i: &mut ::syntax::GenericParam) {
                    visit_generic_param_mut(self, i);
                }
                        fn visit_generics_mut(&mut self, i: &mut ::syntax::Generics) {
                    visit_generics_mut(self, i);
                }
                fn visit_ident_mut(&mut self, i: &mut process::macros::Ident) {
                    visit_ident_mut(self, i);
                }
                            fn visit_impl_item_mut(&mut self, i: &mut ::syntax::ImplItem) {
                    visit_impl_item_mut(self, i);
                }
                            fn visit_impl_item_const_mut(&mut self, i: &mut ::syntax::ImplItemConst) {
                    visit_impl_item_const_mut(self, i);
                }
                            fn visit_impl_item_fn_mut(&mut self, i: &mut ::syntax::ImplItemFn) {
                    visit_impl_item_fn_mut(self, i);
                }
                            fn visit_impl_item_macro_mut(&mut self, i: &mut ::syntax::ImplItemMacro) {
                    visit_impl_item_macro_mut(self, i);
                }
                            fn visit_impl_item_type_mut(&mut self, i: &mut ::syntax::ImplItemType) {
                    visit_impl_item_type_mut(self, i);
                }
                            fn visit_impl_restriction_mut(&mut self, i: &mut ::syntax::ImplRestriction) {
                    visit_impl_restriction_mut(self, i);
                }
                        fn visit_index_mut(&mut self, i: &mut ::syntax::Index) {
                    visit_index_mut(self, i);
                }
                            fn visit_item_mut(&mut self, i: &mut ::syntax::Item) {
                    visit_item_mut(self, i);
                }
                            fn visit_item_const_mut(&mut self, i: &mut ::syntax::ItemConst) {
                    visit_item_const_mut(self, i);
                }
                            fn visit_item_enum_mut(&mut self, i: &mut ::syntax::ItemEnum) {
                    visit_item_enum_mut(self, i);
                }
                            fn visit_item_extern_crate_mut(&mut self, i: &mut ::syntax::ItemExternCrate) {
                    visit_item_extern_crate_mut(self, i);
                }
                            fn visit_item_fn_mut(&mut self, i: &mut ::syntax::ItemFn) {
                    visit_item_fn_mut(self, i);
                }
                            fn visit_item_foreign_mod_mut(&mut self, i: &mut ::syntax::ItemForeignMod) {
                    visit_item_foreign_mod_mut(self, i);
                }
                            fn visit_item_impl_mut(&mut self, i: &mut ::syntax::ItemImpl) {
                    visit_item_impl_mut(self, i);
                }
                            fn visit_item_macro_mut(&mut self, i: &mut ::syntax::ItemMacro) {
                    visit_item_macro_mut(self, i);
                }
                            fn visit_item_mod_mut(&mut self, i: &mut ::syntax::ItemMod) {
                    visit_item_mod_mut(self, i);
                }
                            fn visit_item_static_mut(&mut self, i: &mut ::syntax::ItemStatic) {
                    visit_item_static_mut(self, i);
                }
                            fn visit_item_struct_mut(&mut self, i: &mut ::syntax::ItemStruct) {
                    visit_item_struct_mut(self, i);
                }
                            fn visit_item_trait_mut(&mut self, i: &mut ::syntax::ItemTrait) {
                    visit_item_trait_mut(self, i);
                }
                            fn visit_item_trait_alias_mut(&mut self, i: &mut ::syntax::ItemTraitAlias) {
                    visit_item_trait_alias_mut(self, i);
                }
                            fn visit_item_type_mut(&mut self, i: &mut ::syntax::ItemType) {
                    visit_item_type_mut(self, i);
                }
                            fn visit_item_union_mut(&mut self, i: &mut ::syntax::ItemUnion) {
                    visit_item_union_mut(self, i);
                }
                            fn visit_item_use_mut(&mut self, i: &mut ::syntax::ItemUse) {
                    visit_item_use_mut(self, i);
                }
                            fn visit_label_mut(&mut self, i: &mut ::syntax::Label) {
                    visit_label_mut(self, i);
                }
                fn visit_lifetime_mut(&mut self, i: &mut ::syntax::Lifetime) {
                    visit_lifetime_mut(self, i);
                }
                        fn visit_lifetime_param_mut(&mut self, i: &mut ::syntax::LifetimeParam) {
                    visit_lifetime_param_mut(self, i);
                }
                fn visit_lit_mut(&mut self, i: &mut ::syntax::Lit) {
                    visit_lit_mut(self, i);
                }
                fn visit_lit_bool_mut(&mut self, i: &mut ::syntax::LitBool) {
                    visit_lit_bool_mut(self, i);
                }
                fn visit_lit_byte_mut(&mut self, i: &mut ::syntax::LitByte) {
                    visit_lit_byte_mut(self, i);
                }
                fn visit_lit_byte_str_mut(&mut self, i: &mut ::syntax::LitByteStr) {
                    visit_lit_byte_str_mut(self, i);
                }
                fn visit_lit_cstr_mut(&mut self, i: &mut ::syntax::LitCStr) {
                    visit_lit_cstr_mut(self, i);
                }
                fn visit_lit_char_mut(&mut self, i: &mut ::syntax::LitChar) {
                    visit_lit_char_mut(self, i);
                }
                fn visit_lit_float_mut(&mut self, i: &mut ::syntax::LitFloat) {
                    visit_lit_float_mut(self, i);
                }
                fn visit_lit_int_mut(&mut self, i: &mut ::syntax::LitInt) {
                    visit_lit_int_mut(self, i);
                }
                fn visit_lit_str_mut(&mut self, i: &mut ::syntax::LitStr) {
                    visit_lit_str_mut(self, i);
                }
                            fn visit_local_mut(&mut self, i: &mut ::syntax::Local) {
                    visit_local_mut(self, i);
                }
                            fn visit_local_init_mut(&mut self, i: &mut ::syntax::LocalInit) {
                    visit_local_init_mut(self, i);
                }
                        fn visit_macro_mut(&mut self, i: &mut ::syntax::Macro) {
                    visit_macro_mut(self, i);
                }
                        fn visit_macro_delimiter_mut(&mut self, i: &mut ::syntax::MacroDelimiter) {
                    visit_macro_delimiter_mut(self, i);
                }
                        fn visit_member_mut(&mut self, i: &mut ::syntax::Member) {
                    visit_member_mut(self, i);
                }
                        fn visit_meta_mut(&mut self, i: &mut ::syntax::Meta) {
                    visit_meta_mut(self, i);
                }
                        fn visit_meta_list_mut(&mut self, i: &mut ::syntax::MetaList) {
                    visit_meta_list_mut(self, i);
                }
                        fn visit_meta_name_value_mut(&mut self, i: &mut ::syntax::MetaNameValue) {
                    visit_meta_name_value_mut(self, i);
                }
                        fn visit_parenthesized_generic_arguments_mut(
                    &mut self,
                    i: &mut ::syntax::ParenthesizedGenericArguments,
                ) {
                    visit_parenthesized_generic_arguments_mut(self, i);
                }
                            fn visit_pat_mut(&mut self, i: &mut ::syntax::Pat) {
                    visit_pat_mut(self, i);
                }
                            fn visit_pat_ident_mut(&mut self, i: &mut ::syntax::PatIdent) {
                    visit_pat_ident_mut(self, i);
                }
                            fn visit_pat_or_mut(&mut self, i: &mut ::syntax::PatOr) {
                    visit_pat_or_mut(self, i);
                }
                            fn visit_pat_paren_mut(&mut self, i: &mut ::syntax::PatParen) {
                    visit_pat_paren_mut(self, i);
                }
                            fn visit_pat_reference_mut(&mut self, i: &mut ::syntax::PatReference) {
                    visit_pat_reference_mut(self, i);
                }
                            fn visit_pat_rest_mut(&mut self, i: &mut ::syntax::PatRest) {
                    visit_pat_rest_mut(self, i);
                }
                            fn visit_pat_slice_mut(&mut self, i: &mut ::syntax::PatSlice) {
                    visit_pat_slice_mut(self, i);
                }
                            fn visit_pat_struct_mut(&mut self, i: &mut ::syntax::PatStruct) {
                    visit_pat_struct_mut(self, i);
                }
                            fn visit_pat_tuple_mut(&mut self, i: &mut ::syntax::PatTuple) {
                    visit_pat_tuple_mut(self, i);
                }
                            fn visit_pat_tuple_struct_mut(&mut self, i: &mut ::syntax::PatTupleStruct) {
                    visit_pat_tuple_struct_mut(self, i);
                }
                            fn visit_pat_type_mut(&mut self, i: &mut ::syntax::PatType) {
                    visit_pat_type_mut(self, i);
                }
                            fn visit_pat_wild_mut(&mut self, i: &mut ::syntax::PatWild) {
                    visit_pat_wild_mut(self, i);
                }
                        fn visit_path_mut(&mut self, i: &mut ::syntax::Path) {
                    visit_path_mut(self, i);
                }
                        fn visit_path_arguments_mut(&mut self, i: &mut ::syntax::PathArguments) {
                    visit_path_arguments_mut(self, i);
                }
                        fn visit_path_segment_mut(&mut self, i: &mut ::syntax::PathSegment) {
                    visit_path_segment_mut(self, i);
                }
                            fn visit_pointer_mutability_mut(&mut self, i: &mut ::syntax::PointerMutability) {
                    visit_pointer_mutability_mut(self, i);
                }
                            fn visit_precise_capture_mut(&mut self, i: &mut ::syntax::PreciseCapture) {
                    visit_precise_capture_mut(self, i);
                }
                        fn visit_predicate_lifetime_mut(&mut self, i: &mut ::syntax::PredicateLifetime) {
                    visit_predicate_lifetime_mut(self, i);
                }
                        fn visit_predicate_type_mut(&mut self, i: &mut ::syntax::PredicateType) {
                    visit_predicate_type_mut(self, i);
                }
                        fn visit_qself_mut(&mut self, i: &mut ::syntax::QSelf) {
                    visit_qself_mut(self, i);
                }
                            fn visit_range_limits_mut(&mut self, i: &mut ::syntax::RangeLimits) {
                    visit_range_limits_mut(self, i);
                }
                            fn visit_receiver_mut(&mut self, i: &mut ::syntax::Receiver) {
                    visit_receiver_mut(self, i);
                }
                        fn visit_return_type_mut(&mut self, i: &mut ::syntax::ReturnType) {
                    visit_return_type_mut(self, i);
                }
                            fn visit_signature_mut(&mut self, i: &mut ::syntax::Signature) {
                    visit_signature_mut(self, i);
                }
                fn visit_span_mut(&mut self, i: &mut process::macros::Span) {}
                            fn visit_static_mutability_mut(&mut self, i: &mut ::syntax::StaticMutability) {
                    visit_static_mutability_mut(self, i);
                }
                            fn visit_stmt_mut(&mut self, i: &mut ::syntax::Stmt) {
                    visit_stmt_mut(self, i);
                }
                            fn visit_stmt_macro_mut(&mut self, i: &mut ::syntax::StmtMacro) {
                    visit_stmt_macro_mut(self, i);
                }
                fn visit_token_stream_mut(&mut self, i: &mut process::macros::TokenStream) {}
                        fn visit_trait_bound_mut(&mut self, i: &mut ::syntax::TraitBound) {
                    visit_trait_bound_mut(self, i);
                }
                        fn visit_trait_bound_modifier_mut(&mut self, i: &mut ::syntax::TraitBoundModifier) {
                    visit_trait_bound_modifier_mut(self, i);
                }
                            fn visit_trait_item_mut(&mut self, i: &mut ::syntax::TraitItem) {
                    visit_trait_item_mut(self, i);
                }
                            fn visit_trait_item_const_mut(&mut self, i: &mut ::syntax::TraitItemConst) {
                    visit_trait_item_const_mut(self, i);
                }
                            fn visit_trait_item_fn_mut(&mut self, i: &mut ::syntax::TraitItemFn) {
                    visit_trait_item_fn_mut(self, i);
                }
                            fn visit_trait_item_macro_mut(&mut self, i: &mut ::syntax::TraitItemMacro) {
                    visit_trait_item_macro_mut(self, i);
                }
                            fn visit_trait_item_type_mut(&mut self, i: &mut ::syntax::TraitItemType) {
                    visit_trait_item_type_mut(self, i);
                }
                        fn visit_type_mut(&mut self, i: &mut ::syntax::Type) {
                    visit_type_mut(self, i);
                }
                        fn visit_type_array_mut(&mut self, i: &mut ::syntax::TypeArray) {
                    visit_type_array_mut(self, i);
                }
                        fn visit_type_bare_fn_mut(&mut self, i: &mut ::syntax::TypeBareFn) {
                    visit_type_bare_fn_mut(self, i);
                }
                        fn visit_type_group_mut(&mut self, i: &mut ::syntax::TypeGroup) {
                    visit_type_group_mut(self, i);
                }
                        fn visit_type_impl_trait_mut(&mut self, i: &mut ::syntax::TypeImplTrait) {
                    visit_type_impl_trait_mut(self, i);
                }
                        fn visit_type_infer_mut(&mut self, i: &mut ::syntax::TypeInfer) {
                    visit_type_infer_mut(self, i);
                }
                        fn visit_type_macro_mut(&mut self, i: &mut ::syntax::TypeMacro) {
                    visit_type_macro_mut(self, i);
                }
                        fn visit_type_never_mut(&mut self, i: &mut ::syntax::TypeNever) {
                    visit_type_never_mut(self, i);
                }
                        fn visit_type_param_mut(&mut self, i: &mut ::syntax::TypeParam) {
                    visit_type_param_mut(self, i);
                }
                        fn visit_type_param_bound_mut(&mut self, i: &mut ::syntax::TypeParamBound) {
                    visit_type_param_bound_mut(self, i);
                }
                        fn visit_type_paren_mut(&mut self, i: &mut ::syntax::TypeParen) {
                    visit_type_paren_mut(self, i);
                }
                        fn visit_type_path_mut(&mut self, i: &mut ::syntax::TypePath) {
                    visit_type_path_mut(self, i);
                }
                        fn visit_type_ptr_mut(&mut self, i: &mut ::syntax::TypePtr) {
                    visit_type_ptr_mut(self, i);
                }
                        fn visit_type_reference_mut(&mut self, i: &mut ::syntax::TypeReference) {
                    visit_type_reference_mut(self, i);
                }
                        fn visit_type_slice_mut(&mut self, i: &mut ::syntax::TypeSlice) {
                    visit_type_slice_mut(self, i);
                }
                        fn visit_type_trait_object_mut(&mut self, i: &mut ::syntax::TypeTraitObject) {
                    visit_type_trait_object_mut(self, i);
                }
                        fn visit_type_tuple_mut(&mut self, i: &mut ::syntax::TypeTuple) {
                    visit_type_tuple_mut(self, i);
                }
                        fn visit_un_op_mut(&mut self, i: &mut ::syntax::UnOp) {
                    visit_un_op_mut(self, i);
                }
                            fn visit_use_glob_mut(&mut self, i: &mut ::syntax::UseGlob) {
                    visit_use_glob_mut(self, i);
                }
                            fn visit_use_group_mut(&mut self, i: &mut ::syntax::UseGroup) {
                    visit_use_group_mut(self, i);
                }
                            fn visit_use_name_mut(&mut self, i: &mut ::syntax::UseName) {
                    visit_use_name_mut(self, i);
                }
                            fn visit_use_path_mut(&mut self, i: &mut ::syntax::UsePath) {
                    visit_use_path_mut(self, i);
                }
                            fn visit_use_rename_mut(&mut self, i: &mut ::syntax::UseRename) {
                    visit_use_rename_mut(self, i);
                }
                            fn visit_use_tree_mut(&mut self, i: &mut ::syntax::UseTree) {
                    visit_use_tree_mut(self, i);
                }
                            fn visit_variadic_mut(&mut self, i: &mut ::syntax::Variadic) {
                    visit_variadic_mut(self, i);
                }
                        fn visit_variant_mut(&mut self, i: &mut ::syntax::Variant) {
                    visit_variant_mut(self, i);
                }
                        fn visit_vis_restricted_mut(&mut self, i: &mut ::syntax::VisRestricted) {
                    visit_vis_restricted_mut(self, i);
                }
                        fn visit_visibility_mut(&mut self, i: &mut ::syntax::Visibility) {
                    visit_visibility_mut(self, i);
                }
                        fn visit_where_clause_mut(&mut self, i: &mut ::syntax::WhereClause) {
                    visit_where_clause_mut(self, i);
                }
                        fn visit_where_predicate_mut(&mut self, i: &mut ::syntax::WherePredicate) {
                    visit_where_predicate_mut(self, i);
                }
            }
            pub fn visit_abi_mut<V>(v: &mut V, node: &mut ::syntax::Abi) where
                V: VisitMut + ?Sized,
            {
                skip!(node.extern_token);
                if let Some(it) = &mut node.name {
                    v.visit_lit_str_mut(it);
                }
            }
            pub fn visit_angle_bracketed_generic_arguments_mut<V>(
                v: &mut V,
                node: &mut ::syntax::AngleBracketedGenericArguments,
            ) where
                V: VisitMut + ?Sized,
            {
                skip!(node.colon2_token);
                skip!(node.lt_token);
                for mut el in Punctuated::pairs_mut(&mut node.args) {
                    let it = el.value_mut();
                    v.visit_generic_argument_mut(it);
                }
                skip!(node.gt_token);
            }
                pub fn visit_arm_mut<V>(v: &mut V, node: &mut ::syntax::Arm) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_pat_mut(&mut node.pat);
                if let Some(it) = &mut node.guard {
                    skip!((it).0);
                    v.visit_expr_mut(&mut *(it).1);
                }
                skip!(node.fat_arrow_token);
                v.visit_expr_mut(&mut *node.body);
                skip!(node.comma);
            }
            pub fn visit_assoc_const_mut<V>(v: &mut V, node: &mut ::syntax::AssocConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.generics {
                    v.visit_angle_bracketed_generic_arguments_mut(it);
                }
                skip!(node.eq_token);
                v.visit_expr_mut(&mut node.value);
            }
            pub fn visit_assoc_type_mut<V>(v: &mut V, node: &mut ::syntax::AssocType) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.generics {
                    v.visit_angle_bracketed_generic_arguments_mut(it);
                }
                skip!(node.eq_token);
                v.visit_type_mut(&mut node.ty);
            }
            pub fn visit_attr_style_mut<V>(v: &mut V, node: &mut ::syntax::AttrStyle) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::AttrStyle::Outer => {}
                    ::syntax::AttrStyle::Inner(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_attribute_mut<V>(v: &mut V, node: &mut ::syntax::Attribute) where
                V: VisitMut + ?Sized,
            {
                skip!(node.pound_token);
                v.visit_attr_style_mut(&mut node.style);
                skip!(node.bracket_token);
                v.visit_meta_mut(&mut node.meta);
            }
            pub fn visit_bare_fn_arg_mut<V>(v: &mut V, node: &mut ::syntax::BareFnArg) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.name {
                    v.visit_ident_mut(&mut (it).0);
                    skip!((it).1);
                }
                v.visit_type_mut(&mut node.ty);
            }
            pub fn visit_bare_variadic_mut<V>(v: &mut V, node: &mut ::syntax::BareVariadic) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.name {
                    v.visit_ident_mut(&mut (it).0);
                    skip!((it).1);
                }
                skip!(node.dots);
                skip!(node.comma);
            }
            pub fn visit_bin_op_mut<V>(v: &mut V, node: &mut ::syntax::BinOp) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::BinOp::Add(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Sub(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Mul(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Div(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Rem(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::And(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Or(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitXor(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitAnd(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitOr(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Shl(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Shr(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Eq(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Lt(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Le(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Ne(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Ge(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Gt(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::AddAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::SubAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::MulAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::DivAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::RemAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitXorAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitAndAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitOrAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::ShlAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::ShrAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_block_mut<V>(v: &mut V, node: &mut ::syntax::Block) where
                V: VisitMut + ?Sized,
            {
                skip!(node.brace_token);
                for it in &mut node.stmts {
                    v.visit_stmt_mut(it);
                }
            }
            pub fn visit_bound_lifetimes_mut<V>(v: &mut V, node: &mut ::syntax::BoundLifetimes) where
                V: VisitMut + ?Sized,
            {
                skip!(node.for_token);
                skip!(node.lt_token);
                for mut el in Punctuated::pairs_mut(&mut node.lifetimes) {
                    let it = el.value_mut();
                    v.visit_generic_param_mut(it);
                }
                skip!(node.gt_token);
            }
                pub fn visit_captured_param_mut<V>(v: &mut V, node: &mut ::syntax::CapturedParam) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::CapturedParam::Lifetime(_binding_0) => {
                        v.visit_lifetime_mut(_binding_0);
                    }
                    ::syntax::CapturedParam::Ident(_binding_0) => {
                        v.visit_ident_mut(_binding_0);
                    }
                }
            }
            pub fn visit_const_param_mut<V>(v: &mut V, node: &mut ::syntax::ConstParam) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.const_token);
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon_token);
                v.visit_type_mut(&mut node.ty);
                skip!(node.eq_token);
                if let Some(it) = &mut node.default {
                    v.visit_expr_mut(it);
                }
            }
            pub fn visit_constraint_mut<V>(v: &mut V, node: &mut ::syntax::Constraint) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.generics {
                    v.visit_angle_bracketed_generic_arguments_mut(it);
                }
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
            }
            pub fn visit_data_mut<V>(v: &mut V, node: &mut ::syntax::Data) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Data::Struct(_binding_0) => {
                        v.visit_data_struct_mut(_binding_0);
                    }
                    ::syntax::Data::Enum(_binding_0) => {
                        v.visit_data_enum_mut(_binding_0);
                    }
                    ::syntax::Data::Union(_binding_0) => {
                        v.visit_data_union_mut(_binding_0);
                    }
                }
            }
            pub fn visit_data_enum_mut<V>(v: &mut V, node: &mut ::syntax::DataEnum) where
                V: VisitMut + ?Sized,
            {
                skip!(node.enum_token);
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.variants) {
                    let it = el.value_mut();
                    v.visit_variant_mut(it);
                }
            }
            pub fn visit_data_struct_mut<V>(v: &mut V, node: &mut ::syntax::DataStruct) where
                V: VisitMut + ?Sized,
            {
                skip!(node.struct_token);
                v.visit_fields_mut(&mut node.fields);
                skip!(node.semi_token);
            }
            pub fn visit_data_union_mut<V>(v: &mut V, node: &mut ::syntax::DataUnion) where
                V: VisitMut + ?Sized,
            {
                skip!(node.union_token);
                v.visit_fields_named_mut(&mut node.fields);
            }
            pub fn visit_derive_input_mut<V>(v: &mut V, node: &mut ::syntax::DeriveInput) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                v.visit_data_mut(&mut node.data);
            }
            pub fn visit_expr_mut<V>(v: &mut V, node: &mut ::syntax::Expr) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Expr::Array(_binding_0) => {
                        full!(v.visit_expr_array_mut(_binding_0));
                    }
                    ::syntax::Expr::Assign(_binding_0) => {
                        full!(v.visit_expr_assign_mut(_binding_0));
                    }
                    ::syntax::Expr::Async(_binding_0) => {
                        full!(v.visit_expr_async_mut(_binding_0));
                    }
                    ::syntax::Expr::Await(_binding_0) => {
                        full!(v.visit_expr_await_mut(_binding_0));
                    }
                    ::syntax::Expr::Binary(_binding_0) => {
                        v.visit_expr_binary_mut(_binding_0);
                    }
                    ::syntax::Expr::Block(_binding_0) => {
                        full!(v.visit_expr_block_mut(_binding_0));
                    }
                    ::syntax::Expr::Break(_binding_0) => {
                        full!(v.visit_expr_break_mut(_binding_0));
                    }
                    ::syntax::Expr::Call(_binding_0) => {
                        v.visit_expr_call_mut(_binding_0);
                    }
                    ::syntax::Expr::Cast(_binding_0) => {
                        v.visit_expr_cast_mut(_binding_0);
                    }
                    ::syntax::Expr::Closure(_binding_0) => {
                        full!(v.visit_expr_closure_mut(_binding_0));
                    }
                    ::syntax::Expr::Const(_binding_0) => {
                        full!(v.visit_expr_const_mut(_binding_0));
                    }
                    ::syntax::Expr::Continue(_binding_0) => {
                        full!(v.visit_expr_continue_mut(_binding_0));
                    }
                    ::syntax::Expr::Field(_binding_0) => {
                        v.visit_expr_field_mut(_binding_0);
                    }
                    ::syntax::Expr::ForLoop(_binding_0) => {
                        full!(v.visit_expr_for_loop_mut(_binding_0));
                    }
                    ::syntax::Expr::Group(_binding_0) => {
                        v.visit_expr_group_mut(_binding_0);
                    }
                    ::syntax::Expr::If(_binding_0) => {
                        full!(v.visit_expr_if_mut(_binding_0));
                    }
                    ::syntax::Expr::Index(_binding_0) => {
                        v.visit_expr_index_mut(_binding_0);
                    }
                    ::syntax::Expr::Infer(_binding_0) => {
                        full!(v.visit_expr_infer_mut(_binding_0));
                    }
                    ::syntax::Expr::Let(_binding_0) => {
                        full!(v.visit_expr_let_mut(_binding_0));
                    }
                    ::syntax::Expr::Lit(_binding_0) => {
                        v.visit_expr_lit_mut(_binding_0);
                    }
                    ::syntax::Expr::Loop(_binding_0) => {
                        full!(v.visit_expr_loop_mut(_binding_0));
                    }
                    ::syntax::Expr::Macro(_binding_0) => {
                        v.visit_expr_macro_mut(_binding_0);
                    }
                    ::syntax::Expr::Match(_binding_0) => {
                        full!(v.visit_expr_match_mut(_binding_0));
                    }
                    ::syntax::Expr::MethodCall(_binding_0) => {
                        v.visit_expr_method_call_mut(_binding_0);
                    }
                    ::syntax::Expr::Paren(_binding_0) => {
                        v.visit_expr_paren_mut(_binding_0);
                    }
                    ::syntax::Expr::Path(_binding_0) => {
                        v.visit_expr_path_mut(_binding_0);
                    }
                    ::syntax::Expr::Range(_binding_0) => {
                        full!(v.visit_expr_range_mut(_binding_0));
                    }
                    ::syntax::Expr::RawAddr(_binding_0) => {
                        full!(v.visit_expr_raw_addr_mut(_binding_0));
                    }
                    ::syntax::Expr::Reference(_binding_0) => {
                        v.visit_expr_reference_mut(_binding_0);
                    }
                    ::syntax::Expr::Repeat(_binding_0) => {
                        full!(v.visit_expr_repeat_mut(_binding_0));
                    }
                    ::syntax::Expr::Return(_binding_0) => {
                        full!(v.visit_expr_return_mut(_binding_0));
                    }
                    ::syntax::Expr::Struct(_binding_0) => {
                        v.visit_expr_struct_mut(_binding_0);
                    }
                    ::syntax::Expr::Try(_binding_0) => {
                        full!(v.visit_expr_try_mut(_binding_0));
                    }
                    ::syntax::Expr::TryBlock(_binding_0) => {
                        full!(v.visit_expr_try_block_mut(_binding_0));
                    }
                    ::syntax::Expr::Tuple(_binding_0) => {
                        v.visit_expr_tuple_mut(_binding_0);
                    }
                    ::syntax::Expr::Unary(_binding_0) => {
                        v.visit_expr_unary_mut(_binding_0);
                    }
                    ::syntax::Expr::Unsafe(_binding_0) => {
                        full!(v.visit_expr_unsafe_mut(_binding_0));
                    }
                    ::syntax::Expr::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                    ::syntax::Expr::While(_binding_0) => {
                        full!(v.visit_expr_while_mut(_binding_0));
                    }
                    ::syntax::Expr::Yield(_binding_0) => {
                        full!(v.visit_expr_yield_mut(_binding_0));
                    }
                }
            }
                pub fn visit_expr_array_mut<V>(v: &mut V, node: &mut ::syntax::ExprArray) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.bracket_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_expr_mut(it);
                }
            }
                pub fn visit_expr_assign_mut<V>(v: &mut V, node: &mut ::syntax::ExprAssign) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.left);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.right);
            }
                pub fn visit_expr_async_mut<V>(v: &mut V, node: &mut ::syntax::ExprAsync) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.async_token);
                skip!(node.capture);
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_expr_await_mut<V>(v: &mut V, node: &mut ::syntax::ExprAwait) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.base);
                skip!(node.dot_token);
                skip!(node.await_token);
            }
            pub fn visit_expr_binary_mut<V>(v: &mut V, node: &mut ::syntax::ExprBinary) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.left);
                v.visit_bin_op_mut(&mut node.op);
                v.visit_expr_mut(&mut *node.right);
            }
                pub fn visit_expr_block_mut<V>(v: &mut V, node: &mut ::syntax::ExprBlock) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.label {
                    v.visit_label_mut(it);
                }
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_expr_break_mut<V>(v: &mut V, node: &mut ::syntax::ExprBreak) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.break_token);
                if let Some(it) = &mut node.label {
                    v.visit_lifetime_mut(it);
                }
                if let Some(it) = &mut node.expr {
                    v.visit_expr_mut(&mut **it);
                }
            }
            pub fn visit_expr_call_mut<V>(v: &mut V, node: &mut ::syntax::ExprCall) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.func);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.args) {
                    let it = el.value_mut();
                    v.visit_expr_mut(it);
                }
            }
            pub fn visit_expr_cast_mut<V>(v: &mut V, node: &mut ::syntax::ExprCast) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.as_token);
                v.visit_type_mut(&mut *node.ty);
            }
                pub fn visit_expr_closure_mut<V>(v: &mut V, node: &mut ::syntax::ExprClosure) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.lifetimes {
                    v.visit_bound_lifetimes_mut(it);
                }
                skip!(node.constness);
                skip!(node.movability);
                skip!(node.asyncness);
                skip!(node.capture);
                skip!(node.or1_token);
                for mut el in Punctuated::pairs_mut(&mut node.inputs) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
                skip!(node.or2_token);
                v.visit_return_type_mut(&mut node.output);
                v.visit_expr_mut(&mut *node.body);
            }
                pub fn visit_expr_const_mut<V>(v: &mut V, node: &mut ::syntax::ExprConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.const_token);
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_expr_continue_mut<V>(v: &mut V, node: &mut ::syntax::ExprContinue) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.continue_token);
                if let Some(it) = &mut node.label {
                    v.visit_lifetime_mut(it);
                }
            }
            pub fn visit_expr_field_mut<V>(v: &mut V, node: &mut ::syntax::ExprField) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.base);
                skip!(node.dot_token);
                v.visit_member_mut(&mut node.member);
            }
                pub fn visit_expr_for_loop_mut<V>(v: &mut V, node: &mut ::syntax::ExprForLoop) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.label {
                    v.visit_label_mut(it);
                }
                skip!(node.for_token);
                v.visit_pat_mut(&mut *node.pat);
                skip!(node.in_token);
                v.visit_expr_mut(&mut *node.expr);
                v.visit_block_mut(&mut node.body);
            }
            pub fn visit_expr_group_mut<V>(v: &mut V, node: &mut ::syntax::ExprGroup) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.group_token);
                v.visit_expr_mut(&mut *node.expr);
            }
                pub fn visit_expr_if_mut<V>(v: &mut V, node: &mut ::syntax::ExprIf) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.if_token);
                v.visit_expr_mut(&mut *node.cond);
                v.visit_block_mut(&mut node.then_branch);
                if let Some(it) = &mut node.else_branch {
                    skip!((it).0);
                    v.visit_expr_mut(&mut *(it).1);
                }
            }
            pub fn visit_expr_index_mut<V>(v: &mut V, node: &mut ::syntax::ExprIndex) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.bracket_token);
                v.visit_expr_mut(&mut *node.index);
            }
                pub fn visit_expr_infer_mut<V>(v: &mut V, node: &mut ::syntax::ExprInfer) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.underscore_token);
            }
                pub fn visit_expr_let_mut<V>(v: &mut V, node: &mut ::syntax::ExprLet) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.let_token);
                v.visit_pat_mut(&mut *node.pat);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.expr);
            }
            pub fn visit_expr_lit_mut<V>(v: &mut V, node: &mut ::syntax::ExprLit) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_lit_mut(&mut node.lit);
            }
                pub fn visit_expr_loop_mut<V>(v: &mut V, node: &mut ::syntax::ExprLoop) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.label {
                    v.visit_label_mut(it);
                }
                skip!(node.loop_token);
                v.visit_block_mut(&mut node.body);
            }
            pub fn visit_expr_macro_mut<V>(v: &mut V, node: &mut ::syntax::ExprMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
            }
                pub fn visit_expr_match_mut<V>(v: &mut V, node: &mut ::syntax::ExprMatch) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.match_token);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.brace_token);
                for it in &mut node.arms {
                    v.visit_arm_mut(it);
                }
            }
            pub fn visit_expr_method_call_mut<V>(v: &mut V, node: &mut ::syntax::ExprMethodCall) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.receiver);
                skip!(node.dot_token);
                v.visit_ident_mut(&mut node.method);
                if let Some(it) = &mut node.turbofish {
                    v.visit_angle_bracketed_generic_arguments_mut(it);
                }
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.args) {
                    let it = el.value_mut();
                    v.visit_expr_mut(it);
                }
            }
            pub fn visit_expr_paren_mut<V>(v: &mut V, node: &mut ::syntax::ExprParen) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.paren_token);
                v.visit_expr_mut(&mut *node.expr);
            }
            pub fn visit_expr_path_mut<V>(v: &mut V, node: &mut ::syntax::ExprPath) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
            }
                pub fn visit_expr_range_mut<V>(v: &mut V, node: &mut ::syntax::ExprRange) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.start {
                    v.visit_expr_mut(&mut **it);
                }
                v.visit_range_limits_mut(&mut node.limits);
                if let Some(it) = &mut node.end {
                    v.visit_expr_mut(&mut **it);
                }
            }
                pub fn visit_expr_raw_addr_mut<V>(v: &mut V, node: &mut ::syntax::ExprRawAddr) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.and_token);
                skip!(node.raw);
                v.visit_pointer_mutability_mut(&mut node.mutability);
                v.visit_expr_mut(&mut *node.expr);
            }
            pub fn visit_expr_reference_mut<V>(v: &mut V, node: &mut ::syntax::ExprReference) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.and_token);
                skip!(node.mutability);
                v.visit_expr_mut(&mut *node.expr);
            }
                pub fn visit_expr_repeat_mut<V>(v: &mut V, node: &mut ::syntax::ExprRepeat) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.bracket_token);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.semi_token);
                v.visit_expr_mut(&mut *node.len);
            }
                pub fn visit_expr_return_mut<V>(v: &mut V, node: &mut ::syntax::ExprReturn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.return_token);
                if let Some(it) = &mut node.expr {
                    v.visit_expr_mut(&mut **it);
                }
            }
            pub fn visit_expr_struct_mut<V>(v: &mut V, node: &mut ::syntax::ExprStruct) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.fields) {
                    let it = el.value_mut();
                    v.visit_field_value_mut(it);
                }
                skip!(node.dot2_token);
                if let Some(it) = &mut node.rest {
                    v.visit_expr_mut(&mut **it);
                }
            }
                pub fn visit_expr_try_mut<V>(v: &mut V, node: &mut ::syntax::ExprTry) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.question_token);
            }
                pub fn visit_expr_try_block_mut<V>(v: &mut V, node: &mut ::syntax::ExprTryBlock) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.try_token);
                v.visit_block_mut(&mut node.block);
            }
            pub fn visit_expr_tuple_mut<V>(v: &mut V, node: &mut ::syntax::ExprTuple) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_expr_mut(it);
                }
            }
            pub fn visit_expr_unary_mut<V>(v: &mut V, node: &mut ::syntax::ExprUnary) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_un_op_mut(&mut node.op);
                v.visit_expr_mut(&mut *node.expr);
            }
                pub fn visit_expr_unsafe_mut<V>(v: &mut V, node: &mut ::syntax::ExprUnsafe) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.unsafe_token);
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_expr_while_mut<V>(v: &mut V, node: &mut ::syntax::ExprWhile) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.label {
                    v.visit_label_mut(it);
                }
                skip!(node.while_token);
                v.visit_expr_mut(&mut *node.cond);
                v.visit_block_mut(&mut node.body);
            }
                pub fn visit_expr_yield_mut<V>(v: &mut V, node: &mut ::syntax::ExprYield) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.yield_token);
                if let Some(it) = &mut node.expr {
                    v.visit_expr_mut(&mut **it);
                }
            }
            pub fn visit_field_mut<V>(v: &mut V, node: &mut ::syntax::Field) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                v.visit_field_mutability_mut(&mut node.mutability);
                if let Some(it) = &mut node.ident {
                    v.visit_ident_mut(it);
                }
                skip!(node.colon_token);
                v.visit_type_mut(&mut node.ty);
            }
            pub fn visit_field_mutability_mut<V>(v: &mut V, node: &mut ::syntax::FieldMutability) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::FieldMutability::None => {}
                }
            }
                pub fn visit_field_pat_mut<V>(v: &mut V, node: &mut ::syntax::FieldPat) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_member_mut(&mut node.member);
                skip!(node.colon_token);
                v.visit_pat_mut(&mut *node.pat);
            }
            pub fn visit_field_value_mut<V>(v: &mut V, node: &mut ::syntax::FieldValue) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_member_mut(&mut node.member);
                skip!(node.colon_token);
                v.visit_expr_mut(&mut node.expr);
            }
            pub fn visit_fields_mut<V>(v: &mut V, node: &mut ::syntax::Fields) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Fields::Named(_binding_0) => {
                        v.visit_fields_named_mut(_binding_0);
                    }
                    ::syntax::Fields::Unnamed(_binding_0) => {
                        v.visit_fields_unnamed_mut(_binding_0);
                    }
                    ::syntax::Fields::Unit => {}
                }
            }
            pub fn visit_fields_named_mut<V>(v: &mut V, node: &mut ::syntax::FieldsNamed) where
                V: VisitMut + ?Sized,
            {
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.named) {
                    let it = el.value_mut();
                    v.visit_field_mut(it);
                }
            }
            pub fn visit_fields_unnamed_mut<V>(v: &mut V, node: &mut ::syntax::FieldsUnnamed) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.unnamed) {
                    let it = el.value_mut();
                    v.visit_field_mut(it);
                }
            }
                pub fn visit_file_mut<V>(v: &mut V, node: &mut ::syntax::File) where
                V: VisitMut + ?Sized,
            {
                skip!(node.shebang);
                v.visit_attributes_mut(&mut node.attrs);
                for it in &mut node.items {
                    v.visit_item_mut(it);
                }
            }
                pub fn visit_fn_arg_mut<V>(v: &mut V, node: &mut ::syntax::FnArg) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::FnArg::Receiver(_binding_0) => {
                        v.visit_receiver_mut(_binding_0);
                    }
                    ::syntax::FnArg::Typed(_binding_0) => {
                        v.visit_pat_type_mut(_binding_0);
                    }
                }
            }
                pub fn visit_foreign_item_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItem) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::ForeignItem::Fn(_binding_0) => {
                        v.visit_foreign_item_fn_mut(_binding_0);
                    }
                    ::syntax::ForeignItem::Static(_binding_0) => {
                        v.visit_foreign_item_static_mut(_binding_0);
                    }
                    ::syntax::ForeignItem::Type(_binding_0) => {
                        v.visit_foreign_item_type_mut(_binding_0);
                    }
                    ::syntax::ForeignItem::Macro(_binding_0) => {
                        v.visit_foreign_item_macro_mut(_binding_0);
                    }
                    ::syntax::ForeignItem::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
                pub fn visit_foreign_item_fn_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItemFn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                v.visit_signature_mut(&mut node.sig);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_macro_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItemMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_static_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItemStatic) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.static_token);
                v.visit_static_mutability_mut(&mut node.mutability);
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_type_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItemType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.type_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.semi_token);
            }
            pub fn visit_generic_argument_mut<V>(v: &mut V, node: &mut ::syntax::GenericArgument) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::GenericArgument::Lifetime(_binding_0) => {
                        v.visit_lifetime_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::Type(_binding_0) => {
                        v.visit_type_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::Const(_binding_0) => {
                        v.visit_expr_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::AssocType(_binding_0) => {
                        v.visit_assoc_type_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::AssocConst(_binding_0) => {
                        v.visit_assoc_const_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::Constraint(_binding_0) => {
                        v.visit_constraint_mut(_binding_0);
                    }
                }
            }
            pub fn visit_generic_param_mut<V>(v: &mut V, node: &mut ::syntax::GenericParam) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::GenericParam::Lifetime(_binding_0) => {
                        v.visit_lifetime_param_mut(_binding_0);
                    }
                    ::syntax::GenericParam::Type(_binding_0) => {
                        v.visit_type_param_mut(_binding_0);
                    }
                    ::syntax::GenericParam::Const(_binding_0) => {
                        v.visit_const_param_mut(_binding_0);
                    }
                }
            }
            pub fn visit_generics_mut<V>(v: &mut V, node: &mut ::syntax::Generics) where
                V: VisitMut + ?Sized,
            {
                skip!(node.lt_token);
                for mut el in Punctuated::pairs_mut(&mut node.params) {
                    let it = el.value_mut();
                    v.visit_generic_param_mut(it);
                }
                skip!(node.gt_token);
                if let Some(it) = &mut node.where_clause {
                    v.visit_where_clause_mut(it);
                }
            }
            pub fn visit_ident_mut<V>(v: &mut V, node: &mut process::macros::Ident) where
                V: VisitMut + ?Sized,
            {
                let mut span = node.span();
                v.visit_span_mut(&mut span);
                node.set_span(span);
            }
                pub fn visit_impl_item_mut<V>(v: &mut V, node: &mut ::syntax::ImplItem) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::ImplItem::Const(_binding_0) => {
                        v.visit_impl_item_const_mut(_binding_0);
                    }
                    ::syntax::ImplItem::Fn(_binding_0) => {
                        v.visit_impl_item_fn_mut(_binding_0);
                    }
                    ::syntax::ImplItem::Type(_binding_0) => {
                        v.visit_impl_item_type_mut(_binding_0);
                    }
                    ::syntax::ImplItem::Macro(_binding_0) => {
                        v.visit_impl_item_macro_mut(_binding_0);
                    }
                    ::syntax::ImplItem::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
                pub fn visit_impl_item_const_mut<V>(v: &mut V, node: &mut ::syntax::ImplItemConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.defaultness);
                skip!(node.const_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                v.visit_type_mut(&mut node.ty);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_impl_item_fn_mut<V>(v: &mut V, node: &mut ::syntax::ImplItemFn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.defaultness);
                v.visit_signature_mut(&mut node.sig);
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_impl_item_macro_mut<V>(v: &mut V, node: &mut ::syntax::ImplItemMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_impl_item_type_mut<V>(v: &mut V, node: &mut ::syntax::ImplItemType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.defaultness);
                skip!(node.type_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.eq_token);
                v.visit_type_mut(&mut node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_impl_restriction_mut<V>(v: &mut V, node: &mut ::syntax::ImplRestriction) where
                V: VisitMut + ?Sized,
            {
                match *node {}
            }
            pub fn visit_index_mut<V>(v: &mut V, node: &mut ::syntax::Index) where
                V: VisitMut + ?Sized,
            {
                skip!(node.index);
                v.visit_span_mut(&mut node.span);
            }
                pub fn visit_item_mut<V>(v: &mut V, node: &mut ::syntax::Item) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Item::Const(_binding_0) => {
                        v.visit_item_const_mut(_binding_0);
                    }
                    ::syntax::Item::Enum(_binding_0) => {
                        v.visit_item_enum_mut(_binding_0);
                    }
                    ::syntax::Item::ExternCrate(_binding_0) => {
                        v.visit_item_extern_crate_mut(_binding_0);
                    }
                    ::syntax::Item::Fn(_binding_0) => {
                        v.visit_item_fn_mut(_binding_0);
                    }
                    ::syntax::Item::ForeignMod(_binding_0) => {
                        v.visit_item_foreign_mod_mut(_binding_0);
                    }
                    ::syntax::Item::Impl(_binding_0) => {
                        v.visit_item_impl_mut(_binding_0);
                    }
                    ::syntax::Item::Macro(_binding_0) => {
                        v.visit_item_macro_mut(_binding_0);
                    }
                    ::syntax::Item::Mod(_binding_0) => {
                        v.visit_item_mod_mut(_binding_0);
                    }
                    ::syntax::Item::Static(_binding_0) => {
                        v.visit_item_static_mut(_binding_0);
                    }
                    ::syntax::Item::Struct(_binding_0) => {
                        v.visit_item_struct_mut(_binding_0);
                    }
                    ::syntax::Item::Trait(_binding_0) => {
                        v.visit_item_trait_mut(_binding_0);
                    }
                    ::syntax::Item::TraitAlias(_binding_0) => {
                        v.visit_item_trait_alias_mut(_binding_0);
                    }
                    ::syntax::Item::Type(_binding_0) => {
                        v.visit_item_type_mut(_binding_0);
                    }
                    ::syntax::Item::Union(_binding_0) => {
                        v.visit_item_union_mut(_binding_0);
                    }
                    ::syntax::Item::Use(_binding_0) => {
                        v.visit_item_use_mut(_binding_0);
                    }
                    ::syntax::Item::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
                pub fn visit_item_const_mut<V>(v: &mut V, node: &mut ::syntax::ItemConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.const_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_item_enum_mut<V>(v: &mut V, node: &mut ::syntax::ItemEnum) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.enum_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.variants) {
                    let it = el.value_mut();
                    v.visit_variant_mut(it);
                }
            }
                pub fn visit_item_extern_crate_mut<V>(v: &mut V, node: &mut ::syntax::ItemExternCrate) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.extern_token);
                skip!(node.crate_token);
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.rename {
                    skip!((it).0);
                    v.visit_ident_mut(&mut (it).1);
                }
                skip!(node.semi_token);
            }
                pub fn visit_item_fn_mut<V>(v: &mut V, node: &mut ::syntax::ItemFn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                v.visit_signature_mut(&mut node.sig);
                v.visit_block_mut(&mut *node.block);
            }
                pub fn visit_item_foreign_mod_mut<V>(v: &mut V, node: &mut ::syntax::ItemForeignMod) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.unsafety);
                v.visit_abi_mut(&mut node.abi);
                skip!(node.brace_token);
                for it in &mut node.items {
                    v.visit_foreign_item_mut(it);
                }
            }
                pub fn visit_item_impl_mut<V>(v: &mut V, node: &mut ::syntax::ItemImpl) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.defaultness);
                skip!(node.unsafety);
                skip!(node.impl_token);
                v.visit_generics_mut(&mut node.generics);
                if let Some(it) = &mut node.trait_ {
                    skip!((it).0);
                    v.visit_path_mut(&mut (it).1);
                    skip!((it).2);
                }
                v.visit_type_mut(&mut *node.self_ty);
                skip!(node.brace_token);
                for it in &mut node.items {
                    v.visit_impl_item_mut(it);
                }
            }
                pub fn visit_item_macro_mut<V>(v: &mut V, node: &mut ::syntax::ItemMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.ident {
                    v.visit_ident_mut(it);
                }
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_item_mod_mut<V>(v: &mut V, node: &mut ::syntax::ItemMod) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.unsafety);
                skip!(node.mod_token);
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.content {
                    skip!((it).0);
                    for it in &mut (it).1 {
                        v.visit_item_mut(it);
                    }
                }
                skip!(node.semi);
            }
                pub fn visit_item_static_mut<V>(v: &mut V, node: &mut ::syntax::ItemStatic) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.static_token);
                v.visit_static_mutability_mut(&mut node.mutability);
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_item_struct_mut<V>(v: &mut V, node: &mut ::syntax::ItemStruct) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.struct_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                v.visit_fields_mut(&mut node.fields);
                skip!(node.semi_token);
            }
                pub fn visit_item_trait_mut<V>(v: &mut V, node: &mut ::syntax::ItemTrait) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.unsafety);
                skip!(node.auto_token);
                if let Some(it) = &mut node.restriction {
                    v.visit_impl_restriction_mut(it);
                }
                skip!(node.trait_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.supertraits) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
                skip!(node.brace_token);
                for it in &mut node.items {
                    v.visit_trait_item_mut(it);
                }
            }
                pub fn visit_item_trait_alias_mut<V>(v: &mut V, node: &mut ::syntax::ItemTraitAlias) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.trait_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.eq_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_item_type_mut<V>(v: &mut V, node: &mut ::syntax::ItemType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.type_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.eq_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_item_union_mut<V>(v: &mut V, node: &mut ::syntax::ItemUnion) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.union_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                v.visit_fields_named_mut(&mut node.fields);
            }
                pub fn visit_item_use_mut<V>(v: &mut V, node: &mut ::syntax::ItemUse) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.use_token);
                skip!(node.leading_colon);
                v.visit_use_tree_mut(&mut node.tree);
                skip!(node.semi_token);
            }
                pub fn visit_label_mut<V>(v: &mut V, node: &mut ::syntax::Label) where
                V: VisitMut + ?Sized,
            {
                v.visit_lifetime_mut(&mut node.name);
                skip!(node.colon_token);
            }
            pub fn visit_lifetime_mut<V>(v: &mut V, node: &mut ::syntax::Lifetime) where
                V: VisitMut + ?Sized,
            {
                v.visit_span_mut(&mut node.apostrophe);
                v.visit_ident_mut(&mut node.ident);
            }
            pub fn visit_lifetime_param_mut<V>(v: &mut V, node: &mut ::syntax::LifetimeParam) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_lifetime_mut(&mut node.lifetime);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_lifetime_mut(it);
                }
            }
            pub fn visit_lit_mut<V>(v: &mut V, node: &mut ::syntax::Lit) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Lit::Str(_binding_0) => {
                        v.visit_lit_str_mut(_binding_0);
                    }
                    ::syntax::Lit::ByteStr(_binding_0) => {
                        v.visit_lit_byte_str_mut(_binding_0);
                    }
                    ::syntax::Lit::CStr(_binding_0) => {
                        v.visit_lit_cstr_mut(_binding_0);
                    }
                    ::syntax::Lit::Byte(_binding_0) => {
                        v.visit_lit_byte_mut(_binding_0);
                    }
                    ::syntax::Lit::Char(_binding_0) => {
                        v.visit_lit_char_mut(_binding_0);
                    }
                    ::syntax::Lit::Int(_binding_0) => {
                        v.visit_lit_int_mut(_binding_0);
                    }
                    ::syntax::Lit::Float(_binding_0) => {
                        v.visit_lit_float_mut(_binding_0);
                    }
                    ::syntax::Lit::Bool(_binding_0) => {
                        v.visit_lit_bool_mut(_binding_0);
                    }
                    ::syntax::Lit::Verbatim(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_lit_bool_mut<V>(v: &mut V, node: &mut ::syntax::LitBool) where
                V: VisitMut + ?Sized,
            {
                skip!(node.value);
                v.visit_span_mut(&mut node.span);
            }
            pub fn visit_lit_byte_mut<V>(v: &mut V, node: &mut ::syntax::LitByte) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_byte_str_mut<V>(v: &mut V, node: &mut ::syntax::LitByteStr) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_cstr_mut<V>(v: &mut V, node: &mut ::syntax::LitCStr) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_char_mut<V>(v: &mut V, node: &mut ::syntax::LitChar) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_float_mut<V>(v: &mut V, node: &mut ::syntax::LitFloat) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_int_mut<V>(v: &mut V, node: &mut ::syntax::LitInt) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_str_mut<V>(v: &mut V, node: &mut ::syntax::LitStr) where
                V: VisitMut + ?Sized,
            {}
                pub fn visit_local_mut<V>(v: &mut V, node: &mut ::syntax::Local) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.let_token);
                v.visit_pat_mut(&mut node.pat);
                if let Some(it) = &mut node.init {
                    v.visit_local_init_mut(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_local_init_mut<V>(v: &mut V, node: &mut ::syntax::LocalInit) where
                V: VisitMut + ?Sized,
            {
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.expr);
                if let Some(it) = &mut node.diverge {
                    skip!((it).0);
                    v.visit_expr_mut(&mut *(it).1);
                }
            }
            pub fn visit_macro_mut<V>(v: &mut V, node: &mut ::syntax::Macro) where
                V: VisitMut + ?Sized,
            {
                v.visit_path_mut(&mut node.path);
                skip!(node.bang_token);
                v.visit_macro_delimiter_mut(&mut node.delimiter);
                v.visit_token_stream_mut(&mut node.tokens);
            }
            pub fn visit_macro_delimiter_mut<V>(v: &mut V, node: &mut ::syntax::MacroDelimiter) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::MacroDelimiter::Paren(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::MacroDelimiter::Brace(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::MacroDelimiter::Bracket(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_member_mut<V>(v: &mut V, node: &mut ::syntax::Member) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Member::Named(_binding_0) => {
                        v.visit_ident_mut(_binding_0);
                    }
                    ::syntax::Member::Unnamed(_binding_0) => {
                        v.visit_index_mut(_binding_0);
                    }
                }
            }
            pub fn visit_meta_mut<V>(v: &mut V, node: &mut ::syntax::Meta) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Meta::Path(_binding_0) => {
                        v.visit_path_mut(_binding_0);
                    }
                    ::syntax::Meta::List(_binding_0) => {
                        v.visit_meta_list_mut(_binding_0);
                    }
                    ::syntax::Meta::NameValue(_binding_0) => {
                        v.visit_meta_name_value_mut(_binding_0);
                    }
                }
            }
            pub fn visit_meta_list_mut<V>(v: &mut V, node: &mut ::syntax::MetaList) where
                V: VisitMut + ?Sized,
            {
                v.visit_path_mut(&mut node.path);
                v.visit_macro_delimiter_mut(&mut node.delimiter);
                v.visit_token_stream_mut(&mut node.tokens);
            }
            pub fn visit_meta_name_value_mut<V>(v: &mut V, node: &mut ::syntax::MetaNameValue) where
                V: VisitMut + ?Sized,
            {
                v.visit_path_mut(&mut node.path);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut node.value);
            }
            pub fn visit_parenthesized_generic_arguments_mut<V>(
                v: &mut V,
                node: &mut ::syntax::ParenthesizedGenericArguments,
            ) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.inputs) {
                    let it = el.value_mut();
                    v.visit_type_mut(it);
                }
                v.visit_return_type_mut(&mut node.output);
            }
                pub fn visit_pat_mut<V>(v: &mut V, node: &mut ::syntax::Pat) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Pat::Const(_binding_0) => {
                        v.visit_expr_const_mut(_binding_0);
                    }
                    ::syntax::Pat::Ident(_binding_0) => {
                        v.visit_pat_ident_mut(_binding_0);
                    }
                    ::syntax::Pat::Lit(_binding_0) => {
                        v.visit_expr_lit_mut(_binding_0);
                    }
                    ::syntax::Pat::Macro(_binding_0) => {
                        v.visit_expr_macro_mut(_binding_0);
                    }
                    ::syntax::Pat::Or(_binding_0) => {
                        v.visit_pat_or_mut(_binding_0);
                    }
                    ::syntax::Pat::Paren(_binding_0) => {
                        v.visit_pat_paren_mut(_binding_0);
                    }
                    ::syntax::Pat::Path(_binding_0) => {
                        v.visit_expr_path_mut(_binding_0);
                    }
                    ::syntax::Pat::Range(_binding_0) => {
                        v.visit_expr_range_mut(_binding_0);
                    }
                    ::syntax::Pat::Reference(_binding_0) => {
                        v.visit_pat_reference_mut(_binding_0);
                    }
                    ::syntax::Pat::Rest(_binding_0) => {
                        v.visit_pat_rest_mut(_binding_0);
                    }
                    ::syntax::Pat::Slice(_binding_0) => {
                        v.visit_pat_slice_mut(_binding_0);
                    }
                    ::syntax::Pat::Struct(_binding_0) => {
                        v.visit_pat_struct_mut(_binding_0);
                    }
                    ::syntax::Pat::Tuple(_binding_0) => {
                        v.visit_pat_tuple_mut(_binding_0);
                    }
                    ::syntax::Pat::TupleStruct(_binding_0) => {
                        v.visit_pat_tuple_struct_mut(_binding_0);
                    }
                    ::syntax::Pat::Type(_binding_0) => {
                        v.visit_pat_type_mut(_binding_0);
                    }
                    ::syntax::Pat::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                    ::syntax::Pat::Wild(_binding_0) => {
                        v.visit_pat_wild_mut(_binding_0);
                    }
                }
            }
                pub fn visit_pat_ident_mut<V>(v: &mut V, node: &mut ::syntax::PatIdent) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.by_ref);
                skip!(node.mutability);
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.subpat {
                    skip!((it).0);
                    v.visit_pat_mut(&mut *(it).1);
                }
            }
                pub fn visit_pat_or_mut<V>(v: &mut V, node: &mut ::syntax::PatOr) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.leading_vert);
                for mut el in Punctuated::pairs_mut(&mut node.cases) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
            }
                pub fn visit_pat_paren_mut<V>(v: &mut V, node: &mut ::syntax::PatParen) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.paren_token);
                v.visit_pat_mut(&mut *node.pat);
            }
                pub fn visit_pat_reference_mut<V>(v: &mut V, node: &mut ::syntax::PatReference) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.and_token);
                skip!(node.mutability);
                v.visit_pat_mut(&mut *node.pat);
            }
                pub fn visit_pat_rest_mut<V>(v: &mut V, node: &mut ::syntax::PatRest) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.dot2_token);
            }
                pub fn visit_pat_slice_mut<V>(v: &mut V, node: &mut ::syntax::PatSlice) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.bracket_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
            }
                pub fn visit_pat_struct_mut<V>(v: &mut V, node: &mut ::syntax::PatStruct) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.fields) {
                    let it = el.value_mut();
                    v.visit_field_pat_mut(it);
                }
                if let Some(it) = &mut node.rest {
                    v.visit_pat_rest_mut(it);
                }
            }
                pub fn visit_pat_tuple_mut<V>(v: &mut V, node: &mut ::syntax::PatTuple) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
            }
                pub fn visit_pat_tuple_struct_mut<V>(v: &mut V, node: &mut ::syntax::PatTupleStruct) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
            }
                pub fn visit_pat_type_mut<V>(v: &mut V, node: &mut ::syntax::PatType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_pat_mut(&mut *node.pat);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
            }
                pub fn visit_pat_wild_mut<V>(v: &mut V, node: &mut ::syntax::PatWild) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.underscore_token);
            }
            pub fn visit_path_mut<V>(v: &mut V, node: &mut ::syntax::Path) where
                V: VisitMut + ?Sized,
            {
                skip!(node.leading_colon);
                for mut el in Punctuated::pairs_mut(&mut node.segments) {
                    let it = el.value_mut();
                    v.visit_path_segment_mut(it);
                }
            }
            pub fn visit_path_arguments_mut<V>(v: &mut V, node: &mut ::syntax::PathArguments) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::PathArguments::None => {}
                    ::syntax::PathArguments::AngleBracketed(_binding_0) => {
                        v.visit_angle_bracketed_generic_arguments_mut(_binding_0);
                    }
                    ::syntax::PathArguments::Parenthesized(_binding_0) => {
                        v.visit_parenthesized_generic_arguments_mut(_binding_0);
                    }
                }
            }
            pub fn visit_path_segment_mut<V>(v: &mut V, node: &mut ::syntax::PathSegment) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                v.visit_path_arguments_mut(&mut node.arguments);
            }
                pub fn visit_pointer_mutability_mut<V>(v: &mut V, node: &mut ::syntax::PointerMutability) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::PointerMutability::Const(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::PointerMutability::Mut(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_precise_capture_mut<V>(v: &mut V, node: &mut ::syntax::PreciseCapture) where
                V: VisitMut + ?Sized,
            {
                skip!(node.use_token);
                skip!(node.lt_token);
                for mut el in Punctuated::pairs_mut(&mut node.params) {
                    let it = el.value_mut();
                    v.visit_captured_param_mut(it);
                }
                skip!(node.gt_token);
            }
            pub fn visit_predicate_lifetime_mut<V>(v: &mut V, node: &mut ::syntax::PredicateLifetime) where
                V: VisitMut + ?Sized,
            {
                v.visit_lifetime_mut(&mut node.lifetime);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_lifetime_mut(it);
                }
            }
            pub fn visit_predicate_type_mut<V>(v: &mut V, node: &mut ::syntax::PredicateType) where
                V: VisitMut + ?Sized,
            {
                if let Some(it) = &mut node.lifetimes {
                    v.visit_bound_lifetimes_mut(it);
                }
                v.visit_type_mut(&mut node.bounded_ty);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
            }
            pub fn visit_qself_mut<V>(v: &mut V, node: &mut ::syntax::QSelf) where
                V: VisitMut + ?Sized,
            {
                skip!(node.lt_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.position);
                skip!(node.as_token);
                skip!(node.gt_token);
            }
                pub fn visit_range_limits_mut<V>(v: &mut V, node: &mut ::syntax::RangeLimits) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::RangeLimits::HalfOpen(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::RangeLimits::Closed(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_receiver_mut<V>(v: &mut V, node: &mut ::syntax::Receiver) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.reference {
                    skip!((it).0);
                    if let Some(it) = &mut (it).1 {
                        v.visit_lifetime_mut(it);
                    }
                }
                skip!(node.mutability);
                skip!(node.self_token);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
            }
            pub fn visit_return_type_mut<V>(v: &mut V, node: &mut ::syntax::ReturnType) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::ReturnType::Default => {}
                    ::syntax::ReturnType::Type(_binding_0, _binding_1) => {
                        skip!(_binding_0);
                        v.visit_type_mut(&mut **_binding_1);
                    }
                }
            }
                pub fn visit_signature_mut<V>(v: &mut V, node: &mut ::syntax::Signature) where
                V: VisitMut + ?Sized,
            {
                skip!(node.constness);
                skip!(node.asyncness);
                skip!(node.unsafety);
                if let Some(it) = &mut node.abi {
                    v.visit_abi_mut(it);
                }
                skip!(node.fn_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.inputs) {
                    let it = el.value_mut();
                    v.visit_fn_arg_mut(it);
                }
                if let Some(it) = &mut node.variadic {
                    v.visit_variadic_mut(it);
                }
                v.visit_return_type_mut(&mut node.output);
            }
            pub fn visit_span_mut<V>(v: &mut V, node: &mut process::macros::Span) where
                V: VisitMut + ?Sized,
            {}
                pub fn visit_static_mutability_mut<V>(v: &mut V, node: &mut ::syntax::StaticMutability) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::StaticMutability::Mut(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::StaticMutability::None => {}
                }
            }
                pub fn visit_stmt_mut<V>(v: &mut V, node: &mut ::syntax::Stmt) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Stmt::Local(_binding_0) => {
                        v.visit_local_mut(_binding_0);
                    }
                    ::syntax::Stmt::Item(_binding_0) => {
                        v.visit_item_mut(_binding_0);
                    }
                    ::syntax::Stmt::Expr(_binding_0, _binding_1) => {
                        v.visit_expr_mut(_binding_0);
                        skip!(_binding_1);
                    }
                    ::syntax::Stmt::Macro(_binding_0) => {
                        v.visit_stmt_macro_mut(_binding_0);
                    }
                }
            }
                pub fn visit_stmt_macro_mut<V>(v: &mut V, node: &mut ::syntax::StmtMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
            pub fn visit_trait_bound_mut<V>(v: &mut V, node: &mut ::syntax::TraitBound) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                v.visit_trait_bound_modifier_mut(&mut node.modifier);
                if let Some(it) = &mut node.lifetimes {
                    v.visit_bound_lifetimes_mut(it);
                }
                v.visit_path_mut(&mut node.path);
            }
            pub fn visit_trait_bound_modifier_mut<V>(v: &mut V, node: &mut ::syntax::TraitBoundModifier) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::TraitBoundModifier::None => {}
                    ::syntax::TraitBoundModifier::Maybe(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_trait_item_mut<V>(v: &mut V, node: &mut ::syntax::TraitItem) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::TraitItem::Const(_binding_0) => {
                        v.visit_trait_item_const_mut(_binding_0);
                    }
                    ::syntax::TraitItem::Fn(_binding_0) => {
                        v.visit_trait_item_fn_mut(_binding_0);
                    }
                    ::syntax::TraitItem::Type(_binding_0) => {
                        v.visit_trait_item_type_mut(_binding_0);
                    }
                    ::syntax::TraitItem::Macro(_binding_0) => {
                        v.visit_trait_item_macro_mut(_binding_0);
                    }
                    ::syntax::TraitItem::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
                pub fn visit_trait_item_const_mut<V>(v: &mut V, node: &mut ::syntax::TraitItemConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.const_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                v.visit_type_mut(&mut node.ty);
                if let Some(it) = &mut node.default {
                    skip!((it).0);
                    v.visit_expr_mut(&mut (it).1);
                }
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_fn_mut<V>(v: &mut V, node: &mut ::syntax::TraitItemFn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_signature_mut(&mut node.sig);
                if let Some(it) = &mut node.default {
                    v.visit_block_mut(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_macro_mut<V>(v: &mut V, node: &mut ::syntax::TraitItemMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_type_mut<V>(v: &mut V, node: &mut ::syntax::TraitItemType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.type_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
                if let Some(it) = &mut node.default {
                    skip!((it).0);
                    v.visit_type_mut(&mut (it).1);
                }
                skip!(node.semi_token);
            }
            pub fn visit_type_mut<V>(v: &mut V, node: &mut ::syntax::Type) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Type::Array(_binding_0) => {
                        v.visit_type_array_mut(_binding_0);
                    }
                    ::syntax::Type::BareFn(_binding_0) => {
                        v.visit_type_bare_fn_mut(_binding_0);
                    }
                    ::syntax::Type::Group(_binding_0) => {
                        v.visit_type_group_mut(_binding_0);
                    }
                    ::syntax::Type::ImplTrait(_binding_0) => {
                        v.visit_type_impl_trait_mut(_binding_0);
                    }
                    ::syntax::Type::Infer(_binding_0) => {
                        v.visit_type_infer_mut(_binding_0);
                    }
                    ::syntax::Type::Macro(_binding_0) => {
                        v.visit_type_macro_mut(_binding_0);
                    }
                    ::syntax::Type::Never(_binding_0) => {
                        v.visit_type_never_mut(_binding_0);
                    }
                    ::syntax::Type::Paren(_binding_0) => {
                        v.visit_type_paren_mut(_binding_0);
                    }
                    ::syntax::Type::Path(_binding_0) => {
                        v.visit_type_path_mut(_binding_0);
                    }
                    ::syntax::Type::Ptr(_binding_0) => {
                        v.visit_type_ptr_mut(_binding_0);
                    }
                    ::syntax::Type::Reference(_binding_0) => {
                        v.visit_type_reference_mut(_binding_0);
                    }
                    ::syntax::Type::Slice(_binding_0) => {
                        v.visit_type_slice_mut(_binding_0);
                    }
                    ::syntax::Type::TraitObject(_binding_0) => {
                        v.visit_type_trait_object_mut(_binding_0);
                    }
                    ::syntax::Type::Tuple(_binding_0) => {
                        v.visit_type_tuple_mut(_binding_0);
                    }
                    ::syntax::Type::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
            pub fn visit_type_array_mut<V>(v: &mut V, node: &mut ::syntax::TypeArray) where
                V: VisitMut + ?Sized,
            {
                skip!(node.bracket_token);
                v.visit_type_mut(&mut *node.elem);
                skip!(node.semi_token);
                v.visit_expr_mut(&mut node.len);
            }
            pub fn visit_type_bare_fn_mut<V>(v: &mut V, node: &mut ::syntax::TypeBareFn) where
                V: VisitMut + ?Sized,
            {
                if let Some(it) = &mut node.lifetimes {
                    v.visit_bound_lifetimes_mut(it);
                }
                skip!(node.unsafety);
                if let Some(it) = &mut node.abi {
                    v.visit_abi_mut(it);
                }
                skip!(node.fn_token);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.inputs) {
                    let it = el.value_mut();
                    v.visit_bare_fn_arg_mut(it);
                }
                if let Some(it) = &mut node.variadic {
                    v.visit_bare_variadic_mut(it);
                }
                v.visit_return_type_mut(&mut node.output);
            }
            pub fn visit_type_group_mut<V>(v: &mut V, node: &mut ::syntax::TypeGroup) where
                V: VisitMut + ?Sized,
            {
                skip!(node.group_token);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_impl_trait_mut<V>(v: &mut V, node: &mut ::syntax::TypeImplTrait) where
                V: VisitMut + ?Sized,
            {
                skip!(node.impl_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
            }
            pub fn visit_type_infer_mut<V>(v: &mut V, node: &mut ::syntax::TypeInfer) where
                V: VisitMut + ?Sized,
            {
                skip!(node.underscore_token);
            }
            pub fn visit_type_macro_mut<V>(v: &mut V, node: &mut ::syntax::TypeMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_macro_mut(&mut node.mac);
            }
            pub fn visit_type_never_mut<V>(v: &mut V, node: &mut ::syntax::TypeNever) where
                V: VisitMut + ?Sized,
            {
                skip!(node.bang_token);
            }
            pub fn visit_type_param_mut<V>(v: &mut V, node: &mut ::syntax::TypeParam) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
                skip!(node.eq_token);
                if let Some(it) = &mut node.default {
                    v.visit_type_mut(it);
                }
            }
            pub fn visit_type_param_bound_mut<V>(v: &mut V, node: &mut ::syntax::TypeParamBound) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::TypeParamBound::Trait(_binding_0) => {
                        v.visit_trait_bound_mut(_binding_0);
                    }
                    ::syntax::TypeParamBound::Lifetime(_binding_0) => {
                        v.visit_lifetime_mut(_binding_0);
                    }
                    ::syntax::TypeParamBound::PreciseCapture(_binding_0) => {
                        full!(v.visit_precise_capture_mut(_binding_0));
                    }
                    ::syntax::TypeParamBound::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
            pub fn visit_type_paren_mut<V>(v: &mut V, node: &mut ::syntax::TypeParen) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_path_mut<V>(v: &mut V, node: &mut ::syntax::TypePath) where
                V: VisitMut + ?Sized,
            {
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
            }
            pub fn visit_type_ptr_mut<V>(v: &mut V, node: &mut ::syntax::TypePtr) where
                V: VisitMut + ?Sized,
            {
                skip!(node.star_token);
                skip!(node.const_token);
                skip!(node.mutability);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_reference_mut<V>(v: &mut V, node: &mut ::syntax::TypeReference) where
                V: VisitMut + ?Sized,
            {
                skip!(node.and_token);
                if let Some(it) = &mut node.lifetime {
                    v.visit_lifetime_mut(it);
                }
                skip!(node.mutability);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_slice_mut<V>(v: &mut V, node: &mut ::syntax::TypeSlice) where
                V: VisitMut + ?Sized,
            {
                skip!(node.bracket_token);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_trait_object_mut<V>(v: &mut V, node: &mut ::syntax::TypeTraitObject) where
                V: VisitMut + ?Sized,
            {
                skip!(node.dyn_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
            }
            pub fn visit_type_tuple_mut<V>(v: &mut V, node: &mut ::syntax::TypeTuple) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_type_mut(it);
                }
            }
            pub fn visit_un_op_mut<V>(v: &mut V, node: &mut ::syntax::UnOp) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::UnOp::Deref(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::UnOp::Not(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::UnOp::Neg(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_use_glob_mut<V>(v: &mut V, node: &mut ::syntax::UseGlob) where
                V: VisitMut + ?Sized,
            {
                skip!(node.star_token);
            }
                pub fn visit_use_group_mut<V>(v: &mut V, node: &mut ::syntax::UseGroup) where
                V: VisitMut + ?Sized,
            {
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.items) {
                    let it = el.value_mut();
                    v.visit_use_tree_mut(it);
                }
            }
                pub fn visit_use_name_mut<V>(v: &mut V, node: &mut ::syntax::UseName) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
            }
                pub fn visit_use_path_mut<V>(v: &mut V, node: &mut ::syntax::UsePath) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon2_token);
                v.visit_use_tree_mut(&mut *node.tree);
            }
                pub fn visit_use_rename_mut<V>(v: &mut V, node: &mut ::syntax::UseRename) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                skip!(node.as_token);
                v.visit_ident_mut(&mut node.rename);
            }
                pub fn visit_use_tree_mut<V>(v: &mut V, node: &mut ::syntax::UseTree) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::UseTree::Path(_binding_0) => {
                        v.visit_use_path_mut(_binding_0);
                    }
                    ::syntax::UseTree::Name(_binding_0) => {
                        v.visit_use_name_mut(_binding_0);
                    }
                    ::syntax::UseTree::Rename(_binding_0) => {
                        v.visit_use_rename_mut(_binding_0);
                    }
                    ::syntax::UseTree::Glob(_binding_0) => {
                        v.visit_use_glob_mut(_binding_0);
                    }
                    ::syntax::UseTree::Group(_binding_0) => {
                        v.visit_use_group_mut(_binding_0);
                    }
                }
            }
                pub fn visit_variadic_mut<V>(v: &mut V, node: &mut ::syntax::Variadic) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.pat {
                    v.visit_pat_mut(&mut *(it).0);
                    skip!((it).1);
                }
                skip!(node.dots);
                skip!(node.comma);
            }
            pub fn visit_variant_mut<V>(v: &mut V, node: &mut ::syntax::Variant) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_ident_mut(&mut node.ident);
                v.visit_fields_mut(&mut node.fields);
                if let Some(it) = &mut node.discriminant {
                    skip!((it).0);
                    v.visit_expr_mut(&mut (it).1);
                }
            }
            pub fn visit_vis_restricted_mut<V>(v: &mut V, node: &mut ::syntax::VisRestricted) where
                V: VisitMut + ?Sized,
            {
                skip!(node.pub_token);
                skip!(node.paren_token);
                skip!(node.in_token);
                v.visit_path_mut(&mut *node.path);
            }
            pub fn visit_visibility_mut<V>(v: &mut V, node: &mut ::syntax::Visibility) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Visibility::Public(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::Visibility::Restricted(_binding_0) => {
                        v.visit_vis_restricted_mut(_binding_0);
                    }
                    ::syntax::Visibility::Inherited => {}
                }
            }
            pub fn visit_where_clause_mut<V>(v: &mut V, node: &mut ::syntax::WhereClause) where
                V: VisitMut + ?Sized,
            {
                skip!(node.where_token);
                for mut el in Punctuated::pairs_mut(&mut node.predicates) {
                    let it = el.value_mut();
                    v.visit_where_predicate_mut(it);
                }
            }
            pub fn visit_where_predicate_mut<V>(v: &mut V, node: &mut ::syntax::WherePredicate) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::WherePredicate::Lifetime(_binding_0) => {
                        v.visit_predicate_lifetime_mut(_binding_0);
                    }
                    ::syntax::WherePredicate::Type(_binding_0) => {
                        v.visit_predicate_type_mut(_binding_0);
                    }
                }
            }
        }

        pub mod clone
        {
            use ::
            {
                *,
            };
            /*
            */
             
            impl Clone for ::syntax::Abi {
                fn clone(&self) -> Self {
                    ::syntax::Abi {
                        extern_token: self.extern_token.clone(),
                        name: self.name.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::AngleBracketedGenericArguments {
                fn clone(&self) -> Self {
                    ::syntax::AngleBracketedGenericArguments {
                        colon2_token: self.colon2_token.clone(),
                        lt_token: self.lt_token.clone(),
                        args: self.args.clone(),
                        gt_token: self.gt_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Arm {
                fn clone(&self) -> Self {
                    ::syntax::Arm {
                        attrs: self.attrs.clone(),
                        pat: self.pat.clone(),
                        guard: self.guard.clone(),
                        fat_arrow_token: self.fat_arrow_token.clone(),
                        body: self.body.clone(),
                        comma: self.comma.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::AssocConst {
                fn clone(&self) -> Self {
                    ::syntax::AssocConst {
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        value: self.value.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::AssocType {
                fn clone(&self) -> Self {
                    ::syntax::AssocType {
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::AttrStyle {}
             
            impl Clone for ::syntax::AttrStyle {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::Attribute {
                fn clone(&self) -> Self {
                    ::syntax::Attribute {
                        pound_token: self.pound_token.clone(),
                        style: self.style.clone(),
                        bracket_token: self.bracket_token.clone(),
                        meta: self.meta.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::BareFnArg {
                fn clone(&self) -> Self {
                    ::syntax::BareFnArg {
                        attrs: self.attrs.clone(),
                        name: self.name.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::BareVariadic {
                fn clone(&self) -> Self {
                    ::syntax::BareVariadic {
                        attrs: self.attrs.clone(),
                        name: self.name.clone(),
                        dots: self.dots.clone(),
                        comma: self.comma.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::BinOp {}
             
            impl Clone for ::syntax::BinOp {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::Block {
                fn clone(&self) -> Self {
                    ::syntax::Block {
                        brace_token: self.brace_token.clone(),
                        stmts: self.stmts.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::BoundLifetimes {
                fn clone(&self) -> Self {
                    ::syntax::BoundLifetimes {
                        for_token: self.for_token.clone(),
                        lt_token: self.lt_token.clone(),
                        lifetimes: self.lifetimes.clone(),
                        gt_token: self.gt_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::CapturedParam {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::CapturedParam::Lifetime(v0) => {
                            ::syntax::CapturedParam::Lifetime(v0.clone())
                        }
                        ::syntax::CapturedParam::Ident(v0) => ::syntax::CapturedParam::Ident(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ConstParam {
                fn clone(&self) -> Self {
                    ::syntax::ConstParam {
                        attrs: self.attrs.clone(),
                        const_token: self.const_token.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        eq_token: self.eq_token.clone(),
                        default: self.default.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Constraint {
                fn clone(&self) -> Self {
                    ::syntax::Constraint {
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Data {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Data::Struct(v0) => ::syntax::Data::Struct(v0.clone()),
                        ::syntax::Data::Enum(v0) => ::syntax::Data::Enum(v0.clone()),
                        ::syntax::Data::Union(v0) => ::syntax::Data::Union(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::DataEnum {
                fn clone(&self) -> Self {
                    ::syntax::DataEnum {
                        enum_token: self.enum_token.clone(),
                        brace_token: self.brace_token.clone(),
                        variants: self.variants.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::DataStruct {
                fn clone(&self) -> Self {
                    ::syntax::DataStruct {
                        struct_token: self.struct_token.clone(),
                        fields: self.fields.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::DataUnion {
                fn clone(&self) -> Self {
                    ::syntax::DataUnion {
                        union_token: self.union_token.clone(),
                        fields: self.fields.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::DeriveInput {
                fn clone(&self) -> Self {
                    ::syntax::DeriveInput {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        data: self.data.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Expr {
                fn clone(&self) -> Self {
                    match self {
                                        ::syntax::Expr::Array(v0) => ::syntax::Expr::Array(v0.clone()),
                                        ::syntax::Expr::Assign(v0) => ::syntax::Expr::Assign(v0.clone()),
                                        ::syntax::Expr::Async(v0) => ::syntax::Expr::Async(v0.clone()),
                                        ::syntax::Expr::Await(v0) => ::syntax::Expr::Await(v0.clone()),
                        ::syntax::Expr::Binary(v0) => ::syntax::Expr::Binary(v0.clone()),
                                        ::syntax::Expr::Block(v0) => ::syntax::Expr::Block(v0.clone()),
                                        ::syntax::Expr::Break(v0) => ::syntax::Expr::Break(v0.clone()),
                        ::syntax::Expr::Call(v0) => ::syntax::Expr::Call(v0.clone()),
                        ::syntax::Expr::Cast(v0) => ::syntax::Expr::Cast(v0.clone()),
                                        ::syntax::Expr::Closure(v0) => ::syntax::Expr::Closure(v0.clone()),
                                        ::syntax::Expr::Const(v0) => ::syntax::Expr::Const(v0.clone()),
                                        ::syntax::Expr::Continue(v0) => ::syntax::Expr::Continue(v0.clone()),
                        ::syntax::Expr::Field(v0) => ::syntax::Expr::Field(v0.clone()),
                                        ::syntax::Expr::ForLoop(v0) => ::syntax::Expr::ForLoop(v0.clone()),
                        ::syntax::Expr::Group(v0) => ::syntax::Expr::Group(v0.clone()),
                                        ::syntax::Expr::If(v0) => ::syntax::Expr::If(v0.clone()),
                        ::syntax::Expr::Index(v0) => ::syntax::Expr::Index(v0.clone()),
                                        ::syntax::Expr::Infer(v0) => ::syntax::Expr::Infer(v0.clone()),
                                        ::syntax::Expr::Let(v0) => ::syntax::Expr::Let(v0.clone()),
                        ::syntax::Expr::Lit(v0) => ::syntax::Expr::Lit(v0.clone()),
                                        ::syntax::Expr::Loop(v0) => ::syntax::Expr::Loop(v0.clone()),
                        ::syntax::Expr::Macro(v0) => ::syntax::Expr::Macro(v0.clone()),
                                        ::syntax::Expr::Match(v0) => ::syntax::Expr::Match(v0.clone()),
                        ::syntax::Expr::MethodCall(v0) => ::syntax::Expr::MethodCall(v0.clone()),
                        ::syntax::Expr::Paren(v0) => ::syntax::Expr::Paren(v0.clone()),
                        ::syntax::Expr::Path(v0) => ::syntax::Expr::Path(v0.clone()),
                                        ::syntax::Expr::Range(v0) => ::syntax::Expr::Range(v0.clone()),
                                        ::syntax::Expr::RawAddr(v0) => ::syntax::Expr::RawAddr(v0.clone()),
                        ::syntax::Expr::Reference(v0) => ::syntax::Expr::Reference(v0.clone()),
                                        ::syntax::Expr::Repeat(v0) => ::syntax::Expr::Repeat(v0.clone()),
                                        ::syntax::Expr::Return(v0) => ::syntax::Expr::Return(v0.clone()),
                        ::syntax::Expr::Struct(v0) => ::syntax::Expr::Struct(v0.clone()),
                                        ::syntax::Expr::Try(v0) => ::syntax::Expr::Try(v0.clone()),
                                        ::syntax::Expr::TryBlock(v0) => ::syntax::Expr::TryBlock(v0.clone()),
                        ::syntax::Expr::Tuple(v0) => ::syntax::Expr::Tuple(v0.clone()),
                        ::syntax::Expr::Unary(v0) => ::syntax::Expr::Unary(v0.clone()),
                                        ::syntax::Expr::Unsafe(v0) => ::syntax::Expr::Unsafe(v0.clone()),
                        ::syntax::Expr::Verbatim(v0) => ::syntax::Expr::Verbatim(v0.clone()),
                        ::syntax::Expr::While(v0) => ::syntax::Expr::While(v0.clone()),
                        ::syntax::Expr::Yield(v0) => ::syntax::Expr::Yield(v0.clone()),
                                        
                    }
                }
            }
             
            impl Clone for ::syntax::ExprArray {
                fn clone(&self) -> Self {
                    ::syntax::ExprArray {
                        attrs: self.attrs.clone(),
                        bracket_token: self.bracket_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprAssign {
                fn clone(&self) -> Self {
                    ::syntax::ExprAssign {
                        attrs: self.attrs.clone(),
                        left: self.left.clone(),
                        eq_token: self.eq_token.clone(),
                        right: self.right.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprAsync {
                fn clone(&self) -> Self {
                    ::syntax::ExprAsync {
                        attrs: self.attrs.clone(),
                        async_token: self.async_token.clone(),
                        capture: self.capture.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprAwait {
                fn clone(&self) -> Self {
                    ::syntax::ExprAwait {
                        attrs: self.attrs.clone(),
                        base: self.base.clone(),
                        dot_token: self.dot_token.clone(),
                        await_token: self.await_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprBinary {
                fn clone(&self) -> Self {
                    ::syntax::ExprBinary {
                        attrs: self.attrs.clone(),
                        left: self.left.clone(),
                        op: self.op.clone(),
                        right: self.right.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprBlock {
                fn clone(&self) -> Self {
                    ::syntax::ExprBlock {
                        attrs: self.attrs.clone(),
                        label: self.label.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprBreak {
                fn clone(&self) -> Self {
                    ::syntax::ExprBreak {
                        attrs: self.attrs.clone(),
                        break_token: self.break_token.clone(),
                        label: self.label.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprCall {
                fn clone(&self) -> Self {
                    ::syntax::ExprCall {
                        attrs: self.attrs.clone(),
                        func: self.func.clone(),
                        paren_token: self.paren_token.clone(),
                        args: self.args.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprCast {
                fn clone(&self) -> Self {
                    ::syntax::ExprCast {
                        attrs: self.attrs.clone(),
                        expr: self.expr.clone(),
                        as_token: self.as_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprClosure {
                fn clone(&self) -> Self {
                    ::syntax::ExprClosure {
                        attrs: self.attrs.clone(),
                        lifetimes: self.lifetimes.clone(),
                        constness: self.constness.clone(),
                        movability: self.movability.clone(),
                        asyncness: self.asyncness.clone(),
                        capture: self.capture.clone(),
                        or1_token: self.or1_token.clone(),
                        inputs: self.inputs.clone(),
                        or2_token: self.or2_token.clone(),
                        output: self.output.clone(),
                        body: self.body.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprConst {
                fn clone(&self) -> Self {
                    ::syntax::ExprConst {
                        attrs: self.attrs.clone(),
                        const_token: self.const_token.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprContinue {
                fn clone(&self) -> Self {
                    ::syntax::ExprContinue {
                        attrs: self.attrs.clone(),
                        continue_token: self.continue_token.clone(),
                        label: self.label.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprField {
                fn clone(&self) -> Self {
                    ::syntax::ExprField {
                        attrs: self.attrs.clone(),
                        base: self.base.clone(),
                        dot_token: self.dot_token.clone(),
                        member: self.member.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprForLoop {
                fn clone(&self) -> Self {
                    ::syntax::ExprForLoop {
                        attrs: self.attrs.clone(),
                        label: self.label.clone(),
                        for_token: self.for_token.clone(),
                        pat: self.pat.clone(),
                        in_token: self.in_token.clone(),
                        expr: self.expr.clone(),
                        body: self.body.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprGroup {
                fn clone(&self) -> Self {
                    ::syntax::ExprGroup {
                        attrs: self.attrs.clone(),
                        group_token: self.group_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprIf {
                fn clone(&self) -> Self {
                    ::syntax::ExprIf {
                        attrs: self.attrs.clone(),
                        if_token: self.if_token.clone(),
                        cond: self.cond.clone(),
                        then_branch: self.then_branch.clone(),
                        else_branch: self.else_branch.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprIndex {
                fn clone(&self) -> Self {
                    ::syntax::ExprIndex {
                        attrs: self.attrs.clone(),
                        expr: self.expr.clone(),
                        bracket_token: self.bracket_token.clone(),
                        index: self.index.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprInfer {
                fn clone(&self) -> Self {
                    ::syntax::ExprInfer {
                        attrs: self.attrs.clone(),
                        underscore_token: self.underscore_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprLet {
                fn clone(&self) -> Self {
                    ::syntax::ExprLet {
                        attrs: self.attrs.clone(),
                        let_token: self.let_token.clone(),
                        pat: self.pat.clone(),
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprLit {
                fn clone(&self) -> Self {
                    ::syntax::ExprLit {
                        attrs: self.attrs.clone(),
                        lit: self.lit.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprLoop {
                fn clone(&self) -> Self {
                    ::syntax::ExprLoop {
                        attrs: self.attrs.clone(),
                        label: self.label.clone(),
                        loop_token: self.loop_token.clone(),
                        body: self.body.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprMacro {
                fn clone(&self) -> Self {
                    ::syntax::ExprMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprMatch {
                fn clone(&self) -> Self {
                    ::syntax::ExprMatch {
                        attrs: self.attrs.clone(),
                        match_token: self.match_token.clone(),
                        expr: self.expr.clone(),
                        brace_token: self.brace_token.clone(),
                        arms: self.arms.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprMethodCall {
                fn clone(&self) -> Self {
                    ::syntax::ExprMethodCall {
                        attrs: self.attrs.clone(),
                        receiver: self.receiver.clone(),
                        dot_token: self.dot_token.clone(),
                        method: self.method.clone(),
                        turbofish: self.turbofish.clone(),
                        paren_token: self.paren_token.clone(),
                        args: self.args.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprParen {
                fn clone(&self) -> Self {
                    ::syntax::ExprParen {
                        attrs: self.attrs.clone(),
                        paren_token: self.paren_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprPath {
                fn clone(&self) -> Self {
                    ::syntax::ExprPath {
                        attrs: self.attrs.clone(),
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprRange {
                fn clone(&self) -> Self {
                    ::syntax::ExprRange {
                        attrs: self.attrs.clone(),
                        start: self.start.clone(),
                        limits: self.limits.clone(),
                        end: self.end.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprRawAddr {
                fn clone(&self) -> Self {
                    ::syntax::ExprRawAddr {
                        attrs: self.attrs.clone(),
                        and_token: self.and_token.clone(),
                        raw: self.raw.clone(),
                        mutability: self.mutability.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprReference {
                fn clone(&self) -> Self {
                    ::syntax::ExprReference {
                        attrs: self.attrs.clone(),
                        and_token: self.and_token.clone(),
                        mutability: self.mutability.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprRepeat {
                fn clone(&self) -> Self {
                    ::syntax::ExprRepeat {
                        attrs: self.attrs.clone(),
                        bracket_token: self.bracket_token.clone(),
                        expr: self.expr.clone(),
                        semi_token: self.semi_token.clone(),
                        len: self.len.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprReturn {
                fn clone(&self) -> Self {
                    ::syntax::ExprReturn {
                        attrs: self.attrs.clone(),
                        return_token: self.return_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprStruct {
                fn clone(&self) -> Self {
                    ::syntax::ExprStruct {
                        attrs: self.attrs.clone(),
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                        brace_token: self.brace_token.clone(),
                        fields: self.fields.clone(),
                        dot2_token: self.dot2_token.clone(),
                        rest: self.rest.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprTry {
                fn clone(&self) -> Self {
                    ::syntax::ExprTry {
                        attrs: self.attrs.clone(),
                        expr: self.expr.clone(),
                        question_token: self.question_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprTryBlock {
                fn clone(&self) -> Self {
                    ::syntax::ExprTryBlock {
                        attrs: self.attrs.clone(),
                        try_token: self.try_token.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprTuple {
                fn clone(&self) -> Self {
                    ::syntax::ExprTuple {
                        attrs: self.attrs.clone(),
                        paren_token: self.paren_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprUnary {
                fn clone(&self) -> Self {
                    ::syntax::ExprUnary {
                        attrs: self.attrs.clone(),
                        op: self.op.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprUnsafe {
                fn clone(&self) -> Self {
                    ::syntax::ExprUnsafe {
                        attrs: self.attrs.clone(),
                        unsafe_token: self.unsafe_token.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprWhile {
                fn clone(&self) -> Self {
                    ::syntax::ExprWhile {
                        attrs: self.attrs.clone(),
                        label: self.label.clone(),
                        while_token: self.while_token.clone(),
                        cond: self.cond.clone(),
                        body: self.body.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprYield {
                fn clone(&self) -> Self {
                    ::syntax::ExprYield {
                        attrs: self.attrs.clone(),
                        yield_token: self.yield_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Field {
                fn clone(&self) -> Self {
                    ::syntax::Field {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        mutability: self.mutability.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::FieldMutability {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::FieldMutability::None => ::syntax::FieldMutability::None,
                    }
                }
            }
             
            impl Clone for ::syntax::FieldPat {
                fn clone(&self) -> Self {
                    ::syntax::FieldPat {
                        attrs: self.attrs.clone(),
                        member: self.member.clone(),
                        colon_token: self.colon_token.clone(),
                        pat: self.pat.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::FieldValue {
                fn clone(&self) -> Self {
                    ::syntax::FieldValue {
                        attrs: self.attrs.clone(),
                        member: self.member.clone(),
                        colon_token: self.colon_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Fields {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Fields::Named(v0) => ::syntax::Fields::Named(v0.clone()),
                        ::syntax::Fields::Unnamed(v0) => ::syntax::Fields::Unnamed(v0.clone()),
                        ::syntax::Fields::Unit => ::syntax::Fields::Unit,
                    }
                }
            }
             
            impl Clone for ::syntax::FieldsNamed {
                fn clone(&self) -> Self {
                    ::syntax::FieldsNamed {
                        brace_token: self.brace_token.clone(),
                        named: self.named.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::FieldsUnnamed {
                fn clone(&self) -> Self {
                    ::syntax::FieldsUnnamed {
                        paren_token: self.paren_token.clone(),
                        unnamed: self.unnamed.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::File {
                fn clone(&self) -> Self {
                    ::syntax::File {
                        shebang: self.shebang.clone(),
                        attrs: self.attrs.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::FnArg {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::FnArg::Receiver(v0) => ::syntax::FnArg::Receiver(v0.clone()),
                        ::syntax::FnArg::Typed(v0) => ::syntax::FnArg::Typed(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItem {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::ForeignItem::Fn(v0) => ::syntax::ForeignItem::Fn(v0.clone()),
                        ::syntax::ForeignItem::Static(v0) => ::syntax::ForeignItem::Static(v0.clone()),
                        ::syntax::ForeignItem::Type(v0) => ::syntax::ForeignItem::Type(v0.clone()),
                        ::syntax::ForeignItem::Macro(v0) => ::syntax::ForeignItem::Macro(v0.clone()),
                        ::syntax::ForeignItem::Verbatim(v0) => ::syntax::ForeignItem::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItemFn {
                fn clone(&self) -> Self {
                    ::syntax::ForeignItemFn {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        sig: self.sig.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItemMacro {
                fn clone(&self) -> Self {
                    ::syntax::ForeignItemMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItemStatic {
                fn clone(&self) -> Self {
                    ::syntax::ForeignItemStatic {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        static_token: self.static_token.clone(),
                        mutability: self.mutability.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItemType {
                fn clone(&self) -> Self {
                    ::syntax::ForeignItemType {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        type_token: self.type_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::GenericArgument {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::GenericArgument::Lifetime(v0) => {
                            ::syntax::GenericArgument::Lifetime(v0.clone())
                        }
                        ::syntax::GenericArgument::Type(v0) => ::syntax::GenericArgument::Type(v0.clone()),
                        ::syntax::GenericArgument::Const(v0) => {
                            ::syntax::GenericArgument::Const(v0.clone())
                        }
                        ::syntax::GenericArgument::AssocType(v0) => {
                            ::syntax::GenericArgument::AssocType(v0.clone())
                        }
                        ::syntax::GenericArgument::AssocConst(v0) => {
                            ::syntax::GenericArgument::AssocConst(v0.clone())
                        }
                        ::syntax::GenericArgument::Constraint(v0) => {
                            ::syntax::GenericArgument::Constraint(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::GenericParam {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::GenericParam::Lifetime(v0) => {
                            ::syntax::GenericParam::Lifetime(v0.clone())
                        }
                        ::syntax::GenericParam::Type(v0) => ::syntax::GenericParam::Type(v0.clone()),
                        ::syntax::GenericParam::Const(v0) => ::syntax::GenericParam::Const(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::Generics {
                fn clone(&self) -> Self {
                    ::syntax::Generics {
                        lt_token: self.lt_token.clone(),
                        params: self.params.clone(),
                        gt_token: self.gt_token.clone(),
                        where_clause: self.where_clause.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItem {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::ImplItem::Const(v0) => ::syntax::ImplItem::Const(v0.clone()),
                        ::syntax::ImplItem::Fn(v0) => ::syntax::ImplItem::Fn(v0.clone()),
                        ::syntax::ImplItem::Type(v0) => ::syntax::ImplItem::Type(v0.clone()),
                        ::syntax::ImplItem::Macro(v0) => ::syntax::ImplItem::Macro(v0.clone()),
                        ::syntax::ImplItem::Verbatim(v0) => ::syntax::ImplItem::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItemConst {
                fn clone(&self) -> Self {
                    ::syntax::ImplItemConst {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        defaultness: self.defaultness.clone(),
                        const_token: self.const_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItemFn {
                fn clone(&self) -> Self {
                    ::syntax::ImplItemFn {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        defaultness: self.defaultness.clone(),
                        sig: self.sig.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItemMacro {
                fn clone(&self) -> Self {
                    ::syntax::ImplItemMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItemType {
                fn clone(&self) -> Self {
                    ::syntax::ImplItemType {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        defaultness: self.defaultness.clone(),
                        type_token: self.type_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        ty: self.ty.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplRestriction {
                fn clone(&self) -> Self {
                    match *self {}
                }
            }
             
            impl Clone for ::syntax::Index {
                fn clone(&self) -> Self {
                    ::syntax::Index {
                        index: self.index.clone(),
                        span: self.span.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Item {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Item::Const(v0) => ::syntax::Item::Const(v0.clone()),
                        ::syntax::Item::Enum(v0) => ::syntax::Item::Enum(v0.clone()),
                        ::syntax::Item::ExternCrate(v0) => ::syntax::Item::ExternCrate(v0.clone()),
                        ::syntax::Item::Fn(v0) => ::syntax::Item::Fn(v0.clone()),
                        ::syntax::Item::ForeignMod(v0) => ::syntax::Item::ForeignMod(v0.clone()),
                        ::syntax::Item::Impl(v0) => ::syntax::Item::Impl(v0.clone()),
                        ::syntax::Item::Macro(v0) => ::syntax::Item::Macro(v0.clone()),
                        ::syntax::Item::Mod(v0) => ::syntax::Item::Mod(v0.clone()),
                        ::syntax::Item::Static(v0) => ::syntax::Item::Static(v0.clone()),
                        ::syntax::Item::Struct(v0) => ::syntax::Item::Struct(v0.clone()),
                        ::syntax::Item::Trait(v0) => ::syntax::Item::Trait(v0.clone()),
                        ::syntax::Item::TraitAlias(v0) => ::syntax::Item::TraitAlias(v0.clone()),
                        ::syntax::Item::Type(v0) => ::syntax::Item::Type(v0.clone()),
                        ::syntax::Item::Union(v0) => ::syntax::Item::Union(v0.clone()),
                        ::syntax::Item::Use(v0) => ::syntax::Item::Use(v0.clone()),
                        ::syntax::Item::Verbatim(v0) => ::syntax::Item::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemConst {
                fn clone(&self) -> Self {
                    ::syntax::ItemConst {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        const_token: self.const_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemEnum {
                fn clone(&self) -> Self {
                    ::syntax::ItemEnum {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        enum_token: self.enum_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        brace_token: self.brace_token.clone(),
                        variants: self.variants.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemExternCrate {
                fn clone(&self) -> Self {
                    ::syntax::ItemExternCrate {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        extern_token: self.extern_token.clone(),
                        crate_token: self.crate_token.clone(),
                        ident: self.ident.clone(),
                        rename: self.rename.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemFn {
                fn clone(&self) -> Self {
                    ::syntax::ItemFn {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        sig: self.sig.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemForeignMod {
                fn clone(&self) -> Self {
                    ::syntax::ItemForeignMod {
                        attrs: self.attrs.clone(),
                        unsafety: self.unsafety.clone(),
                        abi: self.abi.clone(),
                        brace_token: self.brace_token.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemImpl {
                fn clone(&self) -> Self {
                    ::syntax::ItemImpl {
                        attrs: self.attrs.clone(),
                        defaultness: self.defaultness.clone(),
                        unsafety: self.unsafety.clone(),
                        impl_token: self.impl_token.clone(),
                        generics: self.generics.clone(),
                        trait_: self.trait_.clone(),
                        self_ty: self.self_ty.clone(),
                        brace_token: self.brace_token.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemMacro {
                fn clone(&self) -> Self {
                    ::syntax::ItemMacro {
                        attrs: self.attrs.clone(),
                        ident: self.ident.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemMod {
                fn clone(&self) -> Self {
                    ::syntax::ItemMod {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        unsafety: self.unsafety.clone(),
                        mod_token: self.mod_token.clone(),
                        ident: self.ident.clone(),
                        content: self.content.clone(),
                        semi: self.semi.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemStatic {
                fn clone(&self) -> Self {
                    ::syntax::ItemStatic {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        static_token: self.static_token.clone(),
                        mutability: self.mutability.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemStruct {
                fn clone(&self) -> Self {
                    ::syntax::ItemStruct {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        struct_token: self.struct_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        fields: self.fields.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemTrait {
                fn clone(&self) -> Self {
                    ::syntax::ItemTrait {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        unsafety: self.unsafety.clone(),
                        auto_token: self.auto_token.clone(),
                        restriction: self.restriction.clone(),
                        trait_token: self.trait_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        supertraits: self.supertraits.clone(),
                        brace_token: self.brace_token.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemTraitAlias {
                fn clone(&self) -> Self {
                    ::syntax::ItemTraitAlias {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        trait_token: self.trait_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        bounds: self.bounds.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemType {
                fn clone(&self) -> Self {
                    ::syntax::ItemType {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        type_token: self.type_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        ty: self.ty.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemUnion {
                fn clone(&self) -> Self {
                    ::syntax::ItemUnion {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        union_token: self.union_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        fields: self.fields.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemUse {
                fn clone(&self) -> Self {
                    ::syntax::ItemUse {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        use_token: self.use_token.clone(),
                        leading_colon: self.leading_colon.clone(),
                        tree: self.tree.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Label {
                fn clone(&self) -> Self {
                    ::syntax::Label {
                        name: self.name.clone(),
                        colon_token: self.colon_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::LifetimeParam {
                fn clone(&self) -> Self {
                    ::syntax::LifetimeParam {
                        attrs: self.attrs.clone(),
                        lifetime: self.lifetime.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Lit {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Lit::Str(v0) => ::syntax::Lit::Str(v0.clone()),
                        ::syntax::Lit::ByteStr(v0) => ::syntax::Lit::ByteStr(v0.clone()),
                        ::syntax::Lit::CStr(v0) => ::syntax::Lit::CStr(v0.clone()),
                        ::syntax::Lit::Byte(v0) => ::syntax::Lit::Byte(v0.clone()),
                        ::syntax::Lit::Char(v0) => ::syntax::Lit::Char(v0.clone()),
                        ::syntax::Lit::Int(v0) => ::syntax::Lit::Int(v0.clone()),
                        ::syntax::Lit::Float(v0) => ::syntax::Lit::Float(v0.clone()),
                        ::syntax::Lit::Bool(v0) => ::syntax::Lit::Bool(v0.clone()),
                        ::syntax::Lit::Verbatim(v0) => ::syntax::Lit::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::LitBool {
                fn clone(&self) -> Self {
                    ::syntax::LitBool {
                        value: self.value.clone(),
                        span: self.span.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Local {
                fn clone(&self) -> Self {
                    ::syntax::Local {
                        attrs: self.attrs.clone(),
                        let_token: self.let_token.clone(),
                        pat: self.pat.clone(),
                        init: self.init.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::LocalInit {
                fn clone(&self) -> Self {
                    ::syntax::LocalInit {
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                        diverge: self.diverge.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Macro {
                fn clone(&self) -> Self {
                    ::syntax::Macro {
                        path: self.path.clone(),
                        bang_token: self.bang_token.clone(),
                        delimiter: self.delimiter.clone(),
                        tokens: self.tokens.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::MacroDelimiter {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::MacroDelimiter::Paren(v0) => ::syntax::MacroDelimiter::Paren(v0.clone()),
                        ::syntax::MacroDelimiter::Brace(v0) => ::syntax::MacroDelimiter::Brace(v0.clone()),
                        ::syntax::MacroDelimiter::Bracket(v0) => {
                            ::syntax::MacroDelimiter::Bracket(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::Member {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Member::Named(v0) => ::syntax::Member::Named(v0.clone()),
                        ::syntax::Member::Unnamed(v0) => ::syntax::Member::Unnamed(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::Meta {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Meta::Path(v0) => ::syntax::Meta::Path(v0.clone()),
                        ::syntax::Meta::List(v0) => ::syntax::Meta::List(v0.clone()),
                        ::syntax::Meta::NameValue(v0) => ::syntax::Meta::NameValue(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::MetaList {
                fn clone(&self) -> Self {
                    ::syntax::MetaList {
                        path: self.path.clone(),
                        delimiter: self.delimiter.clone(),
                        tokens: self.tokens.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::MetaNameValue {
                fn clone(&self) -> Self {
                    ::syntax::MetaNameValue {
                        path: self.path.clone(),
                        eq_token: self.eq_token.clone(),
                        value: self.value.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ParenthesizedGenericArguments {
                fn clone(&self) -> Self {
                    ::syntax::ParenthesizedGenericArguments {
                        paren_token: self.paren_token.clone(),
                        inputs: self.inputs.clone(),
                        output: self.output.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Pat {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Pat::Const(v0) => ::syntax::Pat::Const(v0.clone()),
                        ::syntax::Pat::Ident(v0) => ::syntax::Pat::Ident(v0.clone()),
                        ::syntax::Pat::Lit(v0) => ::syntax::Pat::Lit(v0.clone()),
                        ::syntax::Pat::Macro(v0) => ::syntax::Pat::Macro(v0.clone()),
                        ::syntax::Pat::Or(v0) => ::syntax::Pat::Or(v0.clone()),
                        ::syntax::Pat::Paren(v0) => ::syntax::Pat::Paren(v0.clone()),
                        ::syntax::Pat::Path(v0) => ::syntax::Pat::Path(v0.clone()),
                        ::syntax::Pat::Range(v0) => ::syntax::Pat::Range(v0.clone()),
                        ::syntax::Pat::Reference(v0) => ::syntax::Pat::Reference(v0.clone()),
                        ::syntax::Pat::Rest(v0) => ::syntax::Pat::Rest(v0.clone()),
                        ::syntax::Pat::Slice(v0) => ::syntax::Pat::Slice(v0.clone()),
                        ::syntax::Pat::Struct(v0) => ::syntax::Pat::Struct(v0.clone()),
                        ::syntax::Pat::Tuple(v0) => ::syntax::Pat::Tuple(v0.clone()),
                        ::syntax::Pat::TupleStruct(v0) => ::syntax::Pat::TupleStruct(v0.clone()),
                        ::syntax::Pat::Type(v0) => ::syntax::Pat::Type(v0.clone()),
                        ::syntax::Pat::Verbatim(v0) => ::syntax::Pat::Verbatim(v0.clone()),
                        ::syntax::Pat::Wild(v0) => ::syntax::Pat::Wild(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::PatIdent {
                fn clone(&self) -> Self {
                    ::syntax::PatIdent {
                        attrs: self.attrs.clone(),
                        by_ref: self.by_ref.clone(),
                        mutability: self.mutability.clone(),
                        ident: self.ident.clone(),
                        subpat: self.subpat.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatOr {
                fn clone(&self) -> Self {
                    ::syntax::PatOr {
                        attrs: self.attrs.clone(),
                        leading_vert: self.leading_vert.clone(),
                        cases: self.cases.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatParen {
                fn clone(&self) -> Self {
                    ::syntax::PatParen {
                        attrs: self.attrs.clone(),
                        paren_token: self.paren_token.clone(),
                        pat: self.pat.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatReference {
                fn clone(&self) -> Self {
                    ::syntax::PatReference {
                        attrs: self.attrs.clone(),
                        and_token: self.and_token.clone(),
                        mutability: self.mutability.clone(),
                        pat: self.pat.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatRest {
                fn clone(&self) -> Self {
                    ::syntax::PatRest {
                        attrs: self.attrs.clone(),
                        dot2_token: self.dot2_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatSlice {
                fn clone(&self) -> Self {
                    ::syntax::PatSlice {
                        attrs: self.attrs.clone(),
                        bracket_token: self.bracket_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatStruct {
                fn clone(&self) -> Self {
                    ::syntax::PatStruct {
                        attrs: self.attrs.clone(),
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                        brace_token: self.brace_token.clone(),
                        fields: self.fields.clone(),
                        rest: self.rest.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatTuple {
                fn clone(&self) -> Self {
                    ::syntax::PatTuple {
                        attrs: self.attrs.clone(),
                        paren_token: self.paren_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatTupleStruct {
                fn clone(&self) -> Self {
                    ::syntax::PatTupleStruct {
                        attrs: self.attrs.clone(),
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                        paren_token: self.paren_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatType {
                fn clone(&self) -> Self {
                    ::syntax::PatType {
                        attrs: self.attrs.clone(),
                        pat: self.pat.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatWild {
                fn clone(&self) -> Self {
                    ::syntax::PatWild {
                        attrs: self.attrs.clone(),
                        underscore_token: self.underscore_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Path {
                fn clone(&self) -> Self {
                    ::syntax::Path {
                        leading_colon: self.leading_colon.clone(),
                        segments: self.segments.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PathArguments {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::PathArguments::None => ::syntax::PathArguments::None,
                        ::syntax::PathArguments::AngleBracketed(v0) => {
                            ::syntax::PathArguments::AngleBracketed(v0.clone())
                        }
                        ::syntax::PathArguments::Parenthesized(v0) => {
                            ::syntax::PathArguments::Parenthesized(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::PathSegment {
                fn clone(&self) -> Self {
                    ::syntax::PathSegment {
                        ident: self.ident.clone(),
                        arguments: self.arguments.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PointerMutability {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::PointerMutability::Const(v0) => {
                            ::syntax::PointerMutability::Const(v0.clone())
                        }
                        ::syntax::PointerMutability::Mut(v0) => {
                            ::syntax::PointerMutability::Mut(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::PreciseCapture {
                fn clone(&self) -> Self {
                    ::syntax::PreciseCapture {
                        use_token: self.use_token.clone(),
                        lt_token: self.lt_token.clone(),
                        params: self.params.clone(),
                        gt_token: self.gt_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PredicateLifetime {
                fn clone(&self) -> Self {
                    ::syntax::PredicateLifetime {
                        lifetime: self.lifetime.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PredicateType {
                fn clone(&self) -> Self {
                    ::syntax::PredicateType {
                        lifetimes: self.lifetimes.clone(),
                        bounded_ty: self.bounded_ty.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::QSelf {
                fn clone(&self) -> Self {
                    ::syntax::QSelf {
                        lt_token: self.lt_token.clone(),
                        ty: self.ty.clone(),
                        position: self.position.clone(),
                        as_token: self.as_token.clone(),
                        gt_token: self.gt_token.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::RangeLimits {}
             
            impl Clone for ::syntax::RangeLimits {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::Receiver {
                fn clone(&self) -> Self {
                    ::syntax::Receiver {
                        attrs: self.attrs.clone(),
                        reference: self.reference.clone(),
                        mutability: self.mutability.clone(),
                        self_token: self.self_token.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ReturnType {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::ReturnType::Default => ::syntax::ReturnType::Default,
                        ::syntax::ReturnType::Type(v0, v1) => {
                            ::syntax::ReturnType::Type(v0.clone(), v1.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::Signature {
                fn clone(&self) -> Self {
                    ::syntax::Signature {
                        constness: self.constness.clone(),
                        asyncness: self.asyncness.clone(),
                        unsafety: self.unsafety.clone(),
                        abi: self.abi.clone(),
                        fn_token: self.fn_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        paren_token: self.paren_token.clone(),
                        inputs: self.inputs.clone(),
                        variadic: self.variadic.clone(),
                        output: self.output.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::StaticMutability {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::StaticMutability::Mut(v0) => ::syntax::StaticMutability::Mut(v0.clone()),
                        ::syntax::StaticMutability::None => ::syntax::StaticMutability::None,
                    }
                }
            }
             
            impl Clone for ::syntax::Stmt {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Stmt::Local(v0) => ::syntax::Stmt::Local(v0.clone()),
                        ::syntax::Stmt::Item(v0) => ::syntax::Stmt::Item(v0.clone()),
                        ::syntax::Stmt::Expr(v0, v1) => ::syntax::Stmt::Expr(v0.clone(), v1.clone()),
                        ::syntax::Stmt::Macro(v0) => ::syntax::Stmt::Macro(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::StmtMacro {
                fn clone(&self) -> Self {
                    ::syntax::StmtMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitBound {
                fn clone(&self) -> Self {
                    ::syntax::TraitBound {
                        paren_token: self.paren_token.clone(),
                        modifier: self.modifier.clone(),
                        lifetimes: self.lifetimes.clone(),
                        path: self.path.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::TraitBoundModifier {}
             
            impl Clone for ::syntax::TraitBoundModifier {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::TraitItem {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::TraitItem::Const(v0) => ::syntax::TraitItem::Const(v0.clone()),
                        ::syntax::TraitItem::Fn(v0) => ::syntax::TraitItem::Fn(v0.clone()),
                        ::syntax::TraitItem::Type(v0) => ::syntax::TraitItem::Type(v0.clone()),
                        ::syntax::TraitItem::Macro(v0) => ::syntax::TraitItem::Macro(v0.clone()),
                        ::syntax::TraitItem::Verbatim(v0) => ::syntax::TraitItem::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitItemConst {
                fn clone(&self) -> Self {
                    ::syntax::TraitItemConst {
                        attrs: self.attrs.clone(),
                        const_token: self.const_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        default: self.default.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitItemFn {
                fn clone(&self) -> Self {
                    ::syntax::TraitItemFn {
                        attrs: self.attrs.clone(),
                        sig: self.sig.clone(),
                        default: self.default.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitItemMacro {
                fn clone(&self) -> Self {
                    ::syntax::TraitItemMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitItemType {
                fn clone(&self) -> Self {
                    ::syntax::TraitItemType {
                        attrs: self.attrs.clone(),
                        type_token: self.type_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                        default: self.default.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Type {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Type::Array(v0) => ::syntax::Type::Array(v0.clone()),
                        ::syntax::Type::BareFn(v0) => ::syntax::Type::BareFn(v0.clone()),
                        ::syntax::Type::Group(v0) => ::syntax::Type::Group(v0.clone()),
                        ::syntax::Type::ImplTrait(v0) => ::syntax::Type::ImplTrait(v0.clone()),
                        ::syntax::Type::Infer(v0) => ::syntax::Type::Infer(v0.clone()),
                        ::syntax::Type::Macro(v0) => ::syntax::Type::Macro(v0.clone()),
                        ::syntax::Type::Never(v0) => ::syntax::Type::Never(v0.clone()),
                        ::syntax::Type::Paren(v0) => ::syntax::Type::Paren(v0.clone()),
                        ::syntax::Type::Path(v0) => ::syntax::Type::Path(v0.clone()),
                        ::syntax::Type::Ptr(v0) => ::syntax::Type::Ptr(v0.clone()),
                        ::syntax::Type::Reference(v0) => ::syntax::Type::Reference(v0.clone()),
                        ::syntax::Type::Slice(v0) => ::syntax::Type::Slice(v0.clone()),
                        ::syntax::Type::TraitObject(v0) => ::syntax::Type::TraitObject(v0.clone()),
                        ::syntax::Type::Tuple(v0) => ::syntax::Type::Tuple(v0.clone()),
                        ::syntax::Type::Verbatim(v0) => ::syntax::Type::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeArray {
                fn clone(&self) -> Self {
                    ::syntax::TypeArray {
                        bracket_token: self.bracket_token.clone(),
                        elem: self.elem.clone(),
                        semi_token: self.semi_token.clone(),
                        len: self.len.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeBareFn {
                fn clone(&self) -> Self {
                    ::syntax::TypeBareFn {
                        lifetimes: self.lifetimes.clone(),
                        unsafety: self.unsafety.clone(),
                        abi: self.abi.clone(),
                        fn_token: self.fn_token.clone(),
                        paren_token: self.paren_token.clone(),
                        inputs: self.inputs.clone(),
                        variadic: self.variadic.clone(),
                        output: self.output.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeGroup {
                fn clone(&self) -> Self {
                    ::syntax::TypeGroup {
                        group_token: self.group_token.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeImplTrait {
                fn clone(&self) -> Self {
                    ::syntax::TypeImplTrait {
                        impl_token: self.impl_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeInfer {
                fn clone(&self) -> Self {
                    ::syntax::TypeInfer {
                        underscore_token: self.underscore_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeMacro {
                fn clone(&self) -> Self {
                    ::syntax::TypeMacro {
                        mac: self.mac.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeNever {
                fn clone(&self) -> Self {
                    ::syntax::TypeNever {
                        bang_token: self.bang_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeParam {
                fn clone(&self) -> Self {
                    ::syntax::TypeParam {
                        attrs: self.attrs.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                        eq_token: self.eq_token.clone(),
                        default: self.default.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeParamBound {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::TypeParamBound::Trait(v0) => ::syntax::TypeParamBound::Trait(v0.clone()),
                        ::syntax::TypeParamBound::Lifetime(v0) => {
                            ::syntax::TypeParamBound::Lifetime(v0.clone())
                        }
                                        ::syntax::TypeParamBound::PreciseCapture(v0) => {
                            ::syntax::TypeParamBound::PreciseCapture(v0.clone())
                        }
                        ::syntax::TypeParamBound::Verbatim(v0) => {
                            ::syntax::TypeParamBound::Verbatim(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::TypeParen {
                fn clone(&self) -> Self {
                    ::syntax::TypeParen {
                        paren_token: self.paren_token.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypePath {
                fn clone(&self) -> Self {
                    ::syntax::TypePath {
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypePtr {
                fn clone(&self) -> Self {
                    ::syntax::TypePtr {
                        star_token: self.star_token.clone(),
                        const_token: self.const_token.clone(),
                        mutability: self.mutability.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeReference {
                fn clone(&self) -> Self {
                    ::syntax::TypeReference {
                        and_token: self.and_token.clone(),
                        lifetime: self.lifetime.clone(),
                        mutability: self.mutability.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeSlice {
                fn clone(&self) -> Self {
                    ::syntax::TypeSlice {
                        bracket_token: self.bracket_token.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeTraitObject {
                fn clone(&self) -> Self {
                    ::syntax::TypeTraitObject {
                        dyn_token: self.dyn_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeTuple {
                fn clone(&self) -> Self {
                    ::syntax::TypeTuple {
                        paren_token: self.paren_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::UnOp {}
             
            impl Clone for ::syntax::UnOp {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::UseGlob {
                fn clone(&self) -> Self {
                    ::syntax::UseGlob {
                        star_token: self.star_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UseGroup {
                fn clone(&self) -> Self {
                    ::syntax::UseGroup {
                        brace_token: self.brace_token.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UseName {
                fn clone(&self) -> Self {
                    ::syntax::UseName {
                        ident: self.ident.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UsePath {
                fn clone(&self) -> Self {
                    ::syntax::UsePath {
                        ident: self.ident.clone(),
                        colon2_token: self.colon2_token.clone(),
                        tree: self.tree.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UseRename {
                fn clone(&self) -> Self {
                    ::syntax::UseRename {
                        ident: self.ident.clone(),
                        as_token: self.as_token.clone(),
                        rename: self.rename.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UseTree {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::UseTree::Path(v0) => ::syntax::UseTree::Path(v0.clone()),
                        ::syntax::UseTree::Name(v0) => ::syntax::UseTree::Name(v0.clone()),
                        ::syntax::UseTree::Rename(v0) => ::syntax::UseTree::Rename(v0.clone()),
                        ::syntax::UseTree::Glob(v0) => ::syntax::UseTree::Glob(v0.clone()),
                        ::syntax::UseTree::Group(v0) => ::syntax::UseTree::Group(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::Variadic {
                fn clone(&self) -> Self {
                    ::syntax::Variadic {
                        attrs: self.attrs.clone(),
                        pat: self.pat.clone(),
                        dots: self.dots.clone(),
                        comma: self.comma.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Variant {
                fn clone(&self) -> Self {
                    ::syntax::Variant {
                        attrs: self.attrs.clone(),
                        ident: self.ident.clone(),
                        fields: self.fields.clone(),
                        discriminant: self.discriminant.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::VisRestricted {
                fn clone(&self) -> Self {
                    ::syntax::VisRestricted {
                        pub_token: self.pub_token.clone(),
                        paren_token: self.paren_token.clone(),
                        in_token: self.in_token.clone(),
                        path: self.path.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Visibility {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Visibility::Public(v0) => ::syntax::Visibility::Public(v0.clone()),
                        ::syntax::Visibility::Restricted(v0) => {
                            ::syntax::Visibility::Restricted(v0.clone())
                        }
                        ::syntax::Visibility::Inherited => ::syntax::Visibility::Inherited,
                    }
                }
            }
             
            impl Clone for ::syntax::WhereClause {
                fn clone(&self) -> Self {
                    ::syntax::WhereClause {
                        where_token: self.where_token.clone(),
                        predicates: self.predicates.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::WherePredicate {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::WherePredicate::Lifetime(v0) => {
                            ::syntax::WherePredicate::Lifetime(v0.clone())
                        }
                        ::syntax::WherePredicate::Type(v0) => ::syntax::WherePredicate::Type(v0.clone()),
                    }
                }
            }
        }

        pub mod debug
        {
            use ::
            {
                fmt::{self, Debug},
                *,
            };
            /*
            #![allow(unknown_lints, non_local_definitions)]
            */
            impl Debug for ::syntax::Abi {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Abi");
                    formatter.field("extern_token", &self.extern_token);
                    formatter.field("name", &self.name);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::AngleBracketedGenericArguments {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "AngleBracketedGenericArguments")
                }
            }
            impl ::syntax::AngleBracketedGenericArguments {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("colon2_token", &self.colon2_token);
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("args", &self.args);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::Arm {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Arm");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("pat", &self.pat);
                    formatter.field("guard", &self.guard);
                    formatter.field("fat_arrow_token", &self.fat_arrow_token);
                    formatter.field("body", &self.body);
                    formatter.field("comma", &self.comma);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::AssocConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("AssocConst");
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("value", &self.value);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::AssocType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("AssocType");
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::AttrStyle {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("AttrStyle::")?;
                    match self {
                        ::syntax::AttrStyle::Outer => formatter.write_str("Outer"),
                        ::syntax::AttrStyle::Inner(v0) => {
                            let mut formatter = formatter.debug_tuple("Inner");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::Attribute {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Attribute");
                    formatter.field("pound_token", &self.pound_token);
                    formatter.field("style", &self.style);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("meta", &self.meta);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::BareFnArg {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("BareFnArg");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("name", &self.name);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::BareVariadic {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("BareVariadic");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("name", &self.name);
                    formatter.field("dots", &self.dots);
                    formatter.field("comma", &self.comma);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::BinOp {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("BinOp::")?;
                    match self {
                        ::syntax::BinOp::Add(v0) => {
                            let mut formatter = formatter.debug_tuple("Add");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Sub(v0) => {
                            let mut formatter = formatter.debug_tuple("Sub");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Mul(v0) => {
                            let mut formatter = formatter.debug_tuple("Mul");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Div(v0) => {
                            let mut formatter = formatter.debug_tuple("Div");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Rem(v0) => {
                            let mut formatter = formatter.debug_tuple("Rem");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::And(v0) => {
                            let mut formatter = formatter.debug_tuple("And");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Or(v0) => {
                            let mut formatter = formatter.debug_tuple("Or");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitXor(v0) => {
                            let mut formatter = formatter.debug_tuple("BitXor");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitAnd(v0) => {
                            let mut formatter = formatter.debug_tuple("BitAnd");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitOr(v0) => {
                            let mut formatter = formatter.debug_tuple("BitOr");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Shl(v0) => {
                            let mut formatter = formatter.debug_tuple("Shl");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Shr(v0) => {
                            let mut formatter = formatter.debug_tuple("Shr");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Eq(v0) => {
                            let mut formatter = formatter.debug_tuple("Eq");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Lt(v0) => {
                            let mut formatter = formatter.debug_tuple("Lt");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Le(v0) => {
                            let mut formatter = formatter.debug_tuple("Le");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Ne(v0) => {
                            let mut formatter = formatter.debug_tuple("Ne");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Ge(v0) => {
                            let mut formatter = formatter.debug_tuple("Ge");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Gt(v0) => {
                            let mut formatter = formatter.debug_tuple("Gt");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::AddAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("AddAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::SubAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("SubAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::MulAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("MulAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::DivAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("DivAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::RemAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("RemAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitXorAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("BitXorAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitAndAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("BitAndAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitOrAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("BitOrAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::ShlAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("ShlAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::ShrAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("ShrAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Block {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Block");
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("stmts", &self.stmts);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::BoundLifetimes {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("BoundLifetimes");
                    formatter.field("for_token", &self.for_token);
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::CapturedParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("CapturedParam::")?;
                    match self {
                        ::syntax::CapturedParam::Lifetime(v0) => {
                            let mut formatter = formatter.debug_tuple("Lifetime");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::CapturedParam::Ident(v0) => {
                            let mut formatter = formatter.debug_tuple("Ident");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::ConstParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("ConstParam");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("default", &self.default);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Constraint {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Constraint");
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            
            impl  Debug for ::syntax::Data {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Data::")?;
                    match self {
                        ::syntax::Data::Struct(v0) => v0.debug(formatter, "Struct"),
                        ::syntax::Data::Enum(v0) => v0.debug(formatter, "Enum"),
                        ::syntax::Data::Union(v0) => v0.debug(formatter, "Union"),
                    }
                }
            }
            
            impl  Debug for ::syntax::DataEnum {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "DataEnum")
                }
            }
            
            impl ::syntax::DataEnum {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("enum_token", &self.enum_token);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("variants", &self.variants);
                    formatter.finish()
                }
            }
            
            impl  Debug for ::syntax::DataStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "DataStruct")
                }
            }
            
            impl ::syntax::DataStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("struct_token", &self.struct_token);
                    formatter.field("fields", &self.fields);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
            
            impl  Debug for ::syntax::DataUnion {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "DataUnion")
                }
            }
            
            impl ::syntax::DataUnion {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("union_token", &self.union_token);
                    formatter.field("fields", &self.fields);
                    formatter.finish()
                }
            }
            
            impl  Debug for ::syntax::DeriveInput {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("DeriveInput");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("data", &self.data);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Expr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Expr::")?;
                    match self {
                                        ::syntax::Expr::Array(v0) => v0.debug(formatter, "Array"),
                                        ::syntax::Expr::Assign(v0) => v0.debug(formatter, "Assign"),
                                        ::syntax::Expr::Async(v0) => v0.debug(formatter, "Async"),
                                        ::syntax::Expr::Await(v0) => v0.debug(formatter, "Await"),
                        ::syntax::Expr::Binary(v0) => v0.debug(formatter, "Binary"),
                                        ::syntax::Expr::Block(v0) => v0.debug(formatter, "Block"),
                                        ::syntax::Expr::Break(v0) => v0.debug(formatter, "Break"),
                        ::syntax::Expr::Call(v0) => v0.debug(formatter, "Call"),
                        ::syntax::Expr::Cast(v0) => v0.debug(formatter, "Cast"),
                                        ::syntax::Expr::Closure(v0) => v0.debug(formatter, "Closure"),
                                        ::syntax::Expr::Const(v0) => v0.debug(formatter, "Const"),
                                        ::syntax::Expr::Continue(v0) => v0.debug(formatter, "Continue"),
                        ::syntax::Expr::Field(v0) => v0.debug(formatter, "Field"),
                                        ::syntax::Expr::ForLoop(v0) => v0.debug(formatter, "ForLoop"),
                        ::syntax::Expr::Group(v0) => v0.debug(formatter, "Group"),
                                        ::syntax::Expr::If(v0) => v0.debug(formatter, "If"),
                        ::syntax::Expr::Index(v0) => v0.debug(formatter, "Index"),
                                        ::syntax::Expr::Infer(v0) => v0.debug(formatter, "Infer"),
                                        ::syntax::Expr::Let(v0) => v0.debug(formatter, "Let"),
                        ::syntax::Expr::Lit(v0) => v0.debug(formatter, "Lit"),
                                        ::syntax::Expr::Loop(v0) => v0.debug(formatter, "Loop"),
                        ::syntax::Expr::Macro(v0) => v0.debug(formatter, "Macro"),
                                        ::syntax::Expr::Match(v0) => v0.debug(formatter, "Match"),
                        ::syntax::Expr::MethodCall(v0) => v0.debug(formatter, "MethodCall"),
                        ::syntax::Expr::Paren(v0) => v0.debug(formatter, "Paren"),
                        ::syntax::Expr::Path(v0) => v0.debug(formatter, "Path"),
                                        ::syntax::Expr::Range(v0) => v0.debug(formatter, "Range"),
                                        ::syntax::Expr::RawAddr(v0) => v0.debug(formatter, "RawAddr"),
                        ::syntax::Expr::Reference(v0) => v0.debug(formatter, "Reference"),
                                        ::syntax::Expr::Repeat(v0) => v0.debug(formatter, "Repeat"),
                                        ::syntax::Expr::Return(v0) => v0.debug(formatter, "Return"),
                        ::syntax::Expr::Struct(v0) => v0.debug(formatter, "Struct"),
                                        ::syntax::Expr::Try(v0) => v0.debug(formatter, "Try"),
                                        ::syntax::Expr::TryBlock(v0) => v0.debug(formatter, "TryBlock"),
                        ::syntax::Expr::Tuple(v0) => v0.debug(formatter, "Tuple"),
                        ::syntax::Expr::Unary(v0) => v0.debug(formatter, "Unary"),
                                        ::syntax::Expr::Unsafe(v0) => v0.debug(formatter, "Unsafe"),
                        ::syntax::Expr::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        
                        ::syntax::Expr::While(v0) => v0.debug(formatter, "While"),
                        ::syntax::Expr::Yield(v0) => v0.debug(formatter, "Yield"),
                    }
                }
            }
                impl  Debug for ::syntax::ExprArray {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprArray")
                }
            }
                impl ::syntax::ExprArray {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprAssign {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprAssign")
                }
            }
                impl ::syntax::ExprAssign {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("left", &self.left);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("right", &self.right);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprAsync {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprAsync")
                }
            }
                impl ::syntax::ExprAsync {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("async_token", &self.async_token);
                    formatter.field("capture", &self.capture);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprAwait {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprAwait")
                }
            }
                impl ::syntax::ExprAwait {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("base", &self.base);
                    formatter.field("dot_token", &self.dot_token);
                    formatter.field("await_token", &self.await_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprBinary {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprBinary")
                }
            }
            impl ::syntax::ExprBinary {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("left", &self.left);
                    formatter.field("op", &self.op);
                    formatter.field("right", &self.right);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprBlock {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprBlock")
                }
            }
                impl ::syntax::ExprBlock {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("label", &self.label);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprBreak {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprBreak")
                }
            }
                impl ::syntax::ExprBreak {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("break_token", &self.break_token);
                    formatter.field("label", &self.label);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprCall {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprCall")
                }
            }
            impl ::syntax::ExprCall {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("func", &self.func);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("args", &self.args);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprCast {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprCast")
                }
            }
            impl ::syntax::ExprCast {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("expr", &self.expr);
                    formatter.field("as_token", &self.as_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprClosure {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprClosure")
                }
            }
                impl ::syntax::ExprClosure {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("constness", &self.constness);
                    formatter.field("movability", &self.movability);
                    formatter.field("asyncness", &self.asyncness);
                    formatter.field("capture", &self.capture);
                    formatter.field("or1_token", &self.or1_token);
                    formatter.field("inputs", &self.inputs);
                    formatter.field("or2_token", &self.or2_token);
                    formatter.field("output", &self.output);
                    formatter.field("body", &self.body);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprConst")
                }
            }
                impl ::syntax::ExprConst {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprContinue {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprContinue")
                }
            }
                impl ::syntax::ExprContinue {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("continue_token", &self.continue_token);
                    formatter.field("label", &self.label);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprField {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprField")
                }
            }
            impl ::syntax::ExprField {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("base", &self.base);
                    formatter.field("dot_token", &self.dot_token);
                    formatter.field("member", &self.member);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprForLoop {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprForLoop")
                }
            }
                impl ::syntax::ExprForLoop {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("label", &self.label);
                    formatter.field("for_token", &self.for_token);
                    formatter.field("pat", &self.pat);
                    formatter.field("in_token", &self.in_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("body", &self.body);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprGroup {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprGroup")
                }
            }
            impl ::syntax::ExprGroup {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("group_token", &self.group_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprIf {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprIf")
                }
            }
                impl ::syntax::ExprIf {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("if_token", &self.if_token);
                    formatter.field("cond", &self.cond);
                    formatter.field("then_branch", &self.then_branch);
                    formatter.field("else_branch", &self.else_branch);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprIndex {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprIndex")
                }
            }
            impl ::syntax::ExprIndex {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("expr", &self.expr);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("index", &self.index);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprInfer {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprInfer")
                }
            }
                impl ::syntax::ExprInfer {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("underscore_token", &self.underscore_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprLet {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprLet")
                }
            }
                impl ::syntax::ExprLet {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("let_token", &self.let_token);
                    formatter.field("pat", &self.pat);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprLit {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprLit")
                }
            }
            impl ::syntax::ExprLit {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("lit", &self.lit);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprLoop {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprLoop")
                }
            }
                impl ::syntax::ExprLoop {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("label", &self.label);
                    formatter.field("loop_token", &self.loop_token);
                    formatter.field("body", &self.body);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprMacro")
                }
            }
            impl ::syntax::ExprMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprMatch {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprMatch")
                }
            }
                impl ::syntax::ExprMatch {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("match_token", &self.match_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("arms", &self.arms);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprMethodCall {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprMethodCall")
                }
            }
            impl ::syntax::ExprMethodCall {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("receiver", &self.receiver);
                    formatter.field("dot_token", &self.dot_token);
                    formatter.field("method", &self.method);
                    formatter.field("turbofish", &self.turbofish);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("args", &self.args);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprParen {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprParen")
                }
            }
            impl ::syntax::ExprParen {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprPath {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprPath")
                }
            }
            impl ::syntax::ExprPath {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprRange {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprRange")
                }
            }
                impl ::syntax::ExprRange {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("start", &self.start);
                    formatter.field("limits", &self.limits);
                    formatter.field("end", &self.end);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprRawAddr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprRawAddr")
                }
            }
                impl ::syntax::ExprRawAddr {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("and_token", &self.and_token);
                    formatter.field("raw", &self.raw);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprReference {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprReference")
                }
            }
            impl ::syntax::ExprReference {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("and_token", &self.and_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprRepeat {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprRepeat")
                }
            }
                impl ::syntax::ExprRepeat {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.field("len", &self.len);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprReturn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprReturn")
                }
            }
                impl ::syntax::ExprReturn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("return_token", &self.return_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprStruct")
                }
            }
            impl ::syntax::ExprStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("fields", &self.fields);
                    formatter.field("dot2_token", &self.dot2_token);
                    formatter.field("rest", &self.rest);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprTry {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprTry")
                }
            }
                impl ::syntax::ExprTry {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("expr", &self.expr);
                    formatter.field("question_token", &self.question_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprTryBlock {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprTryBlock")
                }
            }
                impl ::syntax::ExprTryBlock {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("try_token", &self.try_token);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprTuple {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprTuple")
                }
            }
            impl ::syntax::ExprTuple {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprUnary {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprUnary")
                }
            }
            impl ::syntax::ExprUnary {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("op", &self.op);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprUnsafe {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprUnsafe")
                }
            }
                impl ::syntax::ExprUnsafe {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("unsafe_token", &self.unsafe_token);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprWhile {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprWhile")
                }
            }
                impl ::syntax::ExprWhile {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("label", &self.label);
                    formatter.field("while_token", &self.while_token);
                    formatter.field("cond", &self.cond);
                    formatter.field("body", &self.body);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprYield {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprYield")
                }
            }
                impl ::syntax::ExprYield {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("yield_token", &self.yield_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Field {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Field");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::FieldMutability {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("FieldMutability::")?;
                    match self {
                        ::syntax::FieldMutability::None => formatter.write_str("None"),
                    }
                }
            }
                impl  Debug for ::syntax::FieldPat {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("FieldPat");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("member", &self.member);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("pat", &self.pat);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::FieldValue {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("FieldValue");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("member", &self.member);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Fields {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Fields::")?;
                    match self {
                        ::syntax::Fields::Named(v0) => v0.debug(formatter, "Named"),
                        ::syntax::Fields::Unnamed(v0) => v0.debug(formatter, "Unnamed"),
                        ::syntax::Fields::Unit => formatter.write_str("Unit"),
                    }
                }
            }
            impl Debug for ::syntax::FieldsNamed {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "FieldsNamed")
                }
            }
            impl ::syntax::FieldsNamed {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("named", &self.named);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::FieldsUnnamed {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "FieldsUnnamed")
                }
            }
            impl ::syntax::FieldsUnnamed {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("unnamed", &self.unnamed);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::File {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("File");
                    formatter.field("shebang", &self.shebang);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::FnArg {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("FnArg::")?;
                    match self {
                        ::syntax::FnArg::Receiver(v0) => {
                            let mut formatter = formatter.debug_tuple("Receiver");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::FnArg::Typed(v0) => {
                            let mut formatter = formatter.debug_tuple("Typed");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::ForeignItem {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("ForeignItem::")?;
                    match self {
                        ::syntax::ForeignItem::Fn(v0) => v0.debug(formatter, "Fn"),
                        ::syntax::ForeignItem::Static(v0) => v0.debug(formatter, "Static"),
                        ::syntax::ForeignItem::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::ForeignItem::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::ForeignItem::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::ForeignItemFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ForeignItemFn")
                }
            }
                impl ::syntax::ForeignItemFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("sig", &self.sig);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ForeignItemMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ForeignItemMacro")
                }
            }
                impl ::syntax::ForeignItemMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ForeignItemStatic {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ForeignItemStatic")
                }
            }
                impl ::syntax::ForeignItemStatic {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("static_token", &self.static_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ForeignItemType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ForeignItemType")
                }
            }
                impl ::syntax::ForeignItemType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("type_token", &self.type_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::GenericArgument {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("GenericArgument::")?;
                    match self {
                        ::syntax::GenericArgument::Lifetime(v0) => {
                            let mut formatter = formatter.debug_tuple("Lifetime");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::Type(v0) => {
                            let mut formatter = formatter.debug_tuple("Type");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::Const(v0) => {
                            let mut formatter = formatter.debug_tuple("Const");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::AssocType(v0) => {
                            let mut formatter = formatter.debug_tuple("AssocType");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::AssocConst(v0) => {
                            let mut formatter = formatter.debug_tuple("AssocConst");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::Constraint(v0) => {
                            let mut formatter = formatter.debug_tuple("Constraint");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::GenericParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("GenericParam::")?;
                    match self {
                        ::syntax::GenericParam::Lifetime(v0) => {
                            let mut formatter = formatter.debug_tuple("Lifetime");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericParam::Type(v0) => {
                            let mut formatter = formatter.debug_tuple("Type");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericParam::Const(v0) => {
                            let mut formatter = formatter.debug_tuple("Const");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::Generics {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Generics");
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("params", &self.params);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.field("where_clause", &self.where_clause);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplItem {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("ImplItem::")?;
                    match self {
                        ::syntax::ImplItem::Const(v0) => v0.debug(formatter, "Const"),
                        ::syntax::ImplItem::Fn(v0) => v0.debug(formatter, "Fn"),
                        ::syntax::ImplItem::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::ImplItem::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::ImplItem::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::ImplItemConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ImplItemConst")
                }
            }
                impl ::syntax::ImplItemConst {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("defaultness", &self.defaultness);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplItemFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ImplItemFn")
                }
            }
                impl ::syntax::ImplItemFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("defaultness", &self.defaultness);
                    formatter.field("sig", &self.sig);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplItemMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ImplItemMacro")
                }
            }
                impl ::syntax::ImplItemMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplItemType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ImplItemType")
                }
            }
                impl ::syntax::ImplItemType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("defaultness", &self.defaultness);
                    formatter.field("type_token", &self.type_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplRestriction {
                fn fmt(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {
                    match *self {}
                }
            }
            impl Debug for ::syntax::Index {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Index");
                    formatter.field("index", &self.index);
                    formatter.field("span", &self.span);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::Item {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Item::")?;
                    match self {
                        ::syntax::Item::Const(v0) => v0.debug(formatter, "Const"),
                        ::syntax::Item::Enum(v0) => v0.debug(formatter, "Enum"),
                        ::syntax::Item::ExternCrate(v0) => v0.debug(formatter, "ExternCrate"),
                        ::syntax::Item::Fn(v0) => v0.debug(formatter, "Fn"),
                        ::syntax::Item::ForeignMod(v0) => v0.debug(formatter, "ForeignMod"),
                        ::syntax::Item::Impl(v0) => v0.debug(formatter, "Impl"),
                        ::syntax::Item::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::Item::Mod(v0) => v0.debug(formatter, "Mod"),
                        ::syntax::Item::Static(v0) => v0.debug(formatter, "Static"),
                        ::syntax::Item::Struct(v0) => v0.debug(formatter, "Struct"),
                        ::syntax::Item::Trait(v0) => v0.debug(formatter, "Trait"),
                        ::syntax::Item::TraitAlias(v0) => v0.debug(formatter, "TraitAlias"),
                        ::syntax::Item::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::Item::Union(v0) => v0.debug(formatter, "Union"),
                        ::syntax::Item::Use(v0) => v0.debug(formatter, "Use"),
                        ::syntax::Item::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::ItemConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemConst")
                }
            }
                impl ::syntax::ItemConst {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemEnum {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemEnum")
                }
            }
                impl ::syntax::ItemEnum {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("enum_token", &self.enum_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("variants", &self.variants);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemExternCrate {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemExternCrate")
                }
            }
                impl ::syntax::ItemExternCrate {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("extern_token", &self.extern_token);
                    formatter.field("crate_token", &self.crate_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("rename", &self.rename);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemFn")
                }
            }
                impl ::syntax::ItemFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("sig", &self.sig);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemForeignMod {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemForeignMod")
                }
            }
                impl ::syntax::ItemForeignMod {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("abi", &self.abi);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemImpl {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemImpl")
                }
            }
                impl ::syntax::ItemImpl {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("defaultness", &self.defaultness);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("impl_token", &self.impl_token);
                    formatter.field("generics", &self.generics);
                    formatter.field("trait_", &self.trait_);
                    formatter.field("self_ty", &self.self_ty);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemMacro")
                }
            }
                impl ::syntax::ItemMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("ident", &self.ident);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemMod {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemMod")
                }
            }
                impl ::syntax::ItemMod {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("mod_token", &self.mod_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("content", &self.content);
                    formatter.field("semi", &self.semi);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemStatic {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemStatic")
                }
            }
                impl ::syntax::ItemStatic {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("static_token", &self.static_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemStruct")
                }
            }
                impl ::syntax::ItemStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("struct_token", &self.struct_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("fields", &self.fields);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemTrait {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemTrait")
                }
            }
                impl ::syntax::ItemTrait {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("auto_token", &self.auto_token);
                    formatter.field("restriction", &self.restriction);
                    formatter.field("trait_token", &self.trait_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("supertraits", &self.supertraits);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemTraitAlias {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemTraitAlias")
                }
            }
                impl ::syntax::ItemTraitAlias {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("trait_token", &self.trait_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemType")
                }
            }
                impl ::syntax::ItemType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("type_token", &self.type_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemUnion {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemUnion")
                }
            }
                impl ::syntax::ItemUnion {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("union_token", &self.union_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("fields", &self.fields);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemUse {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemUse")
                }
            }
                impl ::syntax::ItemUse {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("use_token", &self.use_token);
                    formatter.field("leading_colon", &self.leading_colon);
                    formatter.field("tree", &self.tree);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::Label {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Label");
                    formatter.field("name", &self.name);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.finish()
                }
            }
            impl  Debug for ::syntax::Lifetime {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "Lifetime")
                }
            }
            impl ::syntax::Lifetime {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("apostrophe", &self.apostrophe);
                    formatter.field("ident", &self.ident);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::LifetimeParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("LifetimeParam");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("lifetime", &self.lifetime);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl  Debug for ::syntax::Lit {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Lit::")?;
                    match self {
                        ::syntax::Lit::Str(v0) => v0.debug(formatter, "Str"),
                        ::syntax::Lit::ByteStr(v0) => v0.debug(formatter, "ByteStr"),
                        ::syntax::Lit::CStr(v0) => v0.debug(formatter, "CStr"),
                        ::syntax::Lit::Byte(v0) => v0.debug(formatter, "Byte"),
                        ::syntax::Lit::Char(v0) => v0.debug(formatter, "Char"),
                        ::syntax::Lit::Int(v0) => v0.debug(formatter, "Int"),
                        ::syntax::Lit::Float(v0) => v0.debug(formatter, "Float"),
                        ::syntax::Lit::Bool(v0) => v0.debug(formatter, "Bool"),
                        ::syntax::Lit::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Local {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "Local")
                }
            }
                impl ::syntax::Local {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("let_token", &self.let_token);
                    formatter.field("pat", &self.pat);
                    formatter.field("init", &self.init);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::LocalInit {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("LocalInit");
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("diverge", &self.diverge);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Macro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Macro");
                    formatter.field("path", &self.path);
                    formatter.field("bang_token", &self.bang_token);
                    formatter.field("delimiter", &self.delimiter);
                    formatter.field("tokens", &self.tokens);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::MacroDelimiter {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("MacroDelimiter::")?;
                    match self {
                        ::syntax::MacroDelimiter::Paren(v0) => {
                            let mut formatter = formatter.debug_tuple("Paren");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::MacroDelimiter::Brace(v0) => {
                            let mut formatter = formatter.debug_tuple("Brace");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::MacroDelimiter::Bracket(v0) => {
                            let mut formatter = formatter.debug_tuple("Bracket");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::Member {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Member::")?;
                    match self {
                        ::syntax::Member::Named(v0) => {
                            let mut formatter = formatter.debug_tuple("Named");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::Member::Unnamed(v0) => {
                            let mut formatter = formatter.debug_tuple("Unnamed");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::Meta {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Meta::")?;
                    match self {
                        ::syntax::Meta::Path(v0) => v0.debug(formatter, "Path"),
                        ::syntax::Meta::List(v0) => v0.debug(formatter, "List"),
                        ::syntax::Meta::NameValue(v0) => v0.debug(formatter, "NameValue"),
                    }
                }
            }
            impl Debug for ::syntax::MetaList {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "MetaList")
                }
            }
            impl ::syntax::MetaList {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("path", &self.path);
                    formatter.field("delimiter", &self.delimiter);
                    formatter.field("tokens", &self.tokens);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::MetaNameValue {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "MetaNameValue")
                }
            }
            impl ::syntax::MetaNameValue {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("path", &self.path);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("value", &self.value);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ParenthesizedGenericArguments {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ParenthesizedGenericArguments")
                }
            }
            impl ::syntax::ParenthesizedGenericArguments {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("inputs", &self.inputs);
                    formatter.field("output", &self.output);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::Pat {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Pat::")?;
                    match self {
                        ::syntax::Pat::Const(v0) => v0.debug(formatter, "Const"),
                        ::syntax::Pat::Ident(v0) => v0.debug(formatter, "Ident"),
                        ::syntax::Pat::Lit(v0) => v0.debug(formatter, "Lit"),
                        ::syntax::Pat::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::Pat::Or(v0) => v0.debug(formatter, "Or"),
                        ::syntax::Pat::Paren(v0) => v0.debug(formatter, "Paren"),
                        ::syntax::Pat::Path(v0) => v0.debug(formatter, "Path"),
                        ::syntax::Pat::Range(v0) => v0.debug(formatter, "Range"),
                        ::syntax::Pat::Reference(v0) => v0.debug(formatter, "Reference"),
                        ::syntax::Pat::Rest(v0) => v0.debug(formatter, "Rest"),
                        ::syntax::Pat::Slice(v0) => v0.debug(formatter, "Slice"),
                        ::syntax::Pat::Struct(v0) => v0.debug(formatter, "Struct"),
                        ::syntax::Pat::Tuple(v0) => v0.debug(formatter, "Tuple"),
                        ::syntax::Pat::TupleStruct(v0) => v0.debug(formatter, "TupleStruct"),
                        ::syntax::Pat::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::Pat::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::Pat::Wild(v0) => v0.debug(formatter, "Wild"),
                    }
                }
            }
                impl  Debug for ::syntax::PatIdent {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatIdent")
                }
            }
                impl ::syntax::PatIdent {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("by_ref", &self.by_ref);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("ident", &self.ident);
                    formatter.field("subpat", &self.subpat);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatOr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatOr")
                }
            }
                impl ::syntax::PatOr {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("leading_vert", &self.leading_vert);
                    formatter.field("cases", &self.cases);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatParen {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatParen")
                }
            }
                impl ::syntax::PatParen {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("pat", &self.pat);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatReference {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatReference")
                }
            }
                impl ::syntax::PatReference {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("and_token", &self.and_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("pat", &self.pat);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatRest {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatRest")
                }
            }
                impl ::syntax::PatRest {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("dot2_token", &self.dot2_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatSlice {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatSlice")
                }
            }
                impl ::syntax::PatSlice {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatStruct")
                }
            }
                impl ::syntax::PatStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("fields", &self.fields);
                    formatter.field("rest", &self.rest);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatTuple {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatTuple")
                }
            }
                impl ::syntax::PatTuple {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatTupleStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatTupleStruct")
                }
            }
                impl ::syntax::PatTupleStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatType")
                }
            }
                impl ::syntax::PatType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("pat", &self.pat);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatWild {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatWild")
                }
            }
                impl ::syntax::PatWild {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("underscore_token", &self.underscore_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Path {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "Path")
                }
            }
            impl ::syntax::Path {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("leading_colon", &self.leading_colon);
                    formatter.field("segments", &self.segments);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::PathArguments {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("PathArguments::")?;
                    match self {
                        ::syntax::PathArguments::None => formatter.write_str("None"),
                        ::syntax::PathArguments::AngleBracketed(v0) => {
                            v0.debug(formatter, "AngleBracketed")
                        }
                        ::syntax::PathArguments::Parenthesized(v0) => {
                            v0.debug(formatter, "Parenthesized")
                        }
                    }
                }
            }
            impl Debug for ::syntax::PathSegment {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("PathSegment");
                    formatter.field("ident", &self.ident);
                    formatter.field("arguments", &self.arguments);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PointerMutability {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("PointerMutability::")?;
                    match self {
                        ::syntax::PointerMutability::Const(v0) => {
                            let mut formatter = formatter.debug_tuple("Const");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::PointerMutability::Mut(v0) => {
                            let mut formatter = formatter.debug_tuple("Mut");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::PreciseCapture {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("PreciseCapture");
                    formatter.field("use_token", &self.use_token);
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("params", &self.params);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::PredicateLifetime {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("PredicateLifetime");
                    formatter.field("lifetime", &self.lifetime);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::PredicateType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("PredicateType");
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("bounded_ty", &self.bounded_ty);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::QSelf {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("QSelf");
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("position", &self.position);
                    formatter.field("as_token", &self.as_token);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::RangeLimits {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("RangeLimits::")?;
                    match self {
                        ::syntax::RangeLimits::HalfOpen(v0) => {
                            let mut formatter = formatter.debug_tuple("HalfOpen");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::RangeLimits::Closed(v0) => {
                            let mut formatter = formatter.debug_tuple("Closed");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Receiver {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Receiver");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("reference", &self.reference);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("self_token", &self.self_token);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ReturnType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("ReturnType::")?;
                    match self {
                        ::syntax::ReturnType::Default => formatter.write_str("Default"),
                        ::syntax::ReturnType::Type(v0, v1) => {
                            let mut formatter = formatter.debug_tuple("Type");
                            formatter.field(v0);
                            formatter.field(v1);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Signature {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Signature");
                    formatter.field("constness", &self.constness);
                    formatter.field("asyncness", &self.asyncness);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("abi", &self.abi);
                    formatter.field("fn_token", &self.fn_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("inputs", &self.inputs);
                    formatter.field("variadic", &self.variadic);
                    formatter.field("output", &self.output);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::StaticMutability {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("StaticMutability::")?;
                    match self {
                        ::syntax::StaticMutability::Mut(v0) => {
                            let mut formatter = formatter.debug_tuple("Mut");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::StaticMutability::None => formatter.write_str("None"),
                    }
                }
            }
                impl  Debug for ::syntax::Stmt {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Stmt::")?;
                    match self {
                        ::syntax::Stmt::Local(v0) => v0.debug(formatter, "Local"),
                        ::syntax::Stmt::Item(v0) => {
                            let mut formatter = formatter.debug_tuple("Item");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::Stmt::Expr(v0, v1) => {
                            let mut formatter = formatter.debug_tuple("Expr");
                            formatter.field(v0);
                            formatter.field(v1);
                            formatter.finish()
                        }
                        ::syntax::Stmt::Macro(v0) => v0.debug(formatter, "Macro"),
                    }
                }
            }
                impl  Debug for ::syntax::StmtMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "StmtMacro")
                }
            }
                impl ::syntax::StmtMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TraitBound {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("TraitBound");
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("modifier", &self.modifier);
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("path", &self.path);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TraitBoundModifier {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("TraitBoundModifier::")?;
                    match self {
                        ::syntax::TraitBoundModifier::None => formatter.write_str("None"),
                        ::syntax::TraitBoundModifier::Maybe(v0) => {
                            let mut formatter = formatter.debug_tuple("Maybe");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::TraitItem {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("TraitItem::")?;
                    match self {
                        ::syntax::TraitItem::Const(v0) => v0.debug(formatter, "Const"),
                        ::syntax::TraitItem::Fn(v0) => v0.debug(formatter, "Fn"),
                        ::syntax::TraitItem::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::TraitItem::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::TraitItem::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::TraitItemConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TraitItemConst")
                }
            }
                impl ::syntax::TraitItemConst {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("default", &self.default);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::TraitItemFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TraitItemFn")
                }
            }
                impl ::syntax::TraitItemFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("sig", &self.sig);
                    formatter.field("default", &self.default);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::TraitItemMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TraitItemMacro")
                }
            }
                impl ::syntax::TraitItemMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::TraitItemType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TraitItemType")
                }
            }
                impl ::syntax::TraitItemType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("type_token", &self.type_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.field("default", &self.default);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Type {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Type::")?;
                    match self {
                        ::syntax::Type::Array(v0) => v0.debug(formatter, "Array"),
                        ::syntax::Type::BareFn(v0) => v0.debug(formatter, "BareFn"),
                        ::syntax::Type::Group(v0) => v0.debug(formatter, "Group"),
                        ::syntax::Type::ImplTrait(v0) => v0.debug(formatter, "ImplTrait"),
                        ::syntax::Type::Infer(v0) => v0.debug(formatter, "Infer"),
                        ::syntax::Type::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::Type::Never(v0) => v0.debug(formatter, "Never"),
                        ::syntax::Type::Paren(v0) => v0.debug(formatter, "Paren"),
                        ::syntax::Type::Path(v0) => v0.debug(formatter, "Path"),
                        ::syntax::Type::Ptr(v0) => v0.debug(formatter, "Ptr"),
                        ::syntax::Type::Reference(v0) => v0.debug(formatter, "Reference"),
                        ::syntax::Type::Slice(v0) => v0.debug(formatter, "Slice"),
                        ::syntax::Type::TraitObject(v0) => v0.debug(formatter, "TraitObject"),
                        ::syntax::Type::Tuple(v0) => v0.debug(formatter, "Tuple"),
                        ::syntax::Type::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::TypeArray {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeArray")
                }
            }
            impl ::syntax::TypeArray {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("elem", &self.elem);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.field("len", &self.len);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeBareFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeBareFn")
                }
            }
            impl ::syntax::TypeBareFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("abi", &self.abi);
                    formatter.field("fn_token", &self.fn_token);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("inputs", &self.inputs);
                    formatter.field("variadic", &self.variadic);
                    formatter.field("output", &self.output);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeGroup {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeGroup")
                }
            }
            impl ::syntax::TypeGroup {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("group_token", &self.group_token);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeImplTrait {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeImplTrait")
                }
            }
            impl ::syntax::TypeImplTrait {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("impl_token", &self.impl_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeInfer {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeInfer")
                }
            }
            impl ::syntax::TypeInfer {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("underscore_token", &self.underscore_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeMacro")
                }
            }
            impl ::syntax::TypeMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("mac", &self.mac);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeNever {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeNever")
                }
            }
            impl ::syntax::TypeNever {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("bang_token", &self.bang_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("TypeParam");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("default", &self.default);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeParamBound {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("TypeParamBound::")?;
                    match self {
                        ::syntax::TypeParamBound::Trait(v0) => {
                            let mut formatter = formatter.debug_tuple("Trait");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::TypeParamBound::Lifetime(v0) => v0.debug(formatter, "Lifetime"),
                                        ::syntax::TypeParamBound::PreciseCapture(v0) => {
                            let mut formatter = formatter.debug_tuple("PreciseCapture");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::TypeParamBound::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::TypeParen {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeParen")
                }
            }
            impl ::syntax::TypeParen {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypePath {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypePath")
                }
            }
            impl ::syntax::TypePath {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypePtr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypePtr")
                }
            }
            impl ::syntax::TypePtr {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("star_token", &self.star_token);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeReference {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeReference")
                }
            }
            impl ::syntax::TypeReference {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("and_token", &self.and_token);
                    formatter.field("lifetime", &self.lifetime);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeSlice {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeSlice")
                }
            }
            impl ::syntax::TypeSlice {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeTraitObject {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeTraitObject")
                }
            }
            impl ::syntax::TypeTraitObject {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("dyn_token", &self.dyn_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeTuple {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeTuple")
                }
            }
            impl ::syntax::TypeTuple {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::UnOp {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("UnOp::")?;
                    match self {
                        ::syntax::UnOp::Deref(v0) => {
                            let mut formatter = formatter.debug_tuple("Deref");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UnOp::Not(v0) => {
                            let mut formatter = formatter.debug_tuple("Not");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UnOp::Neg(v0) => {
                            let mut formatter = formatter.debug_tuple("Neg");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::UseGlob {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UseGlob");
                    formatter.field("star_token", &self.star_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UseGroup {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UseGroup");
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UseName {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UseName");
                    formatter.field("ident", &self.ident);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UsePath {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UsePath");
                    formatter.field("ident", &self.ident);
                    formatter.field("colon2_token", &self.colon2_token);
                    formatter.field("tree", &self.tree);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UseRename {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UseRename");
                    formatter.field("ident", &self.ident);
                    formatter.field("as_token", &self.as_token);
                    formatter.field("rename", &self.rename);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UseTree {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("UseTree::")?;
                    match self {
                        ::syntax::UseTree::Path(v0) => {
                            let mut formatter = formatter.debug_tuple("Path");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UseTree::Name(v0) => {
                            let mut formatter = formatter.debug_tuple("Name");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UseTree::Rename(v0) => {
                            let mut formatter = formatter.debug_tuple("Rename");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UseTree::Glob(v0) => {
                            let mut formatter = formatter.debug_tuple("Glob");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UseTree::Group(v0) => {
                            let mut formatter = formatter.debug_tuple("Group");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Variadic {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Variadic");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("pat", &self.pat);
                    formatter.field("dots", &self.dots);
                    formatter.field("comma", &self.comma);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Variant {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Variant");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("ident", &self.ident);
                    formatter.field("fields", &self.fields);
                    formatter.field("discriminant", &self.discriminant);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::VisRestricted {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "VisRestricted")
                }
            }
            impl ::syntax::VisRestricted {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("pub_token", &self.pub_token);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("in_token", &self.in_token);
                    formatter.field("path", &self.path);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Visibility {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Visibility::")?;
                    match self {
                        ::syntax::Visibility::Public(v0) => {
                            let mut formatter = formatter.debug_tuple("Public");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::Visibility::Restricted(v0) => v0.debug(formatter, "Restricted"),
                        ::syntax::Visibility::Inherited => formatter.write_str("Inherited"),
                    }
                }
            }
            impl Debug for ::syntax::WhereClause {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("WhereClause");
                    formatter.field("where_token", &self.where_token);
                    formatter.field("predicates", &self.predicates);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::WherePredicate {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("WherePredicate::")?;
                    match self {
                        ::syntax::WherePredicate::Lifetime(v0) => {
                            let mut formatter = formatter.debug_tuple("Lifetime");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::WherePredicate::Type(v0) => {
                            let mut formatter = formatter.debug_tuple("Type");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
        }

        pub mod eq
        {
            use ::
            {
                syntax::tt::TokenStreamHelper,
                *,
            };
            /*
            */
            impl Eq for ::syntax::Abi {}
            impl PartialEq for ::syntax::Abi {
                fn eq(&self, other: &Self) -> bool
        {
                    self.name == other.name
                }
            }
            impl Eq for ::syntax::AngleBracketedGenericArguments {}
            impl PartialEq for ::syntax::AngleBracketedGenericArguments {
                fn eq(&self, other: &Self) -> bool
        {
                    self.colon2_token == other.colon2_token && self.args == other.args
                }
            }
                impl  Eq for ::syntax::Arm {}
                impl  PartialEq for ::syntax::Arm {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.guard == other.guard
                        && self.body == other.body && self.comma == other.comma
                }
            }
            impl Eq for ::syntax::AssocConst {}
            impl PartialEq for ::syntax::AssocConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.generics == other.generics
                        && self.value == other.value
                }
            }
            impl Eq for ::syntax::AssocType {}
            impl PartialEq for ::syntax::AssocType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.generics == other.generics
                        && self.ty == other.ty
                }
            }
            impl Eq for ::syntax::AttrStyle {}
            impl PartialEq for ::syntax::AttrStyle {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::AttrStyle::Outer, ::syntax::AttrStyle::Outer) => true,
                        (::syntax::AttrStyle::Inner(_), ::syntax::AttrStyle::Inner(_)) => true,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::Attribute {}
            impl PartialEq for ::syntax::Attribute {
                fn eq(&self, other: &Self) -> bool
        {
                    self.style == other.style && self.meta == other.meta
                }
            }
            impl Eq for ::syntax::BareFnArg {}
            impl PartialEq for ::syntax::BareFnArg {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.name == other.name && self.ty == other.ty
                }
            }
            impl Eq for ::syntax::BareVariadic {}
            impl PartialEq for ::syntax::BareVariadic {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.name == other.name && self.comma == other.comma
                }
            }
            impl Eq for ::syntax::BinOp {}
            impl PartialEq for ::syntax::BinOp {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::BinOp::Add(_), ::syntax::BinOp::Add(_)) => true,
                        (::syntax::BinOp::Sub(_), ::syntax::BinOp::Sub(_)) => true,
                        (::syntax::BinOp::Mul(_), ::syntax::BinOp::Mul(_)) => true,
                        (::syntax::BinOp::Div(_), ::syntax::BinOp::Div(_)) => true,
                        (::syntax::BinOp::Rem(_), ::syntax::BinOp::Rem(_)) => true,
                        (::syntax::BinOp::And(_), ::syntax::BinOp::And(_)) => true,
                        (::syntax::BinOp::Or(_), ::syntax::BinOp::Or(_)) => true,
                        (::syntax::BinOp::BitXor(_), ::syntax::BinOp::BitXor(_)) => true,
                        (::syntax::BinOp::BitAnd(_), ::syntax::BinOp::BitAnd(_)) => true,
                        (::syntax::BinOp::BitOr(_), ::syntax::BinOp::BitOr(_)) => true,
                        (::syntax::BinOp::Shl(_), ::syntax::BinOp::Shl(_)) => true,
                        (::syntax::BinOp::Shr(_), ::syntax::BinOp::Shr(_)) => true,
                        (::syntax::BinOp::Eq(_), ::syntax::BinOp::Eq(_)) => true,
                        (::syntax::BinOp::Lt(_), ::syntax::BinOp::Lt(_)) => true,
                        (::syntax::BinOp::Le(_), ::syntax::BinOp::Le(_)) => true,
                        (::syntax::BinOp::Ne(_), ::syntax::BinOp::Ne(_)) => true,
                        (::syntax::BinOp::Ge(_), ::syntax::BinOp::Ge(_)) => true,
                        (::syntax::BinOp::Gt(_), ::syntax::BinOp::Gt(_)) => true,
                        (::syntax::BinOp::AddAssign(_), ::syntax::BinOp::AddAssign(_)) => true,
                        (::syntax::BinOp::SubAssign(_), ::syntax::BinOp::SubAssign(_)) => true,
                        (::syntax::BinOp::MulAssign(_), ::syntax::BinOp::MulAssign(_)) => true,
                        (::syntax::BinOp::DivAssign(_), ::syntax::BinOp::DivAssign(_)) => true,
                        (::syntax::BinOp::RemAssign(_), ::syntax::BinOp::RemAssign(_)) => true,
                        (::syntax::BinOp::BitXorAssign(_), ::syntax::BinOp::BitXorAssign(_)) => true,
                        (::syntax::BinOp::BitAndAssign(_), ::syntax::BinOp::BitAndAssign(_)) => true,
                        (::syntax::BinOp::BitOrAssign(_), ::syntax::BinOp::BitOrAssign(_)) => true,
                        (::syntax::BinOp::ShlAssign(_), ::syntax::BinOp::ShlAssign(_)) => true,
                        (::syntax::BinOp::ShrAssign(_), ::syntax::BinOp::ShrAssign(_)) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Block {}
                impl  PartialEq for ::syntax::Block {
                fn eq(&self, other: &Self) -> bool
        {
                    self.stmts == other.stmts
                }
            }
            impl Eq for ::syntax::BoundLifetimes {}
            impl PartialEq for ::syntax::BoundLifetimes {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetimes == other.lifetimes
                }
            }
                impl  Eq for ::syntax::CapturedParam {}
                impl  PartialEq for ::syntax::CapturedParam {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::CapturedParam::Lifetime(self0),
                            ::syntax::CapturedParam::Lifetime(other0),
                        ) => self0 == other0,
                        (::syntax::CapturedParam::Ident(self0), ::syntax::CapturedParam::Ident(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::ConstParam {}
            impl PartialEq for ::syntax::ConstParam {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident && self.ty == other.ty
                        && self.eq_token == other.eq_token && self.default == other.default
                }
            }
            impl Eq for ::syntax::Constraint {}
            impl PartialEq for ::syntax::Constraint {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.generics == other.generics
                        && self.bounds == other.bounds
                }
            }
            
            impl  Eq for ::syntax::Data {}
            
            impl  PartialEq for ::syntax::Data {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Data::Struct(self0), ::syntax::Data::Struct(other0)) => self0 == other0,
                        (::syntax::Data::Enum(self0), ::syntax::Data::Enum(other0)) => self0 == other0,
                        (::syntax::Data::Union(self0), ::syntax::Data::Union(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
            
            impl  Eq for ::syntax::DataEnum {}
            
            impl  PartialEq for ::syntax::DataEnum {
                fn eq(&self, other: &Self) -> bool
        {
                    self.variants == other.variants
                }
            }
            
            impl  Eq for ::syntax::DataStruct {}
            
            impl  PartialEq for ::syntax::DataStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.fields == other.fields && self.semi_token == other.semi_token
                }
            }
            
            impl  Eq for ::syntax::DataUnion {}
            
            impl  PartialEq for ::syntax::DataUnion {
                fn eq(&self, other: &Self) -> bool
        {
                    self.fields == other.fields
                }
            }
            
            impl  Eq for ::syntax::DeriveInput {}
            
            impl  PartialEq for ::syntax::DeriveInput {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.data == other.data
                }
            }
            impl Eq for ::syntax::Expr {}
            impl PartialEq for ::syntax::Expr {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                                        (::syntax::Expr::Array(self0), ::syntax::Expr::Array(other0)) => self0 == other0,
                                        (::syntax::Expr::Assign(self0), ::syntax::Expr::Assign(other0)) => self0 == other0,
                                        (::syntax::Expr::Async(self0), ::syntax::Expr::Async(other0)) => self0 == other0,
                                        (::syntax::Expr::Await(self0), ::syntax::Expr::Await(other0)) => self0 == other0,
                        (::syntax::Expr::Binary(self0), ::syntax::Expr::Binary(other0)) => self0 == other0,
                                        (::syntax::Expr::Block(self0), ::syntax::Expr::Block(other0)) => self0 == other0,
                                        (::syntax::Expr::Break(self0), ::syntax::Expr::Break(other0)) => self0 == other0,
                        (::syntax::Expr::Call(self0), ::syntax::Expr::Call(other0)) => self0 == other0,
                        (::syntax::Expr::Cast(self0), ::syntax::Expr::Cast(other0)) => self0 == other0,
                                        (::syntax::Expr::Closure(self0), ::syntax::Expr::Closure(other0)) => {
                            self0 == other0
                        }
                                        (::syntax::Expr::Const(self0), ::syntax::Expr::Const(other0)) => self0 == other0,
                                        (::syntax::Expr::Continue(self0), ::syntax::Expr::Continue(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Field(self0), ::syntax::Expr::Field(other0)) => self0 == other0,
                                        (::syntax::Expr::ForLoop(self0), ::syntax::Expr::ForLoop(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Group(self0), ::syntax::Expr::Group(other0)) => self0 == other0,
                                        (::syntax::Expr::If(self0), ::syntax::Expr::If(other0)) => self0 == other0,
                        (::syntax::Expr::Index(self0), ::syntax::Expr::Index(other0)) => self0 == other0,
                                        (::syntax::Expr::Infer(self0), ::syntax::Expr::Infer(other0)) => self0 == other0,
                                        (::syntax::Expr::Let(self0), ::syntax::Expr::Let(other0)) => self0 == other0,
                        (::syntax::Expr::Lit(self0), ::syntax::Expr::Lit(other0)) => self0 == other0,
                                        (::syntax::Expr::Loop(self0), ::syntax::Expr::Loop(other0)) => self0 == other0,
                        (::syntax::Expr::Macro(self0), ::syntax::Expr::Macro(other0)) => self0 == other0,
                                        (::syntax::Expr::Match(self0), ::syntax::Expr::Match(other0)) => self0 == other0,
                        (::syntax::Expr::MethodCall(self0), ::syntax::Expr::MethodCall(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Paren(self0), ::syntax::Expr::Paren(other0)) => self0 == other0,
                        (::syntax::Expr::Path(self0), ::syntax::Expr::Path(other0)) => self0 == other0,
                                        (::syntax::Expr::Range(self0), ::syntax::Expr::Range(other0)) => self0 == other0,
                                        (::syntax::Expr::RawAddr(self0), ::syntax::Expr::RawAddr(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Reference(self0), ::syntax::Expr::Reference(other0)) => {
                            self0 == other0
                        }
                                        (::syntax::Expr::Repeat(self0), ::syntax::Expr::Repeat(other0)) => self0 == other0,
                                        (::syntax::Expr::Return(self0), ::syntax::Expr::Return(other0)) => self0 == other0,
                        (::syntax::Expr::Struct(self0), ::syntax::Expr::Struct(other0)) => self0 == other0,
                                        (::syntax::Expr::Try(self0), ::syntax::Expr::Try(other0)) => self0 == other0,
                                        (::syntax::Expr::TryBlock(self0), ::syntax::Expr::TryBlock(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Tuple(self0), ::syntax::Expr::Tuple(other0)) => self0 == other0,
                        (::syntax::Expr::Unary(self0), ::syntax::Expr::Unary(other0)) => self0 == other0,
                                        (::syntax::Expr::Unsafe(self0), ::syntax::Expr::Unsafe(other0)) => self0 == other0,
                        (::syntax::Expr::Verbatim(self0), ::syntax::Expr::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                                        (::syntax::Expr::While(self0), ::syntax::Expr::While(other0)) => self0 == other0,
                                        (::syntax::Expr::Yield(self0), ::syntax::Expr::Yield(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ExprArray {}
                impl  PartialEq for ::syntax::ExprArray {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.elems == other.elems
                }
            }
                impl  Eq for ::syntax::ExprAssign {}
                impl  PartialEq for ::syntax::ExprAssign {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.left == other.left && self.right == other.right
                }
            }
                impl  Eq for ::syntax::ExprAsync {}
                impl  PartialEq for ::syntax::ExprAsync {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.capture == other.capture
                        && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ExprAwait {}
                impl  PartialEq for ::syntax::ExprAwait {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.base == other.base
                }
            }
            impl Eq for ::syntax::ExprBinary {}
            impl PartialEq for ::syntax::ExprBinary {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.left == other.left && self.op == other.op
                        && self.right == other.right
                }
            }
                impl  Eq for ::syntax::ExprBlock {}
                impl  PartialEq for ::syntax::ExprBlock {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label
                        && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ExprBreak {}
                impl  PartialEq for ::syntax::ExprBreak {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprCall {}
            impl PartialEq for ::syntax::ExprCall {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.func == other.func && self.args == other.args
                }
            }
            impl Eq for ::syntax::ExprCast {}
            impl PartialEq for ::syntax::ExprCast {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::ExprClosure {}
                impl  PartialEq for ::syntax::ExprClosure {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.lifetimes == other.lifetimes
                        && self.constness == other.constness && self.movability == other.movability
                        && self.asyncness == other.asyncness && self.capture == other.capture
                        && self.inputs == other.inputs && self.output == other.output
                        && self.body == other.body
                }
            }
                impl  Eq for ::syntax::ExprConst {}
                impl  PartialEq for ::syntax::ExprConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ExprContinue {}
                impl  PartialEq for ::syntax::ExprContinue {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label
                }
            }
            impl Eq for ::syntax::ExprField {}
            impl PartialEq for ::syntax::ExprField {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.base == other.base
                        && self.member == other.member
                }
            }
                impl  Eq for ::syntax::ExprForLoop {}
                impl  PartialEq for ::syntax::ExprForLoop {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label && self.pat == other.pat
                        && self.expr == other.expr && self.body == other.body
                }
            }
            impl Eq for ::syntax::ExprGroup {}
            impl PartialEq for ::syntax::ExprGroup {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ExprIf {}
                impl  PartialEq for ::syntax::ExprIf {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.cond == other.cond
                        && self.then_branch == other.then_branch
                        && self.else_branch == other.else_branch
                }
            }
            impl Eq for ::syntax::ExprIndex {}
            impl PartialEq for ::syntax::ExprIndex {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr && self.index == other.index
                }
            }
                impl  Eq for ::syntax::ExprInfer {}
                impl  PartialEq for ::syntax::ExprInfer {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs
                }
            }
                impl  Eq for ::syntax::ExprLet {}
                impl  PartialEq for ::syntax::ExprLet {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprLit {}
            impl PartialEq for ::syntax::ExprLit {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.lit == other.lit
                }
            }
                impl  Eq for ::syntax::ExprLoop {}
                impl  PartialEq for ::syntax::ExprLoop {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label && self.body == other.body
                }
            }
            impl Eq for ::syntax::ExprMacro {}
            impl PartialEq for ::syntax::ExprMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                }
            }
                impl  Eq for ::syntax::ExprMatch {}
                impl  PartialEq for ::syntax::ExprMatch {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr && self.arms == other.arms
                }
            }
            impl Eq for ::syntax::ExprMethodCall {}
            impl PartialEq for ::syntax::ExprMethodCall {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.receiver == other.receiver
                        && self.method == other.method && self.turbofish == other.turbofish
                        && self.args == other.args
                }
            }
            impl Eq for ::syntax::ExprParen {}
            impl PartialEq for ::syntax::ExprParen {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprPath {}
            impl PartialEq for ::syntax::ExprPath {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.qself == other.qself && self.path == other.path
                }
            }
                impl  Eq for ::syntax::ExprRange {}
                impl  PartialEq for ::syntax::ExprRange {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.start == other.start
                        && self.limits == other.limits && self.end == other.end
                }
            }
                impl  Eq for ::syntax::ExprRawAddr {}
                impl  PartialEq for ::syntax::ExprRawAddr {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mutability == other.mutability
                        && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprReference {}
            impl PartialEq for ::syntax::ExprReference {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mutability == other.mutability
                        && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ExprRepeat {}
                impl  PartialEq for ::syntax::ExprRepeat {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr && self.len == other.len
                }
            }
                impl  Eq for ::syntax::ExprReturn {}
                impl  PartialEq for ::syntax::ExprReturn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprStruct {}
            impl PartialEq for ::syntax::ExprStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.qself == other.qself && self.path == other.path
                        && self.fields == other.fields && self.dot2_token == other.dot2_token
                        && self.rest == other.rest
                }
            }
                impl  Eq for ::syntax::ExprTry {}
                impl  PartialEq for ::syntax::ExprTry {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ExprTryBlock {}
                impl  PartialEq for ::syntax::ExprTryBlock {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.block == other.block
                }
            }
            impl Eq for ::syntax::ExprTuple {}
            impl PartialEq for ::syntax::ExprTuple {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.elems == other.elems
                }
            }
            impl Eq for ::syntax::ExprUnary {}
            impl PartialEq for ::syntax::ExprUnary {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.op == other.op && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ExprUnsafe {}
                impl  PartialEq for ::syntax::ExprUnsafe {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ExprWhile {}
                impl  PartialEq for ::syntax::ExprWhile {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label && self.cond == other.cond
                        && self.body == other.body
                }
            }
                impl  Eq for ::syntax::ExprYield {}
                impl  PartialEq for ::syntax::ExprYield {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::Field {}
            impl PartialEq for ::syntax::Field {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.mutability == other.mutability && self.ident == other.ident
                        && self.colon_token == other.colon_token && self.ty == other.ty
                }
            }
            impl Eq for ::syntax::FieldMutability {}
            impl PartialEq for ::syntax::FieldMutability {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::FieldMutability::None, ::syntax::FieldMutability::None) => true,
                    }
                }
            }
                impl  Eq for ::syntax::FieldPat {}
                impl  PartialEq for ::syntax::FieldPat {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.member == other.member
                        && self.colon_token == other.colon_token && self.pat == other.pat
                }
            }
            impl Eq for ::syntax::FieldValue {}
            impl PartialEq for ::syntax::FieldValue {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.member == other.member
                        && self.colon_token == other.colon_token && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::Fields {}
            impl PartialEq for ::syntax::Fields {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Fields::Named(self0), ::syntax::Fields::Named(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Fields::Unnamed(self0), ::syntax::Fields::Unnamed(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Fields::Unit, ::syntax::Fields::Unit) => true,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::FieldsNamed {}
            impl PartialEq for ::syntax::FieldsNamed {
                fn eq(&self, other: &Self) -> bool
        {
                    self.named == other.named
                }
            }
            impl Eq for ::syntax::FieldsUnnamed {}
            impl PartialEq for ::syntax::FieldsUnnamed {
                fn eq(&self, other: &Self) -> bool
        {
                    self.unnamed == other.unnamed
                }
            }
                impl  Eq for ::syntax::File {}
                impl  PartialEq for ::syntax::File {
                fn eq(&self, other: &Self) -> bool
        {
                    self.shebang == other.shebang && self.attrs == other.attrs
                        && self.items == other.items
                }
            }
                impl  Eq for ::syntax::FnArg {}
                impl  PartialEq for ::syntax::FnArg {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::FnArg::Receiver(self0), ::syntax::FnArg::Receiver(other0)) => {
                            self0 == other0
                        }
                        (::syntax::FnArg::Typed(self0), ::syntax::FnArg::Typed(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ForeignItem {}
                impl  PartialEq for ::syntax::ForeignItem {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::ForeignItem::Fn(self0), ::syntax::ForeignItem::Fn(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ForeignItem::Static(self0), ::syntax::ForeignItem::Static(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ForeignItem::Type(self0), ::syntax::ForeignItem::Type(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ForeignItem::Macro(self0), ::syntax::ForeignItem::Macro(other0)) => {
                            self0 == other0
                        }
                        (
                            ::syntax::ForeignItem::Verbatim(self0),
                            ::syntax::ForeignItem::Verbatim(other0),
                        ) => TokenStreamHelper(self0) == TokenStreamHelper(other0),
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ForeignItemFn {}
                impl  PartialEq for ::syntax::ForeignItemFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.sig == other.sig
                }
            }
                impl  Eq for ::syntax::ForeignItemMacro {}
                impl  PartialEq for ::syntax::ForeignItemMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::ForeignItemStatic {}
                impl  PartialEq for ::syntax::ForeignItemStatic {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.mutability == other.mutability && self.ident == other.ident
                        && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::ForeignItemType {}
                impl  PartialEq for ::syntax::ForeignItemType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics
                }
            }
            impl Eq for ::syntax::GenericArgument {}
            impl PartialEq for ::syntax::GenericArgument {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::GenericArgument::Lifetime(self0),
                            ::syntax::GenericArgument::Lifetime(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::Type(self0),
                            ::syntax::GenericArgument::Type(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::Const(self0),
                            ::syntax::GenericArgument::Const(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::AssocType(self0),
                            ::syntax::GenericArgument::AssocType(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::AssocConst(self0),
                            ::syntax::GenericArgument::AssocConst(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::Constraint(self0),
                            ::syntax::GenericArgument::Constraint(other0),
                        ) => self0 == other0,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::GenericParam {}
            impl PartialEq for ::syntax::GenericParam {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::GenericParam::Lifetime(self0),
                            ::syntax::GenericParam::Lifetime(other0),
                        ) => self0 == other0,
                        (::syntax::GenericParam::Type(self0), ::syntax::GenericParam::Type(other0)) => {
                            self0 == other0
                        }
                        (::syntax::GenericParam::Const(self0), ::syntax::GenericParam::Const(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::Generics {}
            impl PartialEq for ::syntax::Generics {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lt_token == other.lt_token && self.params == other.params
                        && self.gt_token == other.gt_token && self.where_clause == other.where_clause
                }
            }
                impl  Eq for ::syntax::ImplItem {}
                impl  PartialEq for ::syntax::ImplItem {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::ImplItem::Const(self0), ::syntax::ImplItem::Const(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ImplItem::Fn(self0), ::syntax::ImplItem::Fn(other0)) => self0 == other0,
                        (::syntax::ImplItem::Type(self0), ::syntax::ImplItem::Type(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ImplItem::Macro(self0), ::syntax::ImplItem::Macro(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ImplItem::Verbatim(self0), ::syntax::ImplItem::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ImplItemConst {}
                impl  PartialEq for ::syntax::ImplItemConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.defaultness == other.defaultness && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                        && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ImplItemFn {}
                impl  PartialEq for ::syntax::ImplItemFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.defaultness == other.defaultness && self.sig == other.sig
                        && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ImplItemMacro {}
                impl  PartialEq for ::syntax::ImplItemMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::ImplItemType {}
                impl  PartialEq for ::syntax::ImplItemType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.defaultness == other.defaultness && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::ImplRestriction {}
                impl  PartialEq for ::syntax::ImplRestriction {
                fn eq(&self, _other: &Self) -> bool
        {
                    match *self {}
                }
            }
                impl  Eq for ::syntax::Item {}
                impl  PartialEq for ::syntax::Item {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Item::Const(self0), ::syntax::Item::Const(other0)) => self0 == other0,
                        (::syntax::Item::Enum(self0), ::syntax::Item::Enum(other0)) => self0 == other0,
                        (::syntax::Item::ExternCrate(self0), ::syntax::Item::ExternCrate(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Item::Fn(self0), ::syntax::Item::Fn(other0)) => self0 == other0,
                        (::syntax::Item::ForeignMod(self0), ::syntax::Item::ForeignMod(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Item::Impl(self0), ::syntax::Item::Impl(other0)) => self0 == other0,
                        (::syntax::Item::Macro(self0), ::syntax::Item::Macro(other0)) => self0 == other0,
                        (::syntax::Item::Mod(self0), ::syntax::Item::Mod(other0)) => self0 == other0,
                        (::syntax::Item::Static(self0), ::syntax::Item::Static(other0)) => self0 == other0,
                        (::syntax::Item::Struct(self0), ::syntax::Item::Struct(other0)) => self0 == other0,
                        (::syntax::Item::Trait(self0), ::syntax::Item::Trait(other0)) => self0 == other0,
                        (::syntax::Item::TraitAlias(self0), ::syntax::Item::TraitAlias(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Item::Type(self0), ::syntax::Item::Type(other0)) => self0 == other0,
                        (::syntax::Item::Union(self0), ::syntax::Item::Union(other0)) => self0 == other0,
                        (::syntax::Item::Use(self0), ::syntax::Item::Use(other0)) => self0 == other0,
                        (::syntax::Item::Verbatim(self0), ::syntax::Item::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ItemConst {}
                impl  PartialEq for ::syntax::ItemConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                        && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ItemEnum {}
                impl  PartialEq for ::syntax::ItemEnum {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.variants == other.variants
                }
            }
                impl  Eq for ::syntax::ItemExternCrate {}
                impl  PartialEq for ::syntax::ItemExternCrate {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.rename == other.rename
                }
            }
                impl  Eq for ::syntax::ItemFn {}
                impl  PartialEq for ::syntax::ItemFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.sig == other.sig
                        && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ItemForeignMod {}
                impl  PartialEq for ::syntax::ItemForeignMod {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.unsafety == other.unsafety
                        && self.abi == other.abi && self.items == other.items
                }
            }
                impl  Eq for ::syntax::ItemImpl {}
                impl  PartialEq for ::syntax::ItemImpl {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.defaultness == other.defaultness
                        && self.unsafety == other.unsafety && self.generics == other.generics
                        && self.trait_ == other.trait_ && self.self_ty == other.self_ty
                        && self.items == other.items
                }
            }
                impl  Eq for ::syntax::ItemMacro {}
                impl  PartialEq for ::syntax::ItemMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::ItemMod {}
                impl  PartialEq for ::syntax::ItemMod {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.unsafety == other.unsafety && self.ident == other.ident
                        && self.content == other.content && self.semi == other.semi
                }
            }
                impl  Eq for ::syntax::ItemStatic {}
                impl  PartialEq for ::syntax::ItemStatic {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.mutability == other.mutability && self.ident == other.ident
                        && self.ty == other.ty && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ItemStruct {}
                impl  PartialEq for ::syntax::ItemStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.fields == other.fields
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::ItemTrait {}
                impl  PartialEq for ::syntax::ItemTrait {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.unsafety == other.unsafety && self.auto_token == other.auto_token
                        && self.restriction == other.restriction && self.ident == other.ident
                        && self.generics == other.generics && self.colon_token == other.colon_token
                        && self.supertraits == other.supertraits && self.items == other.items
                }
            }
                impl  Eq for ::syntax::ItemTraitAlias {}
                impl  PartialEq for ::syntax::ItemTraitAlias {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.bounds == other.bounds
                }
            }
                impl  Eq for ::syntax::ItemType {}
                impl  PartialEq for ::syntax::ItemType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::ItemUnion {}
                impl  PartialEq for ::syntax::ItemUnion {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.fields == other.fields
                }
            }
                impl  Eq for ::syntax::ItemUse {}
                impl  PartialEq for ::syntax::ItemUse {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.leading_colon == other.leading_colon && self.tree == other.tree
                }
            }
                impl  Eq for ::syntax::Label {}
                impl  PartialEq for ::syntax::Label {
                fn eq(&self, other: &Self) -> bool
        {
                    self.name == other.name
                }
            }
            impl Eq for ::syntax::LifetimeParam {}
            impl PartialEq for ::syntax::LifetimeParam {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.lifetime == other.lifetime
                        && self.colon_token == other.colon_token && self.bounds == other.bounds
                }
            }
            impl  Eq for ::syntax::Lit {}
            impl  PartialEq for ::syntax::Lit {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Lit::Str(self0), ::syntax::Lit::Str(other0)) => self0 == other0,
                        (::syntax::Lit::ByteStr(self0), ::syntax::Lit::ByteStr(other0)) => self0 == other0,
                        (::syntax::Lit::CStr(self0), ::syntax::Lit::CStr(other0)) => self0 == other0,
                        (::syntax::Lit::Byte(self0), ::syntax::Lit::Byte(other0)) => self0 == other0,
                        (::syntax::Lit::Char(self0), ::syntax::Lit::Char(other0)) => self0 == other0,
                        (::syntax::Lit::Int(self0), ::syntax::Lit::Int(other0)) => self0 == other0,
                        (::syntax::Lit::Float(self0), ::syntax::Lit::Float(other0)) => self0 == other0,
                        (::syntax::Lit::Bool(self0), ::syntax::Lit::Bool(other0)) => self0 == other0,
                        (::syntax::Lit::Verbatim(self0), ::syntax::Lit::Verbatim(other0)) => {
                            self0.to_string() == other0.to_string()
                        }
                        _ => false,
                    }
                }
            }
            impl  Eq for ::syntax::LitBool {}
            impl  PartialEq for ::syntax::LitBool {
                fn eq(&self, other: &Self) -> bool
        {
                    self.value == other.value
                }
            }
            impl  Eq for ::syntax::LitByte {}
            impl  Eq for ::syntax::LitByteStr {}
            impl  Eq for ::syntax::LitCStr {}
            impl  Eq for ::syntax::LitChar {}
            impl  Eq for ::syntax::LitFloat {}
            impl  Eq for ::syntax::LitInt {}
            impl  Eq for ::syntax::LitStr {}
                impl  Eq for ::syntax::Local {}
                impl  PartialEq for ::syntax::Local {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.init == other.init
                }
            }
                impl  Eq for ::syntax::LocalInit {}
                impl  PartialEq for ::syntax::LocalInit {
                fn eq(&self, other: &Self) -> bool
        {
                    self.expr == other.expr && self.diverge == other.diverge
                }
            }
            impl Eq for ::syntax::Macro {}
            impl PartialEq for ::syntax::Macro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.path == other.path && self.delimiter == other.delimiter
                        && TokenStreamHelper(&self.tokens) == TokenStreamHelper(&other.tokens)
                }
            }
            impl Eq for ::syntax::MacroDelimiter {}
            impl PartialEq for ::syntax::MacroDelimiter {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::MacroDelimiter::Paren(_), ::syntax::MacroDelimiter::Paren(_)) => true,
                        (::syntax::MacroDelimiter::Brace(_), ::syntax::MacroDelimiter::Brace(_)) => true,
                        (::syntax::MacroDelimiter::Bracket(_), ::syntax::MacroDelimiter::Bracket(_)) => {
                            true
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::Meta {}
            impl PartialEq for ::syntax::Meta {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Meta::Path(self0), ::syntax::Meta::Path(other0)) => self0 == other0,
                        (::syntax::Meta::List(self0), ::syntax::Meta::List(other0)) => self0 == other0,
                        (::syntax::Meta::NameValue(self0), ::syntax::Meta::NameValue(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::MetaList {}
            impl PartialEq for ::syntax::MetaList {
                fn eq(&self, other: &Self) -> bool
        {
                    self.path == other.path && self.delimiter == other.delimiter
                        && TokenStreamHelper(&self.tokens) == TokenStreamHelper(&other.tokens)
                }
            }
            impl Eq for ::syntax::MetaNameValue {}
            impl PartialEq for ::syntax::MetaNameValue {
                fn eq(&self, other: &Self) -> bool
        {
                    self.path == other.path && self.value == other.value
                }
            }
            impl Eq for ::syntax::ParenthesizedGenericArguments {}
            impl PartialEq for ::syntax::ParenthesizedGenericArguments {
                fn eq(&self, other: &Self) -> bool
        {
                    self.inputs == other.inputs && self.output == other.output
                }
            }
                impl  Eq for ::syntax::Pat {}
                impl  PartialEq for ::syntax::Pat {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Pat::Const(self0), ::syntax::Pat::Const(other0)) => self0 == other0,
                        (::syntax::Pat::Ident(self0), ::syntax::Pat::Ident(other0)) => self0 == other0,
                        (::syntax::Pat::Lit(self0), ::syntax::Pat::Lit(other0)) => self0 == other0,
                        (::syntax::Pat::Macro(self0), ::syntax::Pat::Macro(other0)) => self0 == other0,
                        (::syntax::Pat::Or(self0), ::syntax::Pat::Or(other0)) => self0 == other0,
                        (::syntax::Pat::Paren(self0), ::syntax::Pat::Paren(other0)) => self0 == other0,
                        (::syntax::Pat::Path(self0), ::syntax::Pat::Path(other0)) => self0 == other0,
                        (::syntax::Pat::Range(self0), ::syntax::Pat::Range(other0)) => self0 == other0,
                        (::syntax::Pat::Reference(self0), ::syntax::Pat::Reference(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Pat::Rest(self0), ::syntax::Pat::Rest(other0)) => self0 == other0,
                        (::syntax::Pat::Slice(self0), ::syntax::Pat::Slice(other0)) => self0 == other0,
                        (::syntax::Pat::Struct(self0), ::syntax::Pat::Struct(other0)) => self0 == other0,
                        (::syntax::Pat::Tuple(self0), ::syntax::Pat::Tuple(other0)) => self0 == other0,
                        (::syntax::Pat::TupleStruct(self0), ::syntax::Pat::TupleStruct(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Pat::Type(self0), ::syntax::Pat::Type(other0)) => self0 == other0,
                        (::syntax::Pat::Verbatim(self0), ::syntax::Pat::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        (::syntax::Pat::Wild(self0), ::syntax::Pat::Wild(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::PatIdent {}
                impl  PartialEq for ::syntax::PatIdent {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.by_ref == other.by_ref
                        && self.mutability == other.mutability && self.ident == other.ident
                        && self.subpat == other.subpat
                }
            }
                impl  Eq for ::syntax::PatOr {}
                impl  PartialEq for ::syntax::PatOr {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.leading_vert == other.leading_vert
                        && self.cases == other.cases
                }
            }
                impl  Eq for ::syntax::PatParen {}
                impl  PartialEq for ::syntax::PatParen {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat
                }
            }
                impl  Eq for ::syntax::PatReference {}
                impl  PartialEq for ::syntax::PatReference {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mutability == other.mutability
                        && self.pat == other.pat
                }
            }
                impl  Eq for ::syntax::PatRest {}
                impl  PartialEq for ::syntax::PatRest {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs
                }
            }
                impl  Eq for ::syntax::PatSlice {}
                impl  PartialEq for ::syntax::PatSlice {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.elems == other.elems
                }
            }
                impl  Eq for ::syntax::PatStruct {}
                impl  PartialEq for ::syntax::PatStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.qself == other.qself && self.path == other.path
                        && self.fields == other.fields && self.rest == other.rest
                }
            }
                impl  Eq for ::syntax::PatTuple {}
                impl  PartialEq for ::syntax::PatTuple {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.elems == other.elems
                }
            }
                impl  Eq for ::syntax::PatTupleStruct {}
                impl  PartialEq for ::syntax::PatTupleStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.qself == other.qself && self.path == other.path
                        && self.elems == other.elems
                }
            }
                impl  Eq for ::syntax::PatType {}
                impl  PartialEq for ::syntax::PatType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::PatWild {}
                impl  PartialEq for ::syntax::PatWild {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs
                }
            }
            impl Eq for ::syntax::Path {}
            impl PartialEq for ::syntax::Path {
                fn eq(&self, other: &Self) -> bool
        {
                    self.leading_colon == other.leading_colon && self.segments == other.segments
                }
            }
            impl Eq for ::syntax::PathArguments {}
            impl PartialEq for ::syntax::PathArguments {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::PathArguments::None, ::syntax::PathArguments::None) => true,
                        (
                            ::syntax::PathArguments::AngleBracketed(self0),
                            ::syntax::PathArguments::AngleBracketed(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::PathArguments::Parenthesized(self0),
                            ::syntax::PathArguments::Parenthesized(other0),
                        ) => self0 == other0,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::PathSegment {}
            impl PartialEq for ::syntax::PathSegment {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.arguments == other.arguments
                }
            }
                impl  Eq for ::syntax::PointerMutability {}
                impl  PartialEq for ::syntax::PointerMutability {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::PointerMutability::Const(_), ::syntax::PointerMutability::Const(_)) => {
                            true
                        }
                        (::syntax::PointerMutability::Mut(_), ::syntax::PointerMutability::Mut(_)) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::PreciseCapture {}
                impl  PartialEq for ::syntax::PreciseCapture {
                fn eq(&self, other: &Self) -> bool
        {
                    self.params == other.params
                }
            }
            impl Eq for ::syntax::PredicateLifetime {}
            impl PartialEq for ::syntax::PredicateLifetime {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetime == other.lifetime && self.bounds == other.bounds
                }
            }
            impl Eq for ::syntax::PredicateType {}
            impl PartialEq for ::syntax::PredicateType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetimes == other.lifetimes && self.bounded_ty == other.bounded_ty
                        && self.bounds == other.bounds
                }
            }
            impl Eq for ::syntax::QSelf {}
            impl PartialEq for ::syntax::QSelf {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ty == other.ty && self.position == other.position
                        && self.as_token == other.as_token
                }
            }
                impl  Eq for ::syntax::RangeLimits {}
                impl  PartialEq for ::syntax::RangeLimits {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::RangeLimits::HalfOpen(_), ::syntax::RangeLimits::HalfOpen(_)) => true,
                        (::syntax::RangeLimits::Closed(_), ::syntax::RangeLimits::Closed(_)) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Receiver {}
                impl  PartialEq for ::syntax::Receiver {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.reference == other.reference
                        && self.mutability == other.mutability
                        && self.colon_token == other.colon_token && self.ty == other.ty
                }
            }
            impl Eq for ::syntax::ReturnType {}
            impl PartialEq for ::syntax::ReturnType {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::ReturnType::Default, ::syntax::ReturnType::Default) => true,
                        (::syntax::ReturnType::Type(_, self1), ::syntax::ReturnType::Type(_, other1)) => {
                            self1 == other1
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Signature {}
                impl  PartialEq for ::syntax::Signature {
                fn eq(&self, other: &Self) -> bool
        {
                    self.constness == other.constness && self.asyncness == other.asyncness
                        && self.unsafety == other.unsafety && self.abi == other.abi
                        && self.ident == other.ident && self.generics == other.generics
                        && self.inputs == other.inputs && self.variadic == other.variadic
                        && self.output == other.output
                }
            }
                impl  Eq for ::syntax::StaticMutability {}
                impl  PartialEq for ::syntax::StaticMutability {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::StaticMutability::Mut(_), ::syntax::StaticMutability::Mut(_)) => true,
                        (::syntax::StaticMutability::None, ::syntax::StaticMutability::None) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Stmt {}
                impl  PartialEq for ::syntax::Stmt {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Stmt::Local(self0), ::syntax::Stmt::Local(other0)) => self0 == other0,
                        (::syntax::Stmt::Item(self0), ::syntax::Stmt::Item(other0)) => self0 == other0,
                        (::syntax::Stmt::Expr(self0, self1), ::syntax::Stmt::Expr(other0, other1)) => {
                            self0 == other0 && self1 == other1
                        }
                        (::syntax::Stmt::Macro(self0), ::syntax::Stmt::Macro(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::StmtMacro {}
                impl  PartialEq for ::syntax::StmtMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
            impl Eq for ::syntax::TraitBound {}
            impl PartialEq for ::syntax::TraitBound {
                fn eq(&self, other: &Self) -> bool
        {
                    self.paren_token == other.paren_token && self.modifier == other.modifier
                        && self.lifetimes == other.lifetimes && self.path == other.path
                }
            }
            impl Eq for ::syntax::TraitBoundModifier {}
            impl PartialEq for ::syntax::TraitBoundModifier {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::TraitBoundModifier::None, ::syntax::TraitBoundModifier::None) => true,
                        (
                            ::syntax::TraitBoundModifier::Maybe(_),
                            ::syntax::TraitBoundModifier::Maybe(_),
                        ) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::TraitItem {}
                impl  PartialEq for ::syntax::TraitItem {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::TraitItem::Const(self0), ::syntax::TraitItem::Const(other0)) => {
                            self0 == other0
                        }
                        (::syntax::TraitItem::Fn(self0), ::syntax::TraitItem::Fn(other0)) => {
                            self0 == other0
                        }
                        (::syntax::TraitItem::Type(self0), ::syntax::TraitItem::Type(other0)) => {
                            self0 == other0
                        }
                        (::syntax::TraitItem::Macro(self0), ::syntax::TraitItem::Macro(other0)) => {
                            self0 == other0
                        }
                        (::syntax::TraitItem::Verbatim(self0), ::syntax::TraitItem::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::TraitItemConst {}
                impl  PartialEq for ::syntax::TraitItemConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                        && self.default == other.default
                }
            }
                impl  Eq for ::syntax::TraitItemFn {}
                impl  PartialEq for ::syntax::TraitItemFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.sig == other.sig
                        && self.default == other.default && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::TraitItemMacro {}
                impl  PartialEq for ::syntax::TraitItemMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::TraitItemType {}
                impl  PartialEq for ::syntax::TraitItemType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident
                        && self.generics == other.generics && self.colon_token == other.colon_token
                        && self.bounds == other.bounds && self.default == other.default
                }
            }
            impl Eq for ::syntax::Type {}
            impl PartialEq for ::syntax::Type {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Type::Array(self0), ::syntax::Type::Array(other0)) => self0 == other0,
                        (::syntax::Type::BareFn(self0), ::syntax::Type::BareFn(other0)) => self0 == other0,
                        (::syntax::Type::Group(self0), ::syntax::Type::Group(other0)) => self0 == other0,
                        (::syntax::Type::ImplTrait(self0), ::syntax::Type::ImplTrait(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Type::Infer(self0), ::syntax::Type::Infer(other0)) => self0 == other0,
                        (::syntax::Type::Macro(self0), ::syntax::Type::Macro(other0)) => self0 == other0,
                        (::syntax::Type::Never(self0), ::syntax::Type::Never(other0)) => self0 == other0,
                        (::syntax::Type::Paren(self0), ::syntax::Type::Paren(other0)) => self0 == other0,
                        (::syntax::Type::Path(self0), ::syntax::Type::Path(other0)) => self0 == other0,
                        (::syntax::Type::Ptr(self0), ::syntax::Type::Ptr(other0)) => self0 == other0,
                        (::syntax::Type::Reference(self0), ::syntax::Type::Reference(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Type::Slice(self0), ::syntax::Type::Slice(other0)) => self0 == other0,
                        (::syntax::Type::TraitObject(self0), ::syntax::Type::TraitObject(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Type::Tuple(self0), ::syntax::Type::Tuple(other0)) => self0 == other0,
                        (::syntax::Type::Verbatim(self0), ::syntax::Type::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::TypeArray {}
            impl PartialEq for ::syntax::TypeArray {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elem == other.elem && self.len == other.len
                }
            }
            impl Eq for ::syntax::TypeBareFn {}
            impl PartialEq for ::syntax::TypeBareFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetimes == other.lifetimes && self.unsafety == other.unsafety
                        && self.abi == other.abi && self.inputs == other.inputs
                        && self.variadic == other.variadic && self.output == other.output
                }
            }
            impl Eq for ::syntax::TypeGroup {}
            impl PartialEq for ::syntax::TypeGroup {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypeImplTrait {}
            impl PartialEq for ::syntax::TypeImplTrait {
                fn eq(&self, other: &Self) -> bool
        {
                    self.bounds == other.bounds
                }
            }
            impl Eq for ::syntax::TypeInfer {}
            impl PartialEq for ::syntax::TypeInfer {
                fn eq(&self, _other: &Self) -> bool
        {
                    true
                }
            }
            impl Eq for ::syntax::TypeMacro {}
            impl PartialEq for ::syntax::TypeMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.mac == other.mac
                }
            }
            impl Eq for ::syntax::TypeNever {}
            impl PartialEq for ::syntax::TypeNever {
                fn eq(&self, _other: &Self) -> bool
        {
                    true
                }
            }
            impl Eq for ::syntax::TypeParam {}
            impl PartialEq for ::syntax::TypeParam {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident
                        && self.colon_token == other.colon_token && self.bounds == other.bounds
                        && self.eq_token == other.eq_token && self.default == other.default
                }
            }
            impl Eq for ::syntax::TypeParamBound {}
            impl PartialEq for ::syntax::TypeParamBound {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::TypeParamBound::Trait(self0),
                            ::syntax::TypeParamBound::Trait(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::TypeParamBound::Lifetime(self0),
                            ::syntax::TypeParamBound::Lifetime(other0),
                        ) => self0 == other0,
                                        (
                            ::syntax::TypeParamBound::PreciseCapture(self0),
                            ::syntax::TypeParamBound::PreciseCapture(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::TypeParamBound::Verbatim(self0),
                            ::syntax::TypeParamBound::Verbatim(other0),
                        ) => TokenStreamHelper(self0) == TokenStreamHelper(other0),
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::TypeParen {}
            impl PartialEq for ::syntax::TypeParen {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypePath {}
            impl PartialEq for ::syntax::TypePath {
                fn eq(&self, other: &Self) -> bool
        {
                    self.qself == other.qself && self.path == other.path
                }
            }
            impl Eq for ::syntax::TypePtr {}
            impl PartialEq for ::syntax::TypePtr {
                fn eq(&self, other: &Self) -> bool
        {
                    self.const_token == other.const_token && self.mutability == other.mutability
                        && self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypeReference {}
            impl PartialEq for ::syntax::TypeReference {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetime == other.lifetime && self.mutability == other.mutability
                        && self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypeSlice {}
            impl PartialEq for ::syntax::TypeSlice {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypeTraitObject {}
            impl PartialEq for ::syntax::TypeTraitObject {
                fn eq(&self, other: &Self) -> bool
        {
                    self.dyn_token == other.dyn_token && self.bounds == other.bounds
                }
            }
            impl Eq for ::syntax::TypeTuple {}
            impl PartialEq for ::syntax::TypeTuple {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elems == other.elems
                }
            }
            impl Eq for ::syntax::UnOp {}
            impl PartialEq for ::syntax::UnOp {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::UnOp::Deref(_), ::syntax::UnOp::Deref(_)) => true,
                        (::syntax::UnOp::Not(_), ::syntax::UnOp::Not(_)) => true,
                        (::syntax::UnOp::Neg(_), ::syntax::UnOp::Neg(_)) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::UseGlob {}
                impl  PartialEq for ::syntax::UseGlob {
                fn eq(&self, _other: &Self) -> bool
        {
                    true
                }
            }
                impl  Eq for ::syntax::UseGroup {}
                impl  PartialEq for ::syntax::UseGroup {
                fn eq(&self, other: &Self) -> bool
        {
                    self.items == other.items
                }
            }
                impl  Eq for ::syntax::UseName {}
                impl  PartialEq for ::syntax::UseName {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident
                }
            }
                impl  Eq for ::syntax::UsePath {}
                impl  PartialEq for ::syntax::UsePath {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.tree == other.tree
                }
            }
                impl  Eq for ::syntax::UseRename {}
                impl  PartialEq for ::syntax::UseRename {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.rename == other.rename
                }
            }
                impl  Eq for ::syntax::UseTree {}
                impl  PartialEq for ::syntax::UseTree {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::UseTree::Path(self0), ::syntax::UseTree::Path(other0)) => {
                            self0 == other0
                        }
                        (::syntax::UseTree::Name(self0), ::syntax::UseTree::Name(other0)) => {
                            self0 == other0
                        }
                        (::syntax::UseTree::Rename(self0), ::syntax::UseTree::Rename(other0)) => {
                            self0 == other0
                        }
                        (::syntax::UseTree::Glob(self0), ::syntax::UseTree::Glob(other0)) => {
                            self0 == other0
                        }
                        (::syntax::UseTree::Group(self0), ::syntax::UseTree::Group(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Variadic {}
                impl  PartialEq for ::syntax::Variadic {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.comma == other.comma
                }
            }
            impl Eq for ::syntax::Variant {}
            impl PartialEq for ::syntax::Variant {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident
                        && self.fields == other.fields && self.discriminant == other.discriminant
                }
            }
            impl Eq for ::syntax::VisRestricted {}
            impl PartialEq for ::syntax::VisRestricted {
                fn eq(&self, other: &Self) -> bool
        {
                    self.in_token == other.in_token && self.path == other.path
                }
            }
            impl Eq for ::syntax::Visibility {}
            impl PartialEq for ::syntax::Visibility {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Visibility::Public(_), ::syntax::Visibility::Public(_)) => true,
                        (
                            ::syntax::Visibility::Restricted(self0),
                            ::syntax::Visibility::Restricted(other0),
                        ) => self0 == other0,
                        (::syntax::Visibility::Inherited, ::syntax::Visibility::Inherited) => true,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::WhereClause {}
            impl PartialEq for ::syntax::WhereClause {
                fn eq(&self, other: &Self) -> bool
        {
                    self.predicates == other.predicates
                }
            }
            impl Eq for ::syntax::WherePredicate {}
            impl PartialEq for ::syntax::WherePredicate {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::WherePredicate::Lifetime(self0),
                            ::syntax::WherePredicate::Lifetime(other0),
                        ) => self0 == other0,
                        (::syntax::WherePredicate::Type(self0), ::syntax::WherePredicate::Type(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
        }

        pub mod hash
        {
            use ::
            {
                hash::{ Hash, Hasher },
                syntax::tt::{ TokenStreamHelper },
                *,
            };
            /*
            */
            impl Hash for ::syntax::Abi
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.name.hash(state);
                }
            }
            
            impl Hash for ::syntax::AngleBracketedGenericArguments
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.colon2_token.hash(state);
                    self.args.hash(state);
                }
            }
            
            impl Hash for ::syntax::Arm
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.guard.hash(state);
                    self.body.hash(state);
                    self.comma.hash(state);
                }
            }
            
            impl Hash for ::syntax::AssocConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.value.hash(state);
                }
            }
            
            impl Hash for ::syntax::AssocType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::AttrStyle
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::AttrStyle::Outer => {
                            state.write_u8(0u8);
                        }
                        ::syntax::AttrStyle::Inner(_) =>
                        {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Attribute
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.style.hash(state);
                    self.meta.hash(state);
                }
            }
            
            impl Hash for ::syntax::BareFnArg
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.name.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::BareVariadic
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.name.hash(state);
                    self.comma.hash(state);
                }
            }
            
            impl Hash for ::syntax::BinOp
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::BinOp::Add(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::BinOp::Sub(_) =>
                        {
                            state.write_u8(1u8);
                        }
                        ::syntax::BinOp::Mul(_) =>
                        {
                            state.write_u8(2u8);
                        }
                        ::syntax::BinOp::Div(_) =>
                        {
                            state.write_u8(3u8);
                        }
                        ::syntax::BinOp::Rem(_) =>
                        {
                            state.write_u8(4u8);
                        }
                        ::syntax::BinOp::And(_) =>
                        {
                            state.write_u8(5u8);
                        }
                        ::syntax::BinOp::Or(_) =>
                        {
                            state.write_u8(6u8);
                        }
                        ::syntax::BinOp::BitXor(_) =>
                        {
                            state.write_u8(7u8);
                        }
                        ::syntax::BinOp::BitAnd(_) =>
                        {
                            state.write_u8(8u8);
                        }
                        ::syntax::BinOp::BitOr(_) =>
                        {
                            state.write_u8(9u8);
                        }
                        ::syntax::BinOp::Shl(_) =>
                        {
                            state.write_u8(10u8);
                        }
                        ::syntax::BinOp::Shr(_) =>
                        {
                            state.write_u8(11u8);
                        }
                        ::syntax::BinOp::Eq(_) =>
                        {
                            state.write_u8(12u8);
                        }
                        ::syntax::BinOp::Lt(_) =>
                        {
                            state.write_u8(13u8);
                        }
                        ::syntax::BinOp::Le(_) =>
                        {
                            state.write_u8(14u8);
                        }
                        ::syntax::BinOp::Ne(_) =>
                        {
                            state.write_u8(15u8);
                        }
                        ::syntax::BinOp::Ge(_) =>
                        {
                            state.write_u8(16u8);
                        }
                        ::syntax::BinOp::Gt(_) =>
                        {
                            state.write_u8(17u8);
                        }
                        ::syntax::BinOp::AddAssign(_) =>
                        {
                            state.write_u8(18u8);
                        }
                        ::syntax::BinOp::SubAssign(_) =>
                        {
                            state.write_u8(19u8);
                        }
                        ::syntax::BinOp::MulAssign(_) =>
                        {
                            state.write_u8(20u8);
                        }
                        ::syntax::BinOp::DivAssign(_) =>
                        {
                            state.write_u8(21u8);
                        }
                        ::syntax::BinOp::RemAssign(_) =>
                        {
                            state.write_u8(22u8);
                        }
                        ::syntax::BinOp::BitXorAssign(_) =>
                        {
                            state.write_u8(23u8);
                        }
                        ::syntax::BinOp::BitAndAssign(_) =>
                        {
                            state.write_u8(24u8);
                        }
                        ::syntax::BinOp::BitOrAssign(_) =>
                        {
                            state.write_u8(25u8);
                        }
                        ::syntax::BinOp::ShlAssign(_) =>
                        {
                            state.write_u8(26u8);
                        }
                        ::syntax::BinOp::ShrAssign(_) =>
                        {
                            state.write_u8(27u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Block
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.stmts.hash(state);
                }
            }
            
            impl Hash for ::syntax::BoundLifetimes
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetimes.hash(state);
                }
            }
            
            impl Hash for ::syntax::CapturedParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::CapturedParam::Lifetime(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::CapturedParam::Ident(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ConstParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.ty.hash(state);
                    self.eq_token.hash(state);
                    self.default.hash(state);
                }
            }
            
            impl Hash for ::syntax::Constraint
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::Data
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Data::Struct(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Data::Enum(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Data::Union(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::DataEnum
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.variants.hash(state);
                }
            }
            
            impl Hash for ::syntax::DataStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.fields.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::DataUnion
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.fields.hash(state);
                }
            }
            
            impl Hash for ::syntax::DeriveInput
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.data.hash(state);
                }
            }
            
            impl Hash for ::syntax::Expr
           
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self
                    {
                        ::syntax::Expr::Array(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Assign(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Async(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Await(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Binary(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Block(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Break(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Call(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }

                        ::syntax::Expr::Cast(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Closure(v0) =>
                        {
                            state.write_u8(9u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Const(v0) =>
                        {
                            state.write_u8(10u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Continue(v0) =>
                        {
                            state.write_u8(11u8);
                            v0.hash(state);
                        }

                        ::syntax::Expr::Field(v0) =>
                        {
                            state.write_u8(12u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::ForLoop(v0) =>
                        {
                            state.write_u8(13u8);
                            v0.hash(state);
                        }

                        ::syntax::Expr::Group(v0) =>
                        {
                            state.write_u8(14u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::If(v0) =>
                        {
                            state.write_u8(15u8);
                            v0.hash(state);
                        }

                        ::syntax::Expr::Index(v0) =>
                        {
                            state.write_u8(16u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Infer(v0) =>
                        {
                            state.write_u8(17u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Let(v0) =>
                        {
                            state.write_u8(18u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Lit(v0) =>
                        {
                            state.write_u8(19u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Loop(v0) =>
                        {
                            state.write_u8(20u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Macro(v0) =>
                        {
                            state.write_u8(21u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Match(v0) =>
                        {
                            state.write_u8(22u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::MethodCall(v0) =>
                        {
                            state.write_u8(23u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Paren(v0) =>
                        {
                            state.write_u8(24u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Path(v0) =>
                        {
                            state.write_u8(25u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Range(v0) =>
                        {
                            state.write_u8(26u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::RawAddr(v0) =>
                        {
                            state.write_u8(27u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Reference(v0) =>
                        {
                            state.write_u8(28u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Repeat(v0) =>
                        {
                            state.write_u8(29u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Return(v0) =>
                        {
                            state.write_u8(30u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Struct(v0) =>
                        {
                            state.write_u8(31u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Try(v0) =>
                        {
                            state.write_u8(32u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::TryBlock(v0) =>
                        {
                            state.write_u8(33u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Tuple(v0) =>
                        {
                            state.write_u8(34u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Unary(v0) =>
                        {
                            state.write_u8(35u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Unsafe(v0) =>
                        {
                            state.write_u8(36u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Verbatim(v0) =>
                        {
                            state.write_u8(37u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                        
                        ::syntax::Expr::While(v0) =>
                        {
                            state.write_u8(38u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Yield(v0) =>
                        {
                            state.write_u8(39u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ExprArray
           
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprAssign
           
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.left.hash(state);
                    self.right.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprAsync
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.capture.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprAwait
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.base.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprBinary
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.left.hash(state);
                    self.op.hash(state);
                    self.right.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprBlock
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprBreak
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprCall
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.func.hash(state);
                    self.args.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprCast
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprClosure
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.lifetimes.hash(state);
                    self.constness.hash(state);
                    self.movability.hash(state);
                    self.asyncness.hash(state);
                    self.capture.hash(state);
                    self.inputs.hash(state);
                    self.output.hash(state);
                    self.body.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprContinue
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprField
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.base.hash(state);
                    self.member.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprForLoop
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.pat.hash(state);
                    self.expr.hash(state);
                    self.body.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprGroup
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprIf
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.cond.hash(state);
                    self.then_branch.hash(state);
                    self.else_branch.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprIndex
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                    self.index.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprInfer
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprLet
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprLit
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.lit.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprLoop
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.body.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprMatch
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                    self.arms.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprMethodCall
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.receiver.hash(state);
                    self.method.hash(state);
                    self.turbofish.hash(state);
                    self.args.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprParen
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprPath
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.qself.hash(state);
                    self.path.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprRange
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.start.hash(state);
                    self.limits.hash(state);
                    self.end.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprRawAddr
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mutability.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprReference
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mutability.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprRepeat
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                    self.len.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprReturn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.qself.hash(state);
                    self.path.hash(state);
                    self.fields.hash(state);
                    self.dot2_token.hash(state);
                    self.rest.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprTry
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprTryBlock
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprTuple
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprUnary
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.op.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprUnsafe
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprWhile
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.cond.hash(state);
                    self.body.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprYield
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::Field
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.mutability.hash(state);
                    self.ident.hash(state);
                    self.colon_token.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::FieldMutability
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::FieldMutability::None => {
                            state.write_u8(0u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::FieldPat
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.member.hash(state);
                    self.colon_token.hash(state);
                    self.pat.hash(state);
                }
            }
            
            impl Hash for ::syntax::FieldValue
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.member.hash(state);
                    self.colon_token.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::Fields
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Fields::Named(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Fields::Unnamed(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Fields::Unit => {
                            state.write_u8(2u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::FieldsNamed
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.named.hash(state);
                }
            }
            
            impl Hash for ::syntax::FieldsUnnamed
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.unnamed.hash(state);
                }
            }
            
            impl Hash for ::syntax::File
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.shebang.hash(state);
                    self.attrs.hash(state);
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::FnArg
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::FnArg::Receiver(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::FnArg::Typed(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ForeignItem
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::ForeignItem::Fn(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::ForeignItem::Static(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::ForeignItem::Type(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::ForeignItem::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::ForeignItem::Verbatim(v0) =>
                        {
                            state.write_u8(4u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ForeignItemFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.sig.hash(state);
                }
            }
            
            impl Hash for ::syntax::ForeignItemMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::ForeignItemStatic
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.mutability.hash(state);
                    self.ident.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ForeignItemType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                }
            }
            
            impl Hash for ::syntax::GenericArgument
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::GenericArgument::Lifetime(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::Type(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::Const(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::AssocType(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::AssocConst(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::Constraint(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::GenericParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::GenericParam::Lifetime(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericParam::Type(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericParam::Const(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Generics
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lt_token.hash(state);
                    self.params.hash(state);
                    self.gt_token.hash(state);
                    self.where_clause.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplItem
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::ImplItem::Const(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::ImplItem::Fn(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::ImplItem::Type(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::ImplItem::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::ImplItem::Verbatim(v0) =>
                        {
                            state.write_u8(4u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ImplItemConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.defaultness.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplItemFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.defaultness.hash(state);
                    self.sig.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplItemMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplItemType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.defaultness.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplRestriction
            {
                fn hash<H>(&self, _state: &mut H) where
                H: Hasher
                {
                    match *self {}
                }
            }
            
            impl Hash for ::syntax::Item
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Item::Const(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Enum(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::ExternCrate(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Fn(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::ForeignMod(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Impl(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Macro(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Mod(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Static(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Struct(v0) =>
                        {
                            state.write_u8(9u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Trait(v0) =>
                        {
                            state.write_u8(10u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::TraitAlias(v0) =>
                        {
                            state.write_u8(11u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Type(v0) =>
                        {
                            state.write_u8(12u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Union(v0) =>
                        {
                            state.write_u8(13u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Use(v0) =>
                        {
                            state.write_u8(14u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Verbatim(v0) =>
                        {
                            state.write_u8(15u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ItemConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemEnum
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.variants.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemExternCrate
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.rename.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.sig.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemForeignMod
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.unsafety.hash(state);
                    self.abi.hash(state);
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemImpl
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.defaultness.hash(state);
                    self.unsafety.hash(state);
                    self.generics.hash(state);
                    self.trait_.hash(state);
                    self.self_ty.hash(state);
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemMod
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.unsafety.hash(state);
                    self.ident.hash(state);
                    self.content.hash(state);
                    self.semi.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemStatic
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.mutability.hash(state);
                    self.ident.hash(state);
                    self.ty.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.fields.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemTrait
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.unsafety.hash(state);
                    self.auto_token.hash(state);
                    self.restriction.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.colon_token.hash(state);
                    self.supertraits.hash(state);
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemTraitAlias
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemUnion
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.fields.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemUse
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.leading_colon.hash(state);
                    self.tree.hash(state);
                }
            }
            
            impl Hash for ::syntax::Label
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.name.hash(state);
                }
            }
            
            impl Hash for ::syntax::LifetimeParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.lifetime.hash(state);
                    self.colon_token.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::Lit
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Lit::Str(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::ByteStr(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::CStr(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Byte(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Char(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Int(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Float(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Bool(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Verbatim(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.to_string().hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::LitBool
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.value.hash(state);
                }
            }
            
            impl Hash for ::syntax::Local
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.init.hash(state);
                }
            }
            
            impl Hash for ::syntax::LocalInit
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.expr.hash(state);
                    self.diverge.hash(state);
                }
            }
            
            impl Hash for ::syntax::Macro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.path.hash(state);
                    self.delimiter.hash(state);
                    TokenStreamHelper(&self.tokens).hash(state);
                }
            }
            
            impl Hash for ::syntax::MacroDelimiter
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::MacroDelimiter::Paren(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::MacroDelimiter::Brace(_) =>
                        {
                            state.write_u8(1u8);
                        }
                        ::syntax::MacroDelimiter::Bracket(_) =>
                        {
                            state.write_u8(2u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Meta
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Meta::Path(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Meta::List(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Meta::NameValue(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::MetaList
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.path.hash(state);
                    self.delimiter.hash(state);
                    TokenStreamHelper(&self.tokens).hash(state);
                }
            }
            
            impl Hash for ::syntax::MetaNameValue
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.path.hash(state);
                    self.value.hash(state);
                }
            }
            
            impl Hash for ::syntax::ParenthesizedGenericArguments
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.inputs.hash(state);
                    self.output.hash(state);
                }
            }
            
            impl Hash for ::syntax::Pat
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Pat::Const(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Ident(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Lit(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Or(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Paren(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Path(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Range(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Reference(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Rest(v0) =>
                        {
                            state.write_u8(9u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Slice(v0) =>
                        {
                            state.write_u8(10u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Struct(v0) =>
                        {
                            state.write_u8(11u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Tuple(v0) =>
                        {
                            state.write_u8(12u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::TupleStruct(v0) =>
                        {
                            state.write_u8(13u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Type(v0) =>
                        {
                            state.write_u8(14u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Verbatim(v0) =>
                        {
                            state.write_u8(15u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                        ::syntax::Pat::Wild(v0) =>
                        {
                            state.write_u8(16u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::PatIdent
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.by_ref.hash(state);
                    self.mutability.hash(state);
                    self.ident.hash(state);
                    self.subpat.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatOr
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.leading_vert.hash(state);
                    self.cases.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatParen
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatReference
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mutability.hash(state);
                    self.pat.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatRest
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatSlice
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.qself.hash(state);
                    self.path.hash(state);
                    self.fields.hash(state);
                    self.rest.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatTuple
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatTupleStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.qself.hash(state);
                    self.path.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatWild
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                }
            }
            
            impl Hash for ::syntax::Path
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.leading_colon.hash(state);
                    self.segments.hash(state);
                }
            }
            
            impl Hash for ::syntax::PathArguments
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::PathArguments::None => {
                            state.write_u8(0u8);
                        }
                        ::syntax::PathArguments::AngleBracketed(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::PathArguments::Parenthesized(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::PathSegment
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.arguments.hash(state);
                }
            }
            
            impl Hash for ::syntax::PointerMutability
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::PointerMutability::Const(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::PointerMutability::Mut(_) =>
                        {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::PreciseCapture
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.params.hash(state);
                }
            }
            
            impl Hash for ::syntax::PredicateLifetime
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetime.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::PredicateType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetimes.hash(state);
                    self.bounded_ty.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::QSelf
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ty.hash(state);
                    self.position.hash(state);
                    self.as_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::RangeLimits
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::RangeLimits::HalfOpen(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::RangeLimits::Closed(_) =>
                        {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Receiver
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.reference.hash(state);
                    self.mutability.hash(state);
                    self.colon_token.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ReturnType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::ReturnType::Default => {
                            state.write_u8(0u8);
                        }
                        ::syntax::ReturnType::Type(_, v1) =>
                        {
                            state.write_u8(1u8);
                            v1.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Signature
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.constness.hash(state);
                    self.asyncness.hash(state);
                    self.unsafety.hash(state);
                    self.abi.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.inputs.hash(state);
                    self.variadic.hash(state);
                    self.output.hash(state);
                }
            }
            
            impl Hash for ::syntax::StaticMutability
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::StaticMutability::Mut(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::StaticMutability::None => {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Stmt
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Stmt::Local(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Stmt::Item(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Stmt::Expr(v0, v1) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                            v1.hash(state);
                        }
                        ::syntax::Stmt::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::StmtMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitBound
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.paren_token.hash(state);
                    self.modifier.hash(state);
                    self.lifetimes.hash(state);
                    self.path.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitBoundModifier
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::TraitBoundModifier::None => {
                            state.write_u8(0u8);
                        }
                        ::syntax::TraitBoundModifier::Maybe(_) =>
                        {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::TraitItem
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::TraitItem::Const(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::TraitItem::Fn(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::TraitItem::Type(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::TraitItem::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::TraitItem::Verbatim(v0) =>
                        {
                            state.write_u8(4u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::TraitItemConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                    self.default.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitItemFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.sig.hash(state);
                    self.default.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitItemMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitItemType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.colon_token.hash(state);
                    self.bounds.hash(state);
                    self.default.hash(state);
                }
            }
            
            impl Hash for ::syntax::Type
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Type::Array(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::BareFn(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Group(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::ImplTrait(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Infer(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Macro(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Never(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Paren(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Path(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Ptr(v0) =>
                        {
                            state.write_u8(9u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Reference(v0) =>
                        {
                            state.write_u8(10u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Slice(v0) =>
                        {
                            state.write_u8(11u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::TraitObject(v0) =>
                        {
                            state.write_u8(12u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Tuple(v0) =>
                        {
                            state.write_u8(13u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Verbatim(v0) =>
                        {
                            state.write_u8(14u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::TypeArray
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elem.hash(state);
                    self.len.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeBareFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetimes.hash(state);
                    self.unsafety.hash(state);
                    self.abi.hash(state);
                    self.inputs.hash(state);
                    self.variadic.hash(state);
                    self.output.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeGroup
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeImplTrait
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeInfer
            {
                fn hash<H>(&self, _state: &mut H) where
                H: Hasher
                {}
            }
            
            impl Hash for ::syntax::TypeMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.mac.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeNever
            {
                fn hash<H>(&self, _state: &mut H) where
                H: Hasher
                {}
            }
            
            impl Hash for ::syntax::TypeParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.colon_token.hash(state);
                    self.bounds.hash(state);
                    self.eq_token.hash(state);
                    self.default.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeParamBound
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self 
                    {
                        ::syntax::TypeParamBound::Trait(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::TypeParamBound::Lifetime(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                                        ::syntax::TypeParamBound::PreciseCapture(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::TypeParamBound::Verbatim(v0) =>
                        {
                            state.write_u8(3u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::TypeParen
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypePath
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.qself.hash(state);
                    self.path.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypePtr
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.const_token.hash(state);
                    self.mutability.hash(state);
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeReference
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetime.hash(state);
                    self.mutability.hash(state);
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeSlice
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeTraitObject
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.dyn_token.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeTuple
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::UnOp
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::UnOp::Deref(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::UnOp::Not(_) =>
                        {
                            state.write_u8(1u8);
                        }
                        ::syntax::UnOp::Neg(_) =>
                        {
                            state.write_u8(2u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::UseGlob
            {
                fn hash<H>(&self, _state: &mut H) where
                H: Hasher
                {}
            }
            
            impl Hash for ::syntax::UseGroup
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::UseName
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                }
            }
            
            impl Hash for ::syntax::UsePath
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.tree.hash(state);
                }
            }
            
            impl Hash for ::syntax::UseRename
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.rename.hash(state);
                }
            }
            
            impl Hash for ::syntax::UseTree
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::UseTree::Path(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::UseTree::Name(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::UseTree::Rename(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::UseTree::Glob(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::UseTree::Group(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Variadic
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.comma.hash(state);
                }
            }
            
            impl Hash for ::syntax::Variant
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.fields.hash(state);
                    self.discriminant.hash(state);
                }
            }
            
            impl Hash for ::syntax::VisRestricted
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.in_token.hash(state);
                    self.path.hash(state);
                }
            }
            
            impl Hash for ::syntax::Visibility
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Visibility::Public(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::Visibility::Restricted(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Visibility::Inherited => {
                            state.write_u8(2u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::WhereClause
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.predicates.hash(state);
                }
            }
            
            impl Hash for ::syntax::WherePredicate           
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::WherePredicate::Lifetime(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::WherePredicate::Type(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                    }
                }
            }
        }
    } pub use self::gen::{ fold, visit, visit_mut };
    
    pub mod __private
    {
        pub use ::
        {
            clone::{ Clone },
            cmp::{ Eq, PartialEq },
            default::{ Default },
            fmt::{ Debug },
            hash::{ Hash, Hasher },
            marker::{ Copy },
            option::Option::{ None, Some },
            result::Result::{ Err, Ok },
            quote::
            {
                self, ToTokens, TokenStreamExt
            },
            syntax::
            {
                group::{ parse_braces, parse_brackets, parse_parens },
                span::{ IntoSpans },
                parse_quote::{ parse as parse_quote },
                token::
                {
                    parsing::{ peek_punct, punct as parse_punct },
                    printing::{ punct as print_punct },
                    private::{ CustomToken },
                },
            },
            *,
        };
        /*
        */
        pub type TokenStream = proc_macro::TokenStream;
        pub type Span = process::macros::Span;
        pub type TokenStream2 = process::macros::TokenStream;
        pub type Formatter<'a> = ::fmt::Formatter<'a>;
        pub type FmtResult = ::fmt::Result;
        pub type bool = ::primitive::bool;
        pub type str = ::primitive::str;
        pub struct private(pub ());
    }
    /// Parse tokens of source code into the chosen syntax tree node.
    pub fn parse<T: parse::Parse>(tokens: proc_macro::TokenStream) -> Result<T>
    {
        parse::Parser::parse(T::parse, tokens)
    }
    /// Parse a proc-macro2 token stream into the chosen syntax tree node.
    pub fn parse2<T: parse::Parse>(tokens: process::macros::TokenStream) -> Result<T>
    {
        parse::Parser::parse2(T::parse, tokens)
    }
    /// Parse a string of Rust code into the chosen syntax tree node.
    pub fn parse_str<T: parse::Parse>(s: &str) -> Result<T>
    {
        parse::Parser::parse_str(T::parse, s)
    }
    /// Parse the content of a file of Rust code.
    pub fn parse_file(mut content: &str) -> Result<File>
    {
        const BOM: &str = "\u{feff}";
        if content.starts_with(BOM) { content = &content[BOM.len()..]; }

        let mut shebang = None;
        
        if content.starts_with("#!")
        {
            let rest = whitespace::skip(&content[2..]);

            if !rest.starts_with('[')
            {
                if let Some(idx) = content.find('\n')
                {
                    shebang = Some(content[..idx].to_string());
                    content = &content[idx..];
                }
                
                else
                {
                    shebang = Some(content.to_string());
                    content = "";
                }
            }
        }

        let mut file: File = parse_str(content)?;
        file.shebang = shebang;
        
        Ok(file)
    }
}

pub mod thread
{
    pub use std::thread::{ * };
}

pub mod u8
{
    pub use std::u8::{ * };
}

pub mod u16
{
    pub use std::u16::{ * };
}

pub mod u32
{
    pub use std::u32::{ * };
}

pub mod u64
{
    pub use std::u64::{ * };
}

pub mod usize
{
    pub use std::usize::{ * };
}

pub mod u128
{
    pub use std::u128::{ * };
}

pub mod vec
{
    pub use std::vec::{ * };
}
// 48697 /////////////////////////////////////////////////////////////////////////////////////////////////////////////
