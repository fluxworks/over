//! Implementation of Unicode Standard Annex #31 for 
//! determining which `char` values are valid in programming language identifiers.
#![feature
(
    
)]

#![allow
(
    non_camel_case_types,
    non_snake_case,
    unused_attributes,
    unused_imports,
    unused_variables,
)]
/*
pub mod _
{
    pub use std::_::{ * };
}

pub mod __
{
    use ::
    {
        *,
    };
    /*
    */
}
*/
extern crate proc_macro;

#[macro_use] pub mod macros
{
    /// Performs variable interpolation against the input and produces it as [`process::macros::TokenStream`].
    #[macro_export] macro_rules! quote
    {
        () =>
        {
            ::__private::TokenStream::new()
        };
       
        ($tt:tt) => 
        {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt _s}
            _s
        }};
       
        (# $var:ident) => {{
            let mut _s = ::__private::TokenStream::new();
            ::ToTokens::to_tokens(&$var, &mut _s);
            _s
        }};
        ($tt1:tt $tt2:tt) => {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt1 _s}
            ::quote_token!{$tt2 _s}
            _s
        }};
       
        ($($tt:tt)*) => {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_each_token!{_s $($tt)*}
            _s
        }};
    }
    /// Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.
    #[macro_export] macro_rules! quote_spanned
    {
        ($span:expr=>) => {{
            let _: ::__private::Span = ::__private::get_span($span).__into_span();
            ::__private::TokenStream::new()
        }};
       
        ($span:expr=> $tt:tt) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span($span).__into_span();
            ::quote_token_spanned!{$tt _s _span}
            _s
        }};
       
        ($span:expr=> # $var:ident) => {{
            let mut _s = ::__private::TokenStream::new();
            let _: ::__private::Span = ::__private::get_span($span).__into_span();
            ::ToTokens::to_tokens(&$var, &mut _s);
            _s
        }};
        ($span:expr=> $tt1:tt $tt2:tt) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span($span).__into_span();
            ::quote_token_spanned!{$tt1 _s _span}
            ::quote_token_spanned!{$tt2 _s _span}
            _s
        }};
       
        ($span:expr=> $($tt:tt)*) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span($span).__into_span();
            ::quote_each_token_spanned!{_s _span $($tt)*}
            _s
        }};
    }
   
    #[macro_export] macro_rules! pounded_var_names
    {
        ($call:ident! $extra:tt $($tts:tt)*) => {
            ::pounded_var_names_with_context!{$call! $extra
                (@ $($tts)*)
                ($($tts)* @)
            }
        };
    }

    #[macro_export] macro_rules! pounded_var_names_with_context
    {
        ($call:ident! $extra:tt ($($b1:tt)*) ($($curr:tt)*)) => {
            $(
                ::pounded_var_with_context!{$call! $extra $b1 $curr}
            )*
        };
    }

    #[macro_export] macro_rules! pounded_var_with_context
    {
        ($call:ident! $extra:tt $b1:tt ( $($inner:tt)* )) => {
            ::pounded_var_names!{$call! $extra $($inner)*}
        };

        ($call:ident! $extra:tt $b1:tt [ $($inner:tt)* ]) => {
            ::pounded_var_names!{$call! $extra $($inner)*}
        };

        ($call:ident! $extra:tt $b1:tt { $($inner:tt)* }) => {
            ::pounded_var_names!{$call! $extra $($inner)*}
        };

        ($call:ident!($($extra:tt)*) # $var:ident) => {
            ::$call!($($extra)* $var);
        };

        ($call:ident! $extra:tt $b1:tt $curr:tt) => {};
    }

    #[macro_export] macro_rules! quote_bind_into_iter 
    {
        ($has_iter:ident $var:ident) => {
           
            #[allow(unused_mut)]
            let (mut $var, i) = $var.quote_into_iter();
            let $has_iter = $has_iter | i;
        };
    }

    #[macro_export] macro_rules! quote_bind_next_or_break 
    {
        ($var:ident) => {
            let $var = match $var.next() {
                Some(_x) => ::__private::RepInterp(_x),
                None => break,
            };
        };
    }
    
    #[macro_export] macro_rules! quote_each_token 
    {
        ($tokens:ident $($tts:tt)*) => {
            ::quote_tokens_with_context!{$tokens
                (@ @ @ @ @ @ $($tts)*)
                (@ @ @ @ @ $($tts)* @)
                (@ @ @ @ $($tts)* @ @)
                (@ @ @ $(($tts))* @ @ @)
                (@ @ $($tts)* @ @ @ @)
                (@ $($tts)* @ @ @ @ @)
                ($($tts)* @ @ @ @ @ @)
            }
        };
    }

    #[macro_export] macro_rules! quote_each_token_spanned 
    {
        ($tokens:ident $span:ident $($tts:tt)*) => {
            ::quote_tokens_with_context_spanned!{$tokens $span
                (@ @ @ @ @ @ $($tts)*)
                (@ @ @ @ @ $($tts)* @)
                (@ @ @ @ $($tts)* @ @)
                (@ @ @ $(($tts))* @ @ @)
                (@ @ $($tts)* @ @ @ @)
                (@ $($tts)* @ @ @ @ @)
                ($($tts)* @ @ @ @ @ @)
            }
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context
    {
        ($tokens:ident
            ($($b3:tt)*) ($($b2:tt)*) ($($b1:tt)*)
            ($($curr:tt)*)
            ($($a1:tt)*) ($($a2:tt)*) ($($a3:tt)*)
        ) => {
            $(
                ::quote_token_with_context!{$tokens $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context_spanned
    {
        ($tokens:ident $span:ident
            ($($b3:tt)*) ($($b2:tt)*) ($($b1:tt)*)
            ($($curr:tt)*)
            ($($a1:tt)*) ($($a2:tt)*) ($($a3:tt)*)
        ) => {
            $(
                ::quote_token_with_context_spanned!{$tokens $span $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_token_with_context
    {  
        ($tokens:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) * $a3:tt) => 
        {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            
            while true 
            {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                ::quote_each_token!{$tokens $($inner)*}
            }
        }};
       
        ($tokens:ident $b3:tt $b2:tt # (( $($inner:tt)* )) * $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt # ( $($inner:tt)* ) (*) $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) $sep:tt *) => 
        {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                if _i > 0 {
                    ::quote_token!{$sep $tokens}
                }
                _i += 1;
                ::quote_each_token!{$tokens $($inner)*}
            }
        }};
       
        ($tokens:ident $b3:tt $b2:tt # (( $($inner:tt)* )) $sep:tt * $a3:tt) => {};
       
        ($tokens:ident $b3:tt # ( $($inner:tt)* ) ($sep:tt) * $a2:tt $a3:tt) => {};
       
       
        ($tokens:ident # ( $($inner:tt)* ) * (*) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token!{* $tokens}
        };
       
        ($tokens:ident # ( $($inner:tt)* ) $sep:tt (*) $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt (#) $var:ident $a2:tt $a3:tt) => {
            ::ToTokens::to_tokens(&$var, &mut $tokens);
        };
       
        ($tokens:ident $b3:tt $b2:tt # ($var:ident) $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt ($curr:tt) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token!{$curr $tokens}
        };
    }
    
    #[macro_export] macro_rules! quote_token_with_context_spanned 
    {
        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) * $a3:tt) => {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                ::quote_each_token_spanned!{$tokens $span $($inner)*}
            }
        }};
        ($tokens:ident $span:ident $b3:tt $b2:tt # (( $($inner:tt)* )) * $a2:tt $a3:tt) => {};
        ($tokens:ident $span:ident $b3:tt # ( $($inner:tt)* ) (*) $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) $sep:tt *) => {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                if _i > 0 {
                    ::quote_token_spanned!{$sep $tokens $span}
                }
                _i += 1;
                ::quote_each_token_spanned!{$tokens $span $($inner)*}
            }
        }};
        ($tokens:ident $span:ident $b3:tt $b2:tt # (( $($inner:tt)* )) $sep:tt * $a3:tt) => {};
        ($tokens:ident $span:ident $b3:tt # ( $($inner:tt)* ) ($sep:tt) * $a2:tt $a3:tt) => {};
        ($tokens:ident $span:ident # ( $($inner:tt)* ) * (*) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token_spanned!{* $tokens $span}
        };
        ($tokens:ident $span:ident # ( $($inner:tt)* ) $sep:tt (*) $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt (#) $var:ident $a2:tt $a3:tt) => {
            ::ToTokens::to_tokens(&$var, &mut $tokens);
        };
        ($tokens:ident $span:ident $b3:tt $b2:tt # ($var:ident) $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ($curr:tt) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token_spanned!{$curr $tokens $span}
        };
    }
    
    #[macro_export] macro_rules! quote_token
    {
        ($ident:ident $tokens:ident) =>
        {
            ::__private::push_ident(&mut $tokens, stringify!($ident));
        };

        (:: $tokens:ident) =>
        {
            ::__private::push_colon2(&mut $tokens);
        };

        (( $($inner:tt)* ) $tokens:ident) =>
        {
            ::__private::push_group
            (
                &mut $tokens,
                ::__private::Delimiter::Parenthesis,
                ::quote!($($inner)*),
            );
        };

        ([ $($inner:tt)* ] $tokens:ident) =>
        {
            ::__private::push_group
            (
                &mut $tokens,
                ::__private::Delimiter::Bracket,
                ::quote!($($inner)*),
            );
        };

        ({ $($inner:tt)* } $tokens:ident) =>
        {
            ::__private::push_group
            (
                &mut $tokens,
                ::__private::Delimiter::Brace,
                ::quote!($($inner)*),
            );
        };

        (# $tokens:ident) =>
        {
            ::__private::push_pound(&mut $tokens);
        };

        (, $tokens:ident) =>
        {
            ::__private::push_comma(&mut $tokens);
        };

        (. $tokens:ident) =>
        {
            ::__private::push_dot(&mut $tokens);
        };

        (; $tokens:ident) =>
        {
            ::__private::push_semi(&mut $tokens);
        };

        (: $tokens:ident) =>
        {
            ::__private::push_colon(&mut $tokens);
        };

        (+ $tokens:ident) =>
        {
            ::__private::push_add(&mut $tokens);
        };

        (+= $tokens:ident) =>
        {
            ::__private::push_add_eq(&mut $tokens);
        };

        (& $tokens:ident) =>
        {
            ::__private::push_and(&mut $tokens);
        };

        (&& $tokens:ident) =>
        {
            ::__private::push_and_and(&mut $tokens);
        };

        (&= $tokens:ident) =>
        {
            ::__private::push_and_eq(&mut $tokens);
        };

        (@ $tokens:ident) =>
        {
            ::__private::push_at(&mut $tokens);
        };

        (! $tokens:ident) =>
        {
            ::__private::push_bang(&mut $tokens);
        };

        (^ $tokens:ident) =>
        {
            ::__private::push_caret(&mut $tokens);
        };

        (^= $tokens:ident) =>
        {
            ::__private::push_caret_eq(&mut $tokens);
        };

        (/ $tokens:ident) =>
        {
            ::__private::push_div(&mut $tokens);
        };

        (/= $tokens:ident) =>
        {
            ::__private::push_div_eq(&mut $tokens);
        };

        (.. $tokens:ident) =>
        {
            ::__private::push_dot2(&mut $tokens);
        };

        (... $tokens:ident) =>
        {
            ::__private::push_dot3(&mut $tokens);
        };

        (..= $tokens:ident) =>
        {
            ::__private::push_dot_dot_eq(&mut $tokens);
        };

        (= $tokens:ident) =>
        {
            ::__private::push_eq(&mut $tokens);
        };

        (== $tokens:ident) =>
        {
            ::__private::push_eq_eq(&mut $tokens);
        };

        (>= $tokens:ident) =>
        {
            ::__private::push_ge(&mut $tokens);
        };

        (> $tokens:ident) =>
        {
            ::__private::push_gt(&mut $tokens);
        };

        (<= $tokens:ident) =>
        {
            ::__private::push_le(&mut $tokens);
        };

        (< $tokens:ident) =>
        {
            ::__private::push_lt(&mut $tokens);
        };

        (*= $tokens:ident) =>
        {
            ::__private::push_mul_eq(&mut $tokens);
        };

        (!= $tokens:ident) =>
        {
            ::__private::push_ne(&mut $tokens);
        };

        (| $tokens:ident) =>
        {
            ::__private::push_or(&mut $tokens);
        };

        (|= $tokens:ident) =>
        {
            ::__private::push_or_eq(&mut $tokens);
        };

        (|| $tokens:ident) =>
        {
            ::__private::push_or_or(&mut $tokens);
        };

        (? $tokens:ident) =>
        {
            ::__private::push_question(&mut $tokens);
        };

        (-> $tokens:ident) =>
        {
            ::__private::push_rarrow(&mut $tokens);
        };

        (<- $tokens:ident) =>
        {
            ::__private::push_larrow(&mut $tokens);
        };

        (% $tokens:ident) =>
        {
            ::__private::push_rem(&mut $tokens);
        };

        (%= $tokens:ident) =>
        {
            ::__private::push_rem_eq(&mut $tokens);
        };

        (=> $tokens:ident) =>
        {
            ::__private::push_fat_arrow(&mut $tokens);
        };

        (<< $tokens:ident) =>
        {
            ::__private::push_shl(&mut $tokens);
        };

        (<<= $tokens:ident) =>
        {
            ::__private::push_shl_eq(&mut $tokens);
        };

        (>> $tokens:ident) =>
        {
            ::__private::push_shr(&mut $tokens);
        };

        (>>= $tokens:ident) =>
        {
            ::__private::push_shr_eq(&mut $tokens);
        };

        (* $tokens:ident) =>
        {
            ::__private::push_star(&mut $tokens);
        };

        (- $tokens:ident) =>
        {
            ::__private::push_sub(&mut $tokens);
        };

        (-= $tokens:ident) =>
        {
            ::__private::push_sub_eq(&mut $tokens);
        };

        ($lifetime:lifetime $tokens:ident) =>
        {
            ::__private::push_lifetime(&mut $tokens, stringify!($lifetime));
        };

        (_ $tokens:ident) =>
        {
            ::__private::push_underscore(&mut $tokens);
        };

        ($other:tt $tokens:ident) =>
        {
            ::__private::parse(&mut $tokens, stringify!($other));
        };
    }

    #[macro_export] macro_rules! quote_token_spanned
    {
        ($ident:ident $tokens:ident $span:ident) =>
        {
            ::__private::push_ident_spanned(&mut $tokens, $span, stringify!($ident));
        };

        (:: $tokens:ident $span:ident) =>
        {
            ::__private::push_colon2_spanned(&mut $tokens, $span);
        };

        (( $($inner:tt)* ) $tokens:ident $span:ident) =>
        {
            ::__private::push_group_spanned            
            (
                &mut $tokens,
                $span,
                ::__private::Delimiter::Parenthesis,
                ::quote_spanned!($span=> $($inner)*),
            );
        };

        ([ $($inner:tt)* ] $tokens:ident $span:ident) =>
        {
            ::__private::push_group_spanned
            (
                &mut $tokens,
                $span,
                ::__private::Delimiter::Bracket,
                ::quote_spanned!($span=> $($inner)*),
            );
        };

        ({ $($inner:tt)* } $tokens:ident $span:ident) =>
        {
            ::__private::push_group_spanned
            
            (
                &mut $tokens,
                $span,
                ::__private::Delimiter::Brace,
                ::quote_spanned!($span=> $($inner)*),
            );
        };

        (# $tokens:ident $span:ident) =>
        {
            ::__private::push_pound_spanned(&mut $tokens, $span);
        };

        (, $tokens:ident $span:ident) =>
        {
            ::__private::push_comma_spanned(&mut $tokens, $span);
        };

        (. $tokens:ident $span:ident) =>
        {
            ::__private::push_dot_spanned(&mut $tokens, $span);
        };

        (; $tokens:ident $span:ident) =>
        {
            ::__private::push_semi_spanned(&mut $tokens, $span);
        };

        (: $tokens:ident $span:ident) =>
        {
            ::__private::push_colon_spanned(&mut $tokens, $span);
        };

        (+ $tokens:ident $span:ident) =>
        {
            ::__private::push_add_spanned(&mut $tokens, $span);
        };

        (+= $tokens:ident $span:ident) =>
        {
            ::__private::push_add_eq_spanned(&mut $tokens, $span);
        };

        (& $tokens:ident $span:ident) =>
        {
            ::__private::push_and_spanned(&mut $tokens, $span);
        };

        (&& $tokens:ident $span:ident) =>
        {
            ::__private::push_and_and_spanned(&mut $tokens, $span);
        };

        (&= $tokens:ident $span:ident) =>
        {
            ::__private::push_and_eq_spanned(&mut $tokens, $span);
        };

        (@ $tokens:ident $span:ident) =>
        {
            ::__private::push_at_spanned(&mut $tokens, $span);
        };

        (! $tokens:ident $span:ident) =>
        {
            ::__private::push_bang_spanned(&mut $tokens, $span);
        };

        (^ $tokens:ident $span:ident) =>
        {
            ::__private::push_caret_spanned(&mut $tokens, $span);
        };

        (^= $tokens:ident $span:ident) =>
        {
            ::__private::push_caret_eq_spanned(&mut $tokens, $span);
        };

        (/ $tokens:ident $span:ident) =>
        {
            ::__private::push_div_spanned(&mut $tokens, $span);
        };

        (/= $tokens:ident $span:ident) =>
        {
            ::__private::push_div_eq_spanned(&mut $tokens, $span);
        };

        (.. $tokens:ident $span:ident) =>
        {
            ::__private::push_dot2_spanned(&mut $tokens, $span);
        };

        (... $tokens:ident $span:ident) =>
        {
            ::__private::push_dot3_spanned(&mut $tokens, $span);
        };

        (..= $tokens:ident $span:ident) =>
        {
            ::__private::push_dot_dot_eq_spanned(&mut $tokens, $span);
        };

        (= $tokens:ident $span:ident) =>
        {
            ::__private::push_eq_spanned(&mut $tokens, $span);
        };

        (== $tokens:ident $span:ident) =>
        {
            ::__private::push_eq_eq_spanned(&mut $tokens, $span);
        };

        (>= $tokens:ident $span:ident) =>
        {
            ::__private::push_ge_spanned(&mut $tokens, $span);
        };

        (> $tokens:ident $span:ident) =>
        {
            ::__private::push_gt_spanned(&mut $tokens, $span);
        };

        (<= $tokens:ident $span:ident) =>
        {
            ::__private::push_le_spanned(&mut $tokens, $span);
        };

        (< $tokens:ident $span:ident) =>
        {
            ::__private::push_lt_spanned(&mut $tokens, $span);
        };

        (*= $tokens:ident $span:ident) =>
        {
            ::__private::push_mul_eq_spanned(&mut $tokens, $span);
        };

        (!= $tokens:ident $span:ident) =>
        {
            ::__private::push_ne_spanned(&mut $tokens, $span);
        };

        (| $tokens:ident $span:ident) =>
        {
            ::__private::push_or_spanned(&mut $tokens, $span);
        };

        (|= $tokens:ident $span:ident) =>
        {
            ::__private::push_or_eq_spanned(&mut $tokens, $span);
        };

        (|| $tokens:ident $span:ident) =>
        {
            ::__private::push_or_or_spanned(&mut $tokens, $span);
        };

        (? $tokens:ident $span:ident) =>
        {
            ::__private::push_question_spanned(&mut $tokens, $span);
        };

        (-> $tokens:ident $span:ident) =>
        {
            ::__private::push_rarrow_spanned(&mut $tokens, $span);
        };

        (<- $tokens:ident $span:ident) =>
        {
            ::__private::push_larrow_spanned(&mut $tokens, $span);
        };

        (% $tokens:ident $span:ident) =>
        {
            ::__private::push_rem_spanned(&mut $tokens, $span);
        };

        (%= $tokens:ident $span:ident) =>
        {
            ::__private::push_rem_eq_spanned(&mut $tokens, $span);
        };

        (=> $tokens:ident $span:ident) =>
        {
            ::__private::push_fat_arrow_spanned(&mut $tokens, $span);
        };

        (<< $tokens:ident $span:ident) =>
        {
            ::__private::push_shl_spanned(&mut $tokens, $span);
        };

        (<<= $tokens:ident $span:ident) =>
        {
            ::__private::push_shl_eq_spanned(&mut $tokens, $span);
        };

        (>> $tokens:ident $span:ident) =>
        {
            ::__private::push_shr_spanned(&mut $tokens, $span);
        };

        (>>= $tokens:ident $span:ident) =>
        {
            ::__private::push_shr_eq_spanned(&mut $tokens, $span);
        };

        (* $tokens:ident $span:ident) =>
        {
            ::__private::push_star_spanned(&mut $tokens, $span);
        };

        (- $tokens:ident $span:ident) =>
        {
            ::__private::push_sub_spanned(&mut $tokens, $span);
        };

        (-= $tokens:ident $span:ident) =>
        {
            ::__private::push_sub_eq_spanned(&mut $tokens, $span);
        };

        ($lifetime:lifetime $tokens:ident $span:ident) =>
        {
            ::__private::push_lifetime_spanned(&mut $tokens, $span, stringify!($lifetime));
        };

        (_ $tokens:ident $span:ident) =>
        {
            ::__private::push_underscore_spanned(&mut $tokens, $span);
        };

        ($other:tt $tokens:ident $span:ident) =>
        {
            ::__private::parse_spanned(&mut $tokens, $span, stringify!($other));
        };
    }

    #[macro_export] macro_rules! format_ident
    {
        ($fmt:expr) => {
            format_ident_impl!([
                ::quote::__private::Option::None,
                $fmt
            ])
        };

        ($fmt:expr, $($rest:tt)*) => {
            format_ident_impl!([
                ::quote::__private::Option::None,
                $fmt
            ] $($rest)*)
        };
    }

    #[macro_export] macro_rules! format_ident_impl
    {
       
        ([$span:expr, $($fmt:tt)*]) => {
            ::quote::__private::mk_ident(
                &::quote::__private::format!($($fmt)*),
                $span,
            )
        };

       
        ([$old:expr, $($fmt:tt)*] span = $span:expr) => {
            format_ident_impl!([$old, $($fmt)*] span = $span,)
        };
        ([$old:expr, $($fmt:tt)*] span = $span:expr, $($rest:tt)*) => {
            format_ident_impl!([
                ::quote::__private::Option::Some::<::quote::__private::Span>($span),
                $($fmt)*
            ] $($rest)*)
        };

       
        ([$span:expr, $($fmt:tt)*] $name:ident = $arg:expr) => {
            format_ident_impl!([$span, $($fmt)*] $name = $arg,)
        };
        ([$span:expr, $($fmt:tt)*] $name:ident = $arg:expr, $($rest:tt)*) => {
            match ::quote::__private::IdentFragmentAdapter(&$arg) {
                arg => format_ident_impl!([$span.or(arg.span()), $($fmt)*, $name = arg] $($rest)*),
            }
        };

       
        ([$span:expr, $($fmt:tt)*] $arg:expr) => {
            format_ident_impl!([$span, $($fmt)*] $arg,)
        };
        ([$span:expr, $($fmt:tt)*] $arg:expr, $($rest:tt)*) => {
            match ::quote::__private::IdentFragmentAdapter(&$arg) {
                arg => format_ident_impl!([$span.or(arg.span()), $($fmt)*, arg] $($rest)*),
            }
        };
    }

    #[macro_export] macro_rules! ast_struct 
    {
        (
            $(#[$attr:meta])*
            $pub:ident $struct:ident $name:ident #full $body:tt
        ) =>
        {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(struct $struct);
            $(#[$attr])* $pub $struct $name $body
        };

        (
            $(#[$attr:meta])*
            $pub:ident $struct:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(struct $struct);

            $(#[$attr])* $pub $struct $name $body
        };
    }
    
    #[macro_export] macro_rules! ast_enum
    {
        (
            $(#[$enum_attr:meta])*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(enum $enum);

            $(#[$enum_attr])* $pub $enum $name $body
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs
    {
        (
            $(#[$enum_attr:meta])*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(enum $enum);

            $(#[$enum_attr])* $pub $enum $name $body

            ast_enum_of_structs_impl!($name $body);

                generate_to_tokens!(() tokens $name $body);
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs_impl
    {
        (
            $name:ident {
                $(
                    $(#[cfg $cfg_attr:tt])*
                    $(#[doc $($doc_attr:tt)*])*
                    $variant:ident $( ($member:ident) )*,
                )*
            }
        ) => {
            $($(
                ast_enum_from_struct!($name::$variant, $member);
            )*)*
        };
    }

    #[macro_export] macro_rules! ast_enum_from_struct
    {
        ($name:ident::Verbatim, $member:ident) => {};

        ($name:ident::$variant:ident, $member:ident) =>
        {
            impl From<$member> for $name
            {
                fn from(e: $member) -> $name {
                    $name::$variant(e)
                }
            }
        };
    }
    
    #[macro_export] macro_rules! generate_to_tokens
    {
        (
            ($($arms:tt)*) $tokens:ident $name:ident {
                $(#[cfg $cfg_attr:tt])*
                $(#[doc $($doc_attr:tt)*])*
                $variant:ident,
                $($next:tt)*
            }
        ) => {
            generate_to_tokens!(
                ($($arms)* $(#[cfg $cfg_attr])* $name::$variant => {})
                $tokens $name { $($next)* }
            );
        };

        (
            ($($arms:tt)*) $tokens:ident $name:ident {
                $(#[cfg $cfg_attr:tt])*
                $(#[doc $($doc_attr:tt)*])*
                $variant:ident($member:ident),
                $($next:tt)*
            }
        ) => {
            generate_to_tokens!(
                ($($arms)* $(#[cfg $cfg_attr])* $name::$variant(_e) => _e.to_tokens($tokens),)
                $tokens $name { $($next)* }
            );
        };

        (($($arms:tt)*) $tokens:ident $name:ident {}) => {
            impl ::quote::ToTokens for $name {
                fn to_tokens(&self, $tokens:&mut ::process::macros::TokenStream )
                {
                    match self {
                        $($arms)*
                    }
                }
            }
        };
    }
    
    #[macro_export] macro_rules! pub_if_not_doc
    {
        ($(#[$m:meta])* $pub:ident $($item:tt)*) => {
            check_keyword_matches!(pub $pub);

            $(#[$m])*
            $pub $($item)*
        };
    }

    #[macro_export] macro_rules! check_keyword_matches 
    {
        (enum enum) => {};
        (pub pub) => {};
        (struct struct) => {};
    }

    #[macro_export] macro_rules! return_impl_trait
    {
        (
            $(#[$attr:meta])*
            $vis:vis fn $name:ident $args:tt -> $impl_trait:ty [$concrete:ty] $body:block
        ) => {
            #[cfg(not(docsrs))]
            $(#[$attr])*
            $vis fn $name $args -> $concrete $body

            #[cfg(docsrs)]
            $(#[$attr])*
            $vis fn $name $args -> $impl_trait $body
        };
    }
    /// Parse a set of parentheses and expose their content to subsequent parsers.
    #[macro_export] macro_rules! parenthesized
    {
        ($content:ident in $cursor:expr) => {
            match ::syntax::__private::parse_parens(&$cursor) {
                ::syntax::__private::Ok(parens) => {
                    $content = parens.content;
                    parens.token
                }
                ::syntax::__private::Err(error) => {
                    return ::syntax::__private::Err(error);
                }
            }
        };
    }
    /// Parse a set of curly braces and expose their content to subsequent parsers.
    #[macro_export] macro_rules! braced
    {
        ($content:ident in $cursor:expr) => 
        {
            match ::syntax::__private::parse_braces(&$cursor) {
                ::syntax::__private::Ok(braces) => {
                    $content = braces.content;
                    braces.token
                }
                ::syntax::__private::Err(error) => {
                    return ::syntax::__private::Err(error);
                }
            }
        };
    }
    /// Parse a set of square brackets and expose their content to subsequent parsers.
    #[macro_export] macro_rules! bracketed
    {
        ($content:ident in $cursor:expr) =>
        {
            match ::syntax::__private::parse_brackets(&$cursor)
            {
                ::syntax::__private::Ok(brackets) => {
                    $content = brackets.content;
                    brackets.token
                }
                ::syntax::__private::Err(error) => {
                    return ::syntax::__private::Err(error);
                }
            }
        };
    }

    #[macro_export] macro_rules! parse_quote
    {
        ($($tt:tt)*) =>
        {
            ::syntax::__private::parse_quote(::syntax::__private::quote::quote!($($tt)*))
        };
    }
    /// This macro is [`parse_quote!`] + [`quote_spanned!`][quote::quote_spanned].
    #[macro_export] macro_rules! parse_quote_spanned
    {
        ($span:expr=> $($tt:tt)*) =>
        {
            ::syntax::__private::parse_quote(::syntax::__private::quote::quote_spanned!($span=> $($tt)*))
        };
    }
    
    #[macro_export] macro_rules! parse_macro_input
    {
        ($tokenstream:ident as $ty:ty) => {
            match ::syntax::parse::<$ty>($tokenstream) {
                ::syntax::__private::Ok(data) => data,
                ::syntax::__private::Err(err) => {
                    return ::syntax::__private::TokenStream::from(err.to_compile_error());
                }
            }
        };
        ($tokenstream:ident with $parser:path) => {
            match ::syntax::parse::Parser::parse($parser, $tokenstream) {
                ::syntax::__private::Ok(data) => data,
                ::syntax::__private::Err(err) => {
                    return ::syntax::__private::TokenStream::from(err.to_compile_error());
                }
            }
        };
        ($tokenstream:ident) => {
            ::syntax::parse_macro_input!($tokenstream as _)
        };
    }

    #[macro_export] macro_rules! custom_punctuation
    {
        ($ident:ident, $($tt:tt)+) =>
        {
            pub struct $ident {
                #[allow(dead_code)]
                pub spans: ::syntax::custom_punctuation_repr!($($tt)+),
            }

                #[allow(dead_code, non_snake_case)]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::custom_punctuation_repr!($($tt)+)>>(
                spans: __S,
            ) -> $ident {
                let _validate_len = 0 $(+ ::syntax::custom_punctuation_len!(strict, $tt))*;
                $ident {
                    spans: ::syntax::__private::IntoSpans::into_spans(spans)
                }
            }

            const _: () = {
                impl ::syntax::__private::Default for $ident {
                    fn default() -> Self {
                        $ident(::syntax::__private::Span::call_site())
                    }
                }

                ::syntax::impl_parse_for_custom_punctuation!($ident, $($tt)+);
                ::syntax::impl_to_tokens_for_custom_punctuation!($ident, $($tt)+);
                ::syntax::impl_clone_for_custom_punctuation!($ident, $($tt)+);
                ::syntax::impl_extra_traits_for_custom_punctuation!($ident, $($tt)+);
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_punctuation {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::CustomToken for $ident {
                fn peek(cursor: ::syntax::buffer::Cursor) -> ::syntax::__private::bool {
                    ::syntax::__private::peek_punct(cursor, ::syntax::stringify_punct!($($tt)+))
                }

                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!("`", ::syntax::stringify_punct!($($tt)+), "`")
                }
            }

            impl ::syntax::parse::Parse for $ident
            {
                fn parse(input: ::syntax::parse::ParseStream) -> ::syntax::parse::Result<$ident> {
                    let spans: ::syntax::custom_punctuation_repr!($($tt)+) =
                        ::syntax::__private::parse_punct(input, ::syntax::stringify_punct!($($tt)+))?;
                    Ok($ident(spans))
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_punctuation {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens(&self, tokens: &mut ::syntax::__private::TokenStream2) {
                    ::syntax::__private::print_punct(::syntax::stringify_punct!($($tt)+), &self.spans, tokens)
                }
            }
        };
    }
        
    #[macro_export] macro_rules! impl_clone_for_custom_punctuation {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::Copy for $ident {}

            #[allow(clippy::expl_impl_clone_on_copy)]
            impl ::syntax::__private::Clone for $ident {
                fn clone(&self) -> Self {
                    *self
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_punctuation {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::Debug for $ident {
                fn fmt(&self, f: &mut ::syntax::__private::Formatter) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str(f, ::syntax::__private::stringify!($ident))
                }
            }

            impl ::syntax::__private::Eq for $ident {}

            impl ::syntax::__private::PartialEq for $ident {
                fn eq(&self, _other: &Self) -> ::syntax::__private::bool {
                    true
                }
            }

            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>(&self, _state: &mut __H) {}
            }
        };
    }
        
    #[macro_export] macro_rules! custom_punctuation_repr {
        ($($tt:tt)+) => {
            [::syntax::__private::Span; 0 $(+ ::syntax::custom_punctuation_len!(lenient, $tt))+]
        };
    }
    
    #[macro_export] macro_rules! custom_punctuation_len {
        ($mode:ident, &)     => { 1 };
        ($mode:ident, &&)    => { 2 };
        ($mode:ident, &=)    => { 2 };
        ($mode:ident, @)     => { 1 };
        ($mode:ident, ^)     => { 1 };
        ($mode:ident, ^=)    => { 2 };
        ($mode:ident, :)     => { 1 };
        ($mode:ident, ,)     => { 1 };
        ($mode:ident, $)     => { 1 };
        ($mode:ident, .)     => { 1 };
        ($mode:ident, ..)    => { 2 };
        ($mode:ident, ...)   => { 3 };
        ($mode:ident, ..=)   => { 3 };
        ($mode:ident, =)     => { 1 };
        ($mode:ident, ==)    => { 2 };
        ($mode:ident, =>)    => { 2 };
        ($mode:ident, >=)    => { 2 };
        ($mode:ident, >)     => { 1 };
        ($mode:ident, <-)    => { 2 };
        ($mode:ident, <=)    => { 2 };
        ($mode:ident, <)     => { 1 };
        ($mode:ident, -)     => { 1 };
        ($mode:ident, -=)    => { 2 };
        ($mode:ident, !=)    => { 2 };
        ($mode:ident, !)     => { 1 };
        ($mode:ident, |)     => { 1 };
        ($mode:ident, |=)    => { 2 };
        ($mode:ident, ||)    => { 2 };
        ($mode:ident, ::)    => { 2 };
        ($mode:ident, %)     => { 1 };
        ($mode:ident, %=)    => { 2 };
        ($mode:ident, +)     => { 1 };
        ($mode:ident, +=)    => { 2 };
        ($mode:ident, #)     => { 1 };
        ($mode:ident, ?)     => { 1 };
        ($mode:ident, ->)    => { 2 };
        ($mode:ident, ;)     => { 1 };
        ($mode:ident, <<)    => { 2 };
        ($mode:ident, <<=)   => { 3 };
        ($mode:ident, >>)    => { 2 };
        ($mode:ident, >>=)   => { 3 };
        ($mode:ident, /)     => { 1 };
        ($mode:ident, /=)    => { 2 };
        ($mode:ident, *)     => { 1 };
        ($mode:ident, *=)    => { 2 };
        ($mode:ident, ~)     => { 1 };
        (lenient, $tt:tt)    => { 0 };
        (strict, $tt:tt)     => {{ ::syntax::custom_punctuation_unexpected!($tt); 0 }};
    }
    
    #[macro_export] macro_rules! custom_punctuation_unexpected {
        () => {};
    }
    
    #[macro_export] macro_rules! stringify_punct {
        ($($tt:tt)+) => {
            ::syntax::__private::concat!($(::syntax::__private::stringify!($tt)),+)
        };
    }

    #[macro_export] macro_rules! custom_keyword
    {
        ($ident:ident) => {
            #[allow(non_camel_case_types)]
            pub struct $ident {
                #[allow(dead_code)]
                pub span: ::syntax::__private::Span,
            }

                #[allow(dead_code, non_snake_case)]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: ::syntax::__private::IntoSpans::into_spans(span),
                }
            }

            const _: () = {
                impl ::syntax::__private::Default for $ident {
                    fn default() -> Self {
                        $ident {
                            span: ::syntax::__private::Span::call_site(),
                        }
                    }
                }

                ::syntax::impl_parse_for_custom_keyword!($ident);
                ::syntax::impl_to_tokens_for_custom_keyword!($ident);
                ::syntax::impl_clone_for_custom_keyword!($ident);
                ::syntax::impl_extra_traits_for_custom_keyword!($ident);
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_keyword {
        ($ident:ident) => {
           
            impl ::syntax::__private::CustomToken for $ident {
                fn peek(cursor: ::syntax::buffer::Cursor) -> ::syntax::__private::bool {
                    if let ::syntax::__private::Some((ident, _rest)) = cursor.ident() {
                        ident == ::syntax::__private::stringify!($ident)
                    } else {
                        false
                    }
                }

                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!("`", ::syntax::__private::stringify!($ident), "`")
                }
            }

            impl ::syntax::parse::Parse for $ident
            {
                fn parse(input: ::syntax::parse::ParseStream) -> ::syntax::parse::Result<$ident> {
                    input.step(|cursor| {
                        if let ::syntax::__private::Some((ident, rest)) = cursor.ident() {
                            if ident == ::syntax::__private::stringify!($ident) {
                                return ::syntax::__private::Ok(($ident { span: ident.span() }, rest));
                            }
                        }
                        ::syntax::__private::Err(cursor.error(::syntax::__private::concat!(
                            "expected `",
                            ::syntax::__private::stringify!($ident),
                            "`",
                        )))
                    })
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_keyword {
        ($ident:ident) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens(&self, tokens: &mut ::syntax::__private::TokenStream2) {
                    let ident = ::syntax::Ident::new(::syntax::__private::stringify!($ident), self.span);
                    ::syntax::__private::TokenStreamExt::append(tokens, ident);
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_clone_for_custom_keyword {
        ($ident:ident) => {
            impl ::syntax::__private::Copy for $ident {}

            #[allow(clippy::expl_impl_clone_on_copy)]
            impl ::syntax::__private::Clone for $ident {
                fn clone(&self) -> Self {
                    *self
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_keyword 
    {
        ($ident:ident) => {
            impl ::syntax::__private::Debug for $ident {
                fn fmt(&self, f: &mut ::syntax::__private::Formatter) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str(
                        f,
                        ::syntax::__private::concat!(
                            "Keyword [",
                            ::syntax::__private::stringify!($ident),
                            "]",
                        ),
                    )
                }
            }

            impl ::syntax::__private::Eq for $ident {}

            impl ::syntax::__private::PartialEq for $ident {
                fn eq(&self, _other: &Self) -> ::syntax::__private::bool {
                    true
                }
            }

            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>(&self, _state: &mut __H) {}
            }
        };
    }
}

pub mod ascii
{
    pub use std::ascii::{ * };
    
    const T: bool = true;
    const F: bool = false;

    #[repr(C, align(8))]
    pub struct Align8<T>(pub T);
    #[repr(C, align(64))]
    pub struct Align64<T>(pub T);

    pub static ASCII_START: Align64<[bool; 128]> = Align64
    ([
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ]);

    pub static ASCII_CONTINUE: Align64<[bool; 128]> = Align64
    ([
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, 
        F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, T, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ]);

    pub const CHUNK: usize = 64;

    pub static TRIE_START: Align8<[u8; 411]> = Align8
    ([
        0x04, 0x0B, 0x0F, 0x13, 0x17, 0x1B, 0x1F, 0x23, 0x27, 0x2D, 0x31, 0x34, 0x38, 0x3C, 0x40, 0x02, 0x45, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x4D, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x51, 0x54, 0x58, 0x5C, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x60, 
        0x64, 0x66, 0x6A, 0x6E, 0x72, 0x28, 0x76, 0x78, 0x7C, 0x80, 0x84, 0x88, 0x8C, 0x90, 0x94, 0x98, 0x9C, 0xA0, 
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xA8, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x00, 
        0x05, 0xB2, 0xB6, 0xBA, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xD1, 0xD3, 0x00, 0x00, 0x00, 0xC9, 0xD9, 0xDD, 0xE1, 0xE5, 0xE9, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7,
    ]);

    pub static TRIE_CONTINUE: Align8<[u8; 1793]> = Align8
    ([
        0x08, 0x0D, 0x11, 0x15, 0x19, 0x1D, 0x21, 0x25, 0x2A, 0x2F, 0x31, 0x36, 0x3A, 0x3E, 0x42, 0x02,0x47, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x4F, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x51, 0x56, 0x5A, 0x5E, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62, 
        0x64, 0x68,0x6C, 0x70, 0x74, 0x28, 0x76, 0x7A, 0x7E, 0x82, 0x86, 0x8A, 0x8E, 0x92, 0x96, 0x9A, 0x9E, 0xA2,
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xAB, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xB0, 0x00, 0x00, 0x00, 
        0x05, 0xB4, 0xB8, 0xBC, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xC3, 0xC6, 0xCE, 
        0xD1, 0xD5, 0x00, 0xD7, 0x00, 0xC9,0xDB, 0xDF, 0xE3, 0xE7, 0xEB, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xCC, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xCF,
    ]);

    pub static LEAF: Align64<[u8; 7968]> = Align64
    ([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xAA, 
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x5F, 0xDC, 0x1F, 0xCF, 0x0F, 0xFF, 0x1F, 
        0xDC, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xA0, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 
        0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0xDF, 0xB8, 0x40, 0xD7, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xB8, 0xC0, 0xD7, 0xFF, 0xFF,
        0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
        0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0x87, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFB, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xB6, 0x00, 0xFF, 0xFF, 0xFF, 0x87, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC0, 0xFE, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2F, 0x00, 0x60, 0xC0, 0x00, 0x9C,
        0x00, 0x00, 0xFD, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x02, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x07, 0x30, 0x04,
        0x00, 0x00, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0x9F, 0xFF, 0xFD, 0xFF, 0x9F,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x24,
        0xFF, 0xFF, 0x3F, 0x04, 0x10, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0x01, 0xFF, 0x03, 0x00, 0xFE, 0xFF,
        0xE1, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0x23, 0x00, 0x40, 0x00, 0xB0, 0x03, 0x00, 0x03, 0x10,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFE, 0xFF,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0xF3, 0x9F, 0x79, 0x80, 0xB0, 0xCF, 0xFF, 0x03, 0x50,
        0xE0, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0x03, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x00, 0x1C, 0x00,
        0xE0, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x02,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x02, 0x00,
        0xE8, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEE, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0xD3, 0x87, 0x39, 0x02, 0x5E, 0xC0, 0xFF, 0x3F, 0x00,
        0xEE, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0xBF, 0x3B, 0x01, 0x00, 0xCF, 0xFF, 0x00, 0xFE,
        0xEE, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0x9F, 0x39, 0xE0, 0xB0, 0xCF, 0xFF, 0x02, 0x00,
        0xEC, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0xC3, 0xC7, 0x3D, 0x81, 0x00, 0xC0, 0xFF, 0x00, 0x00,
        0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0x23, 0x00, 0x00, 0x00, 0x37, 0x03, 0x00, 0x00, 0x00,
        0xE1, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x23, 0x00, 0x00, 0x00, 0x70, 0x03, 0x00, 0x06, 0x00,
        0xF0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x27, 0x00, 0x40, 0x70, 0x80, 0x03, 0x00, 0x00, 0xFC,
        0xE0, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0xF3, 0xDF, 0x3D, 0x60, 0x37, 0xCF, 0xFF, 0x00, 0x00,
        0xEF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0xF3, 0xDF, 0x3D, 0x60, 0x70, 0xCF, 0xFF, 0x0E, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x7D, 0xF0, 0x80, 0xCF, 0xFF, 0x00, 0xFC,
        0xEE, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x84, 0x5F, 0xFF, 0xC0, 0xFF, 0x0C, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0x05, 0x20, 0x5F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x7F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0xFF, 0x3F, 0x5F, 0x7F, 0xFF, 0xF3, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x03, 0xFF, 0x03, 0xA0, 0xC2, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0xFE, 0xFF,
        0xDF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x80, 0x00, 0x00, 0x3F, 0x3C, 0x62, 0xC0, 0xE1, 0xFF,
        0x03, 0x40, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0xFE, 0x03, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x03, 0x80, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xDF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF, 0x1F, 0x00, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xDF, 0x0D, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F, 0x30, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xB8, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x0F, 0xFF, 0x0F, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x01, 0xC0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x9F,
        0xFF, 0x03, 0xFF, 0x03, 0x80, 0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x0F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03, 0x00, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDE, 0x6F, 0x04,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x27, 0x00, 0xF0, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x1F, 0xE2, 0xFF, 0x01, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x78, 0x0C, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x80,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE6, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0x00, 0x0C, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xBF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xBB, 0xF7, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x68,
        0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x80, 0x00, 0x00, 0xDF, 0xFF, 0x00, 0x7C,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xE8,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x80, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0xF7, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0xC4,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x62, 0x3E, 0x05, 0x00, 0x00, 0x38, 0xFF, 0x07, 0x1C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0x7F, 0xFC,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x38, 0xFF, 0xFF, 0x7C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x37, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xA0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xE0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0xFF, 0xFF, 0x07, 0xC0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0xFF, 0x03, 0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07, 0xE0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0x3F, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x91, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x37, 0x00,
        0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x6F, 0xF0, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x87, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xBE, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1B, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x90, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x47, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x3F, 0x80,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x4F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xDE, 0xFF, 0x17, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0x0F, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0xE0, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x03,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xFB, 0x9F, 0x39, 0x81, 0xE0, 0xCF, 0x1F, 0x1F, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xA5, 0xF7, 0x0F, 0x00, 0x06, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x80, 0x07, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xC3, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x01, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0x0F, 0xFF, 0x03, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0xBF, 0xF9, 0x0F, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x1B, 0x00, 0x00, 0x00,
        0x01, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0x00, 0x01, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x20, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0x03,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x01, 0x00, 0xFF, 0x03, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFE, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xB4, 0xFF, 0x00, 0xFF, 0x03, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x7F, 0xFB, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xF4, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x07, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x0F, 0x00, 0xFF, 0x03, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x7C, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x80, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x6F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE3, 0x07, 0xF8,
        0xE7, 0x0F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xE0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xDF, 0x64, 0xDE, 0xFF, 0xEB, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xBF, 0xE7, 0xDF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7B, 0x5F, 0xFC, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x20, 0x00,
        0x10, 0x00, 0x00, 0xF8, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x3F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFF, 0xFF, 0xF9, 0xDB, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x3F, 0xFF, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xB7, 0x3F, 0x1F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x3F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEF, 0xFF, 0xFF, 0xFF, 0x96, 0xFE, 0xF7, 0x0A, 0x84, 0xEA, 0x96, 0xAA, 0x96, 0xF7, 0xF7, 0x5E,
        0xFF, 0xFB, 0xFF, 0x0F, 0xEE, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]);
}

pub mod backtrace
{
    pub use std::backtrace::{ * };
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod cell
{
    pub use std::cell::{ * };
}

pub mod char
{
    pub use std::char::{ * };
}

pub mod clone
{
    pub use std::clone::{ * };
}

pub mod cmp
{
    pub use std::cmp::{ * };
}

pub mod collections
{
    pub use std::collections::{ * };
}

pub mod convert
{
    pub use std::convert::{ * };
}

pub mod default
{
    pub use std::default::{ * };
}

pub mod error
{
    pub use std::error::{ * };
}

pub mod ffi
{
    pub use std::ffi::{ * };
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod hash
{
    pub use std::hash::{ * };
}

pub mod is
{
    use ::
    {
        *,
    };
    /// Whether the character has the Unicode property XID\_Start.
    /*
    pub fn is_xid_start( ... ) -> bool*/
    pub fn xid_start( ch:char ) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_START.0[ch as usize]; }
        let chunk = * ::ascii::TRIE_START.0.get(ch as usize / 8 / ::ascii::CHUNK).unwrap_or(&0);
        let offset = chunk as usize *  ::ascii::CHUNK / 2 + ch as usize / 8 %  ::ascii::CHUNK;
        unsafe {  ::ascii::LEAF.0.get_unchecked(offset) }.wrapping_shr(ch as u32 % 8) & 1 != 0
    }
    /// Whether the character has the Unicode property XID\_Continue.
    /*
    pub fn is_xid_continue(ch: char) -> bool */
    pub fn xid_continue(ch: char) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_CONTINUE.0[ch as usize]; }
        let chunk = *::ascii::TRIE_CONTINUE.0.get(ch as usize / 8 / ::ascii::CHUNK).unwrap_or(&0);
        let offset = chunk as usize * ::ascii::CHUNK / 2 + ch as usize / 8 % ::ascii::CHUNK;
        unsafe { ::ascii::LEAF.0.get_unchecked(offset) }.wrapping_shr(ch as u32 % 8) & 1 != 0
    }
    /*
    fn is_whitespace(ch: char) -> bool*/
    pub fn whitespace(ch: char) -> bool
    {
        ch.is_whitespace() || ch == '\u{200e}' || ch == '\u{200f}'
    }
    /*
    pub fn is_ident_start(c: char) -> bool*/
    pub fn ident_start(c: char) -> bool
    {
        c == '_' || ::is::xid_start(c)
    }
    /*
    pub fn is_ident_continue(c: char) -> bool */
    pub fn ident_continue(c: char) -> bool
    {
        xid_continue(c)
    }
}

pub mod iter
{
    pub use std::iter::{ * };
}

pub mod marker
{
    pub use std::marker::{ * };
    use ::
    {
        rc::{ Rc },
        panic::{ RefUnwindSafe, UnwindSafe },
        *,
    };
    /*
    use alloc::rc::Rc;
    use core::marker::PhantomData;
    use core::panic::{RefUnwindSafe, UnwindSafe};
    */
    pub const MARKER: ProcMacroAutoTraits = ProcMacroAutoTraits(PhantomData);
    /// Zero sized marker with the correct set of autotrait impls we want all proc macro types to have.
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct ProcMacroAutoTraits( pub PhantomData<Rc<()>> );
    impl UnwindSafe for ProcMacroAutoTraits {}
    impl RefUnwindSafe for ProcMacroAutoTraits {}
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod ops
{
    pub use std::ops::{ * };
}

pub mod option
{
    pub use std::option::{ * };
}

pub mod panic
{
    pub use std::panic::{ * };
}

pub mod path
{
    pub use std::path::{ * };
}

pub mod primitive
{
    pub use std::primitive::{ * };
}

pub mod process
{
    pub use std::process::{ * };

    pub mod macros
    {
        use ::
        {
            cmp::{ Ordering },
            error::{ Error },
            fmt::{ self, Debug, Display },
            hash::{ Hash, Hasher },
            ops::{ Range, RangeBounds },
            path::{ PathBuf },
            *,
        };
        /*
            use ::process::macros::extra::DelimSpan;
            use ::process::macros::marker::{ProcMacroAutoTraits, MARKER};
            use core::cmp::Ordering;
            use core::fmt::{self, Debug, Display};
            use core::hash::{Hash, Hasher};
            use core::ops::Range;
            use core::ops::RangeBounds;
            use core::str::FromStr;
            use std::error::Error;
            use std::ffi::CStr;
            use std::path::PathBuf;
            pub use ::process::macros::location::LineColumn;
        */        
        pub mod detection
        {
            use ::
            {
                sync::
                {
                    atomic::{ AtomicUsize, Ordering },
                    Once
                },
                *,
            };
            /*
            */
            static WORKS: AtomicUsize = AtomicUsize::new(0);
            static INIT: Once = Once::new();

            pub fn inside_proc_macro() -> bool
            {
                match WORKS.load(Ordering::Relaxed)
                {
                    1 => return false,
                    2 => return true,
                    _ =>
                    {}
                }

                INIT.call_once(initialize);
                inside_proc_macro()
            }

            pub fn force_fallback() { WORKS.store(1, Ordering::Relaxed); }

            pub fn unforce_fallback() { initialize(); }
            
            #[allow(deprecated)]
            fn initialize()
            {
                use ::panic::{self, PanicInfo};

                type PanicHook = dyn Fn(&PanicInfo) + Sync + Send + 'static;

                let null_hook: Box<PanicHook> = Box::new(|_panic_info| { /* ignore */ });
                let sanity_check = &*null_hook as *const PanicHook;
                let original_hook = panic::take_hook();
                panic::set_hook(null_hook);

                let works = panic::catch_unwind(proc_macro::Span::call_site).is_ok();
                WORKS.store(works as usize + 1, Ordering::Relaxed);

                let hopefully_null_hook = panic::take_hook();
                panic::set_hook(original_hook);
                if sanity_check != &*hopefully_null_hook
                {
                    panic!("observed race condition in process::macros::inside_proc_macro");
                }
            }
        }

        pub mod extra
        {
            use ::
            {
                fmt::{ self, Debug },
                process::macros::
                {
                    fallback, imp, Span, 
                },
                marker::{ ProcMacroAutoTraits, MARKER },
                *,
            };
            /*
            */
            /// Invalidate any `process::macros::Span` that exist on the current thread.
            pub fn invalidate_current_thread_spans()
            {
                ::process::macros::imp::invalidate_current_thread_spans();
            }
            /// An object that holds a [`Group`]'s `span_open()` and `span_close()` together
            /// in a more compact representation than holding those 2 spans individually.
            #[derive(Copy, Clone)]
            pub struct DelimSpan 
            {
                inner: DelimSpanEnum,
                _marker: ProcMacroAutoTraits,
            }

            #[derive(Copy, Clone)]
            enum DelimSpanEnum 
            {
                    Compiler {
                    join: proc_macro::Span,
                    open: proc_macro::Span,
                    close: proc_macro::Span,
                },
                Fallback(fallback::Span),
            }

            impl DelimSpan
            {
                pub fn new(group: &imp::Group) -> Self
               
                {
                    let inner = match group
                    {
                        imp::Group::Compiler(group) => DelimSpanEnum::Compiler
                        {
                            join: group.span(),
                            open: group.span_open(),
                            close: group.span_close(),
                        },
                        imp::Group::Fallback(group) => DelimSpanEnum::Fallback(group.span()),
                    };

                    DelimSpan
                    {
                        inner,
                        _marker: marker::MARKER,
                    }
                }
                /// Returns a span covering the entire delimited group.
                pub fn join( &self ) -> Span
                {
                    match &self.inner
                    {
                        DelimSpanEnum::Compiler { join, .. } => Span::_new(imp::Span::Compiler(*join)),
                        DelimSpanEnum::Fallback(span) => Span::_new_fallback(*span),
                    }
                }
                /// Returns a span for the opening punctuation of the group only.
                pub fn open( &self ) -> Span
                {
                    match &self.inner
                    {
                        DelimSpanEnum::Compiler { open, .. } => Span::_new(imp::Span::Compiler(*open)),
                        DelimSpanEnum::Fallback(span) => Span::_new_fallback(span.first_byte()),
                    }
                }
                /// Returns a span for the closing punctuation of the group only.
                pub fn close( &self ) -> Span
                {
                    match &self.inner
                    {
                        DelimSpanEnum::Compiler { close, .. } => Span::_new(imp::Span::Compiler(*close)),
                        DelimSpanEnum::Fallback(span) => Span::_new_fallback(span.last_byte()),
                    }
                }
            }

            impl Debug for DelimSpan           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    Debug::fmt(&self.join(), f)
                }
            }
        }
        
        pub mod fallback
        {
            use ::
            {
                cell::{ RefCell },
                collections::{ BTreeMap },
                convert::{ TryFrom },
                cmp::{ Ordering },
                fmt::{ self, Debug, Display, Write },
                ffi::{ CStr },
                mem::{ ManuallyDrop },
                ops::{ Range, RangeBounds },
                path::{ PathBuf },
                process::macros::
                {
                    location::LineColumn,
                    parse::{self, Cursor},
                    rcvec::{RcVec, RcVecBuilder, RcVecIntoIter, RcVecMut},
                    imp, Delimiter, Spacing, TokenTree,
                },
                str::{ FromStr },
                *,
            };
            /*
            */
            macro_rules! suffixed_numbers
            {
                ($($name:ident => $kind:ident,)*) => 
                ($(
                    pub fn $name(n: $kind) -> Literal 
                    {
                        Literal::_new(format!(concat!("{}", stringify!($kind)), n))
                    }
                )*)
            }

            macro_rules! unsuffixed_numbers
            {
                ($($name:ident => $kind:ident,)*) => 
                ($(
                    pub fn $name(n: $kind) -> Literal { Literal::_new(n.to_string()) }
                )*)
            }
            /// Force use of proc-macro2's fallback for now, even if the compiler's implementation is available.
            pub fn force()
            {
                ::process::macros::detection::force_fallback();
            }
            /// Resume using the compiler's implementation of the proc macro API if it is available.
            pub fn unforce()
            {
                ::process::macros::detection::unforce_fallback();
            }

            #[derive(Clone)]
            pub struct TokenStream 
            {
                inner: RcVec<TokenTree>,
            }

            #[derive(Debug)]
            pub struct LexError 
            {
                pub span: Span,
            }

            impl LexError           
            {
                pub fn span( &self ) -> Span { self.span }
                pub fn call_site() -> Self
                {
                    LexError
                    {
                        span: Span::call_site(),
                    }
                }
            }

            impl TokenStream
            {
                pub fn new() -> Self
                {
                    TokenStream
                    {
                        inner: RcVecBuilder::new().build(),
                    }
                }

                pub fn from_str_checked(src: &str) -> Result<Self, LexError>
               
                {
                    let mut cursor = get_cursor(src);
                    const BYTE_ORDER_MARK: &str = "\u{feff}";
                    if cursor.starts_with(BYTE_ORDER_MARK) {
                        cursor = cursor.advance(BYTE_ORDER_MARK.len());
                    }

                    parse::token_stream(cursor)
                }
                
                pub fn from_str_unchecked(src: &str) -> Self {
                    Self::from_str_checked(src).unwrap()
                }

                pub fn is_empty( &self ) -> bool
                {
                    self.inner.len() == 0
                }

                fn take_inner( self ) -> RcVecBuilder<TokenTree>
                {
                    let nodrop = ManuallyDrop::new( self );
                    unsafe { ptr::read(&nodrop.inner) }.make_owned()
                }
            }

            fn push_token_from_proc_macro(mut vec: RcVecMut<TokenTree>, token: TokenTree)
            {
                match token
                {
                    TokenTree::Literal
                    (
                        ::process::macros::Literal
                        {
                            inner: ::process::macros::imp::Literal::Fallback(literal),
                            _marker: marker::ProcMacroAutoTraits(_),
                        }
                    ) if literal.repr.starts_with('-') =>
                    {
                        push_negative_literal(vec, literal);
                    }
                    _ => vec.push(token),
                }

                #[cold] fn push_negative_literal(mut vec: RcVecMut<TokenTree>, mut literal: Literal)
                {
                    literal.repr.remove(0);
                    let mut punct = ::process::macros::Punct::new('-', Spacing::Alone);
                    punct.set_span(::process::macros::Span::_new_fallback(literal.span));
                    vec.push(TokenTree::Punct(punct));
                    vec.push(TokenTree::Literal(::process::macros::Literal::_new_fallback(literal)));
                }
            }
            
            impl Drop for TokenStream           
            {
                fn drop( &mut self )
                {
                    let mut stack = Vec::new();
                    let mut current = match self.inner.get_mut() {
                        Some(inner) => inner.take().into_iter(),
                        None => return,
                    };
                    loop {
                        while let Some(token) = current.next() {
                            let group = match token {
                                TokenTree::Group(group) => group.inner,
                                _ => continue,
                            };
                                            let group = match group {
                                ::process::macros::imp::Group::Fallback(group) => group,
                                ::process::macros::imp::Group::Compiler(_) => continue,
                            };
                            let mut group = group;
                            if let Some(inner) = group.stream.inner.get_mut() {
                                stack.push(current);
                                current = inner.take().into_iter();
                            }
                        }
                        match stack.pop() {
                            Some(next) => current = next,
                            None => return,
                        }
                    }
                }
            }

            pub struct TokenStreamBuilder {
                inner: RcVecBuilder<TokenTree>,
            }

            impl TokenStreamBuilder
            {
                pub fn new() -> Self {
                    TokenStreamBuilder {
                        inner: RcVecBuilder::new(),
                    }
                }

                pub fn with_capacity(cap: usize) -> Self {
                    TokenStreamBuilder {
                        inner: RcVecBuilder::with_capacity(cap),
                    }
                }

                pub fn push_token_from_parser(&mut self, tt: TokenTree) {
                    self.inner.push(tt);
                }

                pub fn build( self ) -> TokenStream {
                    TokenStream {
                        inner: self.inner.build(),
                    }
                }
            }
            
            fn get_cursor(src: &str) -> Cursor<'_>
            {
                SOURCE_MAP.with(|sm|
               
                {
                    let mut sm = sm.borrow_mut();
                    let span = sm.add_file(src);
                    Cursor {
                        rest: src,
                        off: span.lo,
                    }
                })
            }

            impl Display for LexError
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                    f.write_str("cannot parse string into token stream")
                }
            }

            impl Display for TokenStream
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    let mut joint = false;
                    for (i, tt) in self.inner.iter().enumerate() {
                        if i != 0 && !joint {
                            write!(f, " ")?;
                        }
                        joint = false;
                        match tt {
                            TokenTree::Group(tt) => Display::fmt(tt, f),
                            TokenTree::Ident(tt) => Display::fmt(tt, f),
                            TokenTree::Punct(tt) =>
                    {
                                joint = tt.spacing() == Spacing::Joint;
                                Display::fmt(tt, f)
                            }
                            TokenTree::Literal(tt) => Display::fmt(tt, f),
                        }?;
                    }

                    Ok(())
                }
            }

            impl Debug for TokenStream
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                    f.write_str("TokenStream ")?;
                    f.debug_list().entries(self.clone()).finish()
                }
            }
            
            impl From<proc_macro::TokenStream> for TokenStream
            {
                fn from(inner: proc_macro::TokenStream) -> Self {
                    TokenStream::from_str_unchecked(&inner.to_string())
                }
            }
            
            impl From<TokenStream> for proc_macro::TokenStream
            {
                fn from(inner: TokenStream) -> Self {
                    proc_macro::TokenStream::from_str_unchecked(&inner.to_string())
                }
            }

            impl From<TokenTree> for TokenStream
            {
                fn from(tree: TokenTree) -> Self
                {
                    let mut stream = RcVecBuilder::new();
                    push_token_from_proc_macro(stream.as_mut(), tree);
                    TokenStream {
                        inner: stream.build(),
                    }
                }
            }

            impl iter::FromIterator<TokenTree> for TokenStream
            {
                fn from_iter<I: IntoIterator<Item = TokenTree>>(tokens: I) -> Self
                {
                    let mut stream = TokenStream::new();
                    stream.extend(tokens);
                    stream
                }
            }

            impl iter::FromIterator<TokenStream> for TokenStream
            {
                fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self
                {
                    let mut v = RcVecBuilder::new();

                    for stream in streams {
                        v.extend(stream.take_inner());
                    }

                    TokenStream { inner: v.build() }
                }
            }

            impl Extend<TokenTree> for TokenStream
            {
                fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, tokens: I)
                {
                    let mut vec = self.inner.make_mut();
                    tokens
                        .into_iter()
                        .for_each(|token| push_token_from_proc_macro(vec.as_mut(), token));
                }
            }

            impl Extend<TokenStream> for TokenStream
            {
                fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {
                    self.inner.make_mut().extend(streams.into_iter().flatten());
                }
            }

            pub type TokenTreeIter = RcVecIntoIter<TokenTree>;

            impl IntoIterator for TokenStream {
                type Item = TokenTree;
                type IntoIter = TokenTreeIter;
                fn into_iter( self ) -> TokenTreeIter {
                    self.take_inner().into_iter()
                }
            }

            thread_local! {
                static SOURCE_MAP: RefCell<SourceMap> = RefCell::new(SourceMap {
                   
                   
                    files: vec![FileInfo {
                        source_text: String::new(),
                        span: Span { lo: 0, hi: 0 },
                        lines: vec![0],
                        char_index_to_byte_offset: BTreeMap::new(),
                    }],
                });
            }

            pub fn invalidate_current_thread_spans() {
                #[cfg(not(fuzzing))]
                SOURCE_MAP.with(|sm| sm.borrow_mut().files.truncate(1));
            }

            struct FileInfo {
                source_text: String,
                span: Span,
                lines: Vec<usize>,
                char_index_to_byte_offset: BTreeMap<usize, usize>,
            }

            impl FileInfo
            {
                fn offset_line_column( &self, offset: usize) -> LineColumn {
                    assert!(self.span_within(Span {
                        lo: offset as u32,
                        hi: offset as u32,
                    }));
                    let offset = offset - self.span.lo as usize;
                    match self.lines.binary_search(&offset) {
                        Ok(found) => LineColumn {
                            line: found + 1,
                            column: 0,
                        },
                        Err(idx) => LineColumn {
                            line: idx,
                            column: offset - self.lines[idx - 1],
                        },
                    }
                }

                fn span_within( &self, span: Span) -> bool
        {
                    span.lo >= self.span.lo && span.hi <= self.span.hi
                }

                fn byte_range(&mut self, span: Span) -> Range<usize>
                {
                    let lo_char = (span.lo - self.span.lo) as usize;

                   
                   
                   
                    let (&last_char_index, &last_byte_offset) = self
                        .char_index_to_byte_offset
                        .range(..=lo_char)
                        .next_back()
                        .unwrap_or((&0, &0));

                    let lo_byte = if last_char_index == lo_char {
                        last_byte_offset
                    } else {
                        let total_byte_offset = match self.source_text[last_byte_offset..]
                            .char_indices()
                            .nth(lo_char - last_char_index)
                        {
                            Some((additional_offset, _ch)) => last_byte_offset + additional_offset,
                            None => self.source_text.len(),
                        };
                        self.char_index_to_byte_offset
                            .insert(lo_char, total_byte_offset);
                        total_byte_offset
                    };

                    let trunc_lo = &self.source_text[lo_byte..];
                    let char_len = (span.hi - span.lo) as usize;
                    lo_byte..match trunc_lo.char_indices().nth(char_len) {
                        Some((offset, _ch)) => lo_byte + offset,
                        None => self.source_text.len(),
                    }
                }

                fn source_text(&mut self, span: Span) -> String
                {
                    let byte_range = self.byte_range(span);
                    self.source_text[byte_range].to_owned()
                }
            }
            /// Computes the offsets of each line in the given source string and the total number of characters
            fn lines_offsets(s: &str) -> (usize, Vec<usize>)
            {
                let mut lines = vec![0];
                let mut total = 0;

                for ch in s.chars() {
                    total += 1;
                    if ch == '\n' {
                        lines.push(total);
                    }
                }

                (total, lines)
            }

            struct SourceMap {
                files: Vec<FileInfo>,
            }

            impl SourceMap
            {
                fn next_start_pos( &self ) -> u32 {

                   
                   
                    self.files.last().unwrap().span.hi + 1
                }

                fn add_file(&mut self, src: &str) -> Span
                {
                    let (len, lines) = lines_offsets(src);
                    let lo = self.next_start_pos();
                    let span = Span {
                        lo,
                        hi: lo + (len as u32),
                    };

                    self.files.push(FileInfo {
                        source_text: src.to_owned(),
                        span,
                        lines,
                       
                        char_index_to_byte_offset: BTreeMap::new(),
                    });

                    span
                }

                fn find( &self, span: Span) -> usize {
                    match self.files.binary_search_by(|file| {
                        if file.span.hi < span.lo {
                            Ordering::Less
                        } else if file.span.lo > span.hi {
                            Ordering::Greater
                        } else {
                            assert!(file.span_within(span));
                            Ordering::Equal
                        }
                    }) {
                        Ok(i) => i,
                        Err(_) => unreachable!("Invalid span with no related FileInfo!"),
                    }
                }

                fn filepath( &self, span: Span) -> String
                {
                    let i = self.find(span);
                    if i == 0 {
                        "<unspecified>".to_owned()
                    } else {
                        format!("<parsed string {}>", i)
                    }
                }

                fn fileinfo( &self, span: Span) -> &FileInfo
                {
                    let i = self.find(span);
                    &self.files[i]
                }

                fn fileinfo_mut(&mut self, span: Span) -> &mut FileInfo
                {
                    let i = self.find(span);
                    &mut self.files[i]
                }
            }

            #[derive(Clone, Copy, PartialEq, Eq)]
            pub struct Span {
                    pub lo: u32,
                    pub hi: u32,
            }

            impl Span 
            {
                pub fn call_site() -> Self {
                    Span { lo: 0, hi: 0 }
                }

                pub fn mixed_site() -> Self {
                    Span::call_site()
                }
                
                pub fn def_site() -> Self {
                    Span::call_site()
                }

                pub fn resolved_at( &self, _other: Span) -> Span {
                    *self
                }

                pub fn located_at( &self, other: Span) -> Span {
                    other
                }

                pub fn byte_range( &self ) -> Range<usize>
                    {
                    #[cfg(fuzzing)]
                    return 0..0;

                    #[cfg(not(fuzzing))]
                    {
                        if self.is_call_site() {
                            0..0
                        } else {
                            SOURCE_MAP.with(|sm| sm.borrow_mut().fileinfo_mut(*self).byte_range(*self))
                        }
                    }
                }

                pub fn start( &self ) -> LineColumn {
                    #[cfg(fuzzing)]
                    return LineColumn { line: 0, column: 0 };

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                        let fi = sm.fileinfo(*self);
                        fi.offset_line_column(self.lo as usize)
                    })
                }

                pub fn end( &self ) -> LineColumn {
                    #[cfg(fuzzing)]
                    return LineColumn { line: 0, column: 0 };

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                        let fi = sm.fileinfo(*self);
                        fi.offset_line_column(self.hi as usize)
                    })
                }

                pub fn file( &self ) -> String {
                    #[cfg(fuzzing)]
                    return "<unspecified>".to_owned();

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                        sm.filepath(*self)
                    })
                }

                pub fn local_file( &self ) -> Option<PathBuf>
                    {
                    None
                }

                pub fn join( &self, other: Span) -> Option<Span>
                    {
                    #[cfg(fuzzing)]
                    return {
                        let _ = other;
                        None
                    };

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                       
                        if !sm.fileinfo(*self).span_within(other) {
                            return None;
                        }
                        Some(Span {
                            lo: cmp::min(self.lo, other.lo),
                            hi: cmp::max(self.hi, other.hi),
                        })
                    })
                }
                
                pub fn source_text( &self ) -> Option<String>
                    {
                    #[cfg(fuzzing)]
                    return None;

                    #[cfg(not(fuzzing))]
                    {
                        if self.is_call_site() {
                            None
                        } else {
                            Some(SOURCE_MAP.with(|sm| sm.borrow_mut().fileinfo_mut(*self).source_text(*self)))
                        }
                    }
                }
                
                pub fn first_byte( self ) -> Self {
                    Span {
                        lo: self.lo,
                        hi: cmp::min(self.lo.saturating_add(1), self.hi),
                    }
                }

                pub fn last_byte( self ) -> Self {
                    Span {
                        lo: cmp::max(self.hi.saturating_sub(1), self.lo),
                        hi: self.hi,
                    }
                }
                
                fn is_call_site( &self ) -> bool
        {
                    self.lo == 0 && self.hi == 0
                }
            }

            impl Debug for Span
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                            return write!(f, "bytes({}..{})", self.lo, self.hi);

                }
            }

            pub fn debug_span_field_if_nontrivial(debug: &mut fmt::DebugStruct, span: Span) {
                    {
                    if span.is_call_site() {
                        return;
                    }
                }

                if cfg!(span_locations) {
                    debug.field("span", &span);
                }
            }

            #[derive(Clone)]
            pub struct Group {
                delimiter: Delimiter,
                stream: TokenStream,
                span: Span,
            }

            impl Group
            {
                pub fn new(delimiter: Delimiter, stream: TokenStream) -> Self {
                    Group {
                        delimiter,
                        stream,
                        span: Span::call_site(),
                    }
                }

                pub fn delimiter( &self ) -> Delimiter {
                    self.delimiter
                }

                pub fn stream( &self ) -> TokenStream {
                    self.stream.clone()
                }

                pub fn span( &self ) -> Span {
                    self.span
                }

                pub fn span_open( &self ) -> Span {
                    self.span.first_byte()
                }

                pub fn span_close( &self ) -> Span {
                    self.span.last_byte()
                }

                pub fn set_span(&mut self, span: Span) {
                    self.span = span;
                }
            }

            impl Display for Group 
            {
               
               
               
               
               
               
               
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    let (open, close) = match self.delimiter {
                        Delimiter::Parenthesis => ("(", ")"),
                        Delimiter::Brace => ("{ ", "}"),
                        Delimiter::Bracket => ("[", "]"),
                        Delimiter::None => ("", ""),
                    };

                    f.write_str(open)?;
                    Display::fmt(&self.stream, f)?;
                    /*
                    if self.delimiter == Delimiter::Brace && !self.stream.inner.is_empty() {
                        f.write_str(" ")?;
                    } */
                    f.write_str(close)?;

                    Ok(())
                }
            }

            impl Debug for Group
            {
                fn fmt( &self, fmt: &mut fmt::Formatter) -> fmt::Result
                {
                    let mut debug = fmt.debug_struct("Group");
                    debug.field("delimiter", &self.delimiter);
                    debug.field("stream", &self.stream);
                    debug_span_field_if_nontrivial(&mut debug, self.span);
                    debug.finish()
                }
            }

            #[derive(Clone)]
            pub struct Ident 
            {
                sym: Box<str>,
                span: Span,
                raw: bool,
            }

            impl Ident 
            {
                #[track_caller]
                pub fn new_checked(string: &str, span: Span) -> Self {
                    validate_ident(string);
                    Ident::new_unchecked(string, span)
                }

                pub fn new_unchecked(string: &str, span: Span) -> Self {
                    Ident {
                        sym: Box::from(string),
                        span,
                        raw: false,
                    }
                }

                #[track_caller]
                pub fn new_raw_checked(string: &str, span: Span) -> Self {
                    validate_ident_raw(string);
                    Ident::new_raw_unchecked(string, span)
                }

                pub fn new_raw_unchecked(string: &str, span: Span) -> Self {
                    Ident {
                        sym: Box::from(string),
                        span,
                        raw: true,
                    }
                }

                pub fn span( &self ) -> Span {
                    self.span
                }

                pub fn set_span(&mut self, span: Span) {
                    self.span = span;
                }
            }

            #[track_caller] fn validate_ident(string: &str) {
                if string.is_empty() {
                    panic!("Ident is not allowed to be empty; use Option<Ident>");
                }

                if string.bytes().all(|digit| b'0' <= digit && digit <= b'9') {
                    panic!("Ident cannot be a number; use Literal instead");
                }

                fn ident_ok(string: &str) -> bool
                {
                    let mut chars = string.chars();
                    let first = chars.next().unwrap();
                    if !::is::ident_start(first) {
                        return false;
                    }
                    for ch in chars {
                        if !::is::ident_continue(ch) {
                            return false;
                        }
                    }
                    true
                }

                if !ident_ok(string) {
                    panic!("{:?} is not a valid Ident", string);
                }
            }

            #[track_caller] fn validate_ident_raw(string: &str) {
                validate_ident(string);

                match string {
                    "_" | "super" | "self" | "Self" | "crate" =>
                    {
                        panic!("`r#{}` cannot be a raw identifier", string);
                    }
                    _ =>
                    {}
                }
            }

            impl PartialEq for Ident
            {
                fn eq( &self, other: &Ident) -> bool
        {
                    self.sym == other.sym && self.raw == other.raw
                }
            }

            impl<T> PartialEq<T> for Ident where
            T: ?Sized + AsRef<str>
            {
                fn eq( &self, other: &T) -> bool
                {
                    let other = other.as_ref();
                    if self.raw {
                        other.starts_with("r#") && *self.sym == other[2..]
                    } else {
                        *self.sym == *other
                    }
                }
            }

            impl Display for Ident
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                    if self.raw {
                        f.write_str("r#")?;
                    }
                    Display::fmt(&self.sym, f)
                }
            }
            
            impl Debug for Ident
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
               
                {
                    let mut debug = f.debug_struct("Ident");
                    debug.field("sym", &format_args!("{}", self));
                    debug_span_field_if_nontrivial(&mut debug, self.span);
                    debug.finish()
                }
            }

            #[derive(Clone)]
            pub struct Literal {
                pub repr: String,
                span: Span,
            }

            impl Literal
            {
                pub fn _new(repr: String) -> Self {
                    Literal {
                        repr,
                        span: Span::call_site(),
                    }
                }

                pub fn from_str_checked(repr: &str) -> Result<Self, LexError>
                {
                    let mut cursor = get_cursor(repr);
                            let lo = cursor.off;

                    let negative = cursor.starts_with_char('-');
                    if negative {
                        cursor = cursor.advance(1);
                        if !cursor.starts_with_fn(|ch| ch.is_ascii_digit()) {
                            return Err(LexError::call_site());
                        }
                    }

                    if let Ok((rest, mut literal)) = parse::literal(cursor) {
                        if rest.is_empty() {
                            if negative {
                                literal.repr.insert(0, '-');
                            }
                            literal.span = Span {
                                                    lo,
                                                    hi: rest.off,
                            };
                            return Ok(literal);
                        }
                    }
                    Err(LexError::call_site())
                }

                pub unsafe fn from_str_unchecked(repr: &str) -> Self {
                    Literal::_new(repr.to_owned())
                }

                suffixed_numbers! {
                    u8_suffixed => u8,
                    u16_suffixed => u16,
                    u32_suffixed => u32,
                    u64_suffixed => u64,
                    u128_suffixed => u128,
                    usize_suffixed => usize,
                    i8_suffixed => i8,
                    i16_suffixed => i16,
                    i32_suffixed => i32,
                    i64_suffixed => i64,
                    i128_suffixed => i128,
                    isize_suffixed => isize,

                    f32_suffixed => f32,
                    f64_suffixed => f64,
                }

                unsuffixed_numbers! {
                    u8_unsuffixed => u8,
                    u16_unsuffixed => u16,
                    u32_unsuffixed => u32,
                    u64_unsuffixed => u64,
                    u128_unsuffixed => u128,
                    usize_unsuffixed => usize,
                    i8_unsuffixed => i8,
                    i16_unsuffixed => i16,
                    i32_unsuffixed => i32,
                    i64_unsuffixed => i64,
                    i128_unsuffixed => i128,
                    isize_unsuffixed => isize,
                }

                pub fn f32_unsuffixed(f: f32) -> Literal
                {
                    let mut s = f.to_string();
                    if !s.contains('.') {
                        s.push_str(".0");
                    }
                    Literal::_new(s)
                }

                pub fn f64_unsuffixed(f: f64) -> Literal
                {
                    let mut s = f.to_string();
                    if !s.contains('.') {
                        s.push_str(".0");
                    }
                    Literal::_new(s)
                }

                pub fn string(string: &str) -> Literal
                {
                    let mut repr = String::with_capacity(string.len() + 2);
                    repr.push('"');
                    escape_utf8(string, &mut repr);
                    repr.push('"');
                    Literal::_new(repr)
                }

                pub fn character(ch: char) -> Literal
                {
                    let mut repr = String::new();
                    repr.push('\'');
                    if ch == '"' {
                       
                        repr.push(ch);
                    } else {
                        repr.extend(ch.escape_debug());
                    }
                    repr.push('\'');
                    Literal::_new(repr)
                }

                pub fn byte_character(byte: u8) -> Literal
                {
                    let mut repr = "b'".to_string();
                    #[allow(clippy::match_overlapping_arm)]
                    match byte {
                        b'\0' => repr.push_str(r"\0"),
                        b'\t' => repr.push_str(r"\t"),
                        b'\n' => repr.push_str(r"\n"),
                        b'\r' => repr.push_str(r"\r"),
                        b'\'' => repr.push_str(r"\'"),
                        b'\\' => repr.push_str(r"\\"),
                        b'\x20'..=b'\x7E' => repr.push(byte as char),
                        _ =>
                    {
                            let _ = write!(repr, r"\x{:02X}", byte);
                        }
                    }
                    repr.push('\'');
                    Literal::_new(repr)
                }

                pub fn byte_string(bytes: &[u8]) -> Literal
                {
                    let mut repr = "b\"".to_string();
                    let mut bytes = bytes.iter();
                    while let Some(&b) = bytes.next() {
                        #[allow(clippy::match_overlapping_arm)]
                        match b {
                            b'\0' => repr.push_str(match bytes.as_slice().first() {
                               
                                Some(b'0'..=b'7') => r"\x00",
                                _ => r"\0",
                            }),
                            b'\t' => repr.push_str(r"\t"),
                            b'\n' => repr.push_str(r"\n"),
                            b'\r' => repr.push_str(r"\r"),
                            b'"' => repr.push_str("\\\""),
                            b'\\' => repr.push_str(r"\\"),
                            b'\x20'..=b'\x7E' => repr.push(b as char),
                            _ =>
                    {
                                let _ = write!(repr, r"\x{:02X}", b);
                            }
                        }
                    }
                    repr.push('"');
                    Literal::_new(repr)
                }

                pub fn c_string(string: &CStr) -> Literal
                {
                    let mut repr = "c\"".to_string();
                    let mut bytes = string.to_bytes();
                    while !bytes.is_empty() {
                        let (valid, invalid) = match str::from_utf8(bytes) {
                            Ok(all_valid) =>
                    {
                                bytes = b"";
                                (all_valid, bytes)
                            }
                            Err(utf8_error) =>
                    {
                                let (valid, rest) = bytes.split_at(utf8_error.valid_up_to());
                                let valid = str::from_utf8(valid).unwrap();
                                let invalid = utf8_error
                                    .error_len()
                                    .map_or(rest, |error_len| &rest[..error_len]);
                                bytes = &bytes[valid.len() + invalid.len()..];
                                (valid, invalid)
                            }
                        };
                        escape_utf8(valid, &mut repr);
                        for &byte in invalid {
                            let _ = write!(repr, r"\x{:02X}", byte);
                        }
                    }
                    repr.push('"');
                    Literal::_new(repr)
                }

                pub fn span( &self ) -> Span {
                    self.span
                }

                pub fn set_span(&mut self, span: Span) {
                    self.span = span;
                }

                pub fn subspan<R: RangeBounds<usize>>( &self, range: R) -> Option<Span> 
                {
                    use ::ops::Bound;

                    let lo = match range.start_bound() {
                        Bound::Included(start) =>
                    {
                            let start = u32::try_from(*start).ok()?;
                            self.span.lo.checked_add(start)?
                        }
                        Bound::Excluded(start) =>
                    {
                            let start = u32::try_from(*start).ok()?;
                            self.span.lo.checked_add(start)?.checked_add(1)?
                        }
                        Bound::Unbounded => self.span.lo,
                    };
                    let hi = match range.end_bound() {
                        Bound::Included(end) =>
                    {
                            let end = u32::try_from(*end).ok()?;
                            self.span.lo.checked_add(end)?.checked_add(1)?
                        }
                        Bound::Excluded(end) =>
                    {
                            let end = u32::try_from(*end).ok()?;
                            self.span.lo.checked_add(end)?
                        }
                        Bound::Unbounded => self.span.hi,
                    };
                    if lo <= hi && hi <= self.span.hi {
                        Some(Span { lo, hi })
                    } else {
                        None
                    }
                }
            }

            impl Display for Literal
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                    Display::fmt(&self.repr, f)
                }
            }

            impl Debug for Literal
            {
                fn fmt( &self, fmt: &mut fmt::Formatter) -> fmt::Result
                {
                    let mut debug = fmt.debug_struct("Literal");
                    debug.field("lit", &format_args!("{}", self.repr));
                    debug_span_field_if_nontrivial(&mut debug, self.span);
                    debug.finish()
                }
            }
            
            pub trait FromStr2: FromStr<Err = proc_macro::LexError>
            {
                    fn valid(src: &str) -> bool;

                    fn from_str_checked(src: &str) -> Result<Self, imp::LexError>
                    {
                   
                   
                   
                    if !Self::valid(src) {
                        return Err(imp::LexError::CompilerPanic);
                    }

                   
                    match panic::catch_unwind(|| Self::from_str(src)) {
                        Ok(Ok(ok)) => Ok(ok),
                        Ok(Err(lex)) => Err(imp::LexError::Compiler(lex)),
                        Err(_panic) => Err(imp::LexError::CompilerPanic),
                    }
                }

                fn from_str_unchecked(src: &str) -> Self {
                    Self::from_str(src).unwrap()
                }
            }
            
            impl FromStr2 for proc_macro::TokenStream
            {
                fn valid(src: &str) -> bool 
                {
                    TokenStream::from_str_checked(src).is_ok()
                }
            }
            
            impl FromStr2 for proc_macro::Literal
            {
                fn valid(src: &str) -> bool 
                {
                    Literal::from_str_checked(src).is_ok()
                }
            }

            fn escape_utf8(string: &str, repr: &mut String)
            {
                let mut chars = string.chars();
                while let Some(ch) = chars.next() {
                    if ch == '\0' {
                        repr.push_str(
                            if chars
                                .as_str()
                                .starts_with(|next| '0' <= next && next <= '7')
                            {
                               
                                r"\x00"
                            } else {
                                r"\0"
                            },
                        );
                    } else if ch == '\'' {
                       
                        repr.push(ch);
                    } else {
                        repr.extend(ch.escape_debug());
                    }
                }
            }
        }
           
        pub mod imp
        {
            use ::
            {
                ffi::{ CStr },
                fmt::{ self, Debug, Display },
                ops::{ Range, RangeBounds },
                path::{ PathBuf },
                process::
                {
                    macros::
                    {
                        detection::inside_proc_macro,
                        fallback::{self, FromStr2 as _},
                        location::LineColumn,
                        probe::{ proc_macro_span, proc_macro_span_file, proc_macro_span_location },
                        Delimiter, Punct, Spacing, TokenTree,                        
                    },
                },
                *,
            };
            /*
            */
            #[derive(Clone)]
            pub enum TokenStream 
            {
                Compiler(DeferredTokenStream),
                Fallback(fallback::TokenStream),
            }

            #[derive(Clone)]
            pub struct DeferredTokenStream 
            {
                stream: proc_macro::TokenStream,
                extra: Vec<proc_macro::TokenTree>,
            }

            pub enum LexError
            {
                Compiler(proc_macro::LexError),
                Fallback(fallback::LexError),
                CompilerPanic,
            }

            #[cold] fn mismatch(line: u32) -> !
            {
                let backtrace = ::backtrace::Backtrace::force_capture();
                panic!("compiler/fallback mismatch L{}\n\n{}", line, backtrace)
            }

            impl DeferredTokenStream           
            {
                fn new(stream: proc_macro::TokenStream) -> Self
                {
                    DeferredTokenStream
                    {
                        stream,
                        extra: Vec::new(),
                    }
                }

                fn is_empty( &self ) -> bool { self.stream.is_empty() && self.extra.is_empty() }

                fn evaluate_now( &mut self )
                {
                    if !self.extra.is_empty() { self.stream.extend(self.extra.drain(..)); }
                }

                fn into_token_stream(mut self) -> proc_macro::TokenStream
                {
                    self.evaluate_now();
                    self.stream
                }
            }

            impl TokenStream           
            {
                pub fn new() -> Self
                {
                    if inside_proc_macro() {
                        TokenStream::Compiler(DeferredTokenStream::new(proc_macro::TokenStream::new()))
                    } else {
                        TokenStream::Fallback(fallback::TokenStream::new())
                    }
                }

                pub fn from_str_checked(src: &str) -> Result<Self, LexError>
                    {
                    if inside_proc_macro() {
                        Ok(TokenStream::Compiler(DeferredTokenStream::new(
                            proc_macro::TokenStream::from_str_checked(src)?,
                        )))
                    } else {
                        Ok(TokenStream::Fallback(
                            fallback::TokenStream::from_str_checked(src)?,
                        ))
                    }
                }

                pub fn is_empty( &self ) -> bool
                {
                    match self {
                        TokenStream::Compiler(tts) => tts.is_empty(),
                        TokenStream::Fallback(tts) => tts.is_empty(),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::TokenStream
                {
                    match self {
                        TokenStream::Compiler(s) => s.into_token_stream(),
                        TokenStream::Fallback(_) => mismatch(line!()),
                    }
                }

                fn unwrap_stable( self ) -> fallback::TokenStream           
                {
                    match self {
                        TokenStream::Compiler(_) => mismatch(line!()),
                        TokenStream::Fallback(s) => s,
                    }
                }
            }

            impl Display for TokenStream                  
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        TokenStream::Compiler(tts) => Display::fmt(&tts.clone().into_token_stream(), f),
                        TokenStream::Fallback(tts) => Display::fmt(tts, f),
                    }
                }
            }

            impl From<proc_macro::TokenStream> for TokenStream           
            {
                fn from(inner: proc_macro::TokenStream) -> Self
                {
                    TokenStream::Compiler(DeferredTokenStream::new(inner))
                }
            }

            impl From<TokenStream> for proc_macro::TokenStream           
            {
                fn from(inner: TokenStream) -> Self
                {
                    match inner {
                        TokenStream::Compiler(inner) => inner.into_token_stream(),
                        TokenStream::Fallback(inner) =>
                    {
                            proc_macro::TokenStream::from_str_unchecked(&inner.to_string())
                        }
                    }
                }
            }

            impl From<fallback::TokenStream> for TokenStream           
            {
                fn from(inner: fallback::TokenStream) -> Self
                {
                    TokenStream::Fallback(inner)
                }
            }
            
            fn into_compiler_token(token: TokenTree) -> proc_macro::TokenTree
            {
                match token {
                    TokenTree::Group(tt) => proc_macro::TokenTree::Group(tt.inner.unwrap_nightly()),
                    TokenTree::Punct(tt) =>
                    {
                        let spacing = match tt.spacing() {
                            Spacing::Joint => proc_macro::Spacing::Joint,
                            Spacing::Alone => proc_macro::Spacing::Alone,
                        };
                        let mut punct = proc_macro::Punct::new(tt.as_char(), spacing);
                        punct.set_span(tt.span().inner.unwrap_nightly());
                        proc_macro::TokenTree::Punct(punct)
                    }
                    TokenTree::Ident(tt) => proc_macro::TokenTree::Ident(tt.inner.unwrap_nightly()),
                    TokenTree::Literal(tt) => proc_macro::TokenTree::Literal(tt.inner.unwrap_nightly()),
                }
            }

            impl From<TokenTree> for TokenStream           
            {
                fn from(token: TokenTree) -> Self
                {
                    if inside_proc_macro() {
                        TokenStream::Compiler(DeferredTokenStream::new(proc_macro::TokenStream::from(
                            into_compiler_token(token),
                        )))
                    } else {
                        TokenStream::Fallback(fallback::TokenStream::from(token))
                    }
                }
            }

            impl iter::FromIterator<TokenTree> for TokenStream           
            {
                fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self
                {
                    if inside_proc_macro() {
                        TokenStream::Compiler(DeferredTokenStream::new(
                            trees.into_iter().map(into_compiler_token).collect(),
                        ))
                    } else {
                        TokenStream::Fallback(trees.into_iter().collect())
                    }
                }
            }

            impl iter::FromIterator<TokenStream> for TokenStream
            {
                fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self
               
                {
                    let mut streams = streams.into_iter();
                    match streams.next() {
                        Some(TokenStream::Compiler(mut first)) =>
                    {
                            first.evaluate_now();
                            first.stream.extend(streams.map(|s| match s {
                                TokenStream::Compiler(s) => s.into_token_stream(),
                                TokenStream::Fallback(_) => mismatch(line!()),
                            }));
                            TokenStream::Compiler(first)
                        }
                        Some(TokenStream::Fallback(mut first)) =>
                    {
                            first.extend(streams.map(|s| match s {
                                TokenStream::Fallback(s) => s,
                                TokenStream::Compiler(_) => mismatch(line!()),
                            }));
                            TokenStream::Fallback(first)
                        }
                        None => TokenStream::new(),
                    }
                }
            }

            impl Extend<TokenTree> for TokenStream           
            {
                fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, stream: I)
                {
                    match self {
                        TokenStream::Compiler(tts) =>
                    {
                           
                            for token in stream {
                                tts.extra.push(into_compiler_token(token));
                            }
                        }
                        TokenStream::Fallback(tts) => tts.extend(stream),
                    }
                }
            }

            impl Extend<TokenStream> for TokenStream           
            {
                fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I)
                {
                    match self {
                        TokenStream::Compiler(tts) =>
                    {
                            tts.evaluate_now();
                            tts.stream
                                .extend(streams.into_iter().map(TokenStream::unwrap_nightly));
                        }
                        TokenStream::Fallback(tts) =>
                    {
                            tts.extend(streams.into_iter().map(TokenStream::unwrap_stable));
                        }
                    }
                }
            }

            impl Debug for TokenStream           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        TokenStream::Compiler(tts) => Debug::fmt(&tts.clone().into_token_stream(), f),
                        TokenStream::Fallback(tts) => Debug::fmt(tts, f),
                    }
                }
            }

            impl LexError
            {
                pub fn span( &self ) -> Span
                {
                    match self {
                        LexError::Compiler(_) | LexError::CompilerPanic => Span::call_site(),
                        LexError::Fallback(e) => Span::Fallback(e.span()),
                    }
                }
            }

            impl From<proc_macro::LexError> for LexError           
            {
                fn from(e: proc_macro::LexError) -> Self
                {
                    LexError::Compiler(e)
                }
            }

            impl From<fallback::LexError> for LexError           
            {
                fn from(e: fallback::LexError) -> Self
                {
                    LexError::Fallback(e)
                }
            }

            impl Debug for LexError           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        LexError::Compiler(e) => Debug::fmt(e, f),
                        LexError::Fallback(e) => Debug::fmt(e, f),
                        LexError::CompilerPanic =>
                    {
                            let fallback = fallback::LexError::call_site();
                            Debug::fmt(&fallback, f)
                        }
                    }
                }
            }

            impl Display for LexError           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        LexError::Compiler(e) => Display::fmt(e, f),
                        LexError::Fallback(e) => Display::fmt(e, f),
                        LexError::CompilerPanic =>
                    {
                            let fallback = fallback::LexError::call_site();
                            Display::fmt(&fallback, f)
                        }
                    }
                }
            }

            #[derive(Clone)]
            pub enum TokenTreeIter 
            {
                Compiler(proc_macro::token_stream::IntoIter),
                Fallback(fallback::TokenTreeIter),
            }

            impl IntoIterator for TokenStream
            {
                type Item = TokenTree;
                type IntoIter = TokenTreeIter;
                fn into_iter( self ) -> TokenTreeIter
                {
                    match self {
                        TokenStream::Compiler(tts) =>
                    {
                            TokenTreeIter::Compiler(tts.into_token_stream().into_iter())
                        }
                        TokenStream::Fallback(tts) => TokenTreeIter::Fallback(tts.into_iter()),
                    }
                }
            }

            impl Iterator for TokenTreeIter
            {
                type Item = TokenTree;
                fn next( &mut self ) -> Option<TokenTree>
                {
                    let token = match self {
                        TokenTreeIter::Compiler(iter) => iter.next()?,
                        TokenTreeIter::Fallback(iter) => return iter.next(),
                    };
                    Some(match token {
                        proc_macro::TokenTree::Group(tt) =>
                    {
                            TokenTree::Group(::process::macros::Group::_new(Group::Compiler(tt)))
                        }
                        proc_macro::TokenTree::Punct(tt) =>
                    {
                            let spacing = match tt.spacing() {
                                proc_macro::Spacing::Joint => Spacing::Joint,
                                proc_macro::Spacing::Alone => Spacing::Alone,
                            };
                            let mut o = Punct::new(tt.as_char(), spacing);
                            o.set_span(::process::macros::Span::_new(Span::Compiler(tt.span())));
                            TokenTree::Punct(o)
                        }
                        proc_macro::TokenTree::Ident(s) =>
                    {
                            TokenTree::Ident(::process::macros::Ident::_new(Ident::Compiler(s)))
                        }
                        proc_macro::TokenTree::Literal(l) =>
                    {
                            TokenTree::Literal(::process::macros::Literal::_new(Literal::Compiler(l)))
                        }
                    })
                }

                fn size_hint( &self ) -> (usize, Option<usize>)
                {
                    match self {
                        TokenTreeIter::Compiler(tts) => tts.size_hint(),
                        TokenTreeIter::Fallback(tts) => tts.size_hint(),
                    }
                }
            }

            #[derive(Copy, Clone)]
            pub enum Span
            {
                Compiler(proc_macro::Span),
                Fallback(fallback::Span),
            }

            impl Span           
            {
                pub fn call_site() -> Self
                {
                    if inside_proc_macro() {
                        Span::Compiler(proc_macro::Span::call_site())
                    } else {
                        Span::Fallback(fallback::Span::call_site())
                    }
                }

                pub fn mixed_site() -> Self
                {
                    if inside_proc_macro() {
                        Span::Compiler(proc_macro::Span::mixed_site())
                    } else {
                        Span::Fallback(fallback::Span::mixed_site())
                    }
                }
                
                pub fn def_site() -> Self
                {
                    Span::Fallback(fallback::Span::def_site())
                    /*
                    if inside_proc_macro() {
                        Span::Compiler(proc_macro::Span::def_site())
                    } else {
                        Span::Fallback(fallback::Span::def_site())
                    } */
                }

                pub fn resolved_at( &self, other: Span) -> Span 
                {
                    match (self, other) {
                        (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.resolved_at(b)),
                        (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.resolved_at(b)),
                        (Span::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Span::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                pub fn located_at( &self, other: Span) -> Span 
                {
                    match (self, other) {
                        (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.located_at(b)),
                        (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.located_at(b)),
                        (Span::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Span::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                pub fn unwrap( self ) -> proc_macro::Span
                {
                    match self {
                        Span::Compiler(s) => s,
                        Span::Fallback(_) => panic!("proc_macro::Span is only available in procedural macros"),
                    }
                }

                pub fn byte_range( &self ) -> Range<usize>
                {
                    match self {
                        #[cfg(proc_macro_span)]
                        Span::Compiler(s) => proc_macro_span::byte_range(s),
                        #[cfg(not(proc_macro_span))]
                        Span::Compiler(_) => 0..0,
                        Span::Fallback(s) => s.byte_range(),
                    }
                }

                pub fn start( &self ) -> LineColumn
                {
                    match self {
                        #[cfg(proc_macro_span_location)]
                        Span::Compiler(s) => LineColumn {
                            line: proc_macro_span_location::line(s),
                            column: proc_macro_span_location::column(s).saturating_sub(1),
                        },
                        #[cfg(not(proc_macro_span_location))]
                        Span::Compiler(_) => LineColumn { line: 0, column: 0 },
                        Span::Fallback(s) => s.start(),
                    }
                }

                pub fn end( &self ) -> LineColumn
                {
                    match self {
                        #[cfg(proc_macro_span_location)]
                        Span::Compiler(s) =>
                    {
                            let end = proc_macro_span_location::end(s);
                            LineColumn {
                                line: proc_macro_span_location::line(&end),
                                column: proc_macro_span_location::column(&end).saturating_sub(1),
                            }
                        }
                        #[cfg(not(proc_macro_span_location))]
                        Span::Compiler(_) => LineColumn { line: 0, column: 0 },
                        Span::Fallback(s) => s.end(),
                    }
                }

                pub fn file( &self ) -> String
                {
                    match self {
                        #[cfg(proc_macro_span_file)]
                        Span::Compiler(s) => proc_macro_span_file::file(s),
                        #[cfg(not(proc_macro_span_file))]
                        Span::Compiler(_) => "<token stream>".to_owned(),
                        Span::Fallback(s) => s.file(),
                    }
                }

                pub fn local_file( &self ) -> Option<PathBuf>
                {
                    match self {
                        #[cfg(proc_macro_span_file)]
                        Span::Compiler(s) => proc_macro_span_file::local_file(s),
                        #[cfg(not(proc_macro_span_file))]
                        Span::Compiler(_) => None,
                        Span::Fallback(s) => s.local_file(),
                    }
                }

                pub fn join( &self, other: Span) -> Option<Span> 
               
                {
                    let ret = match (self, other) {
                        #[cfg(proc_macro_span)]
                        (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(proc_macro_span::join(a, b)?),
                        (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.join(b)?),
                        _ => return None,
                    };
                    Some(ret)
                }
                
                pub fn eq( &self, other: &Span) -> bool 
                {
                    match (self, other)
                    {
                        //(Span::Compiler(a), Span::Compiler(b)) => a.eq(b),
                        (Span::Fallback(a), Span::Fallback(b)) => a.eq(b),
                        _ => false,
                    }
                }

                pub fn source_text( &self ) -> Option<String>
                {
                    match self {
                        #[cfg(not(no_source_text))]
                        Span::Compiler(s) => s.source_text(),
                        #[cfg(no_source_text)]
                        Span::Compiler(_) => None,
                        Span::Fallback(s) => s.source_text(),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Span
                {
                    match self {
                        Span::Compiler(s) => s,
                        Span::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<proc_macro::Span> for ::process::macros::Span           
            {
                fn from(proc_span: proc_macro::Span) -> Self
                {
                    ::process::macros::Span::_new(Span::Compiler(proc_span))
                }
            }

            impl From<fallback::Span> for Span           
            {
                fn from(inner: fallback::Span) -> Self
                {
                    Span::Fallback(inner)
                }
            }

            impl Debug for Span           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Span::Compiler(s) => Debug::fmt(s, f),
                        Span::Fallback(s) => Debug::fmt(s, f),
                    }
                }
            }

            pub fn debug_span_field_if_nontrivial(debug: &mut fmt::DebugStruct, span: Span)
            {
                match span {
                    Span::Compiler(s) =>
                    {
                        debug.field("span", &s);
                    }
                    Span::Fallback(s) => fallback::debug_span_field_if_nontrivial(debug, s),
                }
            }

            #[derive(Clone)]
            pub enum Group
            {
                Compiler(proc_macro::Group),
                Fallback(fallback::Group),
            }

            impl Group           
            {
                pub fn new(delimiter: Delimiter, stream: TokenStream) -> Self
                {
                    match stream {
                        TokenStream::Compiler(tts) =>
                    {
                            let delimiter = match delimiter {
                                Delimiter::Parenthesis => proc_macro::Delimiter::Parenthesis,
                                Delimiter::Bracket => proc_macro::Delimiter::Bracket,
                                Delimiter::Brace => proc_macro::Delimiter::Brace,
                                Delimiter::None => proc_macro::Delimiter::None,
                            };
                            Group::Compiler(proc_macro::Group::new(delimiter, tts.into_token_stream()))
                        }
                        TokenStream::Fallback(stream) =>
                    {
                            Group::Fallback(fallback::Group::new(delimiter, stream))
                        }
                    }
                }

                pub fn delimiter( &self ) -> Delimiter
                {
                    match self {
                        Group::Compiler(g) => match g.delimiter() {
                            proc_macro::Delimiter::Parenthesis => Delimiter::Parenthesis,
                            proc_macro::Delimiter::Bracket => Delimiter::Bracket,
                            proc_macro::Delimiter::Brace => Delimiter::Brace,
                            proc_macro::Delimiter::None => Delimiter::None,
                        },
                        Group::Fallback(g) => g.delimiter(),
                    }
                }

                pub fn stream( &self ) -> TokenStream
                {
                    match self {
                        Group::Compiler(g) => TokenStream::Compiler(DeferredTokenStream::new(g.stream())),
                        Group::Fallback(g) => TokenStream::Fallback(g.stream()),
                    }
                }

                pub fn span( &self ) -> Span
                {
                    match self {
                        Group::Compiler(g) => Span::Compiler(g.span()),
                        Group::Fallback(g) => Span::Fallback(g.span()),
                    }
                }

                pub fn span_open( &self ) -> Span
                {
                    match self {
                        Group::Compiler(g) => Span::Compiler(g.span_open()),
                        Group::Fallback(g) => Span::Fallback(g.span_open()),
                    }
                }

                pub fn span_close( &self ) -> Span
                {
                    match self {
                        Group::Compiler(g) => Span::Compiler(g.span_close()),
                        Group::Fallback(g) => Span::Fallback(g.span_close()),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match (self, span) {
                        (Group::Compiler(g), Span::Compiler(s)) => g.set_span(s),
                        (Group::Fallback(g), Span::Fallback(s)) => g.set_span(s),
                        (Group::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Group::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Group
                {
                    match self {
                        Group::Compiler(g) => g,
                        Group::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<fallback::Group> for Group           
            {
                fn from(g: fallback::Group) -> Self
                {
                    Group::Fallback(g)
                }
            }

            impl Display for Group           
            {
                fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Group::Compiler(group) => Display::fmt(group, formatter),
                        Group::Fallback(group) => Display::fmt(group, formatter),
                    }
                }
            }

            impl Debug for Group           
            {
                fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Group::Compiler(group) => Debug::fmt(group, formatter),
                        Group::Fallback(group) => Debug::fmt(group, formatter),
                    }
                }
            }

            #[derive(Clone)]
            pub enum Ident
            {
                Compiler(proc_macro::Ident),
                Fallback(fallback::Ident),
            }

            impl Ident 
            {
                #[track_caller]
                pub fn new_checked(string: &str, span: Span) -> Self
                {
                    match span {
                        Span::Compiler(s) => Ident::Compiler(proc_macro::Ident::new(string, s)),
                        Span::Fallback(s) => Ident::Fallback(fallback::Ident::new_checked(string, s)),
                    }
                }

                #[track_caller]
                pub fn new_raw_checked(string: &str, span: Span) -> Self
                {
                    match span {
                        Span::Compiler(s) => Ident::Compiler(proc_macro::Ident::new_raw(string, s)),
                        Span::Fallback(s) => Ident::Fallback(fallback::Ident::new_raw_checked(string, s)),
                    }
                }

                pub fn span( &self ) -> Span
                {
                    match self {
                        Ident::Compiler(t) => Span::Compiler(t.span()),
                        Ident::Fallback(t) => Span::Fallback(t.span()),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match (self, span) {
                        (Ident::Compiler(t), Span::Compiler(s)) => t.set_span(s),
                        (Ident::Fallback(t), Span::Fallback(s)) => t.set_span(s),
                        (Ident::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Ident::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Ident
                {
                    match self {
                        Ident::Compiler(s) => s,
                        Ident::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<fallback::Ident> for Ident           
            {
                fn from(inner: fallback::Ident) -> Self
                {
                    Ident::Fallback(inner)
                }
            }

            impl PartialEq for Ident           
            {
                fn eq( &self, other: &Ident) -> bool
        {
                    match (self, other) {
                        (Ident::Compiler(t), Ident::Compiler(o)) => t.to_string() == o.to_string(),
                        (Ident::Fallback(t), Ident::Fallback(o)) => t == o,
                        (Ident::Compiler(_), Ident::Fallback(_)) => mismatch(line!()),
                        (Ident::Fallback(_), Ident::Compiler(_)) => mismatch(line!()),
                    }
                }
            }

            impl<T> PartialEq<T> for Ident where
            T: ?Sized + AsRef<str>
            {
                fn eq( &self, other: &T) -> bool
                {
                    let other = other.as_ref();
                    match self {
                        Ident::Compiler(t) => t.to_string() == other,
                        Ident::Fallback(t) => t == other,
                    }
                }
            }

            impl Display for Ident           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Ident::Compiler(t) => Display::fmt(t, f),
                        Ident::Fallback(t) => Display::fmt(t, f),
                    }
                }
            }

            impl Debug for Ident           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Ident::Compiler(t) => Debug::fmt(t, f),
                        Ident::Fallback(t) => Debug::fmt(t, f),
                    }
                }
            }

            #[derive(Clone)]
            pub enum Literal 
            {
                Compiler(proc_macro::Literal),
                Fallback(fallback::Literal),
            }

            macro_rules! suffixed_numbers 
            {
                ($($name:ident => $kind:ident,)*) => ($(
                    pub fn $name(n: $kind) -> Literal {
                        if inside_proc_macro() {
                            Literal::Compiler(proc_macro::Literal::$name(n))
                        } else {
                            Literal::Fallback(fallback::Literal::$name(n))
                        }
                    }
                )*)
            }

            macro_rules! unsuffixed_integers 
            {
                ($($name:ident => $kind:ident,)*) => ($(
                    pub fn $name(n: $kind) -> Literal {
                        if inside_proc_macro() {
                            Literal::Compiler(proc_macro::Literal::$name(n))
                        } else {
                            Literal::Fallback(fallback::Literal::$name(n))
                        }
                    }
                )*)
            }

            impl Literal
            {
                pub fn from_str_checked(repr: &str) -> Result<Self, LexError>
                    {
                    if inside_proc_macro() {
                        let literal = proc_macro::Literal::from_str_checked(repr)?;
                        Ok(Literal::Compiler(literal))
                    } else {
                        let literal = fallback::Literal::from_str_checked(repr)?;
                        Ok(Literal::Fallback(literal))
                    }
                }

                pub unsafe fn from_str_unchecked(repr: &str) -> Self
                {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::from_str_unchecked(repr))
                    } else {
                        Literal::Fallback(unsafe { fallback::Literal::from_str_unchecked(repr) })
                    }
                }

                suffixed_numbers! {
                    u8_suffixed => u8,
                    u16_suffixed => u16,
                    u32_suffixed => u32,
                    u64_suffixed => u64,
                    u128_suffixed => u128,
                    usize_suffixed => usize,
                    i8_suffixed => i8,
                    i16_suffixed => i16,
                    i32_suffixed => i32,
                    i64_suffixed => i64,
                    i128_suffixed => i128,
                    isize_suffixed => isize,

                    f32_suffixed => f32,
                    f64_suffixed => f64,
                }

                unsuffixed_integers! {
                    u8_unsuffixed => u8,
                    u16_unsuffixed => u16,
                    u32_unsuffixed => u32,
                    u64_unsuffixed => u64,
                    u128_unsuffixed => u128,
                    usize_unsuffixed => usize,
                    i8_unsuffixed => i8,
                    i16_unsuffixed => i16,
                    i32_unsuffixed => i32,
                    i64_unsuffixed => i64,
                    i128_unsuffixed => i128,
                    isize_unsuffixed => isize,
                }

                pub fn f32_unsuffixed(f: f32) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::f32_unsuffixed(f))
                    } else {
                        Literal::Fallback(fallback::Literal::f32_unsuffixed(f))
                    }
                }

                pub fn f64_unsuffixed(f: f64) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::f64_unsuffixed(f))
                    } else {
                        Literal::Fallback(fallback::Literal::f64_unsuffixed(f))
                    }
                }

                pub fn string(string: &str) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::string(string))
                    } else {
                        Literal::Fallback(fallback::Literal::string(string))
                    }
                }

                pub fn character(ch: char) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::character(ch))
                    } else {
                        Literal::Fallback(fallback::Literal::character(ch))
                    }
                }

                pub fn byte_character(byte: u8) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler({
                            #[cfg(not(no_literal_byte_character))]
                            {
                                proc_macro::Literal::byte_character(byte)
                            }

                            #[cfg(no_literal_byte_character)]
                            {
                                let fallback = fallback::Literal::byte_character(byte);
                                proc_macro::Literal::from_str_unchecked(&fallback.repr)
                            }
                        })
                    } else {
                        Literal::Fallback(fallback::Literal::byte_character(byte))
                    }
                }

                pub fn byte_string(bytes: &[u8]) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::byte_string(bytes))
                    } else {
                        Literal::Fallback(fallback::Literal::byte_string(bytes))
                    }
                }

                pub fn c_string(string: &CStr) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler({
                            #[cfg(not(no_literal_c_string))]
                            {
                                proc_macro::Literal::c_string(string)
                            }

                            #[cfg(no_literal_c_string)]
                            {
                                let fallback = fallback::Literal::c_string(string);
                                proc_macro::Literal::from_str_unchecked(&fallback.repr)
                            }
                        })
                    } else {
                        Literal::Fallback(fallback::Literal::c_string(string))
                    }
                }

                pub fn span( &self ) -> Span
                {
                    match self {
                        Literal::Compiler(lit) => Span::Compiler(lit.span()),
                        Literal::Fallback(lit) => Span::Fallback(lit.span()),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match (self, span) {
                        (Literal::Compiler(lit), Span::Compiler(s)) => lit.set_span(s),
                        (Literal::Fallback(lit), Span::Fallback(s)) => lit.set_span(s),
                        (Literal::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Literal::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                pub fn subspan<R: RangeBounds<usize>>( &self, range: R) -> Option<Span>
                {
                    match self {
                        #[cfg(proc_macro_span)]
                        Literal::Compiler(lit) => proc_macro_span::subspan(lit, range).map(Span::Compiler),
                        #[cfg(not(proc_macro_span))]
                        Literal::Compiler(_lit) => None,
                        Literal::Fallback(lit) => lit.subspan(range).map(Span::Fallback),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Literal
                {
                    match self {
                        Literal::Compiler(s) => s,
                        Literal::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<fallback::Literal> for Literal           
            {
                fn from(s: fallback::Literal) -> Self
                {
                    Literal::Fallback(s)
                }
            }

            impl Display for Literal           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Literal::Compiler(t) => Display::fmt(t, f),
                        Literal::Fallback(t) => Display::fmt(t, f),
                    }
                }
            }

            impl Debug for Literal           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Literal::Compiler(t) => Debug::fmt(t, f),
                        Literal::Fallback(t) => Debug::fmt(t, f),
                    }
                }
            }
            
            pub fn invalidate_current_thread_spans()
            {
                if inside_proc_macro()
                {
                    panic!
                    (
                        "process::macros::extra::invalidate_current_thread_spans is not available in procedural macros"
                    );
                }
                
                else
                {
                    ::process::macros::fallback::invalidate_current_thread_spans();
                }
            }
        }
        
        pub mod location
        {
            use ::
            {
                cmp::{ Ordering },
                *,
            };
            /*
            */
            /// A line-column pair representing the start or end of a `Span`.
            #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
            pub struct LineColumn 
            {
                /// The 1-indexed line in the source file on which the span starts or ends (inclusive).
                pub line: usize,
                /// The 0-indexed column (in UT8) in the source file on which the span starts or ends (inclusive).
                pub column: usize,
            }

            impl Ord for LineColumn
            {
                fn cmp( &self, other: &Self) -> Ordering
                {
                    self.line
                    .cmp(&other.line)
                    .then(self.column.cmp(&other.column))
                }
            }

            impl PartialOrd for LineColumn
            {
                fn partial_cmp( &self, other: &Self) -> Option<Ordering>
                {
                    Some(self.cmp(other))
                }
            }
        }
        /**
        A wrapper around the procedural macro API of the compiler's [`proc_macro`] crate.*/
        pub mod parse
        {
            use ::
            {
                process::
                {
                    macros::
                    {
                        fallback::
                        {
                            self, Group, Ident, LexError, Literal, Span, TokenStream, TokenStreamBuilder,
                        },
                        Delimiter, Punct, Spacing, TokenTree,
                    },
                },
                str::{ Bytes, CharIndices, Chars },
                *,
            };
            /*
            */
            /// Rustc's representation of a macro expansion error in expression position or type position.
            pub const ERROR: &str = "(/*ERROR*/)";

            pub type PResult<'a, O> = Result<(Cursor<'a>, O), Reject>;

            #[derive(Copy, Clone, Eq, PartialEq)]
            pub struct Cursor<'a> 
            {
                pub rest: &'a str,
                    pub off: u32,
            }

            impl<'a> Cursor<'a>
            {
                pub fn advance( &self, bytes: usize) -> Cursor<'a>
                {
                    let (_front, rest) = self.rest.split_at(bytes);
                    Cursor {
                        rest,
                                    off: self.off + _front.chars().count() as u32,
                    }
                }

                pub fn starts_with( &self, s: &str) -> bool
        {
                    self.rest.starts_with(s)
                }

                pub fn starts_with_char( &self, ch: char) -> bool
        {
                    self.rest.starts_with(ch)
                }

                pub fn starts_with_fn<Pattern>( &self, f: Pattern) -> bool
                where
                    Pattern: FnMut(char) -> bool,
                {
                    self.rest.starts_with(f)
                }

                pub fn is_empty( &self ) -> bool
        {
                    self.rest.is_empty()
                }

                fn len( &self ) -> usize {
                    self.rest.len()
                }

                fn as_bytes( &self ) -> &'a [u8] {
                    self.rest.as_bytes()
                }

                fn bytes( &self ) -> Bytes<'a>
                    {
                    self.rest.bytes()
                }

                fn chars( &self ) -> Chars<'a>
                    {
                    self.rest.chars()
                }

                fn char_indices( &self ) -> CharIndices<'a>
                    {
                    self.rest.char_indices()
                }

                fn parse( &self, tag: &str) -> Result<Cursor<'a>, Reject>
                    {
                    if self.starts_with(tag) {
                        Ok(self.advance(tag.len()))
                    } else {
                        Err(Reject)
                    }
                }
            }

            pub struct Reject;
            
            fn skip_whitespace(input: Cursor) -> Cursor
            {
                let mut s = input;

                while !s.is_empty()
               
                {
                    let byte = s.as_bytes()[0];
                    
                    if byte == b'/'
                    {
                        if s.starts_with("//")
                            && (!s.starts_with("///") || s.starts_with("////"))
                            && !s.starts_with("//!")
                        {
                            let (cursor, _) = take_until_newline_or_eof(s);
                            s = cursor;
                            continue;
                        } else if s.starts_with("/**/") {
                            s = s.advance(4);
                            continue;
                        } else if s.starts_with("/*")
                            && (!s.starts_with("/**") || s.starts_with("/***"))
                            && !s.starts_with("/*!")
                        {
                            match block_comment(s) {
                                Ok((rest, _)) =>
                    {
                                    s = rest;
                                    continue;
                                }
                                Err(Reject) => return s,
                            }
                        }
                    }
                    
                    match byte
                    {
                        b' ' | 0x09..=0x0d =>
                        {
                            s = s.advance(1);
                            continue;
                        }

                        b if b.is_ascii() =>
                    {}
                        _ =>
                        {
                            let ch = s.chars().next().unwrap();

                            if is::whitespace(ch)
                            {
                                s = s.advance(ch.len_utf8());
                                continue;
                            }
                        }
                    }
                    return s;
                }
                s
            }

            fn block_comment(input: Cursor<'_>) -> PResult<'_, &str>
            {
                if !input.starts_with("/*") {
                    return Err(Reject);
                }

                let mut depth = 0usize;
                let bytes = input.as_bytes();
                let mut i = 0usize;
                let upper = bytes.len() - 1;

                while i < upper {
                    if bytes[i] == b'/' && bytes[i + 1] == b'*' {
                        depth += 1;
                        i += 1;
                    } else if bytes[i] == b'*' && bytes[i + 1] == b'/' {
                        depth -= 1;
                        if depth == 0 {
                            return Ok((input.advance(i + 2), &input.rest[..i + 2]));
                        }
                        i += 1;
                    }
                    i += 1;
                }

                Err(Reject)
            }

            fn word_break(input: Cursor) -> Result<Cursor, Reject>
            {
                match input.chars().next() {
                    Some(ch) if is::ident_continue(ch) => Err(Reject),
                    Some(_) | None => Ok(input),
                }
            }

            pub fn token_stream(mut input: Cursor) -> Result<TokenStream, LexError>
            {
                let mut trees = TokenStreamBuilder::new();
                let mut stack = Vec::new();

                loop {
                    input = skip_whitespace(input);

                    if let Ok((rest, ())) = doc_comment(input, &mut trees) {
                        input = rest;
                        continue;
                    }

                            let lo = input.off;

                    let first = match input.bytes().next() {
                        Some(first) => first,
                        None => match stack.last() {
                            None => return Ok(trees.build()),
                                            Some((lo, _frame)) =>
                    {
                                return Err(LexError {
                                    span: Span { lo: *lo, hi: *lo },
                                })
                            }
                        },
                    };

                    if let Some(open_delimiter) = match first {
                        b'(' if !input.starts_with(ERROR) => Some(Delimiter::Parenthesis),
                        b'[' => Some(Delimiter::Bracket),
                        b'{' => Some(Delimiter::Brace),
                        _ => None,
                    } {
                        input = input.advance(1);
                        let frame = (open_delimiter, trees);
                                    let frame = (lo, frame);
                        stack.push(frame);
                        trees = TokenStreamBuilder::new();
                    } else if let Some(close_delimiter) = match first {
                        b')' => Some(Delimiter::Parenthesis),
                        b']' => Some(Delimiter::Bracket),
                        b'}' => Some(Delimiter::Brace),
                        _ => None,
                    } {
                        let frame = match stack.pop() {
                            Some(frame) => frame,
                            None => return Err(lex_error(input)),
                        };
                                    let (lo, frame) = frame;
                        let (open_delimiter, outer) = frame;
                        if open_delimiter != close_delimiter {
                            return Err(lex_error(input));
                        }
                        input = input.advance(1);
                        let mut g = Group::new(open_delimiter, trees.build());
                        g.set_span(Span {
                                            lo,
                                            hi: input.off,
                        });
                        trees = outer;
                        trees.push_token_from_parser(TokenTree::Group(::process::macros::Group::_new_fallback(g)));
                    } else {
                        let (rest, mut tt) = match leaf_token(input) {
                            Ok((rest, tt)) => (rest, tt),
                            Err(Reject) => return Err(lex_error(input)),
                        };
                        tt.set_span(::process::macros::Span::_new_fallback(Span {
                                            lo,
                                            hi: rest.off,
                        }));
                        trees.push_token_from_parser(tt);
                        input = rest;
                    }
                }
            }

            fn lex_error(cursor: Cursor) -> LexError
            {
                LexError
                {
                    span: Span
                    {
                        lo:cursor.off,
                        hi:cursor.off,
                    },
                }
            }

            fn leaf_token(input: Cursor) -> PResult<TokenTree>
            {
                if let Ok((input, l)) = literal(input) {
                   
                    Ok((input, TokenTree::Literal(::process::macros::Literal::_new_fallback(l))))
                } else if let Ok((input, p)) = punct(input) {
                    Ok((input, TokenTree::Punct(p)))
                } else if let Ok((input, i)) = ident(input) {
                    Ok((input, TokenTree::Ident(i)))
                } else if input.starts_with(ERROR)
                {
                    let rest = input.advance(ERROR.len());
                    let repr = ::process::macros::Literal::_new_fallback(Literal::_new(ERROR.to_owned()));
                    Ok((rest, TokenTree::Literal(repr)))
                } else {
                    Err(Reject)
                }
            }

            fn ident(input: Cursor) -> PResult<::process::macros::Ident>
            {
                if [
                    "r\"", "r#\"", "r##", "b\"", "b\'", "br\"", "br#", "c\"", "cr\"", "cr#",
                ]
                .iter()
                .any(|prefix| input.starts_with(prefix))
                {
                    Err(Reject)
                } else {
                    ident_any(input)
                }
            }

            fn ident_any(input: Cursor) -> PResult<::process::macros::Ident>
            {
                let raw = input.starts_with("r#");
                let rest = input.advance((raw as usize) << 1);

                let (rest, sym) = ident_not_raw(rest)?;

                if !raw
                {
                    let ident =
                        ::process::macros::Ident::_new_fallback(Ident::new_unchecked(sym, fallback::Span::call_site()));
                    return Ok((rest, ident));
                }

                match sym {
                    "_" | "super" | "self" | "Self" | "crate" => return Err(Reject),
                    _ =>
                    {}
                }

                let ident =
                    ::process::macros::Ident::_new_fallback(Ident::new_raw_unchecked(sym, fallback::Span::call_site()));
                Ok((rest, ident))
            }

            fn ident_not_raw(input: Cursor<'_>) -> PResult<'_, &str>
            {
                let mut chars = input.char_indices();

                match chars.next() {
                    Some((_, ch)) if is::ident_start(ch) =>
                    {}
                    _ => return Err(Reject),
                }

                let mut end = input.len();
                for (i, ch) in chars {
                    if !is::ident_continue(ch) {
                        end = i;
                        break;
                    }
                }

                Ok((input.advance(end), &input.rest[..end]))
            }

            pub fn literal(input: Cursor) -> PResult<Literal>
            {
                let rest = literal_nocapture(input)?;
                let end = input.len() - rest.len();
                Ok((rest, Literal::_new(input.rest[..end].to_string())))
            }

            fn literal_nocapture(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(ok) = string(input) {
                    Ok(ok)
                } else if let Ok(ok) = byte_string(input) {
                    Ok(ok)
                } else if let Ok(ok) = c_string(input) {
                    Ok(ok)
                } else if let Ok(ok) = byte(input) {
                    Ok(ok)
                } else if let Ok(ok) = character(input) {
                    Ok(ok)
                } else if let Ok(ok) = float(input) {
                    Ok(ok)
                } else if let Ok(ok) = int(input) {
                    Ok(ok)
                } else {
                    Err(Reject)
                }
            }

            fn literal_suffix(input: Cursor) -> Cursor
            {
                match ident_not_raw(input) {
                    Ok((input, _)) => input,
                    Err(Reject) => input,
                }
            }

            fn string(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(input) = input.parse("\"") {
                    cooked_string(input)
                } else if let Ok(input) = input.parse("r") {
                    raw_string(input)
                } else {
                    Err(Reject)
                }
            }

            fn cooked_string(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let mut chars = input.char_indices();

                while let Some((i, ch)) = chars.next( )
                {
                    match ch {
                        '"' =>
                    {
                            let input = input.advance(i + 1);
                            return Ok(literal_suffix(input));
                        }
                        '\r' => match chars.next() {
                            Some((_, '\n')) =>
                    {}
                            _ => break,
                        },
                        '\\' => match chars.next() {
                            Some((_, 'x')) =>
                    {
                                backslash_x_char(&mut chars)?;
                            }
                            Some((_, 'n' | 'r' | 't' | '\\' | '\'' | '"' | '0')) =>
                    {}
                            Some((_, 'u')) =>
                    {
                                backslash_u(&mut chars)?;
                            }
                            Some((newline, ch @ ('\n' | '\r'))) =>
                    {
                                input = input.advance(newline + 1);
                                trailing_backslash(&mut input, ch as u8)?;
                                chars = input.char_indices();
                            }
                            _ => break,
                        },
                        _ch =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn raw_string(input: Cursor) -> Result<Cursor, Reject>
            {
                let (input, delimiter) = delimiter_of_raw_string(input)?;
                let mut bytes = input.bytes().enumerate();
                while let Some((i, byte)) = bytes.next( )
                {
                    match byte {
                        b'"' if input.rest[i + 1..].starts_with(delimiter) =>
                    {
                            let rest = input.advance(i + 1 + delimiter.len());
                            return Ok(literal_suffix(rest));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        _ =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn byte_string(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(input) = input.parse("b\"") {
                    cooked_byte_string(input)
                } else if let Ok(input) = input.parse("br") {
                    raw_byte_string(input)
                } else {
                    Err(Reject)
                }
            }

            fn cooked_byte_string(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let mut bytes = input.bytes().enumerate();
                while let Some((offset, b)) = bytes.next( )
                {
                    match b {
                        b'"' =>
                    {
                            let input = input.advance(offset + 1);
                            return Ok(literal_suffix(input));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        b'\\' => match bytes.next() {
                            Some((_, b'x')) =>
                    {
                                backslash_x_byte(&mut bytes)?;
                            }
                            Some((_, b'n' | b'r' | b't' | b'\\' | b'0' | b'\'' | b'"')) =>
                    {}
                            Some((newline, b @ (b'\n' | b'\r'))) =>
                    {
                                input = input.advance(newline + 1);
                                trailing_backslash(&mut input, b)?;
                                bytes = input.bytes().enumerate();
                            }
                            _ => break,
                        },
                        b if b.is_ascii() =>
                    {}
                        _ => break,
                    }
                }
                Err(Reject)
            }

            fn delimiter_of_raw_string(input: Cursor<'_>) -> PResult<'_, &str>
            {
                for (i, byte) in input.bytes().enumerate( )
                {
                    match byte {
                        b'"' =>
                    {
                            if i > 255 {
                               
                                return Err(Reject);
                            }
                            return Ok((input.advance(i + 1), &input.rest[..i]));
                        }
                        b'#' =>
                    {}
                        _ => break,
                    }
                }
                Err(Reject)
            }

            fn raw_byte_string(input: Cursor) -> Result<Cursor, Reject>
            {
                let (input, delimiter) = delimiter_of_raw_string(input)?;
                let mut bytes = input.bytes().enumerate();
                while let Some((i, byte)) = bytes.next( )
                {
                    match byte {
                        b'"' if input.rest[i + 1..].starts_with(delimiter) =>
                    {
                            let rest = input.advance(i + 1 + delimiter.len());
                            return Ok(literal_suffix(rest));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        other =>
                    {
                            if !other.is_ascii() {
                                break;
                            }
                        }
                    }
                }
                Err(Reject)
            }

            fn c_string(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(input) = input.parse("c\"") {
                    cooked_c_string(input)
                } else if let Ok(input) = input.parse("cr") {
                    raw_c_string(input)
                } else {
                    Err(Reject)
                }
            }

            fn raw_c_string(input: Cursor) -> Result<Cursor, Reject>
            {
                let (input, delimiter) = delimiter_of_raw_string(input)?;
                let mut bytes = input.bytes().enumerate();
                while let Some((i, byte)) = bytes.next( )
                {
                    match byte {
                        b'"' if input.rest[i + 1..].starts_with(delimiter) =>
                    {
                            let rest = input.advance(i + 1 + delimiter.len());
                            return Ok(literal_suffix(rest));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        b'\0' => break,
                        _ =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn cooked_c_string(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let mut chars = input.char_indices();

                while let Some((i, ch)) = chars.next( )
                {
                    match ch {
                        '"' =>
                    {
                            let input = input.advance(i + 1);
                            return Ok(literal_suffix(input));
                        }
                        '\r' => match chars.next() {
                            Some((_, '\n')) =>
                    {}
                            _ => break,
                        },
                        '\\' => match chars.next() {
                            Some((_, 'x')) =>
                    {
                                backslash_x_nonzero(&mut chars)?;
                            }
                            Some((_, 'n' | 'r' | 't' | '\\' | '\'' | '"')) =>
                    {}
                            Some((_, 'u')) =>
                    {
                                if backslash_u(&mut chars)? == '\0' {
                                    break;
                                }
                            }
                            Some((newline, ch @ ('\n' | '\r'))) =>
                    {
                                input = input.advance(newline + 1);
                                trailing_backslash(&mut input, ch as u8)?;
                                chars = input.char_indices();
                            }
                            _ => break,
                        },
                        '\0' => break,
                        _ch =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn byte(input: Cursor) -> Result<Cursor, Reject>
            {
                let input = input.parse("b'")?;
                let mut bytes = input.bytes().enumerate();
                let ok = match bytes.next().map(|(_, b)| b) {
                    Some(b'\\') => match bytes.next().map(|(_, b)| b) {
                        Some(b'x') => backslash_x_byte(&mut bytes).is_ok(),
                        Some(b'n' | b'r' | b't' | b'\\' | b'0' | b'\'' | b'"') => true,
                        _ => false,
                    },
                    b => b.is_some(),
                };
                if !ok {
                    return Err(Reject);
                }
                let (offset, _) = bytes.next().ok_or(Reject)?;
                if !input.chars().as_str().is_char_boundary(offset) {
                    return Err(Reject);
                }
                let input = input.advance(offset).parse("'")?;
                Ok(literal_suffix(input))
            }

            fn character(input: Cursor) -> Result<Cursor, Reject>
            {
                let input = input.parse("'")?;
                let mut chars = input.char_indices();
                let ok = match chars.next().map(|(_, ch)| ch) {
                    Some('\\') => match chars.next().map(|(_, ch)| ch) {
                        Some('x') => backslash_x_char(&mut chars).is_ok(),
                        Some('u') => backslash_u(&mut chars).is_ok(),
                        Some('n' | 'r' | 't' | '\\' | '0' | '\'' | '"') => true,
                        _ => false,
                    },
                    ch => ch.is_some(),
                };
                if !ok {
                    return Err(Reject);
                }
                let (idx, _) = chars.next().ok_or(Reject)?;
                let input = input.advance(idx).parse("'")?;
                Ok(literal_suffix(input))
            }
            
            fn backslash_x_char<I>(chars: &mut I) -> Result<(), Reject> where
            I: Iterator<Item = (usize, char)>,
            {
                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='7' => ch,
                        _ => return Err(Reject),
                    },
                    None => todo!(),
                };

                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='9' | 'a'..='f' | 'A'..='F' => ch,
                        _ => return Err(Reject),
                    },
                    None => todo!(),
                };

                Ok(())
            } 

            fn backslash_x_byte<I>(chars: &mut I) -> Result<(), Reject> where
            I: Iterator<Item = (usize, u8)>,
            {
                /*
                ($chars:ident @ $pat:pat) =>
                {
                    match $chars.next()
                    {
                        Some((_, ch)) => match ch
                        {
                            $pat => ch,
                            _ => return Err(Reject),
                        },
                        None => return Err(Reject),
                    }
                };
                */
                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };

                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };

                Ok(())
            }

            fn backslash_x_nonzero<I>(chars: &mut I) -> Result<(), Reject> where
            I: Iterator<Item = (usize, char)>,
            {
                let first = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='9' | 'a'..='f' | 'A'..='F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };
                
                let second = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='9' | 'a'..='f' | 'A'..='F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };
                
                if first == '0' && second == '0' {
                    Err(Reject)
                } else {
                    Ok(())
                }
            }

            fn backslash_u<I>(chars: &mut I) -> Result<char, Reject> where
            I: Iterator<Item = (usize, char)>,
            {
                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '{' => ch,
                        _ => return Err(Reject),
                    },
                    None => todo!(),
                };

                let mut value = 0;
                let mut len = 0;
                for (_, ch) in chars
                {
                    let digit = match ch {
                        '0'..='9' => ch as u8 - b'0',
                        'a'..='f' => 10 + ch as u8 - b'a',
                        'A'..='F' => 10 + ch as u8 - b'A',
                        '_' if len > 0 => continue,
                        '}' if len > 0 => return char::from_u32(value).ok_or(Reject),
                        _ => break,
                    };
                    if len == 6 {
                        break;
                    }
                    value *= 0x10;
                    value += u32::from(digit);
                    len += 1;
                }
                Err(Reject)
            }

            fn trailing_backslash(input: &mut Cursor, mut last: u8) -> Result<(), Reject>
            {
                let mut whitespace = input.bytes().enumerate();
                loop {
                    if last == b'\r' && whitespace.next().map_or(true, |(_, b)| b != b'\n') {
                        return Err(Reject);
                    }
                    match whitespace.next() {
                        Some((_, b @ (b' ' | b'\t' | b'\n' | b'\r'))) =>
                    {
                            last = b;
                        }
                        Some((offset, _)) =>
                    {
                            *input = input.advance(offset);
                            return Ok(());
                        }
                        None => return Err(Reject),
                    }
                }
            }

            fn float(input: Cursor) -> Result<Cursor, Reject>
            {
                let mut rest = float_digits(input)?;
                if let Some(ch) = rest.chars().next() {
                    if is::ident_start(ch) {
                        rest = ident_not_raw(rest)?.0;
                    }
                }
                word_break(rest)
            }

            fn float_digits(input: Cursor) -> Result<Cursor, Reject>
            {
                let mut chars = input.chars().peekable();
                match chars.next() {
                    Some(ch) if '0' <= ch && ch <= '9' =>
                    {}
                    _ => return Err(Reject),
                }

                let mut len = 1;
                let mut has_dot = false;
                let mut has_exp = false;
                while let Some(&ch) = chars.peek( )
                {
                    match ch {
                        '0'..='9' | '_' =>
                    {
                            chars.next();
                            len += 1;
                        }
                        '.' =>
                    {
                            if has_dot {
                                break;
                            }
                            chars.next();
                            if chars
                                .peek()
                                .map_or(false, |&ch| ch == '.' || is::ident_start(ch))
                            {
                                return Err(Reject);
                            }
                            len += 1;
                            has_dot = true;
                        }
                        'e' | 'E' =>
                    {
                            chars.next();
                            len += 1;
                            has_exp = true;
                            break;
                        }
                        _ => break,
                    }
                }

                if !(has_dot || has_exp) {
                    return Err(Reject);
                }

                if has_exp
                {
                    let token_before_exp = if has_dot {
                        Ok(input.advance(len - 1))
                    } else {
                        Err(Reject)
                    };
                    let mut has_sign = false;
                    let mut has_exp_value = false;
                    while let Some(&ch) = chars.peek() {
                        match ch {
                            '+' | '-' =>
                    {
                                if has_exp_value {
                                    break;
                                }
                                if has_sign {
                                    return token_before_exp;
                                }
                                chars.next();
                                len += 1;
                                has_sign = true;
                            }
                            '0'..='9' =>
                    {
                                chars.next();
                                len += 1;
                                has_exp_value = true;
                            }
                            '_' =>
                    {
                                chars.next();
                                len += 1;
                            }
                            _ => break,
                        }
                    }
                    if !has_exp_value {
                        return token_before_exp;
                    }
                }

                Ok(input.advance(len))
            }

            fn int(input: Cursor) -> Result<Cursor, Reject>
            {
                let mut rest = digits(input)?;
                if let Some(ch) = rest.chars().next() {
                    if is::ident_start(ch) {
                        rest = ident_not_raw(rest)?.0;
                    }
                }
                word_break(rest)
            }

            fn digits(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let base = if input.starts_with("0x") {
                    input = input.advance(2);
                    16
                } else if input.starts_with("0o") {
                    input = input.advance(2);
                    8
                } else if input.starts_with("0b") {
                    input = input.advance(2);
                    2
                } else {
                    10
                };

                let mut len = 0;
                let mut empty = true;
                for b in input.bytes( )
                {
                    match b {
                        b'0'..=b'9' =>
                    {
                            let digit = (b - b'0') as u64;
                            if digit >= base {
                                return Err(Reject);
                            }
                        }
                        b'a'..=b'f' =>
                    {
                            let digit = 10 + (b - b'a') as u64;
                            if digit >= base {
                                break;
                            }
                        }
                        b'A'..=b'F' =>
                    {
                            let digit = 10 + (b - b'A') as u64;
                            if digit >= base {
                                break;
                            }
                        }
                        b'_' =>
                    {
                            if empty && base == 10 {
                                return Err(Reject);
                            }
                            len += 1;
                            continue;
                        }
                        _ => break,
                    }
                    len += 1;
                    empty = false;
                }
                if empty {
                    Err(Reject)
                } else {
                    Ok(input.advance(len))
                }
            }

            fn punct(input: Cursor) -> PResult<Punct>
            {
                let (rest, ch) = punct_char(input)?;
                if ch == '\''
                {
                    let (after_lifetime, _ident) = ident_any(rest)?;
                    if after_lifetime.starts_with_char('\'')
                        || (after_lifetime.starts_with_char('#') && !rest.starts_with("r#"))
                    {
                        Err(Reject)
                    } else {
                        Ok((rest, Punct::new('\'', Spacing::Joint)))
                    }
                } else
                {
                    let kind = match punct_char(rest) {
                        Ok(_) => Spacing::Joint,
                        Err(Reject) => Spacing::Alone,
                    };
                    Ok((rest, Punct::new(ch, kind)))
                }
            }

            fn punct_char(input: Cursor) -> PResult<char>
            {
                if input.starts_with("//") || input.starts_with("/*") {
                   
                    return Err(Reject);
                }

                let mut chars = input.chars();
                let first = match chars.next() {
                    Some(ch) => ch,
                    None =>
                    {
                        return Err(Reject);
                    }
                };
                let recognized = "~!@#$%^&*-=+|;:,<.>/?'";
                if recognized.contains(first) {
                    Ok((input.advance(first.len_utf8()), first))
                } else {
                    Err(Reject)
                }
            }

            fn doc_comment<'a>(input: Cursor<'a>, trees: &mut TokenStreamBuilder) -> PResult<'a, ()>
            {
                let lo = input.off;
                let (rest, (comment, inner)) = doc_comment_contents(input)?;
                let fallback_span = Span {
                            lo,
                            hi: rest.off,
                };
                let span = ::process::macros::Span::_new_fallback(fallback_span);

                let mut scan_for_bare_cr = comment;
                while let Some(cr) = scan_for_bare_cr.find('\r')
                {
                    let rest = &scan_for_bare_cr[cr + 1..];
                    if !rest.starts_with('\n') {
                        return Err(Reject);
                    }
                    scan_for_bare_cr = rest;
                }

                let mut pound = Punct::new('#', Spacing::Alone);
                pound.set_span(span);
                trees.push_token_from_parser(TokenTree::Punct(pound));

                if inner
                {
                    let mut bang = Punct::new('!', Spacing::Alone);
                    bang.set_span(span);
                    trees.push_token_from_parser(TokenTree::Punct(bang));
                }

                let doc_ident = ::process::macros::Ident::_new_fallback(Ident::new_unchecked("doc", fallback_span));
                let mut equal = Punct::new('=', Spacing::Alone);
                equal.set_span(span);
                let mut literal = ::process::macros::Literal::_new_fallback(Literal::string(comment));
                literal.set_span(span);
                let mut bracketed = TokenStreamBuilder::with_capacity(3);
                bracketed.push_token_from_parser(TokenTree::Ident(doc_ident));
                bracketed.push_token_from_parser(TokenTree::Punct(equal));
                bracketed.push_token_from_parser(TokenTree::Literal(literal));
                let group = Group::new(Delimiter::Bracket, bracketed.build());
                let mut group = ::process::macros::Group::_new_fallback(group);
                group.set_span(span);
                trees.push_token_from_parser(TokenTree::Group(group));

                Ok((rest, ()))
            }

            fn doc_comment_contents(input: Cursor<'_>) -> PResult<'_, (&str, bool)>
            {
                if input.starts_with("//!")
                {
                    let input = input.advance(3);
                    let (input, s) = take_until_newline_or_eof(input);
                    Ok((input, (s, true)))
                } else if input.starts_with("/*!")
                {
                    let (input, s) = block_comment(input)?;
                    Ok((input, (&s[3..s.len() - 2], true)))
                } else if input.starts_with("///")
                {
                    let input = input.advance(3);
                    if input.starts_with_char('/') {
                        return Err(Reject);
                    }
                    let (input, s) = take_until_newline_or_eof(input);
                    Ok((input, (s, false)))
                } else if input.starts_with("/**") && !input.rest[3..].starts_with('*')
                {
                    let (input, s) = block_comment(input)?;
                    Ok((input, (&s[3..s.len() - 2], false)))
                } else {
                    Err(Reject)
                }
            }

            fn take_until_newline_or_eof(input: Cursor<'_>) -> (Cursor<'_>, &str) 
            {
                let chars = input.char_indices();

                for (i, ch) in chars {
                    if ch == '\n' {
                        return (input.advance(i), &input.rest[..i]);
                    } else if ch == '\r' && input.rest[i + 1..].starts_with('\n') {
                        return (input.advance(i + 1), &input.rest[..i]);
                    }
                }

                (input.advance(input.len()), input.rest)
            }
        }

        pub mod probe
        {
            use ::
            {
                *,
            };
            /*
            */
            pub mod proc_macro_span
            {
                use ::
                {
                    ops::{ Range, RangeBounds },
                    path::{ PathBuf },
                    proc_macro::{ Literal, Span },
                    *,
                };
                /*
                */
                pub fn byte_range(this: &Span) -> Range<usize>
                {
                    //this.byte_range()
                    Range { start: 0, end: 0 }
                }
                pub fn start(this: &Span) -> Span { this.start() }
                pub fn end(this: &Span) -> Span { this.end() }
                pub fn line(this: &Span) -> usize { this.line() }
                pub fn column(this: &Span) -> usize { this.column() }
                pub fn file(this: &Span) -> String { this.file() }
                pub fn local_file(this: &Span) -> Option<PathBuf>
                    { this.local_file() }
                pub fn join(this: &Span, other: Span) -> Option<Span> 
                {
                    //this.join(other)
                    None
                }
                pub fn subspan<R:RangeBounds<usize>>( this:&Literal, range:R ) -> Option<Span>
                {
                    //this.subspan( range )
                    None
                }
                /*
               
                #[cfg(procmacro2_build_probe)] */
                const _: Option<&str> = option_env!("RUSTC_BOOTSTRAP");
            }
            
            pub mod proc_macro_span_file
            {
                use ::
                {
                    path::PathBuf,
                    proc_macro::Span,
                    *,
                };
                /*
                */
                pub fn file(this: &Span) -> String {
                    this.file()
                }

                pub fn local_file(this: &Span) -> Option<PathBuf>
                    {
                    this.local_file()
                }
            }
            
            pub mod proc_macro_span_location
            {
                use ::
                {
                    proc_macro::Span,
                    *,
                };
                /*
                */
                pub fn start(this: &Span) -> Span { this.start() }
                pub fn end(this: &Span) -> Span { this.end() }
                pub fn line(this: &Span) -> usize { this.line() }
                pub fn column(this: &Span) -> usize { this.column() }
            }
            
        }

        pub mod rcvec
        {
            use ::
            {
                rc::{ Rc },
                panic::{ RefUnwindSafe },
                *,
            };
            /*
            use alloc::rc::Rc;
            use alloc::vec;
            use core::mem;
            use core::panic::RefUnwindSafe;
            use core::slice;
            */
            pub struct RcVec<T>
            {
                inner: rc::Rc<Vec<T>>,
            }

            pub struct RcVecBuilder<T>
            {
                inner: Vec<T>,
            }

            pub struct RcVecMut<'a, T>
            {
                inner: &'a mut Vec<T>,
            }

            #[derive(Clone)]
            pub struct RcVecIntoIter<T>
            {
                inner: vec::IntoIter<T>,
            }

            impl<T> RcVec<T>
            {
                pub fn is_empty( &self ) -> bool 
                {
                    self.inner.is_empty()
                }

                pub fn len( &self ) -> usize 
                {
                    self.inner.len()
                }

                pub fn iter( &self ) -> slice::Iter<'_, T>
                {
                    self.inner.iter()
                }

                pub fn make_mut( &mut self ) -> RcVecMut<'_, T> where
                T: Clone,
                {
                    RcVecMut {
                        inner: rc::Rc::make_mut(&mut self.inner),
                    }
                }

                pub fn get_mut( &mut self ) -> Option<RcVecMut<'_, T>>
               
                {
                    let inner = rc::Rc::get_mut(&mut self.inner)?;
                    Some(RcVecMut { inner })
                }

                pub fn make_owned(mut self) -> RcVecBuilder<T> where
                T: Clone,
               
                {
                    let vec = if let Some(owned) = rc::Rc::get_mut(&mut self.inner) {
                        mem::take(owned)
                    } else {
                        Vec::clone(&self.inner)
                    };
                    RcVecBuilder { inner: vec }
                }
            }

            impl<T> RcVecBuilder<T>
            {
                pub fn new() -> Self {
                    RcVecBuilder { inner: Vec::new() }
                }

                pub fn with_capacity(cap: usize) -> Self {
                    RcVecBuilder {
                        inner: Vec::with_capacity(cap),
                    }
                }

                pub fn push(&mut self, element: T) {
                    self.inner.push(element);
                }

                pub fn extend(&mut self, iter: impl IntoIterator<Item = T>) {
                    self.inner.extend(iter);
                }

                pub fn as_mut( &mut self ) -> RcVecMut<'_, T>
                {
                    RcVecMut {
                        inner: &mut self.inner,
                    }
                }

                pub fn build( self ) -> RcVec<T>
                    {
                    RcVec {
                        inner: rc::Rc::new(self.inner),
                    }
                }
            }

            impl<'a, T> RcVecMut<'a, T>
            {
                pub fn push(&mut self, element: T) {
                    self.inner.push(element);
                }

                pub fn extend(&mut self, iter: impl IntoIterator<Item = T>) {
                    self.inner.extend(iter);
                }

                pub fn as_mut( &mut self ) -> RcVecMut<'_, T> 
                {
                    RcVecMut { inner: self.inner }
                }

                pub fn take( self ) -> RcVecBuilder<T>
                {
                    let vec = mem::take(self.inner);
                    RcVecBuilder { inner: vec }
                }
            }

            impl<T> Clone for RcVec<T>           
            {
                fn clone( &self ) -> Self
                {
                    RcVec {
                        inner: rc::Rc::clone(&self.inner),
                    }
                }
            }

            impl<T> IntoIterator for RcVecBuilder<T>
            {
                type Item = T;
                type IntoIter = RcVecIntoIter<T>;
                fn into_iter( self ) -> Self::IntoIter
                {
                    RcVecIntoIter
                    {
                        inner: self.inner.into_iter(),
                    }
                }
            }

            impl<T> Iterator for RcVecIntoIter<T>
            {
                type Item = T;
                fn next( &mut self ) -> Option<Self::Item>
                    { self.inner.next() }
                
                fn size_hint( &self ) -> (usize, Option<usize>) { self.inner.size_hint() }
            }

            impl<T> RefUnwindSafe for RcVec<T> where
            T:RefUnwindSafe
            {}
        }
        /// Public implementation details for the `TokenStream` type, such as iterators.
        pub mod token_stream 
        {
            use ::
            {
                fmt::{ self, Debug },
                marker::{ ProcMacroAutoTraits, MARKER },
                process::macros::
                {
                    imp, TokenStream, TokenTree
                },
                *,
            };
            /// An iterator over `TokenStream`'s `TokenTree`s.
            #[derive(Clone)]
            pub struct IntoIter
            {
                inner: imp::TokenTreeIter,
                _marker: ProcMacroAutoTraits,
            }

            impl Iterator for IntoIter
            {
                type Item = TokenTree;
                fn next( &mut self ) -> Option<TokenTree>
                {
                    self.inner.next()
                }

                fn size_hint( &self ) -> (usize, Option<usize>)
                {
                    self.inner.size_hint()
                }
            }

            impl Debug for IntoIter
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    f.write_str("TokenStream ")?;
                    f.debug_list().entries(self.clone()).finish()
                }
            }

            impl IntoIterator for TokenStream
            {
                type Item = TokenTree;
                type IntoIter = IntoIter;
                fn into_iter( self ) -> IntoIter
                {
                    IntoIter {
                        inner: self.inner.into_iter(),
                        _marker: ::marker::MARKER,
                    }
                }
            }
        }
        /// An abstract stream of tokens, or more concretely a sequence of token trees
        #[derive(Clone)]
        pub struct TokenStream
        {
            inner: imp::TokenStream,
            _marker: ::marker::ProcMacroAutoTraits,
        }
        /// Error returned from `TokenStream::from_str`.
        pub struct LexError
        {
            inner: imp::LexError,
            _marker: ::marker::ProcMacroAutoTraits,
        }

        impl TokenStream       
        {
            fn _new(inner: imp::TokenStream) -> Self {
                TokenStream {
                    inner,
                    _marker: marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::TokenStream) -> Self {
                TokenStream {
                    inner: imp::TokenStream::from(inner),
                    _marker: marker::MARKER,
                }
            }
            /// Returns an empty `TokenStream` containing no token trees.
            pub fn new() -> Self {
                TokenStream::_new(imp::TokenStream::new())
            }
            /// Checks if this `TokenStream` is empty.
            pub fn is_empty( &self ) -> bool           
            {
                self.inner.is_empty()
            }
        }
        /// `TokenStream::default()` returns an empty stream, equivalent with `TokenStream::new()`.
        impl Default for TokenStream       
        {
            fn default() -> Self {
                TokenStream::new()
            }
        }
        /// Attempts to break the string into tokens and parse those tokens into a token stream.
        impl str::FromStr for TokenStream
        {
            type Err = LexError;
            fn from_str(src: &str) -> Result<TokenStream, LexError>
            {
                match imp::TokenStream::from_str_checked(src) {
                    Ok(tokens) => Ok(TokenStream::_new(tokens)),
                    Err(lex) => Err(LexError {
                        inner: lex,
                        _marker: marker::MARKER,
                    }),
                }
            }
        }
        
        impl From<proc_macro::TokenStream> for TokenStream       
        {
            fn from(inner: proc_macro::TokenStream) -> Self {
                TokenStream::_new(imp::TokenStream::from(inner))
            }
        }
        
        impl From<TokenStream> for proc_macro::TokenStream       
        {
            fn from(inner: TokenStream) -> Self {
                proc_macro::TokenStream::from(inner.inner)
            }
        }

        impl From<TokenTree> for TokenStream       
        {
            fn from(token: TokenTree) -> Self {
                TokenStream::_new(imp::TokenStream::from(token))
            }
        }

        impl Extend<TokenTree> for TokenStream       
        {
            fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, streams: I)
            {
                self.inner.extend(streams);
            }
        }

        impl Extend<TokenStream> for TokenStream       
        {
            fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I)
            {
                self.inner
                    .extend(streams.into_iter().map(|stream| stream.inner));
            }
        }
        /// Collects a number of token trees into a single stream.
        impl iter::FromIterator<TokenTree> for TokenStream       
        {
            fn from_iter<I: IntoIterator<Item = TokenTree>>(streams: I) -> Self {
                TokenStream::_new(streams.into_iter().collect())
            }
        }
        impl iter::FromIterator<TokenStream> for TokenStream       
        {
            fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {
                TokenStream::_new(streams.into_iter().map(|i| i.inner).collect())
            }
        }
        /// Prints the token stream as a string that is supposed to be losslessly
        /// convertible back into the same token stream (modulo spans), except for
        /// possibly `TokenTree::Group`s with `Delimiter::None` delimiters and negative
        /// numeric literals.
        impl Display for TokenStream       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, f)
            }
        }
        /// Prints token in a form convenient for debugging.
        impl Debug for TokenStream       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }

        impl LexError 
        {
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
        }

        impl Debug for LexError
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }

        impl Display for LexError
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, f)
            }
        }

        impl Error for LexError {}
        /// A region of source code, along with macro expansion information.
        #[derive(Copy, Clone)]
        pub struct Span
        {
            inner: imp::Span,
            _marker: marker::ProcMacroAutoTraits,
        }

        impl Span
        {
            fn _new(inner: imp::Span) -> Self {
                Span {
                    inner,
                    _marker: marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::Span) -> Self 
            {
                Span {
                    inner: imp::Span::from(inner),
                    _marker: marker::MARKER,
                }
            }
            /// The span of the invocation of the current procedural macro
            pub fn call_site() -> Self 
            {
                Span::_new(imp::Span::call_site())
            }
            /// The span located at the invocation of the procedural macro,
            /// but with local variables, labels, and `$crate` resolved at the definition site of the macro.
            pub fn mixed_site() -> Self 
            {
                Span::_new(imp::Span::mixed_site())
            }
            /// A span that resolves at the macro definition site.
            pub fn def_site() -> Self 
            {
                Span::_new(imp::Span::def_site())
            }
            /// Creates a new span with the same line/column information as `self` but
            /// that resolves symbols as though it were at `other`.
            pub fn resolved_at( &self, other: Span) -> Span 
            {
                Span::_new(self.inner.resolved_at(other.inner))
            }
            /// Creates a new span with the same name resolution behavior as `self` but
            /// with the line/column information of `other`.
            pub fn located_at( &self, other: Span) -> Span 
            {
                Span::_new(self.inner.located_at(other.inner))
            }
            /// Convert `process::macros::Span` to `proc_macro::Span`
            pub fn unwrap( self ) -> proc_macro::Span 
           
            {
                self.inner.unwrap()
            }
           
            pub fn unstable( self ) -> proc_macro::Span
           
            {
                self.unwrap()
            }
            /// Returns the span's byte position range in the source file
            pub fn byte_range( &self ) -> Range<usize>
           
            {
                self.inner.byte_range()
            }
            /// Get the starting line/column in the source file for this span
            pub fn start( &self ) -> location::LineColumn
           
            {
                self.inner.start()
            }
            /// Get the ending line/column in the source file for this span
            pub fn end( &self ) -> location::LineColumn
           
            {
                self.inner.end()
            }
            /// The path to the source file in which this span occurs, for display purposes
            pub fn file( &self ) -> String
           
            {
                self.inner.file()
            }
            /// The path to the source file in which this span occurs on disk.
            pub fn local_file( &self ) -> Option<PathBuf>
           
            {
                self.inner.local_file()
            }
            /// Create a new span encompassing `self` and `other`.
            pub fn join( &self, other: Span) -> Option<Span>
           
            {
                self.inner.join(other.inner).map(Span::_new)
            }
            /// Compares two spans to see if they're equal.
            pub fn eq( &self, other: &Span) -> bool
            {
                self.inner.eq(&other.inner)
            }
            /// Returns the source text behind a span.
            pub fn source_text( &self ) -> Option<String>
           
            {
                self.inner.source_text()
            }
        }
        /// Prints a span in a form convenient for debugging.
        impl Debug for Span
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }
        /// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).
        #[derive(Clone)]
        pub enum TokenTree 
        {
            /// A token stream surrounded by bracket delimiters.
            Group(Group),
            /// An identifier.
            Ident(Ident),
            /// A single punctuation character (`+`, `,`, `$`, etc.).
            Punct(Punct),
            /// A literal character (`'a'`), string (`"hello"`), number (`2.3`), etc.
            Literal(Literal),
        }

        impl TokenTree 
        {
            /// Returns the span of this tree, 
            /// delegating to the `span` method of the contained token or a delimited stream.
            pub fn span( &self ) -> Span {
                match self {
                    TokenTree::Group(t) => t.span(),
                    TokenTree::Ident(t) => t.span(),
                    TokenTree::Punct(t) => t.span(),
                    TokenTree::Literal(t) => t.span(),
                }
            }
            /// Configures the span for *only this token*
            pub fn set_span(&mut self, span: Span) {
                match self {
                    TokenTree::Group(t) => t.set_span(span),
                    TokenTree::Ident(t) => t.set_span(span),
                    TokenTree::Punct(t) => t.set_span(span),
                    TokenTree::Literal(t) => t.set_span(span),
                }
            }
        }

        impl From<Group> for TokenTree
        {
            fn from(g: Group) -> Self {
                TokenTree::Group(g)
            }
        }

        impl From<Ident> for TokenTree
        {
            fn from(g: Ident) -> Self {
                TokenTree::Ident(g)
            }
        }

        impl From<Punct> for TokenTree
        {
            fn from(g: Punct) -> Self {
                TokenTree::Punct(g)
            }
        }

        impl From<Literal> for TokenTree
        {
            fn from(g: Literal) -> Self {
                TokenTree::Literal(g)
            }
        }
        /**
            Prints the token tree as a string that is losslessly convertible back into the same tree (modulo spans),
            except for `TokenTree::Group`s with `Delimiter::None` delimiters and negative numeric literals. */
        impl Display for TokenTree       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                match self {
                    TokenTree::Group(t) => Display::fmt(t, f),
                    TokenTree::Ident(t) => Display::fmt(t, f),
                    TokenTree::Punct(t) => Display::fmt(t, f),
                    TokenTree::Literal(t) => Display::fmt(t, f),
                }
            }
        }
        /// Prints token tree in a form convenient for debugging.
        impl Debug for TokenTree
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
               
               
                match self {
                    TokenTree::Group(t) => Debug::fmt(t, f),
                    TokenTree::Ident(t) =>
                    {
                        let mut debug = f.debug_struct("Ident");
                        debug.field("sym", &format_args!("{}", t));
                        imp::debug_span_field_if_nontrivial(&mut debug, t.span().inner);
                        debug.finish()
                    }
                    TokenTree::Punct(t) => Debug::fmt(t, f),
                    TokenTree::Literal(t) => Debug::fmt(t, f),
                }
            }
        }
        /// A delimited token stream.
        #[derive(Clone)]
        pub struct Group {
            inner: imp::Group,
        }
        /// Describes how a sequence of token trees is delimited.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Delimiter 
        {
            /// `( ... )`
            Parenthesis,
            /// `{ ... }`
            Brace,
            /// `[ ... ]`
            Bracket,
            /// ` ... 
            /// Invisible delimiters may not survive roundtrip of a token stream through a string instead in this context.
            None,
        }

        impl Group
        {
            fn _new(inner: imp::Group) -> Self {
                Group { inner }
            }

            fn _new_fallback(inner: fallback::Group) -> Self {
                Group {
                    inner: imp::Group::from(inner),
                }
            }
            /// Creates a new `Group` with the given delimiter and token stream
            pub fn new(delimiter: Delimiter, stream: TokenStream) -> Self {
                Group {
                    inner: imp::Group::new(delimiter, stream.inner),
                }
            }
            /// Returns the punctuation used as the delimiter for this group: a set of
            /// parentheses, square brackets, or curly braces.
            pub fn delimiter( &self ) -> Delimiter
            {
                self.inner.delimiter()
            }
            /// Returns the `TokenStream` of tokens that are delimited in this `Group`
            pub fn stream( &self ) -> TokenStream {
                TokenStream::_new(self.inner.stream())
            }
            /// Returns the span for the delimiters of this token stream, spanning the
            /// entire `Group`
            /// ```
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
            /// Returns the span pointing to the opening delimiter of this group
            /// ```
            pub fn span_open( &self ) -> Span {
                Span::_new(self.inner.span_open())
            }
            /// Returns the span pointing to the closing delimiter of this group
            /// ```
            pub fn span_close( &self ) -> Span {
                Span::_new(self.inner.span_close())
            }
            /// Returns an object that holds this group's `span_open()` and `span_close()` together.
            pub fn delim_span( &self ) -> ::process::macros::extra::DelimSpan
            {
                ::process::macros::extra::DelimSpan::new(&self.inner)
            }
            /// Configures the span for this `Group`'s delimiters, but not its internal
            /// tokens
            pub fn set_span(&mut self, span: Span)
            {
                self.inner.set_span(span.inner);
            }
        }
        /// Prints the group as a string that should be losslessly convertible back
        /// into the same group (modulo spans), except for possibly `TokenTree::Group`s
        /// with `Delimiter::None` delimiters.
        impl Display for Group
        {
            fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, formatter)
            }
        }

        impl Debug for Group
        {
            fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, formatter)
            }
        }
        /// A `Punct` is a single punctuation character like `+`, `-` or `#`.
        #[derive(Clone)]
        pub struct Punct 
        {
            ch: char,
            spacing: Spacing,
            span: Span,
        }
        /// Whether a `Punct` is followed immediately by another `Punct` or followed by another token or whitespace.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Spacing 
        {
            /// E.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.
            Alone,
            /// E.g. `+` is `Joint` in `+=` or `'` is `Joint` in `'#`
            Joint,
        }

        impl Punct
        {
            /// Creates a new `Punct` from the given character and spacing
            /// which can be further configured with the `set_span` method below.
            pub fn new(ch: char, spacing: Spacing) -> Self {
                if let '!' | '#' | '$' | '%' | '&' | '\'' | '*' | '+' | ',' | '-' | '.' | '/' | ':' | ';'
                | '<' | '=' | '>' | '?' | '@' | '^' | '|' | '~' = ch
                {
                    Punct {
                        ch,
                        spacing,
                        span: Span::call_site(),
                    }
                } else {
                    panic!("unsupported proc macro punctuation character {:?}", ch);
                }
            }
            /// Returns the value of this punctuation character as `char`.
            pub fn as_char( &self ) -> char
            {
                self.ch
            }
            /// Returns the spacing of this punctuation character, indicating whether
            /// it's immediately followed by another `Punct` in the token stream, so
            /// they can potentially be combined into a multicharacter operator
            /// (`Joint`), or it's followed by some other token or whitespace (`Alone`)
            /// so the operator has certainly ended.
            pub fn spacing( &self ) -> Spacing
            {
                self.spacing
            }
            /// Returns the span for this punctuation character.
            pub fn span( &self ) -> Span
            {
                self.span
            }
            /// Configure the span for this punctuation character.
            pub fn set_span(&mut self, span: Span)
            {
                self.span = span;
            }
        }
        /// Prints the punctuation character as a string that is losslessly convertible back into the same character.
        impl Display for Punct
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.ch, f)
            }
        }

        impl Debug for Punct       
        {
            fn fmt( &self, fmt: &mut fmt::Formatter) -> fmt::Result
            {
                let mut debug = fmt.debug_struct("Punct");
                debug.field("char", &self.ch);
                debug.field("spacing", &self.spacing);
                imp::debug_span_field_if_nontrivial(&mut debug, self.span.inner);
                debug.finish()
            }
        }
        /// A word of Rust code, which may be a keyword or legal variable name.
        #[derive(Clone)]
        pub struct Ident
        {
            inner: imp::Ident,
            _marker: marker::ProcMacroAutoTraits,
        }

        impl Ident       
        {
            fn _new(inner: imp::Ident) -> Self {
                Ident {
                    inner,
                    _marker: marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::Ident) -> Self {
                Ident {
                    inner: imp::Ident::from(inner),
                    _marker: marker::MARKER,
                }
            }
            /// Creates a new `Ident` with the given `string` as well as the specified `span`
            #[track_caller] pub fn new(string: &str, span: Span) -> Self {
                Ident::_new(imp::Ident::new_checked(string, span.inner))
            }
            /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).
            #[track_caller] pub fn new_raw(string: &str, span: Span) -> Self {
                Ident::_new(imp::Ident::new_raw_checked(string, span.inner))
            }
            /// Returns the span of this `Ident`.
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
            /// Configures the span of this `Ident`, possibly changing its hygiene context.
            pub fn set_span(&mut self, span: Span)
            {
                self.inner.set_span(span.inner);
            }
        }

        impl PartialEq for Ident       
        {
            fn eq( &self, other: &Ident) -> bool
            {
                self.inner == other.inner
            }
        }

        impl<T> PartialEq<T> for Ident where
        T: ?Sized + AsRef<str>       
        {
            fn eq( &self, other: &T) -> bool
            {
                self.inner == other
            }
        }

        impl Eq for Ident {}

        impl PartialOrd for Ident       
        {
            fn partial_cmp( &self, other: &Ident) -> Option<Ordering>
                    {
                Some(self.cmp(other))
            }
        }

        impl Ord for Ident 
       
        {
            fn cmp( &self, other: &Ident) -> Ordering
            {
                self.to_string().cmp(&other.to_string())
            }
        }

        impl Hash for Ident       
        {
            fn hash<H: Hasher>( &self, hasher: &mut H)
            {
                self.to_string().hash(hasher);
            }
        }
        /// Prints the identifier as a string that should be losslessly convertible back into the same identifier.
        impl Display for Ident        
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, f)
            }
        }

        impl Debug for Ident       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }
        /// A literal string (`"hello"`), byte string (`b"hello"`), character (`'a'`),
        /// byte character (`b'a'`), an integer or floating point number with or without
        /// a suffix (`1`, `1u8`, `2.3`, `2.3f32`).
        #[derive(Clone)]
        pub struct Literal
        {
            inner: imp::Literal,
            _marker: marker::ProcMacroAutoTraits,
        }

        macro_rules! suffixed_int_literals
        {
            ($($name:ident => $kind:ident,)*) => 
            ($(
                /// Creates a new suffixed integer literal with the specified value.
                pub fn $name(n: $kind) -> Literal 
                {
                    Literal::_new(imp::Literal::$name(n))
                }
            )*);
        }

        macro_rules! unsuffixed_int_literals 
        {
            ($($name:ident => $kind:ident,)*) => ($(
                /// Creates a new unsuffixed integer literal with the specified value.
                pub fn $name(n: $kind) -> Literal {
                    Literal::_new(imp::Literal::$name(n))
                }
            )*)
        }

        impl Literal        
        {
            fn _new(inner: imp::Literal) -> Self 
            {
                Literal {
                    inner,
                    _marker: ::marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::Literal) -> Self 
            {
                Literal {
                    inner: imp::Literal::from(inner),
                    _marker: ::marker::MARKER,
                }
            }

            suffixed_int_literals! 
            {
                u8_suffixed => u8,
                u16_suffixed => u16,
                u32_suffixed => u32,
                u64_suffixed => u64,
                u128_suffixed => u128,
                usize_suffixed => usize,
                i8_suffixed => i8,
                i16_suffixed => i16,
                i32_suffixed => i32,
                i64_suffixed => i64,
                i128_suffixed => i128,
                isize_suffixed => isize,
            }

            unsuffixed_int_literals! 
            {
                u8_unsuffixed => u8,
                u16_unsuffixed => u16,
                u32_unsuffixed => u32,
                u64_unsuffixed => u64,
                u128_unsuffixed => u128,
                usize_unsuffixed => usize,
                i8_unsuffixed => i8,
                i16_unsuffixed => i16,
                i32_unsuffixed => i32,
                i64_unsuffixed => i64,
                i128_unsuffixed => i128,
                isize_unsuffixed => isize,
            }
            /// Creates a new unsuffixed floating-point literal
            pub fn f64_unsuffixed(f: f64) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f64_unsuffixed(f))
            }
            /// Creates a new suffixed floating-point literal

            pub fn f64_suffixed(f: f64) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f64_suffixed(f))
            }
            /// Creates a new unsuffixed floating-point literal
            pub fn f32_unsuffixed(f: f32) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f32_unsuffixed(f))
            }
            /// Creates a new suffixed floating-point literal
            pub fn f32_suffixed(f: f32) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f32_suffixed(f))
            }
            /// String literal.
            pub fn string(string: &str) -> Literal 
            {
                Literal::_new(imp::Literal::string(string))
            }
            /// Character literal.
            pub fn character(ch: char) -> Literal 
            {
                Literal::_new(imp::Literal::character(ch))
            }
            /// Byte character literal.
            pub fn byte_character(byte: u8) -> Literal 
            {
                Literal::_new(imp::Literal::byte_character(byte))
            }
            /// Byte string literal.
            pub fn byte_string(bytes: &[u8]) -> Literal 
            {
                Literal::_new(imp::Literal::byte_string(bytes))
            }
            /// C string literal.
            pub fn c_string( string:&::ffi::CStr ) -> Literal 
            {
                Literal::_new(imp::Literal::c_string(string))
            }
            /// Returns the span encompassing this literal.
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
            /// Configures the span associated for this literal.
            pub fn set_span(&mut self, span: Span)
            {
                self.inner.set_span(span.inner);
            }
            /// Returns a `Span` that is a subset of `self.span()` containing only
            /// the source bytes in range `range`.
            pub fn subspan<R: RangeBounds<usize>>( &self, range: R) -> Option<Span> 
           
            {
                self.inner.subspan(range).map(Span::_new)
            }

            pub unsafe fn from_str_unchecked(repr: &str) -> Self 
            {
                Literal::_new(unsafe { imp::Literal::from_str_unchecked(repr) })
            }
        }

        impl ::str::FromStr for Literal 
        {
            type Err = LexError;
            fn from_str(repr: &str) -> Result<Self, LexError>
            {
                match imp::Literal::from_str_checked(repr) {
                    Ok(lit) => Ok(Literal::_new(lit)),
                    Err(lex) => Err(LexError {
                        inner: lex,
                        _marker: ::marker::MARKER,
                    }),
                }
            }
        }

        impl Debug for Literal       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.inner, f)
            }
        }

        impl Display for Literal       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.inner, f)
            }
        }
    }
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod quote
{
    /*!
    Provides the [`quote!`] macro for turning Rust syntax tree data structures into tokens of source code. */
    use ::
    {
        *,
    };
    /*
    */
    pub mod ext
    {
        use ::
        {
            process::macros::{ TokenStream, TokenTree },
            quote::{ ToTokens },
            *,
        };
        /*
        */
        /// TokenStream extension trait with methods for appending tokens.
        pub trait TokenStreamExt: private::Sealed
        {
            /// For use by `ToTokens` implementations.
            fn append<U>(&mut self, token: U) where U: Into<TokenTree>;
            /// For use by `ToTokens` implementations.
            fn append_all<I>(&mut self, iter: I) where
            I: IntoIterator,
            I::Item: ToTokens;
            /// For use by `ToTokens` implementations.
            fn append_separated<I, U>(&mut self, iter: I, op: U) where
            I: IntoIterator,
            I::Item: ToTokens,
            U: ToTokens;
            /// For use by `ToTokens` implementations.
            fn append_terminated<I, U>(&mut self, iter: I, term: U) where
            I: IntoIterator,
            I::Item: ToTokens,
            U: ToTokens;
        }

        impl TokenStreamExt for TokenStream
        {
            fn append<U>(&mut self, token: U) where
                U: Into<TokenTree>,
           
            {
                self.extend(iter::once(token.into()));
            }

            fn append_all<I>(&mut self, iter: I) where
                I: IntoIterator,
                I::Item: ToTokens,
            {
                for token in iter {
                    token.to_tokens(self);
                }
            }

            fn append_separated<I, U>(&mut self, iter: I, op: U) where
                I: IntoIterator,
                I::Item: ToTokens,
                U: ToTokens,
            {
                for (i, token) in iter.into_iter().enumerate() {
                    if i > 0 {
                        op.to_tokens(self);
                    }
                    token.to_tokens(self);
                }
            }

            fn append_terminated<I, U>(&mut self, iter: I, term: U) where
                I: IntoIterator,
                I::Item: ToTokens,
                U: ToTokens,
            {
                for token in iter {
                    token.to_tokens(self);
                    term.to_tokens(self);
                }
            }
        }

        mod private 
        {
            use ::process::macros::TokenStream;

            pub trait Sealed {}

            impl Sealed for TokenStream {}
        }
    } pub use self::ext::TokenStreamExt;
    
    pub mod ident_fragment
    {
        use ::
        {
            borrow::{ Cow },
            process::macros::{ Ident, Span },
            *,
        };
        /*
        */
        /// Specialized formatting trait used by `format_ident!`.
        pub trait IdentFragment
        {
            /// Format this value as an identifier fragment.
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result;
            /// Span associated with this `IdentFragment`.
            ///
            /// If non-`None`, may be inherited by formatted identifiers.
            fn span(&self) -> Option<Span> {
                None
            }
        }

        impl<T: IdentFragment + ?Sized> IdentFragment for &T 
        {
            fn span(&self) -> Option<Span> {
                <T as IdentFragment>::span(*self)
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                IdentFragment::fmt(*self, f)
            }
        }

        impl<T: IdentFragment + ?Sized> IdentFragment for &mut T 
        {
            fn span(&self) -> Option<Span> {
                <T as IdentFragment>::span(*self)
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                IdentFragment::fmt(*self, f)
            }
        }

        impl IdentFragment for Ident 
        {
            fn span(&self) -> Option<Span> {
                Some(self.span())
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                let id = self.to_string();
                if let Some(id) = id.strip_prefix("r#") {
                    fmt::Display::fmt(id, f)
                } else {
                    fmt::Display::fmt(&id[..], f)
                }
            }
        }

        impl<T> IdentFragment for Cow<'_, T> where
        T: IdentFragment + ToOwned + ?Sized,
        {
            fn span(&self) -> Option<Span> {
                T::span(self)
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                T::fmt(self, f)
            }
        }
        
        macro_rules! ident_fragment_display
        {
            ($($T:ty),*) => {
                $(
                    impl IdentFragment for $T {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                            fmt::Display::fmt(self, f)
                        }
                    }
                )*
            };
        }

        ident_fragment_display!(bool, str, String, char);
        ident_fragment_display!(u8, u16, u32, u64, u128, usize);
    } pub use self::ident_fragment::IdentFragment;
    
    pub mod to_tokens
    {
        use ::
        {
            borrow::{ Cow },
            process::macros::{ Group, Ident, Literal, Punct, Span, TokenStream, TokenTree },
            quote::{ TokenStreamExt },
            rc::{ Rc },
            *,
        };
        /*
        */
        /// Types that can be interpolated inside a `quote!` invocation.
        pub trait ToTokens {
            /// Write `self` to the given `TokenStream`.
            fn to_tokens(&self, tokens: &mut TokenStream);
            /// Convert `self` directly into a `TokenStream` object.
            fn to_token_stream(&self) -> TokenStream
            {
                let mut tokens = TokenStream::new();
                self.to_tokens(&mut tokens);
                tokens
            }
            /// Convert `self` directly into a `TokenStream` object.
            fn into_token_stream(self) -> TokenStream where
            Self: Sized,
           
            {
                self.to_token_stream()
            }
        }

        impl<'a, T: ?Sized + ToTokens> ToTokens for &'a T {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<'a, T: ?Sized + ToTokens> ToTokens for &'a mut T {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<'a, T: ?Sized + ToOwned + ToTokens> ToTokens for Cow<'a, T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<T: ?Sized + ToTokens> ToTokens for Box<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<T: ?Sized + ToTokens> ToTokens for Rc<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<T: ToTokens> ToTokens for Option<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                if let Some(ref t) = *self {
                    t.to_tokens(tokens);
                }
            }
        }

        impl ToTokens for str 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(Literal::string(self));
            }
        }

        impl ToTokens for String 
        {
            fn to_tokens(&self, tokens: &mut TokenStream)
            {
                self.as_str().to_tokens(tokens);
            }
        }

        macro_rules! primitive 
        {
            ($($t:ident => $name:ident)*) => {
                $(
                    impl ToTokens for $t {
                        fn to_tokens(&self, tokens: &mut TokenStream) {
                            tokens.append(Literal::$name(*self));
                        }
                    }
                )*
            };
        }

        primitive! 
        {
            i8 => i8_suffixed
            i16 => i16_suffixed
            i32 => i32_suffixed
            i64 => i64_suffixed
            i128 => i128_suffixed
            isize => isize_suffixed

            u8 => u8_suffixed
            u16 => u16_suffixed
            u32 => u32_suffixed
            u64 => u64_suffixed
            u128 => u128_suffixed
            usize => usize_suffixed

            f32 => f32_suffixed
            f64 => f64_suffixed
        }

        impl ToTokens for char 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(Literal::character(*self));
            }
        }

        impl ToTokens for bool 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                let word = if *self { "true" } else { "false" };
                tokens.append(Ident::new(word, Span::call_site()));
            }
        }

        impl ToTokens for Group 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for Ident 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for Punct 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for Literal 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for TokenTree 
        {
            fn to_tokens(&self, dst: &mut TokenStream) {
                dst.append(self.clone());
            }
        }

        impl ToTokens for TokenStream 
        {
            fn to_tokens(&self, dst: &mut TokenStream) {
                dst.extend(iter::once(self.clone()));
            }

            fn into_token_stream(self) -> TokenStream { self }
        }
    } pub use self::to_tokens::ToTokens;
    
    pub mod __private
    {
        use ::
        {
            ops::{ BitOr },
            process::macros::{ Group, Ident, Punct, Spacing, TokenTree },
            quote::{ IdentFragment, ToTokens, TokenStreamExt },
            *,
        }; use self::get_span::{GetSpan, GetSpanBase, GetSpanInner};
        /*
        */
        pub type Delimiter = process::macros::Delimiter;
        pub type Span = process::macros::Span;
        pub type TokenStream = process::macros::TokenStream;
        
        macro_rules! push_punct
        {
            ($name:ident $spanned:ident $char1:tt) => {
                    pub fn $name(tokens: &mut TokenStream)
                {
                    tokens.append(Punct::new($char1, Spacing::Alone));
                }
                    pub fn $spanned(tokens: &mut TokenStream, span: Span) {
                    let mut punct = Punct::new($char1, Spacing::Alone);
                    punct.set_span(span);
                    tokens.append(punct);
                }
            };
            ($name:ident $spanned:ident $char1:tt $char2:tt) => {
                    pub fn $name(tokens: &mut TokenStream)
                {
                    tokens.append(Punct::new($char1, Spacing::Joint));
                    tokens.append(Punct::new($char2, Spacing::Alone));
                }
                    pub fn $spanned(tokens: &mut TokenStream, span: Span) {
                    let mut punct = Punct::new($char1, Spacing::Joint);
                    punct.set_span(span);
                    tokens.append(punct);
                    let mut punct = Punct::new($char2, Spacing::Alone);
                    punct.set_span(span);
                    tokens.append(punct);
                }
            };
            ($name:ident $spanned:ident $char1:tt $char2:tt $char3:tt) => {
                    pub fn $name(tokens: &mut TokenStream)
                {
                    tokens.append(Punct::new($char1, Spacing::Joint));
                    tokens.append(Punct::new($char2, Spacing::Joint));
                    tokens.append(Punct::new($char3, Spacing::Alone));
                }
                    pub fn $spanned(tokens: &mut TokenStream, span: Span) {
                    let mut punct = Punct::new($char1, Spacing::Joint);
                    punct.set_span(span);
                    tokens.append(punct);
                    let mut punct = Punct::new($char2, Spacing::Joint);
                    punct.set_span(span);
                    tokens.append(punct);
                    let mut punct = Punct::new($char3, Spacing::Alone);
                    punct.set_span(span);
                    tokens.append(punct);
                }
            };
        }

        pub struct HasIterator;
        pub struct ThereIsNoIteratorInRepetition;

        impl BitOr<ThereIsNoIteratorInRepetition> for ThereIsNoIteratorInRepetition {
            type Output = ThereIsNoIteratorInRepetition;
            fn bitor(self, _rhs: ThereIsNoIteratorInRepetition) -> ThereIsNoIteratorInRepetition {
                ThereIsNoIteratorInRepetition
            }
        }

        impl BitOr<ThereIsNoIteratorInRepetition> for HasIterator {
            type Output = HasIterator;
            fn bitor(self, _rhs: ThereIsNoIteratorInRepetition) -> HasIterator {
                HasIterator
            }
        }

        impl BitOr<HasIterator> for ThereIsNoIteratorInRepetition {
            type Output = HasIterator;
            fn bitor(self, _rhs: HasIterator) -> HasIterator {
                HasIterator
            }
        }

        impl BitOr<HasIterator> for HasIterator {
            type Output = HasIterator;
            fn bitor(self, _rhs: HasIterator) -> HasIterator {
                HasIterator
            }
        }
        /// Extension traits used by the implementation of `quote!`.
        pub mod ext
        {
            use ::
            {
                collections::btree_set::{ self, BTreeSet },
                quote::{ ToTokens },
                *,
            };
            /**/
            use super::RepInterp;
            use super::{HasIterator as HasIter, ThereIsNoIteratorInRepetition as DoesNotHaveIter};
            /// Extension trait providing the `quote_into_iter` method on iterators.
            pub trait RepIteratorExt: Iterator + Sized {
                fn quote_into_iter(self) -> (Self, HasIter) {
                    (self, HasIter)
                }
            }

            impl<T: Iterator> RepIteratorExt for T {}
            /// Extension trait providing the `quote_into_iter` method for non-iterable types.
            pub trait RepToTokensExt {
                /// Pretend to be an iterator for the purposes of `quote_into_iter`.
                /// This allows repeated calls to `quote_into_iter` to continue
                /// correctly returning DoesNotHaveIter.
                fn next(&self) -> Option<&Self> {
                    Some(self)
                }

                fn quote_into_iter(&self) -> (&Self, DoesNotHaveIter) {
                    (self, DoesNotHaveIter)
                }
            }

            impl<T: ToTokens + ?Sized> RepToTokensExt for T {}
            /// Extension trait providing the `quote_into_iter` method for types that can be referenced as an iterator.
            pub trait RepAsIteratorExt<'q>
            {
                type Iter: Iterator;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter);
            }

            impl<'q, 'a, T: RepAsIteratorExt<'q> + ?Sized> RepAsIteratorExt<'q> for &'a T
            {
                type Iter = T::Iter;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    <T as RepAsIteratorExt>::quote_into_iter(*self)
                }
            }

            impl<'q, 'a, T: RepAsIteratorExt<'q> + ?Sized> RepAsIteratorExt<'q> for &'a mut T {
                type Iter = T::Iter;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    <T as RepAsIteratorExt>::quote_into_iter(*self)
                }
            }

            impl<'q, T: 'q> RepAsIteratorExt<'q> for [T] {
                type Iter = slice::Iter<'q, T>;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    (self.iter(), HasIter)
                }
            }

            impl<'q, T: 'q> RepAsIteratorExt<'q> for Vec<T>
            {
                type Iter = slice::Iter<'q, T>;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    (self.iter(), HasIter)
                }
            }

            impl<'q, T: 'q> RepAsIteratorExt<'q> for BTreeSet<T>
            {
                type Iter = btree_set::Iter<'q, T>;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    (self.iter(), HasIter)
                }
            }

            impl<'q, T: RepAsIteratorExt<'q>> RepAsIteratorExt<'q> for RepInterp<T>
            {
                type Iter = T::Iter;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    self.0.quote_into_iter()
                }
            }
        }

        #[derive(Copy, Clone)]
        pub struct RepInterp<T>(pub T);

        impl<T> RepInterp<T>
        {
            pub fn next(self) -> Option<T>
            {
                Some(self.0)
            }
        }

        impl<T: Iterator> Iterator for RepInterp<T>
        {
            type Item = T::Item;
            fn next(&mut self) -> Option<Self::Item>
            {
                self.0.next()
            }
        }

        impl<T: ToTokens> ToTokens for RepInterp<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream)
            {
                self.0.to_tokens(tokens);
            }
        }
        
        #[inline] pub fn get_span<T>(span: T) -> GetSpan<T> 
        {
            GetSpan(GetSpanInner(GetSpanBase(span)))
        }

        mod get_span
        {
            use ::
            {
                ops::{ Deref },
                process::macros::
                {
                    extra::DelimSpan, Span
                },
                *,
            };
            /*
            */
            pub struct GetSpan<T>(pub GetSpanInner<T>);

            pub struct GetSpanInner<T>(pub GetSpanBase<T>);

            pub struct GetSpanBase<T>(pub T);

            impl GetSpan<Span> {
                #[inline]
                pub fn __into_span(self) -> Span {
                    ((self.0).0).0
                }
            }

            impl GetSpanInner<DelimSpan> {
                #[inline]
                pub fn __into_span(&self) -> Span {
                    (self.0).0.join()
                }
            }

            impl<T> GetSpanBase<T> {
                #[allow(clippy::unused_self)]
                pub fn __into_span(&self) -> T {
                    unreachable!()
                }
            }

            impl<T> Deref for GetSpan<T>
            {
                type Target = GetSpanInner<T>;

                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }

            impl<T> Deref for GetSpanInner<T>
            {
                type Target = GetSpanBase<T>;

                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
        }

        pub fn push_group(tokens: &mut TokenStream, delimiter: Delimiter, inner: TokenStream) 
        {
            tokens.append(Group::new(delimiter, inner));
        }

        pub fn push_group_spanned
        (
            tokens: &mut TokenStream,
            span: Span,
            delimiter: Delimiter,
            inner: TokenStream,
        ) 
        {
            let mut g = Group::new(delimiter, inner);
            g.set_span(span);
            tokens.append(g);
        }

        pub fn parse(tokens: &mut TokenStream, s: &str)
        {
            let s: TokenStream = s.parse().expect("invalid token stream");
            tokens.extend(iter::once(s));
        }

        pub fn parse_spanned(tokens: &mut TokenStream, span: Span, s: &str)
        {
            let s: TokenStream = s.parse().expect("invalid token stream");
            tokens.extend(s.into_iter().map(|t| respan_token_tree(t, span)));
        }
        
        fn respan_token_tree(mut token: TokenTree, span: Span) -> TokenTree
        {
            match &mut token {
                TokenTree::Group(g) => {
                    let stream = g
                        .stream()
                        .into_iter()
                        .map(|token| respan_token_tree(token, span))
                        .collect();
                    *g = Group::new(g.delimiter(), stream);
                    g.set_span(span);
                }
                other => other.set_span(span),
            }
            token
        }

        pub fn push_ident(tokens: &mut TokenStream, s: &str)
        {
            let span = Span::call_site();
            push_ident_spanned(tokens, span, s);
        }

        pub fn push_ident_spanned(tokens: &mut TokenStream, span: Span, s: &str)
        {
            tokens.append(ident_maybe_raw(s, span));
        }

        pub fn push_lifetime(tokens: &mut TokenStream, lifetime: &str)
        {
            struct Lifetime<'a> {
                name: &'a str,
                state: u8,
            }

            impl<'a> Iterator for Lifetime<'a>
            {
                type Item = TokenTree;
                fn next(&mut self) -> Option<Self::Item> {
                    match self.state {
                        0 => {
                            self.state = 1;
                            Some(TokenTree::Punct(Punct::new('\'', Spacing::Joint)))
                        }
                        1 => {
                            self.state = 2;
                            Some(TokenTree::Ident(Ident::new(self.name, Span::call_site())))
                        }
                        _ => None,
                    }
                }
            }

            tokens.extend(Lifetime {
                name: &lifetime[1..],
                state: 0,
            });
        }

        pub fn push_lifetime_spanned(tokens: &mut TokenStream, span: Span, lifetime: &str)
        {
            struct Lifetime<'a> {
                name: &'a str,
                span: Span,
                state: u8,
            }

            impl<'a> Iterator for Lifetime<'a>
            {
                type Item = TokenTree;
                fn next(&mut self) -> Option<Self::Item> {
                    match self.state {
                        0 => {
                            self.state = 1;
                            let mut apostrophe = Punct::new('\'', Spacing::Joint);
                            apostrophe.set_span(self.span);
                            Some(TokenTree::Punct(apostrophe))
                        }
                        1 => {
                            self.state = 2;
                            Some(TokenTree::Ident(Ident::new(self.name, self.span)))
                        }
                        _ => None,
                    }
                }
            }

            tokens.extend(Lifetime {
                name: &lifetime[1..],
                span,
                state: 0,
            });
        }

        push_punct!(push_add push_add_spanned '+');
        push_punct!(push_add_eq push_add_eq_spanned '+' '=');
        push_punct!(push_and push_and_spanned '&');
        push_punct!(push_and_and push_and_and_spanned '&' '&');
        push_punct!(push_and_eq push_and_eq_spanned '&' '=');
        push_punct!(push_at push_at_spanned '@');
        push_punct!(push_bang push_bang_spanned '!');
        push_punct!(push_caret push_caret_spanned '^');
        push_punct!(push_caret_eq push_caret_eq_spanned '^' '=');
        push_punct!(push_colon push_colon_spanned ':');
        push_punct!(push_colon2 push_colon2_spanned ':' ':');
        push_punct!(push_comma push_comma_spanned ',');
        push_punct!(push_div push_div_spanned '/');
        push_punct!(push_div_eq push_div_eq_spanned '/' '=');
        push_punct!(push_dot push_dot_spanned '.');
        push_punct!(push_dot2 push_dot2_spanned '.' '.');
        push_punct!(push_dot3 push_dot3_spanned '.' '.' '.');
        push_punct!(push_dot_dot_eq push_dot_dot_eq_spanned '.' '.' '=');
        push_punct!(push_eq push_eq_spanned '=');
        push_punct!(push_eq_eq push_eq_eq_spanned '=' '=');
        push_punct!(push_ge push_ge_spanned '>' '=');
        push_punct!(push_gt push_gt_spanned '>');
        push_punct!(push_le push_le_spanned '<' '=');
        push_punct!(push_lt push_lt_spanned '<');
        push_punct!(push_mul_eq push_mul_eq_spanned '*' '=');
        push_punct!(push_ne push_ne_spanned '!' '=');
        push_punct!(push_or push_or_spanned '|');
        push_punct!(push_or_eq push_or_eq_spanned '|' '=');
        push_punct!(push_or_or push_or_or_spanned '|' '|');
        push_punct!(push_pound push_pound_spanned '#');
        push_punct!(push_question push_question_spanned '?');
        push_punct!(push_rarrow push_rarrow_spanned '-' '>');
        push_punct!(push_larrow push_larrow_spanned '<' '-');
        push_punct!(push_rem push_rem_spanned '%');
        push_punct!(push_rem_eq push_rem_eq_spanned '%' '=');
        push_punct!(push_fat_arrow push_fat_arrow_spanned '=' '>');
        push_punct!(push_semi push_semi_spanned ';');
        push_punct!(push_shl push_shl_spanned '<' '<');
        push_punct!(push_shl_eq push_shl_eq_spanned '<' '<' '=');
        push_punct!(push_shr push_shr_spanned '>' '>');
        push_punct!(push_shr_eq push_shr_eq_spanned '>' '>' '=');
        push_punct!(push_star push_star_spanned '*');
        push_punct!(push_sub push_sub_spanned '-');
        push_punct!(push_sub_eq push_sub_eq_spanned '-' '=');

        pub fn push_underscore(tokens: &mut TokenStream)
        {
            push_underscore_spanned(tokens, Span::call_site());
        }

        pub fn push_underscore_spanned(tokens: &mut TokenStream, span: Span)
        {
            tokens.append(Ident::new("_", span));
        }
       
        pub fn mk_ident(id: &str, span: Option<Span>) -> Ident
        {
            let span = span.unwrap_or_else(Span::call_site);
            ident_maybe_raw(id, span)
        }

        fn ident_maybe_raw(id: &str, span: Span) -> Ident       
        {
            if let Some(id) = id.strip_prefix("r#") {
                Ident::new_raw(id, span)
            } else {
                Ident::new(id, span)
            }
        }
        
        #[derive(Copy, Clone)]
        pub struct IdentFragmentAdapter<T: IdentFragment>(pub T);

        impl<T: IdentFragment> IdentFragmentAdapter<T>
        {
            pub fn span(&self) -> Option<Span> { self.0.span() }
        }

        impl<T: IdentFragment> fmt::Display for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { IdentFragment::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::Octal> fmt::Octal for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Octal::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::LowerHex> fmt::LowerHex for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::LowerHex::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::UpperHex> fmt::UpperHex for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::UpperHex::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::Binary> fmt::Binary for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Binary::fmt(&self.0, f) }
        }
    }
    
    pub mod spanned
    {
        use ::
        {
            process::macros::{ extra::DelimSpan, Span, TokenStream },
            quote::ToTokens,
            *,
        };
        /*
        */
       
        pub trait Spanned: private::Sealed {
            fn __span(&self) -> Span;
        }

        impl Spanned for Span {
            fn __span(&self) -> Span {
                *self
            }
        }

        impl Spanned for DelimSpan {
            fn __span(&self) -> Span
            {
                self.join()
            }
        }

        impl<T: ?Sized + ToTokens> Spanned for T {
            fn __span(&self) -> Span {
                join_spans(self.into_token_stream())
            }
        }

        fn join_spans(tokens: TokenStream) -> Span
        {
            let mut iter = tokens.into_iter().map(|tt| tt.span());

            let first = match iter.next() {
                Some(span) => span,
                None => return Span::call_site(),
            };

            iter.fold(None, |_prev, next| Some(next))
                .and_then(|last| first.join(last))
                .unwrap_or(first)
        }

        mod private
        {
            use ::
            {
                process::macros::
                {
                    extra::DelimSpan, Span
                },
                quote::{ ToTokens },
                *,
            };
            /*
            */
            pub trait Sealed {}
            impl Sealed for Span {}
            impl Sealed for DelimSpan {}
            impl<T: ?Sized + ToTokens> Sealed for T {}
        }
    }
    
}

pub mod rc
{
    pub use std::rc::{ * };
}

pub mod result
{
    pub use std::result::{ * };
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod str
{
    pub use std::str::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };
}
/*
syn v2.0.106 */
pub mod syntax
{
    /*!
    Syn is a parsing library for parsing a stream of Rust tokens into a syntax tree of Rust source code. */
    use ::
    {
        *,
    };
    /*    
        #![doc(html_root_url = "https://docs.rs/syn/2.0.106")]
        #![cfg_attr(docsrs, feature(doc_cfg))]
        #![deny(unsafe_op_in_unsafe_fn)]
        #![allow(non_camel_case_types)]
        #![cfg_attr(not(check_cfg), allow(unexpected_cfgs))]
        #![allow(
            clippy::bool_to_int_with_if,
            clippy::cast_lossless,
            clippy::cast_possible_truncation,
            clippy::cast_possible_wrap,
            clippy::cast_ptr_alignment,
            clippy::default_trait_access,
            clippy::derivable_impls,
            clippy::diverging_sub_expression,
            clippy::doc_markdown,
            clippy::elidable_lifetime_names,
            clippy::enum_glob_use,
            clippy::expl_impl_clone_on_copy,
            clippy::explicit_auto_deref,
            clippy::fn_params_excessive_bools,
            clippy::if_not_else,
            clippy::inherent_to_string,
            clippy::into_iter_without_iter,
            clippy::items_after_statements,
            clippy::large_enum_variant,
            clippy::let_underscore_untyped,
            clippy::manual_assert,
            clippy::manual_let_else,
            clippy::manual_map,
            clippy::match_like_matches_macro,
            clippy::match_same_arms,
            clippy::match_wildcard_for_single_variants,
            clippy::missing_errors_doc,
            clippy::missing_panics_doc,
            clippy::module_name_repetitions,
            clippy::must_use_candidate,
            clippy::needless_doctest_main,
            clippy::needless_lifetimes,
            clippy::needless_pass_by_value,
            clippy::needless_update,
            clippy::never_loop,
            clippy::range_plus_one,
            clippy::redundant_else,
            clippy::ref_option,
            clippy::return_self_not_must_use,
            clippy::similar_names,
            clippy::single_match_else,
            clippy::struct_excessive_bools,
            clippy::too_many_arguments,
            clippy::too_many_lines,
            clippy::trivially_copy_pass_by_ref,
            clippy::unconditional_recursion,
            clippy::uninhabited_references,
            clippy::uninlined_format_args,
            clippy::unnecessary_box_returns,
            clippy::unnecessary_unwrap,
            clippy::used_underscore_binding,
            clippy::wildcard_imports,
        )]
        #![allow(unknown_lints, mismatched_lifetime_syntaxes)]
    */
    pub mod attr
    {
        use ::
        {
            process::macros::TokenStream,
            syntax::
            {
                error::{ Error, Result },
                expr::{ Expr },
                mac::{ MacroDelimiter },
                meta::{ self, ParseNestedMeta },
                parse::{ Parse, ParseStream, Parser },
                path::{ Path },
                token, 
            },
            *,
        };
        /*
        */
        ast_struct!
        {
            /// An attribute, like `#[repr(transparent)]`.
            pub struct Attribute
            {
                pub pound_token: Token![#],
                pub style: AttrStyle,
                pub bracket_token: token::Bracket,
                pub meta: Meta,
            }
        }

        impl Attribute
        {
            /// Returns the path that identifies the interpretation of this attribute.
            pub fn path(&self) -> &Path
            {
                self.meta.path()
            }
            /// Parse the arguments to the attribute as a syntax tree.
            pub fn parse_args<T: Parse>(&self) -> Result<T>
            {
                self.parse_args_with(T::parse)
            }
            /// Parse the arguments to the attribute using the given parser.
            pub fn parse_args_with<F: Parser>(&self, parser: F) -> Result<F::Output>
            {
                match &self.meta {
                    Meta::Path(path) => Err(::syntax::error::new2(
                        path.segments.first().unwrap().ident.span(),
                        path.segments.last().unwrap().ident.span(),
                        format!(
                            "expected attribute arguments in parentheses: {}[{}(...)]",
                            parsing::DisplayAttrStyle(&self.style),
                            parsing::DisplayPath(path),
                        ),
                    )),
                    Meta::NameValue(meta) => Err(Error::new(
                        meta.eq_token.span,
                        format_args!(
                            "expected parentheses: {}[{}(...)]",
                            parsing::DisplayAttrStyle(&self.style),
                            parsing::DisplayPath(&meta.path),
                        ),
                    )),
                    Meta::List(meta) => meta.parse_args_with(parser),
                }
            }
            /// Parse the arguments to the attribute, expecting it to follow the
            /// conventional structure used by most of Rust's built-in attributes.
            pub fn parse_nested_meta(
                &self,
                logic: impl FnMut(ParseNestedMeta) -> Result<()>,
            ) -> Result<()>
            {
                self.parse_args_with(meta::parser(logic))
            }
            /// Parses zero or more outer attributes from the stream.
             
            pub fn parse_outer(input: ParseStream) -> Result<Vec<Self>>
            {
                let mut attrs = Vec::new();
                while input.peek(Token![#]) {
                    attrs.push(input.call(parsing::single_parse_outer)?);
                }
                Ok(attrs)
            }
            /// Parses zero or more inner attributes from the stream.
            pub fn parse_inner(input: ParseStream) -> Result<Vec<Self>>
            {
                let mut attrs = Vec::new();
                parsing::parse_inner(input, &mut attrs)?;
                Ok(attrs)
            }
        }

        ast_enum!
        {
            /// Distinguishes between attributes that decorate an item and those that are contained within an item.
            pub enum AttrStyle {
                Outer,
                Inner(Token![!]),
            }
        }

        ast_enum!        
        {
            /// Content of a compile-time structured attribute.
            pub enum Meta
            {
                Path(Path),
                /// A structured list within an attribute, like `derive(Copy, Clone)`.
                List(MetaList),
                /// A name-value pair within an attribute, like `feature = "nightly"`.
                NameValue(MetaNameValue),
            }
        }

        ast_struct! 
        {
            /// A structured list within an attribute, like `derive(Copy, Clone)`.
            pub struct MetaList {
                pub path: Path,
                pub delimiter: MacroDelimiter,
                pub tokens: TokenStream,
            }
        }

        ast_struct! 
        {
            /// A name-value pair within an attribute, like `feature = "nightly"`.
            pub struct MetaNameValue {
                pub path: Path,
                pub eq_token: Token![=],
                pub value: Expr,
            }
        }

        impl Meta 
        {
            /// Returns the path that begins this structured meta item.
            pub fn path(&self) -> &Path {
                match self {
                    Meta::Path(path) => path,
                    Meta::List(meta) => &meta.path,
                    Meta::NameValue(meta) => &meta.path,
                }
            }
            /// Error if this is a `Meta::List` or `Meta::NameValue`.
             
                pub fn require_path_only(&self) -> Result<&Path>
            {
                let error_span = match self {
                    Meta::Path(path) => return Ok(path),
                    Meta::List(meta) => meta.delimiter.span().open(),
                    Meta::NameValue(meta) => meta.eq_token.span,
                };
                Err(Error::new(error_span, "unexpected token in attribute"))
            }
            /// Error if this is a `Meta::Path` or `Meta::NameValue`.
            pub fn require_list(&self) -> Result<&MetaList>
            {
                match self {
                    Meta::List(meta) => Ok(meta),
                    Meta::Path(path) => Err(::syntax::error::new2(
                        path.segments.first().unwrap().ident.span(),
                        path.segments.last().unwrap().ident.span(),
                        format!(
                            "expected attribute arguments in parentheses: `{}(...)`",
                            parsing::DisplayPath(path),
                        ),
                    )),
                    Meta::NameValue(meta) => Err(Error::new(meta.eq_token.span, "expected `(`")),
                }
            }
            /// Error if this is a `Meta::Path` or `Meta::List`.
             
                pub fn require_name_value(&self) -> Result<&MetaNameValue>
            {
                match self {
                    Meta::NameValue(meta) => Ok(meta),
                    Meta::Path(path) => Err(::syntax::error::new2(
                        path.segments.first().unwrap().ident.span(),
                        path.segments.last().unwrap().ident.span(),
                        format!(
                            "expected a value for this attribute: `{} = ...`",
                            parsing::DisplayPath(path),
                        ),
                    )),
                    Meta::List(meta) => Err(Error::new(meta.delimiter.span().open(), "expected `=`")),
                }
            }
        }

        impl MetaList 
        {
            /// See [`Attribute::parse_args`].
             
                pub fn parse_args<T: Parse>(&self) -> Result<T>
            {
                self.parse_args_with(T::parse)
            }
            /// See [`Attribute::parse_args_with`].
             
                pub fn parse_args_with<F: Parser>(&self, parser: F) -> Result<F::Output>
            {
                let scope = self.delimiter.span().close();
                ::syntax::parse::parse_scoped(parser, scope, self.tokens.clone())
            }
            /// See [`Attribute::parse_nested_meta`].
             
                pub fn parse_nested_meta(
                &self,
                logic: impl FnMut(ParseNestedMeta) -> Result<()>,
            ) -> Result<()>
            {
                self.parse_args_with(meta::parser(logic))
            }
        }
        
        pub trait FilterAttrs<'a>
        {
            type Ret: Iterator<Item = &'a Attribute>;
            fn outer(self) -> Self::Ret;
            fn inner(self) -> Self::Ret;
        }
        
        impl<'a> FilterAttrs<'a> for &'a [Attribute]
        {
            type Ret = iter::Filter<slice::Iter<'a, Attribute>, fn(&&Attribute) -> bool>;

            fn outer(self) -> Self::Ret
            {
                fn is_outer(attr: &&Attribute) -> bool
                {
                    match attr.style
                    {
                        AttrStyle::Outer => true,
                        AttrStyle::Inner(_) => false,
                    }
                }
                self.iter().filter(is_outer)
            }

                fn inner(self) -> Self::Ret {
                fn is_inner(attr: &&Attribute) -> bool
                {
                    match attr.style {
                        AttrStyle::Inner(_) => true,
                        AttrStyle::Outer => false,
                    }
                }
                self.iter().filter(is_inner)
            }
        }

        impl From<Path> for Meta 
        {
            fn from(meta: Path) -> Meta {
                Meta::Path(meta)
            }
        }

        impl From<MetaList> for Meta 
        {
            fn from(meta: MetaList) -> Meta {
                Meta::List(meta)
            }
        }

        impl From<MetaNameValue> for Meta 
        {
            fn from(meta: MetaNameValue) -> Meta {
                Meta::NameValue(meta)
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                fmt::{self, Display},
                process::macros::{ Ident },
                syntax::
                {
                    attr::{AttrStyle, Attribute, Meta, MetaList, MetaNameValue},
                    error::Result,
                    expr::{Expr, ExprLit},
                    lit::Lit,
                    parse::discouraged::Speculative as _,
                    parse::{Parse, ParseStream},
                    path::Path,
                    mac, token,
                },
                *
            };          

            pub fn parse_inner(input: ParseStream, attrs: &mut Vec<Attribute>) -> Result<()> {
                while input.peek(Token![#]) && input.peek2(Token![!]) {
                    attrs.push(input.call(single_parse_inner)?);
                }
                Ok(())
            }

            pub fn single_parse_inner(input: ParseStream) -> Result<Attribute>
            {
                let content;
                Ok(Attribute {
                    pound_token: input.parse()?,
                    style: AttrStyle::Inner(input.parse()?),
                    bracket_token: bracketed!(content in input),
                    meta: content.parse()?,
                })
            }

            pub fn single_parse_outer(input: ParseStream) -> Result<Attribute>
            {
                let content;
                Ok(Attribute {
                    pound_token: input.parse()?,
                    style: AttrStyle::Outer,
                    bracket_token: bracketed!(content in input),
                    meta: content.parse()?,
                })
            }

            impl Parse for Meta
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let path = parse_outermost_meta_path(input)?;
                    parse_meta_after_path(path, input)
                }
            }

            impl Parse for MetaList
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let path = parse_outermost_meta_path(input)?;
                    parse_meta_list_after_path(path, input)
                }
            }

            impl Parse for MetaNameValue
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let path = parse_outermost_meta_path(input)?;
                    parse_meta_name_value_after_path(path, input)
                }
            }
            
            fn parse_outermost_meta_path(input: ParseStream) -> Result<Path> {
                if input.peek(Token![unsafe]) {
                    let unsafe_token: Token![unsafe] = input.parse()?;
                    Ok(Path::from(Ident::new("unsafe", unsafe_token.span)))
                } else {
                    Path::parse_mod_style(input)
                }
            }

            pub fn parse_meta_after_path(path: Path, input: ParseStream) -> Result<Meta> {
                if input.peek(token::Paren) || input.peek(token::Bracket) || input.peek(token::Brace) {
                    parse_meta_list_after_path(path, input).map(Meta::List)
                } else if input.peek(Token![=]) {
                    parse_meta_name_value_after_path(path, input).map(Meta::NameValue)
                } else {
                    Ok(Meta::Path(path))
                }
            }

            fn parse_meta_list_after_path(path: Path, input: ParseStream) -> Result<MetaList>
            {
                let (delimiter, tokens) = mac::parse_delimiter(input)?;
                Ok(MetaList {
                    path,
                    delimiter,
                    tokens,
                })
            }

            fn parse_meta_name_value_after_path(path: Path, input: ParseStream) -> Result<MetaNameValue>
            {
                let eq_token: Token![=] = input.parse()?;
                let ahead = input.fork();
                let lit: Option<Lit> = ahead.parse()?;
                let value = if let (Some(lit), true) = (lit, ahead.is_empty()) {
                    input.advance_to(&ahead);
                    Expr::Lit(ExprLit {
                        attrs: Vec::new(),
                        lit,
                    })
                } else if input.peek(Token![#]) && input.peek2(token::Bracket) {
                    return Err(input.error("unexpected attribute inside of attribute"));
                } else {
                    input.parse()?
                };
                Ok(MetaNameValue {
                    path,
                    eq_token,
                    value,
                })
            }

            pub struct DisplayAttrStyle<'a>(pub &'a AttrStyle);

            impl<'a> Display for DisplayAttrStyle<'a> {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str(match self.0 {
                        AttrStyle::Outer => "#",
                        AttrStyle::Inner(_) => "#!",
                    })
                }
            }

            pub struct DisplayPath<'a>(pub &'a Path);

            impl<'a> Display for DisplayPath<'a> {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    for (i, segment) in self.0.segments.iter().enumerate() {
                        if i > 0 || self.0.leading_colon.is_some() {
                            formatter.write_str("::")?;
                        }
                        write!(formatter, "{}", segment.ident)?;
                    }
                    Ok(())
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::ToTokens,                
                syntax::
                {
                    attr::{AttrStyle, Attribute, Meta, MetaList, MetaNameValue},
                    path,
                    path::printing::PathStyle,
                },
                *,
            };
            
            impl ToTokens for Attribute 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.pound_token.to_tokens(tokens);
                    if let AttrStyle::Inner(b) = &self.style {
                        b.to_tokens(tokens);
                    }
                    self.bracket_token.surround(tokens, |tokens| {
                        self.meta.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for Meta 
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        Meta::Path(path) => path::printing::print_path(tokens, path, PathStyle::Mod),
                        Meta::List(meta_list) => meta_list.to_tokens(tokens),
                        Meta::NameValue(meta_name_value) => meta_name_value.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for MetaList 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    path::printing::print_path(tokens, &self.path, PathStyle::Mod);
                    self.delimiter.surround(tokens, self.tokens.clone());
                }
            }

            impl ToTokens for MetaNameValue 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    path::printing::print_path(tokens, &self.path, PathStyle::Mod);
                    self.eq_token.to_tokens(tokens);
                    self.value.to_tokens(tokens);
                }
            }
        }
    } pub use self::attr::
    {
        AttrStyle, Attribute, Meta, MetaList, MetaNameValue
    };

    pub mod group
    {
        use ::
        {
            process::macros::
            {
                extra::DelimSpan, Delimiter
            },
            syntax::
            {
                error::{ Result },
                parse::{ ParseBuffer },
                token
            },
            *,
        };
        /*
        */
        pub struct Parens<'a> 
        {
                pub token: token::Paren,
                pub content: ParseBuffer<'a>,
        }
        
        pub struct Braces<'a> {
                pub token: token::Brace,
                pub content: ParseBuffer<'a>,
        }
        
        pub struct Brackets<'a> {
                pub token: token::Bracket,
                pub content: ParseBuffer<'a>,
        }
        
        pub struct Group<'a> {
                pub token: token::Group,
                pub content: ParseBuffer<'a>,
        }
        
        pub fn parse_parens<'a>(input: &ParseBuffer<'a>) -> Result<Parens<'a>> {
            parse_delimited(input, Delimiter::Parenthesis).map(|(span, content)| Parens {
                token: token::Paren(span),
                content,
            })
        }
        
        pub fn parse_braces<'a>(input: &ParseBuffer<'a>) -> Result<Braces<'a>> {
            parse_delimited(input, Delimiter::Brace).map(|(span, content)| Braces {
                token: token::Brace(span),
                content,
            })
        }
        
        pub fn parse_brackets<'a>(input: &ParseBuffer<'a>) -> Result<Brackets<'a>> {
            parse_delimited(input, Delimiter::Bracket).map(|(span, content)| Brackets {
                token: token::Bracket(span),
                content,
            })
        }
        
        pub fn parse_group<'a>(input: &ParseBuffer<'a>) -> Result<Group<'a>> {
            parse_delimited(input, Delimiter::None).map(|(span, content)| Group {
                token: token::Group(span.join()),
                content,
            })
        }

        fn parse_delimited<'a>(
            input: &ParseBuffer<'a>,
            delimiter: Delimiter,
        ) -> Result<(DelimSpan, ParseBuffer<'a>)> {
            input.step(|cursor| {
                if let Some((content, span, rest)) = cursor.group(delimiter) {
                    let scope = span.close();
                    let nested = ::syntax::parse::advance_step_cursor(cursor, content);
                    let unexpected = ::syntax::parse::get_unexpected(input);
                    let content = ::syntax::parse::new_parse_buffer(scope, nested, unexpected);
                    Ok(((span, content), rest))
                } else {
                    let message = match delimiter {
                        Delimiter::Parenthesis => "expected parentheses",
                        Delimiter::Brace => "expected curly braces",
                        Delimiter::Bracket => "expected square brackets",
                        Delimiter::None => "expected invisible group",
                    };
                    Err(cursor.error(message))
                }
            })
        }
    }

    pub mod token
    {
        //! Tokens representing Rust punctuation, keywords, and delimiters.
        use ::
        {
            fmt::{ self, Debug },
            hash::{ Hash, Hasher },
            ops::{ Deref, DerefMut },
            process::macros::
            {
                extra::{ DelimSpan },
                Delimiter, Ident, Literal, Punct, Span, TokenStream, TokenTree
            },
            quote::{ ToTokens, TokenStreamExt },
            syntax::
            {
                buffer::Cursor,
                error::Result,
                lifetime::Lifetime,
                parse::{Parse, ParseStream},
                span::IntoSpans,
            },
            *,
        };
        /*
        */
        pub use self::private::{ CustomToken, WithSpan };

        macro_rules! impl_low_level_token
        {
            ($display:literal $($path:ident)::+ $get:ident) =>
            {
                impl Token for $($path)::+
                {
                    fn peek(cursor: Cursor) -> bool { cursor.$get().is_some() }
                    fn display() -> &'static str { $display }
                }
                
                impl private::Sealed for $($path)::+ {}
            };
        }

        macro_rules! define_keywords
        {
            ($($token:literal pub struct $name:ident)*) => 
            {
                $
                (
                    pub struct $name 
                    {
                        pub span: Span,
                    }
            
                    pub fn $name<S: IntoSpans<Span>>(span: S) -> $name
                    {
                        $name
                        {
                            span: span.into_spans(),
                        }
                    }

                    impl ::default::Default for $name
                    {
                        fn default() -> Self
                        {
                            $name
                            {
                                span: Span::call_site(),
                            }
                        }
                    }
                    
                    impl Copy for $name {}
                    
                    impl Clone for $name
                    {
                        fn clone(&self) -> Self { *self }
                    }

                    impl Debug for $name
                    {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { f.write_str(stringify!($name)) }
                    }

                    impl cmp::Eq for $name {}

                    impl PartialEq for $name
                    {
                        fn eq(&self, _other: &$name) -> bool { true }
                    }

                    impl Hash for $name
                    {
                        fn hash<H: Hasher>(&self, _state: &mut H) {}
                    }
                   
                    impl ToTokens for $name
                    {
                        fn to_tokens(&self, tokens: &mut TokenStream)
                        { printing::keyword($token, self.span, tokens); }
                    }
                    
                    impl Parse for $name
                    {
                        fn parse(input: ParseStream) -> Result<Self>
                        {
                            Ok($name
                            {
                                span: parsing::keyword(input, $token)?,
                            })
                        }
                    }
                    
                    impl Token for $name
                    {
                        fn peek(cursor: Cursor) -> bool { parsing::peek_keyword(cursor, $token) }
                        fn display() -> &'static str { concat!("`", $token, "`") }
                    }
                    
                    impl private::Sealed for $name {}
                )*
            };
        }

        macro_rules! impl_deref_if_len_is_1 
        {
            ($name:ident/1) =>
            {
                impl Deref for $name
                {
                    type Target = WithSpan;

                    fn deref(&self) -> &Self::Target
                    {
                        unsafe { &*(self as *const Self).cast::<WithSpan>() }
                    }
                }

                impl DerefMut for $name
                {
                    fn deref_mut(&mut self) -> &mut Self::Target
                    {
                        unsafe { &mut *(self as *mut Self).cast::<WithSpan>() }
                    }
                }
            };

            ($name:ident/$len:literal) => {};
        }

        macro_rules! define_punctuation_structs 
        {
            ($($token:literal pub struct $name:ident/$len:tt #[doc = $usage:literal])*) =>
            {
                $
                (
                    pub struct $name
                    {
                        pub spans: [Span; $len],
                    }
            
                    pub fn $name<S: IntoSpans<[Span; $len]>>(spans: S) -> $name
                    {
                        $name
                        {
                            spans: spans.into_spans(),
                        }
                    }

                    impl ::default::Default for $name
                    {
                        fn default() -> Self
                        {
                            $name
                            {
                                spans: [Span::call_site(); $len],
                            }
                        }
                    }
                    
                    impl Copy for $name {}
                    
                    impl Clone for $name
                    {
                        fn clone(&self) -> Self { *self }
                    }

                    impl Debug for $name
                    {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { f.write_str(stringify!($name)) }
                    }

                    impl cmp::Eq for $name {}

                    impl PartialEq for $name
                    {
                        fn eq(&self, _other: &$name) -> bool { true }
                    }

                    impl Hash for $name
                    {
                        fn hash<H: Hasher>(&self, _state: &mut H) {}
                    }

                    impl_deref_if_len_is_1!($name/$len);
                )*
            };
        }

        macro_rules! define_punctuation 
        {
            ($($token:literal pub struct $name:ident/$len:tt #[doc = $usage:literal])*) =>
            {
                $
                (
                    define_punctuation_structs!
                    {
                        $token pub struct $name/$len #[doc = $usage]
                    }
                   
                    impl ToTokens for $name
                    {
                        fn to_tokens(&self, tokens: &mut TokenStream)
                        { printing::punct($token, &self.spans, tokens); }
                    }
                    
                    impl Parse for $name
                    {
                        fn parse(input: ParseStream) -> Result<Self>
                        {
                            Ok
                            (
                                $name
                                {
                                    spans: parsing::punct(input, $token)?,
                                }
                            )
                        }
                    }
                     
                    impl Token for $name
                    {
                        fn peek(cursor: Cursor) -> bool { parsing::peek_punct(cursor, $token) }
                        fn display() -> &'static str { concat!("`", $token, "`") }
                    }
                     
                    impl private::Sealed for $name {}
                )*
            };
        }

        macro_rules! define_delimiters 
        {
            ($($delim:ident pub struct $name:ident #[$doc:meta])*) =>
            {
                $
                (
                    #[$doc]
                    pub struct $name
                    {
                        pub span: DelimSpan,
                    }
            
                    pub fn $name<S: IntoSpans<DelimSpan>>(span: S) -> $name
                    {
                        $name
                        {
                            span: span.into_spans(),
                        }
                    }

                    impl std::default::Default for $name
                    {
                        fn default() -> Self { $name(Span::call_site()) }
                    }
                    
                    impl Copy for $name {}
                    
                    impl Clone for $name
                    {
                        fn clone(&self) -> Self { *self }
                    }

                    impl Debug for $name
                    {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                        { f.write_str(stringify!($name)) }
                    }

                    impl cmp::Eq for $name {}

                    impl PartialEq for $name
                    {
                        fn eq(&self, _other: &$name) -> bool { true }
                    }

                    impl Hash for $name
                    {
                        fn hash<H: Hasher>(&self, _state: &mut H) {}
                    }

                    impl $name
                    {
                        pub fn surround<F>( &self, tokens:&mut TokenStream, f:F ) where
                        F: FnOnce( &mut TokenStream )
                        {
                            let mut inner = TokenStream::new();
                            f( &mut inner );
                            printing::delim( Delimiter::$delim, self.span.join(), tokens, inner );
                        }
                    }
                    
                    impl private::Sealed for $name {}
                )*
            };
        }
        /// Marker trait for types that represent single tokens.
        pub trait Token: private::Sealed
        {
            fn peek(cursor: Cursor) -> bool;
            fn display() -> &'static str;
        }

        pub mod private
        {
            use ::
            {
                process::macros::Span,
                syntax::buffer::Cursor,
                *,
            };
            
            pub trait Sealed {}
            /// Support writing `token.span` rather than `token.spans[0]` on tokens that hold a single span.
            #[repr(transparent)]
            pub struct WithSpan
            {
                pub span: Span,
            }
            
            pub trait CustomToken
            {
                fn peek(cursor: Cursor) -> bool;
                fn display() -> &'static str;
            }
        }
        
        impl private::Sealed for Ident {}

        impl_low_level_token!("punctuation token" Punct punct);
        impl_low_level_token!("literal" Literal literal);
        impl_low_level_token!("token" TokenTree token_tree);
        impl_low_level_token!("group token" process::macros::Group any_group);
        impl_low_level_token!("lifetime" Lifetime lifetime);
        
        impl<T: CustomToken> private::Sealed for T {}
        impl<T: CustomToken> Token for T
        {
            fn peek(cursor: Cursor) -> bool { <Self as CustomToken>::peek(cursor) }
            fn display() -> &'static str { <Self as CustomToken>::display() }
        }

        define_punctuation_structs! 
        {
            "_" pub struct Underscore/1 /// wildcard patterns, inferred types, unnamed items in constants, extern crates, use declarations, and destructuring assignment
        }
        
        impl ToTokens for Underscore {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(Ident::new("_", self.span));
            }
        }

         
            impl Parse for Underscore {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| {
                    if let Some((ident, rest)) = cursor.ident() {
                        if ident == "_" {
                            return Ok((Underscore(ident.span()), rest));
                        }
                    }
                    if let Some((punct, rest)) = cursor.punct() {
                        if punct.as_char() == '_' {
                            return Ok((Underscore(punct.span()), rest));
                        }
                    }
                    Err(cursor.error("expected `_`"))
                })
            }
        }

         
            impl Token for Underscore {
            fn peek(cursor: Cursor) -> bool
        {
                if let Some((ident, _rest)) = cursor.ident() {
                    return ident == "_";
                }
                if let Some((punct, _rest)) = cursor.punct() {
                    return punct.as_char() == '_';
                }
                false
            }

            fn display() -> &'static str {
                "`_`"
            }
        }

         
            impl private::Sealed for Underscore {}
        /// None-delimited group
        pub struct Group {
            pub span: Span,
        }

        pub fn Group<S: IntoSpans<Span>>(span: S) -> Group {
            Group {
                span: span.into_spans(),
            }
        }

        impl std::default::Default for Group {
            fn default() -> Self {
                Group {
                    span: Span::call_site(),
                }
            }
        }

        impl Copy for Group {}

        impl Clone for Group {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl Debug for Group {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_str("Group")
            }
        }

        impl cmp::Eq for Group {}

        impl PartialEq for Group {
            fn eq(&self, _other: &Group) -> bool
        {
                true
            }
        }

        impl Hash for Group {
            fn hash<H: Hasher>(&self, _state: &mut H) {}
        }

        impl Group
        {
            pub fn surround<F>(&self, tokens: &mut TokenStream, f: F) where
                F: FnOnce(&mut TokenStream),
            {
                let mut inner = TokenStream::new();
                f(&mut inner);
                printing::delim(Delimiter::None, self.span, tokens, inner);
            }
        }

         
            impl private::Sealed for Group {}

         
            impl Token for Paren {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.group(Delimiter::Parenthesis).is_some()
            }

            fn display() -> &'static str {
                "parentheses"
            }
        }

         
            impl Token for Brace {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.group(Delimiter::Brace).is_some()
            }

            fn display() -> &'static str {
                "curly braces"
            }
        }

         
            impl Token for Bracket {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.group(Delimiter::Bracket).is_some()
            }

            fn display() -> &'static str {
                "square brackets"
            }
        }

         
            impl Token for Group {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.group(Delimiter::None).is_some()
            }

            fn display() -> &'static str {
                "invisible group"
            }
        }

        define_keywords! {
            "abstract"    pub struct Abstract
            "as"          pub struct As
            "async"       pub struct Async
            "auto"        pub struct Auto
            "await"       pub struct Await
            "become"      pub struct Become
            "box"         pub struct Box
            "break"       pub struct Break
            "const"       pub struct Const
            "continue"    pub struct Continue
            "crate"       pub struct Crate
            "default"     pub struct Default
            "do"          pub struct Do
            "dyn"         pub struct Dyn
            "else"        pub struct Else
            "enum"        pub struct Enum
            "extern"      pub struct Extern
            "final"       pub struct Final
            "fn"          pub struct Fn
            "for"         pub struct For
            "if"          pub struct If
            "impl"        pub struct Impl
            "in"          pub struct In
            "let"         pub struct Let
            "loop"        pub struct Loop
            "macro"       pub struct Macro
            "match"       pub struct Match
            "mod"         pub struct Mod
            "move"        pub struct Move
            "mut"         pub struct Mut
            "override"    pub struct Override
            "priv"        pub struct Priv
            "pub"         pub struct Pub
            "raw"         pub struct Raw
            "ref"         pub struct Ref
            "return"      pub struct Return
            "Self"        pub struct SelfType
            "self"        pub struct SelfValue
            "static"      pub struct Static
            "struct"      pub struct Struct
            "super"       pub struct Super
            "trait"       pub struct Trait
            "try"         pub struct Try
            "type"        pub struct Type
            "typeof"      pub struct Typeof
            "union"       pub struct Union
            "unsafe"      pub struct Unsafe
            "unsized"     pub struct Unsized
            "use"         pub struct Use
            "virtual"     pub struct Virtual
            "where"       pub struct Where
            "while"       pub struct While
            "yield"       pub struct Yield
        }

        define_punctuation! {
            "&"           pub struct And/1        /// bitwise and logical AND, borrow, references, reference patterns
            "&&"          pub struct AndAnd/2     /// lazy AND, borrow, references, reference patterns
            "&="          pub struct AndEq/2      /// bitwise AND assignment
            "@"           pub struct At/1         /// subpattern binding
            "^"           pub struct Caret/1      /// bitwise and logical XOR
            "^="          pub struct CaretEq/2    /// bitwise XOR assignment
            ":"           pub struct Colon/1      /// various separators
            ","           pub struct Comma/1      /// various separators
            "$"           pub struct Dollar/1     /// macros
            "."           pub struct Dot/1        /// field access, tuple index
            ".."          pub struct DotDot/2     /// range, struct expressions, patterns, range patterns
            "..."         pub struct DotDotDot/3  /// variadic functions, range patterns
            "..="         pub struct DotDotEq/3   /// inclusive range, range patterns
            "="           pub struct Eq/1         /// assignment, attributes, various type definitions
            "=="          pub struct EqEq/2       /// equal
            "=>"          pub struct FatArrow/2   /// match arms, macros
            ">="          pub struct Ge/2         /// greater than or equal to, generics
            ">"           pub struct Gt/1         /// greater than, generics, paths
            "<-"          pub struct LArrow/2     /// unused
            "<="          pub struct Le/2         /// less than or equal to
            "<"           pub struct Lt/1         /// less than, generics, paths
            "-"           pub struct Minus/1      /// subtraction, negation
            "-="          pub struct MinusEq/2    /// subtraction assignment
            "!="          pub struct Ne/2         /// not equal
            "!"           pub struct Not/1        /// bitwise and logical NOT, macro calls, inner attributes, never type, negative impls
            "|"           pub struct Or/1         /// bitwise and logical OR, closures, patterns in match, if let, and while let
            "|="          pub struct OrEq/2       /// bitwise OR assignment
            "||"          pub struct OrOr/2       /// lazy OR, closures
            "::"          pub struct PathSep/2    /// path separator
            "%"           pub struct Percent/1    /// remainder
            "%="          pub struct PercentEq/2  /// remainder assignment
            "+"           pub struct Plus/1       /// addition, trait bounds, macro Kleene matcher
            "+="          pub struct PlusEq/2     /// addition assignment
            "#"           pub struct Pound/1      /// attributes
            "?"           pub struct Question/1   /// question mark operator, questionably sized, macro Kleene matcher
            "->"          pub struct RArrow/2     /// function return type, closure return type, function pointer type
            ";"           pub struct Semi/1       /// terminator for various items and statements, array types
            "<<"          pub struct Shl/2        /// shift left, nested generics
            "<<="         pub struct ShlEq/3      /// shift left assignment
            ">>"          pub struct Shr/2        /// shift right, nested generics
            ">>="         pub struct ShrEq/3      /// shift right assignment, nested generics
            "/"           pub struct Slash/1      /// division
            "/="          pub struct SlashEq/2    /// division assignment
            "*"           pub struct Star/1       /// multiplication, dereference, raw pointers, macro Kleene matcher, use wildcards
            "*="          pub struct StarEq/2     /// multiplication assignment
            "~"           pub struct Tilde/1      /// unused since before Rust 1.0
        }

        define_delimiters! {
            Brace         pub struct Brace        /// `{`&hellip;`}`
            Bracket       pub struct Bracket      /// `[`&hellip;`]`
            Parenthesis   pub struct Paren        /// `(`&hellip;`)`
        }
        /// A type-macro that expands to the name of the Rust type representation of a given token.
        #[macro_export]
        macro_rules! Token {
            [abstract]    => { ::syntax::token::Abstract };
            [as]          => { ::syntax::token::As };
            [async]       => { ::syntax::token::Async };
            [auto]        => { ::syntax::token::Auto };
            [await]       => { ::syntax::token::Await };
            [become]      => { ::syntax::token::Become };
            [box]         => { ::syntax::token::Box };
            [break]       => { ::syntax::token::Break };
            [const]       => { ::syntax::token::Const };
            [continue]    => { ::syntax::token::Continue };
            [crate]       => { ::syntax::token::Crate };
            [default]     => { ::syntax::token::Default };
            [do]          => { ::syntax::token::Do };
            [dyn]         => { ::syntax::token::Dyn };
            [else]        => { ::syntax::token::Else };
            [enum]        => { ::syntax::token::Enum };
            [extern]      => { ::syntax::token::Extern };
            [final]       => { ::syntax::token::Final };
            [fn]          => { ::syntax::token::Fn };
            [for]         => { ::syntax::token::For };
            [if]          => { ::syntax::token::If };
            [impl]        => { ::syntax::token::Impl };
            [in]          => { ::syntax::token::In };
            [let]         => { ::syntax::token::Let };
            [loop]        => { ::syntax::token::Loop };
            [macro]       => { ::syntax::token::Macro };
            [match]       => { ::syntax::token::Match };
            [mod]         => { ::syntax::token::Mod };
            [move]        => { ::syntax::token::Move };
            [mut]         => { ::syntax::token::Mut };
            [override]    => { ::syntax::token::Override };
            [priv]        => { ::syntax::token::Priv };
            [pub]         => { ::syntax::token::Pub };
            [raw]         => { ::syntax::token::Raw };
            [ref]         => { ::syntax::token::Ref };
            [return]      => { ::syntax::token::Return };
            [Self]        => { ::syntax::token::SelfType };
            [self]        => { ::syntax::token::SelfValue };
            [static]      => { ::syntax::token::Static };
            [struct]      => { ::syntax::token::Struct };
            [super]       => { ::syntax::token::Super };
            [trait]       => { ::syntax::token::Trait };
            [try]         => { ::syntax::token::Try };
            [type]        => { ::syntax::token::Type };
            [typeof]      => { ::syntax::token::Typeof };
            [union]       => { ::syntax::token::Union };
            [unsafe]      => { ::syntax::token::Unsafe };
            [unsized]     => { ::syntax::token::Unsized };
            [use]         => { ::syntax::token::Use };
            [virtual]     => { ::syntax::token::Virtual };
            [where]       => { ::syntax::token::Where };
            [while]       => { ::syntax::token::While };
            [yield]       => { ::syntax::token::Yield };
            [&]           => { ::syntax::token::And };
            [&&]          => { ::syntax::token::AndAnd };
            [&=]          => { ::syntax::token::AndEq };
            [@]           => { ::syntax::token::At };
            [^]           => { ::syntax::token::Caret };
            [^=]          => { ::syntax::token::CaretEq };
            [:]           => { ::syntax::token::Colon };
            [,]           => { ::syntax::token::Comma };
            [$]           => { ::syntax::token::Dollar };
            [.]           => { ::syntax::token::Dot };
            [..]          => { ::syntax::token::DotDot };
            [...]         => { ::syntax::token::DotDotDot };
            [..=]         => { ::syntax::token::DotDotEq };
            [=]           => { ::syntax::token::Eq };
            [==]          => { ::syntax::token::EqEq };
            [=>]          => { ::syntax::token::FatArrow };
            [>=]          => { ::syntax::token::Ge };
            [>]           => { ::syntax::token::Gt };
            [<-]          => { ::syntax::token::LArrow };
            [<=]          => { ::syntax::token::Le };
            [<]           => { ::syntax::token::Lt };
            [-]           => { ::syntax::token::Minus };
            [-=]          => { ::syntax::token::MinusEq };
            [!=]          => { ::syntax::token::Ne };
            [!]           => { ::syntax::token::Not };
            [|]           => { ::syntax::token::Or };
            [|=]          => { ::syntax::token::OrEq };
            [||]          => { ::syntax::token::OrOr };
            [::]          => { ::syntax::token::PathSep };
            [%]           => { ::syntax::token::Percent };
            [%=]          => { ::syntax::token::PercentEq };
            [+]           => { ::syntax::token::Plus };
            [+=]          => { ::syntax::token::PlusEq };
            [#]           => { ::syntax::token::Pound };
            [?]           => { ::syntax::token::Question };
            [->]          => { ::syntax::token::RArrow };
            [;]           => { ::syntax::token::Semi };
            [<<]          => { ::syntax::token::Shl };
            [<<=]         => { ::syntax::token::ShlEq };
            [>>]          => { ::syntax::token::Shr };
            [>>=]         => { ::syntax::token::ShrEq };
            [/]           => { ::syntax::token::Slash };
            [/=]          => { ::syntax::token::SlashEq };
            [*]           => { ::syntax::token::Star };
            [*=]          => { ::syntax::token::StarEq };
            [~]           => { ::syntax::token::Tilde };
            [_]           => { ::syntax::token::Underscore };
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::{Spacing, Span},
                syntax::
                {
                    buffer::Cursor,
                    error::{Error, Result},
                    parse::ParseStream,
                },
                *,
            };

            pub fn keyword(input: ParseStream, token: &str) -> Result<Span> {
                input.step(|cursor| {
                    if let Some((ident, rest)) = cursor.ident() {
                        if ident == token {
                            return Ok((ident.span(), rest));
                        }
                    }
                    Err(cursor.error(format!("expected `{}`", token)))
                })
            }

            pub fn peek_keyword(cursor: Cursor, token: &str) -> bool
        {
                if let Some((ident, _rest)) = cursor.ident() {
                    ident == token
                } else {
                    false
                }
            }

                pub fn punct<const N: usize>(input: ParseStream, token: &str) -> Result<[Span; N]>
            {
                let mut spans = [input.span(); N];
                punct_helper(input, token, &mut spans)?;
                Ok(spans)
            }

            fn punct_helper(input: ParseStream, token: &str, spans: &mut [Span]) -> Result<()> {
                input.step(|cursor| {
                    let mut cursor = *cursor;
                    assert_eq!(token.len(), spans.len());

                    for (i, ch) in token.chars().enumerate() {
                        match cursor.punct() {
                            Some((punct, rest)) => {
                                spans[i] = punct.span();
                                if punct.as_char() != ch {
                                    break;
                                } else if i == token.len() - 1 {
                                    return Ok(((), rest));
                                } else if punct.spacing() != Spacing::Joint {
                                    break;
                                }
                                cursor = rest;
                            }
                            None => break,
                        }
                    }

                    Err(Error::new(spans[0], format!("expected `{}`", token)))
                })
            }

                pub fn peek_punct(mut cursor: Cursor, token: &str) -> bool
        {
                for (i, ch) in token.chars().enumerate( )
                {
                    match cursor.punct() {
                        Some((punct, rest)) => {
                            if punct.as_char() != ch {
                                break;
                            } else if i == token.len() - 1 {
                                return true;
                            } else if punct.spacing() != Spacing::Joint {
                                break;
                            }
                            cursor = rest;
                        }
                        None => break,
                    }
                }
                false
            }
        }
        
        pub mod printing
        {
            use ::process::macros::{Delimiter, Group, Ident, Punct, Spacing, Span, TokenStream};
            use ::quote::TokenStreamExt;

                pub fn punct(s: &str, spans: &[Span], tokens: &mut TokenStream)
            {
                assert_eq!(s.len(), spans.len());

                let mut chars = s.chars();
                let mut spans = spans.iter();
                let ch = chars.next_back().unwrap();
                let span = spans.next_back().unwrap();
                for (ch, span) in chars.zip(spans) {
                    let mut op = Punct::new(ch, Spacing::Joint);
                    op.set_span(*span);
                    tokens.append(op);
                }

                let mut op = Punct::new(ch, Spacing::Alone);
                op.set_span(*span);
                tokens.append(op);
            }

            pub fn keyword(s: &str, span: Span, tokens: &mut TokenStream) {
                tokens.append(Ident::new(s, span));
            }

            pub fn delim(
                delim: Delimiter,
                span: Span,
                tokens: &mut TokenStream,
                inner: TokenStream,
            ) {
                let mut g = Group::new(delim, inner);
                g.set_span(span);
                tokens.append(g);
            }
        }
    }

    pub mod bigint
    {
        use ::
        {
            ops::{ AddAssign, MulAssign },
            *,
        };
        
        pub struct BigInt {
            digits: Vec<u8>,
        }

        impl BigInt {
            pub fn new() -> Self {
                BigInt { digits: Vec::new() }
            }

            pub fn to_string(&self) -> String {
                let mut repr = String::with_capacity(self.digits.len());

                let mut has_nonzero = false;
                for digit in self.digits.iter().rev() {
                    has_nonzero |= *digit != 0;
                    if has_nonzero {
                        repr.push((*digit + b'0') as char);
                    }
                }

                if repr.is_empty() {
                    repr.push('0');
                }

                repr
            }

            fn reserve_two_digits(&mut self) {
                let len = self.digits.len();
                let desired =
                    len + !self.digits.ends_with(&[0, 0]) as usize + !self.digits.ends_with(&[0]) as usize;
                self.digits.resize(desired, 0);
            }
        }

        impl AddAssign<u8> for BigInt {
           
            fn add_assign(&mut self, mut increment: u8)
            {
                self.reserve_two_digits();

                let mut i = 0;
                while increment > 0 {
                    let sum = self.digits[i] + increment;
                    self.digits[i] = sum % 10;
                    increment = sum / 10;
                    i += 1;
                }
            }
        }

        impl MulAssign<u8> for BigInt {
           
            fn mul_assign(&mut self, base: u8)
            {
                self.reserve_two_digits();

                let mut carry = 0;
                for digit in &mut self.digits {
                    let prod = *digit * base + carry;
                    *digit = prod % 10;
                    carry = prod / 10;
                }
            }
        }
    }
    
    pub mod buffer
    {
        //! A stably addressed token buffer supporting efficient traversal based on a cheaply copyable cursor.
        use ::
        {
            cmp::{ Ordering },
            marker::{ PhantomData },
            process::macros::
            {
                extra::DelimSpan,
                Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree,
            },
            *,
        };
        /*
        */
        /// Internal type which is used instead of `TokenTree` to represent a token tree within a `TokenBuffer`.
        enum Entry {
           
           
            Group(Group, usize),
            Ident(Ident),
            Punct(Punct),
            Literal(Literal),
           
           
            End(isize, isize),
        }
        /// A buffer that can be efficiently traversed multiple times, 
        /// unlike `TokenStream` which requires a deep copy in order to traverse more than once.
        pub struct TokenBuffer {
           
           
            entries: Box<[Entry]>,
        }

        impl TokenBuffer {
            fn recursive_new(entries: &mut Vec<Entry>, stream: TokenStream) {
                for tt in stream {
                    match tt {
                        TokenTree::Ident(ident) => entries.push(Entry::Ident(ident)),
                        TokenTree::Punct(punct) => entries.push(Entry::Punct(punct)),
                        TokenTree::Literal(literal) => entries.push(Entry::Literal(literal)),
                        TokenTree::Group(group) => {
                            let group_start_index = entries.len();
                            entries.push(Entry::End(0, 0));
                            Self::recursive_new(entries, group.stream());
                            let group_end_index = entries.len();
                            let group_offset = group_end_index - group_start_index;
                            entries.push(Entry::End(
                                -(group_end_index as isize),
                                -(group_offset as isize),
                            ));
                            entries[group_start_index] = Entry::Group(group, group_offset);
                        }
                    }
                }
            }
            /// Creates a `TokenBuffer` containing all the tokens from the input
            /// `proc_macro::TokenStream`.
            #[cfg(feature = "proc-macro")]
            #[cfg_attr(docsrs, doc(cfg(feature = "proc-macro")))]
            pub fn new(stream: proc_macro::TokenStream) -> Self {
                Self::new2(stream.into())
            }
            /// Creates a `TokenBuffer` containing all the tokens from the input
            /// `process::macros::TokenStream`.
            pub fn new2(stream: TokenStream) -> Self {
                let mut entries = Vec::new();
                Self::recursive_new(&mut entries, stream);
                entries.push(Entry::End(-(entries.len() as isize), 0));
                Self {
                    entries: entries.into_boxed_slice(),
                }
            }
            /// Creates a cursor referencing the first token in the buffer and able to
            /// traverse until the end of the buffer.
            pub fn begin(&self) -> Cursor {
                let ptr = self.entries.as_ptr();
                unsafe { Cursor::create(ptr, ptr.add(self.entries.len() - 1)) }
            }
        }
        /// A cheaply copyable cursor into a `TokenBuffer`.
        pub struct Cursor<'a> {
           
            ptr: *const Entry,
           
           
            scope: *const Entry,
           
           
            marker: PhantomData<&'a Entry>,
        }

        impl<'a> Cursor<'a> {
            /// Creates a cursor referencing a static empty TokenStream.
            pub fn empty() -> Self {
               
               
               
               
                //
               
               
                struct UnsafeSyncEntry(Entry);
                unsafe impl Sync for UnsafeSyncEntry {}
                static EMPTY_ENTRY: UnsafeSyncEntry = UnsafeSyncEntry(Entry::End(0, 0));

                Cursor {
                    ptr: &EMPTY_ENTRY.0,
                    scope: &EMPTY_ENTRY.0,
                    marker: PhantomData,
                }
            }
            /// This create method intelligently exits non-explicitly-entered
            /// `None`-delimited scopes when the cursor reaches the end of them,
            /// allowing for them to be treated transparently.
            unsafe fn create(mut ptr: *const Entry, scope: *const Entry) -> Self {
               
               
               
               
                while let Entry::End(..) = unsafe { &*ptr } {
                    if ptr::eq(ptr, scope) {
                        break;
                    }
                    ptr = unsafe { ptr.add(1) };
                }

                Cursor {
                    ptr,
                    scope,
                    marker: PhantomData,
                }
            }
            /// Get the current entry.
            fn entry(self) -> &'a Entry {
                unsafe { &*self.ptr }
            }
            /// Bump the cursor to point at the next token after the current one. This
            /// is undefined behavior if the cursor is currently looking at an
            /// `Entry::End`.
            unsafe fn bump_ignore_group(self) -> Cursor<'a> {
                unsafe { Cursor::create(self.ptr.offset(1), self.scope) }
            }
            /// While the cursor is looking at a `None`-delimited group, move it to look
            /// at the first token inside instead. If the group is empty, this will move
            /// the cursor past the `None`-delimited group.
            ///
            /// WARNING: This mutates its argument.
            fn ignore_none(&mut self) {
                while let Entry::Group(group, _) = self.entry() {
                    if group.delimiter() == Delimiter::None {
                        unsafe { *self = self.bump_ignore_group() };
                    } else {
                        break;
                    }
                }
            }
            /// Checks whether the cursor is currently pointing at the end of its valid
            /// scope.
            pub fn eof(self) -> bool
            {
               
                ptr::eq(self.ptr, self.scope)
            }
            /// If the cursor is pointing at a `Ident`, returns it along with a cursor
            /// pointing at the next `TokenTree`.
            pub fn ident(mut self) -> Option<(Ident, Cursor<'a>)>
            {
                self.ignore_none();
                match self.entry() {
                    Entry::Ident(ident) => Some((ident.clone(), unsafe { self.bump_ignore_group() })),
                    _ => None,
                }
            }
            /// If the cursor is pointing at a `Punct`, returns it along with a cursor
            /// pointing at the next `TokenTree`.
            pub fn punct(mut self) -> Option<(Punct, Cursor<'a>)>
            {
                self.ignore_none();
                match self.entry() {
                    Entry::Punct(punct) if punct.as_char() != '\'' => {
                        Some((punct.clone(), unsafe { self.bump_ignore_group() }))
                    }
                    _ => None,
                }
            }
            /// If the cursor is pointing at a `Literal`, return it along with a cursor
            /// pointing at the next `TokenTree`.
            pub fn literal(mut self) -> Option<(Literal, Cursor<'a>)>
            {
                self.ignore_none();
                match self.entry() {
                    Entry::Literal(literal) => Some((literal.clone(), unsafe { self.bump_ignore_group() })),
                    _ => None,
                }
            }
            /// If the cursor is pointing at a `Lifetime`, returns it along with a
            /// cursor pointing at the next `TokenTree`.
            pub fn lifetime(mut self) -> Option<( ::syntax::Lifetime, Cursor<'a>)>
            {
                self.ignore_none();
                match self.entry() {
                    Entry::Punct(punct) if punct.as_char() == '\'' && punct.spacing() == Spacing::Joint => {
                        let next = unsafe { self.bump_ignore_group() };
                        let (ident, rest) = next.ident()?;
                        let lifetime = ::syntax::Lifetime {
                            apostrophe: punct.span(),
                            ident,
                        };
                        Some((lifetime, rest))
                    }
                    _ => None,
                }
            }
            /// If the cursor is pointing at a `Group` with the given delimiter, returns
            /// a cursor into that group and one pointing to the next `TokenTree`.
            pub fn group(mut self, delim: Delimiter) -> Option<(Cursor<'a>, DelimSpan, Cursor<'a>)> {
               
               
               
                if delim != Delimiter::None {
                    self.ignore_none();
                }

                if let Entry::Group(group, end_offset) = self.entry() {
                    if group.delimiter() == delim {
                        let span = group.delim_span();
                        let end_of_group = unsafe { self.ptr.add(*end_offset) };
                        let inside_of_group = unsafe { Cursor::create(self.ptr.add(1), end_of_group) };
                        let after_group = unsafe { Cursor::create(end_of_group, self.scope) };
                        return Some((inside_of_group, span, after_group));
                    }
                }

                None
            }
            /// If the cursor is pointing at a `Group`, returns a cursor into the group
            /// and one pointing to the next `TokenTree`.
            pub fn any_group(self) -> Option<(Cursor<'a>, Delimiter, DelimSpan, Cursor<'a>)> {
                if let Entry::Group(group, end_offset) = self.entry() {
                    let delimiter = group.delimiter();
                    let span = group.delim_span();
                    let end_of_group = unsafe { self.ptr.add(*end_offset) };
                    let inside_of_group = unsafe { Cursor::create(self.ptr.add(1), end_of_group) };
                    let after_group = unsafe { Cursor::create(end_of_group, self.scope) };
                    return Some((inside_of_group, delimiter, span, after_group));
                }

                None
            }

            pub fn any_group_token(self) -> Option<(Group, Cursor<'a>)> {
                if let Entry::Group(group, end_offset) = self.entry() {
                    let end_of_group = unsafe { self.ptr.add(*end_offset) };
                    let after_group = unsafe { Cursor::create(end_of_group, self.scope) };
                    return Some((group.clone(), after_group));
                }

                None
            }
            /// Copies all remaining tokens visible from this cursor into a
            /// `TokenStream`.
            pub fn token_stream(self) -> TokenStream {
                let mut tts = Vec::new();
                let mut cursor = self;
                while let Some((tt, rest)) = cursor.token_tree() {
                    tts.push(tt);
                    cursor = rest;
                }
                tts.into_iter().collect()
            }
            /// If the cursor is pointing at a `TokenTree`, returns it along with a
            /// cursor pointing at the next `TokenTree`.
            pub fn token_tree(self) -> Option<(TokenTree, Cursor<'a>)>
            {
                let (tree, len) = match self.entry() {
                    Entry::Group(group, end_offset) => (group.clone().into(), *end_offset),
                    Entry::Literal(literal) => (literal.clone().into(), 1),
                    Entry::Ident(ident) => (ident.clone().into(), 1),
                    Entry::Punct(punct) => (punct.clone().into(), 1),
                    Entry::End(..) => return None,
                };

                let rest = unsafe { Cursor::create(self.ptr.add(len), self.scope) };
                Some((tree, rest))
            }
            /// Returns the `Span` of the current token, or `Span::call_site()` if this
            /// cursor points to eof.
            pub fn span(mut self) -> Span {
                match self.entry() {
                    Entry::Group(group, _) => group.span(),
                    Entry::Literal(literal) => literal.span(),
                    Entry::Ident(ident) => ident.span(),
                    Entry::Punct(punct) => punct.span(),
                    Entry::End(_, offset) => {
                        self.ptr = unsafe { self.ptr.offset(*offset) };
                        if let Entry::Group(group, _) = self.entry() {
                            group.span_close()
                        } else {
                            Span::call_site()
                        }
                    }
                }
            }
            /// Returns the `Span` of the token immediately prior to the position of
            /// this cursor, or of the current token if there is no previous one.
                pub fn prev_span(mut self) -> Span {
                if start_of_buffer(self) < self.ptr {
                    self.ptr = unsafe { self.ptr.offset(-1) };
                }
                self.span()
            }
            /// Skip over the next token that is not a None-delimited group, without
            /// cloning it. Returns `None` if this cursor points to eof.
            ///
            /// This method treats `'lifetimes` as a single token.
            pub fn skip(mut self) -> Option<Cursor<'a>>
            {
                self.ignore_none();

                let len = match self.entry() {
                    Entry::End(..) => return None,

                   
                    Entry::Punct(punct) if punct.as_char() == '\'' && punct.spacing() == Spacing::Joint => {
                        match unsafe { &*self.ptr.add(1) } {
                            Entry::Ident(_) => 2,
                            _ => 1,
                        }
                    }

                    Entry::Group(_, end_offset) => *end_offset,
                    _ => 1,
                };

                Some(unsafe { Cursor::create(self.ptr.add(len), self.scope) })
            }

            pub fn scope_delimiter(self) -> Delimiter {
                match unsafe { &*self.scope } {
                    Entry::End(_, offset) => match unsafe { &*self.scope.offset(*offset) } {
                        Entry::Group(group, _) => group.delimiter(),
                        _ => Delimiter::None,
                    },
                    _ => unreachable!(),
                }
            }
        }

        impl<'a> Copy for Cursor<'a> {}

        impl<'a> Clone for Cursor<'a> {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl<'a> Eq for Cursor<'a> {}

        impl<'a> PartialEq for Cursor<'a> {
            fn eq(&self, other: &Self) -> bool
        {
                ptr::eq(self.ptr, other.ptr)
            }
        }

        impl<'a> PartialOrd for Cursor<'a> {
            fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
                if same_buffer(*self, *other) {
                    Some(cmp_assuming_same_buffer(*self, *other))
                } else {
                    None
                }
            }
        }

        pub fn same_scope(a: Cursor, b: Cursor) -> bool
        {
            ptr::eq(a.scope, b.scope)
        }

        pub fn same_buffer(a: Cursor, b: Cursor) -> bool
        {
            ptr::eq(start_of_buffer(a), start_of_buffer(b))
        }

        fn start_of_buffer(cursor: Cursor) -> *const Entry {
            unsafe {
                match &*cursor.scope {
                    Entry::End(offset, _) => cursor.scope.offset(*offset),
                    _ => unreachable!(),
                }
            }
        }

        pub fn cmp_assuming_same_buffer(a: Cursor, b: Cursor) -> Ordering {
            a.ptr.cmp(&b.ptr)
        }

        pub fn open_span_of_group(cursor: Cursor) -> Span {
            match cursor.entry() {
                Entry::Group(group, _) => group.span_open(),
                _ => cursor.span(),
            }
        }
    }
    
    pub mod classify
    {
        use ::
        {
            ops::{ ControlFlow },
            process::macros::{Delimiter, TokenStream, TokenTree},
            syntax::
            {
                expr::Expr,
                generics::TypeParamBound,
                path::{Path, PathArguments},
                punctuated::Punctuated,
                ty::{ReturnType, Type},
            },
            *,
        };
        /*
        
        */
        pub fn requires_semi_to_be_stmt(expr: &Expr) -> bool
        {
            match expr {
                Expr::Macro(expr) => !expr.mac.delimiter.is_brace(),
                _ => requires_comma_to_be_match_arm(expr),
            }
        }

        pub fn requires_comma_to_be_match_arm(expr: &Expr) -> bool
        {
            match expr {
                Expr::If(_)
                | Expr::Match(_)
                | Expr::Block(_) | Expr::Unsafe(_)
                | Expr::While(_)
                | Expr::Loop(_)
                | Expr::ForLoop(_)
                | Expr::TryBlock(_)
                | Expr::Const(_) => false,

                Expr::Array(_)
                | Expr::Assign(_)
                | Expr::Async(_)
                | Expr::Await(_)
                | Expr::Binary(_)
                | Expr::Break(_)
                | Expr::Call(_)
                | Expr::Cast(_)
                | Expr::Closure(_)
                | Expr::Continue(_)
                | Expr::Field(_)
                | Expr::Group(_)
                | Expr::Index(_)
                | Expr::Infer(_)
                | Expr::Let(_)
                | Expr::Lit(_)
                | Expr::Macro(_)
                | Expr::MethodCall(_)
                | Expr::Paren(_)
                | Expr::Path(_)
                | Expr::Range(_)
                | Expr::RawAddr(_)
                | Expr::Reference(_)
                | Expr::Repeat(_)
                | Expr::Return(_)
                | Expr::Struct(_)
                | Expr::Try(_)
                | Expr::Tuple(_)
                | Expr::Unary(_)
                | Expr::Yield(_)
                | Expr::Verbatim(_) => true,
            }
        }
        
        pub fn trailing_unparameterized_path(mut ty: &Type) -> bool
        {
            loop {
                match ty {
                    Type::BareFn(t) => match &t.output {
                        ReturnType::Default => return false,
                        ReturnType::Type(_, ret) => ty = ret,
                    },
                    Type::ImplTrait(t) => match last_type_in_bounds(&t.bounds) {
                        ControlFlow::Break(trailing_path) => return trailing_path,
                        ControlFlow::Continue(t) => ty = t,
                    },
                    Type::Path(t) => match last_type_in_path(&t.path) {
                        ControlFlow::Break(trailing_path) => return trailing_path,
                        ControlFlow::Continue(t) => ty = t,
                    },
                    Type::Ptr(t) => ty = &t.elem,
                    Type::Reference(t) => ty = &t.elem,
                    Type::TraitObject(t) => match last_type_in_bounds(&t.bounds) {
                        ControlFlow::Break(trailing_path) => return trailing_path,
                        ControlFlow::Continue(t) => ty = t,
                    },

                    Type::Array(_)
                    | Type::Group(_)
                    | Type::Infer(_)
                    | Type::Macro(_)
                    | Type::Never(_)
                    | Type::Paren(_)
                    | Type::Slice(_)
                    | Type::Tuple(_)
                    | Type::Verbatim(_) => return false,
                }
            }

            fn last_type_in_path(path: &Path) -> ControlFlow<bool, &Type>
            {
                match &path.segments.last().unwrap().arguments {
                    PathArguments::None => ControlFlow::Break(true),
                    PathArguments::AngleBracketed(_) => ControlFlow::Break(false),
                    PathArguments::Parenthesized(arg) => match &arg.output {
                        ReturnType::Default => ControlFlow::Break(false),
                        ReturnType::Type(_, ret) => ControlFlow::Continue(ret),
                    },
                }
            }

            fn last_type_in_bounds(
                bounds: &Punctuated<TypeParamBound, Token![+]>,
            ) -> ControlFlow<bool, &Type>
            {
                match bounds.last().unwrap() {
                    TypeParamBound::Trait(t) => last_type_in_path(&t.path),
                    TypeParamBound::Lifetime(_)
                    | TypeParamBound::PreciseCapture(_)
                    | TypeParamBound::Verbatim(_) => ControlFlow::Break(false),
                }
            }
        }
        /// Whether the expression's first token is the label of a loop/block.
        pub fn expr_leading_label(mut expr: &Expr) -> bool
        {
            loop {
                match expr {
                    Expr::Block(e) => return e.label.is_some(),
                    Expr::ForLoop(e) => return e.label.is_some(),
                    Expr::Loop(e) => return e.label.is_some(),
                    Expr::While(e) => return e.label.is_some(),

                    Expr::Assign(e) => expr = &e.left,
                    Expr::Await(e) => expr = &e.base,
                    Expr::Binary(e) => expr = &e.left,
                    Expr::Call(e) => expr = &e.func,
                    Expr::Cast(e) => expr = &e.expr,
                    Expr::Field(e) => expr = &e.base,
                    Expr::Index(e) => expr = &e.expr,
                    Expr::MethodCall(e) => expr = &e.receiver,
                    Expr::Range(e) => match &e.start {
                        Some(start) => expr = start,
                        None => return false,
                    },
                    Expr::Try(e) => expr = &e.expr,

                    Expr::Array(_)
                    | Expr::Async(_)
                    | Expr::Break(_)
                    | Expr::Closure(_)
                    | Expr::Const(_)
                    | Expr::Continue(_)
                    | Expr::Group(_)
                    | Expr::If(_)
                    | Expr::Infer(_)
                    | Expr::Let(_)
                    | Expr::Lit(_)
                    | Expr::Macro(_)
                    | Expr::Match(_)
                    | Expr::Paren(_)
                    | Expr::Path(_)
                    | Expr::RawAddr(_)
                    | Expr::Reference(_)
                    | Expr::Repeat(_)
                    | Expr::Return(_)
                    | Expr::Struct(_)
                    | Expr::TryBlock(_)
                    | Expr::Tuple(_)
                    | Expr::Unary(_)
                    | Expr::Unsafe(_)
                    | Expr::Verbatim(_)
                    | Expr::Yield(_) => return false,
                }
            }
        }
        /// Whether the expression's last token is `}`.
        pub fn expr_trailing_brace(mut expr: &Expr) -> bool
        {
            loop {
                match expr {
                    Expr::Async(_)
                    | Expr::Block(_)
                    | Expr::Const(_)
                    | Expr::ForLoop(_)
                    | Expr::If(_)
                    | Expr::Loop(_)
                    | Expr::Match(_)
                    | Expr::Struct(_)
                    | Expr::TryBlock(_)
                    | Expr::Unsafe(_)
                    | Expr::While(_) => return true,

                    Expr::Assign(e) => expr = &e.right,
                    Expr::Binary(e) => expr = &e.right,
                    Expr::Break(e) => match &e.expr {
                        Some(e) => expr = e,
                        None => return false,
                    },
                    Expr::Cast(e) => return type_trailing_brace(&e.ty),
                    Expr::Closure(e) => expr = &e.body,
                    Expr::Let(e) => expr = &e.expr,
                    Expr::Macro(e) => return e.mac.delimiter.is_brace(),
                    Expr::Range(e) => match &e.end {
                        Some(end) => expr = end,
                        None => return false,
                    },
                    Expr::RawAddr(e) => expr = &e.expr,
                    Expr::Reference(e) => expr = &e.expr,
                    Expr::Return(e) => match &e.expr {
                        Some(e) => expr = e,
                        None => return false,
                    },
                    Expr::Unary(e) => expr = &e.expr,
                    Expr::Verbatim(e) => return tokens_trailing_brace(e),
                    Expr::Yield(e) => match &e.expr {
                        Some(e) => expr = e,
                        None => return false,
                    },

                    Expr::Array(_)
                    | Expr::Await(_)
                    | Expr::Call(_)
                    | Expr::Continue(_)
                    | Expr::Field(_)
                    | Expr::Group(_)
                    | Expr::Index(_)
                    | Expr::Infer(_)
                    | Expr::Lit(_)
                    | Expr::MethodCall(_)
                    | Expr::Paren(_)
                    | Expr::Path(_)
                    | Expr::Repeat(_)
                    | Expr::Try(_)
                    | Expr::Tuple(_) => return false,
                }
            }

            fn type_trailing_brace(mut ty: &Type) -> bool
        {
                loop {
                    match ty {
                        Type::BareFn(t) => match &t.output {
                            ReturnType::Default => return false,
                            ReturnType::Type(_, ret) => ty = ret,
                        },
                        Type::ImplTrait(t) => match last_type_in_bounds(&t.bounds) {
                            ControlFlow::Break(trailing_brace) => return trailing_brace,
                            ControlFlow::Continue(t) => ty = t,
                        },
                        Type::Macro(t) => return t.mac.delimiter.is_brace(),
                        Type::Path(t) => match last_type_in_path(&t.path) {
                            Some(t) => ty = t,
                            None => return false,
                        },
                        Type::Ptr(t) => ty = &t.elem,
                        Type::Reference(t) => ty = &t.elem,
                        Type::TraitObject(t) => match last_type_in_bounds(&t.bounds) {
                            ControlFlow::Break(trailing_brace) => return trailing_brace,
                            ControlFlow::Continue(t) => ty = t,
                        },
                        Type::Verbatim(t) => return tokens_trailing_brace(t),

                        Type::Array(_)
                        | Type::Group(_)
                        | Type::Infer(_)
                        | Type::Never(_)
                        | Type::Paren(_)
                        | Type::Slice(_)
                        | Type::Tuple(_) => return false,
                    }
                }
            }

            fn last_type_in_path(path: &Path) -> Option<&Type>
            {
                match &path.segments.last().unwrap().arguments {
                    PathArguments::None | PathArguments::AngleBracketed(_) => None,
                    PathArguments::Parenthesized(arg) => match &arg.output {
                        ReturnType::Default => None,
                        ReturnType::Type(_, ret) => Some(ret),
                    },
                }
            }

            fn last_type_in_bounds(
                bounds: &Punctuated<TypeParamBound, Token![+]>,
            ) -> ControlFlow<bool, &Type>
            {
                match bounds.last().unwrap() {
                    TypeParamBound::Trait(t) => match last_type_in_path(&t.path) {
                        Some(t) => ControlFlow::Continue(t),
                        None => ControlFlow::Break(false),
                    },
                    TypeParamBound::Lifetime(_) | TypeParamBound::PreciseCapture(_) => {
                        ControlFlow::Break(false)
                    }
                    TypeParamBound::Verbatim(t) => ControlFlow::Break(tokens_trailing_brace(t)),
                }
            }

            fn tokens_trailing_brace(tokens: &TokenStream) -> bool
        {
                if let Some(TokenTree::Group(last)) = tokens.clone().into_iter().last() {
                    last.delimiter() == Delimiter::Brace
                } else {
                    false
                }
            }
        }
    }
        
    pub mod data
    {
        use ::
        {
            syntax::
            {
                attr::Attribute,
                expr::{Expr, Index, Member},
                ident::Ident,
                punctuated::{self, Punctuated},
                restriction::{FieldMutability, Visibility},
                token,
                ty::Type,
            },
            *,
        };
        /*
        */
        ast_struct! {
            /// An enum variant.
            pub struct Variant {
                pub attrs: Vec<Attribute>,
                /// Name of the variant.
                pub ident: Ident,
                /// Content stored in the variant.
                pub fields: Fields,
                /// Explicit discriminant: `Variant = 1`
                pub discriminant: Option<(Token![=], Expr)>,
            }
        }

        ast_enum_of_structs! {
            /// Data stored within an enum variant or struct.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            pub enum Fields {
                /// Named fields of a struct or struct variant such as `Point { x: f64,
                /// y: f64 }`.
                Named(FieldsNamed),
                /// Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.
                Unnamed(FieldsUnnamed),
                /// Unit struct or unit variant such as `None`.
                Unit,
            }
        }

        ast_struct! {
            /// Named fields of a struct or struct variant such as `Point { x: f64,
            /// y: f64 }`.
            pub struct FieldsNamed {
                pub brace_token: token::Brace,
                pub named: Punctuated<Field, Token![,]>,
            }
        }

        ast_struct! {
            /// Unnamed fields of a tuple struct or tuple variant such as `Some(T)`.
            pub struct FieldsUnnamed {
                pub paren_token: token::Paren,
                pub unnamed: Punctuated<Field, Token![,]>,
            }
        }

        impl Fields
        {
            /// Get an iterator over the borrowed [`Field`] items in this object.
            pub fn iter(&self) -> punctuated::Iter<Field>
            {
                match self {
                    Fields::Unit => ::syntax::punctuated::empty_punctuated_iter(),
                    Fields::Named(f) => f.named.iter(),
                    Fields::Unnamed(f) => f.unnamed.iter(),
                }
            }
            /// Get an iterator over the mutably borrowed [`Field`] items in this object.
            pub fn iter_mut(&mut self) -> punctuated::IterMut<Field>
            {
                match self {
                    Fields::Unit => ::syntax::punctuated::empty_punctuated_iter_mut(),
                    Fields::Named(f) => f.named.iter_mut(),
                    Fields::Unnamed(f) => f.unnamed.iter_mut(),
                }
            }
            /// Returns the number of fields.
            pub fn len(&self) -> usize {
                match self {
                    Fields::Unit => 0,
                    Fields::Named(f) => f.named.len(),
                    Fields::Unnamed(f) => f.unnamed.len(),
                }
            }
            /// Returns `true` if there are zero fields.
            pub fn is_empty(&self) -> bool
            {
                match self {
                    Fields::Unit => true,
                    Fields::Named(f) => f.named.is_empty(),
                    Fields::Unnamed(f) => f.unnamed.is_empty(),
                }
            }

            return_impl_trait!
            {
                /// Get an iterator over the fields of a struct or variant as [`Member`]s.
                pub fn members(&self) -> impl Iterator<Item = Member> + Clone + '_ [Members] {
                    Members {
                        fields: self.iter(),
                        index: 0,
                    }
                }
            }
        }

        impl IntoIterator for Fields {
            type Item = Field;
            type IntoIter = punctuated::IntoIter<Field>;

            fn into_iter(self) -> Self::IntoIter {
                match self {
                    Fields::Unit => Punctuated::<Field, ()>::new().into_iter(),
                    Fields::Named(f) => f.named.into_iter(),
                    Fields::Unnamed(f) => f.unnamed.into_iter(),
                }
            }
        }

        impl<'a> IntoIterator for &'a Fields {
            type Item = &'a Field;
            type IntoIter = punctuated::Iter<'a, Field>;

            fn into_iter(self) -> Self::IntoIter
            {
                self.iter()
            }
        }

        impl<'a> IntoIterator for &'a mut Fields {
            type Item = &'a mut Field;
            type IntoIter = punctuated::IterMut<'a, Field>;

            fn into_iter(self) -> Self::IntoIter
            {
                self.iter_mut()
            }
        }

        ast_struct! {
            /// A field of a struct or enum variant.
            pub struct Field {
                pub attrs: Vec<Attribute>,

                pub vis: Visibility,

                pub mutability: FieldMutability,
                /// Name of the field, if any.
                ///
                /// Fields of tuple structs have no names.
                pub ident: Option<Ident>,

                pub colon_token: Option<Token![:]>,

                pub ty: Type,
            }
        }

        pub struct Members<'a> {
            fields: punctuated::Iter<'a, Field>,
            index: u32,
        }

        impl<'a> Iterator for Members<'a> {
            type Item = Member;

            fn next(&mut self) -> Option<Self::Item>
            {
                let field = self.fields.next()?;
                let member = match &field.ident {
                    Some(ident) => Member::Named(ident.clone()),
                    None => {
                        #[cfg(all(feature = "parsing", feature = "printing"))]
                        let span = ::syntax::spanned::Spanned::span(&field.ty);
                        #[cfg(not(all(feature = "parsing", feature = "printing")))]
                        let span = process::macros::Span::call_site();
                        Member::Unnamed(Index {
                            index: self.index,
                            span,
                        })
                    }
                };
                self.index += 1;
                Some(member)
            }
        }

        impl<'a> Clone for Members<'a> {
            fn clone(&self) -> Self {
                Members {
                    fields: self.fields.clone(),
                    index: self.index,
                }
            }
        }

        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    attr::Attribute,
                    data::{Field, Fields, FieldsNamed, FieldsUnnamed, Variant},
                    error::Result,
                    expr::Expr,
                    ext::IdentExt as _,
                    ident::Ident,
                    parse::{Parse, ParseStream},
                    restriction::{FieldMutability, Visibility},
                    token,
                    ty::Type,
                    verbatim,
                },
                *,
            };
            
            impl Parse for Variant
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let _visibility: Visibility = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let fields = if input.peek(token::Brace) {
                        Fields::Named(input.parse()?)
                    } else if input.peek(token::Paren) {
                        Fields::Unnamed(input.parse()?)
                    } else {
                        Fields::Unit
                    };
                    let discriminant = if input.peek(Token![=]) {
                        let eq_token: Token![=] = input.parse()?;
                                        let discriminant: Expr = input.parse()?;
                        Some((eq_token, discriminant))
                    } else {
                        None
                    };
                    Ok(Variant {
                        attrs,
                        ident,
                        fields,
                        discriminant,
                    })
                }
            }

            impl Parse for FieldsNamed
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(FieldsNamed {
                        brace_token: braced!(content in input),
                        named: content.parse_terminated(Field::parse_named, Token![,])?,
                    })
                }
            }

            impl Parse for FieldsUnnamed
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(FieldsUnnamed {
                        paren_token: parenthesized!(content in input),
                        unnamed: content.parse_terminated(Field::parse_unnamed, Token![,])?,
                    })
                }
            }

            impl Field {
                /// Parses a named (braced struct) field.
                    pub fn parse_named(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;

                    let unnamed_field = cfg!(feature = "full") && input.peek(Token![_]);
                    let ident = if unnamed_field {
                        input.call(Ident::parse_any)
                    } else {
                        input.parse()
                    }?;

                    let colon_token: Token![:] = input.parse()?;

                    let ty: Type = if unnamed_field
                        && (input.peek(Token![struct])
                            || input.peek(Token![union]) && input.peek2(token::Brace))
                    {
                        let begin = input.fork();
                        input.call(Ident::parse_any)?;
                        input.parse::<FieldsNamed>()?;
                        Type::Verbatim(verbatim::between(&begin, input))
                    } else {
                        input.parse()?
                    };

                    Ok(Field {
                        attrs,
                        vis,
                        mutability: FieldMutability::None,
                        ident: Some(ident),
                        colon_token: Some(colon_token),
                        ty,
                    })
                }

                /// Parses an unnamed (tuple struct) field.
                    pub fn parse_unnamed(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (Field {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        mutability: FieldMutability::None,
                        ident: None,
                        colon_token: None,
                        ty: input.parse()?,
                    })
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    data::{Field, FieldsNamed, FieldsUnnamed, Variant},
                    print::TokensOrDefault,
                },
                *,
            };

            impl ToTokens for Variant {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(&self.attrs);
                    self.ident.to_tokens(tokens);
                    self.fields.to_tokens(tokens);
                    if let Some((eq_token, disc)) = &self.discriminant {
                        eq_token.to_tokens(tokens);
                        disc.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for FieldsNamed {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.brace_token.surround(tokens, |tokens| {
                        self.named.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for FieldsUnnamed {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.paren_token.surround(tokens, |tokens| {
                        self.unnamed.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for Field {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(&self.attrs);
                    self.vis.to_tokens(tokens);
                    if let Some(ident) = &self.ident {
                        ident.to_tokens(tokens);
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                    }
                    self.ty.to_tokens(tokens);
                }
            }
        }
    } pub use self::data::{Field, Fields, FieldsNamed, FieldsUnnamed, Variant};
    
    pub mod derive
    {
        use ::
        {
            syntax::
            {
                attr::Attribute,
                data::{ Fields, FieldsNamed, Variant },
                generics::Generics,
                ident::Ident,
                punctuated::Punctuated,
                restriction::Visibility,
                token,
            },
            *,
        };
        /*
        */
        ast_struct!
        {
            /// Data structure sent to a `proc_macro_derive` macro.
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub struct DeriveInput {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub ident: Ident,
                pub generics: Generics,
                pub data: Data,
            }
        }

        ast_enum! 
        {
            /// The storage of a struct, enum or union data structure.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub enum Data {
                Struct(DataStruct),
                Enum(DataEnum),
                Union(DataUnion),
            }
        }

        ast_struct! 
        {
            /// A struct input to a `proc_macro_derive` macro.
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub struct DataStruct {
                pub struct_token: Token![struct],
                pub fields: Fields,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// An enum input to a `proc_macro_derive` macro.
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub struct DataEnum {
                pub enum_token: Token![enum],
                pub brace_token: token::Brace,
                pub variants: Punctuated<Variant, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// An untagged union input to a `proc_macro_derive` macro.
            #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
            pub struct DataUnion {
                pub union_token: Token![union],
                pub fields: FieldsNamed,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    attr::Attribute,
                    data::{Fields, FieldsNamed, Variant},
                    derive::{Data, DataEnum, DataStruct, DataUnion, DeriveInput},
                    error::Result,
                    generics::{Generics, WhereClause},
                    ident::Ident,
                    parse::{Parse, ParseStream},
                    punctuated::Punctuated,
                    restriction::Visibility,
                    token,
                },
                *,
            };
            
            impl Parse for DeriveInput
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis = input.parse::<Visibility>()?;

                    let lookahead = input.lookahead1();
                    if lookahead.peek(Token![struct]) {
                        let struct_token = input.parse::<Token![struct]>()?;
                        let ident = input.parse::<Ident>()?;
                        let generics = input.parse::<Generics>()?;
                        let (where_clause, fields, semi) = data_struct(input)?;
                        Ok(DeriveInput {
                            attrs,
                            vis,
                            ident,
                            generics: Generics {
                                where_clause,
                                ..generics
                            },
                            data: Data::Struct(DataStruct {
                                struct_token,
                                fields,
                                semi_token: semi,
                            }),
                        })
                    } else if lookahead.peek(Token![enum]) {
                        let enum_token = input.parse::<Token![enum]>()?;
                        let ident = input.parse::<Ident>()?;
                        let generics = input.parse::<Generics>()?;
                        let (where_clause, brace, variants) = data_enum(input)?;
                        Ok(DeriveInput {
                            attrs,
                            vis,
                            ident,
                            generics: Generics {
                                where_clause,
                                ..generics
                            },
                            data: Data::Enum(DataEnum {
                                enum_token,
                                brace_token: brace,
                                variants,
                            }),
                        })
                    } else if lookahead.peek(Token![union]) {
                        let union_token = input.parse::<Token![union]>()?;
                        let ident = input.parse::<Ident>()?;
                        let generics = input.parse::<Generics>()?;
                        let (where_clause, fields) = data_union(input)?;
                        Ok(DeriveInput {
                            attrs,
                            vis,
                            ident,
                            generics: Generics {
                                where_clause,
                                ..generics
                            },
                            data: Data::Union(DataUnion {
                                union_token,
                                fields,
                            }),
                        })
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            pub fn data_struct(
                input: ParseStream,
            ) -> Result<(Option<WhereClause>, Fields, Option<Token![;]>)>
            {
                let mut lookahead = input.lookahead1();
                let mut where_clause = None;
                if lookahead.peek(Token![where]) {
                    where_clause = Some(input.parse()?);
                    lookahead = input.lookahead1();
                }

                if where_clause.is_none() && lookahead.peek(token::Paren) {
                    let fields = input.parse()?;

                    lookahead = input.lookahead1();
                    if lookahead.peek(Token![where]) {
                        where_clause = Some(input.parse()?);
                        lookahead = input.lookahead1();
                    }

                    if lookahead.peek(Token![;]) {
                        let semi = input.parse()?;
                        Ok((where_clause, Fields::Unnamed(fields), Some(semi)))
                    } else {
                        Err(lookahead.error())
                    }
                } else if lookahead.peek(token::Brace) {
                    let fields = input.parse()?;
                    Ok((where_clause, Fields::Named(fields), None))
                } else if lookahead.peek(Token![;]) {
                    let semi = input.parse()?;
                    Ok((where_clause, Fields::Unit, Some(semi)))
                } else {
                    Err(lookahead.error())
                }
            }

            pub fn data_enum(
                input: ParseStream,
            ) -> Result<(
                Option<WhereClause>,
                token::Brace,
                Punctuated<Variant, Token![,]>,
            )>
            {
                let where_clause = input.parse()?;

                let content;
                let brace = braced!(content in input);
                let variants = content.parse_terminated(Variant::parse, Token![,])?;

                Ok((where_clause, brace, variants))
            }

            pub fn data_union(input: ParseStream) -> Result<(Option<WhereClause>, FieldsNamed)>
            {
                let where_clause = input.parse()?;
                let fields = input.parse()?;
                Ok((where_clause, fields))
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::ToTokens,
                syntax::
                {
                    attr::FilterAttrs,
                    data::Fields,
                    derive::{Data, DeriveInput},
                    print::TokensOrDefault,
                },
                *,
            };
            
            impl ToTokens for DeriveInput {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    for attr in self.attrs.outer() {
                        attr.to_tokens(tokens);
                    }
                    self.vis.to_tokens(tokens);
                    match &self.data {
                        Data::Struct(d) => d.struct_token.to_tokens(tokens),
                        Data::Enum(d) => d.enum_token.to_tokens(tokens),
                        Data::Union(d) => d.union_token.to_tokens(tokens),
                    }
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    match &self.data {
                        Data::Struct(data) => match &data.fields {
                            Fields::Named(fields) => {
                                self.generics.where_clause.to_tokens(tokens);
                                fields.to_tokens(tokens);
                            }
                            Fields::Unnamed(fields) => {
                                fields.to_tokens(tokens);
                                self.generics.where_clause.to_tokens(tokens);
                                TokensOrDefault(&data.semi_token).to_tokens(tokens);
                            }
                            Fields::Unit => {
                                self.generics.where_clause.to_tokens(tokens);
                                TokensOrDefault(&data.semi_token).to_tokens(tokens);
                            }
                        },
                        Data::Enum(data) => {
                            self.generics.where_clause.to_tokens(tokens);
                            data.brace_token.surround(tokens, |tokens| {
                                data.variants.to_tokens(tokens);
                            });
                        }
                        Data::Union(data) => {
                            self.generics.where_clause.to_tokens(tokens);
                            data.fields.to_tokens(tokens);
                        }
                    }
                }
            }
        }
    } pub use self::derive::{Data, DataEnum, DataStruct, DataUnion, DeriveInput};

    pub mod drops
    {
        use ::
        {
            mem::{ ManuallyDrop },
            ops::{ Deref, DerefMut },
            *,
        };
        /*
        */
        #[repr(transparent)]
        pub struct NoDrop<T: ?Sized>(ManuallyDrop<T>);

        impl<T> NoDrop<T>
        {
            pub fn new(value: T) -> Self
            where
                T: TrivialDrop,
            {
                NoDrop(ManuallyDrop::new(value))
            }
        }

        impl<T: ?Sized> Deref for NoDrop<T> {
            type Target = T;
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }

        impl<T: ?Sized> DerefMut for NoDrop<T> {
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }

        pub trait TrivialDrop {}

        impl<T> TrivialDrop for iter::Empty<T> {}
        impl<T> TrivialDrop for slice::Iter<'_, T> {}
        impl<T> TrivialDrop for slice::IterMut<'_, T> {}
        impl<T> TrivialDrop for option::IntoIter<&T> {}
        impl<T> TrivialDrop for option::IntoIter<&mut T> {}
    }

    pub mod error
    {
        use ::
        {
            fmt::{ self, Debug, Display },
            iter::{ FromIterator },
            process::macros::
            {
                Delimiter, Group, Ident, LexError, Literal, Punct, Spacing, Span, TokenStream, TokenTree
            },
            quote::{ ToTokens },
            syntax::
            {
                buffer::Cursor,
                thread::ThreadBound,
            },
            *,
        };
        /*
        */
        /// The result of a Syn parser.
        pub type Result<T> = ::result::Result<T, Error>;

        /// Error returned when a Syn parser cannot parse the input tokens.
        pub struct Error {
            messages: Vec<ErrorMessage>,
        }

        struct ErrorMessage
        {
            span: ThreadBound<SpanRange>,
            message: String,
        }

       
       
       
        struct SpanRange {
            start: Span,
            end: Span,
        }
        

        impl Error {
            /// Usually the [`ParseStream::error`] method will be used instead, which
            /// automatically uses the correct span from the current position of the
            /// parse stream.
            pub fn new<T: Display>(span: Span, message: T) -> Self {
                return new(span, message.to_string());

                fn new(span: Span, message: String) -> Error {
                    Error {
                        messages: vec![ErrorMessage {
                            span: ThreadBound::new(SpanRange {
                                start: span,
                                end: span,
                            }),
                            message,
                        }],
                    }
                }
            }
            /// Creates an error with the specified message spanning the given syntax
            /// tree node.
            pub fn new_spanned<T: ToTokens, U: Display>(tokens: T, message: U) -> Self {
                return new_spanned(tokens.into_token_stream(), message.to_string());

                fn new_spanned(tokens: TokenStream, message: String) -> Error {
                    let mut iter = tokens.into_iter();
                    let start = iter.next().map_or_else(Span::call_site, |t| t.span());
                    let end = iter.last().map_or(start, |t| t.span());
                    Error {
                        messages: vec![ErrorMessage {
                            span: ThreadBound::new(SpanRange { start, end }),
                            message,
                        }],
                    }
                }
            }
            /// The source location of the error.
            pub fn span(&self) -> Span {
                let SpanRange { start, end } = match self.messages[0].span.get() {
                    Some(span) => *span,
                    None => return Span::call_site(),
                };
                start.join(end).unwrap_or(start)
            }
            /// Render the error as an invocation of [`compile_error!`].
            pub fn to_compile_error(&self) -> TokenStream
            {
                self.messages
                    .iter()
                    .map(ErrorMessage::to_compile_error)
                    .collect()
            }
            /// Render the error as an invocation of [`compile_error!`].
            pub fn into_compile_error(self) -> TokenStream
            {
                self.to_compile_error()
            }
            /// Add another error message to self such that when `to_compile_error()` is
            /// called, both errors will be emitted together.
            pub fn combine(&mut self, another: Error)
            {
                self.messages.extend(another.messages);
            }
        }

        impl ErrorMessage {
            fn to_compile_error(&self) -> TokenStream {
                let (start, end) = match self.span.get() {
                    Some(range) => (range.start, range.end),
                    None => (Span::call_site(), Span::call_site()),
                };

               
                TokenStream::from_iter([
                    TokenTree::Punct({
                        let mut punct = Punct::new(':', Spacing::Joint);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Punct({
                        let mut punct = Punct::new(':', Spacing::Alone);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Ident(Ident::new("core", start)),
                    TokenTree::Punct({
                        let mut punct = Punct::new(':', Spacing::Joint);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Punct({
                        let mut punct = Punct::new(':', Spacing::Alone);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Ident(Ident::new("compile_error", start)),
                    TokenTree::Punct({
                        let mut punct = Punct::new('!', Spacing::Alone);
                        punct.set_span(start);
                        punct
                    }),
                    TokenTree::Group({
                        let mut group = Group::new(Delimiter::Brace, {
                            TokenStream::from_iter([TokenTree::Literal({
                                let mut string = Literal::string(&self.message);
                                string.set_span(end);
                                string
                            })])
                        });
                        group.set_span(end);
                        group
                    }),
                ])
            }
        }

         
            pub fn new_at<T: Display>(scope: Span, cursor: Cursor, message: T) -> Error {
            if cursor.eof() {
                Error::new(scope, format!("unexpected end of input, {}", message))
            } else {
                let span = ::syntax::buffer::open_span_of_group(cursor);
                Error::new(span, message)
            }
        }
        
        pub fn new2<T: Display>(start: Span, end: Span, message: T) -> Error
        {
            return new2(start, end, message.to_string());

            fn new2(start: Span, end: Span, message: String) -> Error
            {
                Error {
                    messages: vec![ErrorMessage {
                        span: ThreadBound::new(SpanRange { start, end }),
                        message,
                    }],
                }
            }
        }

        impl Debug for Error {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                if self.messages.len() == 1 {
                    formatter
                        .debug_tuple("Error")
                        .field(&self.messages[0])
                        .finish()
                } else {
                    formatter
                        .debug_tuple("Error")
                        .field(&self.messages)
                        .finish()
                }
            }
        }

        impl Debug for ErrorMessage {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.message, formatter)
            }
        }

        impl Display for Error {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_str(&self.messages[0].message)
            }
        }

        impl Clone for Error {
            fn clone(&self) -> Self {
                Error {
                    messages: self.messages.clone(),
                }
            }
        }

        impl Clone for ErrorMessage {
            fn clone(&self) -> Self {
                ErrorMessage {
                    span: self.span,
                    message: self.message.clone(),
                }
            }
        }

        impl Clone for SpanRange {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl Copy for SpanRange {}

        impl std::error::Error for Error {}

        impl From<LexError> for Error {
            fn from(err: LexError) -> Self {
                Error::new(err.span(), err)
            }
        }

        impl IntoIterator for Error {
            type Item = Error;
            type IntoIter = IntoIter;

            fn into_iter(self) -> Self::IntoIter {
                IntoIter {
                    messages: self.messages.into_iter(),
                }
            }
        }

        pub struct IntoIter {
            messages: vec::IntoIter<ErrorMessage>,
        }

        impl Iterator for IntoIter {
            type Item = Error;

            fn next(&mut self) -> Option<Self::Item> {
                Some(Error {
                    messages: vec![self.messages.next()?],
                })
            }
        }

        impl<'a> IntoIterator for &'a Error {
            type Item = Error;
            type IntoIter = Iter<'a>;

            fn into_iter(self) -> Self::IntoIter {
                Iter {
                    messages: self.messages.iter(),
                }
            }
        }

        pub struct Iter<'a> {
            messages: slice::Iter<'a, ErrorMessage>,
        }

        impl<'a> Iterator for Iter<'a> {
            type Item = Error;

            fn next(&mut self) -> Option<Self::Item> {
                Some(Error {
                    messages: vec![self.messages.next()?.clone()],
                })
            }
        }

        impl Extend<Error> for Error {
            fn extend<T: IntoIterator<Item = Error>>(&mut self, iter: T) {
                for err in iter {
                    self.combine(err);
                }
            }
        }
    } pub use self::error::{Error, Result};
    
    pub mod expr
    {
        use ::
        {
            fmt::{ self, Display },
            hash::{ Hash, Hasher },
            process::macros::{ Span, TokenStream },
            quote::{ IdentFragment },
            syntax::
            {
                attr::Attribute,
                error::Result,
                ext::IdentExt as _,
                generics::BoundLifetimes,
                ident::Ident,
                lifetime::Lifetime,
                lit::Lit,
                mac::Macro,
                op::{BinOp, UnOp},
                parse::ParseStream,
                pat::Pat,
                path::{AngleBracketedGenericArguments, Path, QSelf},
                punctuated::Punctuated,
                stmt::Block,
                token,
                ty::ReturnType,
                ty::Type,
            },
            *,
        };
        /*        
        */
        ast_enum_of_structs!
        {
            /// A Rust expression.
            /// are designed to be traversed using the following rebinding idiom.
            /// # };
            /// match expr {
            ///     Expr::MethodCall(expr) => {
            ///         /* ... */
            ///     }
            ///     Expr::Cast(expr) => {
            ///         /* ... */
            ///     }
            ///     Expr::If(expr) => {
            ///         /* ... */
            ///     }
            ///
            ///     /* ... */
            ///     # _ => {}
            /// # }
            /// # }
            /// ```
            ///
            /// We begin with a variable `expr` of type `Expr` that has no fields
            /// (because it is an enum), and by matching on it and rebinding a variable
            /// with the same name `expr` we effectively imbue our variable with all of
            /// the data fields provided by the variant that it turned out to be. So for
            /// example above if we ended up in the `MethodCall` case then we get to use
            /// `expr.receiver`, `expr.args` etc; if we ended up in the `If` case we get
            /// to use `expr.cond`, `expr.then_branch`, `expr.else_branch`.
            /// #
            /// # fn example(expr: Expr) {
            ///
            /// match expr {
            ///     Expr::MethodCall(ExprMethodCall { method, args, .. }) => {
            /// # }
            /// # _ => {}
            /// # }
            /// # }
            /// ```
            ///
            /// In general, the name to which a syntax tree enum variant is bound should
            /// be a suitable name for the complete syntax tree enum type.
            /// if let Expr::Tuple(base) = *discriminant.base {
            /// # }
            /// # }
            /// ```
            ///
            /// A sign that you may not be choosing the right variable names is if you
            /// see names getting repeated in your code, like accessing
            /// `receiver.receiver` or `pat.pat` or `cond.cond`.
            #[non_exhaustive]
            pub enum Expr {
                /// A slice literal expression: `[a, b, c, d]`.
                Array(ExprArray),
                /// An assignment expression: `a = compute()`.
                Assign(ExprAssign),
                /// An async block: `async { ... }`.
                Async(ExprAsync),
                /// An await expression: `fut.await`.
                Await(ExprAwait),
                /// A binary operation: `a + b`, `a += b`.
                Binary(ExprBinary),
                /// A blocked scope: `{ ... }`.
                Block(ExprBlock),
                /// A `break`, with an optional label to break and an optional
                /// expression.
                Break(ExprBreak),
                /// A function call expression: `invoke(a, b)`.
                Call(ExprCall),
                /// A cast expression: `foo as f64`.
                Cast(ExprCast),
                /// A closure expression: `|a, b| a + b`.
                Closure(ExprClosure),
                /// A const block: `const { ... }`.
                Const(ExprConst),
                /// A `continue`, with an optional label.
                Continue(ExprContinue),
                /// Access of a named struct field (`obj.k`) or unnamed tuple struct
                /// field (`obj.0`).
                Field(ExprField),
                /// A for loop: `for pat in expr { ... }`.
                ForLoop(ExprForLoop),
                /// An expression contained within invisible delimiters.
                ///
                /// This variant is important for faithfully representing the precedence
                /// of expressions and is related to `None`-delimited spans in a
                /// `TokenStream`.
                Group(ExprGroup),
                /// An `if` expression with an optional `else` block: `if expr { ... }
                /// else { ... }`.
                ///
                /// The `else` branch expression may only be an `If` or `Block`
                /// expression, not any of the other types of expression.
                If(ExprIf),
                /// A square bracketed indexing expression: `vector[2]`.
                Index(ExprIndex),
                /// The inferred value of a const generic argument, denoted `_`.
                Infer(ExprInfer),
                /// A `let` guard: `let Some(x) = opt`.
                Let(ExprLet),
                /// A literal in place of an expression: `1`, `"foo"`.
                Lit(ExprLit),
                /// Conditionless loop: `loop { ... }`.
                Loop(ExprLoop),
                /// A macro invocation expression: `format!("{}", q)`.
                Macro(ExprMacro),
                /// A `match` expression: `match n { Some(n) => {}, None => {} }`.
                Match(ExprMatch),
                /// A method call expression: `x.foo::<T>(a, b)`.
                MethodCall(ExprMethodCall),
                /// A parenthesized expression: `(a + b)`.
                Paren(ExprParen),
                /// A path like `std::mem::replace` possibly containing generic
                /// parameters and a qualified self-type.
                ///
                /// A plain identifier like `x` is a path of length 1.
                Path(ExprPath),
                /// A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.
                Range(ExprRange),
                /// Address-of operation: `&raw const place` or `&raw mut place`.
                RawAddr(ExprRawAddr),
                /// A referencing operation: `&a` or `&mut a`.
                Reference(ExprReference),
                /// An array literal constructed from one repeated element: `[0u8; N]`.
                Repeat(ExprRepeat),
                /// A `return`, with an optional value to be returned.
                Return(ExprReturn),
                /// A struct literal expression: `Point { x: 1, y: 1 }`.
                ///
                /// The `rest` provides the value of the remaining fields as in `S { a:
                /// 1, b: 1, ..rest }`.
                Struct(ExprStruct),
                /// A try-expression: `expr?`.
                Try(ExprTry),
                /// A try block: `try { ... }`.
                TryBlock(ExprTryBlock),
                /// A tuple expression: `(a, b, c, d)`.
                Tuple(ExprTuple),
                /// A unary operation: `!x`, `*x`.
                Unary(ExprUnary),
                /// An unsafe block: `unsafe { ... }`.
                Unsafe(ExprUnsafe),
                /// Tokens in expression position not interpreted by Syn.
                Verbatim(TokenStream),
                /// A while loop: `while expr { ... }`.
                While(ExprWhile),
                /// A yield expression: `yield expr`.
                Yield(ExprYield),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// A slice literal expression: `[a, b, c, d]`.
            pub struct ExprArray #full {
                pub attrs: Vec<Attribute>,
                pub bracket_token: token::Bracket,
                pub elems: Punctuated<Expr, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// An assignment expression: `a = compute()`.
            pub struct ExprAssign #full {
                pub attrs: Vec<Attribute>,
                pub left: Box<Expr>,
                pub eq_token: Token![=],
                pub right: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// An async block: `async { ... }`.
            pub struct ExprAsync #full {
                pub attrs: Vec<Attribute>,
                pub async_token: Token![async],
                pub capture: Option<Token![move]>,
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// An await expression: `fut.await`.
            pub struct ExprAwait #full {
                pub attrs: Vec<Attribute>,
                pub base: Box<Expr>,
                pub dot_token: Token![.],
                pub await_token: Token![await],
            }
        }

        ast_struct! 
        {
            /// A binary operation: `a + b`, `a += b`.
            pub struct ExprBinary {
                pub attrs: Vec<Attribute>,
                pub left: Box<Expr>,
                pub op: BinOp,
                pub right: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A blocked scope: `{ ... }`.
            pub struct ExprBlock #full {
                pub attrs: Vec<Attribute>,
                pub label: Option<Label>,
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// A `break`, with an optional label to break and an optional
            /// expression.
            pub struct ExprBreak #full {
                pub attrs: Vec<Attribute>,
                pub break_token: Token![break],
                pub label: Option<Lifetime>,
                pub expr: Option<Box<Expr>>,
            }
        }

        ast_struct! 
        {
            /// A function call expression: `invoke(a, b)`.
            pub struct ExprCall {
                pub attrs: Vec<Attribute>,
                pub func: Box<Expr>,
                pub paren_token: token::Paren,
                pub args: Punctuated<Expr, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A cast expression: `foo as f64`.
            pub struct ExprCast {
                pub attrs: Vec<Attribute>,
                pub expr: Box<Expr>,
                pub as_token: Token![as],
                pub ty: Box<Type>,
            }
        }

        ast_struct! 
        {
            /// A closure expression: `|a, b| a + b`.
            pub struct ExprClosure #full {
                pub attrs: Vec<Attribute>,
                pub lifetimes: Option<BoundLifetimes>,
                pub constness: Option<Token![const]>,
                pub movability: Option<Token![static]>,
                pub asyncness: Option<Token![async]>,
                pub capture: Option<Token![move]>,
                pub or1_token: Token![|],
                pub inputs: Punctuated<Pat, Token![,]>,
                pub or2_token: Token![|],
                pub output: ReturnType,
                pub body: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A const block: `const { ... }`.
            pub struct ExprConst #full {
                pub attrs: Vec<Attribute>,
                pub const_token: Token![const],
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// A `continue`, with an optional label.
            pub struct ExprContinue #full {
                pub attrs: Vec<Attribute>,
                pub continue_token: Token![continue],
                pub label: Option<Lifetime>,
            }
        }

        ast_struct! 
        {
            /// Access of a named struct field (`obj.k`) or unnamed tuple struct
            /// field (`obj.0`).
            pub struct ExprField {
                pub attrs: Vec<Attribute>,
                pub base: Box<Expr>,
                pub dot_token: Token![.],
                pub member: Member,
            }
        }

        ast_struct! 
        {
            /// A for loop: `for pat in expr { ... }`.
            pub struct ExprForLoop #full {
                pub attrs: Vec<Attribute>,
                pub label: Option<Label>,
                pub for_token: Token![for],
                pub pat: Box<Pat>,
                pub in_token: Token![in],
                pub expr: Box<Expr>,
                pub body: Block,
            }
        }

        ast_struct! 
        {
            /// An expression contained within invisible delimiters.
            /// `TokenStream`.
            pub struct ExprGroup {
                pub attrs: Vec<Attribute>,
                pub group_token: token::Group,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// An `if` expression with an optional `else` block: `if expr { ... }
            /// else { ... }`.
            pub struct ExprIf #full {
                pub attrs: Vec<Attribute>,
                pub if_token: Token![if],
                pub cond: Box<Expr>,
                pub then_branch: Block,
                pub else_branch: Option<(Token![else], Box<Expr>)>,
            }
        }

        ast_struct! 
        {
            /// A square bracketed indexing expression: `vector[2]`.
            pub struct ExprIndex {
                pub attrs: Vec<Attribute>,
                pub expr: Box<Expr>,
                pub bracket_token: token::Bracket,
                pub index: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// The inferred value of a const generic argument, denoted `_`.
            pub struct ExprInfer #full {
                pub attrs: Vec<Attribute>,
                pub underscore_token: Token![_],
            }
        }

        ast_struct! 
        {
            /// A `let` guard: `let Some(x) = opt`.
            pub struct ExprLet #full {
                pub attrs: Vec<Attribute>,
                pub let_token: Token![let],
                pub pat: Box<Pat>,
                pub eq_token: Token![=],
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A literal in place of an expression: `1`, `"foo"`.
            pub struct ExprLit {
                pub attrs: Vec<Attribute>,
                pub lit: Lit,
            }
        }

        ast_struct! 
        {
            /// Conditionless loop: `loop { ... }`.
            pub struct ExprLoop #full {
                pub attrs: Vec<Attribute>,
                pub label: Option<Label>,
                pub loop_token: Token![loop],
                pub body: Block,
            }
        }

        ast_struct! 
        {
            /// A macro invocation expression: `format!("{}", q)`.
            pub struct ExprMacro {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
            }
        }

        ast_struct! 
        {
            /// A `match` expression: `match n { Some(n) => {}, None => {} }`.
            pub struct ExprMatch #full {
                pub attrs: Vec<Attribute>,
                pub match_token: Token![match],
                pub expr: Box<Expr>,
                pub brace_token: token::Brace,
                pub arms: Vec<Arm>,
            }
        }

        ast_struct! 
        {
            /// A method call expression: `x.foo::<T>(a, b)`.
            pub struct ExprMethodCall {
                pub attrs: Vec<Attribute>,
                pub receiver: Box<Expr>,
                pub dot_token: Token![.],
                pub method: Ident,
                pub turbofish: Option<AngleBracketedGenericArguments>,
                pub paren_token: token::Paren,
                pub args: Punctuated<Expr, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A parenthesized expression: `(a + b)`.
            pub struct ExprParen {
                pub attrs: Vec<Attribute>,
                pub paren_token: token::Paren,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A path like `std::mem::replace` possibly containing generic
            /// parameters and a qualified self-type.
            ///
            /// A plain identifier like `x` is a path of length 1.
            pub struct ExprPath {
                pub attrs: Vec<Attribute>,
                pub qself: Option<QSelf>,
                pub path: Path,
            }
        }

        ast_struct! 
        {
            /// A range expression: `1..2`, `1..`, `..2`, `1..=2`, `..=2`.
            pub struct ExprRange #full {
                pub attrs: Vec<Attribute>,
                pub start: Option<Box<Expr>>,
                pub limits: RangeLimits,
                pub end: Option<Box<Expr>>,
            }
        }

        ast_struct! 
        {
            /// Address-of operation: `&raw const place` or `&raw mut place`.
            pub struct ExprRawAddr #full {
                pub attrs: Vec<Attribute>,
                pub and_token: Token![&],
                pub raw: Token![raw],
                pub mutability: PointerMutability,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A referencing operation: `&a` or `&mut a`.
            pub struct ExprReference {
                pub attrs: Vec<Attribute>,
                pub and_token: Token![&],
                pub mutability: Option<Token![mut]>,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// An array literal constructed from one repeated element: `[0u8; N]`.
            pub struct ExprRepeat #full {
                pub attrs: Vec<Attribute>,
                pub bracket_token: token::Bracket,
                pub expr: Box<Expr>,
                pub semi_token: Token![;],
                pub len: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// A `return`, with an optional value to be returned.
            pub struct ExprReturn #full {
                pub attrs: Vec<Attribute>,
                pub return_token: Token![return],
                pub expr: Option<Box<Expr>>,
            }
        }

        ast_struct! {
            /// A struct literal expression: `Point { x: 1, y: 1 }`.
            pub struct ExprStruct {
                pub attrs: Vec<Attribute>,
                pub qself: Option<QSelf>,
                pub path: Path,
                pub brace_token: token::Brace,
                pub fields: Punctuated<FieldValue, Token![,]>,
                pub dot2_token: Option<Token![..]>,
                pub rest: Option<Box<Expr>>,
            }
        }

        ast_struct! 
        {
            /// A try-expression: `expr?`.
            pub struct ExprTry #full {
                pub attrs: Vec<Attribute>,
                pub expr: Box<Expr>,
                pub question_token: Token![?],
            }
        }

        ast_struct! 
        {
            /// A try block: `try { ... }`.
            pub struct ExprTryBlock #full {
                pub attrs: Vec<Attribute>,
                pub try_token: Token![try],
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// A tuple expression: `(a, b, c, d)`.
            pub struct ExprTuple {
                pub attrs: Vec<Attribute>,
                pub paren_token: token::Paren,
                pub elems: Punctuated<Expr, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A unary operation: `!x`, `*x`.
            pub struct ExprUnary {
                pub attrs: Vec<Attribute>,
                pub op: UnOp,
                pub expr: Box<Expr>,
            }
        }

        ast_struct! 
        {
            /// An unsafe block: `unsafe { ... }`.
            pub struct ExprUnsafe #full {
                pub attrs: Vec<Attribute>,
                pub unsafe_token: Token![unsafe],
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// A while loop: `while expr { ... }`.
            pub struct ExprWhile #full {
                pub attrs: Vec<Attribute>,
                pub label: Option<Label>,
                pub while_token: Token![while],
                pub cond: Box<Expr>,
                pub body: Block,
            }
        }

        ast_struct! 
        {
            /// A yield expression: `yield expr`.
            pub struct ExprYield #full {
                pub attrs: Vec<Attribute>,
                pub yield_token: Token![yield],
                pub expr: Option<Box<Expr>>,
            }
        }

        impl Expr 
        {
            /// An unspecified invalid expression.
            /// use std::mem;
            /// use syn::{parse_quote, Expr};
            ///
            /// fn unparenthesize(e: &mut Expr) {
            ///     while let Expr::Paren(paren) = e {
            ///         *e = mem::replace(&mut *paren.expr, Expr::PLACEHOLDER);
            ///     }
            /// }
            ///
            /// fn main() {
            ///     let mut e: Expr = parse_quote! { ((1 + 1)) };
            ///     unparenthesize(&mut e);
            ///     assert_eq!("1 + 1", e.to_token_stream().to_string());
            /// }
            /// ```
            pub const PLACEHOLDER: Self = Expr::Path(ExprPath {
                attrs: Vec::new(),
                qself: None,
                path: Path {
                    leading_colon: None,
                    segments: Punctuated::new(),
                },
            });

            /// An alternative to the primary `Expr::parse` parser (from the [`Parse`]
            /// trait) for ambiguous syntactic positions in which a trailing brace
            /// should not be taken as part of the expression.
            /// following code, the expression `S {}` is one expression. Presumably
            /// there is an empty struct `struct S {}` defined somewhere which it is
            /// instantiating.
            /// #     }
            /// # }
            /// let _ = *S {};
            ///
            ///
            /// ```
            ///
            /// We would want to parse the above using `Expr::parse` after the `=`
            /// token.
            /// if *S {} {}
            ///
            ///
            /// //
            ///
            ///
            ///
            ///
            ///
            ///
            /// ```
            ///
            /// For that reason we would want to parse if-conditions using
            /// `Expr::parse_without_eager_brace` after the `if` token. Same for similar
            /// syntactic positions such as the condition expr after a `while` token or
            /// the expr at the top of a `match`.
            /// behavior could work in most positions, and language designers just
            /// decide each case based on which is more likely to be what the programmer
            /// had in mind most of the time.
            ///
            ///
            /// //
            ///
            /// //
            ///
            ///
            ///
            /// ```
            ///
            /// Note the grammar ambiguity on trailing braces is distinct from
            /// precedence and is not captured by assigning a precedence level to the
            /// braced struct init expr in relation to other operators. This can be
            /// illustrated by `return 0..S {}` vs `match 0..S {}`. The former parses as
            /// `return (0..(S {}))` implying tighter precedence for struct init than
            /// `..`, while the latter parses as `match (0..S) {}` implying tighter
            /// precedence for `..` than struct init, a contradiction.
            #[cfg(all(feature = "full", feature = "parsing"))]
            #[cfg_attr(docsrs, doc(cfg(all(feature = "full", feature = "parsing"))))]
            pub fn parse_without_eager_brace(input: ParseStream) -> Result<Expr> {
                parsing::ambiguous_expr(input, parsing::AllowStruct(false))
            }
            /// An alternative to the primary `Expr::parse` parser (from the [`Parse`]
            /// trait) for syntactic positions in which expression boundaries are placed
            /// more eagerly than done by the typical expression grammar. This includes
            /// expressions at the head of a statement or in the right-hand side of a
            /// `match` arm.
            ///
            /// 1.
            ///   ```
            ///   # let result = ();
            ///   # let guard = false;
            ///   # let cond = true;
            ///   # let f = true;
            ///   # let g = f;
            ///   #
            ///   let _ = match result {
            ///       () if guard => if cond { f } else { g }
            ///       () => false,
            ///   };
            ///   ```
            ///
            /// 2.
            ///   ```
            ///   # let cond = true;
            ///   # let f = ();
            ///   # let g = f;
            ///   #
            ///   let _ = || {
            ///       if cond { f } else { g }
            ///       ()
            ///   };
            ///   ```
            ///
            /// 3.
            ///   ```
            ///   # let cond = true;
            ///   # let f = || ();
            ///   # let g = f;
            ///   #
            ///   let _ = [if cond { f } else { g } ()];
            ///   ```
            ///
            /// The same sequence of tokens `if cond { f } else { g } ()` appears in
            /// expression position 3 times. The first two syntactic positions use eager
            /// placement of expression boundaries, and parse as `Expr::If`, with the
            /// adjacent `()` becoming `Pat::Tuple` or `Expr::Tuple`. In contrast, the
            /// third case uses standard expression boundaries and parses as
            /// `Expr::Call`.
            ///
            /// [`parse_without_eager_brace`]: Self::parse_without_eager_brace
            #[cfg(all(feature = "full", feature = "parsing"))]
            #[cfg_attr(docsrs, doc(cfg(all(feature = "full", feature = "parsing"))))]
            pub fn parse_with_earlier_boundary_rule(input: ParseStream) -> Result<Expr> {
                parsing::parse_with_earlier_boundary_rule(input)
            }
            /// Returns whether the next token in the parse stream is one that might
            /// possibly form the beginning of an expr.
            /// operator because it cannot be a starting token for any Rust expression.
             
                pub fn peek(input: ParseStream) -> bool
        {
                input.peek(Ident::peek_any) && !input.peek(Token![as])
                    || input.peek(token::Paren)
                    || input.peek(token::Bracket)
                    || input.peek(token::Brace)
                    || input.peek(Lit)
                    || input.peek(Token![!]) && !input.peek(Token![!=])
                    || input.peek(Token![-]) && !input.peek(Token![-=]) && !input.peek(Token![->])
                    || input.peek(Token![*]) && !input.peek(Token![*=])
                    || input.peek(Token![|]) && !input.peek(Token![|=])
                    || input.peek(Token![&]) && !input.peek(Token![&=])
                    || input.peek(Token![..])
                    || input.peek(Token![<]) && !input.peek(Token![<=]) && !input.peek(Token![<<=])
                    || input.peek(Token![::])
                    || input.peek(Lifetime)
                    || input.peek(Token![#])
            }

            #[cfg(all(feature = "parsing", feature = "full"))]
            pub fn replace_attrs(&mut self, new: Vec<Attribute>) -> Vec<Attribute>
            {
                match self {
                    Expr::Array(ExprArray { attrs, .. })
                    | Expr::Assign(ExprAssign { attrs, .. })
                    | Expr::Async(ExprAsync { attrs, .. })
                    | Expr::Await(ExprAwait { attrs, .. })
                    | Expr::Binary(ExprBinary { attrs, .. })
                    | Expr::Block(ExprBlock { attrs, .. })
                    | Expr::Break(ExprBreak { attrs, .. })
                    | Expr::Call(ExprCall { attrs, .. })
                    | Expr::Cast(ExprCast { attrs, .. })
                    | Expr::Closure(ExprClosure { attrs, .. })
                    | Expr::Const(ExprConst { attrs, .. })
                    | Expr::Continue(ExprContinue { attrs, .. })
                    | Expr::Field(ExprField { attrs, .. })
                    | Expr::ForLoop(ExprForLoop { attrs, .. })
                    | Expr::Group(ExprGroup { attrs, .. })
                    | Expr::If(ExprIf { attrs, .. })
                    | Expr::Index(ExprIndex { attrs, .. })
                    | Expr::Infer(ExprInfer { attrs, .. })
                    | Expr::Let(ExprLet { attrs, .. })
                    | Expr::Lit(ExprLit { attrs, .. })
                    | Expr::Loop(ExprLoop { attrs, .. })
                    | Expr::Macro(ExprMacro { attrs, .. })
                    | Expr::Match(ExprMatch { attrs, .. })
                    | Expr::MethodCall(ExprMethodCall { attrs, .. })
                    | Expr::Paren(ExprParen { attrs, .. })
                    | Expr::Path(ExprPath { attrs, .. })
                    | Expr::Range(ExprRange { attrs, .. })
                    | Expr::RawAddr(ExprRawAddr { attrs, .. })
                    | Expr::Reference(ExprReference { attrs, .. })
                    | Expr::Repeat(ExprRepeat { attrs, .. })
                    | Expr::Return(ExprReturn { attrs, .. })
                    | Expr::Struct(ExprStruct { attrs, .. })
                    | Expr::Try(ExprTry { attrs, .. })
                    | Expr::TryBlock(ExprTryBlock { attrs, .. })
                    | Expr::Tuple(ExprTuple { attrs, .. })
                    | Expr::Unary(ExprUnary { attrs, .. })
                    | Expr::Unsafe(ExprUnsafe { attrs, .. })
                    | Expr::While(ExprWhile { attrs, .. })
                    | Expr::Yield(ExprYield { attrs, .. }) => mem::replace(attrs, new),
                    Expr::Verbatim(_) => Vec::new(),
                }
            }
        }

        ast_enum! 
        {
            /// A struct or tuple struct field accessed in a struct literal or field
            /// expression.
            pub enum Member {
                /// A named field like `self.x`.
                Named(Ident),
                /// An unnamed field like `self.0`.
                Unnamed(Index),
            }
        }

        impl From<Ident> for Member 
        {
            fn from(ident: Ident) -> Member {
                Member::Named(ident)
            }
        }

        impl From<Index> for Member 
        {
            fn from(index: Index) -> Member {
                Member::Unnamed(index)
            }
        }

        impl From<usize> for Member 
        {
            fn from(index: usize) -> Member {
                Member::Unnamed(Index::from(index))
            }
        }

        impl Eq for Member {

        }

        impl PartialEq for Member 
        {
            fn eq(&self, other: &Self) -> bool
        {
                match (self, other) {
                    (Member::Named(this), Member::Named(other)) => this == other,
                    (Member::Unnamed(this), Member::Unnamed(other)) => this == other,
                    _ => false,
                }
            }
        }

        impl Hash for Member 
        {
            fn hash<H: Hasher>(&self, state: &mut H) {
                match self {
                    Member::Named(m) => m.hash(state),
                    Member::Unnamed(m) => m.hash(state),
                }
            }
        }
        
        impl IdentFragment for Member

        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                match self {
                    Member::Named(m) => Display::fmt(m, formatter),
                    Member::Unnamed(m) => Display::fmt(&m.index, formatter),
                }
            }

            fn span(&self) -> Option<Span>
            {
                match self {
                    Member::Named(m) => Some(m.span()),
                    Member::Unnamed(m) => Some(m.span),
                }
            }
        }

        impl Member 
        {
            pub fn is_named(&self) -> bool
        {
                match self {
                    Member::Named(_) => true,
                    Member::Unnamed(_) => false,
                }
            }
        }

        ast_struct! 
        {
            /// The index of an unnamed tuple struct field.
            pub struct Index {
                pub index: u32,
                pub span: Span,
            }
        }

        impl From<usize> for Index 
        {
            fn from(index: usize) -> Index {
                assert!(index < u32::MAX as usize);
                Index {
                    index: index as u32,
                    span: Span::call_site(),
                }
            }
        }

        impl Eq for Index {

        }

        impl PartialEq for Index 
        {
            fn eq(&self, other: &Self) -> bool
            {
                self.index == other.index
            }
        }

        impl Hash for Index 
        {
            fn hash<H: Hasher>(&self, state: &mut H)
            {
                self.index.hash(state);
            }
        }
        
        impl IdentFragment for Index
        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.index, formatter)
            }

            fn span(&self) -> Option<Span> {
                Some(self.span)
            }
        }

        ast_struct! 
        {
            /// A field-value pair in a struct literal.
            pub struct FieldValue {
                pub attrs: Vec<Attribute>,
                pub member: Member,
                /// The colon in `Struct { x: x }`. If written in shorthand like
                /// `Struct { x }`, there is no colon.
                pub colon_token: Option<Token![:]>,

                pub expr: Expr,
            }
        }

        ast_struct! 
        {
            /// A lifetime labeling a `for`, `while`, or `loop`.
            pub struct Label {
                pub name: Lifetime,
                pub colon_token: Token![:],
            }
        }

        ast_struct! 
        {
            /// One arm of a `match` expression: `0..=10 => { return true; }`.
            /// #     let n = 0;
            /// match n {
            ///     0..=10 => {
            ///         return true;
            ///     }
            ///    
            ///     # _ => {}
            /// }
            /// #   false
            /// # }
            /// ```
            pub struct Arm {
                pub attrs: Vec<Attribute>,
                pub pat: Pat,
                pub guard: Option<(Token![if], Box<Expr>)>,
                pub fat_arrow_token: Token![=>],
                pub body: Box<Expr>,
                pub comma: Option<Token![,]>,
            }
        }

        ast_enum! 
        {
            /// Limit types of a range, inclusive or exclusive.
            pub enum RangeLimits {
                /// Inclusive at the beginning, exclusive at the end.
                HalfOpen(Token![..]),
                /// Inclusive at the beginning and end.
                Closed(Token![..=]),
            }
        }

        ast_enum!
        {
            /// Mutability of a raw pointer (`*const T`, `*mut T`), in which non-mutable
            /// isn't the implicit default.
            pub enum PointerMutability {
                Const(Token![const]),
                Mut(Token![mut]),
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::{Span, TokenStream},
                syntax::
                {
                    attr,
                    attr::Attribute,
                    classify,
                    error::{Error, Result},
                    expr::
                    {
                        Arm, ExprArray, ExprAssign, ExprAsync, ExprAwait, ExprBlock, ExprBreak, ExprClosure,
                        ExprConst, ExprContinue, ExprForLoop, ExprIf, ExprInfer, ExprLet, ExprLoop, ExprMatch,
                        ExprRange, ExprRawAddr, ExprRepeat, ExprReturn, ExprTry, ExprTryBlock, ExprUnsafe,
                        ExprWhile, ExprYield, Label, PointerMutability, RangeLimits, Expr, ExprBinary, ExprCall, 
                        ExprCast, ExprField, ExprGroup, ExprIndex, ExprLit, ExprMacro, ExprMethodCall, ExprParen, 
                        ExprPath, ExprReference, ExprStruct, ExprTuple, ExprUnary, FieldValue, Index, Member,
                    },
                    generics::{self, BoundLifetimes},
                    ident::Ident,
                    lifetime::Lifetime,
                    lit::{Lit, LitFloat, LitInt},
                    mac::{self, Macro},
                    op::BinOp,
                    parse::discouraged::Speculative as _,
                    parse::ParseBuffer,
                    parse::{Parse, ParseStream},
                    pat::{Pat, PatType},
                    path::{self, AngleBracketedGenericArguments, Path, QSelf},
                    precedence::Precedence,
                    punctuated::Punctuated,
                    stmt::Block,
                    token,
                    ty::{self, ReturnType, Type},
                    verbatim,
                },
                *,
            };
            
            pub struct AllowStruct(pub bool);

            impl Parse for Expr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    ambiguous_expr(
                        input,
                                        AllowStruct(true),
                    )
                }
            }

                pub fn parse_with_earlier_boundary_rule(input: ParseStream) -> Result<Expr>
            {
                let mut attrs = input.call(expr_attrs)?;
                let mut expr = if input.peek(token::Group) {
                    let allow_struct = AllowStruct(true);
                    let atom = expr_group(input, allow_struct)?;
                    if continue_parsing_early(&atom) {
                        trailer_helper(input, atom)?
                    } else {
                        atom
                    }
                } else if input.peek(Token![if]) {
                    Expr::If(input.parse()?)
                } else if input.peek(Token![while]) {
                    Expr::While(input.parse()?)
                } else if input.peek(Token![for])
                    && !generics::parsing::choose_generics_over_qpath_after_keyword(input)
                {
                    Expr::ForLoop(input.parse()?)
                } else if input.peek(Token![loop]) {
                    Expr::Loop(input.parse()?)
                } else if input.peek(Token![match]) {
                    Expr::Match(input.parse()?)
                } else if input.peek(Token![try]) && input.peek2(token::Brace) {
                    Expr::TryBlock(input.parse()?)
                } else if input.peek(Token![unsafe]) {
                    Expr::Unsafe(input.parse()?)
                } else if input.peek(Token![const]) && input.peek2(token::Brace) {
                    Expr::Const(input.parse()?)
                } else if input.peek(token::Brace) {
                    Expr::Block(input.parse()?)
                } else if input.peek(Lifetime) {
                    atom_labeled(input)?
                } else {
                    let allow_struct = AllowStruct(true);
                    unary_expr(input, allow_struct)?
                };

                if continue_parsing_early(&expr) {
                    attrs.extend(expr.replace_attrs(Vec::new()));
                    expr.replace_attrs(attrs);

                    let allow_struct = AllowStruct(true);
                    return parse_expr(input, expr, allow_struct, Precedence::MIN);
                }

                if input.peek(Token![.]) && !input.peek(Token![..]) || input.peek(Token![?]) {
                    expr = trailer_helper(input, expr)?;

                    attrs.extend(expr.replace_attrs(Vec::new()));
                    expr.replace_attrs(attrs);

                    let allow_struct = AllowStruct(true);
                    return parse_expr(input, expr, allow_struct, Precedence::MIN);
                }

                attrs.extend(expr.replace_attrs(Vec::new()));
                expr.replace_attrs(attrs);
                Ok(expr)
            }

                impl Copy for AllowStruct {}

                impl Clone for AllowStruct {
                fn clone(&self) -> Self {
                    *self
                }
            }

            fn parse_expr
            (
                input: ParseStream,
                mut lhs: Expr,
                allow_struct: AllowStruct,
                base: Precedence,
            ) -> Result<Expr> 
            {
                loop {
                    let ahead = input.fork();
                    if let Expr::Range(_) = lhs {
                       
                        break;
                    } else if let Ok(op) = ahead.parse::<BinOp>() {
                        let precedence = Precedence::of_binop(&op);
                        if precedence < base {
                            break;
                        }
                        if precedence == Precedence::Assign {
                            if let Expr::Range(_) = lhs {
                                break;
                            }
                        }
                        if precedence == Precedence::Compare {
                            if let Expr::Binary(lhs) = &lhs {
                                if Precedence::of_binop(&lhs.op) == Precedence::Compare {
                                    return Err(input.error("comparison operators cannot be chained"));
                                }
                            }
                        }
                        input.advance_to(&ahead);
                        let right = parse_binop_rhs(input, allow_struct, precedence)?;
                        lhs = Expr::Binary(ExprBinary {
                            attrs: Vec::new(),
                            left: Box::new(lhs),
                            op,
                            right,
                        });
                    } else if Precedence::Assign >= base
                        && input.peek(Token![=])
                        && !input.peek(Token![=>])
                        && match lhs {
                            Expr::Range(_) => false,
                            _ => true,
                        }
                    {
                        let eq_token: Token![=] = input.parse()?;
                        let right = parse_binop_rhs(input, allow_struct, Precedence::Assign)?;
                        lhs = Expr::Assign(ExprAssign {
                            attrs: Vec::new(),
                            left: Box::new(lhs),
                            eq_token,
                            right,
                        });
                    } else if Precedence::Range >= base && input.peek(Token![..]) {
                        let limits: RangeLimits = input.parse()?;
                        let end = parse_range_end(input, &limits, allow_struct)?;
                        lhs = Expr::Range(ExprRange {
                            attrs: Vec::new(),
                            start: Some(Box::new(lhs)),
                            limits,
                            end,
                        });
                    } else if Precedence::Cast >= base && input.peek(Token![as]) {
                        let as_token: Token![as] = input.parse()?;
                        let allow_plus = false;
                        let allow_group_generic = false;
                        let ty = ty::parsing::ambig_ty(input, allow_plus, allow_group_generic)?;
                        check_cast(input)?;
                        lhs = Expr::Cast(ExprCast {
                            attrs: Vec::new(),
                            expr: Box::new(lhs),
                            as_token,
                            ty: Box::new(ty),
                        });
                    } else {
                        break;
                    }
                }
                Ok(lhs)
            }
            
            fn parse_binop_rhs
            (
                input: ParseStream,
                #[cfg(feature = "full")] allow_struct: AllowStruct,
                precedence: Precedence,
            ) -> Result<Box<Expr>>
            {
                let mut rhs = unary_expr(
                    input,
                                allow_struct,
                )?;
                loop {
                    let next = peek_precedence(input);
                    if next > precedence || next == precedence && precedence == Precedence::Assign {
                        let cursor = input.cursor();
                        rhs = parse_expr(
                            input,
                            rhs,
                                                allow_struct,
                            next,
                        )?;
                        if cursor == input.cursor() {
                           
                           
                           
                           
                            break;
                        }
                    } else {
                        break;
                    }
                }
                Ok(Box::new(rhs))
            }

            fn peek_precedence(input: ParseStream) -> Precedence {
                if let Ok(op) = input.fork().parse() {
                    Precedence::of_binop(&op)
                } else if input.peek(Token![=]) && !input.peek(Token![=>]) {
                    Precedence::Assign
                } else if input.peek(Token![..]) {
                    Precedence::Range
                } else if input.peek(Token![as]) {
                    Precedence::Cast
                } else {
                    Precedence::MIN
                }
            }

            pub fn ambiguous_expr(
                input: ParseStream,
                #[cfg(feature = "full")] allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                let lhs = unary_expr(
                    input,
                                allow_struct,
                )?;
                parse_expr(
                    input,
                    lhs,
                                allow_struct,
                    Precedence::MIN,
                )
            }

                fn expr_attrs(input: ParseStream) -> Result<Vec<Attribute>>
            {
                let mut attrs = Vec::new();
                while !input.peek(token::Group) && input.peek(Token![#]) {
                    attrs.push(input.call(attr::parsing::single_parse_outer)?);
                }
                Ok(attrs)
            }

           
           
           
           
                fn unary_expr(input: ParseStream, allow_struct: AllowStruct) -> Result<Expr>
            {
                let begin = input.fork();
                let attrs = input.call(expr_attrs)?;
                if input.peek(token::Group) {
                    return trailer_expr(begin, attrs, input, allow_struct);
                }

                if input.peek(Token![&]) {
                    let and_token: Token![&] = input.parse()?;
                    let raw: Option<Token![raw]> = if input.peek(Token![raw])
                        && (input.peek2(Token![mut]) || input.peek2(Token![const]))
                    {
                        Some(input.parse()?)
                    } else {
                        None
                    };
                    let mutability: Option<Token![mut]> = input.parse()?;
                    let const_token: Option<Token![const]> = if raw.is_some() && mutability.is_none() {
                        Some(input.parse()?)
                    } else {
                        None
                    };
                    let expr = Box::new(unary_expr(input, allow_struct)?);
                    if let Some(raw) = raw {
                        Ok(Expr::RawAddr(ExprRawAddr {
                            attrs,
                            and_token,
                            raw,
                            mutability: match mutability {
                                Some(mut_token) => PointerMutability::Mut(mut_token),
                                None => PointerMutability::Const(const_token.unwrap()),
                            },
                            expr,
                        }))
                    } else {
                        Ok(Expr::Reference(ExprReference {
                            attrs,
                            and_token,
                            mutability,
                            expr,
                        }))
                    }
                } else if input.peek(Token![*]) || input.peek(Token![!]) || input.peek(Token![-]) {
                    expr_unary(input, attrs, allow_struct).map(Expr::Unary)
                } else {
                    trailer_expr(begin, attrs, input, allow_struct)
                }
            }
            
            fn trailer_expr
            (
                begin: ParseBuffer,
                mut attrs: Vec<Attribute>,
                input: ParseStream,
                allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                let atom = atom_expr(input, allow_struct)?;
                let mut e = trailer_helper(input, atom)?;

                if let Expr::Verbatim(tokens) = &mut e {
                    *tokens = verbatim::between(&begin, input);
                } else if !attrs.is_empty() {
                    if let Expr::Range(range) = e {
                        let spans: &[Span] = match &range.limits {
                            RangeLimits::HalfOpen(limits) => &limits.spans,
                            RangeLimits::Closed(limits) => &limits.spans,
                        };
                        return Err(::syntax::error::new2(
                            spans[0],
                            *spans.last().unwrap(),
                            "attributes are not allowed on range expressions starting with `..`",
                        ));
                    }
                    let inner_attrs = e.replace_attrs(Vec::new());
                    attrs.extend(inner_attrs);
                    e.replace_attrs(attrs);
                }

                Ok(e)
            }
            
            fn trailer_helper(input: ParseStream, mut e: Expr) -> Result<Expr>
            {
                loop {
                    if input.peek(token::Paren) {
                        let content;
                        e = Expr::Call(ExprCall {
                            attrs: Vec::new(),
                            func: Box::new(e),
                            paren_token: parenthesized!(content in input),
                            args: content.parse_terminated(Expr::parse, Token![,])?,
                        });
                    } else if input.peek(Token![.])
                        && !input.peek(Token![..])
                        && match e {
                            Expr::Range(_) => false,
                            _ => true,
                        }
                    {
                        let mut dot_token: Token![.] = input.parse()?;

                        let float_token: Option<LitFloat> = input.parse()?;
                        if let Some(float_token) = float_token {
                            if multi_index(&mut e, &mut dot_token, float_token)? {
                                continue;
                            }
                        }

                        let await_token: Option<Token![await]> = input.parse()?;
                        if let Some(await_token) = await_token {
                            e = Expr::Await(ExprAwait {
                                attrs: Vec::new(),
                                base: Box::new(e),
                                dot_token,
                                await_token,
                            });
                            continue;
                        }

                        let member: Member = input.parse()?;
                        let turbofish = if member.is_named() && input.peek(Token![::]) {
                            Some(AngleBracketedGenericArguments::parse_turbofish(input)?)
                        } else {
                            None
                        };

                        if turbofish.is_some() || input.peek(token::Paren) {
                            if let Member::Named(method) = member {
                                let content;
                                e = Expr::MethodCall(ExprMethodCall {
                                    attrs: Vec::new(),
                                    receiver: Box::new(e),
                                    dot_token,
                                    method,
                                    turbofish,
                                    paren_token: parenthesized!(content in input),
                                    args: content.parse_terminated(Expr::parse, Token![,])?,
                                });
                                continue;
                            }
                        }

                        e = Expr::Field(ExprField {
                            attrs: Vec::new(),
                            base: Box::new(e),
                            dot_token,
                            member,
                        });
                    } else if input.peek(token::Bracket) {
                        let content;
                        e = Expr::Index(ExprIndex {
                            attrs: Vec::new(),
                            expr: Box::new(e),
                            bracket_token: bracketed!(content in input),
                            index: content.parse()?,
                        });
                    } else if input.peek(Token![?])
                        && match e {
                            Expr::Range(_) => false,
                            _ => true,
                        }
                    {
                        e = Expr::Try(ExprTry {
                            attrs: Vec::new(),
                            expr: Box::new(e),
                            question_token: input.parse()?,
                        });
                    } else {
                        break;
                    }
                }
                Ok(e)
            }
            
            fn atom_expr(input: ParseStream, allow_struct: AllowStruct) -> Result<Expr>
            {
                if input.peek(token::Group) {
                    expr_group(input, allow_struct)
                } else if input.peek(Lit) {
                    input.parse().map(Expr::Lit)
                } else if input.peek(Token![async])
                    && (input.peek2(token::Brace) || input.peek2(Token![move]) && input.peek3(token::Brace))
                {
                    input.parse().map(Expr::Async)
                } else if input.peek(Token![try]) && input.peek2(token::Brace) {
                    input.parse().map(Expr::TryBlock)
                } else if input.peek(Token![|])
                    || input.peek(Token![move])
                    || input.peek(Token![for])
                        && generics::parsing::choose_generics_over_qpath_after_keyword(input)
                    || input.peek(Token![const]) && !input.peek2(token::Brace)
                    || input.peek(Token![static])
                    || input.peek(Token![async]) && (input.peek2(Token![|]) || input.peek2(Token![move]))
                {
                    expr_closure(input, allow_struct).map(Expr::Closure)
                } else if token::parsing::peek_keyword(input.cursor(), "builtin") && input.peek2(Token![#])
                {
                    expr_builtin(input)
                } else if input.peek(Ident)
                    || input.peek(Token![::])
                    || input.peek(Token![<])
                    || input.peek(Token![self])
                    || input.peek(Token![Self])
                    || input.peek(Token![super])
                    || input.peek(Token![crate])
                    || input.peek(Token![try]) && (input.peek2(Token![!]) || input.peek2(Token![::]))
                {
                    path_or_macro_or_struct(input, allow_struct)
                } else if input.peek(token::Paren) {
                    paren_or_tuple(input)
                } else if input.peek(Token![break]) {
                    expr_break(input, allow_struct).map(Expr::Break)
                } else if input.peek(Token![continue]) {
                    input.parse().map(Expr::Continue)
                } else if input.peek(Token![return]) {
                    input.parse().map(Expr::Return)
                } else if input.peek(Token![become]) {
                    expr_become(input)
                } else if input.peek(token::Bracket) {
                    array_or_repeat(input)
                } else if input.peek(Token![let]) {
                    expr_let(input, allow_struct).map(Expr::Let)
                } else if input.peek(Token![if]) {
                    input.parse().map(Expr::If)
                } else if input.peek(Token![while]) {
                    input.parse().map(Expr::While)
                } else if input.peek(Token![for]) {
                    input.parse().map(Expr::ForLoop)
                } else if input.peek(Token![loop]) {
                    input.parse().map(Expr::Loop)
                } else if input.peek(Token![match]) {
                    input.parse().map(Expr::Match)
                } else if input.peek(Token![yield]) {
                    input.parse().map(Expr::Yield)
                } else if input.peek(Token![unsafe]) {
                    input.parse().map(Expr::Unsafe)
                } else if input.peek(Token![const]) {
                    input.parse().map(Expr::Const)
                } else if input.peek(token::Brace) {
                    input.parse().map(Expr::Block)
                } else if input.peek(Token![..]) {
                    expr_range(input, allow_struct).map(Expr::Range)
                } else if input.peek(Token![_]) {
                    input.parse().map(Expr::Infer)
                } else if input.peek(Lifetime) {
                    atom_labeled(input)
                } else {
                    Err(input.error("expected an expression"))
                }
            }
            
            fn atom_labeled(input: ParseStream) -> Result<Expr>
            {
                let the_label: Label = input.parse()?;
                let mut expr = if input.peek(Token![while]) {
                    Expr::While(input.parse()?)
                } else if input.peek(Token![for]) {
                    Expr::ForLoop(input.parse()?)
                } else if input.peek(Token![loop]) {
                    Expr::Loop(input.parse()?)
                } else if input.peek(token::Brace) {
                    Expr::Block(input.parse()?)
                } else {
                    return Err(input.error("expected loop or block expression"));
                };
                match &mut expr {
                    Expr::While(ExprWhile { label, .. })
                    | Expr::ForLoop(ExprForLoop { label, .. })
                    | Expr::Loop(ExprLoop { label, .. })
                    | Expr::Block(ExprBlock { label, .. }) => *label = Some(the_label),
                    _ => unreachable!(),
                }
                Ok(expr)
            }
            
            fn expr_builtin(input: ParseStream) -> Result<Expr>
            {
                let begin = input.fork();

                token::parsing::keyword(input, "builtin")?;
                input.parse::<Token![#]>()?;
                input.parse::<Ident>()?;

                let args;
                parenthesized!(args in input);
                args.parse::<TokenStream>()?;

                Ok(Expr::Verbatim(verbatim::between(&begin, input)))
            }

            fn path_or_macro_or_struct(
                input: ParseStream,
                #[cfg(feature = "full")] allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                let expr_style = true;
                let (qself, path) = path::parsing::qpath(input, expr_style)?;
                rest_of_path_or_macro_or_struct(
                    qself,
                    path,
                    input,
                                allow_struct,
                )
            }

            fn rest_of_path_or_macro_or_struct
            (
                qself: Option<QSelf>,
                path: Path,
                input: ParseStream,
                allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                if qself.is_none()
                && input.peek(Token![!])
                && !input.peek(Token![!=])
                && path.is_mod_style()
                {
                    let bang_token: Token![!] = input.parse()?;
                    let (delimiter, tokens) = mac::parse_delimiter(input)?;
                    return Ok
                    (
                        Expr::Macro
                        (
                            ExprMacro
                            {
                                attrs: Vec::new(),
                                mac: Macro
                                {
                                    path,
                                    bang_token,
                                    delimiter,
                                    tokens,
                                },
                            }
                        )
                    );
                }
                
                if allow_struct.0 && input.peek(token::Brace)
                {
                    return expr_struct_helper(input, qself, path).map(Expr::Struct);
                }

                Ok
                (
                    Expr::Path
                    (
                        ExprPath
                        {
                            attrs: Vec::new(),
                            qself,
                            path,
                        }
                    )
                )
            }

            impl Parse for ExprMacro
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprMacro {
                        attrs: Vec::new(),
                        mac: input.parse()?,
                    })
                }
            }

            fn paren_or_tuple(input: ParseStream) -> Result<Expr>
            {
                let content;
                let paren_token = parenthesized!(content in input);
                if content.is_empty() {
                    return Ok(Expr::Tuple(ExprTuple {
                        attrs: Vec::new(),
                        paren_token,
                        elems: Punctuated::new(),
                    }));
                }

                let first: Expr = content.parse()?;
                if content.is_empty() {
                    return Ok(Expr::Paren(ExprParen {
                        attrs: Vec::new(),
                        paren_token,
                        expr: Box::new(first),
                    }));
                }

                let mut elems = Punctuated::new();
                elems.push_value(first);
                while !content.is_empty() {
                    let punct = content.parse()?;
                    elems.push_punct(punct);
                    if content.is_empty() {
                        break;
                    }
                    let value = content.parse()?;
                    elems.push_value(value);
                }
                Ok(Expr::Tuple(ExprTuple {
                    attrs: Vec::new(),
                    paren_token,
                    elems,
                }))
            }

                fn array_or_repeat(input: ParseStream) -> Result<Expr>
            {
                let content;
                let bracket_token = bracketed!(content in input);
                if content.is_empty() {
                    return Ok(Expr::Array(ExprArray {
                        attrs: Vec::new(),
                        bracket_token,
                        elems: Punctuated::new(),
                    }));
                }

                let first: Expr = content.parse()?;
                if content.is_empty() || content.peek(Token![,]) {
                    let mut elems = Punctuated::new();
                    elems.push_value(first);
                    while !content.is_empty() {
                        let punct = content.parse()?;
                        elems.push_punct(punct);
                        if content.is_empty() {
                            break;
                        }
                        let value = content.parse()?;
                        elems.push_value(value);
                    }
                    Ok(Expr::Array(ExprArray {
                        attrs: Vec::new(),
                        bracket_token,
                        elems,
                    }))
                } else if content.peek(Token![;]) {
                    let semi_token: Token![;] = content.parse()?;
                    let len: Expr = content.parse()?;
                    Ok(Expr::Repeat(ExprRepeat {
                        attrs: Vec::new(),
                        bracket_token,
                        expr: Box::new(first),
                        semi_token,
                        len: Box::new(len),
                    }))
                } else {
                    Err(content.error("expected `,` or `;`"))
                }
            }

                impl Parse for ExprArray
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    let bracket_token = bracketed!(content in input);
                    let mut elems = Punctuated::new();

                    while !content.is_empty() {
                        let first: Expr = content.parse()?;
                        elems.push_value(first);
                        if content.is_empty() {
                            break;
                        }
                        let punct = content.parse()?;
                        elems.push_punct(punct);
                    }

                    Ok(ExprArray {
                        attrs: Vec::new(),
                        bracket_token,
                        elems,
                    })
                }
            }

                impl Parse for ExprRepeat
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(ExprRepeat {
                        bracket_token: bracketed!(content in input),
                        attrs: Vec::new(),
                        expr: content.parse()?,
                        semi_token: content.parse()?,
                        len: content.parse()?,
                    })
                }
            }

                fn continue_parsing_early(mut expr: &Expr) -> bool
        {
                while let Expr::Group(group) = expr {
                    expr = &group.expr;
                }
                match expr {
                    Expr::If(_)
                    | Expr::While(_)
                    | Expr::ForLoop(_)
                    | Expr::Loop(_)
                    | Expr::Match(_)
                    | Expr::TryBlock(_)
                    | Expr::Unsafe(_)
                    | Expr::Const(_)
                    | Expr::Block(_) => false,
                    _ => true,
                }
            }

            impl Parse for ExprLit
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprLit {
                        attrs: Vec::new(),
                        lit: input.parse()?,
                    })
                }
            }

            fn expr_group(
                input: ParseStream,
                #[cfg(feature = "full")] allow_struct: AllowStruct,
            ) -> Result<Expr>
            {
                let group = ::syntax::group::parse_group(input)?;
                let mut inner: Expr = group.content.parse()?;

                match inner {
                    Expr::Path(mut expr) if expr.attrs.is_empty() => {
                        let grouped_len = expr.path.segments.len();
                        Path::parse_rest(input, &mut expr.path, true)?;
                        match rest_of_path_or_macro_or_struct(
                            expr.qself,
                            expr.path,
                            input,
                                                allow_struct,
                        )? {
                            Expr::Path(expr) if expr.path.segments.len() == grouped_len => {
                                inner = Expr::Path(expr);
                            }
                            extended => return Ok(extended),
                        }
                    }
                    _ => {}
                }

                Ok(Expr::Group(ExprGroup {
                    attrs: Vec::new(),
                    group_token: group.token,
                    expr: Box::new(inner),
                }))
            }

                impl Parse for ExprParen
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(ExprParen {
                        attrs: Vec::new(),
                        paren_token: parenthesized!(content in input),
                        expr: content.parse()?,
                    })
                }
            }

                impl Parse for ExprLet
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    expr_let(input, allow_struct)
                }
            }

                fn expr_let(input: ParseStream, allow_struct: AllowStruct) -> Result<ExprLet>
            {
                Ok
                (ExprLet {
                    attrs: Vec::new(),
                    let_token: input.parse()?,
                    pat: Box::new(Pat::parse_multi_with_leading_vert(input)?),
                    eq_token: input.parse()?,
                    expr: Box::new({
                        let lhs = unary_expr(input, allow_struct)?;
                        parse_expr(input, lhs, allow_struct, Precedence::Compare)?
                    }),
                })
            }

                impl Parse for ExprIf
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;

                    let mut clauses = Vec::new();
                    let mut expr;
                    loop {
                        let if_token: Token![if] = input.parse()?;
                        let cond = input.call(Expr::parse_without_eager_brace)?;
                        let then_branch: Block = input.parse()?;

                        expr = ExprIf {
                            attrs: Vec::new(),
                            if_token,
                            cond: Box::new(cond),
                            then_branch,
                            else_branch: None,
                        };

                        if !input.peek(Token![else]) {
                            break;
                        }

                        let else_token: Token![else] = input.parse()?;
                        let lookahead = input.lookahead1();
                        if lookahead.peek(Token![if]) {
                            expr.else_branch = Some((else_token, Box::new(Expr::PLACEHOLDER)));
                            clauses.push(expr);
                        } else if lookahead.peek(token::Brace) {
                            expr.else_branch = Some((
                                else_token,
                                Box::new(Expr::Block(ExprBlock {
                                    attrs: Vec::new(),
                                    label: None,
                                    block: input.parse()?,
                                })),
                            ));
                            break;
                        } else {
                            return Err(lookahead.error());
                        }
                    }

                    while let Some(mut prev) = clauses.pop() {
                        *prev.else_branch.as_mut().unwrap().1 = Expr::If(expr);
                        expr = prev;
                    }
                    expr.attrs = attrs;
                    Ok(expr)
                }
            }

                impl Parse for ExprInfer
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprInfer {
                        attrs: input.call(Attribute::parse_outer)?,
                        underscore_token: input.parse()?,
                    })
                }
            }

                impl Parse for ExprForLoop
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let label: Option<Label> = input.parse()?;
                    let for_token: Token![for] = input.parse()?;

                    let pat = Pat::parse_multi_with_leading_vert(input)?;

                    let in_token: Token![in] = input.parse()?;
                    let expr: Expr = input.call(Expr::parse_without_eager_brace)?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprForLoop {
                        attrs,
                        label,
                        for_token,
                        pat: Box::new(pat),
                        in_token,
                        expr: Box::new(expr),
                        body: Block { brace_token, stmts },
                    })
                }
            }

                impl Parse for ExprLoop
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let label: Option<Label> = input.parse()?;
                    let loop_token: Token![loop] = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprLoop {
                        attrs,
                        label,
                        loop_token,
                        body: Block { brace_token, stmts },
                    })
                }
            }

                impl Parse for ExprMatch
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let match_token: Token![match] = input.parse()?;
                    let expr = Expr::parse_without_eager_brace(input)?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;

                    let arms = Arm::parse_multiple(&content)?;

                    Ok(ExprMatch {
                        attrs,
                        match_token,
                        expr: Box::new(expr),
                        brace_token,
                        arms,
                    })
                }
            }

            macro_rules! impl_by_parsing_expr {
                (
                    $(
                        $expr_type:ty, $variant:ident, $msg:expr,
                    )*
                ) => {
                    $(
                        #[cfg(all(feature = "full", feature = "printing"))]
                                    impl Parse for $expr_type {
                            fn parse(input: ParseStream) -> Result<Self> {
                                let mut expr: Expr = input.parse()?;
                                loop {
                                    match expr {
                                        Expr::$variant(inner) => return Ok(inner),
                                        Expr::Group(next) => expr = *next.expr,
                                        _ => return Err(Error::new_spanned(expr, $msg)),
                                    }
                                }
                            }
                        }
                    )*
                };
            }

            impl_by_parsing_expr! {
                ExprAssign, Assign, "expected assignment expression",
                ExprAwait, Await, "expected await expression",
                ExprBinary, Binary, "expected binary operation",
                ExprCall, Call, "expected function call expression",
                ExprCast, Cast, "expected cast expression",
                ExprField, Field, "expected struct field access",
                ExprIndex, Index, "expected indexing expression",
                ExprMethodCall, MethodCall, "expected method call expression",
                ExprRange, Range, "expected range expression",
                ExprTry, Try, "expected try expression",
                ExprTuple, Tuple, "expected tuple expression",
            }

                impl Parse for ExprUnary
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = Vec::new();
                    let allow_struct = AllowStruct(true);
                    expr_unary(input, attrs, allow_struct)
                }
            }

                fn expr_unary(
                input: ParseStream,
                attrs: Vec<Attribute>,
                allow_struct: AllowStruct,
            ) -> Result<ExprUnary>
            {
                Ok
                (ExprUnary {
                    attrs,
                    op: input.parse()?,
                    expr: Box::new(unary_expr(input, allow_struct)?),
                })
            }

                impl Parse for ExprClosure
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    expr_closure(input, allow_struct)
                }
            }

                impl Parse for ExprRawAddr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    Ok(ExprRawAddr {
                        attrs: Vec::new(),
                        and_token: input.parse()?,
                        raw: input.parse()?,
                        mutability: input.parse()?,
                        expr: Box::new(unary_expr(input, allow_struct)?),
                    })
                }
            }

                impl Parse for ExprReference
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    Ok(ExprReference {
                        attrs: Vec::new(),
                        and_token: input.parse()?,
                        mutability: input.parse()?,
                        expr: Box::new(unary_expr(input, allow_struct)?),
                    })
                }
            }

                impl Parse for ExprBreak
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_struct = AllowStruct(true);
                    expr_break(input, allow_struct)
                }
            }

                impl Parse for ExprReturn
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprReturn {
                        attrs: Vec::new(),
                        return_token: input.parse()?,
                        expr: {
                            if Expr::peek(input) {
                                Some(input.parse()?)
                            } else {
                                None
                            }
                        },
                    })
                }
            }

                fn expr_become(input: ParseStream) -> Result<Expr>
            {
                let begin = input.fork();
                input.parse::<Token![become]>()?;
                input.parse::<Expr>()?;
                Ok(Expr::Verbatim(verbatim::between(&begin, input)))
            }

                impl Parse for ExprTryBlock
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprTryBlock {
                        attrs: Vec::new(),
                        try_token: input.parse()?,
                        block: input.parse()?,
                    })
                }
            }

                impl Parse for ExprYield
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprYield {
                        attrs: Vec::new(),
                        yield_token: input.parse()?,
                        expr: {
                            if Expr::peek(input) {
                                Some(input.parse()?)
                            } else {
                                None
                            }
                        },
                    })
                }
            }

                fn expr_closure(input: ParseStream, allow_struct: AllowStruct) -> Result<ExprClosure>
            {
                let lifetimes: Option<BoundLifetimes> = input.parse()?;
                let constness: Option<Token![const]> = input.parse()?;
                let movability: Option<Token![static]> = input.parse()?;
                let asyncness: Option<Token![async]> = input.parse()?;
                let capture: Option<Token![move]> = input.parse()?;
                let or1_token: Token![|] = input.parse()?;

                let mut inputs = Punctuated::new();
                loop {
                    if input.peek(Token![|]) {
                        break;
                    }
                    let value = closure_arg(input)?;
                    inputs.push_value(value);
                    if input.peek(Token![|]) {
                        break;
                    }
                    let punct: Token![,] = input.parse()?;
                    inputs.push_punct(punct);
                }

                let or2_token: Token![|] = input.parse()?;

                let (output, body) = if input.peek(Token![->]) {
                    let arrow_token: Token![->] = input.parse()?;
                    let ty: Type = input.parse()?;
                    let body: Block = input.parse()?;
                    let output = ReturnType::Type(arrow_token, Box::new(ty));
                    let block = Expr::Block(ExprBlock {
                        attrs: Vec::new(),
                        label: None,
                        block: body,
                    });
                    (output, block)
                } else {
                    let body = ambiguous_expr(input, allow_struct)?;
                    (ReturnType::Default, body)
                };

                Ok(ExprClosure {
                    attrs: Vec::new(),
                    lifetimes,
                    constness,
                    movability,
                    asyncness,
                    capture,
                    or1_token,
                    inputs,
                    or2_token,
                    output,
                    body: Box::new(body),
                })
            }

                impl Parse for ExprAsync
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprAsync {
                        attrs: Vec::new(),
                        async_token: input.parse()?,
                        capture: input.parse()?,
                        block: input.parse()?,
                    })
                }
            }

                fn closure_arg(input: ParseStream) -> Result<Pat>
            {
                let attrs = input.call(Attribute::parse_outer)?;
                let mut pat = Pat::parse_single(input)?;

                if input.peek(Token![:]) {
                    Ok(Pat::Type(PatType {
                        attrs,
                        pat: Box::new(pat),
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                    }))
                } else {
                    match &mut pat {
                        Pat::Const(pat) => pat.attrs = attrs,
                        Pat::Ident(pat) => pat.attrs = attrs,
                        Pat::Lit(pat) => pat.attrs = attrs,
                        Pat::Macro(pat) => pat.attrs = attrs,
                        Pat::Or(pat) => pat.attrs = attrs,
                        Pat::Paren(pat) => pat.attrs = attrs,
                        Pat::Path(pat) => pat.attrs = attrs,
                        Pat::Range(pat) => pat.attrs = attrs,
                        Pat::Reference(pat) => pat.attrs = attrs,
                        Pat::Rest(pat) => pat.attrs = attrs,
                        Pat::Slice(pat) => pat.attrs = attrs,
                        Pat::Struct(pat) => pat.attrs = attrs,
                        Pat::Tuple(pat) => pat.attrs = attrs,
                        Pat::TupleStruct(pat) => pat.attrs = attrs,
                        Pat::Type(_) => unreachable!(),
                        Pat::Verbatim(_) => {}
                        Pat::Wild(pat) => pat.attrs = attrs,
                    }
                    Ok(pat)
                }
            }

                impl Parse for ExprWhile
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let label: Option<Label> = input.parse()?;
                    let while_token: Token![while] = input.parse()?;
                    let cond = Expr::parse_without_eager_brace(input)?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprWhile {
                        attrs,
                        label,
                        while_token,
                        cond: Box::new(cond),
                        body: Block { brace_token, stmts },
                    })
                }
            }

                impl Parse for ExprConst
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let const_token: Token![const] = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    let inner_attrs = content.call(Attribute::parse_inner)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprConst {
                        attrs: inner_attrs,
                        const_token,
                        block: Block { brace_token, stmts },
                    })
                }
            }

                impl Parse for Label
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (Label {
                        name: input.parse()?,
                        colon_token: input.parse()?,
                    })
                }
            }

                impl Parse for Option<Label>
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Lifetime) {
                        input.parse().map(Some)
                    } else {
                        Ok(None)
                    }
                }
            }

                impl Parse for ExprContinue
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ExprContinue {
                        attrs: Vec::new(),
                        continue_token: input.parse()?,
                        label: input.parse()?,
                    })
                }
            }

                fn expr_break(input: ParseStream, allow_struct: AllowStruct) -> Result<ExprBreak>
            {
                let break_token: Token![break] = input.parse()?;

                let ahead = input.fork();
                let label: Option<Lifetime> = ahead.parse()?;
                if label.is_some() && ahead.peek(Token![:]) {
                   
                   
                    let _: Expr = input.parse()?;
                    let start_span = label.unwrap().apostrophe;
                    let end_span = input.cursor().prev_span();
                    return Err(::syntax::error::new2(
                        start_span,
                        end_span,
                        "parentheses required",
                    ));
                }

                input.advance_to(&ahead);
                let expr = if Expr::peek(input) && (allow_struct.0 || !input.peek(token::Brace)) {
                    Some(input.parse()?)
                } else {
                    None
                };

                Ok(ExprBreak {
                    attrs: Vec::new(),
                    break_token,
                    label,
                    expr,
                })
            }

            impl Parse for FieldValue
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let member: Member = input.parse()?;
                    let (colon_token, value) = if input.peek(Token![:]) || !member.is_named() {
                        let colon_token: Token![:] = input.parse()?;
                        let value: Expr = input.parse()?;
                        (Some(colon_token), value)
                    } else if let Member::Named(ident) = &member {
                        let value = Expr::Path(ExprPath {
                            attrs: Vec::new(),
                            qself: None,
                            path: Path::from(ident.clone()),
                        });
                        (None, value)
                    } else {
                        unreachable!()
                    };

                    Ok(FieldValue {
                        attrs,
                        member,
                        colon_token,
                        expr: value,
                    })
                }
            }

            impl Parse for ExprStruct
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let expr_style = true;
                    let (qself, path) = path::parsing::qpath(input, expr_style)?;
                    expr_struct_helper(input, qself, path)
                }
            }

            fn expr_struct_helper(
                input: ParseStream,
                qself: Option<QSelf>,
                path: Path,
            ) -> Result<ExprStruct>
            {
                let content;
                let brace_token = braced!(content in input);

                let mut fields = Punctuated::new();
                while !content.is_empty() {
                    if content.peek(Token![..]) {
                        return Ok(ExprStruct {
                            attrs: Vec::new(),
                            qself,
                            path,
                            brace_token,
                            fields,
                            dot2_token: Some(content.parse()?),
                            rest: if content.is_empty() {
                                None
                            } else {
                                Some(Box::new(content.parse()?))
                            },
                        });
                    }

                    fields.push(content.parse()?);
                    if content.is_empty() {
                        break;
                    }
                    let punct: Token![,] = content.parse()?;
                    fields.push_punct(punct);
                }

                Ok(ExprStruct {
                    attrs: Vec::new(),
                    qself,
                    path,
                    brace_token,
                    fields,
                    dot2_token: None,
                    rest: None,
                })
            }

                impl Parse for ExprUnsafe
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let unsafe_token: Token![unsafe] = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    let inner_attrs = content.call(Attribute::parse_inner)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprUnsafe {
                        attrs: inner_attrs,
                        unsafe_token,
                        block: Block { brace_token, stmts },
                    })
                }
            }

                impl Parse for ExprBlock
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let label: Option<Label> = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let stmts = content.call(Block::parse_within)?;

                    Ok(ExprBlock {
                        attrs,
                        label,
                        block: Block { brace_token, stmts },
                    })
                }
            }

                fn expr_range(input: ParseStream, allow_struct: AllowStruct) -> Result<ExprRange>
            {
                let limits: RangeLimits = input.parse()?;
                let end = parse_range_end(input, &limits, allow_struct)?;
                Ok(ExprRange {
                    attrs: Vec::new(),
                    start: None,
                    limits,
                    end,
                })
            }

                fn parse_range_end(
                input: ParseStream,
                limits: &RangeLimits,
                allow_struct: AllowStruct,
            ) -> Result<Option<Box<Expr>>> {
                if matches!(limits, RangeLimits::HalfOpen(_))
                    && (input.is_empty()
                        || input.peek(Token![,])
                        || input.peek(Token![;])
                        || input.peek(Token![.]) && !input.peek(Token![..])
                        || input.peek(Token![?])
                        || input.peek(Token![=>])
                        || !allow_struct.0 && input.peek(token::Brace)
                        || input.peek(Token![=])
                        || input.peek(Token![+])
                        || input.peek(Token![/])
                        || input.peek(Token![%])
                        || input.peek(Token![^])
                        || input.peek(Token![>])
                        || input.peek(Token![<=])
                        || input.peek(Token![!=])
                        || input.peek(Token![-=])
                        || input.peek(Token![*=])
                        || input.peek(Token![&=])
                        || input.peek(Token![|=])
                        || input.peek(Token![<<=])
                        || input.peek(Token![as]))
                {
                    Ok(None)
                } else {
                    let end = parse_binop_rhs(input, allow_struct, Precedence::Range)?;
                    Ok(Some(end))
                }
            }

                impl Parse for RangeLimits
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    let dot_dot = lookahead.peek(Token![..]);
                    let dot_dot_eq = dot_dot && lookahead.peek(Token![..=]);
                    let dot_dot_dot = dot_dot && input.peek(Token![...]);
                    if dot_dot_eq {
                        input.parse().map(RangeLimits::Closed)
                    } else if dot_dot && !dot_dot_dot {
                        input.parse().map(RangeLimits::HalfOpen)
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

                impl RangeLimits {
                pub fn parse_obsolete(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    let dot_dot = lookahead.peek(Token![..]);
                    let dot_dot_eq = dot_dot && lookahead.peek(Token![..=]);
                    let dot_dot_dot = dot_dot && input.peek(Token![...]);
                    if dot_dot_eq {
                        input.parse().map(RangeLimits::Closed)
                    } else if dot_dot_dot {
                        let dot3: Token![...] = input.parse()?;
                        Ok(RangeLimits::Closed(Token![..=](dot3.spans)))
                    } else if dot_dot {
                        input.parse().map(RangeLimits::HalfOpen)
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            impl Parse for ExprPath
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let expr_style = true;
                    let (qself, path) = path::parsing::qpath(input, expr_style)?;
                    Ok(ExprPath { attrs, qself, path })
                }
            }

            impl Parse for Member
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Ident) {
                        input.parse().map(Member::Named)
                    } else if input.peek(LitInt) {
                        input.parse().map(Member::Unnamed)
                    } else {
                        Err(input.error("expected identifier or integer"))
                    }
                }
            }

                impl Arm {
                pub fn parse_multiple(input: ParseStream) -> Result<Vec<Self>> {
                    let mut arms = Vec::new();
                    while !input.is_empty() {
                        arms.push(input.call(Arm::parse)?);
                    }
                    Ok(arms)
                }
            }

                impl Parse for Arm
            {
                fn parse(input: ParseStream) -> Result<Arm> {
                    let requires_comma;
                    Ok(Arm {
                        attrs: input.call(Attribute::parse_outer)?,
                        pat: Pat::parse_multi_with_leading_vert(input)?,
                        guard: {
                            if input.peek(Token![if]) {
                                let if_token: Token![if] = input.parse()?;
                                let guard: Expr = input.parse()?;
                                Some((if_token, Box::new(guard)))
                            } else {
                                None
                            }
                        },
                        fat_arrow_token: input.parse()?,
                        body: {
                            let body = Expr::parse_with_earlier_boundary_rule(input)?;
                            requires_comma = classify::requires_comma_to_be_match_arm(&body);
                            Box::new(body)
                        },
                        comma: {
                            if requires_comma && !input.is_empty() {
                                Some(input.parse()?)
                            } else {
                                input.parse()?
                            }
                        },
                    })
                }
            }

            impl Parse for Index
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lit: LitInt = input.parse()?;
                    if lit.suffix().is_empty() {
                        Ok(Index {
                            index: lit
                                .base10_digits()
                                .parse()
                                .map_err(|err| Error::new(lit.span(), err))?,
                            span: lit.span(),
                        })
                    } else {
                        Err(Error::new(lit.span(), "expected unsuffixed integer"))
                    }
                }
            }

            fn multi_index(e: &mut Expr, dot_token: &mut Token![.], float: LitFloat) -> Result<bool>
            {
                let float_token = float.token();
                let float_span = float_token.span();
                let mut float_repr = float_token.to_string();
                let trailing_dot = float_repr.ends_with('.');
                if trailing_dot {
                    float_repr.truncate(float_repr.len() - 1);
                }

                let mut offset = 0;
                for part in float_repr.split('.') {
                    let mut index: Index =
                        ::syntax::parse_str(part).map_err(|err| Error::new(float_span, err))?;
                    let part_end = offset + part.len();
                    index.span = float_token.subspan(offset..part_end).unwrap_or(float_span);

                    let base = mem::replace(e, Expr::PLACEHOLDER);
                    *e = Expr::Field(ExprField {
                        attrs: Vec::new(),
                        base: Box::new(base),
                        dot_token: Token![.](dot_token.span),
                        member: Member::Unnamed(index),
                    });

                    let dot_span = float_token
                        .subspan(part_end..part_end + 1)
                        .unwrap_or(float_span);
                    *dot_token = Token![.](dot_span);
                    offset = part_end + 1;
                }

                Ok(!trailing_dot)
            }

                impl Parse for PointerMutability
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    if lookahead.peek(Token![const]) {
                        Ok(PointerMutability::Const(input.parse()?))
                    } else if lookahead.peek(Token![mut]) {
                        Ok(PointerMutability::Mut(input.parse()?))
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            fn check_cast(input: ParseStream) -> Result<()>
            {
                let kind = if input.peek(Token![.]) && !input.peek(Token![..]) {
                    if input.peek2(Token![await]) {
                        "`.await`"
                    } else if input.peek2(Ident) && (input.peek3(token::Paren) || input.peek3(Token![::])) {
                        "a method call"
                    } else {
                        "a field access"
                    }
                } else if input.peek(Token![?]) {
                    "`?`"
                } else if input.peek(token::Bracket) {
                    "indexing"
                } else if input.peek(token::Paren) {
                    "a function call"
                } else {
                    return Ok(());
                };
                let msg = format!("casts cannot be followed by {}", kind);
                Err(input.error(msg))
            }
        }
        
        pub mod printing
        {
            use ::
            {
                process::macros::{Literal, Span, TokenStream},
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    attr::Attribute,
                    attr::FilterAttrs,
                    classify,
                    expr::
                    {
                        Arm, ExprArray, ExprAssign, ExprAsync, ExprAwait, ExprBlock, ExprBreak, ExprClosure, 
                        ExprConst, ExprContinue, ExprForLoop, ExprIf, ExprInfer, ExprLet, ExprLoop, ExprMatch,
                        ExprRange, ExprRawAddr, ExprRepeat, ExprReturn, ExprTry, ExprTryBlock, ExprUnsafe,
                        ExprWhile, ExprYield, Label, PointerMutability, RangeLimits, Expr, ExprBinary, ExprCall,
                        ExprCast, ExprField, ExprGroup, ExprIndex, ExprLit, ExprMacro, ExprMethodCall, ExprParen,
                        ExprPath, ExprReference, ExprStruct, ExprTuple, ExprUnary, FieldValue, Index, Member,
                    },
                    fixup::FixupContext,
                    op::BinOp,
                    path,
                    path::printing::PathStyle,
                    precedence::Precedence,
                    token,
                    ty::ReturnType,
                },
                *,
            };
            
            pub fn outer_attrs_to_tokens(attrs: &[Attribute], tokens: &mut TokenStream) {
                tokens.append_all(attrs.outer());
            }

                fn inner_attrs_to_tokens(attrs: &[Attribute], tokens: &mut TokenStream) {
                tokens.append_all(attrs.inner());
            }
            
            pub fn print_subexpression
            (
                expr: &Expr,
                needs_group: bool,
                tokens: &mut TokenStream,
                mut fixup: FixupContext,
            )
            {
                if needs_group {


                   
                   
                   


                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| print_expr(expr, tokens, fixup);

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }

            pub fn print_expr(expr: &Expr, tokens: &mut TokenStream, mut fixup: FixupContext)
            {
                let needs_group = fixup.parenthesize(expr);

                if needs_group { fixup = FixupContext::NONE; }

                let do_print_expr = |tokens: &mut TokenStream| match expr
                {
                    Expr::Array(e) => e.to_tokens(tokens),
                    Expr::Assign(e) => print_expr_assign(e, tokens, fixup),
                    Expr::Async(e) => e.to_tokens(tokens),
                    Expr::Await(e) => print_expr_await(e, tokens, fixup),
                    Expr::Binary(e) => print_expr_binary(e, tokens, fixup),
                    Expr::Block(e) => e.to_tokens(tokens),
                    Expr::Break(e) => print_expr_break(e, tokens, fixup),
                    Expr::Call(e) => print_expr_call(e, tokens, fixup),
                    Expr::Cast(e) => print_expr_cast(e, tokens, fixup),
                    Expr::Closure(e) => print_expr_closure(e, tokens, fixup),
                    Expr::Const(e) => e.to_tokens(tokens),
                    Expr::Continue(e) => e.to_tokens(tokens),
                    Expr::Field(e) => print_expr_field(e, tokens, fixup),
                    Expr::ForLoop(e) => e.to_tokens(tokens),
                    Expr::Group(e) => e.to_tokens(tokens),
                    Expr::If(e) => e.to_tokens(tokens),
                    Expr::Index(e) => print_expr_index(e, tokens, fixup),
                    Expr::Infer(e) => e.to_tokens(tokens),
                    Expr::Let(e) => print_expr_let(e, tokens, fixup),
                    Expr::Lit(e) => e.to_tokens(tokens),
                    Expr::Loop(e) => e.to_tokens(tokens),
                    Expr::Macro(e) => e.to_tokens(tokens),
                    Expr::Match(e) => e.to_tokens(tokens),
                    Expr::MethodCall(e) => print_expr_method_call(e, tokens, fixup),
                    Expr::Paren(e) => e.to_tokens(tokens),
                    Expr::Path(e) => e.to_tokens(tokens),
                    Expr::Range(e) => print_expr_range(e, tokens, fixup),
                    Expr::RawAddr(e) => print_expr_raw_addr(e, tokens, fixup),
                    Expr::Reference(e) => print_expr_reference(e, tokens, fixup),
                    Expr::Repeat(e) => e.to_tokens(tokens),
                    Expr::Return(e) => print_expr_return(e, tokens, fixup),
                    Expr::Struct(e) => e.to_tokens(tokens),
                    Expr::Try(e) => print_expr_try(e, tokens, fixup),
                    Expr::TryBlock(e) => e.to_tokens(tokens),
                    Expr::Tuple(e) => e.to_tokens(tokens),
                    Expr::Unary(e) => print_expr_unary(e, tokens, fixup),
                    Expr::Unsafe(e) => e.to_tokens(tokens),
                    Expr::Verbatim(e) => e.to_tokens(tokens),
                    Expr::While(e) => e.to_tokens(tokens),
                    Expr::Yield(e) => print_expr_yield(e, tokens, fixup),
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }
            
            impl ToTokens for ExprArray {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.bracket_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                    });
                }
            }

                impl ToTokens for ExprAssign {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_assign(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_assign(e: &ExprAssign, tokens: &mut TokenStream, mut fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let needs_group = !e.attrs.is_empty();
                if needs_group {
                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| {
                    let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                        &e.left,
                        false,
                        false,
                        Precedence::Assign,
                    );
                    print_subexpression(&e.left, left_prec <= Precedence::Range, tokens, left_fixup);
                    e.eq_token.to_tokens(tokens);
                    print_expr(
                        &e.right,
                        tokens,
                        fixup.rightmost_subexpression_fixup(false, false, Precedence::Assign),
                    );
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }

                impl ToTokens for ExprAsync {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.async_token.to_tokens(tokens);
                    self.capture.to_tokens(tokens);
                    self.block.to_tokens(tokens);
                }
            }

                impl ToTokens for ExprAwait {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_await(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_await(e: &ExprAwait, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_dot(&e.base);
                print_subexpression(
                    &e.base,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.dot_token.to_tokens(tokens);
                e.await_token.to_tokens(tokens);
            }

            impl ToTokens for ExprBinary {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_binary(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_binary(e: &ExprBinary, tokens: &mut TokenStream, mut fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let needs_group = !e.attrs.is_empty();
                if needs_group {
                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| {
                    let binop_prec = Precedence::of_binop(&e.op);
                    let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                        &e.left,
                                        match &e.op {
                            BinOp::Sub(_)
                            | BinOp::Mul(_)
                            | BinOp::And(_)
                            | BinOp::Or(_)
                            | BinOp::BitAnd(_)
                            | BinOp::BitOr(_)
                            | BinOp::Shl(_)
                            | BinOp::Lt(_) => true,
                            _ => false,
                        },
                        match &e.op {
                            BinOp::Shl(_) | BinOp::Lt(_) => true,
                            _ => false,
                        },
                                        binop_prec,
                    );
                    let left_needs_group = match binop_prec {
                        Precedence::Assign => left_prec <= Precedence::Range,
                        Precedence::Compare => left_prec <= binop_prec,
                        _ => left_prec < binop_prec,
                    };

                    let right_fixup = fixup.rightmost_subexpression_fixup(
                                        false,
                                        false,
                                        binop_prec,
                    );
                    let right_needs_group = binop_prec != Precedence::Assign
                        && right_fixup.rightmost_subexpression_precedence(&e.right) <= binop_prec;

                    print_subexpression(&e.left, left_needs_group, tokens, left_fixup);
                    e.op.to_tokens(tokens);
                    print_subexpression(&e.right, right_needs_group, tokens, right_fixup);
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }

                impl ToTokens for ExprBlock {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.label.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }

                impl ToTokens for ExprBreak {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_break(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_break(e: &ExprBreak, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.break_token.to_tokens(tokens);
                e.label.to_tokens(tokens);
                if let Some(value) = &e.expr {
                    print_subexpression(
                        value,
                       
                       
                        e.label.is_none() && classify::expr_leading_label(value),
                        tokens,
                        fixup.rightmost_subexpression_fixup(true, true, Precedence::Jump),
                    );
                }
            }

            impl ToTokens for ExprCall {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_call(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_call(e: &ExprCall, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                    &e.func,
                                true,
                    false,
                                Precedence::Unambiguous,
                );
                let needs_group = if let Expr::Field(func) = &*e.func {
                    func.member.is_named()
                } else {
                    left_prec < Precedence::Unambiguous
                };
                print_subexpression(&e.func, needs_group, tokens, left_fixup);

                e.paren_token.surround(tokens, |tokens| {
                    e.args.to_tokens(tokens);
                });
            }

            impl ToTokens for ExprCast {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_cast(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_cast(e: &ExprCast, tokens: &mut TokenStream, mut fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let needs_group = !e.attrs.is_empty();
                if needs_group {
                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| {
                    let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                        &e.expr,
                                        false,
                        false,
                                        Precedence::Cast,
                    );
                    print_subexpression(&e.expr, left_prec < Precedence::Cast, tokens, left_fixup);
                    e.as_token.to_tokens(tokens);
                    e.ty.to_tokens(tokens);
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }

                impl ToTokens for ExprClosure {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_closure(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_closure(e: &ExprClosure, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.lifetimes.to_tokens(tokens);
                e.constness.to_tokens(tokens);
                e.movability.to_tokens(tokens);
                e.asyncness.to_tokens(tokens);
                e.capture.to_tokens(tokens);
                e.or1_token.to_tokens(tokens);
                e.inputs.to_tokens(tokens);
                e.or2_token.to_tokens(tokens);
                e.output.to_tokens(tokens);
                if matches!(e.output, ReturnType::Default)
                    || matches!(&*e.body, Expr::Block(body) if body.attrs.is_empty() && body.label.is_none())
                {
                    print_expr(
                        &e.body,
                        tokens,
                        fixup.rightmost_subexpression_fixup(false, false, Precedence::Jump),
                    );
                } else {
                    token::Brace::default().surround(tokens, |tokens| {
                        print_expr(&e.body, tokens, FixupContext::new_stmt());
                    });
                }
            }

                impl ToTokens for ExprConst {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.const_token.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }

                impl ToTokens for ExprContinue {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.continue_token.to_tokens(tokens);
                    self.label.to_tokens(tokens);
                }
            }

            impl ToTokens for ExprField {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_field(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_field(e: &ExprField, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_dot(&e.base);
                print_subexpression(
                    &e.base,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.dot_token.to_tokens(tokens);
                e.member.to_tokens(tokens);
            }

                impl ToTokens for ExprForLoop {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.label.to_tokens(tokens);
                    self.for_token.to_tokens(tokens);
                    self.pat.to_tokens(tokens);
                    self.in_token.to_tokens(tokens);
                    print_expr(&self.expr, tokens, FixupContext::new_condition());
                    self.body.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.body.stmts);
                    });
                }
            }

            impl ToTokens for ExprGroup {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.group_token.surround(tokens, |tokens| {
                        self.expr.to_tokens(tokens);
                    });
                }
            }

                impl ToTokens for ExprIf {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);

                    let mut expr = self;
                    loop {
                        expr.if_token.to_tokens(tokens);
                        print_expr(&expr.cond, tokens, FixupContext::new_condition());
                        expr.then_branch.to_tokens(tokens);

                        let (else_token, else_) = match &expr.else_branch {
                            Some(else_branch) => else_branch,
                            None => break,
                        };

                        else_token.to_tokens(tokens);
                        match &**else_ {
                            Expr::If(next) => {
                                expr = next;
                            }
                            Expr::Block(last) => {
                                last.to_tokens(tokens);
                                break;
                            }
                           
                           
                            other => {
                                token::Brace::default().surround(tokens, |tokens| {
                                    print_expr(other, tokens, FixupContext::new_stmt());
                                });
                                break;
                            }
                        }
                    }
                }
            }

            impl ToTokens for ExprIndex {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_index(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_index(e: &ExprIndex, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                    &e.expr,
                                true,
                    false,
                                Precedence::Unambiguous,
                );
                print_subexpression(
                    &e.expr,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.bracket_token.surround(tokens, |tokens| {
                    e.index.to_tokens(tokens);
                });
            }

                impl ToTokens for ExprInfer {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.underscore_token.to_tokens(tokens);
                }
            }

                impl ToTokens for ExprLet {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_let(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_let(e: &ExprLet, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.let_token.to_tokens(tokens);
                e.pat.to_tokens(tokens);
                e.eq_token.to_tokens(tokens);
                let (right_prec, right_fixup) = fixup.rightmost_subexpression(&e.expr, Precedence::Let);
                print_subexpression(&e.expr, right_prec < Precedence::Let, tokens, right_fixup);
            }

            impl ToTokens for ExprLit {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.lit.to_tokens(tokens);
                }
            }

                impl ToTokens for ExprLoop {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.label.to_tokens(tokens);
                    self.loop_token.to_tokens(tokens);
                    self.body.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.body.stmts);
                    });
                }
            }

            impl ToTokens for ExprMacro {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.mac.to_tokens(tokens);
                }
            }

                impl ToTokens for ExprMatch {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.match_token.to_tokens(tokens);
                    print_expr(&self.expr, tokens, FixupContext::new_condition());
                    self.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        for (i, arm) in self.arms.iter().enumerate() {
                            arm.to_tokens(tokens);
                           
                           
                            let is_last = i == self.arms.len() - 1;
                            if !is_last
                                && classify::requires_comma_to_be_match_arm(&arm.body)
                                && arm.comma.is_none()
                            {
                                <Token![,]>::default().to_tokens(tokens);
                            }
                        }
                    });
                }
            }

            impl ToTokens for ExprMethodCall {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_method_call(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_method_call(e: &ExprMethodCall, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_dot(&e.receiver);
                print_subexpression(
                    &e.receiver,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.dot_token.to_tokens(tokens);
                e.method.to_tokens(tokens);
                if let Some(turbofish) = &e.turbofish {
                    path::printing::print_angle_bracketed_generic_arguments(
                        tokens,
                        turbofish,
                        PathStyle::Expr,
                    );
                }
                e.paren_token.surround(tokens, |tokens| {
                    e.args.to_tokens(tokens);
                });
            }

            impl ToTokens for ExprParen {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.paren_token.surround(tokens, |tokens| {
                        self.expr.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for ExprPath {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::Expr);
                }
            }

                impl ToTokens for ExprRange {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_range(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_range(e: &ExprRange, tokens: &mut TokenStream, mut fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);

                let needs_group = !e.attrs.is_empty();
                if needs_group {
                    fixup = FixupContext::NONE;
                }

                let do_print_expr = |tokens: &mut TokenStream| {
                    if let Some(start) = &e.start {
                        let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_operator(
                            start,
                            true,
                            false,
                            Precedence::Range,
                        );
                        print_subexpression(start, left_prec <= Precedence::Range, tokens, left_fixup);
                    }
                    e.limits.to_tokens(tokens);
                    if let Some(end) = &e.end {
                        let right_fixup =
                            fixup.rightmost_subexpression_fixup(false, true, Precedence::Range);
                        let right_prec = right_fixup.rightmost_subexpression_precedence(end);
                        print_subexpression(end, right_prec <= Precedence::Range, tokens, right_fixup);
                    }
                };

                if needs_group {
                    token::Paren::default().surround(tokens, do_print_expr);
                } else {
                    do_print_expr(tokens);
                }
            }

                impl ToTokens for ExprRawAddr {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_raw_addr(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_raw_addr(e: &ExprRawAddr, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.and_token.to_tokens(tokens);
                e.raw.to_tokens(tokens);
                e.mutability.to_tokens(tokens);
                let (right_prec, right_fixup) = fixup.rightmost_subexpression(&e.expr, Precedence::Prefix);
                print_subexpression(
                    &e.expr,
                    right_prec < Precedence::Prefix,
                    tokens,
                    right_fixup,
                );
            }

            impl ToTokens for ExprReference {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_reference(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_reference(e: &ExprReference, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.and_token.to_tokens(tokens);
                e.mutability.to_tokens(tokens);
                let (right_prec, right_fixup) = fixup.rightmost_subexpression(
                    &e.expr,
                                Precedence::Prefix,
                );
                print_subexpression(
                    &e.expr,
                    right_prec < Precedence::Prefix,
                    tokens,
                    right_fixup,
                );
            }

                impl ToTokens for ExprRepeat {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.bracket_token.surround(tokens, |tokens| {
                        self.expr.to_tokens(tokens);
                        self.semi_token.to_tokens(tokens);
                        self.len.to_tokens(tokens);
                    });
                }
            }

                impl ToTokens for ExprReturn {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_return(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_return(e: &ExprReturn, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.return_token.to_tokens(tokens);
                if let Some(expr) = &e.expr {
                    print_expr(
                        expr,
                        tokens,
                        fixup.rightmost_subexpression_fixup(true, false, Precedence::Jump),
                    );
                }
            }

            impl ToTokens for ExprStruct {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::Expr);
                    self.brace_token.surround(tokens, |tokens| {
                        self.fields.to_tokens(tokens);
                        if let Some(dot2_token) = &self.dot2_token {
                            dot2_token.to_tokens(tokens);
                        } else if self.rest.is_some() {
                            Token![..](Span::call_site()).to_tokens(tokens);
                        }
                        self.rest.to_tokens(tokens);
                    });
                }
            }

                impl ToTokens for ExprTry {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_try(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_try(e: &ExprTry, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                let (left_prec, left_fixup) = fixup.leftmost_subexpression_with_dot(&e.expr);
                print_subexpression(
                    &e.expr,
                    left_prec < Precedence::Unambiguous,
                    tokens,
                    left_fixup,
                );
                e.question_token.to_tokens(tokens);
            }

                impl ToTokens for ExprTryBlock {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.try_token.to_tokens(tokens);
                    self.block.to_tokens(tokens);
                }
            }

            impl ToTokens for ExprTuple {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.paren_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                       
                       
                        if self.elems.len() == 1 && !self.elems.trailing_punct() {
                            <Token![,]>::default().to_tokens(tokens);
                        }
                    });
                }
            }

            impl ToTokens for ExprUnary {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_unary(self, tokens, FixupContext::NONE);
                }
            }

            fn print_expr_unary(e: &ExprUnary, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.op.to_tokens(tokens);
                let (right_prec, right_fixup) = fixup.rightmost_subexpression(
                    &e.expr,
                                Precedence::Prefix,
                );
                print_subexpression(
                    &e.expr,
                    right_prec < Precedence::Prefix,
                    tokens,
                    right_fixup,
                );
            }

                impl ToTokens for ExprUnsafe {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.unsafe_token.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }

                impl ToTokens for ExprWhile {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.label.to_tokens(tokens);
                    self.while_token.to_tokens(tokens);
                    print_expr(&self.cond, tokens, FixupContext::new_condition());
                    self.body.brace_token.surround(tokens, |tokens| {
                        inner_attrs_to_tokens(&self.attrs, tokens);
                        tokens.append_all(&self.body.stmts);
                    });
                }
            }

                impl ToTokens for ExprYield {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_expr_yield(self, tokens, FixupContext::NONE);
                }
            }

                fn print_expr_yield(e: &ExprYield, tokens: &mut TokenStream, fixup: FixupContext) {
                outer_attrs_to_tokens(&e.attrs, tokens);
                e.yield_token.to_tokens(tokens);
                if let Some(expr) = &e.expr {
                    print_expr(
                        expr,
                        tokens,
                        fixup.rightmost_subexpression_fixup(true, false, Precedence::Jump),
                    );
                }
            }

                impl ToTokens for Arm {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(&self.attrs);
                    self.pat.to_tokens(tokens);
                    if let Some((if_token, guard)) = &self.guard {
                        if_token.to_tokens(tokens);
                        guard.to_tokens(tokens);
                    }
                    self.fat_arrow_token.to_tokens(tokens);
                    print_expr(&self.body, tokens, FixupContext::new_match_arm());
                    self.comma.to_tokens(tokens);
                }
            }

            impl ToTokens for FieldValue {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    outer_attrs_to_tokens(&self.attrs, tokens);
                    self.member.to_tokens(tokens);
                    if let Some(colon_token) = &self.colon_token {
                        colon_token.to_tokens(tokens);
                        self.expr.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for Index {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    let mut lit = Literal::i64_unsuffixed(i64::from(self.index));
                    lit.set_span(self.span);
                    tokens.append(lit);
                }
            }

                impl ToTokens for Label {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.name.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                }
            }

            impl ToTokens for Member {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        Member::Named(ident) => ident.to_tokens(tokens),
                        Member::Unnamed(index) => index.to_tokens(tokens),
                    }
                }
            }

                impl ToTokens for RangeLimits {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        RangeLimits::HalfOpen(t) => t.to_tokens(tokens),
                        RangeLimits::Closed(t) => t.to_tokens(tokens),
                    }
                }
            }

                impl ToTokens for PointerMutability {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        PointerMutability::Const(const_token) => const_token.to_tokens(tokens),
                        PointerMutability::Mut(mut_token) => mut_token.to_tokens(tokens),
                    }
                }
            }
        }
    }
    
    pub use ::syntax::expr::
    {
        Arm, Label, PointerMutability, RangeLimits, Expr, ExprBinary, ExprCall, ExprCast, ExprField, ExprIndex, 
        ExprLit, ExprMacro, ExprMethodCall, ExprParen, ExprPath, ExprReference, ExprStruct, ExprUnary, FieldValue, 
        Index, Member, ExprArray, ExprAssign, ExprAsync, ExprAwait, ExprBlock, ExprBreak, ExprClosure, ExprConst,
        ExprContinue, ExprForLoop, ExprGroup, ExprIf, ExprInfer, ExprLet, ExprLoop, ExprMatch, ExprRange,
        ExprRawAddr, ExprRepeat, ExprReturn, ExprTry, ExprTryBlock, ExprTuple, ExprUnsafe, ExprWhile, ExprYield,
    };
    
    pub mod ext
    {
        //! Extension traits to provide parsing methods on foreign types.
        use ::
        {
            process::macros::Ident,
            syntax::
            {
                buffer::Cursor,
                error::Result,
                parse::ParseStream,
                parse::Peek,
                sealed::lookahead,
                token::CustomToken,
            },
            *,
        };
        /*
        */
        /// Additional methods for `Ident` not provided by proc-macro2 or libproc_macro.
        pub trait IdentExt: Sized + private::Sealed {
            /// Parses any identifier including keywords.
            fn parse_any(input: ParseStream) -> Result<Self>;

            /// Peeks any identifier including keywords.
            const peek_any: private::PeekFn = private::PeekFn;

            /// Strips the raw marker `r#`, if any, from the beginning of an ident.
            /// invalid identifiers like `__pyo3_get_r#move`.
            /// use syn::Ident;
            /// use syn::ext::IdentExt;
            ///
            /// fn ident_for_getter(variable: &Ident) -> Ident {
            ///     let getter = format!("__pyo3_get_{}", variable.unraw());
            ///     Ident::new(&getter, Span::call_site())
            /// }
            /// ```
            fn unraw(&self) -> Ident;
        }

        impl IdentExt for Ident {
            fn parse_any(input: ParseStream) -> Result<Self> {
                input.step(|cursor| match cursor.ident() {
                    Some((ident, rest)) => Ok((ident, rest)),
                    None => Err(cursor.error("expected ident")),
                })
            }

            fn unraw(&self) -> Ident {
                let string = self.to_string();
                if let Some(string) = string.strip_prefix("r#") {
                    Ident::new(string, self.span())
                } else {
                    self.clone()
                }
            }
        }

        impl Peek for private::PeekFn {
            type Token = private::IdentAny;
        }

        impl CustomToken for private::IdentAny {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.ident().is_some()
            }

            fn display() -> &'static str {
                "identifier"
            }
        }

        impl lookahead::Sealed for private::PeekFn {}

        mod private {
            use ::process::macros::Ident;

            pub trait Sealed {}

            impl Sealed for Ident {}

            pub struct PeekFn;
            pub struct IdentAny;

            impl Copy for PeekFn {}
            impl Clone for PeekFn {
                fn clone(&self) -> Self {
                    *self
                }
            }
        }
    }
    
    pub mod file
    {
        use ::
        {
            syntax::
            {
                attr::{ Attribute },
                item::{ Item },
            },
            *,
        };
        /*
        */
        ast_struct!
        {
            /// A complete file of Rust source code.
            ///
            /// # Example
            ///
            /// Parse a Rust source file into a `syn::File` and print out a debug
            /// representation of the syntax tree.
            /// use std::fs;
            /// use std::process;
            ///
            /// fn main() {
            /// # }
            /// #
            /// # fn fake_main() {
            ///     let mut args = env::args();
            ///     let _ = args.next();
            ///
            ///     let filename = match (args.next(), args.next()) {
            ///         (Some(filename), None) => filename,
            ///         _ => {
            ///             eprintln!("Usage: dump-syntax path/to/filename.rs");
            ///             process::exit(1);
            ///         }
            ///     };
            ///
            ///     let src = fs::read_to_string(&filename).expect("unable to read file");
            ///     let syntax = syn::parse_file(&src).expect("unable to parse file");
            ///
            ///    
            ///     println!("{:#?}", syntax);
            /// }
            /// ```
            ///
            /// Running with its own source code as input, this program prints output
            /// that begins with:
            ///
            /// ```text
            /// File {
            ///     shebang: None,
            ///     attrs: [],
            ///     items: [
            ///         Use(
            ///             ItemUse {
            ///                 attrs: [],
            ///                 vis: Inherited,
            ///                 use_token: Use,
            ///                 leading_colon: None,
            ///                 tree: Path(
            ///                     UsePath {
            ///                         ident: Ident(
            ///                             std,
            ///                         ),
            ///                         colon2_token: Colon2,
            ///                         tree: Name(
            ///                             UseName {
            ///                                 ident: Ident(
            ///                                     env,
            ///                                 ),
            ///                             },
            ///                         ),
            ///                     },
            ///                 ),
            ///                 semi_token: Semi,
            ///             },
            ///         ),
            /// ...
            /// ```
            pub struct File {
                pub shebang: Option<String>,
                pub attrs: Vec<Attribute>,
                pub items: Vec<Item>,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    attr::Attribute,
                    error::Result,
                    file::File,
                    parse::{Parse, ParseStream},
                },
                *,
            };
            
            impl Parse for File
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (File {
                        shebang: None,
                        attrs: input.call(Attribute::parse_inner)?,
                        items: {
                            let mut items = Vec::new();
                            while !input.is_empty() {
                                items.push(input.parse()?);
                            }
                            items
                        },
                    })
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    attr::FilterAttrs,
                    file::File,
                },
                *,
            };
            
            impl ToTokens for File {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.inner());
                    tokens.append_all(&self.items);
                }
            }
        }
    } pub use self::file::{ File };
    
    pub mod fixup
    {
        use ::
        {
            syntax::
            {
                expr::{ Expr, ExprBreak, ExprRange, ExprRawAddr, ExprReference, ExprReturn, ExprUnary, ExprYield },
                precedence::{ Precedence },
                ty::{ ReturnType },
                classify
            },
            *,
        };
        /*
        */
        pub struct FixupContext
        {
                previous_operator: Precedence,
                next_operator: Precedence,

           
           
            //
           
           
            //
           
            //
           
            //
                stmt: bool,

           
            //
           
            //
           
            //
           
           
           
            //
           
            //
           
            //
           
            //
           
            //
           
            //
           
           
           
            //
           
            //
           
            //
           
                leftmost_subexpression_in_stmt: bool,

           
            //
           
           
           
           
            //
           
            //
           
           
           
            //
                match_arm: bool,

           
           
            //
           
           
           
            //
           
            //
           
           
           
            //
                leftmost_subexpression_in_match_arm: bool,

           
            //
           
            //
           
           
           
            //
                condition: bool,

           
            //
           
            //
           
            //
                rightmost_subexpression_in_condition: bool,

           
            //
           
            //
           
            //
                leftmost_subexpression_in_optional_operand: bool,

           
            //
           
            //
           
            //
                next_operator_can_begin_expr: bool,

           
            //
           
            //
           
            //
                next_operator_can_continue_expr: bool,

           
            //
           
            //
           
            //
           
            next_operator_can_begin_generics: bool,
        }

        impl FixupContext 
        {
            /// The default amount of fixing is minimal fixing. Fixups should be turned
            /// on in a targeted fashion where needed.
            pub const NONE: Self = FixupContext {
                        previous_operator: Precedence::MIN,
                        next_operator: Precedence::MIN,
                        stmt: false,
                        leftmost_subexpression_in_stmt: false,
                        match_arm: false,
                        leftmost_subexpression_in_match_arm: false,
                        condition: false,
                        rightmost_subexpression_in_condition: false,
                        leftmost_subexpression_in_optional_operand: false,
                        next_operator_can_begin_expr: false,
                        next_operator_can_continue_expr: false,
                next_operator_can_begin_generics: false,
            };

            /// Create the initial fixup for printing an expression in statement
            /// position.
                pub fn new_stmt() -> Self {
                FixupContext {
                    stmt: true,
                    ..FixupContext::NONE
                }
            }
            /// Create the initial fixup for printing an expression as the right-hand
            /// side of a match arm.
                pub fn new_match_arm() -> Self {
                FixupContext {
                    match_arm: true,
                    ..FixupContext::NONE
                }
            }
            /// Create the initial fixup for printing an expression as the "condition"
            /// of an `if` or `while`. There are a few other positions which are
            /// grammatically equivalent and also use this, such as the iterator
            /// expression in `for` and the scrutinee in `match`.
                pub fn new_condition() -> Self {
                FixupContext {
                    condition: true,
                    rightmost_subexpression_in_condition: true,
                    ..FixupContext::NONE
                }
            }
            /// Transform this fixup into the one that should apply when printing the
            /// leftmost subexpression of the current expression.
            ///
            /// For example in `$a + $b` and `$a.method()`, the subexpression `$a` is a
            /// leftmost subexpression.
            pub fn leftmost_subexpression_with_operator(
                self,
                expr: &Expr,
                #[cfg(feature = "full")] next_operator_can_begin_expr: bool,
                next_operator_can_begin_generics: bool,
                #[cfg(feature = "full")] precedence: Precedence,
            ) -> (Precedence, Self) {
                let fixup = FixupContext {
                                next_operator: precedence,
                                stmt: false,
                                leftmost_subexpression_in_stmt: self.stmt || self.leftmost_subexpression_in_stmt,
                                match_arm: false,
                                leftmost_subexpression_in_match_arm: self.match_arm
                        || self.leftmost_subexpression_in_match_arm,
                                rightmost_subexpression_in_condition: false,
                                next_operator_can_begin_expr,
                                next_operator_can_continue_expr: true,
                    next_operator_can_begin_generics,
                    ..self
                };

                (fixup.leftmost_subexpression_precedence(expr), fixup)
            }
            /// Transform this fixup into the one that should apply when printing a
            /// leftmost subexpression followed by a `.` or `?` token, which confer
            /// different statement boundary rules compared to other leftmost
            /// subexpressions.
            pub fn leftmost_subexpression_with_dot(self, expr: &Expr) -> (Precedence, Self) {
                let fixup = FixupContext {
                                next_operator: Precedence::Unambiguous,
                                stmt: self.stmt || self.leftmost_subexpression_in_stmt,
                                leftmost_subexpression_in_stmt: false,
                                match_arm: self.match_arm || self.leftmost_subexpression_in_match_arm,
                                leftmost_subexpression_in_match_arm: false,
                                rightmost_subexpression_in_condition: false,
                                next_operator_can_begin_expr: false,
                                next_operator_can_continue_expr: true,
                    next_operator_can_begin_generics: false,
                    ..self
                };

                (fixup.leftmost_subexpression_precedence(expr), fixup)
            }

            fn leftmost_subexpression_precedence(self, expr: &Expr) -> Precedence {
                        if !self.next_operator_can_begin_expr || self.next_operator == Precedence::Range {
                    if let Scan::Bailout = scan_right(expr, self, Precedence::MIN, 0, 0) {
                        if scan_left(expr, self) {
                            return Precedence::Unambiguous;
                        }
                    }
                }

                self.precedence(expr)
            }
            /// Transform this fixup into the one that should apply when printing the
            /// rightmost subexpression of the current expression.
            ///
            /// For example in `$a + $b` and `-$b`, the subexpression `$b` is a
            /// rightmost subexpression.
            pub fn rightmost_subexpression(
                self,
                expr: &Expr,
                #[cfg(feature = "full")] precedence: Precedence,
            ) -> (Precedence, Self) {
                let fixup = self.rightmost_subexpression_fixup(
                                false,
                                false,
                                precedence,
                );
                (fixup.rightmost_subexpression_precedence(expr), fixup)
            }

            pub fn rightmost_subexpression_fixup(
                self,
                #[cfg(feature = "full")] reset_allow_struct: bool,
                #[cfg(feature = "full")] optional_operand: bool,
                #[cfg(feature = "full")] precedence: Precedence,
            ) -> Self {
                FixupContext {
                                previous_operator: precedence,
                                stmt: false,
                                leftmost_subexpression_in_stmt: false,
                                match_arm: false,
                                leftmost_subexpression_in_match_arm: false,
                                condition: self.condition && !reset_allow_struct,
                                leftmost_subexpression_in_optional_operand: self.condition && optional_operand,
                    ..self
                }
            }

            pub fn rightmost_subexpression_precedence(self, expr: &Expr) -> Precedence {
                let default_prec = self.precedence(expr);

                        if match self.previous_operator {
                    Precedence::Assign | Precedence::Let | Precedence::Prefix => {
                        default_prec < self.previous_operator
                    }
                    _ => default_prec <= self.previous_operator,
                } && match self.next_operator {
                    Precedence::Range | Precedence::Or | Precedence::And => true,
                    _ => !self.next_operator_can_begin_expr,
                } {
                    if let Scan::Bailout | Scan::Fail = scan_right(expr, self, self.previous_operator, 1, 0)
                    {
                        if scan_left(expr, self) {
                            return Precedence::Prefix;
                        }
                    }
                }

                default_prec
            }
            /// Determine whether parentheses are needed around the given expression to
            /// head off the early termination of a statement or condition.
                pub fn parenthesize(self, expr: &Expr) -> bool
        {
                (self.leftmost_subexpression_in_stmt && !classify::requires_semi_to_be_stmt(expr))
                    || ((self.stmt || self.leftmost_subexpression_in_stmt) && matches!(expr, Expr::Let(_)))
                    || (self.leftmost_subexpression_in_match_arm
                        && !classify::requires_comma_to_be_match_arm(expr))
                    || (self.condition && matches!(expr, Expr::Struct(_)))
                    || (self.rightmost_subexpression_in_condition
                        && matches!(
                            expr,
                            Expr::Return(ExprReturn { expr: None, .. })
                                | Expr::Yield(ExprYield { expr: None, .. })
                        ))
                    || (self.rightmost_subexpression_in_condition
                        && !self.condition
                        && matches!(
                            expr,
                            Expr::Break(ExprBreak { expr: None, .. })
                                | Expr::Path(_)
                                | Expr::Range(ExprRange { end: None, .. })
                        ))
                    || (self.leftmost_subexpression_in_optional_operand
                        && matches!(expr, Expr::Block(expr) if expr.attrs.is_empty() && expr.label.is_none()))
            }
            /// Determines the effective precedence of a subexpression. Some expressions
            /// have higher or lower precedence when adjacent to particular operators.
            fn precedence(self, expr: &Expr) -> Precedence {
                        if self.next_operator_can_begin_expr {
                   
                   
                   
                    if let Expr::Break(ExprBreak { expr: None, .. })
                    | Expr::Return(ExprReturn { expr: None, .. })
                    | Expr::Yield(ExprYield { expr: None, .. }) = expr
                    {
                        return Precedence::Jump;
                    }
                }

                        if !self.next_operator_can_continue_expr {
                    match expr {
                       
                       
                        Expr::Break(_)
                        | Expr::Closure(_)
                        | Expr::Let(_)
                        | Expr::Return(_)
                        | Expr::Yield(_) => {
                            return Precedence::Prefix;
                        }
                        Expr::Range(e) if e.start.is_none() => return Precedence::Prefix,
                        _ => {}
                    }
                }

                if self.next_operator_can_begin_generics {
                    if let Expr::Cast(cast) = expr {
                        if classify::trailing_unparameterized_path(&cast.ty) {
                            return Precedence::MIN;
                        }
                    }
                }

                Precedence::of(expr)
            }
        }

        impl Copy for FixupContext {}

        impl Clone for FixupContext 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        enum Scan 
        {
            Fail,
            Bailout,
            Consume,
        }

        impl Copy for Scan {}

        impl Clone for Scan 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl PartialEq for Scan 
        {
            fn eq(&self, other: &Self) -> bool
        {
                *self as u8 == *other as u8
            }
        }

        fn scan_left(expr: &Expr, fixup: FixupContext) -> bool 
        {
            match expr {
                Expr::Assign(_) => fixup.previous_operator <= Precedence::Assign,
                Expr::Binary(e) => match Precedence::of_binop(&e.op) {
                    Precedence::Assign => fixup.previous_operator <= Precedence::Assign,
                    binop_prec => fixup.previous_operator < binop_prec,
                },
                Expr::Cast(_) => fixup.previous_operator < Precedence::Cast,
                Expr::Range(e) => e.start.is_none() || fixup.previous_operator < Precedence::Assign,
                _ => true,
            }
        }

        fn scan_right
        (
            expr: &Expr,
            fixup: FixupContext,
            precedence: Precedence,
            fail_offset: u8,
            bailout_offset: u8,
        ) -> Scan 
        {
            let consume_by_precedence = if match precedence {
                Precedence::Assign | Precedence::Compare => precedence <= fixup.next_operator,
                _ => precedence < fixup.next_operator,
            } || fixup.next_operator == Precedence::MIN
            {
                Scan::Consume
            } else {
                Scan::Bailout
            };
            if fixup.parenthesize(expr) {
                return consume_by_precedence;
            }
            match expr {
                Expr::Assign(e) if e.attrs.is_empty() =>
                {
                    if match fixup.next_operator {
                        Precedence::Unambiguous => fail_offset >= 2,
                        _ => bailout_offset >= 1,
                    } {
                        return Scan::Consume;
                    }
                    let right_fixup = fixup.rightmost_subexpression_fixup(false, false, Precedence::Assign);
                    let scan = scan_right(
                        &e.right,
                        right_fixup,
                        Precedence::Assign,
                        match fixup.next_operator {
                            Precedence::Unambiguous => fail_offset,
                            _ => 1,
                        },
                        1,
                    );
                    if let Scan::Bailout | Scan::Consume = scan {
                        Scan::Consume
                    } else if let Precedence::Unambiguous = fixup.next_operator {
                        Scan::Fail
                    } else {
                        Scan::Bailout
                    }
                }
                Expr::Binary(e) if e.attrs.is_empty() =>
                {
                    if match fixup.next_operator {
                        Precedence::Unambiguous => {
                            fail_offset >= 2
                                && (consume_by_precedence == Scan::Consume || bailout_offset >= 1)
                        }
                        _ => bailout_offset >= 1,
                    } {
                        return Scan::Consume;
                    }
                    let binop_prec = Precedence::of_binop(&e.op);
                    if binop_prec == Precedence::Compare && fixup.next_operator == Precedence::Compare {
                        return Scan::Consume;
                    }
                    let right_fixup = fixup.rightmost_subexpression_fixup(false, false, binop_prec);
                    let scan = scan_right(
                        &e.right,
                        right_fixup,
                        binop_prec,
                        match fixup.next_operator {
                            Precedence::Unambiguous => fail_offset,
                            _ => 1,
                        },
                        consume_by_precedence as u8 - Scan::Bailout as u8,
                    );
                    match scan {
                        Scan::Fail => {}
                        Scan::Bailout => return consume_by_precedence,
                        Scan::Consume => return Scan::Consume,
                    }
                    let right_needs_group = binop_prec != Precedence::Assign
                        && right_fixup.rightmost_subexpression_precedence(&e.right) <= binop_prec;
                    if right_needs_group {
                        consume_by_precedence
                    } else if let (Scan::Fail, Precedence::Unambiguous) = (scan, fixup.next_operator) {
                        Scan::Fail
                    } else {
                        Scan::Bailout
                    }
                }
                Expr::RawAddr(ExprRawAddr { expr, .. })
                | Expr::Reference(ExprReference { expr, .. })
                | Expr::Unary(ExprUnary { expr, .. }) =>
                {
                    if match fixup.next_operator {
                        Precedence::Unambiguous => {
                            fail_offset >= 2
                                && (consume_by_precedence == Scan::Consume || bailout_offset >= 1)
                        }
                        _ => bailout_offset >= 1,
                    } {
                        return Scan::Consume;
                    }
                    let right_fixup = fixup.rightmost_subexpression_fixup(false, false, Precedence::Prefix);
                    let scan = scan_right(
                        expr,
                        right_fixup,
                        precedence,
                        match fixup.next_operator {
                            Precedence::Unambiguous => fail_offset,
                            _ => 1,
                        },
                        consume_by_precedence as u8 - Scan::Bailout as u8,
                    );
                    match scan {
                        Scan::Fail => {}
                        Scan::Bailout => return consume_by_precedence,
                        Scan::Consume => return Scan::Consume,
                    }
                    if right_fixup.rightmost_subexpression_precedence(expr) < Precedence::Prefix {
                        consume_by_precedence
                    } else if let (Scan::Fail, Precedence::Unambiguous) = (scan, fixup.next_operator) {
                        Scan::Fail
                    } else {
                        Scan::Bailout
                    }
                }
                Expr::Range(e) if e.attrs.is_empty() => match &e.end {
                    Some(end) => {
                        if fail_offset >= 2 {
                            return Scan::Consume;
                        }
                        let right_fixup =
                            fixup.rightmost_subexpression_fixup(false, true, Precedence::Range);
                        let scan = scan_right(
                            end,
                            right_fixup,
                            Precedence::Range,
                            fail_offset,
                            match fixup.next_operator {
                                Precedence::Assign | Precedence::Range => 0,
                                _ => 1,
                            },
                        );
                        if match (scan, fixup.next_operator) {
                            (Scan::Fail, _) => false,
                            (Scan::Bailout, Precedence::Assign | Precedence::Range) => false,
                            (Scan::Bailout | Scan::Consume, _) => true,
                        } {
                            return Scan::Consume;
                        }
                        if right_fixup.rightmost_subexpression_precedence(end) <= Precedence::Range {
                            Scan::Consume
                        } else {
                            Scan::Fail
                        }
                    }
                    None => {
                        if fixup.next_operator_can_begin_expr {
                            Scan::Consume
                        } else {
                            Scan::Fail
                        }
                    }
                },
                Expr::Break(e) => match &e.expr {
                    Some(value) => {
                        if bailout_offset >= 1 || e.label.is_none() && classify::expr_leading_label(value) {
                            return Scan::Consume;
                        }
                        let right_fixup = fixup.rightmost_subexpression_fixup(true, true, Precedence::Jump);
                        match scan_right(value, right_fixup, Precedence::Jump, 1, 1) {
                            Scan::Fail => Scan::Bailout,
                            Scan::Bailout | Scan::Consume => Scan::Consume,
                        }
                    }
                    None => match fixup.next_operator {
                        Precedence::Assign if precedence > Precedence::Assign => Scan::Fail,
                        _ => Scan::Consume,
                    },
                },
                Expr::Return(ExprReturn { expr, .. }) | Expr::Yield(ExprYield { expr, .. }) => match expr {
                    Some(e) => {
                        if bailout_offset >= 1 {
                            return Scan::Consume;
                        }
                        let right_fixup =
                            fixup.rightmost_subexpression_fixup(true, false, Precedence::Jump);
                        match scan_right(e, right_fixup, Precedence::Jump, 1, 1) {
                            Scan::Fail => Scan::Bailout,
                            Scan::Bailout | Scan::Consume => Scan::Consume,
                        }
                    }
                    None => match fixup.next_operator {
                        Precedence::Assign if precedence > Precedence::Assign => Scan::Fail,
                        _ => Scan::Consume,
                    },
                },
                Expr::Closure(e) =>
                {
                    if matches!(e.output, ReturnType::Default)
                        || matches!(&*e.body, Expr::Block(body) if body.attrs.is_empty() && body.label.is_none())
                    {
                        if bailout_offset >= 1 {
                            return Scan::Consume;
                        }
                        let right_fixup =
                            fixup.rightmost_subexpression_fixup(false, false, Precedence::Jump);
                        match scan_right(&e.body, right_fixup, Precedence::Jump, 1, 1) {
                            Scan::Fail => Scan::Bailout,
                            Scan::Bailout | Scan::Consume => Scan::Consume,
                        }
                    } else {
                        Scan::Consume
                    }
                }
                Expr::Let(e) =>
                {
                    if bailout_offset >= 1 {
                        return Scan::Consume;
                    }
                    let right_fixup = fixup.rightmost_subexpression_fixup(false, false, Precedence::Let);
                    let scan = scan_right(
                        &e.expr,
                        right_fixup,
                        Precedence::Let,
                        1,
                        if fixup.next_operator < Precedence::Let {
                            0
                        } else {
                            1
                        },
                    );
                    match scan {
                        Scan::Fail | Scan::Bailout if fixup.next_operator < Precedence::Let => {
                            return Scan::Bailout;
                        }
                        Scan::Consume => return Scan::Consume,
                        _ => {}
                    }
                    if right_fixup.rightmost_subexpression_precedence(&e.expr) < Precedence::Let {
                        Scan::Consume
                    } else if let Scan::Fail = scan {
                        Scan::Bailout
                    } else {
                        Scan::Consume
                    }
                }
                Expr::Array(_)
                | Expr::Assign(_)
                | Expr::Async(_)
                | Expr::Await(_)
                | Expr::Binary(_)
                | Expr::Block(_)
                | Expr::Call(_)
                | Expr::Cast(_)
                | Expr::Const(_)
                | Expr::Continue(_)
                | Expr::Field(_)
                | Expr::ForLoop(_)
                | Expr::Group(_)
                | Expr::If(_)
                | Expr::Index(_)
                | Expr::Infer(_)
                | Expr::Lit(_)
                | Expr::Loop(_)
                | Expr::Macro(_)
                | Expr::Match(_)
                | Expr::MethodCall(_)
                | Expr::Paren(_)
                | Expr::Path(_)
                | Expr::Range(_)
                | Expr::Repeat(_)
                | Expr::Struct(_)
                | Expr::Try(_)
                | Expr::TryBlock(_)
                | Expr::Tuple(_)
                | Expr::Unsafe(_)
                | Expr::Verbatim(_)
                | Expr::While(_) => match fixup.next_operator {
                    Precedence::Assign | Precedence::Range if precedence == Precedence::Range => Scan::Fail,
                    _ if precedence == Precedence::Let && fixup.next_operator < Precedence::Let => {
                        Scan::Fail
                    }
                    _ => consume_by_precedence,
                },
            }
        }
    }
    
    pub mod generics
    {
        use ::
        {
            fmt::{self, Debug},
            hash::{Hash, Hasher},
            process::macros::{ TokenStream },
            syntax::
            {
                attr::Attribute,
                expr::Expr,
                ident::Ident,
                lifetime::Lifetime,
                path::Path,
                punctuated::{ Iter, IterMut, Punctuated },
                token,
                ty::Type,
            },
            *,
        };
        /*        
        */
        ast_struct! 
        {
            /// Lifetimes and type parameters attached to a declaration of a function,
            /// enum, trait, etc.
            /// grammar, there may be other tokens in between these two things.
            pub struct Generics {
                pub lt_token: Option<Token![<]>,
                pub params: Punctuated<GenericParam, Token![,]>,
                pub gt_token: Option<Token![>]>,
                pub where_clause: Option<WhereClause>,
            }
        }

        ast_enum_of_structs! 
        {
            /// A generic type parameter, lifetime, or const generic: `T: Into<String>`,
            /// `'a: 'b`, `const LEN: usize`.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            pub enum GenericParam {
                /// A lifetime parameter: `'a: 'b + 'c + 'd`.
                Lifetime(LifetimeParam),
                /// A generic type parameter: `T: Into<String>`.
                Type(TypeParam),
                /// A const generic parameter: `const LENGTH: usize`.
                Const(ConstParam),
            }
        }

        ast_struct! 
        {
            /// A lifetime definition: `'a: 'b + 'c + 'd`.
            pub struct LifetimeParam {
                pub attrs: Vec<Attribute>,
                pub lifetime: Lifetime,
                pub colon_token: Option<Token![:]>,
                pub bounds: Punctuated<Lifetime, Token![+]>,
            }
        }

        ast_struct! 
        {
            /// A generic type parameter: `T: Into<String>`.
            pub struct TypeParam {
                pub attrs: Vec<Attribute>,
                pub ident: Ident,
                pub colon_token: Option<Token![:]>,
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
                pub eq_token: Option<Token![=]>,
                pub default: Option<Type>,
            }
        }

        ast_struct! 
        {
            /// A const generic parameter: `const LENGTH: usize`.
            pub struct ConstParam {
                pub attrs: Vec<Attribute>,
                pub const_token: Token![const],
                pub ident: Ident,
                pub colon_token: Token![:],
                pub ty: Type,
                pub eq_token: Option<Token![=]>,
                pub default: Option<Expr>,
            }
        }

        impl Default for Generics
        {
            fn default() -> Self {
                Generics {
                    lt_token: None,
                    params: Punctuated::new(),
                    gt_token: None,
                    where_clause: None,
                }
            }
        }

        impl Generics
        {
            return_impl_trait! 
            {
                /// Iterator over the lifetime parameters in `self.params`.
                pub fn lifetimes(&self) -> impl Iterator<Item = &LifetimeParam> [Lifetimes] {
                    Lifetimes(self.params.iter())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the lifetime parameters in `self.params`.
                pub fn lifetimes_mut(&mut self) -> impl Iterator<Item = &mut LifetimeParam> [LifetimesMut] {
                    LifetimesMut(self.params.iter_mut())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the type parameters in `self.params`.
                pub fn type_params(&self) -> impl Iterator<Item = &TypeParam> [TypeParams] {
                    TypeParams(self.params.iter())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the type parameters in `self.params`.
                pub fn type_params_mut(&mut self) -> impl Iterator<Item = &mut TypeParam> [TypeParamsMut] {
                    TypeParamsMut(self.params.iter_mut())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the constant parameters in `self.params`.
                pub fn const_params(&self) -> impl Iterator<Item = &ConstParam> [ConstParams] {
                    ConstParams(self.params.iter())
                }
            }

            return_impl_trait! 
            {
                /// Iterator over the constant parameters in `self.params`.
                pub fn const_params_mut(&mut self) -> impl Iterator<Item = &mut ConstParam> [ConstParamsMut] {
                    ConstParamsMut(self.params.iter_mut())
                }
            }
            /// Initializes an empty `where`-clause if there is not one present already.
            pub fn make_where_clause(&mut self) -> &mut WhereClause
            {
                self.where_clause.get_or_insert_with(|| WhereClause {
                    where_token: <Token![where]>::default(),
                    predicates: Punctuated::new(),
                })
            }
            /// Split a type's generics into the pieces required for impl'ing a trait for that type.
            pub fn split_for_impl(&self) -> (ImplGenerics, TypeGenerics, Option<&WhereClause>) {
                (
                    ImplGenerics(self),
                    TypeGenerics(self),
                    self.where_clause.as_ref(),
                )
            }
        }

        pub struct Lifetimes<'a>(Iter<'a, GenericParam>);

        impl<'a> Iterator for Lifetimes<'a> {
            type Item = &'a LifetimeParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Lifetime(lifetime) = self.0.next()? {
                    Some(lifetime)
                } else {
                    self.next()
                }
            }
        }

        pub struct LifetimesMut<'a>(IterMut<'a, GenericParam>);

        impl<'a> Iterator for LifetimesMut<'a> {
            type Item = &'a mut LifetimeParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Lifetime(lifetime) = self.0.next()? {
                    Some(lifetime)
                } else {
                    self.next()
                }
            }
        }

        pub struct TypeParams<'a>(Iter<'a, GenericParam>);

        impl<'a> Iterator for TypeParams<'a> {
            type Item = &'a TypeParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Type(type_param) = self.0.next()? {
                    Some(type_param)
                } else {
                    self.next()
                }
            }
        }

        pub struct TypeParamsMut<'a>(IterMut<'a, GenericParam>);

        impl<'a> Iterator for TypeParamsMut<'a> {
            type Item = &'a mut TypeParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Type(type_param) = self.0.next()? {
                    Some(type_param)
                } else {
                    self.next()
                }
            }
        }

        pub struct ConstParams<'a>(Iter<'a, GenericParam>);

        impl<'a> Iterator for ConstParams<'a> {
            type Item = &'a ConstParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Const(const_param) = self.0.next()? {
                    Some(const_param)
                } else {
                    self.next()
                }
            }
        }

        pub struct ConstParamsMut<'a>(IterMut<'a, GenericParam>);

        impl<'a> Iterator for ConstParamsMut<'a> {
            type Item = &'a mut ConstParam;

            fn next(&mut self) -> Option<Self::Item> {
                if let GenericParam::Const(const_param) = self.0.next()? {
                    Some(const_param)
                } else {
                    self.next()
                }
            }
        }
        /// Returned by `Generics::split_for_impl`.
        pub struct ImplGenerics<'a>(&'a Generics);

        /// Returned by `Generics::split_for_impl`.
        pub struct TypeGenerics<'a>(&'a Generics);

        /// Returned by `TypeGenerics::as_turbofish`.
        pub struct Turbofish<'a>(&'a Generics);
        
        macro_rules! generics_wrapper_impls {
            ($ty:ident) => {
                impl<'a> Clone for $ty<'a> {
                    fn clone(&self) -> Self {
                        $ty(self.0)
                    }
                }

                        impl<'a> Debug for $ty<'a> {
                    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                        formatter
                            .debug_tuple(stringify!($ty))
                            .field(self.0)
                            .finish()
                    }
                }

                        impl<'a> Eq for $ty<'a> {}

                        impl<'a> PartialEq for $ty<'a> {
                    fn eq(&self, other: &Self) -> bool
        {
                        self.0 == other.0
                    }
                }

                        impl<'a> Hash for $ty<'a> {
                    fn hash<H: Hasher>(&self, state: &mut H) {
                        self.0.hash(state);
                    }
                }
            };
        }

        
        generics_wrapper_impls!(ImplGenerics);
                
        generics_wrapper_impls!(TypeGenerics);
                
        generics_wrapper_impls!(Turbofish);
        
        impl<'a> TypeGenerics<'a>
        {
            /// Turn a type's generics like `<X, Y>` into a turbofish like `::<X, Y>`.
            pub fn as_turbofish(&self) -> Turbofish<'a> {
                Turbofish(self.0)
            }
        }

        ast_struct! {
            /// A set of bound lifetimes: `for<'a, 'b, 'c>`.
            pub struct BoundLifetimes {
                pub for_token: Token![for],
                pub lt_token: Token![<],
                pub lifetimes: Punctuated<GenericParam, Token![,]>,
                pub gt_token: Token![>],
            }
        }

        impl Default for BoundLifetimes {
            fn default() -> Self {
                BoundLifetimes {
                    for_token: Default::default(),
                    lt_token: Default::default(),
                    lifetimes: Punctuated::new(),
                    gt_token: Default::default(),
                }
            }
        }

        impl LifetimeParam {
            pub fn new(lifetime: Lifetime) -> Self {
                LifetimeParam {
                    attrs: Vec::new(),
                    lifetime,
                    colon_token: None,
                    bounds: Punctuated::new(),
                }
            }
        }

        impl From<Ident> for TypeParam {
            fn from(ident: Ident) -> Self {
                TypeParam {
                    attrs: vec![],
                    ident,
                    colon_token: None,
                    bounds: Punctuated::new(),
                    eq_token: None,
                    default: None,
                }
            }
        }

        ast_enum_of_structs! {
            /// A trait or lifetime used as a bound on a type parameter.
            #[non_exhaustive]
            pub enum TypeParamBound {
                Trait(TraitBound),
                Lifetime(Lifetime),
                PreciseCapture(PreciseCapture),
                Verbatim(TokenStream),
            }
        }

        ast_struct! {
            /// A trait used as a bound on a type parameter.
            pub struct TraitBound {
                pub paren_token: Option<token::Paren>,
                pub modifier: TraitBoundModifier,
                /// The `for<'a>` in `for<'a> Foo<&'a T>`
                pub lifetimes: Option<BoundLifetimes>,
                /// The `Foo<&'a T>` in `for<'a> Foo<&'a T>`
                pub path: Path,
            }
        }

        ast_enum! {
            /// A modifier on a trait bound, currently only used for the `?` in
            /// `?Sized`.
            pub enum TraitBoundModifier {
                None,
                Maybe(Token![?]),
            }
        }

        ast_struct! {
            /// Precise capturing bound: the 'use&lt;&hellip;&gt;' in `impl Trait +
            /// use<'a, T>`.
            pub struct PreciseCapture #full {
                pub use_token: Token![use],
                pub lt_token: Token![<],
                pub params: Punctuated<CapturedParam, Token![,]>,
                pub gt_token: Token![>],
            }
        }

        ast_enum! {
            /// Single parameter in a precise capturing bound.
            #[non_exhaustive]
            pub enum CapturedParam {
                /// A lifetime parameter in precise capturing bound: `fn f<'a>() -> impl
                /// Trait + use<'a>`.
                Lifetime(Lifetime),
                /// A type parameter or const generic parameter in precise capturing
                /// bound: `fn f<T>() -> impl Trait + use<T>` or `fn f<const K: T>() ->
                /// impl Trait + use<K>`.
                Ident(Ident),
            }
        }

        ast_struct! {
            /// A `where` clause in a definition: `where T: Deserialize<'de>, D:
            /// 'static`.
            pub struct WhereClause {
                pub where_token: Token![where],
                pub predicates: Punctuated<WherePredicate, Token![,]>,
            }
        }

        ast_enum_of_structs! {
            /// A single predicate in a `where` clause: `T: Deserialize<'de>`.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            #[non_exhaustive]
            pub enum WherePredicate {
                /// A lifetime predicate in a `where` clause: `'a: 'b + 'c`.
                Lifetime(PredicateLifetime),
                /// A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.
                Type(PredicateType),
            }
        }

        ast_struct! {
            /// A lifetime predicate in a `where` clause: `'a: 'b + 'c`.
            pub struct PredicateLifetime {
                pub lifetime: Lifetime,
                pub colon_token: Token![:],
                pub bounds: Punctuated<Lifetime, Token![+]>,
            }
        }

        ast_struct! {
            /// A type predicate in a `where` clause: `for<'c> Foo<'c>: Trait<'c>`.
            pub struct PredicateType {
                /// Any lifetimes from a `for` binding
                pub lifetimes: Option<BoundLifetimes>,
                /// The type being bounded
                pub bounded_ty: Type,
                pub colon_token: Token![:],
                /// Trait and lifetime bounds (`Clone+Send+'static`)
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    attr::{ Attribute },
                    error::{ self, Error, Result },
                    ext::{ IdentExt as _ },
                    generics::
                    {
                        BoundLifetimes, ConstParam, GenericParam, Generics, LifetimeParam, PredicateLifetime, 
                        PredicateType, TraitBound, TraitBoundModifier, TypeParam, TypeParamBound, WhereClause, 
                        WherePredicate,
                    },
                    ident::{ Ident },
                    lifetime::{ Lifetime },
                    parse::{ Parse, ParseStream },
                    path::{ self, ParenthesizedGenericArguments, Path, PathArguments },
                    punctuated::{ Punctuated },
                    ty::{ Type },
                    token, verbatim,

                },
                *,
            };
            /*
            */
            impl Parse for Generics
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if !input.peek(Token![<]) {
                        return Ok(Generics::default());
                    }

                    let lt_token: Token![<] = input.parse()?;

                    let mut params = Punctuated::new();
                    loop {
                        if input.peek(Token![>]) {
                            break;
                        }

                        let attrs = input.call(Attribute::parse_outer)?;
                        let lookahead = input.lookahead1();
                        if lookahead.peek(Lifetime) {
                            params.push_value(GenericParam::Lifetime(LifetimeParam {
                                attrs,
                                ..input.parse()?
                            }));
                        } else if lookahead.peek(Ident) {
                            params.push_value(GenericParam::Type(TypeParam {
                                attrs,
                                ..input.parse()?
                            }));
                        } else if lookahead.peek(Token![const]) {
                            params.push_value(GenericParam::Const(ConstParam {
                                attrs,
                                ..input.parse()?
                            }));
                        } else if input.peek(Token![_]) {
                            params.push_value(GenericParam::Type(TypeParam {
                                attrs,
                                ident: input.call(Ident::parse_any)?,
                                colon_token: None,
                                bounds: Punctuated::new(),
                                eq_token: None,
                                default: None,
                            }));
                        } else {
                            return Err(lookahead.error());
                        }

                        if input.peek(Token![>]) {
                            break;
                        }
                        let punct = input.parse()?;
                        params.push_punct(punct);
                    }

                    let gt_token: Token![>] = input.parse()?;

                    Ok(Generics {
                        lt_token: Some(lt_token),
                        params,
                        gt_token: Some(gt_token),
                        where_clause: None,
                    })
                }
            }

            impl Parse for GenericParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;

                    let lookahead = input.lookahead1();
                    if lookahead.peek(Ident) {
                        Ok(GenericParam::Type(TypeParam {
                            attrs,
                            ..input.parse()?
                        }))
                    } else if lookahead.peek(Lifetime) {
                        Ok(GenericParam::Lifetime(LifetimeParam {
                            attrs,
                            ..input.parse()?
                        }))
                    } else if lookahead.peek(Token![const]) {
                        Ok(GenericParam::Const(ConstParam {
                            attrs,
                            ..input.parse()?
                        }))
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            impl Parse for LifetimeParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let has_colon;
                    Ok(LifetimeParam {
                        attrs: input.call(Attribute::parse_outer)?,
                        lifetime: input.parse()?,
                        colon_token: {
                            if input.peek(Token![:]) {
                                has_colon = true;
                                Some(input.parse()?)
                            } else {
                                has_colon = false;
                                None
                            }
                        },
                        bounds: {
                            let mut bounds = Punctuated::new();
                            if has_colon {
                                loop {
                                    if input.peek(Token![,]) || input.peek(Token![>]) {
                                        break;
                                    }
                                    let value = input.parse()?;
                                    bounds.push_value(value);
                                    if !input.peek(Token![+]) {
                                        break;
                                    }
                                    let punct = input.parse()?;
                                    bounds.push_punct(punct);
                                }
                            }
                            bounds
                        },
                    })
                }
            }

            impl Parse for BoundLifetimes
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (BoundLifetimes {
                        for_token: input.parse()?,
                        lt_token: input.parse()?,
                        lifetimes: {
                            let mut lifetimes = Punctuated::new();
                            while !input.peek(Token![>]) {
                                lifetimes.push_value(input.parse()?);
                                if input.peek(Token![>]) {
                                    break;
                                }
                                lifetimes.push_punct(input.parse()?);
                            }
                            lifetimes
                        },
                        gt_token: input.parse()?,
                    })
                }
            }

            impl Parse for Option<BoundLifetimes>
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![for]) {
                        input.parse().map(Some)
                    } else {
                        Ok(None)
                    }
                }
            }

            impl Parse for TypeParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let ident: Ident = input.parse()?;
                    let colon_token: Option<Token![:]> = input.parse()?;

                    let mut bounds = Punctuated::new();
                    if colon_token.is_some() {
                        loop {
                            if input.peek(Token![,]) || input.peek(Token![>]) || input.peek(Token![=]) {
                                break;
                            }
                            bounds.push_value({
                                let allow_precise_capture = false;
                                let allow_const = true;
                                TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                            });
                            if !input.peek(Token![+]) {
                                break;
                            }
                            let punct: Token![+] = input.parse()?;
                            bounds.push_punct(punct);
                        }
                    }

                    let eq_token: Option<Token![=]> = input.parse()?;
                    let default = if eq_token.is_some() {
                        Some(input.parse::<Type>()?)
                    } else {
                        None
                    };

                    Ok(TypeParam {
                        attrs,
                        ident,
                        colon_token,
                        bounds,
                        eq_token,
                        default,
                    })
                }
            }

            impl Parse for TypeParamBound
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_precise_capture = true;
                    let allow_const = true;
                    Self::parse_single(input, allow_precise_capture, allow_const)
                }
            }

            impl TypeParamBound 
            {
                pub fn parse_single(
                    input: ParseStream,
                    #[cfg_attr(not(feature = "full"), allow(unused_variables))] allow_precise_capture: bool,
                    allow_const: bool,
                ) -> Result<Self>
                {
                    if input.peek(Lifetime) {
                        return input.parse().map(TypeParamBound::Lifetime);
                    }

                                {
                        if input.peek(Token![use]) {
                            let precise_capture: PreciseCapture = input.parse()?;
                            return if allow_precise_capture {
                                Ok(TypeParamBound::PreciseCapture(precise_capture))
                            } else {
                                let msg = "`use<...>` precise capturing syntax is not allowed here";
                                Err(error::new2(
                                    precise_capture.use_token.span,
                                    precise_capture.gt_token.span,
                                    msg,
                                ))
                            };
                        }
                    }

                    let begin = input.fork();

                    let content;
                    let (paren_token, content) = if input.peek(token::Paren) {
                        (Some(parenthesized!(content in input)), &content)
                    } else {
                        (None, input)
                    };

                    if let Some(mut bound) = TraitBound::do_parse(content, allow_const)? {
                        bound.paren_token = paren_token;
                        Ok(TypeParamBound::Trait(bound))
                    } else {
                        Ok(TypeParamBound::Verbatim(verbatim::between(&begin, input)))
                    }
                }

                pub fn parse_multiple(
                    input: ParseStream,
                    allow_plus: bool,
                    allow_precise_capture: bool,
                    allow_const: bool,
                ) -> Result<Punctuated<Self, Token![+]>> {
                    let mut bounds = Punctuated::new();
                    loop {
                        let bound = Self::parse_single(input, allow_precise_capture, allow_const)?;
                        bounds.push_value(bound);
                        if !(allow_plus && input.peek(Token![+])) {
                            break;
                        }
                        bounds.push_punct(input.parse()?);
                        if !(input.peek(Ident::peek_any)
                            || input.peek(Token![::])
                            || input.peek(Token![?])
                            || input.peek(Lifetime)
                            || input.peek(token::Paren)
                            || (allow_const && (input.peek(token::Bracket) || input.peek(Token![const]))))
                        {
                            break;
                        }
                    }
                    Ok(bounds)
                }
            }

            impl Parse for TraitBound
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_const = false;
                    Self::do_parse(input, allow_const).map(Option::unwrap)
                }
            }

            impl TraitBound 
            {
                fn do_parse(input: ParseStream, allow_const: bool) -> Result<Option<Self>> {
                    let mut lifetimes: Option<BoundLifetimes> = input.parse()?;

                    let is_conditionally_const = cfg!(feature = "full") && input.peek(token::Bracket);
                    let is_unconditionally_const = cfg!(feature = "full") && input.peek(Token![const]);
                    if is_conditionally_const {
                        let conditionally_const;
                        let bracket_token = bracketed!(conditionally_const in input);
                        conditionally_const.parse::<Token![const]>()?;
                        if !allow_const {
                            let msg = "`[const]` is not allowed here";
                            return Err(Error::new(bracket_token.span.join(), msg));
                        }
                    } else if is_unconditionally_const {
                        let const_token: Token![const] = input.parse()?;
                        if !allow_const {
                            let msg = "`const` is not allowed here";
                            return Err(Error::new(const_token.span, msg));
                        }
                    }

                    let modifier: TraitBoundModifier = input.parse()?;
                    if lifetimes.is_none() && matches!(modifier, TraitBoundModifier::Maybe(_)) {
                        lifetimes = input.parse()?;
                    }

                    let mut path: Path = input.parse()?;
                    if path.segments.last().unwrap().arguments.is_empty()
                        && (input.peek(token::Paren) || input.peek(Token![::]) && input.peek3(token::Paren))
                    {
                        input.parse::<Option<Token![::]>>()?;
                        let args: ParenthesizedGenericArguments = input.parse()?;
                        let parenthesized = PathArguments::Parenthesized(args);
                        path.segments.last_mut().unwrap().arguments = parenthesized;
                    }

                    if lifetimes.is_some() {
                        match modifier {
                            TraitBoundModifier::None => {}
                            TraitBoundModifier::Maybe(maybe) => {
                                let msg = "`for<...>` binder not allowed with `?` trait polarity modifier";
                                return Err(Error::new(maybe.span, msg));
                            }
                        }
                    }

                    if is_conditionally_const || is_unconditionally_const {
                        Ok(None)
                    } else {
                        Ok(Some(TraitBound {
                            paren_token: None,
                            modifier,
                            lifetimes,
                            path,
                        }))
                    }
                }
            }

            impl Parse for TraitBoundModifier
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![?]) {
                        input.parse().map(TraitBoundModifier::Maybe)
                    } else {
                        Ok(TraitBoundModifier::None)
                    }
                }
            }

            impl Parse for ConstParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut default = None;
                    Ok(ConstParam {
                        attrs: input.call(Attribute::parse_outer)?,
                        const_token: input.parse()?,
                        ident: input.parse()?,
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                        eq_token: {
                            if input.peek(Token![=]) {
                                let eq_token = input.parse()?;
                                default = Some(path::parsing::const_argument(input)?);
                                Some(eq_token)
                            } else {
                                None
                            }
                        },
                        default,
                    })
                }
            }

            impl Parse for WhereClause
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let where_token: Token![where] = input.parse()?;

                    if choose_generics_over_qpath(input) {
                        return Err(input
                            .error("generic parameters on `where` clauses are reserved for future use"));
                    }

                    Ok(WhereClause {
                        where_token,
                        predicates: {
                            let mut predicates = Punctuated::new();
                            loop {
                                if input.is_empty()
                                    || input.peek(token::Brace)
                                    || input.peek(Token![,])
                                    || input.peek(Token![;])
                                    || input.peek(Token![:]) && !input.peek(Token![::])
                                    || input.peek(Token![=])
                                {
                                    break;
                                }
                                let value = input.parse()?;
                                predicates.push_value(value);
                                if !input.peek(Token![,]) {
                                    break;
                                }
                                let punct = input.parse()?;
                                predicates.push_punct(punct);
                            }
                            predicates
                        },
                    })
                }
            }

            impl Parse for Option<WhereClause>
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![where]) {
                        input.parse().map(Some)
                    } else {
                        Ok(None)
                    }
                }
            }

            impl Parse for WherePredicate
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Lifetime) && input.peek2(Token![:]) {
                        Ok(WherePredicate::Lifetime(PredicateLifetime {
                            lifetime: input.parse()?,
                            colon_token: input.parse()?,
                            bounds: {
                                let mut bounds = Punctuated::new();
                                loop {
                                    if input.is_empty()
                                        || input.peek(token::Brace)
                                        || input.peek(Token![,])
                                        || input.peek(Token![;])
                                        || input.peek(Token![:])
                                        || input.peek(Token![=])
                                    {
                                        break;
                                    }
                                    let value = input.parse()?;
                                    bounds.push_value(value);
                                    if !input.peek(Token![+]) {
                                        break;
                                    }
                                    let punct = input.parse()?;
                                    bounds.push_punct(punct);
                                }
                                bounds
                            },
                        }))
                    } else {
                        Ok(WherePredicate::Type(PredicateType {
                            lifetimes: input.parse()?,
                            bounded_ty: input.parse()?,
                            colon_token: input.parse()?,
                            bounds: {
                                let mut bounds = Punctuated::new();
                                loop {
                                    if input.is_empty()
                                        || input.peek(token::Brace)
                                        || input.peek(Token![,])
                                        || input.peek(Token![;])
                                        || input.peek(Token![:]) && !input.peek(Token![::])
                                        || input.peek(Token![=])
                                    {
                                        break;
                                    }
                                    bounds.push_value({
                                        let allow_precise_capture = false;
                                        let allow_const = true;
                                        TypeParamBound::parse_single(
                                            input,
                                            allow_precise_capture,
                                            allow_const,
                                        )?
                                    });
                                    if !input.peek(Token![+]) {
                                        break;
                                    }
                                    let punct = input.parse()?;
                                    bounds.push_punct(punct);
                                }
                                bounds
                            },
                        }))
                    }
                }
            }

                impl Parse for PreciseCapture
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let use_token: Token![use] = input.parse()?;
                    let lt_token: Token![<] = input.parse()?;
                    let mut params = Punctuated::new();
                    loop {
                        let lookahead = input.lookahead1();
                        params.push_value(
                            if lookahead.peek(Lifetime) || lookahead.peek(Ident) || input.peek(Token![Self])
                            {
                                input.parse::<CapturedParam>()?
                            } else if lookahead.peek(Token![>]) {
                                break;
                            } else {
                                return Err(lookahead.error());
                            },
                        );
                        let lookahead = input.lookahead1();
                        params.push_punct(if lookahead.peek(Token![,]) {
                            input.parse::<Token![,]>()?
                        } else if lookahead.peek(Token![>]) {
                            break;
                        } else {
                            return Err(lookahead.error());
                        });
                    }
                    let gt_token: Token![>] = input.parse()?;
                    Ok(PreciseCapture {
                        use_token,
                        lt_token,
                        params,
                        gt_token,
                    })
                }
            }

                impl Parse for CapturedParam
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    if lookahead.peek(Lifetime) {
                        input.parse().map(CapturedParam::Lifetime)
                    } else if lookahead.peek(Ident) || input.peek(Token![Self]) {
                        input.call(Ident::parse_any).map(CapturedParam::Ident)
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            pub fn choose_generics_over_qpath(input: ParseStream) -> bool
        {
               
               
               
               
                //
               
               
                //
               
               
               
               
               
               
               
                //
               
                //
               
                //
               
               
                input.peek(Token![<])
                    && (input.peek2(Token![>])
                        || input.peek2(Token![#])
                        || (input.peek2(Lifetime) || input.peek2(Ident))
                            && (input.peek3(Token![>])
                                || input.peek3(Token![,])
                                || input.peek3(Token![:]) && !input.peek3(Token![::])
                                || input.peek3(Token![=]))
                        || input.peek2(Token![const]))
            }

                pub fn choose_generics_over_qpath_after_keyword(input: ParseStream) -> bool
        {
                let input = input.fork();
                input.call(Ident::parse_any).unwrap();
                choose_generics_over_qpath(&input)
            }
        }
        
        pub mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    attr::FilterAttrs,
                    expr,
                    expr::Expr,
                    fixup::FixupContext,
                    generics::
                    {
                        BoundLifetimes, ConstParam, GenericParam, Generics, ImplGenerics, LifetimeParam,
                        PredicateLifetime, PredicateType, TraitBound, TraitBoundModifier, Turbofish, TypeGenerics,
                        TypeParam, WhereClause, CapturedParam, PreciseCapture
                    },
                    print::TokensOrDefault,
                    token,
                },
                *,
            };
            
            impl ToTokens for Generics {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if self.params.is_empty() {
                        return;
                    }

                    TokensOrDefault(&self.lt_token).to_tokens(tokens);

                   
                   
                    let mut trailing_or_empty = true;
                    for param in self.params.pairs() {
                        if let GenericParam::Lifetime(_) = **param.value() {
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                    }
                    for param in self.params.pairs() {
                        match param.value() {
                            GenericParam::Type(_) | GenericParam::Const(_) => {
                                if !trailing_or_empty {
                                    <Token![,]>::default().to_tokens(tokens);
                                    trailing_or_empty = true;
                                }
                                param.to_tokens(tokens);
                            }
                            GenericParam::Lifetime(_) => {}
                        }
                    }

                    TokensOrDefault(&self.gt_token).to_tokens(tokens);
                }
            }

            impl<'a> ToTokens for ImplGenerics<'a> {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if self.0.params.is_empty() {
                        return;
                    }

                    TokensOrDefault(&self.0.lt_token).to_tokens(tokens);

                   
                   
                    let mut trailing_or_empty = true;
                    for param in self.0.params.pairs() {
                        if let GenericParam::Lifetime(_) = **param.value() {
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                    }
                    for param in self.0.params.pairs() {
                        if let GenericParam::Lifetime(_) = **param.value() {
                            continue;
                        }
                        if !trailing_or_empty {
                            <Token![,]>::default().to_tokens(tokens);
                            trailing_or_empty = true;
                        }
                        match param.value() {
                            GenericParam::Lifetime(_) => unreachable!(),
                            GenericParam::Type(param) => {
                               
                                tokens.append_all(param.attrs.outer());
                                param.ident.to_tokens(tokens);
                                if !param.bounds.is_empty() {
                                    TokensOrDefault(&param.colon_token).to_tokens(tokens);
                                    param.bounds.to_tokens(tokens);
                                }
                            }
                            GenericParam::Const(param) => {
                               
                                tokens.append_all(param.attrs.outer());
                                param.const_token.to_tokens(tokens);
                                param.ident.to_tokens(tokens);
                                param.colon_token.to_tokens(tokens);
                                param.ty.to_tokens(tokens);
                            }
                        }
                        param.punct().to_tokens(tokens);
                    }

                    TokensOrDefault(&self.0.gt_token).to_tokens(tokens);
                }
            }

            impl<'a> ToTokens for TypeGenerics<'a> {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if self.0.params.is_empty() {
                        return;
                    }

                    TokensOrDefault(&self.0.lt_token).to_tokens(tokens);

                   
                   
                    let mut trailing_or_empty = true;
                    for param in self.0.params.pairs() {
                        if let GenericParam::Lifetime(def) = *param.value() {
                           
                            def.lifetime.to_tokens(tokens);
                            param.punct().to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                    }
                    for param in self.0.params.pairs() {
                        if let GenericParam::Lifetime(_) = **param.value() {
                            continue;
                        }
                        if !trailing_or_empty {
                            <Token![,]>::default().to_tokens(tokens);
                            trailing_or_empty = true;
                        }
                        match param.value() {
                            GenericParam::Lifetime(_) => unreachable!(),
                            GenericParam::Type(param) => {
                               
                                param.ident.to_tokens(tokens);
                            }
                            GenericParam::Const(param) => {
                               
                                param.ident.to_tokens(tokens);
                            }
                        }
                        param.punct().to_tokens(tokens);
                    }

                    TokensOrDefault(&self.0.gt_token).to_tokens(tokens);
                }
            }

            impl<'a> ToTokens for Turbofish<'a> {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if !self.0.params.is_empty() {
                        <Token![::]>::default().to_tokens(tokens);
                        TypeGenerics(self.0).to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for BoundLifetimes {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.for_token.to_tokens(tokens);
                    self.lt_token.to_tokens(tokens);
                    self.lifetimes.to_tokens(tokens);
                    self.gt_token.to_tokens(tokens);
                }
            }

            impl ToTokens for LifetimeParam {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.lifetime.to_tokens(tokens);
                    if !self.bounds.is_empty() {
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                        self.bounds.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for TypeParam {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.ident.to_tokens(tokens);
                    if !self.bounds.is_empty() {
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                        self.bounds.to_tokens(tokens);
                    }
                    if let Some(default) = &self.default {
                        TokensOrDefault(&self.eq_token).to_tokens(tokens);
                        default.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for TraitBound {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    let to_tokens = |tokens: &mut TokenStream| {
                        self.modifier.to_tokens(tokens);
                        self.lifetimes.to_tokens(tokens);
                        self.path.to_tokens(tokens);
                    };
                    match &self.paren_token {
                        Some(paren) => paren.surround(tokens, to_tokens),
                        None => to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for TraitBoundModifier {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        TraitBoundModifier::None => {}
                        TraitBoundModifier::Maybe(t) => t.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for ConstParam {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.const_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    if let Some(default) = &self.default {
                        TokensOrDefault(&self.eq_token).to_tokens(tokens);
                        print_const_argument(default, tokens);
                    }
                }
            }

            impl ToTokens for WhereClause {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    if !self.predicates.is_empty() {
                        self.where_token.to_tokens(tokens);
                        self.predicates.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for PredicateLifetime {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.lifetime.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }

            impl ToTokens for PredicateType {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.lifetimes.to_tokens(tokens);
                    self.bounded_ty.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }

                impl ToTokens for PreciseCapture {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.use_token.to_tokens(tokens);
                    self.lt_token.to_tokens(tokens);

                   
                   
                    let mut trailing_or_empty = true;
                    for param in self.params.pairs() {
                        if let CapturedParam::Lifetime(_) = **param.value() {
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                    }
                    for param in self.params.pairs() {
                        if let CapturedParam::Ident(_) = **param.value() {
                            if !trailing_or_empty {
                                <Token![,]>::default().to_tokens(tokens);
                                trailing_or_empty = true;
                            }
                            param.to_tokens(tokens);
                        }
                    }

                    self.gt_token.to_tokens(tokens);
                }
            }

                impl ToTokens for CapturedParam {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        CapturedParam::Lifetime(lifetime) => lifetime.to_tokens(tokens),
                        CapturedParam::Ident(ident) => ident.to_tokens(tokens),
                    }
                }
            }

            pub fn print_const_argument(expr: &Expr, tokens: &mut TokenStream) {
                match expr {
                    Expr::Lit(expr) => expr.to_tokens(tokens),

                    Expr::Path(expr)
                        if expr.attrs.is_empty()
                            && expr.qself.is_none()
                            && expr.path.get_ident().is_some() =>
                    {
                        expr.to_tokens(tokens);
                    }
                    
                    Expr::Block(expr) => expr.to_tokens(tokens),
                    
                   
                    _ => token::Brace::default().surround(tokens, |tokens|
                    {
                        expr::printing::print_expr(expr, tokens, FixupContext::new_stmt());
                    }),
                }
            }
        }
    } pub use self::generics::
    {
        BoundLifetimes, CapturedParam, ImplGenerics, Turbofish, TypeGenerics, PreciseCapture, ConstParam,
        GenericParam, Generics, LifetimeParam,  PredicateLifetime, PredicateType, TraitBound, TraitBoundModifier, 
        TypeParam, TypeParamBound,  WhereClause, WherePredicate,
    };

    pub mod ident
    {
        use ::
        {
            process::macros::{ Ident },
            syntax::{ lookahead },
            *,
        };
        /*
        */
        macro_rules! ident_from_token
        {
            ($token:ident) => {
                impl From<Token![$token]> for Ident {
                    fn from(token: Token![$token]) -> Ident {
                        Ident::new(stringify!($token), token.span)
                    }
                }
            };
        }

        pub_if_not_doc!
        {
            pub fn Ident(marker: lookahead::TokenMarker) -> Ident
            {
                match marker {}
            }
        }

        ident_from_token!(self);
        ident_from_token!(Self);
        ident_from_token!(super);
        ident_from_token!(crate);
        ident_from_token!(extern);

        impl From<Token![_]> for Ident 
        {
            fn from(token: Token![_]) -> Ident {
                Ident::new("_", token.span)
            }
        }

        pub fn xid_ok(symbol: &str) -> bool 
        {
            let mut chars = symbol.chars();
            let first = chars.next().unwrap();
            if !(first == '_' || is::xid_start(first)) {
                return false;
            }
            for ch in chars {
                if !is::xid_continue(ch) {
                    return false;
                }
            }
            true
        }
        
        mod parsing
        {
            use ::
            {
                process::macros::Ident,
                syntax::
                {
                    buffer::Cursor,
                    error::Result,
                    parse::{Parse, ParseStream},
                    token::Token,
                },
                *,
            };

            fn accept_as_ident(ident: &Ident) -> bool
        {
                match ident.to_string().as_str() {
                    "_" |
                   
                    "abstract" | "as" | "async" | "await" | "become" | "box" | "break" |
                    "const" | "continue" | "crate" | "do" | "dyn" | "else" | "enum" |
                    "extern" | "false" | "final" | "fn" | "for" | "if" | "impl" | "in" |
                    "let" | "loop" | "macro" | "match" | "mod" | "move" | "mut" |
                    "override" | "priv" | "pub" | "ref" | "return" | "Self" | "self" |
                    "static" | "struct" | "super" | "trait" | "true" | "try" | "type" |
                    "typeof" | "unsafe" | "unsized" | "use" | "virtual" | "where" |
                    "while" | "yield" => false,
                    _ => true,
                }
            }

            impl Parse for Ident
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    input.step(|cursor| {
                        if let Some((ident, rest)) = cursor.ident() {
                            if accept_as_ident(&ident) {
                                Ok((ident, rest))
                            } else {
                                Err(cursor.error(format_args!(
                                    "expected identifier, found keyword `{}`",
                                    ident,
                                )))
                            }
                        } else {
                            Err(cursor.error("expected identifier"))
                        }
                    })
                }
            }

            impl Token for Ident {
                fn peek(cursor: Cursor) -> bool
        {
                    if let Some((ident, _rest)) = cursor.ident() {
                        accept_as_ident(&ident)
                    } else {
                        false
                    }
                }

                fn display() -> &'static str {
                    "identifier"
                }
            }
        }
    } pub use self::ident::Ident;
    
    pub mod item
    {
        use ::
        {
            process::macros::{ TokenStream },
            syntax::
            {
                attr::Attribute,
                data::{Fields, FieldsNamed, Variant},
                derive::{Data, DataEnum, DataStruct, DataUnion, DeriveInput},
                expr::Expr,
                generics::{Generics, TypeParamBound},
                ident::Ident,
                lifetime::Lifetime,
                mac::Macro,
                pat::{Pat, PatType},
                path::Path,
                punctuated::Punctuated,
                restriction::Visibility,
                stmt::Block,
                token,
                ty::{Abi, ReturnType, Type},
            },
            *,
        };
        /*
        */
        ast_enum_of_structs!
        {
            /// Things that can appear directly inside of a module or scope.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            #[non_exhaustive]
            pub enum Item {
                /// A constant item: `const MAX: u16 = 65535`.
                Const(ItemConst),
                /// An enum definition: `enum Foo<A, B> { A(A), B(B) }`.
                Enum(ItemEnum),
                /// An `extern crate` item: `extern crate serde`.
                ExternCrate(ItemExternCrate),
                /// A free-standing function: `fn process(n: usize) -> Result<()> { ...
                /// }`.
                Fn(ItemFn),
                /// A block of foreign items: `extern "C" { ... }`.
                ForeignMod(ItemForeignMod),
                /// An impl block providing trait or associated items: `impl<A> Trait
                /// for Data<A> { ... }`.
                Impl(ItemImpl),
                /// A macro invocation, which includes `macro_rules!` definitions.
                Macro(ItemMacro),
                /// A module or module declaration: `mod m` or `mod m { ... }`.
                Mod(ItemMod),
                /// A static item: `static BIKE: Shed = Shed(42)`.
                Static(ItemStatic),
                /// A struct definition: `struct Foo<A> { x: A }`.
                Struct(ItemStruct),
                /// A trait definition: `pub trait Iterator { ... }`.
                Trait(ItemTrait),
                /// A trait alias: `pub trait SharableIterator = Iterator + Sync`.
                TraitAlias(ItemTraitAlias),
                /// A type alias: `type Result<T> = std::result::Result<T, MyError>`.
                Type(ItemType),
                /// A union definition: `union Foo<A, B> { x: A, y: B }`.
                Union(ItemUnion),
                /// A use declaration: `use std::collections::HashMap`.
                Use(ItemUse),
                /// Tokens forming an item not interpreted by Syn.
                Verbatim(TokenStream),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// A constant item: `const MAX: u16 = 65535`.
            pub struct ItemConst {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub const_token: Token![const],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Token![:],
                pub ty: Box<Type>,
                pub eq_token: Token![=],
                pub expr: Box<Expr>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// An enum definition: `enum Foo<A, B> { A(A), B(B) }`.
            pub struct ItemEnum {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub enum_token: Token![enum],
                pub ident: Ident,
                pub generics: Generics,
                pub brace_token: token::Brace,
                pub variants: Punctuated<Variant, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// An `extern crate` item: `extern crate serde`.
            pub struct ItemExternCrate {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub extern_token: Token![extern],
                pub crate_token: Token![crate],
                pub ident: Ident,
                pub rename: Option<(Token![as], Ident)>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A free-standing function: `fn process(n: usize) -> Result<()> { ... }`.
            pub struct ItemFn {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub sig: Signature,
                pub block: Box<Block>,
            }
        }

        ast_struct! 
        {
            /// A block of foreign items: `extern "C" { ... }`.
            pub struct ItemForeignMod {
                pub attrs: Vec<Attribute>,
                pub unsafety: Option<Token![unsafe]>,
                pub abi: Abi,
                pub brace_token: token::Brace,
                pub items: Vec<ForeignItem>,
            }
        }

        ast_struct! 
        {
            /// An impl block providing trait or associated items: `impl<A> Trait
            /// for Data<A> { ... }`.
            pub struct ItemImpl {
                pub attrs: Vec<Attribute>,
                pub defaultness: Option<Token![default]>,
                pub unsafety: Option<Token![unsafe]>,
                pub impl_token: Token![impl],
                pub generics: Generics,
                /// Trait this impl implements.
                pub trait_: Option<(Option<Token![!]>, Path, Token![for])>,
                /// The Self type of the impl.
                pub self_ty: Box<Type>,
                pub brace_token: token::Brace,
                pub items: Vec<ImplItem>,
            }
        }

        ast_struct! 
        {
            /// A macro invocation, which includes `macro_rules!` definitions.
            pub struct ItemMacro {
                pub attrs: Vec<Attribute>,
                /// The `example` in `macro_rules! example { ... }`.
                pub ident: Option<Ident>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// A module or module declaration: `mod m` or `mod m { ... }`.
            pub struct ItemMod {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub unsafety: Option<Token![unsafe]>,
                pub mod_token: Token![mod],
                pub ident: Ident,
                pub content: Option<(token::Brace, Vec<Item>)>,
                pub semi: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// A static item: `static BIKE: Shed = Shed(42)`.
            pub struct ItemStatic {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub static_token: Token![static],
                pub mutability: StaticMutability,
                pub ident: Ident,
                pub colon_token: Token![:],
                pub ty: Box<Type>,
                pub eq_token: Token![=],
                pub expr: Box<Expr>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A struct definition: `struct Foo<A> { x: A }`.
            pub struct ItemStruct {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub struct_token: Token![struct],
                pub ident: Ident,
                pub generics: Generics,
                pub fields: Fields,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// A trait definition: `pub trait Iterator { ... }`.
            pub struct ItemTrait {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub unsafety: Option<Token![unsafe]>,
                pub auto_token: Option<Token![auto]>,
                pub restriction: Option<ImplRestriction>,
                pub trait_token: Token![trait],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Option<Token![:]>,
                pub supertraits: Punctuated<TypeParamBound, Token![+]>,
                pub brace_token: token::Brace,
                pub items: Vec<TraitItem>,
            }
        }

        ast_struct! 
        {
            /// A trait alias: `pub trait SharableIterator = Iterator + Sync`.
            pub struct ItemTraitAlias {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub trait_token: Token![trait],
                pub ident: Ident,
                pub generics: Generics,
                pub eq_token: Token![=],
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A type alias: `type Result<T> = std::result::Result<T, MyError>`.
            pub struct ItemType {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub type_token: Token![type],
                pub ident: Ident,
                pub generics: Generics,
                pub eq_token: Token![=],
                pub ty: Box<Type>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A union definition: `union Foo<A, B> { x: A, y: B }`.
            pub struct ItemUnion {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub union_token: Token![union],
                pub ident: Ident,
                pub generics: Generics,
                pub fields: FieldsNamed,
            }
        }

        ast_struct! 
        {
            /// A use declaration: `use std::collections::HashMap`.
            pub struct ItemUse {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub use_token: Token![use],
                pub leading_colon: Option<Token![::]>,
                pub tree: UseTree,
                pub semi_token: Token![;],
            }
        }

        impl Item 
        {
             
                pub fn replace_attrs(&mut self, new: Vec<Attribute>) -> Vec<Attribute>
            {
                match self {
                    Item::Const(ItemConst { attrs, .. })
                    | Item::Enum(ItemEnum { attrs, .. })
                    | Item::ExternCrate(ItemExternCrate { attrs, .. })
                    | Item::Fn(ItemFn { attrs, .. })
                    | Item::ForeignMod(ItemForeignMod { attrs, .. })
                    | Item::Impl(ItemImpl { attrs, .. })
                    | Item::Macro(ItemMacro { attrs, .. })
                    | Item::Mod(ItemMod { attrs, .. })
                    | Item::Static(ItemStatic { attrs, .. })
                    | Item::Struct(ItemStruct { attrs, .. })
                    | Item::Trait(ItemTrait { attrs, .. })
                    | Item::TraitAlias(ItemTraitAlias { attrs, .. })
                    | Item::Type(ItemType { attrs, .. })
                    | Item::Union(ItemUnion { attrs, .. })
                    | Item::Use(ItemUse { attrs, .. }) => mem::replace(attrs, new),
                    Item::Verbatim(_) => Vec::new(),
                }
            }
        }

        impl From<DeriveInput> for Item 
        {
            fn from(input: DeriveInput) -> Item {
                match input.data {
                    Data::Struct(data) => Item::Struct(ItemStruct {
                        attrs: input.attrs,
                        vis: input.vis,
                        struct_token: data.struct_token,
                        ident: input.ident,
                        generics: input.generics,
                        fields: data.fields,
                        semi_token: data.semi_token,
                    }),
                    Data::Enum(data) => Item::Enum(ItemEnum {
                        attrs: input.attrs,
                        vis: input.vis,
                        enum_token: data.enum_token,
                        ident: input.ident,
                        generics: input.generics,
                        brace_token: data.brace_token,
                        variants: data.variants,
                    }),
                    Data::Union(data) => Item::Union(ItemUnion {
                        attrs: input.attrs,
                        vis: input.vis,
                        union_token: data.union_token,
                        ident: input.ident,
                        generics: input.generics,
                        fields: data.fields,
                    }),
                }
            }
        }

        impl From<ItemStruct> for DeriveInput 
        {
            fn from(input: ItemStruct) -> DeriveInput {
                DeriveInput {
                    attrs: input.attrs,
                    vis: input.vis,
                    ident: input.ident,
                    generics: input.generics,
                    data: Data::Struct(DataStruct {
                        struct_token: input.struct_token,
                        fields: input.fields,
                        semi_token: input.semi_token,
                    }),
                }
            }
        }

        impl From<ItemEnum> for DeriveInput 
        {
            fn from(input: ItemEnum) -> DeriveInput {
                DeriveInput {
                    attrs: input.attrs,
                    vis: input.vis,
                    ident: input.ident,
                    generics: input.generics,
                    data: Data::Enum(DataEnum {
                        enum_token: input.enum_token,
                        brace_token: input.brace_token,
                        variants: input.variants,
                    }),
                }
            }
        }

        impl From<ItemUnion> for DeriveInput 
        {
            fn from(input: ItemUnion) -> DeriveInput {
                DeriveInput {
                    attrs: input.attrs,
                    vis: input.vis,
                    ident: input.ident,
                    generics: input.generics,
                    data: Data::Union(DataUnion {
                        union_token: input.union_token,
                        fields: input.fields,
                    }),
                }
            }
        }

        ast_enum_of_structs! 
        {
            /// A suffix of an import tree in a `use` item: `Type as Renamed` or `*`.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            pub enum UseTree {
                /// A path prefix of imports in a `use` item: `std::...`.
                Path(UsePath),
                /// An identifier imported by a `use` item: `HashMap`.
                Name(UseName),
                /// An renamed identifier imported by a `use` item: `HashMap as Map`.
                Rename(UseRename),
                /// A glob import in a `use` item: `*`.
                Glob(UseGlob),
                /// A braced group of imports in a `use` item: `{A, B, C}`.
                Group(UseGroup),
            }
        }

        ast_struct! 
        {
            /// A path prefix of imports in a `use` item: `std::...`.
            pub struct UsePath {
                pub ident: Ident,
                pub colon2_token: Token![::],
                pub tree: Box<UseTree>,
            }
        }

        ast_struct! 
        {
            /// An identifier imported by a `use` item: `HashMap`.
            pub struct UseName {
                pub ident: Ident,
            }
        }

        ast_struct! 
        {
            /// An renamed identifier imported by a `use` item: `HashMap as Map`.
            pub struct UseRename {
                pub ident: Ident,
                pub as_token: Token![as],
                pub rename: Ident,
            }
        }

        ast_struct! 
        {
            /// A glob import in a `use` item: `*`.
            pub struct UseGlob {
                pub star_token: Token![*],
            }
        }

        ast_struct! 
        {
            /// A braced group of imports in a `use` item: `{A, B, C}`.
            pub struct UseGroup {
                pub brace_token: token::Brace,
                pub items: Punctuated<UseTree, Token![,]>,
            }
        }

        ast_enum_of_structs! 
        {
            /// An item within an `extern` block.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            #[non_exhaustive]
            pub enum ForeignItem {
                /// A foreign function in an `extern` block.
                Fn(ForeignItemFn),
                /// A foreign static item in an `extern` block: `static ext: u8`.
                Static(ForeignItemStatic),
                /// A foreign type in an `extern` block: `type void`.
                Type(ForeignItemType),
                /// A macro invocation within an extern block.
                Macro(ForeignItemMacro),
                /// Tokens in an `extern` block not interpreted by Syn.
                Verbatim(TokenStream),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// A foreign function in an `extern` block.
            pub struct ForeignItemFn {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub sig: Signature,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A foreign static item in an `extern` block: `static ext: u8`.
            pub struct ForeignItemStatic {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub static_token: Token![static],
                pub mutability: StaticMutability,
                pub ident: Ident,
                pub colon_token: Token![:],
                pub ty: Box<Type>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A foreign type in an `extern` block: `type void`.
            pub struct ForeignItemType {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub type_token: Token![type],
                pub ident: Ident,
                pub generics: Generics,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A macro invocation within an extern block.
            pub struct ForeignItemMacro {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_enum_of_structs! 
        {
            /// An item declaration within the definition of a trait.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            #[non_exhaustive]
            pub enum TraitItem {
                /// An associated constant within the definition of a trait.
                Const(TraitItemConst),
                /// An associated function within the definition of a trait.
                Fn(TraitItemFn),
                /// An associated type within the definition of a trait.
                Type(TraitItemType),
                /// A macro invocation within the definition of a trait.
                Macro(TraitItemMacro),
                /// Tokens within the definition of a trait not interpreted by Syn.
                Verbatim(TokenStream),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// An associated constant within the definition of a trait.
            pub struct TraitItemConst {
                pub attrs: Vec<Attribute>,
                pub const_token: Token![const],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Token![:],
                pub ty: Type,
                pub default: Option<(Token![=], Expr)>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// An associated function within the definition of a trait.
            pub struct TraitItemFn {
                pub attrs: Vec<Attribute>,
                pub sig: Signature,
                pub default: Option<Block>,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// An associated type within the definition of a trait.
            pub struct TraitItemType {
                pub attrs: Vec<Attribute>,
                pub type_token: Token![type],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Option<Token![:]>,
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
                pub default: Option<(Token![=], Type)>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A macro invocation within the definition of a trait.
            pub struct TraitItemMacro {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_enum_of_structs! 
        {
            /// An item within an impl block.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            #[non_exhaustive]
            pub enum ImplItem {
                /// An associated constant within an impl block.
                Const(ImplItemConst),
                /// An associated function within an impl block.
                Fn(ImplItemFn),
                /// An associated type within an impl block.
                Type(ImplItemType),
                /// A macro invocation within an impl block.
                Macro(ImplItemMacro),
                /// Tokens within an impl block not interpreted by Syn.
                Verbatim(TokenStream),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! 
        {
            /// An associated constant within an impl block.
            pub struct ImplItemConst {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub defaultness: Option<Token![default]>,
                pub const_token: Token![const],
                pub ident: Ident,
                pub generics: Generics,
                pub colon_token: Token![:],
                pub ty: Type,
                pub eq_token: Token![=],
                pub expr: Expr,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// An associated function within an impl block.
            pub struct ImplItemFn {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub defaultness: Option<Token![default]>,
                pub sig: Signature,
                pub block: Block,
            }
        }

        ast_struct! 
        {
            /// An associated type within an impl block.
            pub struct ImplItemType {
                pub attrs: Vec<Attribute>,
                pub vis: Visibility,
                pub defaultness: Option<Token![default]>,
                pub type_token: Token![type],
                pub ident: Ident,
                pub generics: Generics,
                pub eq_token: Token![=],
                pub ty: Type,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// A macro invocation within an impl block.
            pub struct ImplItemMacro {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }

        ast_struct! 
        {
            /// A function signature in a trait or implementation: `unsafe fn
            /// initialize(&self)`.
            pub struct Signature {
                pub constness: Option<Token![const]>,
                pub asyncness: Option<Token![async]>,
                pub unsafety: Option<Token![unsafe]>,
                pub abi: Option<Abi>,
                pub fn_token: Token![fn],
                pub ident: Ident,
                pub generics: Generics,
                pub paren_token: token::Paren,
                pub inputs: Punctuated<FnArg, Token![,]>,
                pub variadic: Option<Variadic>,
                pub output: ReturnType,
            }
        }

        impl Signature 
        {
            /// A method's `self` receiver, such as `&self` or `self: Box<Self>`.
            pub fn receiver(&self) -> Option<&Receiver>
            {
                let arg = self.inputs.first()?;
                match arg {
                    FnArg::Receiver(receiver) => Some(receiver),
                    FnArg::Typed(_) => None,
                }
            }
        }

        ast_enum_of_structs! 
        {
            /// An argument in a function signature: the `n: usize` in `fn f(n: usize)`.
            pub enum FnArg {
                /// The `self` argument of an associated method.
                Receiver(Receiver),
                /// A function argument accepted by pattern and type.
                Typed(PatType),
            }
        }

        ast_struct! 
        {
            /// The `self` argument of an associated method.
            /// is written in shorthand such as `self` or `&self` or `&mut self`. In the
            /// shorthand case, the type in `ty` is reconstructed as one of `Self`,
            /// `&Self`, or `&mut Self`.
            pub struct Receiver {
                pub attrs: Vec<Attribute>,
                pub reference: Option<(Token![&], Option<Lifetime>)>,
                pub mutability: Option<Token![mut]>,
                pub self_token: Token![self],
                pub colon_token: Option<Token![:]>,
                pub ty: Box<Type>,
            }
        }

        impl Receiver 
        {
            pub fn lifetime(&self) -> Option<&Lifetime>
            {
                self.reference.as_ref()?.1.as_ref()
            }
        }

        ast_struct! 
        {
            /// The variadic argument of a foreign function.
            ///    
            /// }
            /// ```
            pub struct Variadic {
                pub attrs: Vec<Attribute>,
                pub pat: Option<(Box<Pat>, Token![:])>,
                pub dots: Token![...],
                pub comma: Option<Token![,]>,
            }
        }

        ast_enum! 
        {
            /// The mutability of an `Item::Static` or `ForeignItem::Static`.
            #[non_exhaustive]
            pub enum StaticMutability {
                Mut(Token![mut]),
                None,
            }
        }

        ast_enum! 
        {
            /// Unused, but reserved for RFC 3323 restrictions.
            #[non_exhaustive]
            pub enum ImplRestriction {}


           
            //
           
           
           
           
           
           
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::{ TokenStream },
                syntax::
                {
                    attr::{self, Attribute},
                    derive,
                    error::{Error, Result},
                    expr::Expr,
                    ext::IdentExt as _,
                    generics::{self, Generics, TypeParamBound},
                    ident::Ident,
                    item::
                    {
                        FnArg, ForeignItem, ForeignItemFn, ForeignItemMacro, ForeignItemStatic, ForeignItemType,
                        ImplItem, ImplItemConst, ImplItemFn, ImplItemMacro, ImplItemType, Item, ItemConst, ItemEnum,
                        ItemExternCrate, ItemFn, ItemForeignMod, ItemImpl, ItemMacro, ItemMod, ItemStatic, ItemStruct,
                        ItemTrait, ItemTraitAlias, ItemType, ItemUnion, ItemUse, Receiver, Signature, 
                        StaticMutability, TraitItem, TraitItemConst, TraitItemFn, TraitItemMacro, TraitItemType, 
                        UseGlob, UseGroup, UseName, UsePath, UseRename, UseTree, Variadic,
                    },
                    lifetime::Lifetime,
                    lit::LitStr,
                    mac::{self, Macro},
                    parse::discouraged::Speculative as _,
                    parse::{Parse, ParseBuffer, ParseStream},
                    pat::{Pat, PatType, PatWild},
                    path::Path,
                    punctuated::Punctuated,
                    restriction::Visibility,
                    stmt::Block,
                    token,
                    ty::{Abi, ReturnType, Type, TypePath, TypeReference},
                    verbatim,
                },
                *,
            };

            impl Parse for Item
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let attrs = input.call(Attribute::parse_outer)?;
                    parse_rest_of_item(begin, attrs, input)
                }
            }

            pub fn parse_rest_of_item
            (
                begin: ParseBuffer,
                mut attrs: Vec<Attribute>,
                input: ParseStream,
            ) -> Result<Item>
            {
                let ahead = input.fork();
                let vis: Visibility = ahead.parse()?;

                let lookahead = ahead.lookahead1();
                let allow_safe = false;
                let mut item = if lookahead.peek(Token![fn]) || peek_signature(&ahead, allow_safe) {
                    let vis: Visibility = input.parse()?;
                    let sig: Signature = input.parse()?;
                    if input.peek(Token![;]) {
                        input.parse::<Token![;]>()?;
                        Ok(Item::Verbatim(verbatim::between(&begin, input)))
                    } else {
                        parse_rest_of_fn(input, Vec::new(), vis, sig).map(Item::Fn)
                    }
                } else if lookahead.peek(Token![extern]) {
                    ahead.parse::<Token![extern]>()?;
                    let lookahead = ahead.lookahead1();
                    if lookahead.peek(Token![crate]) {
                        input.parse().map(Item::ExternCrate)
                    } else if lookahead.peek(token::Brace) {
                        input.parse().map(Item::ForeignMod)
                    } else if lookahead.peek(LitStr) {
                        ahead.parse::<LitStr>()?;
                        let lookahead = ahead.lookahead1();
                        if lookahead.peek(token::Brace) {
                            input.parse().map(Item::ForeignMod)
                        } else {
                            Err(lookahead.error())
                        }
                    } else {
                        Err(lookahead.error())
                    }
                } else if lookahead.peek(Token![use]) {
                    let allow_crate_root_in_path = true;
                    match parse_item_use(input, allow_crate_root_in_path)? {
                        Some(item_use) => Ok(Item::Use(item_use)),
                        None => Ok(Item::Verbatim(verbatim::between(&begin, input))),
                    }
                } else if lookahead.peek(Token![static]) {
                    let vis = input.parse()?;
                    let static_token = input.parse()?;
                    let mutability = input.parse()?;
                    let ident = input.parse()?;
                    if input.peek(Token![=]) {
                        input.parse::<Token![=]>()?;
                        input.parse::<Expr>()?;
                        input.parse::<Token![;]>()?;
                        Ok(Item::Verbatim(verbatim::between(&begin, input)))
                    } else {
                        let colon_token = input.parse()?;
                        let ty = input.parse()?;
                        if input.peek(Token![;]) {
                            input.parse::<Token![;]>()?;
                            Ok(Item::Verbatim(verbatim::between(&begin, input)))
                        } else {
                            Ok(Item::Static(ItemStatic {
                                attrs: Vec::new(),
                                vis,
                                static_token,
                                mutability,
                                ident,
                                colon_token,
                                ty,
                                eq_token: input.parse()?,
                                expr: input.parse()?,
                                semi_token: input.parse()?,
                            }))
                        }
                    }
                } else if lookahead.peek(Token![const]) {
                    let vis = input.parse()?;
                    let const_token: Token![const] = input.parse()?;
                    let lookahead = input.lookahead1();
                    let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                        input.call(Ident::parse_any)?
                    } else {
                        return Err(lookahead.error());
                    };
                    let mut generics: Generics = input.parse()?;
                    let colon_token = input.parse()?;
                    let ty = input.parse()?;
                    let value = if let Some(eq_token) = input.parse::<Option<Token![=]>>()? {
                        let expr: Expr = input.parse()?;
                        Some((eq_token, expr))
                    } else {
                        None
                    };
                    generics.where_clause = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;
                    match value {
                        Some((eq_token, expr))
                            if generics.lt_token.is_none() && generics.where_clause.is_none() =>
                        {
                            Ok(Item::Const(ItemConst {
                                attrs: Vec::new(),
                                vis,
                                const_token,
                                ident,
                                generics,
                                colon_token,
                                ty,
                                eq_token,
                                expr: Box::new(expr),
                                semi_token,
                            }))
                        }
                        _ => Ok(Item::Verbatim(verbatim::between(&begin, input))),
                    }
                } else if lookahead.peek(Token![unsafe]) {
                    ahead.parse::<Token![unsafe]>()?;
                    let lookahead = ahead.lookahead1();
                    if lookahead.peek(Token![trait])
                        || lookahead.peek(Token![auto]) && ahead.peek2(Token![trait])
                    {
                        input.parse().map(Item::Trait)
                    } else if lookahead.peek(Token![impl]) {
                        let allow_verbatim_impl = true;
                        if let Some(item) = parse_impl(input, allow_verbatim_impl)? {
                            Ok(Item::Impl(item))
                        } else {
                            Ok(Item::Verbatim(verbatim::between(&begin, input)))
                        }
                    } else if lookahead.peek(Token![extern]) {
                        input.parse().map(Item::ForeignMod)
                    } else if lookahead.peek(Token![mod]) {
                        input.parse().map(Item::Mod)
                    } else {
                        Err(lookahead.error())
                    }
                } else if lookahead.peek(Token![mod]) {
                    input.parse().map(Item::Mod)
                } else if lookahead.peek(Token![type]) {
                    parse_item_type(begin, input)
                } else if lookahead.peek(Token![struct]) {
                    input.parse().map(Item::Struct)
                } else if lookahead.peek(Token![enum]) {
                    input.parse().map(Item::Enum)
                } else if lookahead.peek(Token![union]) && ahead.peek2(Ident) {
                    input.parse().map(Item::Union)
                } else if lookahead.peek(Token![trait]) {
                    input.call(parse_trait_or_trait_alias)
                } else if lookahead.peek(Token![auto]) && ahead.peek2(Token![trait]) {
                    input.parse().map(Item::Trait)
                } else if lookahead.peek(Token![impl])
                    || lookahead.peek(Token![default]) && !ahead.peek2(Token![!])
                {
                    let allow_verbatim_impl = true;
                    if let Some(item) = parse_impl(input, allow_verbatim_impl)? {
                        Ok(Item::Impl(item))
                    } else {
                        Ok(Item::Verbatim(verbatim::between(&begin, input)))
                    }
                } else if lookahead.peek(Token![macro]) {
                    input.advance_to(&ahead);
                    parse_macro2(begin, vis, input)
                } else if vis.is_inherited()
                    && (lookahead.peek(Ident)
                        || lookahead.peek(Token![self])
                        || lookahead.peek(Token![super])
                        || lookahead.peek(Token![crate])
                        || lookahead.peek(Token![::]))
                {
                    input.parse().map(Item::Macro)
                } else {
                    Err(lookahead.error())
                }?;

                attrs.extend(item.replace_attrs(Vec::new()));
                item.replace_attrs(attrs);
                Ok(item)
            }

            struct FlexibleItemType 
            {
                vis: Visibility,
                defaultness: Option<Token![default]>,
                type_token: Token![type],
                ident: Ident,
                generics: Generics,
                colon_token: Option<Token![:]>,
                bounds: Punctuated<TypeParamBound, Token![+]>,
                ty: Option<(Token![=], Type)>,
                semi_token: Token![;],
            }

            enum TypeDefaultness 
            {
                Optional,
                Disallowed,
            }

            enum WhereClauseLocation 
            {
               
                BeforeEq,
               
                AfterEq,
               
                Both,
            }

            impl FlexibleItemType
            {
                fn parse(
                    input: ParseStream,
                    allow_defaultness: TypeDefaultness,
                    where_clause_location: WhereClauseLocation,
                ) -> Result<Self> {
                    let vis: Visibility = input.parse()?;
                    let defaultness: Option<Token![default]> = match allow_defaultness {
                        TypeDefaultness::Optional => input.parse()?,
                        TypeDefaultness::Disallowed => None,
                    };
                    let type_token: Token![type] = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let mut generics: Generics = input.parse()?;
                    let (colon_token, bounds) = Self::parse_optional_bounds(input)?;

                    match where_clause_location {
                        WhereClauseLocation::BeforeEq | WhereClauseLocation::Both => {
                            generics.where_clause = input.parse()?;
                        }
                        WhereClauseLocation::AfterEq => {}
                    }

                    let ty = Self::parse_optional_definition(input)?;

                    match where_clause_location {
                        WhereClauseLocation::AfterEq | WhereClauseLocation::Both
                            if generics.where_clause.is_none() =>
                        {
                            generics.where_clause = input.parse()?;
                        }
                        _ => {}
                    }

                    let semi_token: Token![;] = input.parse()?;

                    Ok(FlexibleItemType {
                        vis,
                        defaultness,
                        type_token,
                        ident,
                        generics,
                        colon_token,
                        bounds,
                        ty,
                        semi_token,
                    })
                }

                fn parse_optional_bounds(
                    input: ParseStream,
                ) -> Result<(Option<Token![:]>, Punctuated<TypeParamBound, Token![+]>)> {
                    let colon_token: Option<Token![:]> = input.parse()?;

                    let mut bounds = Punctuated::new();
                    if colon_token.is_some() {
                        loop {
                            if input.peek(Token![where]) || input.peek(Token![=]) || input.peek(Token![;]) {
                                break;
                            }
                            bounds.push_value({
                                let allow_precise_capture = false;
                                let allow_const = true;
                                TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                            });
                            if input.peek(Token![where]) || input.peek(Token![=]) || input.peek(Token![;]) {
                                break;
                            }
                            bounds.push_punct(input.parse::<Token![+]>()?);
                        }
                    }

                    Ok((colon_token, bounds))
                }

                fn parse_optional_definition(input: ParseStream) -> Result<Option<(Token![=], Type)>> {
                    let eq_token: Option<Token![=]> = input.parse()?;
                    if let Some(eq_token) = eq_token {
                        let definition: Type = input.parse()?;
                        Ok(Some((eq_token, definition)))
                    } else {
                        Ok(None)
                    }
                }
            }

            impl Parse for ItemMacro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let path = input.call(Path::parse_mod_style)?;
                    let bang_token: Token![!] = input.parse()?;
                    let ident: Option<Ident> = if input.peek(Token![try]) {
                        input.call(Ident::parse_any).map(Some)
                    } else {
                        input.parse()
                    }?;
                    let (delimiter, tokens) = input.call(mac::parse_delimiter)?;
                    let semi_token: Option<Token![;]> = if !delimiter.is_brace() {
                        Some(input.parse()?)
                    } else {
                        None
                    };
                    Ok(ItemMacro {
                        attrs,
                        ident,
                        mac: Macro {
                            path,
                            bang_token,
                            delimiter,
                            tokens,
                        },
                        semi_token,
                    })
                }
            }

            fn parse_macro2(begin: ParseBuffer, _vis: Visibility, input: ParseStream) -> Result<Item> 
            {
                input.parse::<Token![macro]>()?;
                input.parse::<Ident>()?;

                let mut lookahead = input.lookahead1();
                if lookahead.peek(token::Paren) {
                    let paren_content;
                    parenthesized!(paren_content in input);
                    paren_content.parse::<TokenStream>()?;
                    lookahead = input.lookahead1();
                }

                if lookahead.peek(token::Brace) {
                    let brace_content;
                    braced!(brace_content in input);
                    brace_content.parse::<TokenStream>()?;
                } else {
                    return Err(lookahead.error());
                }

                Ok(Item::Verbatim(verbatim::between(&begin, input)))
            }

            impl Parse for ItemExternCrate
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ItemExternCrate {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        extern_token: input.parse()?,
                        crate_token: input.parse()?,
                        ident: {
                            if input.peek(Token![self]) {
                                input.call(Ident::parse_any)?
                            } else {
                                input.parse()?
                            }
                        },
                        rename: {
                            if input.peek(Token![as]) {
                                let as_token: Token![as] = input.parse()?;
                                let rename: Ident = if input.peek(Token![_]) {
                                    Ident::from(input.parse::<Token![_]>()?)
                                } else {
                                    input.parse()?
                                };
                                Some((as_token, rename))
                            } else {
                                None
                            }
                        },
                        semi_token: input.parse()?,
                    })
                }
            }

            impl Parse for ItemUse
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_crate_root_in_path = false;
                    parse_item_use(input, allow_crate_root_in_path).map(Option::unwrap)
                }
            }

            fn parse_item_use
            (
                input: ParseStream,
                allow_crate_root_in_path: bool,
            ) -> Result<Option<ItemUse>>
            {
                let attrs = input.call(Attribute::parse_outer)?;
                let vis: Visibility = input.parse()?;
                let use_token: Token![use] = input.parse()?;
                let leading_colon: Option<Token![::]> = input.parse()?;
                let tree = parse_use_tree(input, allow_crate_root_in_path && leading_colon.is_none())?;
                let semi_token: Token![;] = input.parse()?;

                let tree = match tree {
                    Some(tree) => tree,
                    None => return Ok(None),
                };

                Ok(Some(ItemUse {
                    attrs,
                    vis,
                    use_token,
                    leading_colon,
                    tree,
                    semi_token,
                }))
            }

            impl Parse for UseTree
            {
                fn parse(input: ParseStream) -> Result<UseTree> {
                    let allow_crate_root_in_path = false;
                    parse_use_tree(input, allow_crate_root_in_path).map(Option::unwrap)
                }
            }

            fn parse_use_tree
            (
                input: ParseStream,
                allow_crate_root_in_path: bool,
            ) -> Result<Option<UseTree>>
            {
                let lookahead = input.lookahead1();
                if lookahead.peek(Ident)
                    || lookahead.peek(Token![self])
                    || lookahead.peek(Token![super])
                    || lookahead.peek(Token![crate])
                    || lookahead.peek(Token![try])
                {
                    let ident = input.call(Ident::parse_any)?;
                    if input.peek(Token![::]) {
                        Ok(Some(UseTree::Path(UsePath {
                            ident,
                            colon2_token: input.parse()?,
                            tree: Box::new(input.parse()?),
                        })))
                    } else if input.peek(Token![as]) {
                        Ok(Some(UseTree::Rename(UseRename {
                            ident,
                            as_token: input.parse()?,
                            rename: {
                                if input.peek(Ident) {
                                    input.parse()?
                                } else if input.peek(Token![_]) {
                                    Ident::from(input.parse::<Token![_]>()?)
                                } else {
                                    return Err(input.error("expected identifier or underscore"));
                                }
                            },
                        })))
                    } else {
                        Ok(Some(UseTree::Name(UseName { ident })))
                    }
                } else if lookahead.peek(Token![*]) {
                    Ok(Some(UseTree::Glob(UseGlob {
                        star_token: input.parse()?,
                    })))
                } else if lookahead.peek(token::Brace) {
                    let content;
                    let brace_token = braced!(content in input);
                    let mut items = Punctuated::new();
                    let mut has_any_crate_root_in_path = false;
                    loop {
                        if content.is_empty() {
                            break;
                        }
                        let this_tree_starts_with_crate_root =
                            allow_crate_root_in_path && content.parse::<Option<Token![::]>>()?.is_some();
                        has_any_crate_root_in_path |= this_tree_starts_with_crate_root;
                        match parse_use_tree(
                            &content,
                            allow_crate_root_in_path && !this_tree_starts_with_crate_root,
                        )? {
                            Some(tree) if !has_any_crate_root_in_path => items.push_value(tree),
                            _ => has_any_crate_root_in_path = true,
                        }
                        if content.is_empty() {
                            break;
                        }
                        let comma: Token![,] = content.parse()?;
                        if !has_any_crate_root_in_path {
                            items.push_punct(comma);
                        }
                    }
                    if has_any_crate_root_in_path {
                        Ok(None)
                    } else {
                        Ok(Some(UseTree::Group(UseGroup { brace_token, items })))
                    }
                } else {
                    Err(lookahead.error())
                }
            }

            impl Parse for ItemStatic
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ItemStatic {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        static_token: input.parse()?,
                        mutability: input.parse()?,
                        ident: input.parse()?,
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                        eq_token: input.parse()?,
                        expr: input.parse()?,
                        semi_token: input.parse()?,
                    })
                }
            }

            impl Parse for ItemConst
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let const_token: Token![const] = input.parse()?;

                    let lookahead = input.lookahead1();
                    let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                        input.call(Ident::parse_any)?
                    } else {
                        return Err(lookahead.error());
                    };

                    let colon_token: Token![:] = input.parse()?;
                    let ty: Type = input.parse()?;
                    let eq_token: Token![=] = input.parse()?;
                    let expr: Expr = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;

                    Ok(ItemConst {
                        attrs,
                        vis,
                        const_token,
                        ident,
                        generics: Generics::default(),
                        colon_token,
                        ty: Box::new(ty),
                        eq_token,
                        expr: Box::new(expr),
                        semi_token,
                    })
                }
            }

            fn peek_signature(input: ParseStream, allow_safe: bool) -> bool
            {
                let fork = input.fork();
                fork.parse::<Option<Token![const]>>().is_ok()
                    && fork.parse::<Option<Token![async]>>().is_ok()
                    && ((allow_safe
                        && token::parsing::peek_keyword(fork.cursor(), "safe")
                        && token::parsing::keyword(&fork, "safe").is_ok())
                        || fork.parse::<Option<Token![unsafe]>>().is_ok())
                    && fork.parse::<Option<Abi>>().is_ok()
                    && fork.peek(Token![fn])
            }

            impl Parse for Signature
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_safe = false;
                    parse_signature(input, allow_safe).map(Option::unwrap)
                }
            }

            fn parse_signature(input: ParseStream, allow_safe: bool) -> Result<Option<Signature>>
            {
                let constness: Option<Token![const]> = input.parse()?;
                let asyncness: Option<Token![async]> = input.parse()?;
                let unsafety: Option<Token![unsafe]> = input.parse()?;
                let safe = allow_safe
                    && unsafety.is_none()
                    && token::parsing::peek_keyword(input.cursor(), "safe");
                if safe {
                    token::parsing::keyword(input, "safe")?;
                }
                let abi: Option<Abi> = input.parse()?;
                let fn_token: Token![fn] = input.parse()?;
                let ident: Ident = input.parse()?;
                let mut generics: Generics = input.parse()?;

                let content;
                let paren_token = parenthesized!(content in input);
                let (inputs, variadic) = parse_fn_args(&content)?;

                let output: ReturnType = input.parse()?;
                generics.where_clause = input.parse()?;

                Ok(if safe {
                    None
                } else {
                    Some(Signature {
                        constness,
                        asyncness,
                        unsafety,
                        abi,
                        fn_token,
                        ident,
                        generics,
                        paren_token,
                        inputs,
                        variadic,
                        output,
                    })
                })
            }

            impl Parse for ItemFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let outer_attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let sig: Signature = input.parse()?;
                    parse_rest_of_fn(input, outer_attrs, vis, sig)
                }
            }

            fn parse_rest_of_fn
            (
                input: ParseStream,
                mut attrs: Vec<Attribute>,
                vis: Visibility,
                sig: Signature,
            ) -> Result<ItemFn>
            {
                let content;
                let brace_token = braced!(content in input);
                attr::parsing::parse_inner(&content, &mut attrs)?;
                let stmts = content.call(Block::parse_within)?;

                Ok(ItemFn {
                    attrs,
                    vis,
                    sig,
                    block: Box::new(Block { brace_token, stmts }),
                })
            }

            impl Parse for FnArg
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_variadic = false;
                    let attrs = input.call(Attribute::parse_outer)?;
                    match parse_fn_arg_or_variadic(input, attrs, allow_variadic)? {
                        FnArgOrVariadic::FnArg(arg) => Ok(arg),
                        FnArgOrVariadic::Variadic(_) => unreachable!(),
                    }
                }
            }

            enum FnArgOrVariadic
            {
                FnArg(FnArg),
                Variadic(Variadic),
            }

            fn parse_fn_arg_or_variadic
            (
                input: ParseStream,
                attrs: Vec<Attribute>,
                allow_variadic: bool,
            ) -> Result<FnArgOrVariadic>
            {
                let ahead = input.fork();
                if let Ok(mut receiver) = ahead.parse::<Receiver>() {
                    input.advance_to(&ahead);
                    receiver.attrs = attrs;
                    return Ok(FnArgOrVariadic::FnArg(FnArg::Receiver(receiver)));
                }

               
               
               
                if input.peek(Ident) && input.peek2(Token![<]) {
                    let span = input.span();
                    return Ok(FnArgOrVariadic::FnArg(FnArg::Typed(PatType {
                        attrs,
                        pat: Box::new(Pat::Wild(PatWild {
                            attrs: Vec::new(),
                            underscore_token: Token![_](span),
                        })),
                        colon_token: Token![:](span),
                        ty: input.parse()?,
                    })));
                }

                let pat = Box::new(Pat::parse_single(input)?);
                let colon_token: Token![:] = input.parse()?;

                if allow_variadic {
                    if let Some(dots) = input.parse::<Option<Token![...]>>()? {
                        return Ok(FnArgOrVariadic::Variadic(Variadic {
                            attrs,
                            pat: Some((pat, colon_token)),
                            dots,
                            comma: None,
                        }));
                    }
                }

                Ok(FnArgOrVariadic::FnArg(FnArg::Typed(PatType {
                    attrs,
                    pat,
                    colon_token,
                    ty: input.parse()?,
                })))
            }

            impl Parse for Receiver
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let reference = if input.peek(Token![&]) {
                        let ampersand: Token![&] = input.parse()?;
                        let lifetime: Option<Lifetime> = input.parse()?;
                        Some((ampersand, lifetime))
                    } else {
                        None
                    };
                    let mutability: Option<Token![mut]> = input.parse()?;
                    let self_token: Token![self] = input.parse()?;
                    let colon_token: Option<Token![:]> = if reference.is_some() {
                        None
                    } else {
                        input.parse()?
                    };
                    let ty: Type = if colon_token.is_some() {
                        input.parse()?
                    } else {
                        let mut ty = Type::Path(TypePath {
                            qself: None,
                            path: Path::from(Ident::new("Self", self_token.span)),
                        });
                        if let Some((ampersand, lifetime)) = reference.as_ref() {
                            ty = Type::Reference(TypeReference {
                                and_token: Token![&](ampersand.span),
                                lifetime: lifetime.clone(),
                                mutability: mutability.as_ref().map(|m| Token![mut](m.span)),
                                elem: Box::new(ty),
                            });
                        }
                        ty
                    };
                    Ok(Receiver {
                        attrs: Vec::new(),
                        reference,
                        mutability,
                        self_token,
                        colon_token,
                        ty: Box::new(ty),
                    })
                }
            }

            fn parse_fn_args
            (
                input: ParseStream,
            ) -> Result<(Punctuated<FnArg, Token![,]>, Option<Variadic>)>
            {
                let mut args = Punctuated::new();
                let mut variadic = None;
                let mut has_receiver = false;

                while !input.is_empty() {
                    let attrs = input.call(Attribute::parse_outer)?;

                    if let Some(dots) = input.parse::<Option<Token![...]>>()? {
                        variadic = Some(Variadic {
                            attrs,
                            pat: None,
                            dots,
                            comma: if input.is_empty() {
                                None
                            } else {
                                Some(input.parse()?)
                            },
                        });
                        break;
                    }

                    let allow_variadic = true;
                    let arg = match parse_fn_arg_or_variadic(input, attrs, allow_variadic)? {
                        FnArgOrVariadic::FnArg(arg) => arg,
                        FnArgOrVariadic::Variadic(arg) => {
                            variadic = Some(Variadic {
                                comma: if input.is_empty() {
                                    None
                                } else {
                                    Some(input.parse()?)
                                },
                                ..arg
                            });
                            break;
                        }
                    };

                    match &arg {
                        FnArg::Receiver(receiver) if has_receiver => {
                            return Err(Error::new(
                                receiver.self_token.span,
                                "unexpected second method receiver",
                            ));
                        }
                        FnArg::Receiver(receiver) if !args.is_empty() => {
                            return Err(Error::new(
                                receiver.self_token.span,
                                "unexpected method receiver",
                            ));
                        }
                        FnArg::Receiver(_) => has_receiver = true,
                        FnArg::Typed(_) => {}
                    }
                    args.push_value(arg);

                    if input.is_empty() {
                        break;
                    }

                    let comma: Token![,] = input.parse()?;
                    args.push_punct(comma);
                }

                Ok((args, variadic))
            }

            impl Parse for ItemMod
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let unsafety: Option<Token![unsafe]> = input.parse()?;
                    let mod_token: Token![mod] = input.parse()?;
                    let ident: Ident = if input.peek(Token![try]) {
                        input.call(Ident::parse_any)
                    } else {
                        input.parse()
                    }?;

                    let lookahead = input.lookahead1();
                    if lookahead.peek(Token![;]) {
                        Ok(ItemMod {
                            attrs,
                            vis,
                            unsafety,
                            mod_token,
                            ident,
                            content: None,
                            semi: Some(input.parse()?),
                        })
                    } else if lookahead.peek(token::Brace) {
                        let content;
                        let brace_token = braced!(content in input);
                        attr::parsing::parse_inner(&content, &mut attrs)?;

                        let mut items = Vec::new();
                        while !content.is_empty() {
                            items.push(content.parse()?);
                        }

                        Ok(ItemMod {
                            attrs,
                            vis,
                            unsafety,
                            mod_token,
                            ident,
                            content: Some((brace_token, items)),
                            semi: None,
                        })
                    } else {
                        Err(lookahead.error())
                    }
                }
            }

            impl Parse for ItemForeignMod
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let unsafety: Option<Token![unsafe]> = input.parse()?;
                    let abi: Abi = input.parse()?;

                    let content;
                    let brace_token = braced!(content in input);
                    attr::parsing::parse_inner(&content, &mut attrs)?;
                    let mut items = Vec::new();
                    while !content.is_empty() {
                        items.push(content.parse()?);
                    }

                    Ok(ItemForeignMod {
                        attrs,
                        unsafety,
                        abi,
                        brace_token,
                        items,
                    })
                }
            }

            impl Parse for ForeignItem
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let ahead = input.fork();
                    let vis: Visibility = ahead.parse()?;

                    let lookahead = ahead.lookahead1();
                    let allow_safe = true;
                    let mut item = if lookahead.peek(Token![fn]) || peek_signature(&ahead, allow_safe) {
                        let vis: Visibility = input.parse()?;
                        let sig = parse_signature(input, allow_safe)?;
                        let has_safe = sig.is_none();
                        let has_body = input.peek(token::Brace);
                        let semi_token: Option<Token![;]> = if has_body {
                            let content;
                            braced!(content in input);
                            content.call(Attribute::parse_inner)?;
                            content.call(Block::parse_within)?;
                            None
                        } else {
                            Some(input.parse()?)
                        };
                        if has_safe || has_body {
                            Ok(ForeignItem::Verbatim(verbatim::between(&begin, input)))
                        } else {
                            Ok(ForeignItem::Fn(ForeignItemFn {
                                attrs: Vec::new(),
                                vis,
                                sig: sig.unwrap(),
                                semi_token: semi_token.unwrap(),
                            }))
                        }
                    } else if lookahead.peek(Token![static])
                        || ((ahead.peek(Token![unsafe])
                            || token::parsing::peek_keyword(ahead.cursor(), "safe"))
                            && ahead.peek2(Token![static]))
                    {
                        let vis = input.parse()?;
                        let unsafety: Option<Token![unsafe]> = input.parse()?;
                        let safe =
                            unsafety.is_none() && token::parsing::peek_keyword(input.cursor(), "safe");
                        if safe {
                            token::parsing::keyword(input, "safe")?;
                        }
                        let static_token = input.parse()?;
                        let mutability = input.parse()?;
                        let ident = input.parse()?;
                        let colon_token = input.parse()?;
                        let ty = input.parse()?;
                        let has_value = input.peek(Token![=]);
                        if has_value {
                            input.parse::<Token![=]>()?;
                            input.parse::<Expr>()?;
                        }
                        let semi_token: Token![;] = input.parse()?;
                        if unsafety.is_some() || safe || has_value {
                            Ok(ForeignItem::Verbatim(verbatim::between(&begin, input)))
                        } else {
                            Ok(ForeignItem::Static(ForeignItemStatic {
                                attrs: Vec::new(),
                                vis,
                                static_token,
                                mutability,
                                ident,
                                colon_token,
                                ty,
                                semi_token,
                            }))
                        }
                    } else if lookahead.peek(Token![type]) {
                        parse_foreign_item_type(begin, input)
                    } else if vis.is_inherited()
                        && (lookahead.peek(Ident)
                            || lookahead.peek(Token![self])
                            || lookahead.peek(Token![super])
                            || lookahead.peek(Token![crate])
                            || lookahead.peek(Token![::]))
                    {
                        input.parse().map(ForeignItem::Macro)
                    } else {
                        Err(lookahead.error())
                    }?;

                    let item_attrs = match &mut item {
                        ForeignItem::Fn(item) => &mut item.attrs,
                        ForeignItem::Static(item) => &mut item.attrs,
                        ForeignItem::Type(item) => &mut item.attrs,
                        ForeignItem::Macro(item) => &mut item.attrs,
                        ForeignItem::Verbatim(_) => return Ok(item),
                    };
                    attrs.append(item_attrs);
                    *item_attrs = attrs;

                    Ok(item)
                }
            }

            impl Parse for ForeignItemFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let sig: Signature = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;
                    Ok(ForeignItemFn {
                        attrs,
                        vis,
                        sig,
                        semi_token,
                    })
                }
            }

            impl Parse for ForeignItemStatic
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ForeignItemStatic {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        static_token: input.parse()?,
                        mutability: input.parse()?,
                        ident: input.parse()?,
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                        semi_token: input.parse()?,
                    })
                }
            }

            impl Parse for ForeignItemType
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ForeignItemType {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        type_token: input.parse()?,
                        ident: input.parse()?,
                        generics: {
                            let mut generics: Generics = input.parse()?;
                            generics.where_clause = input.parse()?;
                            generics
                        },
                        semi_token: input.parse()?,
                    })
                }
            }

            fn parse_foreign_item_type(begin: ParseBuffer, input: ParseStream) -> Result<ForeignItem>
            {
                let FlexibleItemType {
                    vis,
                    defaultness: _,
                    type_token,
                    ident,
                    generics,
                    colon_token,
                    bounds: _,
                    ty,
                    semi_token,
                } = FlexibleItemType::parse(
                    input,
                    TypeDefaultness::Disallowed,
                    WhereClauseLocation::Both,
                )?;

                if colon_token.is_some() || ty.is_some() {
                    Ok(ForeignItem::Verbatim(verbatim::between(&begin, input)))
                } else {
                    Ok(ForeignItem::Type(ForeignItemType {
                        attrs: Vec::new(),
                        vis,
                        type_token,
                        ident,
                        generics,
                        semi_token,
                    }))
                }
            }

            impl Parse for ForeignItemMacro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let mac: Macro = input.parse()?;
                    let semi_token: Option<Token![;]> = if mac.delimiter.is_brace() {
                        None
                    } else {
                        Some(input.parse()?)
                    };
                    Ok(ForeignItemMacro {
                        attrs,
                        mac,
                        semi_token,
                    })
                }
            }

            impl Parse for ItemType
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (ItemType {
                        attrs: input.call(Attribute::parse_outer)?,
                        vis: input.parse()?,
                        type_token: input.parse()?,
                        ident: input.parse()?,
                        generics: {
                            let mut generics: Generics = input.parse()?;
                            generics.where_clause = input.parse()?;
                            generics
                        },
                        eq_token: input.parse()?,
                        ty: input.parse()?,
                        semi_token: input.parse()?,
                    })
                }
            }

            fn parse_item_type(begin: ParseBuffer, input: ParseStream) -> Result<Item>
            {
                let FlexibleItemType {
                    vis,
                    defaultness: _,
                    type_token,
                    ident,
                    generics,
                    colon_token,
                    bounds: _,
                    ty,
                    semi_token,
                } = FlexibleItemType::parse(
                    input,
                    TypeDefaultness::Disallowed,
                    WhereClauseLocation::BeforeEq,
                )?;

                let (eq_token, ty) = match ty {
                    Some(ty) if colon_token.is_none() => ty,
                    _ => return Ok(Item::Verbatim(verbatim::between(&begin, input))),
                };

                Ok(Item::Type(ItemType {
                    attrs: Vec::new(),
                    vis,
                    type_token,
                    ident,
                    generics,
                    eq_token,
                    ty: Box::new(ty),
                    semi_token,
                }))
            }

            impl Parse for ItemStruct
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis = input.parse::<Visibility>()?;
                    let struct_token = input.parse::<Token![struct]>()?;
                    let ident = input.parse::<Ident>()?;
                    let generics = input.parse::<Generics>()?;
                    let (where_clause, fields, semi_token) = derive::parsing::data_struct(input)?;
                    Ok(ItemStruct {
                        attrs,
                        vis,
                        struct_token,
                        ident,
                        generics: Generics {
                            where_clause,
                            ..generics
                        },
                        fields,
                        semi_token,
                    })
                }
            }

            impl Parse for ItemEnum
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis = input.parse::<Visibility>()?;
                    let enum_token = input.parse::<Token![enum]>()?;
                    let ident = input.parse::<Ident>()?;
                    let generics = input.parse::<Generics>()?;
                    let (where_clause, brace_token, variants) = derive::parsing::data_enum(input)?;
                    Ok(ItemEnum {
                        attrs,
                        vis,
                        enum_token,
                        ident,
                        generics: Generics {
                            where_clause,
                            ..generics
                        },
                        brace_token,
                        variants,
                    })
                }
            }

            impl Parse for ItemUnion
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis = input.parse::<Visibility>()?;
                    let union_token = input.parse::<Token![union]>()?;
                    let ident = input.parse::<Ident>()?;
                    let generics = input.parse::<Generics>()?;
                    let (where_clause, fields) = derive::parsing::data_union(input)?;
                    Ok(ItemUnion {
                        attrs,
                        vis,
                        union_token,
                        ident,
                        generics: Generics {
                            where_clause,
                            ..generics
                        },
                        fields,
                    })
                }
            }

            fn parse_trait_or_trait_alias(input: ParseStream) -> Result<Item>
            {
                let (attrs, vis, trait_token, ident, generics) = parse_start_of_trait_alias(input)?;
                let lookahead = input.lookahead1();
                if lookahead.peek(token::Brace)
                    || lookahead.peek(Token![:])
                    || lookahead.peek(Token![where])
                {
                    let unsafety = None;
                    let auto_token = None;
                    parse_rest_of_trait(
                        input,
                        attrs,
                        vis,
                        unsafety,
                        auto_token,
                        trait_token,
                        ident,
                        generics,
                    )
                    .map(Item::Trait)
                } else if lookahead.peek(Token![=]) {
                    parse_rest_of_trait_alias(input, attrs, vis, trait_token, ident, generics)
                        .map(Item::TraitAlias)
                } else {
                    Err(lookahead.error())
                }
            }

            impl Parse for ItemTrait
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let outer_attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let unsafety: Option<Token![unsafe]> = input.parse()?;
                    let auto_token: Option<Token![auto]> = input.parse()?;
                    let trait_token: Token![trait] = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let generics: Generics = input.parse()?;
                    parse_rest_of_trait(
                        input,
                        outer_attrs,
                        vis,
                        unsafety,
                        auto_token,
                        trait_token,
                        ident,
                        generics,
                    )
                }
            }

            fn parse_rest_of_trait
            (
                input: ParseStream,
                mut attrs: Vec<Attribute>,
                vis: Visibility,
                unsafety: Option<Token![unsafe]>,
                auto_token: Option<Token![auto]>,
                trait_token: Token![trait],
                ident: Ident,
                mut generics: Generics,
            ) -> Result<ItemTrait>
            {
                let colon_token: Option<Token![:]> = input.parse()?;

                let mut supertraits = Punctuated::new();
                if colon_token.is_some() {
                    loop {
                        if input.peek(Token![where]) || input.peek(token::Brace) {
                            break;
                        }
                        supertraits.push_value({
                            let allow_precise_capture = false;
                            let allow_const = true;
                            TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                        });
                        if input.peek(Token![where]) || input.peek(token::Brace) {
                            break;
                        }
                        supertraits.push_punct(input.parse()?);
                    }
                }

                generics.where_clause = input.parse()?;

                let content;
                let brace_token = braced!(content in input);
                attr::parsing::parse_inner(&content, &mut attrs)?;
                let mut items = Vec::new();
                while !content.is_empty() {
                    items.push(content.parse()?);
                }

                Ok(ItemTrait {
                    attrs,
                    vis,
                    unsafety,
                    auto_token,
                    restriction: None,
                    trait_token,
                    ident,
                    generics,
                    colon_token,
                    supertraits,
                    brace_token,
                    items,
                })
            }

            impl Parse for ItemTraitAlias
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let (attrs, vis, trait_token, ident, generics) = parse_start_of_trait_alias(input)?;
                    parse_rest_of_trait_alias(input, attrs, vis, trait_token, ident, generics)
                }
            }

            fn parse_start_of_trait_alias
            (
                input: ParseStream,
            ) -> Result<(Vec<Attribute>, Visibility, Token![trait], Ident, Generics)>
            {
                let attrs = input.call(Attribute::parse_outer)?;
                let vis: Visibility = input.parse()?;
                let trait_token: Token![trait] = input.parse()?;
                let ident: Ident = input.parse()?;
                let generics: Generics = input.parse()?;
                Ok((attrs, vis, trait_token, ident, generics))
            }

            fn parse_rest_of_trait_alias
            (
                input: ParseStream,
                attrs: Vec<Attribute>,
                vis: Visibility,
                trait_token: Token![trait],
                ident: Ident,
                mut generics: Generics,
            ) -> Result<ItemTraitAlias>
            {
                let eq_token: Token![=] = input.parse()?;

                let mut bounds = Punctuated::new();
                loop {
                    if input.peek(Token![where]) || input.peek(Token![;]) {
                        break;
                    }
                    bounds.push_value({
                        let allow_precise_capture = false;
                        let allow_const = false;
                        TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                    });
                    if input.peek(Token![where]) || input.peek(Token![;]) {
                        break;
                    }
                    bounds.push_punct(input.parse()?);
                }

                generics.where_clause = input.parse()?;
                let semi_token: Token![;] = input.parse()?;

                Ok(ItemTraitAlias {
                    attrs,
                    vis,
                    trait_token,
                    ident,
                    generics,
                    eq_token,
                    bounds,
                    semi_token,
                })
            }

            impl Parse for TraitItem
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let defaultness: Option<Token![default]> = input.parse()?;
                    let ahead = input.fork();

                    let lookahead = ahead.lookahead1();
                    let allow_safe = false;
                    let mut item = if lookahead.peek(Token![fn]) || peek_signature(&ahead, allow_safe) {
                        input.parse().map(TraitItem::Fn)
                    } else if lookahead.peek(Token![const]) {
                        let const_token: Token![const] = ahead.parse()?;
                        let lookahead = ahead.lookahead1();
                        if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                            input.advance_to(&ahead);
                            let ident = input.call(Ident::parse_any)?;
                            let mut generics: Generics = input.parse()?;
                            let colon_token: Token![:] = input.parse()?;
                            let ty: Type = input.parse()?;
                            let default = if let Some(eq_token) = input.parse::<Option<Token![=]>>()? {
                                let expr: Expr = input.parse()?;
                                Some((eq_token, expr))
                            } else {
                                None
                            };
                            generics.where_clause = input.parse()?;
                            let semi_token: Token![;] = input.parse()?;
                            if generics.lt_token.is_none() && generics.where_clause.is_none() {
                                Ok(TraitItem::Const(TraitItemConst {
                                    attrs: Vec::new(),
                                    const_token,
                                    ident,
                                    generics,
                                    colon_token,
                                    ty,
                                    default,
                                    semi_token,
                                }))
                            } else {
                                return Ok(TraitItem::Verbatim(verbatim::between(&begin, input)));
                            }
                        } else if lookahead.peek(Token![async])
                            || lookahead.peek(Token![unsafe])
                            || lookahead.peek(Token![extern])
                            || lookahead.peek(Token![fn])
                        {
                            input.parse().map(TraitItem::Fn)
                        } else {
                            Err(lookahead.error())
                        }
                    } else if lookahead.peek(Token![type]) {
                        parse_trait_item_type(begin.fork(), input)
                    } else if vis.is_inherited()
                        && defaultness.is_none()
                        && (lookahead.peek(Ident)
                            || lookahead.peek(Token![self])
                            || lookahead.peek(Token![super])
                            || lookahead.peek(Token![crate])
                            || lookahead.peek(Token![::]))
                    {
                        input.parse().map(TraitItem::Macro)
                    } else {
                        Err(lookahead.error())
                    }?;

                    match (vis, defaultness) {
                        (Visibility::Inherited, None) => {}
                        _ => return Ok(TraitItem::Verbatim(verbatim::between(&begin, input))),
                    }

                    let item_attrs = match &mut item {
                        TraitItem::Const(item) => &mut item.attrs,
                        TraitItem::Fn(item) => &mut item.attrs,
                        TraitItem::Type(item) => &mut item.attrs,
                        TraitItem::Macro(item) => &mut item.attrs,
                        TraitItem::Verbatim(_) => unreachable!(),
                    };
                    attrs.append(item_attrs);
                    *item_attrs = attrs;
                    Ok(item)
                }
            }

            impl Parse for TraitItemConst
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let const_token: Token![const] = input.parse()?;

                    let lookahead = input.lookahead1();
                    let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                        input.call(Ident::parse_any)?
                    } else {
                        return Err(lookahead.error());
                    };

                    let colon_token: Token![:] = input.parse()?;
                    let ty: Type = input.parse()?;
                    let default = if input.peek(Token![=]) {
                        let eq_token: Token![=] = input.parse()?;
                        let default: Expr = input.parse()?;
                        Some((eq_token, default))
                    } else {
                        None
                    };
                    let semi_token: Token![;] = input.parse()?;

                    Ok(TraitItemConst {
                        attrs,
                        const_token,
                        ident,
                        generics: Generics::default(),
                        colon_token,
                        ty,
                        default,
                        semi_token,
                    })
                }
            }

            impl Parse for TraitItemFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let sig: Signature = input.parse()?;

                    let lookahead = input.lookahead1();
                    let (brace_token, stmts, semi_token) = if lookahead.peek(token::Brace) {
                        let content;
                        let brace_token = braced!(content in input);
                        attr::parsing::parse_inner(&content, &mut attrs)?;
                        let stmts = content.call(Block::parse_within)?;
                        (Some(brace_token), stmts, None)
                    } else if lookahead.peek(Token![;]) {
                        let semi_token: Token![;] = input.parse()?;
                        (None, Vec::new(), Some(semi_token))
                    } else {
                        return Err(lookahead.error());
                    };

                    Ok(TraitItemFn {
                        attrs,
                        sig,
                        default: brace_token.map(|brace_token| Block { brace_token, stmts }),
                        semi_token,
                    })
                }
            }

            impl Parse for TraitItemType
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let type_token: Token![type] = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let mut generics: Generics = input.parse()?;
                    let (colon_token, bounds) = FlexibleItemType::parse_optional_bounds(input)?;
                    let default = FlexibleItemType::parse_optional_definition(input)?;
                    generics.where_clause = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;
                    Ok(TraitItemType {
                        attrs,
                        type_token,
                        ident,
                        generics,
                        colon_token,
                        bounds,
                        default,
                        semi_token,
                    })
                }
            }

            fn parse_trait_item_type(begin: ParseBuffer, input: ParseStream) -> Result<TraitItem>
            {
                let FlexibleItemType {
                    vis,
                    defaultness: _,
                    type_token,
                    ident,
                    generics,
                    colon_token,
                    bounds,
                    ty,
                    semi_token,
                } = FlexibleItemType::parse(
                    input,
                    TypeDefaultness::Disallowed,
                    WhereClauseLocation::AfterEq,
                )?;

                if vis.is_some() {
                    Ok(TraitItem::Verbatim(verbatim::between(&begin, input)))
                } else {
                    Ok(TraitItem::Type(TraitItemType {
                        attrs: Vec::new(),
                        type_token,
                        ident,
                        generics,
                        colon_token,
                        bounds,
                        default: ty,
                        semi_token,
                    }))
                }
            }

            impl Parse for TraitItemMacro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let mac: Macro = input.parse()?;
                    let semi_token: Option<Token![;]> = if mac.delimiter.is_brace() {
                        None
                    } else {
                        Some(input.parse()?)
                    };
                    Ok(TraitItemMacro {
                        attrs,
                        mac,
                        semi_token,
                    })
                }
            }

            impl Parse for ItemImpl
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_verbatim_impl = false;
                    parse_impl(input, allow_verbatim_impl).map(Option::unwrap)
                }
            }

            fn parse_impl(input: ParseStream, allow_verbatim_impl: bool) -> Result<Option<ItemImpl>>
            {
                let mut attrs = input.call(Attribute::parse_outer)?;
                let has_visibility = allow_verbatim_impl && input.parse::<Visibility>()?.is_some();
                let defaultness: Option<Token![default]> = input.parse()?;
                let unsafety: Option<Token![unsafe]> = input.parse()?;
                let impl_token: Token![impl] = input.parse()?;

                let has_generics = generics::parsing::choose_generics_over_qpath(input);
                let mut generics: Generics = if has_generics {
                    input.parse()?
                } else {
                    Generics::default()
                };

                let is_const_impl = allow_verbatim_impl
                    && (input.peek(Token![const]) || input.peek(Token![?]) && input.peek2(Token![const]));
                if is_const_impl {
                    input.parse::<Option<Token![?]>>()?;
                    input.parse::<Token![const]>()?;
                }

                let polarity = if input.peek(Token![!]) && !input.peek2(token::Brace) {
                    Some(input.parse::<Token![!]>()?)
                } else {
                    None
                };
                
                let mut first_ty: Type = input.parse()?;
                let self_ty: Type;
                let trait_;

                let is_impl_for = input.peek(Token![for]);
                if is_impl_for {
                    let for_token: Token![for] = input.parse()?;
                    let mut first_ty_ref = &first_ty;
                    while let Type::Group(ty) = first_ty_ref {
                        first_ty_ref = &ty.elem;
                    }
                    if let Type::Path(TypePath { qself: None, .. }) = first_ty_ref {
                        while let Type::Group(ty) = first_ty {
                            first_ty = *ty.elem;
                        }
                        if let Type::Path(TypePath { qself: None, path }) = first_ty {
                            trait_ = Some((polarity, path, for_token));
                        } else {
                            unreachable!();
                        }
                    } else if !allow_verbatim_impl {
                        
                return Err(Error::new_spanned(first_ty_ref, "expected trait path"));
                    } else {
                        trait_ = None;
                    }
                    self_ty = input.parse()?;
                } else if let Some(polarity) = polarity {
                    return Err(Error::new(
                        polarity.span,
                        "inherent impls cannot be negative",
                    ));
                } else {
                    trait_ = None;
                    self_ty = first_ty;
                }

                generics.where_clause = input.parse()?;

                let content;
                let brace_token = braced!(content in input);
                attr::parsing::parse_inner(&content, &mut attrs)?;

                let mut items = Vec::new();
                while !content.is_empty() {
                    items.push(content.parse()?);
                }

                if has_visibility || is_const_impl || is_impl_for && trait_.is_none() {
                    Ok(None)
                } else {
                    Ok(Some(ItemImpl {
                        attrs,
                        defaultness,
                        unsafety,
                        impl_token,
                        generics,
                        trait_,
                        self_ty: Box::new(self_ty),
                        brace_token,
                        items,
                    }))
                }
            }

            impl Parse for ImplItem
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let mut attrs = input.call(Attribute::parse_outer)?;
                    let ahead = input.fork();
                    let vis: Visibility = ahead.parse()?;

                    let mut lookahead = ahead.lookahead1();
                    let defaultness = if lookahead.peek(Token![default]) && !ahead.peek2(Token![!]) {
                        let defaultness: Token![default] = ahead.parse()?;
                        lookahead = ahead.lookahead1();
                        Some(defaultness)
                    } else {
                        None
                    };

                    let allow_safe = false;
                    let mut item = if lookahead.peek(Token![fn]) || peek_signature(&ahead, allow_safe) {
                        let allow_omitted_body = true;
                        if let Some(item) = parse_impl_item_fn(input, allow_omitted_body)? {
                            Ok(ImplItem::Fn(item))
                        } else {
                            Ok(ImplItem::Verbatim(verbatim::between(&begin, input)))
                        }
                    } else if lookahead.peek(Token![const]) {
                        input.advance_to(&ahead);
                        let const_token: Token![const] = input.parse()?;
                        let lookahead = input.lookahead1();
                        let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                            input.call(Ident::parse_any)?
                        } else {
                            return Err(lookahead.error());
                        };
                        let mut generics: Generics = input.parse()?;
                        let colon_token: Token![:] = input.parse()?;
                        let ty: Type = input.parse()?;
                        let value = if let Some(eq_token) = input.parse::<Option<Token![=]>>()? {
                            let expr: Expr = input.parse()?;
                            Some((eq_token, expr))
                        } else {
                            None
                        };
                        generics.where_clause = input.parse()?;
                        let semi_token: Token![;] = input.parse()?;
                        return match value {
                            Some((eq_token, expr))
                                if generics.lt_token.is_none() && generics.where_clause.is_none() =>
                            {
                                Ok(ImplItem::Const(ImplItemConst {
                                    attrs,
                                    vis,
                                    defaultness,
                                    const_token,
                                    ident,
                                    generics,
                                    colon_token,
                                    ty,
                                    eq_token,
                                    expr,
                                    semi_token,
                                }))
                            }
                            _ => Ok(ImplItem::Verbatim(verbatim::between(&begin, input))),
                        };
                    } else if lookahead.peek(Token![type]) {
                        parse_impl_item_type(begin, input)
                    } else if vis.is_inherited()
                        && defaultness.is_none()
                        && (lookahead.peek(Ident)
                            || lookahead.peek(Token![self])
                            || lookahead.peek(Token![super])
                            || lookahead.peek(Token![crate])
                            || lookahead.peek(Token![::]))
                    {
                        input.parse().map(ImplItem::Macro)
                    } else {
                        Err(lookahead.error())
                    }?;

                    {
                        let item_attrs = match &mut item {
                            ImplItem::Const(item) => &mut item.attrs,
                            ImplItem::Fn(item) => &mut item.attrs,
                            ImplItem::Type(item) => &mut item.attrs,
                            ImplItem::Macro(item) => &mut item.attrs,
                            ImplItem::Verbatim(_) => return Ok(item),
                        };
                        attrs.append(item_attrs);
                        *item_attrs = attrs;
                    }

                    Ok(item)
                }
            }

            impl Parse for ImplItemConst
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let defaultness: Option<Token![default]> = input.parse()?;
                    let const_token: Token![const] = input.parse()?;

                    let lookahead = input.lookahead1();
                    let ident = if lookahead.peek(Ident) || lookahead.peek(Token![_]) {
                        input.call(Ident::parse_any)?
                    } else {
                        return Err(lookahead.error());
                    };

                    let colon_token: Token![:] = input.parse()?;
                    let ty: Type = input.parse()?;
                    let eq_token: Token![=] = input.parse()?;
                    let expr: Expr = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;

                    Ok(ImplItemConst {
                        attrs,
                        vis,
                        defaultness,
                        const_token,
                        ident,
                        generics: Generics::default(),
                        colon_token,
                        ty,
                        eq_token,
                        expr,
                        semi_token,
                    })
                }
            }

            impl Parse for ImplItemFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_omitted_body = false;
                    parse_impl_item_fn(input, allow_omitted_body).map(Option::unwrap)
                }
            }

            fn parse_impl_item_fn
            (
                input: ParseStream,
                allow_omitted_body: bool,
            ) -> Result<Option<ImplItemFn>>
            {
                let mut attrs = input.call(Attribute::parse_outer)?;
                let vis: Visibility = input.parse()?;
                let defaultness: Option<Token![default]> = input.parse()?;
                let sig: Signature = input.parse()?;

               
               
               
                if allow_omitted_body && input.parse::<Option<Token![;]>>()?.is_some() {
                    return Ok(None);
                }

                let content;
                let brace_token = braced!(content in input);
                attrs.extend(content.call(Attribute::parse_inner)?);
                let block = Block {
                    brace_token,
                    stmts: content.call(Block::parse_within)?,
                };

                Ok(Some(ImplItemFn {
                    attrs,
                    vis,
                    defaultness,
                    sig,
                    block,
                }))
            }

            impl Parse for ImplItemType
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let vis: Visibility = input.parse()?;
                    let defaultness: Option<Token![default]> = input.parse()?;
                    let type_token: Token![type] = input.parse()?;
                    let ident: Ident = input.parse()?;
                    let mut generics: Generics = input.parse()?;
                    let eq_token: Token![=] = input.parse()?;
                    let ty: Type = input.parse()?;
                    generics.where_clause = input.parse()?;
                    let semi_token: Token![;] = input.parse()?;
                    Ok(ImplItemType {
                        attrs,
                        vis,
                        defaultness,
                        type_token,
                        ident,
                        generics,
                        eq_token,
                        ty,
                        semi_token,
                    })
                }
            }

            fn parse_impl_item_type(begin: ParseBuffer, input: ParseStream) -> Result<ImplItem>
            {
                let FlexibleItemType {
                    vis,
                    defaultness,
                    type_token,
                    ident,
                    generics,
                    colon_token,
                    bounds: _,
                    ty,
                    semi_token,
                } = FlexibleItemType::parse(
                    input,
                    TypeDefaultness::Optional,
                    WhereClauseLocation::AfterEq,
                )?;

                let (eq_token, ty) = match ty {
                    Some(ty) if colon_token.is_none() => ty,
                    _ => return Ok(ImplItem::Verbatim(verbatim::between(&begin, input))),
                };

                Ok(ImplItem::Type(ImplItemType {
                    attrs: Vec::new(),
                    vis,
                    defaultness,
                    type_token,
                    ident,
                    generics,
                    eq_token,
                    ty,
                    semi_token,
                }))
            }

            impl Parse for ImplItemMacro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let attrs = input.call(Attribute::parse_outer)?;
                    let mac: Macro = input.parse()?;
                    let semi_token: Option<Token![;]> = if mac.delimiter.is_brace() {
                        None
                    } else {
                        Some(input.parse()?)
                    };
                    Ok(ImplItemMacro {
                        attrs,
                        mac,
                        semi_token,
                    })
                }
            }

            impl Visibility
            {
                fn is_inherited(&self) -> bool
        {
                    match self {
                        Visibility::Inherited => true,
                        _ => false,
                    }
                }
            }

            impl Parse for StaticMutability
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let mut_token: Option<Token![mut]> = input.parse()?;
                    Ok(mut_token.map_or(StaticMutability::None, StaticMutability::Mut))
                }
            }
        }
        
        pub mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    attr::FilterAttrs,
                    data::Fields,
                    item::
                    {
                        ForeignItemFn, ForeignItemMacro, ForeignItemStatic, ForeignItemType, ImplItemConst,
                        ImplItemFn, ImplItemMacro, ImplItemType, ItemConst, ItemEnum, ItemExternCrate, ItemFn,
                        ItemForeignMod, ItemImpl, ItemMacro, ItemMod, ItemStatic, ItemStruct, ItemTrait,
                        ItemTraitAlias, ItemType, ItemUnion, ItemUse, Receiver, Signature, StaticMutability,
                        TraitItemConst, TraitItemFn, TraitItemMacro, TraitItemType, UseGlob, UseGroup, UseName,
                        UsePath, UseRename, Variadic,
                    },
                    mac::MacroDelimiter,
                    path,
                    path::printing::PathStyle,
                    print::TokensOrDefault,
                    ty::Type,
                },
                *,
            };
            
            impl ToTokens for ItemExternCrate {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.extern_token.to_tokens(tokens);
                    self.crate_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    if let Some((as_token, rename)) = &self.rename {
                        as_token.to_tokens(tokens);
                        rename.to_tokens(tokens);
                    }
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemUse {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.use_token.to_tokens(tokens);
                    self.leading_colon.to_tokens(tokens);
                    self.tree.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemStatic {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.static_token.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.expr.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemConst {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.const_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.expr.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemFn {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.sig.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }

            impl ToTokens for ItemMod {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.mod_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    if let Some((brace, items)) = &self.content {
                        brace.surround(tokens, |tokens| {
                            tokens.append_all(self.attrs.inner());
                            tokens.append_all(items);
                        });
                    } else {
                        TokensOrDefault(&self.semi).to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for ItemForeignMod {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.unsafety.to_tokens(tokens);
                    self.abi.to_tokens(tokens);
                    self.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.items);
                    });
                }
            }

            impl ToTokens for ItemType {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.type_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemEnum {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.enum_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.brace_token.surround(tokens, |tokens| {
                        self.variants.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for ItemStruct {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.struct_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    match &self.fields {
                        Fields::Named(fields) => {
                            self.generics.where_clause.to_tokens(tokens);
                            fields.to_tokens(tokens);
                        }
                        Fields::Unnamed(fields) => {
                            fields.to_tokens(tokens);
                            self.generics.where_clause.to_tokens(tokens);
                            TokensOrDefault(&self.semi_token).to_tokens(tokens);
                        }
                        Fields::Unit => {
                            self.generics.where_clause.to_tokens(tokens);
                            TokensOrDefault(&self.semi_token).to_tokens(tokens);
                        }
                    }
                }
            }

            impl ToTokens for ItemUnion {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.union_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.fields.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemTrait {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.auto_token.to_tokens(tokens);
                    self.trait_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    if !self.supertraits.is_empty() {
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                        self.supertraits.to_tokens(tokens);
                    }
                    self.generics.where_clause.to_tokens(tokens);
                    self.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.items);
                    });
                }
            }

            impl ToTokens for ItemTraitAlias {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.trait_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ItemImpl {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.defaultness.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.impl_token.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    if let Some((polarity, path, for_token)) = &self.trait_ {
                        polarity.to_tokens(tokens);
                        path.to_tokens(tokens);
                        for_token.to_tokens(tokens);
                    }
                    self.self_ty.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.items);
                    });
                }
            }

            impl ToTokens for ItemMacro {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    path::printing::print_path(tokens, &self.mac.path, PathStyle::Mod);
                    self.mac.bang_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    match &self.mac.delimiter {
                        MacroDelimiter::Paren(paren) => {
                            paren.surround(tokens, |tokens| self.mac.tokens.to_tokens(tokens));
                        }
                        MacroDelimiter::Brace(brace) => {
                            brace.surround(tokens, |tokens| self.mac.tokens.to_tokens(tokens));
                        }
                        MacroDelimiter::Bracket(bracket) => {
                            bracket.surround(tokens, |tokens| self.mac.tokens.to_tokens(tokens));
                        }
                    }
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for UsePath {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.colon2_token.to_tokens(tokens);
                    self.tree.to_tokens(tokens);
                }
            }

            impl ToTokens for UseName {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                }
            }

            impl ToTokens for UseRename {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.as_token.to_tokens(tokens);
                    self.rename.to_tokens(tokens);
                }
            }

            impl ToTokens for UseGlob {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.star_token.to_tokens(tokens);
                }
            }

            impl ToTokens for UseGroup {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.brace_token.surround(tokens, |tokens| {
                        self.items.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TraitItemConst {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.const_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    if let Some((eq_token, default)) = &self.default {
                        eq_token.to_tokens(tokens);
                        default.to_tokens(tokens);
                    }
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for TraitItemFn {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.sig.to_tokens(tokens);
                    match &self.default {
                        Some(block) => {
                            block.brace_token.surround(tokens, |tokens| {
                                tokens.append_all(self.attrs.inner());
                                tokens.append_all(&block.stmts);
                            });
                        }
                        None => {
                            TokensOrDefault(&self.semi_token).to_tokens(tokens);
                        }
                    }
                }
            }

            impl ToTokens for TraitItemType {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.type_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    if !self.bounds.is_empty() {
                        TokensOrDefault(&self.colon_token).to_tokens(tokens);
                        self.bounds.to_tokens(tokens);
                    }
                    if let Some((eq_token, default)) = &self.default {
                        eq_token.to_tokens(tokens);
                        default.to_tokens(tokens);
                    }
                    self.generics.where_clause.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for TraitItemMacro {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.mac.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ImplItemConst {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.defaultness.to_tokens(tokens);
                    self.const_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.expr.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ImplItemFn {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.defaultness.to_tokens(tokens);
                    self.sig.to_tokens(tokens);
                    self.block.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(self.attrs.inner());
                        tokens.append_all(&self.block.stmts);
                    });
                }
            }

            impl ToTokens for ImplItemType {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.defaultness.to_tokens(tokens);
                    self.type_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ImplItemMacro {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.mac.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ForeignItemFn {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.sig.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ForeignItemStatic {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.static_token.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ForeignItemType {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.vis.to_tokens(tokens);
                    self.type_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for ForeignItemMacro {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.mac.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for Signature {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.constness.to_tokens(tokens);
                    self.asyncness.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.abi.to_tokens(tokens);
                    self.fn_token.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.paren_token.surround(tokens, |tokens| {
                        self.inputs.to_tokens(tokens);
                        if let Some(variadic) = &self.variadic {
                            if !self.inputs.empty_or_trailing() {
                                <Token![,]>::default().to_tokens(tokens);
                            }
                            variadic.to_tokens(tokens);
                        }
                    });
                    self.output.to_tokens(tokens);
                    self.generics.where_clause.to_tokens(tokens);
                }
            }

            impl ToTokens for Receiver {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some((ampersand, lifetime)) = &self.reference {
                        ampersand.to_tokens(tokens);
                        lifetime.to_tokens(tokens);
                    }
                    self.mutability.to_tokens(tokens);
                    self.self_token.to_tokens(tokens);
                    if let Some(colon_token) = &self.colon_token {
                        colon_token.to_tokens(tokens);
                        self.ty.to_tokens(tokens);
                    } else {
                        let consistent = match (&self.reference, &self.mutability, &*self.ty) {
                            (Some(_), mutability, Type::Reference(ty)) => {
                                mutability.is_some() == ty.mutability.is_some()
                                    && match &*ty.elem {
                                        Type::Path(ty) => ty.qself.is_none() && ty.path.is_ident("Self"),
                                        _ => false,
                                    }
                            }
                            (None, _, Type::Path(ty)) => ty.qself.is_none() && ty.path.is_ident("Self"),
                            _ => false,
                        };
                        if !consistent {
                            <Token![:]>::default().to_tokens(tokens);
                            self.ty.to_tokens(tokens);
                        }
                    }
                }
            }

            impl ToTokens for Variadic {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some((pat, colon)) = &self.pat {
                        pat.to_tokens(tokens);
                        colon.to_tokens(tokens);
                    }
                    self.dots.to_tokens(tokens);
                    self.comma.to_tokens(tokens);
                }
            }

            impl ToTokens for StaticMutability {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        StaticMutability::None => {}
                        StaticMutability::Mut(mut_token) => mut_token.to_tokens(tokens),
                    }
                }
            }
        }
    } pub use self::item::
    {
        FnArg, ForeignItem, ForeignItemFn, ForeignItemMacro, ForeignItemStatic, ForeignItemType, ImplItem,
        ImplItemConst, ImplItemFn, ImplItemMacro, ImplItemType, ImplRestriction, Item, ItemConst, ItemEnum,
        ItemExternCrate, ItemFn, ItemForeignMod, ItemImpl, ItemMacro, ItemMod, ItemStatic, ItemStruct, ItemTrait,
        ItemTraitAlias, ItemType, ItemUnion, ItemUse, Receiver, Signature, StaticMutability, TraitItem,
        TraitItemConst, TraitItemFn, TraitItemMacro, TraitItemType, UseGlob, UseGroup, UseName, UsePath,
        UseRename, UseTree, Variadic,
    };

    pub mod lifetime
    {
        use ::
        {
            cmp::{ Ordering },
            fmt::{ self, Display },
            hash::{ Hash, Hasher },
            process::macros::{ Ident, Span },
            syntax::{ lookahead },
            *,
        };
        /*
        */
        /// A Rust lifetime: `'a`.
        pub struct Lifetime 
        {
            pub apostrophe: Span,
            pub ident: Ident,
        }

        impl Lifetime 
        {
            /// # Panics
            ///
            /// Panics if the lifetime does not conform to the bulleted rules above.
            /// # use syn::Lifetime;
            /// #
            /// # fn f() -> Lifetime {
            /// Lifetime::new("'a", Span::call_site())
            /// # }
            /// ```
            pub fn new(symbol: &str, span: Span) -> Self {
                if !symbol.starts_with('\'') {
                    panic!(
                        "lifetime name must start with apostrophe as in \"'a\", got {:?}",
                        symbol
                    );
                }

                if symbol == "'" {
                    panic!("lifetime name must not be empty");
                }

                if !::syntax::ident::xid_ok(&symbol[1..]) {
                    panic!("{:?} is not a valid lifetime name", symbol);
                }

                Lifetime {
                    apostrophe: span,
                    ident: Ident::new(&symbol[1..], span),
                }
            }

            pub fn span(&self) -> Span
            {
                self.apostrophe
                    .join(self.ident.span())
                    .unwrap_or(self.apostrophe)
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.apostrophe = span;
                self.ident.set_span(span);
            }
        }

        impl Display for Lifetime 
        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                "'".fmt(formatter)?;
                self.ident.fmt(formatter)
            }
        }

        impl Clone for Lifetime 
        {
            fn clone(&self) -> Self {
                Lifetime {
                    apostrophe: self.apostrophe,
                    ident: self.ident.clone(),
                }
            }
        }

        impl PartialEq for Lifetime 
        {
            fn eq(&self, other: &Lifetime) -> bool
            {
                self.ident.eq(&other.ident)
            }
        }

        impl Eq for Lifetime {}

        impl PartialOrd for Lifetime 
        {
            fn partial_cmp(&self, other: &Lifetime) -> Option<Ordering> {
                Some(self.cmp(other))
            }
        }

        impl Ord for Lifetime 
        {
            fn cmp(&self, other: &Lifetime) -> Ordering
            {
                self.ident.cmp(&other.ident)
            }
        }

        impl Hash for Lifetime 
        {
            fn hash<H: Hasher>(&self, h: &mut H)
            {
                self.ident.hash(h);
            }
        }
        
        pub_if_not_doc!
        {
            pub fn Lifetime(marker: lookahead::TokenMarker) -> Lifetime
            {
                match marker {}
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    error::Result,
                    lifetime::Lifetime,
                    parse::{Parse, ParseStream},
                },
                *,
            };
            
            impl Parse for Lifetime
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    input.step(|cursor| {
                        cursor
                            .lifetime()
                            .ok_or_else(|| cursor.error("expected lifetime"))
                    })
                }
            }
        }

        mod printing
        {
            use ::
            {
                process::macros::{Punct, Spacing, TokenStream},
                quote::{ToTokens, TokenStreamExt},
                syntax::lifetime::Lifetime,
                *,
            };
            
            impl ToTokens for Lifetime {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    let mut apostrophe = Punct::new('\'', Spacing::Joint);
                    apostrophe.set_span(self.apostrophe);
                    tokens.append(apostrophe);
                    self.ident.to_tokens(tokens);
                }
            }
        }
    } pub use self::lifetime::{ Lifetime };

    pub mod lit
    {
        use ::
        {
            ffi::{ CStr, CString },
            fmt::{ self, Display },
            hash::{ Hash, Hasher },
            process::macros::
            {
                Ident, Literal, Span, TokenStream, TokenTree
            },
            syntax::
            {
                parse::{ Parse, Parser },
                lookahead, Error, Result
            },
            str::{ self, FromStr },
            *,
        };
        /*
        */
        ast_enum_of_structs!
        {
            /// A Rust literal such as a string or integer or boolean.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            #[non_exhaustive]
            pub enum Lit {
                /// A UTF-8 string literal: `"foo"`.
                Str(LitStr),
                /// A byte string literal: `b"foo"`.
                ByteStr(LitByteStr),
                /// A nul-terminated C-string literal: `c"foo"`.
                CStr(LitCStr),
                /// A byte literal: `b'f'`.
                Byte(LitByte),
                /// A character literal: `'a'`.
                Char(LitChar),
                /// An integer literal: `1` or `1u16`.
                Int(LitInt),
                /// A floating point literal: `1f64` or `1.0e10f64`.
                ///
                /// Must be finite. May not be infinite or NaN.
                Float(LitFloat),
                /// A boolean literal: `true` or `false`.
                Bool(LitBool),
                /// A raw token literal not interpreted by Syn.
                Verbatim(Literal),
            }
        }

        ast_struct! {
            /// A UTF-8 string literal: `"foo"`.
            pub struct LitStr {
                repr: Box<LitRepr>,
            }
        }

        ast_struct! {
            /// A byte string literal: `b"foo"`.
            pub struct LitByteStr {
                repr: Box<LitRepr>,
            }
        }

        ast_struct! {
            /// A nul-terminated C-string literal: `c"foo"`.
            pub struct LitCStr {
                repr: Box<LitRepr>,
            }
        }

        ast_struct! {
            /// A byte literal: `b'f'`.
            pub struct LitByte {
                repr: Box<LitRepr>,
            }
        }

        ast_struct! {
            /// A character literal: `'a'`.
            pub struct LitChar {
                repr: Box<LitRepr>,
            }
        }

        struct LitRepr {
            token: Literal,
            suffix: Box<str>,
        }

        ast_struct! {
            /// An integer literal: `1` or `1u16`.
            pub struct LitInt {
                repr: Box<LitIntRepr>,
            }
        }

        struct LitIntRepr {
            token: Literal,
            digits: Box<str>,
            suffix: Box<str>,
        }

        ast_struct! {
            /// A floating point literal: `1f64` or `1.0e10f64`.
            ///
            /// Must be finite. May not be infinite or NaN.
            pub struct LitFloat {
                repr: Box<LitFloatRepr>,
            }
        }

        struct LitFloatRepr {
            token: Literal,
            digits: Box<str>,
            suffix: Box<str>,
        }

        ast_struct! {
            /// A boolean literal: `true` or `false`.
            pub struct LitBool {
                pub value: bool,
                pub span: Span,
            }
        }

        impl LitStr {
            pub fn new(value: &str, span: Span) -> Self {
                let mut token = Literal::string(value);
                token.set_span(span);
                LitStr {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> String {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_str(&repr);
                String::from(value)
            }
            /// Parse a syntax tree node from the content of this string literal.
            ///         return Ok(None);
            ///     }
            ///
            ///     if let Meta::NameValue(meta) = &attr.meta {
            ///         if let Expr::Lit(expr) = &meta.value {
            ///             if let Lit::Str(lit_str) = &expr.lit {
            ///                 return lit_str.parse().map(Some);
            ///             }
            ///         }
            ///     }
            ///
            ///     let message = "expected #[path = \"...\"]";
            ///     Err(Error::new_spanned(attr, message))
            /// }
            /// ```
             
                pub fn parse<T: Parse>(&self) -> Result<T>
            {
                self.parse_with(T::parse)
            }
            /// Invoke parser on the content of this string literal.
            /// #     const IGNORE: &str = stringify! {
            /// let lit_str: LitStr = /* ... */;
            /// #     };
            ///
            ///
            ///
            /// let basic_path = lit_str.parse_with(syn::Path::parse_mod_style)?;
            /// #
            /// #     Ok(())
            /// # }
            /// ```
             
                pub fn parse_with<F: Parser>(&self, parser: F) -> Result<F::Output> {
                use ::process::macros::Group;

               
                fn respan_token_stream(stream: TokenStream, span: Span) -> TokenStream {
                    stream
                        .into_iter()
                        .map(|token| respan_token_tree(token, span))
                        .collect()
                }

               
                fn respan_token_tree(mut token: TokenTree, span: Span) -> TokenTree {
                    match &mut token {
                        TokenTree::Group(g) => {
                            let stream = respan_token_stream(g.stream(), span);
                            *g = Group::new(g.delimiter(), stream);
                            g.set_span(span);
                        }
                        other => other.set_span(span),
                    }
                    token
                }

               
               
                let span = self.span();
                let mut tokens = TokenStream::from_str(&self.value())?;
                tokens = respan_token_stream(tokens, span);

                let result = ::syntax::parse::parse_scoped(parser, span, tokens)?;

                let suffix = self.suffix();
                if !suffix.is_empty() {
                    return Err(Error::new(
                        self.span(),
                        format!("unexpected suffix `{}` on string literal", suffix),
                    ));
                }

                Ok(result)
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitByteStr {
            pub fn new(value: &[u8], span: Span) -> Self {
                let mut token = Literal::byte_string(value);
                token.set_span(span);
                LitByteStr {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> Vec<u8>
            {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_byte_str(&repr);
                value
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitCStr {
            pub fn new(value: &CStr, span: Span) -> Self {
                let mut token = Literal::c_string(value);
                token.set_span(span);
                LitCStr {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> CString {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_c_str(&repr);
                value
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitByte {
            pub fn new(value: u8, span: Span) -> Self {
                let mut token = Literal::u8_suffixed(value);
                token.set_span(span);
                LitByte {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> u8 {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_byte(&repr);
                value
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitChar {
            pub fn new(value: char, span: Span) -> Self {
                let mut token = Literal::character(value);
                token.set_span(span);
                LitChar {
                    repr: Box::new(LitRepr {
                        token,
                        suffix: Box::<str>::default(),
                    }),
                }
            }

            pub fn value(&self) -> char {
                let repr = self.repr.token.to_string();
                let (value, _suffix) = value::parse_lit_char(&repr);
                value
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl LitInt {
            #[track_caller]
            pub fn new(repr: &str, span: Span) -> Self {
                let (digits, suffix) = match value::parse_lit_int(repr) {
                    Some(parse) => parse,
                    None => panic!("not an integer literal: `{}`", repr),
                };

                let mut token: Literal = repr.parse().unwrap();
                token.set_span(span);
                LitInt {
                    repr: Box::new(LitIntRepr {
                        token,
                        digits,
                        suffix,
                    }),
                }
            }

            pub fn base10_digits(&self) -> &str {
                &self.repr.digits
            }
            /// Parses the literal into a selected number type.
            /// in the macro input.
            /// use syn::parse::{Parse, ParseStream, Result};
            ///
            /// struct Port {
            ///     value: u16,
            /// }
            ///
            /// impl Parse for Port {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         let lit: LitInt = input.parse()?;
            ///         let value = lit.base10_parse::<u16>()?;
            ///         Ok(Port { value })
            ///     }
            /// }
            /// ```
            pub fn base10_parse<N>(&self) -> Result<N> where
                N: FromStr,
                N::Err: Display,
           
            {
                self.base10_digits()
                    .parse()
                    .map_err(|err| Error::new(self.span(), err))
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl From<Literal> for LitInt {
            #[track_caller]
            fn from(token: Literal) -> Self {
                let repr = token.to_string();
                if let Some((digits, suffix)) = value::parse_lit_int(&repr) {
                    LitInt {
                        repr: Box::new(LitIntRepr {
                            token,
                            digits,
                            suffix,
                        }),
                    }
                } else {
                    panic!("not an integer literal: `{}`", repr);
                }
            }
        }

        impl Display for LitInt {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result
            {
                self.repr.token.fmt(formatter)
            }
        }

        impl LitFloat {
            #[track_caller]
            pub fn new(repr: &str, span: Span) -> Self {
                let (digits, suffix) = match value::parse_lit_float(repr) {
                    Some(parse) => parse,
                    None => panic!("not a float literal: `{}`", repr),
                };

                let mut token: Literal = repr.parse().unwrap();
                token.set_span(span);
                LitFloat {
                    repr: Box::new(LitFloatRepr {
                        token,
                        digits,
                        suffix,
                    }),
                }
            }

            pub fn base10_digits(&self) -> &str {
                &self.repr.digits
            }

            pub fn base10_parse<N>(&self) -> Result<N> where
                N: FromStr,
                N::Err: Display,
           
            {
                self.base10_digits()
                    .parse()
                    .map_err(|err| Error::new(self.span(), err))
            }

            pub fn suffix(&self) -> &str {
                &self.repr.suffix
            }

            pub fn span(&self) -> Span
            {
                self.repr.token.span()
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.repr.token.set_span(span);
            }

            pub fn token(&self) -> Literal
            {
                self.repr.token.clone()
            }
        }

        impl From<Literal> for LitFloat {
            #[track_caller]
            fn from(token: Literal) -> Self {
                let repr = token.to_string();
                if let Some((digits, suffix)) = value::parse_lit_float(&repr) {
                    LitFloat {
                        repr: Box::new(LitFloatRepr {
                            token,
                            digits,
                            suffix,
                        }),
                    }
                } else {
                    panic!("not a float literal: `{}`", repr);
                }
            }
        }

        impl Display for LitFloat {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result
            {
                self.repr.token.fmt(formatter)
            }
        }

        impl LitBool {
            pub fn new(value: bool, span: Span) -> Self {
                LitBool { value, span }
            }

            pub fn value(&self) -> bool
            {
                self.value
            }

            pub fn span(&self) -> Span
            {
                self.span
            }

            pub fn set_span(&mut self, span: Span)
            {
                self.span = span;
            }

            pub fn token(&self) -> Ident {
                let s = if self.value { "true" } else { "false" };
                Ident::new(s, self.span)
            }
        }

        mod debug_impls
        {
            use ::
            {
                fmt::{ self, Debug },
                syntax::lit::{ LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitInt, LitStr },
                *,
            };

            impl  Debug for LitStr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitStr")
                }
            }

            impl LitStr {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitByteStr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitByteStr")
                }
            }

            impl LitByteStr {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitCStr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitCStr")
                }
            }

            impl LitCStr {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitByte {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitByte")
                }
            }

            impl LitByte {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitChar {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitChar")
                }
            }

            impl LitChar {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitInt {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitInt")
                }
            }

            impl LitInt {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitFloat {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitFloat")
                }
            }

            impl LitFloat {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("token", &format_args!("{}", self.repr.token))
                        .finish()
                }
            }

            impl  Debug for LitBool {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "LitBool")
                }
            }

            impl LitBool {
                pub fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    formatter
                        .debug_struct(name)
                        .field("value", &self.value)
                        .finish()
                }
            }
        }

        impl Clone for LitRepr {
            fn clone(&self) -> Self {
                LitRepr {
                    token: self.token.clone(),
                    suffix: self.suffix.clone(),
                }
            }
        }

        impl Clone for LitIntRepr {
            fn clone(&self) -> Self {
                LitIntRepr {
                    token: self.token.clone(),
                    digits: self.digits.clone(),
                    suffix: self.suffix.clone(),
                }
            }
        }

        impl Clone for LitFloatRepr {
            fn clone(&self) -> Self {
                LitFloatRepr {
                    token: self.token.clone(),
                    digits: self.digits.clone(),
                    suffix: self.suffix.clone(),
                }
            }
        }

        macro_rules! lit_extra_traits {
            ($ty:ident) => {
                impl Clone for $ty {
                    fn clone(&self) -> Self {
                        $ty {
                            repr: self.repr.clone(),
                        }
                    }
                }

                        impl PartialEq for $ty {
                    fn eq(&self, other: &Self) -> bool
        {
                        self.repr.token.to_string() == other.repr.token.to_string()
                    }
                }

                        impl Hash for $ty {
                    fn hash<H>(&self, state: &mut H)
                    where
                        H: Hasher,
                    {
                        self.repr.token.to_string().hash(state);
                    }
                }

                 
                    pub_if_not_doc! {
                                
                    pub fn $ty(marker: lookahead::TokenMarker) -> $ty {
                        match marker {}
                    }
                }
            };
        }

        lit_extra_traits!(LitStr);
        lit_extra_traits!(LitByteStr);
        lit_extra_traits!(LitCStr);
        lit_extra_traits!(LitByte);
        lit_extra_traits!(LitChar);
        lit_extra_traits!(LitInt);
        lit_extra_traits!(LitFloat);

         
            pub_if_not_doc! {
                
            pub fn LitBool(marker: lookahead::TokenMarker) -> LitBool {
                match marker {}
            }
        }
        /// The style of a string literal, either plain quoted or a raw string like `r##"data"##`.
        pub enum StrStyle {
            /// An ordinary string like `"data"`.
            Cooked,
            /// A raw string like `r##"data"##`.
            ///
            /// The unsigned integer is the number of `#` symbols used.
            Raw(usize),
        }

         
            pub_if_not_doc! {
                
            pub fn Lit(marker: lookahead::TokenMarker) -> Lit {
                match marker {}
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                cell::{ Cell },
                process::macros::{ Literal, Punct, Span },
                rc::{ Rc },
                syntax::
                {
                    buffer::Cursor,
                    error::Result,
                    lit::
                    {
                        value, Lit, LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitFloatRepr, LitInt,
                        LitIntRepr, LitStr,
                    },
                    parse::{Parse, ParseStream, Unexpected},
                    token::{self, Token},
                },
            };

            impl Parse for Lit
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    input.step(|cursor| {
                        if let Some((lit, rest)) = cursor.literal() {
                            return Ok((Lit::new(lit), rest));
                        }

                        if let Some((ident, rest)) = cursor.ident() {
                            let value = ident == "true";
                            if value || ident == "false" {
                                let lit_bool = LitBool {
                                    value,
                                    span: ident.span(),
                                };
                                return Ok((Lit::Bool(lit_bool), rest));
                            }
                        }

                        if let Some((punct, rest)) = cursor.punct() {
                            if punct.as_char() == '-' {
                                if let Some((lit, rest)) = parse_negative_lit(punct, rest) {
                                    return Ok((lit, rest));
                                }
                            }
                        }

                        Err(cursor.error("expected literal"))
                    })
                }
            }

            fn parse_negative_lit(neg: Punct, cursor: Cursor) -> Option<(Lit, Cursor)>
            {
                let (lit, rest) = cursor.literal()?;

                let mut span = neg.span();
                span = span.join(lit.span()).unwrap_or(span);

                let mut repr = lit.to_string();
                repr.insert(0, '-');

                if let Some((digits, suffix)) = value::parse_lit_int(&repr) {
                    let mut token: Literal = repr.parse().unwrap();
                    token.set_span(span);
                    return Some((
                        Lit::Int(LitInt {
                            repr: Box::new(LitIntRepr {
                                token,
                                digits,
                                suffix,
                            }),
                        }),
                        rest,
                    ));
                }

                let (digits, suffix) = value::parse_lit_float(&repr)?;
                let mut token: Literal = repr.parse().unwrap();
                token.set_span(span);
                Some((
                    Lit::Float(LitFloat {
                        repr: Box::new(LitFloatRepr {
                            token,
                            digits,
                            suffix,
                        }),
                    }),
                    rest,
                ))
            }

            impl Parse for LitStr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Str(lit)) => Ok(lit),
                        _ => Err(head.error("expected string literal")),
                    }
                }
            }

            impl Parse for LitByteStr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::ByteStr(lit)) => Ok(lit),
                        _ => Err(head.error("expected byte string literal")),
                    }
                }
            }

            impl Parse for LitCStr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::CStr(lit)) => Ok(lit),
                        _ => Err(head.error("expected C string literal")),
                    }
                }
            }

            impl Parse for LitByte
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Byte(lit)) => Ok(lit),
                        _ => Err(head.error("expected byte literal")),
                    }
                }
            }

            impl Parse for LitChar
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Char(lit)) => Ok(lit),
                        _ => Err(head.error("expected character literal")),
                    }
                }
            }

            impl Parse for LitInt
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Int(lit)) => Ok(lit),
                        _ => Err(head.error("expected integer literal")),
                    }
                }
            }

            impl Parse for LitFloat
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Float(lit)) => Ok(lit),
                        _ => Err(head.error("expected floating point literal")),
                    }
                }
            }

            impl Parse for LitBool
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let head = input.fork();
                    match input.parse() {
                        Ok(Lit::Bool(lit)) => Ok(lit),
                        _ => Err(head.error("expected boolean literal")),
                    }
                }
            }

            fn peek_impl(cursor: Cursor, peek: fn(ParseStream) -> bool) -> bool
        {
                let scope = Span::call_site();
                let unexpected = Rc::new(Cell::new(Unexpected::None));
                let buffer = ::syntax::parse::new_parse_buffer(scope, cursor, unexpected);
                peek(&buffer)
            }

            macro_rules! impl_token {
                ($display:literal $name:ty) => {
                    impl Token for $name {
                        fn peek(cursor: Cursor) -> bool
        {
                            fn peek(input: ParseStream) -> bool
        {
                                <$name as Parse>::parse(input).is_ok()
                            }
                            peek_impl(cursor, peek)
                        }

                        fn display() -> &'static str {
                            $display
                        }
                    }

                    impl token::private::Sealed for $name {}
                };
            }

            impl_token!("literal" Lit);
            impl_token!("string literal" LitStr);
            impl_token!("byte string literal" LitByteStr);
            impl_token!("C-string literal" LitCStr);
            impl_token!("byte literal" LitByte);
            impl_token!("character literal" LitChar);
            impl_token!("integer literal" LitInt);
            impl_token!("floating point literal" LitFloat);
            impl_token!("boolean literal" LitBool);
        }

        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::lit::{LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitInt, LitStr},
                *,
            };
            
            impl ToTokens for LitStr
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitByteStr {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitCStr {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitByte {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitChar {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitInt {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitFloat {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.repr.token.to_tokens(tokens);
                }
            }

            impl ToTokens for LitBool {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append(self.token());
                }
            }
        }

        mod value
        {
            use ::
            {
                ffi::{ CString },
                ops::{ Index, RangeFrom },
                process::macros::{ Literal, Span },
                syntax::
                {
                    bigint::BigInt,
                    lit::
                    {
                        Lit, LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitFloatRepr, LitInt, 
                        LitIntRepr, LitRepr, LitStr,
                    },
                },
                *,
            };
            
            impl Lit {
                /// Interpret a Syn literal from a proc-macro2 literal.
                #[track_caller]
                pub fn new(token: Literal) -> Self {
                    let repr = token.to_string();

                    match byte(&repr, 0) {
                       
                        b'"' | b'r' => {
                            let (_, suffix) = parse_lit_str(&repr);
                            return Lit::Str(LitStr {
                                repr: Box::new(LitRepr { token, suffix }),
                            });
                        }
                        b'b' => match byte(&repr, 1) {
                           
                            b'"' | b'r' => {
                                let (_, suffix) = parse_lit_byte_str(&repr);
                                return Lit::ByteStr(LitByteStr {
                                    repr: Box::new(LitRepr { token, suffix }),
                                });
                            }
                           
                            b'\'' => {
                                let (_, suffix) = parse_lit_byte(&repr);
                                return Lit::Byte(LitByte {
                                    repr: Box::new(LitRepr { token, suffix }),
                                });
                            }
                            _ => {}
                        },
                       
                        b'c' => {
                            let (_, suffix) = parse_lit_c_str(&repr);
                            return Lit::CStr(LitCStr {
                                repr: Box::new(LitRepr { token, suffix }),
                            });
                        }
                       
                        b'\'' => {
                            let (_, suffix) = parse_lit_char(&repr);
                            return Lit::Char(LitChar {
                                repr: Box::new(LitRepr { token, suffix }),
                            });
                        }
                        b'0'..=b'9' | b'-' => {
                           
                            if let Some((digits, suffix)) = parse_lit_int(&repr) {
                                return Lit::Int(LitInt {
                                    repr: Box::new(LitIntRepr {
                                        token,
                                        digits,
                                        suffix,
                                    }),
                                });
                            }
                           
                            if let Some((digits, suffix)) = parse_lit_float(&repr) {
                                return Lit::Float(LitFloat {
                                    repr: Box::new(LitFloatRepr {
                                        token,
                                        digits,
                                        suffix,
                                    }),
                                });
                            }
                        }
                       
                        b't' | b'f' => {
                            if repr == "true" || repr == "false" {
                                return Lit::Bool(LitBool {
                                    value: repr == "true",
                                    span: token.span(),
                                });
                            }
                        }
                        b'(' if repr == "(/*ERROR*/)" => return Lit::Verbatim(token),
                        _ => {}
                    }

                    panic!("unrecognized literal: `{}`", repr);
                }

                pub fn suffix(&self) -> &str {
                    match self {
                        Lit::Str(lit) => lit.suffix(),
                        Lit::ByteStr(lit) => lit.suffix(),
                        Lit::CStr(lit) => lit.suffix(),
                        Lit::Byte(lit) => lit.suffix(),
                        Lit::Char(lit) => lit.suffix(),
                        Lit::Int(lit) => lit.suffix(),
                        Lit::Float(lit) => lit.suffix(),
                        Lit::Bool(_) | Lit::Verbatim(_) => "",
                    }
                }

                pub fn span(&self) -> Span {
                    match self {
                        Lit::Str(lit) => lit.span(),
                        Lit::ByteStr(lit) => lit.span(),
                        Lit::CStr(lit) => lit.span(),
                        Lit::Byte(lit) => lit.span(),
                        Lit::Char(lit) => lit.span(),
                        Lit::Int(lit) => lit.span(),
                        Lit::Float(lit) => lit.span(),
                        Lit::Bool(lit) => lit.span,
                        Lit::Verbatim(lit) => lit.span(),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match self {
                        Lit::Str(lit) => lit.set_span(span),
                        Lit::ByteStr(lit) => lit.set_span(span),
                        Lit::CStr(lit) => lit.set_span(span),
                        Lit::Byte(lit) => lit.set_span(span),
                        Lit::Char(lit) => lit.set_span(span),
                        Lit::Int(lit) => lit.set_span(span),
                        Lit::Float(lit) => lit.set_span(span),
                        Lit::Bool(lit) => lit.span = span,
                        Lit::Verbatim(lit) => lit.set_span(span),
                    }
                }
            }
            /// Get a byte at offset idx, or a default of `b'\0'` if we're looking past the end of the input buffer.
            pub fn byte<S: AsRef<[u8]> + ?Sized>(s: &S, idx: usize) -> u8 {
                let s = s.as_ref();
                if idx < s.len() {
                    s[idx]
                } else {
                    0
                }
            }

            fn next_chr(s: &str) -> char {
                s.chars().next().unwrap_or('\0')
            }

            pub fn parse_lit_str(s: &str) -> (Box<str>, Box<str>) {
                match byte(s, 0) {
                    b'"' => parse_lit_str_cooked(s),
                    b'r' => parse_lit_str_raw(s),
                    _ => unreachable!(),
                }
            }

            fn parse_lit_str_cooked(mut s: &str) -> (Box<str>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'"');
                s = &s[1..];

                let mut content = String::new();
                'outer: loop {
                    let ch = match byte(s, 0) {
                        b'"' => break,
                        b'\\' => {
                            let b = byte(s, 1);
                            s = &s[2..];
                            match b {
                                b'x' => {
                                    let (byte, rest) = backslash_x(s);
                                    s = rest;
                                    assert!(byte <= 0x7F, "invalid \\x byte in string literal");
                                    char::from(byte)
                                }
                                b'u' => {
                                    let (ch, rest) = backslash_u(s);
                                    s = rest;
                                    ch
                                }
                                b'n' => '\n',
                                b'r' => '\r',
                                b't' => '\t',
                                b'\\' => '\\',
                                b'0' => '\0',
                                b'\'' => '\'',
                                b'"' => '"',
                                b'\r' | b'\n' => loop {
                                    let b = byte(s, 0);
                                    match b {
                                        b' ' | b'\t' | b'\n' | b'\r' => s = &s[1..],
                                        _ => continue 'outer,
                                    }
                                },
                                b => panic!(
                                    "unexpected byte '{}' after \\ character in string literal",
                                    ascii::escape_default(b),
                                ),
                            }
                        }
                        b'\r' => {
                            assert_eq!(byte(s, 1), b'\n', "bare CR not allowed in string");
                            s = &s[2..];
                            '\n'
                        }
                        _ => {
                            let ch = next_chr(s);
                            s = &s[ch.len_utf8()..];
                            ch
                        }
                    };
                    content.push(ch);
                }

                assert!(s.starts_with('"'));
                let content = content.into_boxed_str();
                let suffix = s[1..].to_owned().into_boxed_str();
                (content, suffix)
            }

            fn parse_lit_str_raw(mut s: &str) -> (Box<str>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'r');
                s = &s[1..];

                let mut pounds = 0;
                while byte(s, pounds) == b'#' {
                    pounds += 1;
                }
                assert_eq!(byte(s, pounds), b'"');
                let close = s.rfind('"').unwrap();
                for end in s[close + 1..close + 1 + pounds].bytes() {
                    assert_eq!(end, b'#');
                }

                let content = s[pounds + 1..close].to_owned().into_boxed_str();
                let suffix = s[close + 1 + pounds..].to_owned().into_boxed_str();
                (content, suffix)
            }

            pub fn parse_lit_byte_str(s: &str) -> (Vec<u8>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'b');
                match byte(s, 1) {
                    b'"' => parse_lit_byte_str_cooked(s),
                    b'r' => parse_lit_byte_str_raw(s),
                    _ => unreachable!(),
                }
            }

            fn parse_lit_byte_str_cooked(mut s: &str) -> (Vec<u8>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'b');
                assert_eq!(byte(s, 1), b'"');
                s = &s[2..];

               
                let mut v = s.as_bytes();

                let mut out = Vec::new();
                'outer: loop {
                    let byte = match byte(v, 0) {
                        b'"' => break,
                        b'\\' => {
                            let b = byte(v, 1);
                            v = &v[2..];
                            match b {
                                b'x' => {
                                    let (b, rest) = backslash_x(v);
                                    v = rest;
                                    b
                                }
                                b'n' => b'\n',
                                b'r' => b'\r',
                                b't' => b'\t',
                                b'\\' => b'\\',
                                b'0' => b'\0',
                                b'\'' => b'\'',
                                b'"' => b'"',
                                b'\r' | b'\n' => loop {
                                    let byte = byte(v, 0);
                                    if matches!(byte, b' ' | b'\t' | b'\n' | b'\r') {
                                        v = &v[1..];
                                    } else {
                                        continue 'outer;
                                    }
                                },
                                b => panic!(
                                    "unexpected byte '{}' after \\ character in byte-string literal",
                                    ascii::escape_default(b),
                                ),
                            }
                        }
                        b'\r' => {
                            assert_eq!(byte(v, 1), b'\n', "bare CR not allowed in string");
                            v = &v[2..];
                            b'\n'
                        }
                        b => {
                            v = &v[1..];
                            b
                        }
                    };
                    out.push(byte);
                }

                assert_eq!(byte(v, 0), b'"');
                let suffix = s[s.len() - v.len() + 1..].to_owned().into_boxed_str();
                (out, suffix)
            }

            fn parse_lit_byte_str_raw(s: &str) -> (Vec<u8>, Box<str>)
            {
                assert_eq!(byte(s, 0), b'b');
                let (value, suffix) = parse_lit_str_raw(&s[1..]);
                (String::from(value).into_bytes(), suffix)
            }

            pub fn parse_lit_c_str(s: &str) -> (CString, Box<str>)
            {
                assert_eq!(byte(s, 0), b'c');
                match byte(s, 1) {
                    b'"' => parse_lit_c_str_cooked(s),
                    b'r' => parse_lit_c_str_raw(s),
                    _ => unreachable!(),
                }
            }

            fn parse_lit_c_str_cooked(mut s: &str) -> (CString, Box<str>)
            {
                assert_eq!(byte(s, 0), b'c');
                assert_eq!(byte(s, 1), b'"');
                s = &s[2..];

               
                let mut v = s.as_bytes();

                let mut out = Vec::new();
                'outer: loop {
                    let byte = match byte(v, 0) {
                        b'"' => break,
                        b'\\' => {
                            let b = byte(v, 1);
                            v = &v[2..];
                            match b {
                                b'x' => {
                                    let (b, rest) = backslash_x(v);
                                    assert!(b != 0, "\\x00 is not allowed in C-string literal");
                                    v = rest;
                                    b
                                }
                                b'u' => {
                                    let (ch, rest) = backslash_u(v);
                                    assert!(ch != '\0', "\\u{{0}} is not allowed in C-string literal");
                                    v = rest;
                                    out.extend_from_slice(ch.encode_utf8(&mut [0u8; 4]).as_bytes());
                                    continue 'outer;
                                }
                                b'n' => b'\n',
                                b'r' => b'\r',
                                b't' => b'\t',
                                b'\\' => b'\\',
                                b'\'' => b'\'',
                                b'"' => b'"',
                                b'\r' | b'\n' => loop {
                                    let byte = byte(v, 0);
                                    if matches!(byte, b' ' | b'\t' | b'\n' | b'\r') {
                                        v = &v[1..];
                                    } else {
                                        continue 'outer;
                                    }
                                },
                                b => panic!(
                                    "unexpected byte '{}' after \\ character in byte literal",
                                    ascii::escape_default(b),
                                ),
                            }
                        }
                        b'\r' => {
                            assert_eq!(byte(v, 1), b'\n', "bare CR not allowed in string");
                            v = &v[2..];
                            b'\n'
                        }
                        b => {
                            v = &v[1..];
                            b
                        }
                    };
                    out.push(byte);
                }

                assert_eq!(byte(v, 0), b'"');
                let suffix = s[s.len() - v.len() + 1..].to_owned().into_boxed_str();
                (CString::new(out).unwrap(), suffix)
            }

            fn parse_lit_c_str_raw(s: &str) -> (CString, Box<str>)
            {
                assert_eq!(byte(s, 0), b'c');
                let (value, suffix) = parse_lit_str_raw(&s[1..]);
                (CString::new(String::from(value)).unwrap(), suffix)
            }

            pub fn parse_lit_byte(s: &str) -> (u8, Box<str>)
            {
                assert_eq!(byte(s, 0), b'b');
                assert_eq!(byte(s, 1), b'\'');

               
                let mut v = &s.as_bytes()[2..];

                let b = match byte(v, 0) {
                    b'\\' => {
                        let b = byte(v, 1);
                        v = &v[2..];
                        match b {
                            b'x' => {
                                let (b, rest) = backslash_x(v);
                                v = rest;
                                b
                            }
                            b'n' => b'\n',
                            b'r' => b'\r',
                            b't' => b'\t',
                            b'\\' => b'\\',
                            b'0' => b'\0',
                            b'\'' => b'\'',
                            b'"' => b'"',
                            b => panic!(
                                "unexpected byte '{}' after \\ character in byte literal",
                                ascii::escape_default(b),
                            ),
                        }
                    }
                    b => {
                        v = &v[1..];
                        b
                    }
                };

                assert_eq!(byte(v, 0), b'\'');
                let suffix = s[s.len() - v.len() + 1..].to_owned().into_boxed_str();
                (b, suffix)
            }

            pub fn parse_lit_char(mut s: &str) -> (char, Box<str>)
            {
                assert_eq!(byte(s, 0), b'\'');
                s = &s[1..];

                let ch = match byte(s, 0) {
                    b'\\' => {
                        let b = byte(s, 1);
                        s = &s[2..];
                        match b {
                            b'x' => {
                                let (byte, rest) = backslash_x(s);
                                s = rest;
                                assert!(byte <= 0x7F, "invalid \\x byte in character literal");
                                char::from(byte)
                            }
                            b'u' => {
                                let (ch, rest) = backslash_u(s);
                                s = rest;
                                ch
                            }
                            b'n' => '\n',
                            b'r' => '\r',
                            b't' => '\t',
                            b'\\' => '\\',
                            b'0' => '\0',
                            b'\'' => '\'',
                            b'"' => '"',
                            b => panic!(
                                "unexpected byte '{}' after \\ character in character literal",
                                ascii::escape_default(b),
                            ),
                        }
                    }
                    _ => {
                        let ch = next_chr(s);
                        s = &s[ch.len_utf8()..];
                        ch
                    }
                };
                assert_eq!(byte(s, 0), b'\'');
                let suffix = s[1..].to_owned().into_boxed_str();
                (ch, suffix)
            }

            fn backslash_x<S>(s: &S) -> (u8, &S) where
                S: Index<RangeFrom<usize>, Output = S> + AsRef<[u8]> + ?Sized,
            {
                let mut ch = 0;
                let b0 = byte(s, 0);
                let b1 = byte(s, 1);
                ch += 0x10
                    * match b0 {
                        b'0'..=b'9' => b0 - b'0',
                        b'a'..=b'f' => 10 + (b0 - b'a'),
                        b'A'..=b'F' => 10 + (b0 - b'A'),
                        _ => panic!("unexpected non-hex character after \\x"),
                    };
                ch += match b1 {
                    b'0'..=b'9' => b1 - b'0',
                    b'a'..=b'f' => 10 + (b1 - b'a'),
                    b'A'..=b'F' => 10 + (b1 - b'A'),
                    _ => panic!("unexpected non-hex character after \\x"),
                };
                (ch, &s[2..])
            }

            fn backslash_u<S>(mut s: &S) -> (char, &S) where
                S: Index<RangeFrom<usize>, Output = S> + AsRef<[u8]> + ?Sized,
            {
                if byte(s, 0) != b'{' {
                    panic!("{}", "expected { after \\u");
                }
                s = &s[1..];

                let mut ch = 0;
                let mut digits = 0;
                loop {
                    let b = byte(s, 0);
                    let digit = match b {
                        b'0'..=b'9' => b - b'0',
                        b'a'..=b'f' => 10 + b - b'a',
                        b'A'..=b'F' => 10 + b - b'A',
                        b'_' if digits > 0 => {
                            s = &s[1..];
                            continue;
                        }
                        b'}' if digits == 0 => panic!("invalid empty unicode escape"),
                        b'}' => break,
                        _ => panic!("unexpected non-hex character after \\u"),
                    };
                    if digits == 6 {
                        panic!("overlong unicode escape (must have at most 6 hex digits)");
                    }
                    ch *= 0x10;
                    ch += u32::from(digit);
                    digits += 1;
                    s = &s[1..];
                }
                assert!(byte(s, 0) == b'}');
                s = &s[1..];

                if let Some(ch) = char::from_u32(ch) {
                    (ch, s)
                } else {
                    panic!("character code {:x} is not a valid unicode character", ch);
                }
            }

            pub fn parse_lit_int(mut s: &str) -> Option<(Box<str>, Box<str>)>
            {
                let negative = byte(s, 0) == b'-';
                if negative {
                    s = &s[1..];
                }

                let base = match (byte(s, 0), byte(s, 1)) {
                    (b'0', b'x') => {
                        s = &s[2..];
                        16
                    }
                    (b'0', b'o') => {
                        s = &s[2..];
                        8
                    }
                    (b'0', b'b') => {
                        s = &s[2..];
                        2
                    }
                    (b'0'..=b'9', _) => 10,
                    _ => return None,
                };

                let mut value = BigInt::new();
                let mut has_digit = false;
                'outer: loop {
                    let b = byte(s, 0);
                    let digit = match b {
                        b'0'..=b'9' => b - b'0',
                        b'a'..=b'f' if base > 10 => b - b'a' + 10,
                        b'A'..=b'F' if base > 10 => b - b'A' + 10,
                        b'_' => {
                            s = &s[1..];
                            continue;
                        }
                       
                       
                        b'.' if base == 10 => return None,
                        b'e' | b'E' if base == 10 => {
                            let mut has_exp = false;
                            for (i, b) in s[1..].bytes().enumerate() {
                                match b {
                                    b'_' => {}
                                    b'-' | b'+' => return None,
                                    b'0'..=b'9' => has_exp = true,
                                    _ => {
                                        let suffix = &s[1 + i..];
                                        if has_exp && ::syntax::ident::xid_ok(suffix) {
                                            return None;
                                        } else {
                                            break 'outer;
                                        }
                                    }
                                }
                            }
                            if has_exp {
                                return None;
                            } else {
                                break;
                            }
                        }
                        _ => break,
                    };

                    if digit >= base {
                        return None;
                    }

                    has_digit = true;
                    value *= base;
                    value += digit;
                    s = &s[1..];
                }

                if !has_digit {
                    return None;
                }

                let suffix = s;
                if suffix.is_empty() || ::syntax::ident::xid_ok(suffix) {
                    let mut repr = value.to_string();
                    if negative {
                        repr.insert(0, '-');
                    }
                    Some((repr.into_boxed_str(), suffix.to_owned().into_boxed_str()))
                } else {
                    None
                }
            }

            pub fn parse_lit_float(input: &str) -> Option<(Box<str>, Box<str>)> {
               
               
               

                let mut bytes = input.to_owned().into_bytes();

                let start = (*bytes.first()? == b'-') as usize;
                match bytes.get(start)? {
                    b'0'..=b'9' => {}
                    _ => return None,
                }

                let mut read = start;
                let mut write = start;
                let mut has_dot = false;
                let mut has_e = false;
                let mut has_sign = false;
                let mut has_exponent = false;
                while read < bytes.len( )
                {
                    match bytes[read] {
                        b'_' => {
                           
                            read += 1;
                            continue;
                        }
                        b'0'..=b'9' => {
                            if has_e {
                                has_exponent = true;
                            }
                            bytes[write] = bytes[read];
                        }
                        b'.' => {
                            if has_e || has_dot {
                                return None;
                            }
                            has_dot = true;
                            bytes[write] = b'.';
                        }
                        b'e' | b'E' => {
                            match bytes[read + 1..]
                                .iter()
                                .find(|b| **b != b'_')
                                .unwrap_or(&b'\0')
                            {
                                b'-' | b'+' | b'0'..=b'9' => {}
                                _ => break,
                            }
                            if has_e {
                                if has_exponent {
                                    break;
                                } else {
                                    return None;
                                }
                            }
                            has_e = true;
                            bytes[write] = b'e';
                        }
                        b'-' | b'+' => {
                            if has_sign || has_exponent || !has_e {
                                return None;
                            }
                            has_sign = true;
                            if bytes[read] == b'-' {
                                bytes[write] = bytes[read];
                            } else {
                               
                                read += 1;
                                continue;
                            }
                        }
                        _ => break,
                    }
                    read += 1;
                    write += 1;
                }

                if has_e && !has_exponent {
                    return None;
                }

                let mut digits = String::from_utf8(bytes).unwrap();
                let suffix = digits.split_off(read);
                digits.truncate(write);
                if suffix.is_empty() || ::syntax::ident::xid_ok(&suffix) {
                    Some((digits.into_boxed_str(), suffix.into_boxed_str()))
                } else {
                    None
                }
            }
        }
    } pub use self::lit::
    {
        Lit, LitBool, LitByte, LitByteStr, LitCStr, LitChar, LitFloat, LitInt, LitStr, StrStyle
    };

    pub mod lookahead
    {
        use ::
        {
            cell::{ RefCell },
            process::macros::{Delimiter, Span},
            syntax::
            {
                buffer::Cursor,
                error::{self, Error},
                sealed::lookahead::Sealed,
                span::IntoSpans,
                token::{CustomToken, Token},
            },
            *,
        };
        /*
        */
        /// Support for checking the next token in a stream to decide how to parse.
        pub struct Lookahead1<'a> {
            scope: Span,
            cursor: Cursor<'a>,
            comparisons: RefCell<Vec<&'static str>>,
        }

        pub fn new(scope: Span, cursor: Cursor) -> Lookahead1 {
            Lookahead1 {
                scope,
                cursor,
                comparisons: RefCell::new(Vec::new()),
            }
        }

        fn peek_impl(
            lookahead: &Lookahead1,
            peek: fn(Cursor) -> bool,
            display: fn() -> &'static str,
        ) -> bool
        {
            if peek(lookahead.cursor) {
                return true;
            }
            lookahead.comparisons.borrow_mut().push(display());
            false
        }

        impl<'a> Lookahead1<'a> {
            /// Looks at the next token in the parse stream to determine whether it
            /// matches the requested type of token.
            pub fn peek<T: Peek>(&self, token: T) -> bool
        {
                let _ = token;
                peek_impl(self, T::Token::peek, T::Token::display)
            }
            /// Triggers an error at the current position of the parse stream.
            pub fn error(self) -> Error {
                let mut comparisons = self.comparisons.into_inner();
                comparisons.retain_mut(|display| {
                    if *display == "`)`" {
                        *display = match self.cursor.scope_delimiter() {
                            Delimiter::Parenthesis => "`)`",
                            Delimiter::Brace => "`}`",
                            Delimiter::Bracket => "`]`",
                            Delimiter::None => return false,
                        }
                    }
                    true
                });
                match comparisons.len() {
                    0 => {
                        if self.cursor.eof() {
                            Error::new(self.scope, "unexpected end of input")
                        } else {
                            Error::new(self.cursor.span(), "unexpected token")
                        }
                    }
                    1 => {
                        let message = format!("expected {}", comparisons[0]);
                        error::new_at(self.scope, self.cursor, message)
                    }
                    2 => {
                        let message = format!("expected {} or {}", comparisons[0], comparisons[1]);
                        error::new_at(self.scope, self.cursor, message)
                    }
                    _ => {
                        let join = comparisons.join(", ");
                        let message = format!("expected one of: {}", join);
                        error::new_at(self.scope, self.cursor, message)
                    }
                }
            }
        }
        /// Types that can be parsed by looking at just one token.
        pub trait Peek: Sealed {
           
                type Token: Token;
        }
        /// Pseudo-token used for peeking the end of a parse stream.
        /// - [`ParseStream::peek2`][::syntax::parse::ParseBuffer::peek2]
        /// - [`ParseStream::peek3`][::syntax::parse::ParseBuffer::peek3]
        /// - [`Lookahead1::peek`]
        ///
        /// The peek will return `true` if there are no remaining tokens after that
        /// point in the parse stream.
        /// arguments:
        ///
        /// - `#[fmt("simple example")]`
        /// - `#[fmt("interpolation e{}ample", self.x)]`
        /// - `#[fmt("interpolation e{x}ample")]`
        ///
        /// and we want to recognize the cases where no interpolation occurs so that
        /// more efficient code can be generated.
        /// consuming the comma from the parse stream, because if it isn't a trailing
        /// comma, that same comma needs to be parsed as part of `args`.
        /// use ::quote::quote;
        /// use syn::parse::{End, Parse, ParseStream, Result};
        /// use syn::{parse_quote, Attribute, LitStr, Token};
        ///
        /// struct FormatArgs {
        ///     template: LitStr, 
        ///     args: TokenStream,
        /// }
        ///
        /// impl Parse for FormatArgs {
        ///     fn parse(input: ParseStream) -> Result<Self> {
        ///         let template: LitStr = input.parse()?;
        ///
        ///         let args = if input.is_empty()
        ///             || input.peek(Token![,]) && input.peek2(End)
        ///         {
        ///             input.parse::<Option<Token![,]>>()?;
        ///             TokenStream::new()
        ///         } else {
        ///             input.parse()?
        ///         };
        ///
        ///         Ok(FormatArgs {
        ///             template,
        ///             args,
        ///         })
        ///     }
        /// }
        ///
        /// fn main() -> Result<()> {
        ///     let attrs: Vec<Attribute> = parse_quote! {
        ///         #[fmt("simple example")]
        ///         #[fmt("interpolation e{}ample", self.x)]
        ///         #[fmt("interpolation e{x}ample")]
        ///     };
        ///
        ///     for attr in &attrs {
        ///         let FormatArgs { template, args } = attr.parse_args()?;
        ///         let requires_fmt_machinery =
        ///             !args.is_empty() || template.value().contains(['{', '}']);
        ///         let out = if requires_fmt_machinery {
        ///             quote! {
        ///                 ::core::write!(__formatter, #template #args)
        ///             }
        ///         } else {
        ///             quote! {
        ///                 __formatter.write_str(#template)
        ///             }
        ///         };
        ///         println!("{}", out);
        ///     }
        ///     Ok(())
        /// }
        /// ```
        ///
        /// Implementing this parsing logic without `peek2(End)` is more clumsy because
        /// we'd need a parse stream actually advanced past the comma before being able
        /// to find out whether there is anything after it. It would look something
        /// like:
        ///
        /// ```
        /// # use ::process::macros::TokenStream;
        /// # use syn::parse::{ParseStream, Result};
        /// # use syn::Token;
        /// #
        /// # fn parse(input: ParseStream) -> Result<()> {
        /// use syn::parse::discouraged::Speculative as _;
        ///
        /// let ahead = input.fork();
        /// ahead.parse::<Option<Token![,]>>()?;
        /// let args = if ahead.is_empty() {
        ///     input.advance_to(&ahead);
        ///     TokenStream::new()
        /// } else {
        ///     input.parse()?
        /// };
        /// # Ok(())
        /// # }
        /// ```
        ///
        /// or:
        ///
        /// ```
        /// # use ::process::macros::TokenStream;
        /// # use syn::parse::{ParseStream, Result};
        /// # use syn::Token;
        /// #
        /// # fn parse(input: ParseStream) -> Result<()> {
        /// use ::quote::ToTokens as _;
        ///
        /// let comma: Option<Token![,]> = input.parse()?;
        /// let mut args = TokenStream::new();
        /// if !input.is_empty() {
        ///     comma.to_tokens(&mut args);
        ///     input.parse::<TokenStream>()?.to_tokens(&mut args);
        /// }
        /// # Ok(())
        /// # }
        /// ```
        pub struct End;

        impl Copy for End {}

        impl Clone for End {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl Peek for End {
            type Token = Self;
        }

        impl CustomToken for End {
            fn peek(cursor: Cursor) -> bool
        {
                cursor.eof()
            }

            fn display() -> &'static str {
                "`)`"
            }
        }

        impl<F: Copy + FnOnce(TokenMarker) -> T, T: Token> Peek for F {
            type Token = T;
        }

        pub enum TokenMarker {}

        impl<S> IntoSpans<S> for TokenMarker {
            fn into_spans(self) -> S {
                match self {}
            }
        }

        impl<F: Copy + FnOnce(TokenMarker) -> T, T: Token> Sealed for F {}

        impl Sealed for End {}
    }
    
    pub mod mac
    {
        use ::
        {
            process::macros::
            {
                extra::DelimSpan, Delimiter, TokenStream, TokenTree
            },
            syntax::
            {
                error::Result,
                parse::{ Parse, ParseStream, Parser },
                path::Path,
                token::{ Brace, Bracket, Paren },
            },
            *,
        };
        /*
        */
        ast_struct! 
        {
            /// A macro invocation: `println!("{}", mac)`.
            pub struct Macro {
                pub path: Path,
                pub bang_token: Token![!],
                pub delimiter: MacroDelimiter,
                pub tokens: TokenStream,
            }
        }

        ast_enum! 
        {
            /// A grouping token that surrounds a macro body: `m!(...)` or `m!{...}` or `m![...]`.
            pub enum MacroDelimiter {
                Paren(Paren),
                Brace(Brace),
                Bracket(Bracket),
            }
        }

        impl MacroDelimiter 
        {
            pub fn span(&self) -> &DelimSpan {
                match self {
                    MacroDelimiter::Paren(token) => &token.span,
                    MacroDelimiter::Brace(token) => &token.span,
                    MacroDelimiter::Bracket(token) => &token.span,
                }
            }

            #[cfg(all(feature = "full", any(feature = "parsing", feature = "printing")))]
            pub fn is_brace(&self) -> bool
        {
                match self {
                    MacroDelimiter::Brace(_) => true,
                    MacroDelimiter::Paren(_) | MacroDelimiter::Bracket(_) => false,
                }
            }
        }

        impl Macro 
        {
            /// Parse the tokens within the macro invocation's delimiters into a syntax
            /// tree.
            /// use syn::ext::IdentExt;
            /// use syn::parse::{Error, Parse, ParseStream, Result};
            /// use syn::punctuated::Punctuated;
            ///
            ///
            ///
            /// //
            ///
            /// struct FormatArgs {
            ///     format_string: Expr,
            ///     positional_args: Vec<Expr>,
            ///     named_args: Vec<(Ident, Expr)>,
            /// }
            ///
            /// impl Parse for FormatArgs {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         let format_string: Expr;
            ///         let mut positional_args = Vec::new();
            ///         let mut named_args = Vec::new();
            ///
            ///         format_string = input.parse()?;
            ///         while !input.is_empty() {
            ///             input.parse::<Token![,]>()?;
            ///             if input.is_empty() {
            ///                 break;
            ///             }
            ///             if input.peek(Ident::peek_any) && input.peek2(Token![=]) {
            ///                 while !input.is_empty() {
            ///                     let name: Ident = input.call(Ident::parse_any)?;
            ///                     input.parse::<Token![=]>()?;
            ///                     let value: Expr = input.parse()?;
            ///                     named_args.push((name, value));
            ///                     if input.is_empty() {
            ///                         break;
            ///                     }
            ///                     input.parse::<Token![,]>()?;
            ///                 }
            ///                 break;
            ///             }
            ///             positional_args.push(input.parse()?);
            ///         }
            ///
            ///         Ok(FormatArgs {
            ///             format_string,
            ///             positional_args,
            ///             named_args,
            ///         })
            ///     }
            /// }
            ///
            ///
            ///
            /// fn get_format_string(m: &Macro) -> Result<LitStr> {
            ///     let args: FormatArgs = m.parse_body()?;
            ///     match args.format_string {
            ///         Expr::Lit(ExprLit { lit: Lit::Str(lit), .. }) => Ok(lit),
            ///         other => {
            ///            
            ///            
            ///             Err(Error::new_spanned(other, "format string must be a string literal"))
            ///         }
            ///     }
            /// }
            ///
            /// fn main() {
            ///     let invocation = parse_quote! {
            ///         println!("{:?}", Instant::now())
            ///     };
            ///     let lit = get_format_string(&invocation).unwrap();
            ///     assert_eq!(lit.value(), "{:?}");
            /// }
            /// ```
             
                pub fn parse_body<T: Parse>(&self) -> Result<T>
            {
                self.parse_body_with(T::parse)
            }
            /// Parse the tokens within the macro invocation's delimiters using the
            /// given parser.
             
                pub fn parse_body_with<F: Parser>(&self, parser: F) -> Result<F::Output>
            {
                let scope = self.delimiter.span().close();
                ::syntax::parse::parse_scoped(parser, scope, self.tokens.clone())
            }
        }
        
        pub fn parse_delimiter(input: ParseStream) -> Result<(MacroDelimiter, TokenStream)>
        {
            input.step(|cursor| {
                if let Some((TokenTree::Group(g), rest)) = cursor.token_tree() {
                    let span = g.delim_span();
                    let delimiter = match g.delimiter() {
                        Delimiter::Parenthesis => MacroDelimiter::Paren(Paren(span)),
                        Delimiter::Brace => MacroDelimiter::Brace(Brace(span)),
                        Delimiter::Bracket => MacroDelimiter::Bracket(Bracket(span)),
                        Delimiter::None => {
                            return Err(cursor.error("expected delimiter"));
                        }
                    };
                    Ok(((delimiter, g.stream()), rest))
                } else {
                    Err(cursor.error("expected delimiter"))
                }
            })
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {    
                    error::Result,
                    mac::{parse_delimiter, Macro},
                    parse::{Parse, ParseStream},
                    path::Path,
                },
                *,
            };
            
            impl Parse for Macro
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let tokens;
                    Ok(Macro {
                        path: input.call(Path::parse_mod_style)?,
                        bang_token: input.parse()?,
                        delimiter: {
                            let (delimiter, content) = parse_delimiter(input)?;
                            tokens = content;
                            delimiter
                        },
                        tokens,
                    })
                }
            }
        }

        mod printing
        {
            use ::
            {
                process::macros::{ Delimiter, TokenStream },
                quote::{ ToTokens },
                syntax::
                {
                    mac::{Macro, MacroDelimiter},
                    path,
                    path::printing::PathStyle,
                    token,
                },
                *,
            };
            
            impl MacroDelimiter {
                pub fn surround(&self, tokens: &mut TokenStream, inner: TokenStream) {
                    let (delim, span) = match self {
                        MacroDelimiter::Paren(paren) => (Delimiter::Parenthesis, paren.span),
                        MacroDelimiter::Brace(brace) => (Delimiter::Brace, brace.span),
                        MacroDelimiter::Bracket(bracket) => (Delimiter::Bracket, bracket.span),
                    };
                    token::printing::delim(delim, span.join(), tokens, inner);
                }
            }

            impl ToTokens for Macro {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    path::printing::print_path(tokens, &self.path, PathStyle::Mod);
                    self.bang_token.to_tokens(tokens);
                    self.delimiter.surround(tokens, self.tokens.clone());
                }
            }
        }
    } pub use self::mac::{Macro, MacroDelimiter};
    
    pub mod meta
    {
        //! Facility for interpreting structured content inside of an `Attribute`.
        use ::
        {
            fmt::{ Display },
            process::macros::{ Ident },
            syntax::
            {
                error::{Error, Result},
                ext::IdentExt as _,
                lit::Lit,
                parse::{ParseStream, Parser},
                path::{Path, PathSegment},
                punctuated::Punctuated,
            },
            *,
        };
        /*
        */
        /// Make a parser that is usable with `parse_macro_input!` in a `#[proc_macro_attribute]` macro.
        pub fn parser(logic: impl FnMut(ParseNestedMeta) -> Result<()>) -> impl Parser<Output = ()> {
            |input: ParseStream| {
                if input.is_empty() {
                    Ok(())
                } else {
                    parse_nested_meta(input, logic)
                }
            }
        }
        /// Context for parsing a single property in the conventional syntax for structured attributes.
        #[non_exhaustive]
        pub struct ParseNestedMeta<'a>
        {
            pub path: Path,
            pub input: ParseStream<'a>,
        }

        impl<'a> ParseNestedMeta<'a> {
            /// Used when parsing `key = "value"` syntax.
            /// `meta.parse::<Token![=]>()?`, so at most it is a minor convenience to
            /// use `meta.value()?`.
            ///         if meta.path.is_ident("kind") { 
            ///             let value = meta.value()?;  
            ///             let s: LitStr = value.parse()?; 
            ///             if s.value() == "EarlGrey" {
            ///                
            ///             }
            ///             Ok(())
            ///         } else {
            ///             Err(meta.error("unsupported attribute"))
            ///         }
            ///     })?;
            /// }
            /// # anyhow::Ok(())
            /// ```
            pub fn value(&self) -> Result<ParseStream<'a>>
            {
                self.input.parse::<Token![=]>()?;
                Ok(self.input)
            }
            /// Used when parsing `list(...)` syntax **if** the content inside the
            /// nested parentheses is also expected to conform to Rust's structured
            /// attribute convention.
            /// };
            ///
            /// if attr.path().is_ident("tea") {
            ///     attr.parse_nested_meta(|meta| {
            ///         if meta.path.is_ident("with") {
            ///             meta.parse_nested_meta(|meta| { 
            ///                 if meta.path.is_ident("sugar") {
            ///                    
            ///                     Ok(())
            ///                 } else if meta.path.is_ident("milk") {
            ///                     Ok(())
            ///                 } else {
            ///                     Err(meta.error("unsupported ingredient"))
            ///                 }
            ///             })
            ///         } else {
            ///             Err(meta.error("unsupported tea property"))
            ///         }
            ///     })?;
            /// }
            /// # anyhow::Ok(())
            /// ```
            ///
            /// # Counterexample
            ///
            /// If you don't need `parse_nested_meta`'s help in parsing the content
            /// written within the nested parentheses, keep in mind that you can always
            /// just parse it yourself from the exposed ParseStream. Rust syntax permits
            /// arbitrary tokens within those parentheses so for the crazier stuff,
            /// `parse_nested_meta` is not what you want.
            ///
            /// let attr: Attribute = parse_quote! {
            ///     #[repr(align(32))]
            /// };
            ///
            /// let mut align: Option<LitInt> = None;
            /// if attr.path().is_ident("repr") {
            ///     attr.parse_nested_meta(|meta| {
            ///         if meta.path.is_ident("align") {
            ///             let content;
            ///             parenthesized!(content in meta.input);
            ///             align = Some(content.parse()?);
            ///             Ok(())
            ///         } else {
            ///             Err(meta.error("unsupported repr"))
            ///         }
            ///     })?;
            /// }
            /// # anyhow::Ok(())
            /// ```
            pub fn parse_nested_meta(
                &self,
                logic: impl FnMut(ParseNestedMeta) -> Result<()>,
            ) -> Result<()>
            {
                let content;
                parenthesized!(content in self.input);
                parse_nested_meta(&content, logic)
            }
            /// Report that the attribute's content did not conform to expectations.
            ///
            /// There are 2 ways you might call this. First, if `meta.path` is not
            /// something you recognize:
            ///
            /// ```
            /// # use syn::Attribute;
            /// #
            /// # fn example(attr: &Attribute) -> syn::Result<()> {
            /// attr.parse_nested_meta(|meta| {
            ///     if meta.path.is_ident("kind") {
            ///        
            ///         Ok(())
            ///     } else {
            ///         Err(meta.error("unsupported tea property"))
            ///     }
            /// })?;
            /// # Ok(())
            /// # }
            /// ```
            ///
            /// In this case, it behaves exactly like
            /// `syn::Error::new_spanned(&meta.path, "message...")`.
            /// ```
            ///
            /// More usefully, the second place is if you've already parsed a value but
            /// have decided not to accept the value:
            ///
            /// ```
            /// # use syn::Attribute;
            /// #
            /// # fn example(attr: &Attribute) -> syn::Result<()> {
            /// use syn::Expr;
            ///
            /// attr.parse_nested_meta(|meta| {
            ///     if meta.path.is_ident("kind") {
            ///         let expr: Expr = meta.value()?.parse()?;
            ///         match expr {
            ///             Expr::Lit(expr) => /* ... */
            /// #               unimplemented!(),
            ///             Expr::Path(expr) => /* ... */
            /// #               unimplemented!(),
            ///             Expr::Macro(expr) => /* ... */
            /// #               unimplemented!(),
            ///             _ => Err(meta.error("tea kind must be a string literal, path, or macro")),
            ///         }
            ///     } else /* as above */
            /// #       { unimplemented!() }
            ///
            /// })?;
            /// # Ok(())
            /// # }
            /// ```
            ///
            /// ```console
            /// error: tea kind must be a string literal, path, or macro
            ///  --> src/main.rs:3:7
            ///   |
            /// 3 | #[tea(kind = async { replicator.await })]
            ///   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            /// ```
            ///
            /// Often you may want to use `syn::Error::new_spanned` even in this
            /// situation. In the above code, that would be:
            ///
            /// ```
            /// # use syn::{Error, Expr};
            /// #
            /// # fn example(expr: Expr) -> syn::Result<()> {
            ///     match expr {
            ///         Expr::Lit(expr) => /* ... */
            /// #           unimplemented!(),
            ///         Expr::Path(expr) => /* ... */
            /// #           unimplemented!(),
            ///         Expr::Macro(expr) => /* ... */
            /// #           unimplemented!(),
            ///         _ => Err(Error::new_spanned(expr, "unsupported expression type for `kind`")),
            ///     }
            /// # }
            /// ```
            ///
            /// ```console
            /// error: unsupported expression type for `kind`
            ///  --> src/main.rs:3:14
            ///   |
            /// 3 | #[tea(kind = async { replicator.await })]
            ///   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^
            /// ```
            pub fn error(&self, msg: impl Display) -> Error {
                let start_span = self.path.segments[0].ident.span();
                let end_span = self.input.cursor().prev_span();
                ::syntax::error::new2(start_span, end_span, msg)
            }
        }

        pub fn parse_nested_meta(
            input: ParseStream,
            mut logic: impl FnMut(ParseNestedMeta) -> Result<()>,
        ) -> Result<()> {
            loop {
                let path = input.call(parse_meta_path)?;
                logic(ParseNestedMeta { path, input })?;
                if input.is_empty() {
                    return Ok(());
                }
                input.parse::<Token![,]>()?;
                if input.is_empty() {
                    return Ok(());
                }
            }
        }
        
        fn parse_meta_path(input: ParseStream) -> Result<Path> {
            Ok(Path {
                leading_colon: input.parse()?,
                segments: {
                    let mut segments = Punctuated::new();
                    if input.peek(Ident::peek_any) {
                        let ident = Ident::parse_any(input)?;
                        segments.push_value(PathSegment::from(ident));
                    } else if input.is_empty() {
                        return Err(input.error("expected nested attribute"));
                    } else if input.peek(Lit) {
                        return Err(input.error("unexpected literal in nested attribute, expected ident"));
                    } else {
                        return Err(input.error("unexpected token in nested attribute, expected ident"));
                    }
                    while input.peek(Token![::]) {
                        let punct = input.parse()?;
                        segments.push_punct(punct);
                        let ident = Ident::parse_any(input)?;
                        segments.push_value(PathSegment::from(ident));
                    }
                    segments
                },
            })
        }
    }
    
    pub mod op
    {
        use ::
        {
            *,
        };
        /*
        */
        ast_enum!
        {
            /// A binary operator: `+`, `+=`, `&`.
            #[non_exhaustive]
            pub enum BinOp {
                /// The `+` operator (addition)
                Add(Token![+]),
                /// The `-` operator (subtraction)
                Sub(Token![-]),
                /// The `*` operator (multiplication)
                Mul(Token![*]),
                /// The `/` operator (division)
                Div(Token![/]),
                /// The `%` operator (modulus)
                Rem(Token![%]),
                /// The `&&` operator (logical and)
                And(Token![&&]),
                /// The `||` operator (logical or)
                Or(Token![||]),
                /// The `^` operator (bitwise xor)
                BitXor(Token![^]),
                /// The `&` operator (bitwise and)
                BitAnd(Token![&]),
                /// The `|` operator (bitwise or)
                BitOr(Token![|]),
                /// The `<<` operator (shift left)
                Shl(Token![<<]),
                /// The `>>` operator (shift right)
                Shr(Token![>>]),
                /// The `==` operator (equality)
                Eq(Token![==]),
                /// The `<` operator (less than)
                Lt(Token![<]),
                /// The `<=` operator (less than or equal to)
                Le(Token![<=]),
                /// The `!=` operator (not equal to)
                Ne(Token![!=]),
                /// The `>=` operator (greater than or equal to)
                Ge(Token![>=]),
                /// The `>` operator (greater than)
                Gt(Token![>]),
                /// The `+=` operator
                AddAssign(Token![+=]),
                /// The `-=` operator
                SubAssign(Token![-=]),
                /// The `*=` operator
                MulAssign(Token![*=]),
                /// The `/=` operator
                DivAssign(Token![/=]),
                /// The `%=` operator
                RemAssign(Token![%=]),
                /// The `^=` operator
                BitXorAssign(Token![^=]),
                /// The `&=` operator
                BitAndAssign(Token![&=]),
                /// The `|=` operator
                BitOrAssign(Token![|=]),
                /// The `<<=` operator
                ShlAssign(Token![<<=]),
                /// The `>>=` operator
                ShrAssign(Token![>>=]),
            }
        }

        ast_enum!
        {
            /// A unary operator: `*`, `!`, `-`.
            #[non_exhaustive]
            pub enum UnOp {
                /// The `*` operator for dereferencing
                Deref(Token![*]),
                /// The `!` operator for logical inversion
                Not(Token![!]),
                /// The `-` operator for negation
                Neg(Token![-]),
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    error::Result,
                    op::{BinOp, UnOp},
                    parse::{Parse, ParseStream},
                },
                *
            };
            
            impl Parse for BinOp
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![+=]) {
                        input.parse().map(BinOp::AddAssign)
                    } else if input.peek(Token![-=]) {
                        input.parse().map(BinOp::SubAssign)
                    } else if input.peek(Token![*=]) {
                        input.parse().map(BinOp::MulAssign)
                    } else if input.peek(Token![/=]) {
                        input.parse().map(BinOp::DivAssign)
                    } else if input.peek(Token![%=]) {
                        input.parse().map(BinOp::RemAssign)
                    } else if input.peek(Token![^=]) {
                        input.parse().map(BinOp::BitXorAssign)
                    } else if input.peek(Token![&=]) {
                        input.parse().map(BinOp::BitAndAssign)
                    } else if input.peek(Token![|=]) {
                        input.parse().map(BinOp::BitOrAssign)
                    } else if input.peek(Token![<<=]) {
                        input.parse().map(BinOp::ShlAssign)
                    } else if input.peek(Token![>>=]) {
                        input.parse().map(BinOp::ShrAssign)
                    } else if input.peek(Token![&&]) {
                        input.parse().map(BinOp::And)
                    } else if input.peek(Token![||]) {
                        input.parse().map(BinOp::Or)
                    } else if input.peek(Token![<<]) {
                        input.parse().map(BinOp::Shl)
                    } else if input.peek(Token![>>]) {
                        input.parse().map(BinOp::Shr)
                    } else if input.peek(Token![==]) {
                        input.parse().map(BinOp::Eq)
                    } else if input.peek(Token![<=]) {
                        input.parse().map(BinOp::Le)
                    } else if input.peek(Token![!=]) {
                        input.parse().map(BinOp::Ne)
                    } else if input.peek(Token![>=]) {
                        input.parse().map(BinOp::Ge)
                    } else if input.peek(Token![+]) {
                        input.parse().map(BinOp::Add)
                    } else if input.peek(Token![-]) {
                        input.parse().map(BinOp::Sub)
                    } else if input.peek(Token![*]) {
                        input.parse().map(BinOp::Mul)
                    } else if input.peek(Token![/]) {
                        input.parse().map(BinOp::Div)
                    } else if input.peek(Token![%]) {
                        input.parse().map(BinOp::Rem)
                    } else if input.peek(Token![^]) {
                        input.parse().map(BinOp::BitXor)
                    } else if input.peek(Token![&]) {
                        input.parse().map(BinOp::BitAnd)
                    } else if input.peek(Token![|]) {
                        input.parse().map(BinOp::BitOr)
                    } else if input.peek(Token![<]) {
                        input.parse().map(BinOp::Lt)
                    } else if input.peek(Token![>]) {
                        input.parse().map(BinOp::Gt)
                    } else {
                        Err(input.error("expected binary operator"))
                    }
                }
            }

            impl Parse for UnOp
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let lookahead = input.lookahead1();
                    if lookahead.peek(Token![*]) {
                        input.parse().map(UnOp::Deref)
                    } else if lookahead.peek(Token![!]) {
                        input.parse().map(UnOp::Not)
                    } else if lookahead.peek(Token![-]) {
                        input.parse().map(UnOp::Neg)
                    } else {
                        Err(lookahead.error())
                    }
                }
            }
        }
        
        pub mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::ToTokens,
                syntax::op::{BinOp, UnOp},
                *,
            };
            
            impl ToTokens for BinOp
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        BinOp::Add(t) => t.to_tokens(tokens),
                        BinOp::Sub(t) => t.to_tokens(tokens),
                        BinOp::Mul(t) => t.to_tokens(tokens),
                        BinOp::Div(t) => t.to_tokens(tokens),
                        BinOp::Rem(t) => t.to_tokens(tokens),
                        BinOp::And(t) => t.to_tokens(tokens),
                        BinOp::Or(t) => t.to_tokens(tokens),
                        BinOp::BitXor(t) => t.to_tokens(tokens),
                        BinOp::BitAnd(t) => t.to_tokens(tokens),
                        BinOp::BitOr(t) => t.to_tokens(tokens),
                        BinOp::Shl(t) => t.to_tokens(tokens),
                        BinOp::Shr(t) => t.to_tokens(tokens),
                        BinOp::Eq(t) => t.to_tokens(tokens),
                        BinOp::Lt(t) => t.to_tokens(tokens),
                        BinOp::Le(t) => t.to_tokens(tokens),
                        BinOp::Ne(t) => t.to_tokens(tokens),
                        BinOp::Ge(t) => t.to_tokens(tokens),
                        BinOp::Gt(t) => t.to_tokens(tokens),
                        BinOp::AddAssign(t) => t.to_tokens(tokens),
                        BinOp::SubAssign(t) => t.to_tokens(tokens),
                        BinOp::MulAssign(t) => t.to_tokens(tokens),
                        BinOp::DivAssign(t) => t.to_tokens(tokens),
                        BinOp::RemAssign(t) => t.to_tokens(tokens),
                        BinOp::BitXorAssign(t) => t.to_tokens(tokens),
                        BinOp::BitAndAssign(t) => t.to_tokens(tokens),
                        BinOp::BitOrAssign(t) => t.to_tokens(tokens),
                        BinOp::ShlAssign(t) => t.to_tokens(tokens),
                        BinOp::ShrAssign(t) => t.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for UnOp
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        UnOp::Deref(t) => t.to_tokens(tokens),
                        UnOp::Not(t) => t.to_tokens(tokens),
                        UnOp::Neg(t) => t.to_tokens(tokens),
                    }
                }
            }
        }
    } pub use self::op::{BinOp, UnOp};
    
    pub mod parse
    {
        //! Parsing interface for parsing a token stream into a syntax tree node.
        use ::
        {
            cell::{ Cell },
            fmt::{ self, Debug, Display },
            hash::{ Hash, Hasher },
            marker::{ PhantomData },
            ops::{ Deref },
            panic::{ RefUnwindSafe, UnwindSafe },
            process::macros::{ Delimiter, Group, Literal, Punct, Span, TokenStream, TokenTree },
            quote::{ ToTokens },
            rc::{ Rc },
            str::{ FromStr },
            syntax::
            {
                buffer::{ Cursor, TokenBuffer },
                error,
                lookahead,
                punctuated::Punctuated,
                token::Token,
            },
            *,
        };
        /*
        */
        pub use ::syntax::
        {
            error::{ Error, Result },
            lookahead::{ End, Lookahead1, Peek },
        };

        pub mod discouraged
        {
            //! Extensions to the parsing API with niche applicability.
            use ::
            {
                cell::{ Cell },
                process::macros::
                {
                    extra::DelimSpan, Delimiter,
                },
                rc::{ Rc },
                syntax::
                {
                    buffer::Cursor,
                    error::Result,
                    parse::{inner_unexpected, ParseBuffer, Unexpected},
                },
                *,
            };
            /*
            */
            /// Extensions to the `ParseStream` API to support speculative parsing.
            pub trait Speculative {
                /// Advance this parse stream to the position of a forked parse stream.
                ///
                /// This is the opposite operation to [`ParseStream::fork`]. You can fork a
                /// parse stream, perform some speculative parsing, then join the original
                /// stream to the fork to "commit" the parsing from the fork to the main
                /// stream.
                ///
                /// If you can avoid doing this, you should, as it limits the ability to
                /// generate useful errors. That said, it is often the only way to parse
                /// syntax of the form `A* B*` for arbitrary syntax `A` and `B`. The problem
                /// is that when the fork fails to parse an `A`, it's impossible to tell
                /// whether that was because of a syntax error and the user meant to provide
                /// an `A`, or that the `A`s are finished and it's time to start parsing
                /// `B`s. Use with care.
                ///
                /// Also note that if `A` is a subset of `B`, `A* B*` can be parsed by
                /// parsing `B*` and removing the leading members of `A` from the
                /// repetition, bypassing the need to involve the downsides associated with
                /// speculative parsing.
                ///
                /// [`ParseStream::fork`]: ParseBuffer::fork
                ///
                /// # Example
                ///
                /// There has been chatter about the possibility of making the colons in the
                /// turbofish syntax like `path::to::<T>` no longer required by accepting
                /// `path::to<T>` in expression position. Specifically, according to [RFC
                /// 2544], [`PathSegment`] parsing should always try to consume a following
                /// `<` token as the start of generic arguments, and reset to the `<` if
                /// that fails (e.g. the token is acting as a less-than operator).
                ///
                /// This is the exact kind of parsing behavior which requires the "fork,
                /// try, commit" behavior that [`ParseStream::fork`] discourages. With
                /// `advance_to`, we can avoid having to parse the speculatively parsed
                /// content a second time.
                ///
                /// This change in behavior can be implemented in syn by replacing just the
                /// `Parse` implementation for `PathSegment`:
                ///
                /// ```
                /// # use syn::ext::IdentExt;
                /// use syn::parse::discouraged::Speculative;
                /// # use syn::parse::{Parse, ParseStream};
                /// # use syn::{Ident, PathArguments, Result, Token};
                ///
                /// pub struct PathSegment {
                ///     pub ident: Ident,
                ///     pub arguments: PathArguments,
                /// }
                /// #
                /// # impl<T> From<T> for PathSegment
                /// # where
                /// #     T: Into<Ident>,
                /// # {
                /// #     fn from(ident: T) -> Self {
                /// #         PathSegment {
                /// #             ident: ident.into(),
                /// #             arguments: PathArguments::None,
                /// #         }
                /// #     }
                /// # }
                ///
                /// impl Parse for PathSegment {
                ///     fn parse(input: ParseStream) -> Result<Self> {
                ///         if input.peek(Token![super])
                ///             || input.peek(Token![self])
                ///             || input.peek(Token![Self])
                ///             || input.peek(Token![crate])
                ///         {
                ///             let ident = input.call(Ident::parse_any)?;
                ///             return Ok(PathSegment::from(ident));
                ///         }
                ///
                ///         let ident = input.parse()?;
                ///         if input.peek(Token![::]) && input.peek3(Token![<]) {
                ///             return Ok(PathSegment {
                ///                 ident,
                ///                 arguments: PathArguments::AngleBracketed(input.parse()?),
                ///             });
                ///         }
                ///         if input.peek(Token![<]) && !input.peek(Token![<=]) {
                ///             let fork = input.fork();
                ///             if let Ok(arguments) = fork.parse() {
                ///                 input.advance_to(&fork);
                ///                 return Ok(PathSegment {
                ///                     ident,
                ///                     arguments: PathArguments::AngleBracketed(arguments),
                ///                 });
                ///             }
                ///         }
                ///         Ok(PathSegment::from(ident))
                ///     }
                /// }
                ///
                /// # syn::parse_str::<PathSegment>("a<b,c>").unwrap();
                /// ```
                ///
                /// # Drawbacks
                ///
                /// The main drawback of this style of speculative parsing is in error
                /// presentation. Even if the lookahead is the "correct" parse, the error
                /// that is shown is that of the "fallback" parse. To use the same example
                /// as the turbofish above, take the following unfinished "turbofish":
                ///
                /// ```text
                /// let _ = f<&'a fn(), for<'a> serde::>();
                /// ```
                ///
                /// If this is parsed as generic arguments, we can provide the error message
                ///
                /// ```text
                /// error: expected identifier
                ///  --> src.rs:L:C
                ///   |
                /// L | let _ = f<&'a fn(), for<'a> serde::>();
                ///   |                                    ^
                /// ```
                ///
                /// but if parsed using the above speculative parsing, it falls back to
                /// assuming that the `<` is a less-than when it fails to parse the generic
                /// arguments, and tries to interpret the `&'a` as the start of a labelled
                /// loop, resulting in the much less helpful error
                ///
                /// ```text
                /// error: expected `:`
                ///  --> src.rs:L:C
                ///   |
                /// L | let _ = f<&'a fn(), for<'a> serde::>();
                ///   |               ^^
                /// ```
                ///
                /// This can be mitigated with various heuristics (two examples: show both
                /// forks' parse errors, or show the one that consumed more tokens), but
                /// when you can control the grammar, sticking to something that can be
                /// parsed LL(3) and without the LL(*) speculative parsing this makes
                /// possible, displaying reasonable errors becomes much more simple.
                ///
                /// [RFC 2544]: https://github.com/rust-lang/rfcs/pull/2544
                /// [`PathSegment`]: ::syntax::PathSegment
                ///
                /// # Performance
                ///
                /// This method performs a cheap fixed amount of work that does not depend
                /// on how far apart the two streams are positioned.
                ///
                /// # Panics
                ///
                /// The forked stream in the argument of `advance_to` must have been
                /// obtained by forking `self`. Attempting to advance to any other stream
                /// will cause a panic.
                fn advance_to(&self, fork: &Self);
            }

            impl<'a> Speculative for ParseBuffer<'a> {
                fn advance_to(&self, fork: &Self) {
                    if !::syntax::buffer::same_scope(self.cursor(), fork.cursor()) {
                        panic!("fork was not derived from the advancing parse stream");
                    }

                    let (self_unexp, self_sp) = inner_unexpected(self);
                    let (fork_unexp, fork_sp) = inner_unexpected(fork);
                    if !Rc::ptr_eq(&self_unexp, &fork_unexp) {
                        match (fork_sp, self_sp) {
                           
                            (Some((span, delimiter)), None) => {
                                self_unexp.set(Unexpected::Some(span, delimiter));
                            }
                           
                            (None, None) => {
                                fork_unexp.set(Unexpected::Chain(self_unexp));

                               
                               
                               
                               
                                fork.unexpected
                                    .set(Some(Rc::new(Cell::new(Unexpected::None))));
                            }
                           
                            (_, Some(_)) => {}
                        }
                    }

                   
                    self.cell
                        .set(unsafe { mem::transmute::<Cursor, Cursor<'static>>(fork.cursor()) });
                }
            }
            /// Extensions to the `ParseStream` API to support manipulating invisible
            /// delimiters the same as if they were visible.
            pub trait AnyDelimiter {
                /// Returns the delimiter, the span of the delimiter token, and the nested
                /// contents for further parsing.
                fn parse_any_delimiter(&self) -> Result<(Delimiter, DelimSpan, ParseBuffer)>;
            }

            impl<'a> AnyDelimiter for ParseBuffer<'a>
            {
                fn parse_any_delimiter(&self) -> Result<(Delimiter, DelimSpan, ParseBuffer)> {
                    self.step(|cursor| {
                        if let Some((content, delimiter, span, rest)) = cursor.any_group() {
                            let scope = span.close();
                            let nested = ::syntax::parse::advance_step_cursor(cursor, content);
                            let unexpected = ::syntax::parse::get_unexpected(self);
                            let content = ::syntax::parse::new_parse_buffer(scope, nested, unexpected);
                            Ok(((delimiter, span, content), rest))
                        } else {
                            Err(cursor.error("expected any delimiter"))
                        }
                    })
                }
            }
        }
        /// Parsing interface implemented by all types that can be parsed in a default
        /// way from a token stream.
        pub trait Parse: Sized {
            fn parse(input: ParseStream) -> Result<Self>;
        }
        /// Input to a Syn parser function.
        pub type ParseStream<'a> = &'a ParseBuffer<'a>;

        /// Cursor position within a buffered token stream.
        pub struct ParseBuffer<'a> {
            scope: Span,
           
            cell: Cell<Cursor<'static>>,
            marker: PhantomData<Cursor<'a>>,
            unexpected: Cell<Option<Rc<Cell<Unexpected>>>>,
        }

        impl<'a> Drop for ParseBuffer<'a> {
            fn drop(&mut self) {
                if let Some((unexpected_span, delimiter)) = span_of_unexpected_ignoring_nones(self.cursor())
                {
                    let (inner, old_span) = inner_unexpected(self);
                    if old_span.is_none() {
                        inner.set(Unexpected::Some(unexpected_span, delimiter));
                    }
                }
            }
        }

        impl<'a> Display for ParseBuffer<'a> {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                Display::fmt(&self.cursor().token_stream(), f)
            }
        }

        impl<'a> Debug for ParseBuffer<'a> {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                Debug::fmt(&self.cursor().token_stream(), f)
            }
        }

        impl<'a> UnwindSafe for ParseBuffer<'a> {}
        impl<'a> RefUnwindSafe for ParseBuffer<'a> {}
        /// Cursor state associated with speculative parsing.
        pub struct StepCursor<'c, 'a> 
        {
            scope: Span,
           
            cursor: Cursor<'c>,
           
           
           
           
            //
           
           
           
            marker: PhantomData<fn(Cursor<'c>) -> Cursor<'a>>,
        }

        impl<'c, 'a> Deref for StepCursor<'c, 'a> 
        {
            type Target = Cursor<'c>;

            fn deref(&self) -> &Self::Target {
                &self.cursor
            }
        }

        impl<'c, 'a> Copy for StepCursor<'c, 'a> {}

        impl<'c, 'a> Clone for StepCursor<'c, 'a> 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl<'c, 'a> StepCursor<'c, 'a> 
        {
            /// Triggers an error at the current position of the parse stream.
            pub fn error<T: Display>(self, message: T) -> Error {
                error::new_at(self.scope, self.cursor, message)
            }
        }

        pub fn advance_step_cursor<'c, 'a>(proof: StepCursor<'c, 'a>, to: Cursor<'c>) -> Cursor<'a> 
        {
           
           
           
           
            let _ = proof;
            unsafe { mem::transmute::<Cursor<'c>, Cursor<'a>>(to) }
        }

        pub fn new_parse_buffer(
            scope: Span,
            cursor: Cursor,
            unexpected: Rc<Cell<Unexpected>>,
        ) -> ParseBuffer 
        {
            ParseBuffer {
                scope,
               
                cell: Cell::new(unsafe { mem::transmute::<Cursor, Cursor<'static>>(cursor) }),
                marker: PhantomData,
                unexpected: Cell::new(Some(unexpected)),
            }
        }

        pub enum Unexpected 
        {
            None,
            Some(Span, Delimiter),
            Chain(Rc<Cell<Unexpected>>),
        }

        impl Default for Unexpected 
        {
            fn default() -> Self {
                Unexpected::None
            }
        }

        impl Clone for Unexpected 
        {
            fn clone(&self) -> Self {
                match self {
                    Unexpected::None => Unexpected::None,
                    Unexpected::Some(span, delimiter) => Unexpected::Some(*span, *delimiter),
                    Unexpected::Chain(next) => Unexpected::Chain(next.clone()),
                }
            }
        }

        fn cell_clone<T: Default + Clone>(cell: &Cell<T>) -> T 
        {
            let prev = cell.take();
            let ret = prev.clone();
            cell.set(prev);
            ret
        }

        fn inner_unexpected(buffer: &ParseBuffer) -> (Rc<Cell<Unexpected>>, Option<(Span, Delimiter)>) 
        {
            let mut unexpected = get_unexpected(buffer);
            loop {
                match cell_clone(&unexpected) {
                    Unexpected::None => return (unexpected, None),
                    Unexpected::Some(span, delimiter) => return (unexpected, Some((span, delimiter))),
                    Unexpected::Chain(next) => unexpected = next,
                }
            }
        }

        pub fn get_unexpected(buffer: &ParseBuffer) -> Rc<Cell<Unexpected>> 
        {
            cell_clone(&buffer.unexpected).unwrap()
        }

        fn span_of_unexpected_ignoring_nones(mut cursor: Cursor) -> Option<(Span, Delimiter)> 
        {
            if cursor.eof() {
                return None;
            }
            while let Some((inner, _span, rest)) = cursor.group(Delimiter::None) {
                if let Some(unexpected) = span_of_unexpected_ignoring_nones(inner) {
                    return Some(unexpected);
                }
                cursor = rest;
            }
            if cursor.eof() {
                None
            } else {
                Some((cursor.span(), cursor.scope_delimiter()))
            }
        }

        impl<'a> ParseBuffer<'a> 
        {
            /// Parses a syntax tree node of type `T`, advancing the position of our
            /// parse stream past it.
            pub fn parse<T: Parse>(&self) -> Result<T> {
                T::parse(self)
            }
            /// Calls the given parser function to parse a syntax tree node of type `T`
            /// from this stream.
            /// use syn::{Attribute, Ident, Result, Token};
            /// use syn::parse::{Parse, ParseStream};
            ///
            ///
            /// //
            ///
            ///
            /// struct UnitStruct {
            ///     attrs: Vec<Attribute>,
            ///     struct_token: Token![struct],
            ///     name: Ident,
            ///     semi_token: Token![;],
            /// }
            ///
            /// impl Parse for UnitStruct {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         Ok(UnitStruct {
            ///             attrs: input.call(Attribute::parse_outer)?,
            ///             struct_token: input.parse()?,
            ///             name: input.parse()?,
            ///             semi_token: input.parse()?,
            ///         })
            ///     }
            /// }
            /// ```
            pub fn call<T>(&'a self, function: fn(ParseStream<'a>) -> Result<T>) -> Result<T> {
                function(self)
            }
            /// Looks at the next token in the parse stream to determine whether it
            /// matches the requested type of token.
            ///
            /// In this example we finish parsing the list of supertraits when the next
            /// token in the input is either `where` or an opening curly brace.
            /// use syn::parse::{Parse, ParseStream};
            /// use syn::punctuated::Punctuated;
            ///
            ///
            /// //
            ///
            /// struct MarkerTrait {
            ///     trait_token: Token![trait],
            ///     ident: Ident,
            ///     generics: Generics,
            ///     colon_token: Option<Token![:]>,
            ///     supertraits: Punctuated<TypeParamBound, Token![+]>,
            ///     brace_token: token::Brace,
            /// }
            ///
            /// impl Parse for MarkerTrait {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         let trait_token: Token![trait] = input.parse()?;
            ///         let ident: Ident = input.parse()?;
            ///         let mut generics: Generics = input.parse()?;
            ///         let colon_token: Option<Token![:]> = input.parse()?;
            ///
            ///         let mut supertraits = Punctuated::new();
            ///         if colon_token.is_some() {
            ///             loop {
            ///                 supertraits.push_value(input.parse()?);
            ///                 if input.peek(Token![where]) || input.peek(token::Brace) {
            ///                     break;
            ///                 }
            ///                 supertraits.push_punct(input.parse()?);
            ///             }
            ///         }
            ///
            ///         generics.where_clause = input.parse()?;
            ///         let content;
            ///         let empty_brace_token = braced!(content in input);
            ///
            ///         Ok(MarkerTrait {
            ///             trait_token,
            ///             ident,
            ///             generics,
            ///             colon_token,
            ///             supertraits,
            ///             brace_token: empty_brace_token,
            ///         })
            ///     }
            /// }
            /// ```
            pub fn peek<T: Peek>(&self, token: T) -> bool
        {
                let _ = token;
                T::Token::peek(self.cursor())
            }
            /// Looks at the second-next token in the parse stream.
            /// union` and a macro invocation that looks like `union::some_macro! { ...
            /// }`. In other words `union` is a contextual keyword.
            /// use syn::parse::{Parse, ParseStream};
            ///
            ///
            /// enum UnionOrMacro {
            ///    
            ///     Union(ItemUnion),
            ///    
            ///     Macro(Macro),
            /// }
            ///
            /// impl Parse for UnionOrMacro {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         if input.peek(Token![union]) && input.peek2(Ident) {
            ///             input.parse().map(UnionOrMacro::Union)
            ///         } else {
            ///             input.parse().map(UnionOrMacro::Macro)
            ///         }
            ///     }
            /// }
            /// ```
            pub fn peek2<T: Peek>(&self, token: T) -> bool
        {
                fn peek2(buffer: &ParseBuffer, peek: fn(Cursor) -> bool) -> bool
        {
                    buffer.cursor().skip().map_or(false, peek)
                }

                let _ = token;
                peek2(self, T::Token::peek)
            }
            /// Looks at the third-next token in the parse stream.
            pub fn peek3<T: Peek>(&self, token: T) -> bool
        {
                fn peek3(buffer: &ParseBuffer, peek: fn(Cursor) -> bool) -> bool
        {
                    buffer
                        .cursor()
                        .skip()
                        .and_then(Cursor::skip)
                        .map_or(false, peek)
                }

                let _ = token;
                peek3(self, T::Token::peek)
            }
            /// Parses zero or more occurrences of `T` separated by punctuation of type
            /// `P`, with optional trailing punctuation.
            ///
            /// struct TupleStruct {
            ///     struct_token: Token![struct],
            ///     ident: Ident,
            ///     paren_token: token::Paren,
            ///     fields: Punctuated<Type, Token![,]>,
            ///     semi_token: Token![;],
            /// }
            ///
            /// impl Parse for TupleStruct {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         let content;
            ///         Ok(TupleStruct {
            ///             struct_token: input.parse()?,
            ///             ident: input.parse()?,
            ///             paren_token: parenthesized!(content in input),
            ///             fields: content.parse_terminated(Type::parse, Token![,])?,
            ///             semi_token: input.parse()?,
            ///         })
            ///     }
            /// }
            /// #
            /// # let input = quote! {
            /// #     struct S(A, B);
            /// # };
            /// # syn::parse2::<TupleStruct>(input).unwrap();
            /// ```
            ///
            /// # See also
            ///
            /// If your separator is anything more complicated than an invocation of the
            /// `Token!` macro, this method won't be applicable and you can instead
            /// directly use `Punctuated`'s parser functions: [`parse_terminated`],
            /// [`parse_separated_nonempty`] etc.
            ///
            /// ```
            /// use syn::{custom_keyword, Expr, Result, Token};
            /// use syn::parse::{Parse, ParseStream};
            /// use syn::punctuated::Punctuated;
            ///
            /// mod kw {
            ///     syn::custom_keyword!(fin);
            /// }
            ///
            /// struct Fin(kw::fin, Token![;]);
            ///
            /// impl Parse for Fin {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         Ok(Self(input.parse()?, input.parse()?))
            ///     }
            /// }
            ///
            /// struct Thing {
            ///     steps: Punctuated<Expr, Fin>,
            /// }
            ///
            /// impl Parse for Thing {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            /// # if true {
            ///         Ok(Thing {
            ///             steps: Punctuated::parse_terminated(input)?,
            ///         })
            /// # } else {
            ///        
            /// #       Ok(Thing {
            ///             steps: input.call(Punctuated::parse_terminated)?,
            /// #       })
            /// # }
            ///     }
            /// }
            /// ```
            pub fn parse_terminated<T, P>(
                &'a self,
                parser: fn(ParseStream<'a>) -> Result<T>,
                separator: P,
            ) -> Result<Punctuated<T, P::Token>> where
                P: Peek,
                P::Token: Parse,
            {
                let _ = separator;
                Punctuated::parse_terminated_with(self, parser)
            }
            /// Returns whether there are no more tokens remaining to be parsed from
            /// this stream.
            /// outermost parsing entry point.
            /// Use `.peek2(End)` or `.peek3(End)` to look for the end of a parse stream
            /// further ahead than the current position.
            /// use syn::parse::{Parse, ParseStream};
            ///
            ///
            /// struct Mod {
            ///     mod_token: Token![mod],
            ///     name: Ident,
            ///     brace_token: token::Brace,
            ///     items: Vec<Item>,
            /// }
            ///
            /// impl Parse for Mod {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         let content;
            ///         Ok(Mod {
            ///             mod_token: input.parse()?,
            ///             name: input.parse()?,
            ///             brace_token: braced!(content in input),
            ///             items: {
            ///                 let mut items = Vec::new();
            ///                 while !content.is_empty() {
            ///                     items.push(content.parse()?);
            ///                 }
            ///                 items
            ///             },
            ///         })
            ///     }
            /// }
            /// ```
            pub fn is_empty(&self) -> bool
            {
                self.cursor().eof()
            }
            /// Constructs a helper for peeking at the next token in this stream and
            /// building an error message if it is not one of a set of expected tokens.
            /// use syn::parse::{Parse, ParseStream};
            ///
            ///
            ///
            /// //
            ///
            /// //
            ///
            /// //
            ///
            ///
            ///
            ///
            /// enum GenericParam {
            ///     Type(TypeParam),
            ///     Lifetime(LifetimeParam),
            ///     Const(ConstParam),
            /// }
            ///
            /// impl Parse for GenericParam {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         let lookahead = input.lookahead1();
            ///         if lookahead.peek(Ident) {
            ///             input.parse().map(GenericParam::Type)
            ///         } else if lookahead.peek(Lifetime) {
            ///             input.parse().map(GenericParam::Lifetime)
            ///         } else if lookahead.peek(Token![const]) {
            ///             input.parse().map(GenericParam::Const)
            ///         } else {
            ///             Err(lookahead.error())
            ///         }
            ///     }
            /// }
            /// ```
            pub fn lookahead1(&self) -> Lookahead1<'a> {
                lookahead::new(self.scope, self.cursor())
            }
            /// Forks a parse stream so that parsing tokens out of either the original
            /// or the fork does not advance the position of the other.
            /// is if your macro ends up parsing a large amount of content more than
            /// once.
            /// if input.fork().parse::<Expr>().is_ok() {
            ///     return input.parse::<Expr>();
            /// }
            /// # unimplemented!()
            /// # }
            /// ```
            ///
            /// As a rule, avoid parsing an unbounded amount of tokens out of a forked
            /// parse stream. Only use a fork when the amount of work performed against
            /// the fork is small and bounded.
            /// original stream once the fork's parse is determined to have been
            /// successful.
            ///
            /// [`parse::discouraged::Speculative`]: discouraged::Speculative
            /// [`ParseStream::step`]: ParseBuffer::step
            ///
            /// # Example
            ///
            /// The parse implementation shown here parses possibly restricted `pub`
            /// visibilities.
            /// - `pub(self)`
            /// - `pub(super)`
            /// - `pub(in some::path)`
            ///
            /// To handle the case of visibilities inside of tuple structs, the parser
            /// needs to distinguish parentheses that specify visibility restrictions
            /// from parentheses that form part of a tuple type.
            /// ```
            ///
            /// In this example input the first tuple struct element of `S` has
            /// `pub(crate)` visibility while the second tuple struct element has `pub`
            /// visibility; the parentheses around `(B, C)` are part of the type rather
            /// than part of a visibility restriction.
            /// work performed against the forked parse stream.
            /// use syn::ext::IdentExt;
            /// use syn::parse::{Parse, ParseStream};
            ///
            /// struct PubVisibility {
            ///     pub_token: Token![pub],
            ///     restricted: Option<Restricted>,
            /// }
            ///
            /// struct Restricted {
            ///     paren_token: token::Paren,
            ///     in_token: Option<Token![in]>,
            ///     path: Path,
            /// }
            ///
            /// impl Parse for PubVisibility {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         let pub_token: Token![pub] = input.parse()?;
            ///
            ///         if input.peek(token::Paren) {
            ///             let ahead = input.fork();
            ///             let mut content;
            ///             parenthesized!(content in ahead);
            ///
            ///             if content.peek(Token![crate])
            ///                 || content.peek(Token![self])
            ///                 || content.peek(Token![super])
            ///             {
            ///                 return Ok(PubVisibility {
            ///                     pub_token,
            ///                     restricted: Some(Restricted {
            ///                         paren_token: parenthesized!(content in input),
            ///                         in_token: None,
            ///                         path: Path::from(content.call(Ident::parse_any)?),
            ///                     }),
            ///                 });
            ///             } else if content.peek(Token![in]) {
            ///                 return Ok(PubVisibility {
            ///                     pub_token,
            ///                     restricted: Some(Restricted {
            ///                         paren_token: parenthesized!(content in input),
            ///                         in_token: Some(content.parse()?),
            ///                         path: content.call(Path::parse_mod_style)?,
            ///                     }),
            ///                 });
            ///             }
            ///         }
            ///
            ///         Ok(PubVisibility {
            ///             pub_token,
            ///             restricted: None,
            ///         })
            ///     }
            /// }
            /// ```
            pub fn fork(&self) -> Self {
                ParseBuffer {
                    scope: self.scope,
                    cell: self.cell.clone(),
                    marker: PhantomData,
                   
                   
                    unexpected: Cell::new(Some(Rc::new(Cell::new(Unexpected::None)))),
                }
            }
            /// Triggers an error at the current position of the parse stream.
            /// use syn::parse::{Parse, ParseStream};
            ///
            ///
            /// struct Loop {
            ///     expr: Expr,
            /// }
            ///
            /// impl Parse for Loop {
            ///     fn parse(input: ParseStream) -> Result<Self> {
            ///         if input.peek(Token![while])
            ///             || input.peek(Token![for])
            ///             || input.peek(Token![loop])
            ///         {
            ///             Ok(Loop {
            ///                 expr: input.parse()?,
            ///             })
            ///         } else {
            ///             Err(input.error("expected some kind of loop"))
            ///         }
            ///     }
            /// }
            /// ```
            pub fn error<T: Display>(&self, message: T) -> Error {
                error::new_at(self.scope, self.cursor(), message)
            }
            /// Speculatively parses tokens from this parse stream, advancing the
            /// position of this stream only if parsing succeeds.
            /// widely outside of the Syn codebase.
            /// use syn::Result;
            /// use syn::parse::ParseStream;
            ///
            ///
            ///
            ///
            /// fn skip_past_next_at(input: ParseStream) -> Result<()> {
            ///     input.step(|cursor| {
            ///         let mut rest = *cursor;
            ///         while let Some((tt, next)) = rest.token_tree() {
            ///             match &tt {
            ///                 TokenTree::Punct(punct) if punct.as_char() == '@' => {
            ///                     return Ok(((), next));
            ///                 }
            ///                 _ => rest = next,
            ///             }
            ///         }
            ///         Err(cursor.error("no `@` was found after this point"))
            ///     })
            /// }
            /// #
            /// # fn remainder_after_skipping_past_next_at(
            /// #     input: ParseStream,
            /// # ) -> Result<process::macros::TokenStream> {
            /// #     skip_past_next_at(input)?;
            /// #     input.parse()
            /// # }
            /// #
            /// # use syn::parse::Parser;
            /// # let remainder = remainder_after_skipping_past_next_at
            /// #     .parse_str("a @ b c")
            /// #     .unwrap();
            /// # assert_eq!(remainder.to_string(), "b c");
            /// ```
            pub fn step<F, R>(&self, function: F) -> Result<R> where
                F: for<'c> FnOnce(StepCursor<'c, 'a>) -> Result<(R, Cursor<'c>)>,
            {
               
               
               
                //
               
               
               
               
               
               
               
                //
               
               
               
               
               
                let (node, rest) = function(StepCursor {
                    scope: self.scope,
                    cursor: self.cell.get(),
                    marker: PhantomData,
                })?;
                self.cell.set(rest);
                Ok(node)
            }
            /// Returns the `Span` of the next token in the parse stream, or
            /// `Span::call_site()` if this parse stream has completely exhausted its
            /// input `TokenStream`.
            pub fn span(&self) -> Span {
                let cursor = self.cursor();
                if cursor.eof() {
                    self.scope
                } else {
                    ::syntax::buffer::open_span_of_group(cursor)
                }
            }
            /// Provides low-level access to the token representation underlying this
            /// parse stream.
            /// use syn::buffer::Cursor;
            /// use syn::parse::{ParseStream, Result};
            ///
            ///
            ///
            /// fn recognize_token_stream<T>(
            ///     recognizer: fn(ParseStream) -> Result<T>,
            /// ) -> impl Fn(ParseStream) -> Result<TokenStream> {
            ///     move |input| {
            ///         let begin = input.cursor();
            ///         recognizer(input)?;
            ///         let end = input.cursor();
            ///         Ok(tokens_between(begin, end))
            ///     }
            /// }
            ///
            ///
            /// fn tokens_between(begin: Cursor, end: Cursor) -> TokenStream {
            ///     assert!(begin <= end);
            ///
            ///     let mut cursor = begin;
            ///     let mut tokens = TokenStream::new();
            ///     while cursor < end {
            ///         let (token, next) = cursor.token_tree().unwrap();
            ///         tokens.extend(std::iter::once(token));
            ///         cursor = next;
            ///     }
            ///     tokens
            /// }
            ///
            /// fn main() {
            ///     use ::quote::quote;
            ///     use syn::parse::{Parse, Parser};
            ///     use syn::Token;
            ///
            ///    
            ///     fn example(input: ParseStream) -> Result<TokenStream> {
            ///         let _langle: Token![<] = input.parse()?;
            ///         let ty = recognize_token_stream(syn::Type::parse)(input)?;
            ///         let _rangle: Token![>] = input.parse()?;
            ///         Ok(ty)
            ///     }
            ///
            ///     let tokens = quote! { <fn() -> u8> };
            ///     println!("{}", example.parse2(tokens).unwrap());
            /// }
            /// ```
            pub fn cursor(&self) -> Cursor<'a>
            {
                self.cell.get()
            }

            fn check_unexpected(&self) -> Result<()>
            {
                match inner_unexpected(self).1 {
                    Some((span, delimiter)) => Err(err_unexpected_token(span, delimiter)),
                    None => Ok(()),
                }
            }
        }

        impl<T: Parse> Parse for Box<T> 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.parse().map(Box::new)
            }
        }

        impl<T: Parse + Token> Parse for Option<T> 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                if T::peek(input.cursor()) {
                    Ok(Some(input.parse()?))
                } else {
                    Ok(None)
                }
            }
        }

        impl Parse for TokenStream 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| Ok((cursor.token_stream(), Cursor::empty())))
            }
        }

        impl Parse for TokenTree 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| match cursor.token_tree() {
                    Some((tt, rest)) => Ok((tt, rest)),
                    None => Err(cursor.error("expected token tree")),
                })
            }
        }

        impl Parse for Group 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| {
                    if let Some((group, rest)) = cursor.any_group_token() {
                        if group.delimiter() != Delimiter::None {
                            return Ok((group, rest));
                        }
                    }
                    Err(cursor.error("expected group token"))
                })
            }
        }

        impl Parse for Punct 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| match cursor.punct() {
                    Some((punct, rest)) => Ok((punct, rest)),
                    None => Err(cursor.error("expected punctuation token")),
                })
            }
        }

        impl Parse for Literal 
        {
            fn parse(input: ParseStream) -> Result<Self> {
                input.step(|cursor| match cursor.literal() {
                    Some((literal, rest)) => Ok((literal, rest)),
                    None => Err(cursor.error("expected literal token")),
                })
            }
        }
        /// Parser that can parse Rust tokens into a particular syntax tree node.
        pub trait Parser: Sized 
        {
            type Output;

            /// Parse a proc-macro2 token stream into the chosen syntax tree node.
            fn parse2(self, tokens: TokenStream) -> Result<Self::Output>;

            /// Parse tokens of source code into the chosen syntax tree node.
            #[cfg(feature = "proc-macro")]
            #[cfg_attr(docsrs, doc(cfg(feature = "proc-macro")))]
            fn parse(self, tokens: proc_macro::TokenStream) -> Result<Self::Output>
            {
                self.parse2(process::macros::TokenStream::from(tokens))
            }
            /// Parse a string of Rust code into the chosen syntax tree node.
            fn parse_str(self, s: &str) -> Result<Self::Output>
            {
                self.parse2(process::macros::TokenStream::from_str(s)?)
            }

           
                fn __parse_scoped(self, scope: Span, tokens: TokenStream) -> Result<Self::Output>
            {
                let _ = scope;
                self.parse2(tokens)
            }
        }

        fn tokens_to_parse_buffer(tokens: &TokenBuffer) -> ParseBuffer 
        {
            let scope = Span::call_site();
            let cursor = tokens.begin();
            let unexpected = Rc::new(Cell::new(Unexpected::None));
            new_parse_buffer(scope, cursor, unexpected)
        }

        impl<F, T> Parser for F
        where
            F: FnOnce(ParseStream) -> Result<T>,
        {
            type Output = T;

            fn parse2(self, tokens: TokenStream) -> Result<T>
            {
                let buf = TokenBuffer::new2(tokens);
                let state = tokens_to_parse_buffer(&buf);
                let node = self(&state)?;
                state.check_unexpected()?;
                if let Some((unexpected_span, delimiter)) =
                    span_of_unexpected_ignoring_nones(state.cursor())
                {
                    Err(err_unexpected_token(unexpected_span, delimiter))
                } else {
                    Ok(node)
                }
            }

            fn __parse_scoped(self, scope: Span, tokens: TokenStream) -> Result<Self::Output>
            {
                let buf = TokenBuffer::new2(tokens);
                let cursor = buf.begin();
                let unexpected = Rc::new(Cell::new(Unexpected::None));
                let state = new_parse_buffer(scope, cursor, unexpected);
                let node = self(&state)?;
                state.check_unexpected()?;
                if let Some((unexpected_span, delimiter)) =
                    span_of_unexpected_ignoring_nones(state.cursor())
                {
                    Err(err_unexpected_token(unexpected_span, delimiter))
                } else {
                    Ok(node)
                }
            }
        }

        pub fn parse_scoped<F: Parser>(f: F, scope: Span, tokens: TokenStream) -> Result<F::Output> 
        {
            f.__parse_scoped(scope, tokens)
        }

        fn err_unexpected_token(span: Span, delimiter: Delimiter) -> Error 
        {
            let msg = match delimiter {
                Delimiter::Parenthesis => "unexpected token, expected `)`",
                Delimiter::Brace => "unexpected token, expected `}`",
                Delimiter::Bracket => "unexpected token, expected `]`",
                Delimiter::None => "unexpected token",
            };
            Error::new(span, msg)
        }
        /// An empty syntax tree node that consumes no tokens when parsed.
        pub struct Nothing;

        impl Parse for Nothing 
        {
            fn parse(_input: ParseStream) -> Result<Self>
            {
                Ok
                (Nothing)
            }
        }
        
        impl ToTokens for Nothing
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                let _ = tokens;
            }
        }

        impl Clone for Nothing 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl Copy for Nothing {}

        impl Debug for Nothing 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                f.write_str("Nothing")
            }
        }

        impl Eq for Nothing {}

        impl PartialEq for Nothing 
        {
            fn eq(&self, _other: &Self) -> bool
        {
                true
            }
        }

        impl Hash for Nothing 
        {
            fn hash<H: Hasher>(&self, _state: &mut H) {}
        }
    } 
    
    pub mod parse_quote
    {
       
        /// type inference to figure out a return type for those tokens.
        use ::
        {
            process::macros::{ TokenStream },
            syntax::
            {
                error::Result,
                parse::{Parse, ParseStream, Parser},
                Arm, Block, Pat, Stmt, attr, Attribute, Field, FieldMutability, Ident, Type, Visibility,
            },
            *,
        };
        /*
        Can parse any type that implements Parse. */       
        #[track_caller] pub fn parse<T: ParseQuote>(token_stream: TokenStream) -> T {
            let parser = T::parse;
            match parser.parse2(token_stream) {
                Ok(t) => t,
                Err(err) => panic!("{}", err),
            }
        }

        pub trait ParseQuote: Sized {
            fn parse(input: ParseStream) -> Result<Self>;
        }

        impl<T: Parse> ParseQuote for T {
            fn parse(input: ParseStream) -> Result<Self> {
                <T as Parse>::parse(input)
            }
        }
        
        impl ParseQuote for Attribute {
            fn parse(input: ParseStream) -> Result<Self> {
                if input.peek(Token![#]) && input.peek2(Token![!]) {
                    attr::parsing::single_parse_inner(input)
                } else {
                    attr::parsing::single_parse_outer(input)
                }
            }
        }

        impl ParseQuote for Vec<Attribute> {
            fn parse(input: ParseStream) -> Result<Self>
            {
                let mut attrs = Vec::new();
                while !input.is_empty() {
                    attrs.push(ParseQuote::parse(input)?);
                }
                Ok(attrs)
            }
        }

        impl ParseQuote for Field {
            fn parse(input: ParseStream) -> Result<Self>
            {
                let attrs = input.call(Attribute::parse_outer)?;
                let vis: Visibility = input.parse()?;

                let ident: Option<Ident>;
                let colon_token: Option<Token![:]>;
                let is_named = input.peek(Ident) && input.peek2(Token![:]) && !input.peek2(Token![::]);
                if is_named {
                    ident = Some(input.parse()?);
                    colon_token = Some(input.parse()?);
                } else {
                    ident = None;
                    colon_token = None;
                }

                let ty: Type = input.parse()?;

                Ok(Field {
                    attrs,
                    vis,
                    mutability: FieldMutability::None,
                    ident,
                    colon_token,
                    ty,
                })
            }
        }

        impl ParseQuote for Pat {
            fn parse(input: ParseStream) -> Result<Self> {
                Pat::parse_multi_with_leading_vert(input)
            }
        }

        impl ParseQuote for Box<Pat> {
            fn parse(input: ParseStream) -> Result<Self> {
                <Pat as ParseQuote>::parse(input).map(Box::new)
            }
        }

        impl<T: Parse, P: Parse> ParseQuote for Punctuated<T, P> {
            fn parse(input: ParseStream) -> Result<Self> {
                Self::parse_terminated(input)
            }
        }

        impl ParseQuote for Vec<Stmt> {
            fn parse(input: ParseStream) -> Result<Self> {
                Block::parse_within(input)
            }
        }

        impl ParseQuote for Vec<Arm> {
            fn parse(input: ParseStream) -> Result<Self> {
                Arm::parse_multiple(input)
            }
        }
    }
    
    pub mod pat
    {
        use ::
        {
            process::macros::TokenStream,
            syntax::
            {
                attr::{ Attribute },
                expr::{ Member },
                ident::{ Ident },
                path::{ Path, QSelf },
                punctuated::{ Punctuated },
                ty::{ Type },
                token,
            },
            *,
        };
        
        pub use ::syntax::expr::
        {
            ExprConst as PatConst, 
            ExprLit as PatLit, 
            ExprMacro as PatMacro, 
            ExprPath as PatPath, 
            ExprRange as PatRange,
        };
        /*
        */
        ast_enum_of_structs!
        {
            /// A pattern in a local binding, function signature, match expression, or
            /// various other places.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            #[non_exhaustive]
            pub enum Pat {
                /// A const block: `const { ... }`.
                Const(PatConst),
                /// A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.
                Ident(PatIdent),
                /// A literal pattern: `0`.
                Lit(PatLit),
                /// A macro in pattern position.
                Macro(PatMacro),
                /// A pattern that matches any one of a set of cases.
                Or(PatOr),
                /// A parenthesized pattern: `(A | B)`.
                Paren(PatParen),
                /// A path pattern like `Color::Red`, optionally qualified with a
                /// self-type.
                ///
                /// Unqualified path patterns can legally refer to variants, structs,
                /// constants or associated constants. Qualified path patterns like
                /// `<A>::B::C` and `<A as Trait>::B::C` can only legally refer to
                /// associated constants.
                Path(PatPath),
                /// A range pattern: `1..=2`.
                Range(PatRange),
                /// A reference pattern: `&mut var`.
                Reference(PatReference),
                /// The dots in a tuple or slice pattern: `[0, 1, ..]`.
                Rest(PatRest),
                /// A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.
                Slice(PatSlice),
                /// A struct or struct variant pattern: `Variant { x, y, .. }`.
                Struct(PatStruct),
                /// A tuple pattern: `(a, b)`.
                Tuple(PatTuple),
                /// A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.
                TupleStruct(PatTupleStruct),
                /// A type ascription pattern: `foo: f64`.
                Type(PatType),
                /// Tokens in pattern position not interpreted by Syn.
                Verbatim(TokenStream),
                /// A pattern that matches any value: `_`.
                Wild(PatWild),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct!
        {
            /// A pattern that binds a new variable: `ref mut binding @ SUBPATTERN`.
            pub struct PatIdent {
                pub attrs: Vec<Attribute>,
                pub by_ref: Option<Token![ref]>,
                pub mutability: Option<Token![mut]>,
                pub ident: Ident,
                pub subpat: Option<(Token![@], Box<Pat>)>,
            }
        }

        ast_struct! 
        {
            /// A pattern that matches any one of a set of cases.
            pub struct PatOr {
                pub attrs: Vec<Attribute>,
                pub leading_vert: Option<Token![|]>,
                pub cases: Punctuated<Pat, Token![|]>,
            }
        }

        ast_struct! 
        {
            /// A parenthesized pattern: `(A | B)`.
            pub struct PatParen {
                pub attrs: Vec<Attribute>,
                pub paren_token: token::Paren,
                pub pat: Box<Pat>,
            }
        }

        ast_struct! 
        {
            /// A reference pattern: `&mut var`.
            pub struct PatReference {
                pub attrs: Vec<Attribute>,
                pub and_token: Token![&],
                pub mutability: Option<Token![mut]>,
                pub pat: Box<Pat>,
            }
        }

        ast_struct! 
        {
            /// The dots in a tuple or slice pattern: `[0, 1, ..]`.
            pub struct PatRest {
                pub attrs: Vec<Attribute>,
                pub dot2_token: Token![..],
            }
        }

        ast_struct! 
        {
            /// A dynamically sized slice pattern: `[a, b, ref i @ .., y, z]`.
            pub struct PatSlice {
                pub attrs: Vec<Attribute>,
                pub bracket_token: token::Bracket,
                pub elems: Punctuated<Pat, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A struct or struct variant pattern: `Variant { x, y, .. }`.
            pub struct PatStruct {
                pub attrs: Vec<Attribute>,
                pub qself: Option<QSelf>,
                pub path: Path,
                pub brace_token: token::Brace,
                pub fields: Punctuated<FieldPat, Token![,]>,
                pub rest: Option<PatRest>,
            }
        }

        ast_struct! 
        {
            /// A tuple pattern: `(a, b)`.
            pub struct PatTuple {
                pub attrs: Vec<Attribute>,
                pub paren_token: token::Paren,
                pub elems: Punctuated<Pat, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A tuple struct or tuple variant pattern: `Variant(x, y, .., z)`.
            pub struct PatTupleStruct {
                pub attrs: Vec<Attribute>,
                pub qself: Option<QSelf>,
                pub path: Path,
                pub paren_token: token::Paren,
                pub elems: Punctuated<Pat, Token![,]>,
            }
        }

        ast_struct! 
        {
            /// A type ascription pattern: `foo: f64`.
            pub struct PatType {
                pub attrs: Vec<Attribute>,
                pub pat: Box<Pat>,
                pub colon_token: Token![:],
                pub ty: Box<Type>,
            }
        }

        ast_struct! 
        {
            /// A pattern that matches any value: `_`.
            pub struct PatWild {
                pub attrs: Vec<Attribute>,
                pub underscore_token: Token![_],
            }
        }

        ast_struct! 
        {
            /// A single field in a struct pattern.
            pub struct FieldPat {
                pub attrs: Vec<Attribute>,
                pub member: Member,
                pub colon_token: Option<Token![:]>,
                pub pat: Box<Pat>,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::TokenStream,
                syntax::
                {
                    attr::Attribute,
                    error::{self, Result},
                    expr::
                    {
                        Expr, ExprConst, ExprLit, ExprMacro, ExprPath, ExprRange, Member, RangeLimits,
                    },
                    ext::IdentExt as _,
                    ident::Ident,
                    lit::Lit,
                    mac::{self, Macro},
                    parse::{Parse, ParseBuffer, ParseStream},
                    pat::{
                        FieldPat, Pat, PatIdent, PatOr, PatParen, PatReference, PatRest, PatSlice, PatStruct,
                        PatTuple, PatTupleStruct, PatType, PatWild,
                    },
                    path::{self, Path, QSelf},
                    punctuated::Punctuated,
                    stmt::Block,
                    token,
                    verbatim,
                },
                *,
            };

            impl Pat {
                /// Parse a pattern that does _not_ involve `|` at the top level.
                ///
                /// This parser matches the behavior of the `$:pat_param` macro_rules
                /// matcher, and on editions prior to Rust 2021, the behavior of
                /// `$:pat`.
                ///
                /// In Rust syntax, some examples of where this syntax would occur are
                /// in the argument pattern of functions and closures. Patterns using
                /// `|` are not allowed to occur in these positions.
                ///
                /// ```compile_fail
                /// fn f(Some(_) | None: Option<T>) {
                ///     let _ = |Some(_) | None: Option<T>| {};
                ///    
                /// }
                /// ```
                ///
                /// ```console
                /// error: top-level or-patterns are not allowed in function parameters
                ///  --> src/main.rs:1:6
                ///   |
                /// 1 | fn f(Some(_) | None: Option<T>) {
                ///   |      ^^^^^^^^^^^^^^ help: wrap the pattern in parentheses: `(Some(_) | None)`
                /// ```
                pub fn parse_single(input: ParseStream) -> Result<Self> {
                    let begin = input.fork();
                    let lookahead = input.lookahead1();
                    if lookahead.peek(Ident)
                        && (input.peek2(Token![::])
                            || input.peek2(Token![!])
                            || input.peek2(token::Brace)
                            || input.peek2(token::Paren)
                            || input.peek2(Token![..]))
                        || input.peek(Token![self]) && input.peek2(Token![::])
                        || lookahead.peek(Token![::])
                        || lookahead.peek(Token![<])
                        || input.peek(Token![Self])
                        || input.peek(Token![super])
                        || input.peek(Token![crate])
                    {
                        pat_path_or_macro_or_struct_or_range(input)
                    } else if lookahead.peek(Token![_]) {
                        input.call(pat_wild).map(Pat::Wild)
                    } else if input.peek(Token![box]) {
                        pat_box(begin, input)
                    } else if input.peek(Token![-]) || lookahead.peek(Lit) || lookahead.peek(Token![const])
                    {
                        pat_lit_or_range(input)
                    } else if lookahead.peek(Token![ref])
                        || lookahead.peek(Token![mut])
                        || input.peek(Token![self])
                        || input.peek(Ident)
                    {
                        input.call(pat_ident).map(Pat::Ident)
                    } else if lookahead.peek(Token![&]) {
                        input.call(pat_reference).map(Pat::Reference)
                    } else if lookahead.peek(token::Paren) {
                        input.call(pat_paren_or_tuple)
                    } else if lookahead.peek(token::Bracket) {
                        input.call(pat_slice).map(Pat::Slice)
                    } else if lookahead.peek(Token![..]) && !input.peek(Token![...]) {
                        pat_range_half_open(input)
                    } else if lookahead.peek(Token![const]) {
                        input.call(pat_const).map(Pat::Verbatim)
                    } else {
                        Err(lookahead.error())
                    }
                }

                /// Parse a pattern, possibly involving `|`, but not a leading `|`.
                pub fn parse_multi(input: ParseStream) -> Result<Self> {
                    multi_pat_impl(input, None)
                }

                /// Parse a pattern, possibly involving `|`, possibly including a
                /// leading `|`.
                ///
                /// This parser matches the behavior of the Rust 2021 edition's `$:pat`
                /// macro_rules matcher.
                ///
                /// In Rust syntax, an example of where this syntax would occur is in
                /// the pattern of a `match` arm, where the language permits an optional
                /// leading `|`, although it is not idiomatic to write one there in
                /// handwritten code.
                ///
                /// ```
                /// # let wat = None;
                /// match wat {
                ///     | None | Some(false) => {}
                ///     | Some(true) => {}
                /// }
                /// ```
                ///
                /// The compiler accepts it only to facilitate some situations in
                /// macro-generated code where a macro author might need to write:
                ///
                /// ```
                /// # macro_rules! doc {
                /// #     ($value:expr, ($($conditions1:pat),*), ($($conditions2:pat),*), $then:expr) => {
                /// match $value {
                ///     $(| $conditions1)* $(| $conditions2)* => $then
                /// }
                /// #     };
                /// # }
                /// #
                /// # doc!(true, (true), (false), {});
                /// # doc!(true, (), (true, false), {});
                /// # doc!(true, (true, false), (), {});
                /// ```
                ///
                /// Expressing the same thing correctly in the case that either one (but
                /// not both) of `$conditions1` and `$conditions2` might be empty,
                /// without leading `|`, is complex.
                ///
                /// Use [`Pat::parse_multi`] instead if you are not intending to support
                /// macro-generated macro input.
                pub fn parse_multi_with_leading_vert(input: ParseStream) -> Result<Self> {
                    let leading_vert: Option<Token![|]> = input.parse()?;
                    multi_pat_impl(input, leading_vert)
                }
            }

            impl Parse for PatType
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (PatType {
                        attrs: Vec::new(),
                        pat: Box::new(Pat::parse_single(input)?),
                        colon_token: input.parse()?,
                        ty: input.parse()?,
                    })
                }
            }

            fn multi_pat_impl(input: ParseStream, leading_vert: Option<Token![|]>) -> Result<Pat>
            {
                let mut pat = Pat::parse_single(input)?;
                if leading_vert.is_some()
                    || input.peek(Token![|]) && !input.peek(Token![||]) && !input.peek(Token![|=])
                {
                    let mut cases = Punctuated::new();
                    cases.push_value(pat);
                    while input.peek(Token![|]) && !input.peek(Token![||]) && !input.peek(Token![|=]) {
                        let punct = input.parse()?;
                        cases.push_punct(punct);
                        let pat = Pat::parse_single(input)?;
                        cases.push_value(pat);
                    }
                    pat = Pat::Or(PatOr {
                        attrs: Vec::new(),
                        leading_vert,
                        cases,
                    });
                }
                Ok(pat)
            }

            fn pat_path_or_macro_or_struct_or_range(input: ParseStream) -> Result<Pat>
            {
                let expr_style = true;
                let (qself, path) = path::parsing::qpath(input, expr_style)?;

                if qself.is_none()
                    && input.peek(Token![!])
                    && !input.peek(Token![!=])
                    && path.is_mod_style()
                {
                    let bang_token: Token![!] = input.parse()?;
                    let (delimiter, tokens) = mac::parse_delimiter(input)?;
                    return Ok(Pat::Macro(ExprMacro {
                        attrs: Vec::new(),
                        mac: Macro {
                            path,
                            bang_token,
                            delimiter,
                            tokens,
                        },
                    }));
                }

                if input.peek(token::Brace) {
                    pat_struct(input, qself, path).map(Pat::Struct)
                } else if input.peek(token::Paren) {
                    pat_tuple_struct(input, qself, path).map(Pat::TupleStruct)
                } else if input.peek(Token![..]) {
                    pat_range(input, qself, path)
                } else {
                    Ok(Pat::Path(ExprPath {
                        attrs: Vec::new(),
                        qself,
                        path,
                    }))
                }
            }

            fn pat_wild(input: ParseStream) -> Result<PatWild>
            {
                Ok
                (PatWild {
                    attrs: Vec::new(),
                    underscore_token: input.parse()?,
                })
            }

            fn pat_box(begin: ParseBuffer, input: ParseStream) -> Result<Pat> {
                input.parse::<Token![box]>()?;
                Pat::parse_single(input)?;
                Ok(Pat::Verbatim(verbatim::between(&begin, input)))
            }

            fn pat_ident(input: ParseStream) -> Result<PatIdent>
            {
                Ok
                (PatIdent {
                    attrs: Vec::new(),
                    by_ref: input.parse()?,
                    mutability: input.parse()?,
                    ident: {
                        if input.peek(Token![self]) {
                            input.call(Ident::parse_any)?
                        } else {
                            input.parse()?
                        }
                    },
                    subpat: {
                        if input.peek(Token![@]) {
                            let at_token: Token![@] = input.parse()?;
                            let subpat = Pat::parse_single(input)?;
                            Some((at_token, Box::new(subpat)))
                        } else {
                            None
                        }
                    },
                })
            }

            fn pat_tuple_struct(
                input: ParseStream,
                qself: Option<QSelf>,
                path: Path,
            ) -> Result<PatTupleStruct>
            {
                let content;
                let paren_token = parenthesized!(content in input);

                let mut elems = Punctuated::new();
                while !content.is_empty() {
                    let value = Pat::parse_multi_with_leading_vert(&content)?;
                    elems.push_value(value);
                    if content.is_empty() {
                        break;
                    }
                    let punct = content.parse()?;
                    elems.push_punct(punct);
                }

                Ok(PatTupleStruct {
                    attrs: Vec::new(),
                    qself,
                    path,
                    paren_token,
                    elems,
                })
            }

            fn pat_struct(input: ParseStream, qself: Option<QSelf>, path: Path) -> Result<PatStruct>
            {
                let content;
                let brace_token = braced!(content in input);

                let mut fields = Punctuated::new();
                let mut rest = None;
                while !content.is_empty() {
                    let attrs = content.call(Attribute::parse_outer)?;
                    if content.peek(Token![..]) {
                        rest = Some(PatRest {
                            attrs,
                            dot2_token: content.parse()?,
                        });
                        break;
                    }
                    let mut value = content.call(field_pat)?;
                    value.attrs = attrs;
                    fields.push_value(value);
                    if content.is_empty() {
                        break;
                    }
                    let punct: Token![,] = content.parse()?;
                    fields.push_punct(punct);
                }

                Ok(PatStruct {
                    attrs: Vec::new(),
                    qself,
                    path,
                    brace_token,
                    fields,
                    rest,
                })
            }

            fn field_pat(input: ParseStream) -> Result<FieldPat>
            {
                let begin = input.fork();
                let boxed: Option<Token![box]> = input.parse()?;
                let by_ref: Option<Token![ref]> = input.parse()?;
                let mutability: Option<Token![mut]> = input.parse()?;

                let member = if boxed.is_some() || by_ref.is_some() || mutability.is_some() {
                    input.parse().map(Member::Named)
                } else {
                    input.parse()
                }?;

                if boxed.is_none() && by_ref.is_none() && mutability.is_none() && input.peek(Token![:])
                    || !member.is_named()
                {
                    return Ok(FieldPat {
                        attrs: Vec::new(),
                        member,
                        colon_token: Some(input.parse()?),
                        pat: Box::new(Pat::parse_multi_with_leading_vert(input)?),
                    });
                }

                let ident = match member {
                    Member::Named(ident) => ident,
                    Member::Unnamed(_) => unreachable!(),
                };

                let pat = if boxed.is_some() {
                    Pat::Verbatim(verbatim::between(&begin, input))
                } else {
                    Pat::Ident(PatIdent {
                        attrs: Vec::new(),
                        by_ref,
                        mutability,
                        ident: ident.clone(),
                        subpat: None,
                    })
                };

                Ok(FieldPat {
                    attrs: Vec::new(),
                    member: Member::Named(ident),
                    colon_token: None,
                    pat: Box::new(pat),
                })
            }

            fn pat_range(input: ParseStream, qself: Option<QSelf>, path: Path) -> Result<Pat>
            {
                let limits = RangeLimits::parse_obsolete(input)?;
                let end = input.call(pat_range_bound)?;
                if let (RangeLimits::Closed(_), None) = (&limits, &end) {
                    return Err(input.error("expected range upper bound"));
                }
                Ok(Pat::Range(ExprRange {
                    attrs: Vec::new(),
                    start: Some(Box::new(Expr::Path(ExprPath {
                        attrs: Vec::new(),
                        qself,
                        path,
                    }))),
                    limits,
                    end: end.map(PatRangeBound::into_expr),
                }))
            }

            fn pat_range_half_open(input: ParseStream) -> Result<Pat>
            {
                let limits: RangeLimits = input.parse()?;
                let end = input.call(pat_range_bound)?;
                if end.is_some() {
                    Ok(Pat::Range(ExprRange {
                        attrs: Vec::new(),
                        start: None,
                        limits,
                        end: end.map(PatRangeBound::into_expr),
                    }))
                } else {
                    match limits {
                        RangeLimits::HalfOpen(dot2_token) => Ok(Pat::Rest(PatRest {
                            attrs: Vec::new(),
                            dot2_token,
                        })),
                        RangeLimits::Closed(_) => Err(input.error("expected range upper bound")),
                    }
                }
            }

            fn pat_paren_or_tuple(input: ParseStream) -> Result<Pat>
            {
                let content;
                let paren_token = parenthesized!(content in input);

                let mut elems = Punctuated::new();
                while !content.is_empty() {
                    let value = Pat::parse_multi_with_leading_vert(&content)?;
                    if content.is_empty() {
                        if elems.is_empty() && !matches!(value, Pat::Rest(_)) {
                            return Ok(Pat::Paren(PatParen {
                                attrs: Vec::new(),
                                paren_token,
                                pat: Box::new(value),
                            }));
                        }
                        elems.push_value(value);
                        break;
                    }
                    elems.push_value(value);
                    let punct = content.parse()?;
                    elems.push_punct(punct);
                }

                Ok(Pat::Tuple(PatTuple {
                    attrs: Vec::new(),
                    paren_token,
                    elems,
                }))
            }

            fn pat_reference(input: ParseStream) -> Result<PatReference>
            {
                Ok
                (PatReference {
                    attrs: Vec::new(),
                    and_token: input.parse()?,
                    mutability: input.parse()?,
                    pat: Box::new(Pat::parse_single(input)?),
                })
            }

            fn pat_lit_or_range(input: ParseStream) -> Result<Pat>
            {
                let start = input.call(pat_range_bound)?.unwrap();
                if input.peek(Token![..]) {
                    let limits = RangeLimits::parse_obsolete(input)?;
                    let end = input.call(pat_range_bound)?;
                    if let (RangeLimits::Closed(_), None) = (&limits, &end) {
                        return Err(input.error("expected range upper bound"));
                    }
                    Ok(Pat::Range(ExprRange {
                        attrs: Vec::new(),
                        start: Some(start.into_expr()),
                        limits,
                        end: end.map(PatRangeBound::into_expr),
                    }))
                } else {
                    Ok(start.into_pat())
                }
            }

           
            enum PatRangeBound {
                Const(ExprConst),
                Lit(ExprLit),
                Path(ExprPath),
            }

            impl PatRangeBound {
                fn into_expr(self) -> Box<Expr> {
                    Box::new(match self {
                        PatRangeBound::Const(pat) => Expr::Const(pat),
                        PatRangeBound::Lit(pat) => Expr::Lit(pat),
                        PatRangeBound::Path(pat) => Expr::Path(pat),
                    })
                }

                fn into_pat(self) -> Pat {
                    match self {
                        PatRangeBound::Const(pat) => Pat::Const(pat),
                        PatRangeBound::Lit(pat) => Pat::Lit(pat),
                        PatRangeBound::Path(pat) => Pat::Path(pat),
                    }
                }
            }

            fn pat_range_bound(input: ParseStream) -> Result<Option<PatRangeBound>> {
                if input.is_empty()
                    || input.peek(Token![|])
                    || input.peek(Token![=])
                    || input.peek(Token![:]) && !input.peek(Token![::])
                    || input.peek(Token![,])
                    || input.peek(Token![;])
                    || input.peek(Token![if])
                {
                    return Ok(None);
                }

                let lookahead = input.lookahead1();
                let expr = if lookahead.peek(Lit) {
                    PatRangeBound::Lit(input.parse()?)
                } else if lookahead.peek(Ident)
                    || lookahead.peek(Token![::])
                    || lookahead.peek(Token![<])
                    || lookahead.peek(Token![self])
                    || lookahead.peek(Token![Self])
                    || lookahead.peek(Token![super])
                    || lookahead.peek(Token![crate])
                {
                    PatRangeBound::Path(input.parse()?)
                } else if lookahead.peek(Token![const]) {
                    PatRangeBound::Const(input.parse()?)
                } else {
                    return Err(lookahead.error());
                };

                Ok(Some(expr))
            }

            fn pat_slice(input: ParseStream) -> Result<PatSlice>
            {
                let content;
                let bracket_token = bracketed!(content in input);

                let mut elems = Punctuated::new();
                while !content.is_empty() {
                    let value = Pat::parse_multi_with_leading_vert(&content)?;
                    match value {
                        Pat::Range(pat) if pat.start.is_none() || pat.end.is_none() => {
                            let (start, end) = match pat.limits {
                                RangeLimits::HalfOpen(dot_dot) => (dot_dot.spans[0], dot_dot.spans[1]),
                                RangeLimits::Closed(dot_dot_eq) => {
                                    (dot_dot_eq.spans[0], dot_dot_eq.spans[2])
                                }
                            };
                            let msg = "range pattern is not allowed unparenthesized inside slice pattern";
                            return Err(error::new2(start, end, msg));
                        }
                        _ => {}
                    }
                    elems.push_value(value);
                    if content.is_empty() {
                        break;
                    }
                    let punct = content.parse()?;
                    elems.push_punct(punct);
                }

                Ok(PatSlice {
                    attrs: Vec::new(),
                    bracket_token,
                    elems,
                })
            }

            fn pat_const(input: ParseStream) -> Result<TokenStream>
            {
                let begin = input.fork();
                input.parse::<Token![const]>()?;

                let content;
                braced!(content in input);
                content.call(Attribute::parse_inner)?;
                content.call(Block::parse_within)?;

                Ok(verbatim::between(&begin, input))
            }
        }

        mod printing
        {
            use ::
            {
                process::macros::{ TokenStream },
                quote::{ ToTokens, TokenStreamExt },
                syntax::
                {
                    attr::{ FilterAttrs },
                    pat::
                    {
                        FieldPat, Pat, PatIdent, PatOr, PatParen, PatReference, PatRest, PatSlice, PatStruct,
                        PatTuple, PatTupleStruct, PatType, PatWild,
                    },
                    path::{ self, printing::{ PathStyle }, },
                },
                *,
            };
            /*
            */
            impl ToTokens for PatIdent 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.by_ref.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.ident.to_tokens(tokens);
                    if let Some((at_token, subpat)) = &self.subpat {
                        at_token.to_tokens(tokens);
                        subpat.to_tokens(tokens);
                    }
                }
            }

            impl ToTokens for PatOr 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.leading_vert.to_tokens(tokens);
                    self.cases.to_tokens(tokens);
                }
            }

            impl ToTokens for PatParen 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.paren_token.surround(tokens, |tokens| {
                        self.pat.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for PatReference 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.and_token.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.pat.to_tokens(tokens);
                }
            }

            impl ToTokens for PatRest 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.dot2_token.to_tokens(tokens);
                }
            }

            impl ToTokens for PatSlice 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.bracket_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for PatStruct 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::Expr);
                    self.brace_token.surround(tokens, |tokens| {
                        self.fields.to_tokens(tokens);
                       
                        if !self.fields.empty_or_trailing() && self.rest.is_some() {
                            <Token![,]>::default().to_tokens(tokens);
                        }
                        self.rest.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for PatTuple 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.paren_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                       
                       
                       
                        if self.elems.len() == 1
                            && !self.elems.trailing_punct()
                            && !matches!(self.elems[0], Pat::Rest { .. })
                        {
                            <Token![,]>::default().to_tokens(tokens);
                        }
                    });
                }
            }

            impl ToTokens for PatTupleStruct 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::Expr);
                    self.paren_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for PatType 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.pat.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                }
            }

            impl ToTokens for PatWild 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    self.underscore_token.to_tokens(tokens);
                }
            }

            impl ToTokens for FieldPat 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some(colon_token) = &self.colon_token {
                        self.member.to_tokens(tokens);
                        colon_token.to_tokens(tokens);
                    }
                    self.pat.to_tokens(tokens);
                }
            }
        }
    } pub use self::pat::
    {
        FieldPat, Pat, PatConst, PatIdent, PatLit, PatMacro, PatOr, PatParen, PatPath, PatRange,
        PatReference, PatRest, PatSlice, PatStruct, PatTuple, PatTupleStruct, PatType, PatWild,
    }; 
    
    pub mod path
    {
        use ::
        {
            syntax::
            {
                error::Result,
                expr::Expr,
                generics::TypeParamBound,
                ident::Ident,
                lifetime::Lifetime,
                punctuated::Punctuated,
                token,
                ty::{ReturnType, Type},
            },
            *,
        };
        /*
        */
        ast_struct! 
        {
            /// A path at which a named item is exported (e.g. `std::collections::HashMap`).
            pub struct Path {
                pub leading_colon: Option<Token![::]>,
                pub segments: Punctuated<PathSegment, Token![::]>,
            }
        }

        impl<T> From<T> for Path where
        T: Into<PathSegment>
        {
            fn from(segment: T) -> Self {
                let mut path = Path {
                    leading_colon: None,
                    segments: Punctuated::new(),
                };
                path.segments.push_value(segment.into());
                path
            }
        }

        impl Path 
        {
            /// Determines whether this is a path of length 1 equal to the given
            /// ident.
            /// - the first path segment has no angle bracketed or parenthesized
            ///   path arguments, and
            /// - the ident of the first path segment is equal to the given one.
            /// use syn::{Attribute, Error, Meta, Result};
            ///
            /// fn get_serde_meta_item(attr: &Attribute) -> Result<Option<&TokenStream>> {
            ///     if attr.path().is_ident("serde") {
            ///         match &attr.meta {
            ///             Meta::List(meta) => Ok(Some(&meta.tokens)),
            ///             bad => Err(Error::new_spanned(bad, "unrecognized attribute")),
            ///         }
            ///     } else {
            ///         Ok(None)
            ///     }
            /// }
            /// ```
            pub fn is_ident<I>(&self, ident: &I) -> bool
            where
                I: ?Sized,
                Ident: PartialEq<I>,
            {
                match self.get_ident() {
                    Some(id) => id == ident,
                    None => false,
                }
            }
            /// If this path consists of a single ident, returns the ident.
            /// - the first path segment has no angle bracketed or parenthesized
            ///   path arguments.
            pub fn get_ident(&self) -> Option<&Ident> {
                if self.leading_colon.is_none()
                    && self.segments.len() == 1
                    && self.segments[0].arguments.is_none()
                {
                    Some(&self.segments[0].ident)
                } else {
                    None
                }
            }
            /// An error if this path is not a single ident, as defined in `get_ident`.
             
                pub fn require_ident(&self) -> Result<&Ident>
            {
                self.get_ident().ok_or_else(|| {
                    ::syntax::error::new2(
                        self.segments.first().unwrap().ident.span(),
                        self.segments.last().unwrap().ident.span(),
                        "expected this path to be an identifier",
                    )
                })
            }
        }

        ast_struct! 
        {
            /// A segment of a path together with any path arguments on that segment.
            pub struct PathSegment {
                pub ident: Ident,
                pub arguments: PathArguments,
            }
        }

        impl<T> From<T> for PathSegment where
        T: Into<Ident>,
        {
            fn from(ident: T) -> Self {
                PathSegment {
                    ident: ident.into(),
                    arguments: PathArguments::None,
                }
            }
        }

        ast_enum! 
        {
            /// Angle bracketed or parenthesized arguments of a path segment.
            ///
            /// ## Parenthesized
            ///
            /// The `(A, B) -> C` in `Fn(A, B) -> C`.
            pub enum PathArguments {
                None,
                /// The `<'a, T>` in `std::slice::iter<'a, T>`.
                AngleBracketed(AngleBracketedGenericArguments),
                /// The `(A, B) -> C` in `Fn(A, B) -> C`.
                Parenthesized(ParenthesizedGenericArguments),
            }
        }

        impl Default for PathArguments 
        {
            fn default() -> Self {
                PathArguments::None
            }
        }

        impl PathArguments 
        {
            pub fn is_empty(&self) -> bool
        {
                match self {
                    PathArguments::None => true,
                    PathArguments::AngleBracketed(bracketed) => bracketed.args.is_empty(),
                    PathArguments::Parenthesized(_) => false,
                }
            }

            pub fn is_none(&self) -> bool
        {
                match self {
                    PathArguments::None => true,
                    PathArguments::AngleBracketed(_) | PathArguments::Parenthesized(_) => false,
                }
            }
        }

        ast_enum! 
        {
            /// An individual generic argument, like `'a`, `T`, or `Item = T`.
            #[non_exhaustive]
            pub enum GenericArgument {
                /// A lifetime argument.
                Lifetime(Lifetime),
                /// A type argument.
                Type(Type),
                /// A const expression. Must be inside of a block.
                ///
                /// NOTE: Identity expressions are represented as Type arguments, as
                /// they are indistinguishable syntactically.
                Const(Expr),
                /// A binding (equality constraint) on an associated type: the `Item =
                /// u8` in `Iterator<Item = u8>`.
                AssocType(AssocType),
                /// An equality constraint on an associated constant: the `PANIC =
                /// false` in `Trait<PANIC = false>`.
                AssocConst(AssocConst),
                /// An associated type bound: `Iterator<Item: Display>`.
                Constraint(Constraint),
            }
        }

        ast_struct! 
        {
            /// Angle bracketed arguments of a path segment: the `<K, V>` in `HashMap<K,
            /// V>`.
            pub struct AngleBracketedGenericArguments {
                pub colon2_token: Option<Token![::]>,
                pub lt_token: Token![<],
                pub args: Punctuated<GenericArgument, Token![,]>,
                pub gt_token: Token![>],
            }
        }

        ast_struct! 
        {
            /// A binding (equality constraint) on an associated type: the `Item = u8`
            /// in `Iterator<Item = u8>`.
            pub struct AssocType {
                pub ident: Ident,
                pub generics: Option<AngleBracketedGenericArguments>,
                pub eq_token: Token![=],
                pub ty: Type,
            }
        }

        ast_struct! 
        {
            /// An equality constraint on an associated constant: the `PANIC = false` in
            /// `Trait<PANIC = false>`.
            pub struct AssocConst {
                pub ident: Ident,
                pub generics: Option<AngleBracketedGenericArguments>,
                pub eq_token: Token![=],
                pub value: Expr,
            }
        }

        ast_struct! 
        {
            /// An associated type bound: `Iterator<Item: Display>`.
            pub struct Constraint {
                pub ident: Ident,
                pub generics: Option<AngleBracketedGenericArguments>,
                pub colon_token: Token![:],
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
            }
        }

        ast_struct! 
        {
            /// Arguments of a function path segment: the `(A, B) -> C` in `Fn(A,B) ->
            /// C`.
            pub struct ParenthesizedGenericArguments {
                pub paren_token: token::Paren,
                /// `(A, B)`
                pub inputs: Punctuated<Type, Token![,]>,
                /// `C`
                pub output: ReturnType,
            }
        }

        ast_struct! 
        {
            /// The explicit Self type in a qualified path: the `T` in `<T as
            /// Display>::fmt`.
            /// item qualified with this Self type.
            ///  ^~~~~~    ~~~~~~~~~~~~~~^
            ///  ty        position = 3
            ///
            /// <Vec<T>>::AssociatedItem
            ///  ^~~~~~   ^
            ///  ty       position = 0
            /// ```
            pub struct QSelf {
                pub lt_token: Token![<],
                pub ty: Box<Type>,
                pub position: usize,
                pub as_token: Option<Token![as]>,
                pub gt_token: Token![>],
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                syntax::
                {
                    error::Result,
                    expr::ExprBlock,
                    expr::{Expr, ExprPath},
                    ext::IdentExt as _,
                    generics::TypeParamBound,
                    ident::Ident,
                    lifetime::Lifetime,
                    lit::Lit,
                    parse::{Parse, ParseStream},
                    path::
                    {
                        AngleBracketedGenericArguments, AssocConst, AssocType, Constraint, GenericArgument, 
                        ParenthesizedGenericArguments, Path, PathArguments, PathSegment, QSelf,
                    },
                    punctuated::Punctuated,
                    token,
                    ty::{ReturnType, Type},
                },
                *,
            };

            impl Parse for Path
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    Self::parse_helper(input, false)
                }
            }

            impl Parse for GenericArgument
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Lifetime) && !input.peek2(Token![+]) {
                        return Ok(GenericArgument::Lifetime(input.parse()?));
                    }

                    if input.peek(Lit) || input.peek(token::Brace) {
                        return const_argument(input).map(GenericArgument::Const);
                    }

                    let mut argument: Type = input.parse()?;

                    match argument {
                        Type::Path(mut ty)
                            if ty.qself.is_none()
                                && ty.path.leading_colon.is_none()
                                && ty.path.segments.len() == 1
                                && match &ty.path.segments[0].arguments {
                                    PathArguments::None | PathArguments::AngleBracketed(_) => true,
                                    PathArguments::Parenthesized(_) => false,
                                } =>
                        {
                            if let Some(eq_token) = input.parse::<Option<Token![=]>>()? {
                                let segment = ty.path.segments.pop().unwrap().into_value();
                                let ident = segment.ident;
                                let generics = match segment.arguments {
                                    PathArguments::None => None,
                                    PathArguments::AngleBracketed(arguments) => Some(arguments),
                                    PathArguments::Parenthesized(_) => unreachable!(),
                                };
                                return if input.peek(Lit) || input.peek(token::Brace) {
                                    Ok(GenericArgument::AssocConst(AssocConst {
                                        ident,
                                        generics,
                                        eq_token,
                                        value: const_argument(input)?,
                                    }))
                                } else {
                                    Ok(GenericArgument::AssocType(AssocType {
                                        ident,
                                        generics,
                                        eq_token,
                                        ty: input.parse()?,
                                    }))
                                };
                            }

                                                if let Some(colon_token) = input.parse::<Option<Token![:]>>()? {
                                let segment = ty.path.segments.pop().unwrap().into_value();
                                return Ok(GenericArgument::Constraint(Constraint {
                                    ident: segment.ident,
                                    generics: match segment.arguments {
                                        PathArguments::None => None,
                                        PathArguments::AngleBracketed(arguments) => Some(arguments),
                                        PathArguments::Parenthesized(_) => unreachable!(),
                                    },
                                    colon_token,
                                    bounds: {
                                        let mut bounds = Punctuated::new();
                                        loop {
                                            if input.peek(Token![,]) || input.peek(Token![>]) {
                                                break;
                                            }
                                            bounds.push_value({
                                                let allow_precise_capture = false;
                                                let allow_const = true;
                                                TypeParamBound::parse_single(
                                                    input,
                                                    allow_precise_capture,
                                                    allow_const,
                                                )?
                                            });
                                            if !input.peek(Token![+]) {
                                                break;
                                            }
                                            let punct: Token![+] = input.parse()?;
                                            bounds.push_punct(punct);
                                        }
                                        bounds
                                    },
                                }));
                            }

                            argument = Type::Path(ty);
                        }
                        _ => {}
                    }

                    Ok(GenericArgument::Type(argument))
                }
            }

            pub fn const_argument(input: ParseStream) -> Result<Expr>
            {
                let lookahead = input.lookahead1();

                if input.peek(Lit) {
                    let lit = input.parse()?;
                    return Ok(Expr::Lit(lit));
                }

                if input.peek(Ident) {
                    let ident: Ident = input.parse()?;
                    return Ok(Expr::Path(ExprPath {
                        attrs: Vec::new(),
                        qself: None,
                        path: Path::from(ident),
                    }));
                }

                if input.peek(token::Brace)
                {
                    let block: ExprBlock = input.parse()?;
                    return Ok(Expr::Block(block));
                }

                Err(lookahead.error())
            }

            impl AngleBracketedGenericArguments {
                /// Parse `::<>` with mandatory leading `::`.
                ///
                /// The ordinary [`Parse`] impl for `AngleBracketedGenericArguments`
                /// parses optional leading `::`.
                        #[cfg_attr(docsrs, doc(cfg(all(feature = "parsing", feature = "full"))))]
                pub fn parse_turbofish(input: ParseStream) -> Result<Self> {
                    let colon2_token: Token![::] = input.parse()?;
                    Self::do_parse(Some(colon2_token), input)
                }

                pub fn do_parse(
                    colon2_token: Option<Token![::]>,
                    input: ParseStream,
                ) -> Result<Self>
                {
                    Ok
                    (AngleBracketedGenericArguments {
                        colon2_token,
                        lt_token: input.parse()?,
                        args: {
                            let mut args = Punctuated::new();
                            loop {
                                if input.peek(Token![>]) {
                                    break;
                                }
                                let value: GenericArgument = input.parse()?;
                                args.push_value(value);
                                if input.peek(Token![>]) {
                                    break;
                                }
                                let punct: Token![,] = input.parse()?;
                                args.push_punct(punct);
                            }
                            args
                        },
                        gt_token: input.parse()?,
                    })
                }
            }

            impl Parse for AngleBracketedGenericArguments
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let colon2_token: Option<Token![::]> = input.parse()?;
                    Self::do_parse(colon2_token, input)
                }
            }

            impl Parse for ParenthesizedGenericArguments
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(ParenthesizedGenericArguments {
                        paren_token: parenthesized!(content in input),
                        inputs: content.parse_terminated(Type::parse, Token![,])?,
                        output: input.call(ReturnType::without_plus)?,
                    })
                }
            }

            impl Parse for PathSegment
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    Self::parse_helper(input, false)
                }
            }

            impl PathSegment
            {
                fn parse_helper(input: ParseStream, expr_style: bool) -> Result<Self>
                {
                    if input.peek(Token![super])
                        || input.peek(Token![self])
                        || input.peek(Token![crate])
                        || cfg!(feature = "full") && input.peek(Token![try])
                    {
                        let ident = input.call(Ident::parse_any)?;
                        return Ok(PathSegment::from(ident));
                    }

                    let ident = if input.peek(Token![Self]) {
                        input.call(Ident::parse_any)?
                    } else {
                        input.parse()?
                    };

                    if !expr_style
                        && input.peek(Token![<])
                        && !input.peek(Token![<=])
                        && !input.peek(Token![<<=])
                        || input.peek(Token![::]) && input.peek3(Token![<])
                    {
                        Ok(PathSegment {
                            ident,
                            arguments: PathArguments::AngleBracketed(input.parse()?),
                        })
                    } else {
                        Ok(PathSegment::from(ident))
                    }
                }
            }

            impl Path {
                /// Parse a `Path` containing no path arguments on any of its segments.
                ///
                /// # Example
                ///
                /// ```
                /// use syn::{Path, Result, Token};
                /// use syn::parse::{Parse, ParseStream};
                ///
                ///
                /// //
                ///
                /// //
                ///
                ///
                /// //
                ///
                /// struct SingleUse {
                ///     use_token: Token![use],
                ///     path: Path,
                /// }
                ///
                /// impl Parse for SingleUse {
                ///     fn parse(input: ParseStream) -> Result<Self> {
                ///         Ok(SingleUse {
                ///             use_token: input.parse()?,
                ///             path: input.call(Path::parse_mod_style)?,
                ///         })
                ///     }
                /// }
                /// ```
                    pub fn parse_mod_style(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (Path {
                        leading_colon: input.parse()?,
                        segments: {
                            let mut segments = Punctuated::new();
                            loop {
                                if !input.peek(Ident)
                                    && !input.peek(Token![super])
                                    && !input.peek(Token![self])
                                    && !input.peek(Token![Self])
                                    && !input.peek(Token![crate])
                                {
                                    break;
                                }
                                let ident = Ident::parse_any(input)?;
                                segments.push_value(PathSegment::from(ident));
                                if !input.peek(Token![::]) {
                                    break;
                                }
                                let punct = input.parse()?;
                                segments.push_punct(punct);
                            }
                            if segments.is_empty() {
                                return Err(input.parse::<Ident>().unwrap_err());
                            } else if segments.trailing_punct() {
                                return Err(input.error("expected path segment after `::`"));
                            }
                            segments
                        },
                    })
                }

                pub fn parse_helper(input: ParseStream, expr_style: bool) -> Result<Self> {
                    let mut path = Path {
                        leading_colon: input.parse()?,
                        segments: {
                            let mut segments = Punctuated::new();
                            let value = PathSegment::parse_helper(input, expr_style)?;
                            segments.push_value(value);
                            segments
                        },
                    };
                    Path::parse_rest(input, &mut path, expr_style)?;
                    Ok(path)
                }

                pub fn parse_rest(
                    input: ParseStream,
                    path: &mut Self,
                    expr_style: bool,
                ) -> Result<()> {
                    while input.peek(Token![::]) && !input.peek3(token::Paren) {
                        let punct: Token![::] = input.parse()?;
                        path.segments.push_punct(punct);
                        let value = PathSegment::parse_helper(input, expr_style)?;
                        path.segments.push_value(value);
                    }
                    Ok(())
                }

                pub fn is_mod_style(&self) -> bool
        {
                    self.segments
                        .iter()
                        .all(|segment| segment.arguments.is_none())
                }
            }

            pub fn qpath(input: ParseStream, expr_style: bool) -> Result<(Option<QSelf>, Path)> {
                if input.peek(Token![<]) {
                    let lt_token: Token![<] = input.parse()?;
                    let this: Type = input.parse()?;
                    let path = if input.peek(Token![as]) {
                        let as_token: Token![as] = input.parse()?;
                        let path: Path = input.parse()?;
                        Some((as_token, path))
                    } else {
                        None
                    };
                    let gt_token: Token![>] = input.parse()?;
                    let colon2_token: Token![::] = input.parse()?;
                    let mut rest = Punctuated::new();
                    loop {
                        let path = PathSegment::parse_helper(input, expr_style)?;
                        rest.push_value(path);
                        if !input.peek(Token![::]) {
                            break;
                        }
                        let punct: Token![::] = input.parse()?;
                        rest.push_punct(punct);
                    }
                    let (position, as_token, path) = match path {
                        Some((as_token, mut path)) => {
                            let pos = path.segments.len();
                            path.segments.push_punct(colon2_token);
                            path.segments.extend(rest.into_pairs());
                            (pos, Some(as_token), path)
                        }
                        None => {
                            let path = Path {
                                leading_colon: Some(colon2_token),
                                segments: rest,
                            };
                            (0, None, path)
                        }
                    };
                    let qself = QSelf {
                        lt_token,
                        ty: Box::new(this),
                        position,
                        as_token,
                        gt_token,
                    };
                    Ok((Some(qself), path))
                } else {
                    let path = Path::parse_helper(input, expr_style)?;
                    Ok((None, path))
                }
            }
        }

        pub mod printing
        {
            use ::
            {
                process::macros::{ Span, TokenStream },
                quote::ToTokens,
                syntax::
                {
                    generics,
                    print::TokensOrDefault,
                    spanned::Spanned,
                    path::
                    {
                        AngleBracketedGenericArguments, AssocConst, AssocType, Constraint, GenericArgument,
                        ParenthesizedGenericArguments, Path, PathArguments, PathSegment, QSelf,
                    }
                },
                *,
            };

            pub enum PathStyle {
                Expr,
                Mod,
                AsWritten,
            }

            impl Copy for PathStyle {}

            impl Clone for PathStyle {
                fn clone(&self) -> Self {
                    *self
                }
            }

            impl ToTokens for Path {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_path(tokens, self, PathStyle::AsWritten);
                }
            }

            pub fn print_path(tokens: &mut TokenStream, path: &Path, style: PathStyle) {
                path.leading_colon.to_tokens(tokens);
                for segment in path.segments.pairs() {
                    print_path_segment(tokens, segment.value(), style);
                    segment.punct().to_tokens(tokens);
                }
            }

            impl ToTokens for PathSegment {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_path_segment(tokens, self, PathStyle::AsWritten);
                }
            }

            fn print_path_segment(tokens: &mut TokenStream, segment: &PathSegment, style: PathStyle) {
                segment.ident.to_tokens(tokens);
                print_path_arguments(tokens, &segment.arguments, style);
            }

            impl ToTokens for PathArguments {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_path_arguments(tokens, self, PathStyle::AsWritten);
                }
            }

            fn print_path_arguments(tokens: &mut TokenStream, arguments: &PathArguments, style: PathStyle) {
                match arguments {
                    PathArguments::None => {}
                    PathArguments::AngleBracketed(arguments) => {
                        print_angle_bracketed_generic_arguments(tokens, arguments, style);
                    }
                    PathArguments::Parenthesized(arguments) => {
                        print_parenthesized_generic_arguments(tokens, arguments, style);
                    }
                }
            }

            impl ToTokens for GenericArgument {
                #[allow(clippy::match_same_arms)]
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        GenericArgument::Lifetime(lt) => lt.to_tokens(tokens),
                        GenericArgument::Type(ty) => ty.to_tokens(tokens),
                        GenericArgument::Const(expr) => {
                            generics::printing::print_const_argument(expr, tokens);
                        }
                        GenericArgument::AssocType(assoc) => assoc.to_tokens(tokens),
                        GenericArgument::AssocConst(assoc) => assoc.to_tokens(tokens),
                        GenericArgument::Constraint(constraint) => constraint.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for AngleBracketedGenericArguments {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_angle_bracketed_generic_arguments(tokens, self, PathStyle::AsWritten);
                }
            }

            pub fn print_angle_bracketed_generic_arguments(
                tokens: &mut TokenStream,
                arguments: &AngleBracketedGenericArguments,
                style: PathStyle,
            ) {
                if let PathStyle::Mod = style {
                    return;
                }

                conditionally_print_turbofish(tokens, &arguments.colon2_token, style);
                arguments.lt_token.to_tokens(tokens);

               
               
                let mut trailing_or_empty = true;
                for param in arguments.args.pairs( )
                {
                    match param.value() {
                        GenericArgument::Lifetime(_) => {
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                        GenericArgument::Type(_)
                        | GenericArgument::Const(_)
                        | GenericArgument::AssocType(_)
                        | GenericArgument::AssocConst(_)
                        | GenericArgument::Constraint(_) => {}
                    }
                }
                for param in arguments.args.pairs( )
                {
                    match param.value() {
                        GenericArgument::Type(_)
                        | GenericArgument::Const(_)
                        | GenericArgument::AssocType(_)
                        | GenericArgument::AssocConst(_)
                        | GenericArgument::Constraint(_) => {
                            if !trailing_or_empty {
                                <Token![,]>::default().to_tokens(tokens);
                            }
                            param.to_tokens(tokens);
                            trailing_or_empty = param.punct().is_some();
                        }
                        GenericArgument::Lifetime(_) => {}
                    }
                }

                arguments.gt_token.to_tokens(tokens);
            }

            impl ToTokens for AssocType {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    self.ty.to_tokens(tokens);
                }
            }

            impl ToTokens for AssocConst {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.eq_token.to_tokens(tokens);
                    generics::printing::print_const_argument(&self.value, tokens);
                }
            }

            impl ToTokens for Constraint {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.ident.to_tokens(tokens);
                    self.generics.to_tokens(tokens);
                    self.colon_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }

            impl ToTokens for ParenthesizedGenericArguments {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    print_parenthesized_generic_arguments(tokens, self, PathStyle::AsWritten);
                }
            }

            fn print_parenthesized_generic_arguments(
                tokens: &mut TokenStream,
                arguments: &ParenthesizedGenericArguments,
                style: PathStyle,
            ) {
                if let PathStyle::Mod = style {
                    return;
                }

                conditionally_print_turbofish(tokens, &None, style);
                arguments.paren_token.surround(tokens, |tokens| {
                    arguments.inputs.to_tokens(tokens);
                });
                arguments.output.to_tokens(tokens);
            }

            pub fn print_qpath(
                tokens: &mut TokenStream,
                qself: &Option<QSelf>,
                path: &Path,
                style: PathStyle,
            ) {
                let qself = match qself {
                    Some(qself) => qself,
                    None => {
                        print_path(tokens, path, style);
                        return;
                    }
                };
                qself.lt_token.to_tokens(tokens);
                qself.ty.to_tokens(tokens);

                let pos = cmp::min(qself.position, path.segments.len());
                let mut segments = path.segments.pairs();
                if pos > 0 {
                    TokensOrDefault(&qself.as_token).to_tokens(tokens);
                    path.leading_colon.to_tokens(tokens);
                    for (i, segment) in segments.by_ref().take(pos).enumerate() {
                        print_path_segment(tokens, segment.value(), PathStyle::AsWritten);
                        if i + 1 == pos {
                            qself.gt_token.to_tokens(tokens);
                        }
                        segment.punct().to_tokens(tokens);
                    }
                } else {
                    qself.gt_token.to_tokens(tokens);
                    path.leading_colon.to_tokens(tokens);
                }
                for segment in segments {
                    print_path_segment(tokens, segment.value(), style);
                    segment.punct().to_tokens(tokens);
                }
            }

            fn conditionally_print_turbofish(
                tokens: &mut TokenStream,
                colon2_token: &Option<Token![::]>,
                style: PathStyle,
            ) {
                match style {
                    PathStyle::Expr => TokensOrDefault(colon2_token).to_tokens(tokens),
                    PathStyle::Mod => unreachable!(),
                    PathStyle::AsWritten => colon2_token.to_tokens(tokens),
                }
            }
            
            impl Spanned for QSelf
            {
                fn span(&self) -> Span
                {
                    struct QSelfDelimiters<'a>(&'a QSelf);

                    impl<'a> ToTokens for QSelfDelimiters<'a> {
                        fn to_tokens(&self, tokens: &mut TokenStream) {
                            self.0.lt_token.to_tokens(tokens);
                            self.0.gt_token.to_tokens(tokens);
                        }
                    }

                    QSelfDelimiters(self).span()
                }
            }
        }
    }
    pub use self::path::
    {
        AngleBracketedGenericArguments, AssocConst, AssocType, Constraint, GenericArgument,
        ParenthesizedGenericArguments, Path, PathArguments, PathSegment, QSelf,
    };
    
    pub mod precedence
    {
        use ::
        {
            cmp::{ Ordering },
            syntax::
            {
                attr::{ AttrStyle, Attribute },
                expr::
                {
                    Expr, ExprArray, ExprAsync, ExprAwait, ExprBlock, ExprBreak, ExprCall, ExprConst, ExprContinue,
                    ExprField, ExprForLoop, ExprGroup, ExprIf, ExprIndex, ExprInfer, ExprLit, ExprLoop, ExprMacro,
                    ExprMatch, ExprMethodCall, ExprParen, ExprPath, ExprRepeat, ExprReturn, ExprStruct, ExprTry,
                    ExprTryBlock, ExprTuple, ExprUnsafe, ExprWhile, ExprYield,
                },
                op::{ BinOp },
                ty::{ ReturnType },
            },
            *,
        };
        /*
        */
        pub enum Precedence
        {
            Jump,
            Assign,
            Range,
            Or,
            And,
            Let,
            Compare,
            BitOr,
            BitXor,
            BitAnd,
            Shift,
            Sum,
            Product,
            Cast,
            Prefix,
            Unambiguous,
        }

        impl Precedence
        {
            pub const MIN: Self = Precedence::Jump;

            pub fn of_binop(op: &BinOp) -> Self
            {
                match op {
                    BinOp::Add(_) | BinOp::Sub(_) => Precedence::Sum,
                    BinOp::Mul(_) | BinOp::Div(_) | BinOp::Rem(_) => Precedence::Product,
                    BinOp::And(_) => Precedence::And,
                    BinOp::Or(_) => Precedence::Or,
                    BinOp::BitXor(_) => Precedence::BitXor,
                    BinOp::BitAnd(_) => Precedence::BitAnd,
                    BinOp::BitOr(_) => Precedence::BitOr,
                    BinOp::Shl(_) | BinOp::Shr(_) => Precedence::Shift,

                    BinOp::Eq(_)
                    | BinOp::Lt(_)
                    | BinOp::Le(_)
                    | BinOp::Ne(_)
                    | BinOp::Ge(_)
                    | BinOp::Gt(_) => Precedence::Compare,

                    BinOp::AddAssign(_)
                    | BinOp::SubAssign(_)
                    | BinOp::MulAssign(_)
                    | BinOp::DivAssign(_)
                    | BinOp::RemAssign(_)
                    | BinOp::BitXorAssign(_)
                    | BinOp::BitAndAssign(_)
                    | BinOp::BitOrAssign(_)
                    | BinOp::ShlAssign(_)
                    | BinOp::ShrAssign(_) => Precedence::Assign,
                }
            }
            
            pub fn of(e: &Expr) -> Self
            {
                fn prefix_attrs(attrs: &[Attribute]) -> Precedence
                {
                    for attr in attrs
                    {
                        if let AttrStyle::Outer = attr.style { return Precedence::Prefix; }
                    }

                    Precedence::Unambiguous
                }

                match e
                {
                    Expr::Closure(e) => match e.output
                    {
                        ReturnType::Default => Precedence::Jump,
                        ReturnType::Type(..) => prefix_attrs(&e.attrs),
                    },

                    Expr::Break(ExprBreak { expr, .. })
                    | Expr::Return(ExprReturn { expr, .. })
                    | Expr::Yield(ExprYield { expr, .. }) => match expr
                    {
                        Some(_) => Precedence::Jump,
                        None => Precedence::Unambiguous,
                    },

                    Expr::Assign(_) => Precedence::Assign,
                    Expr::Range(_) => Precedence::Range,
                    Expr::Binary(e) => Precedence::of_binop(&e.op),
                    Expr::Let(_) => Precedence::Let,
                    Expr::Cast(_) => Precedence::Cast,
                    Expr::RawAddr(_) | Expr::Reference(_) | Expr::Unary(_) => Precedence::Prefix,
                    
                    Expr::Array(ExprArray { attrs, .. })
                    | Expr::Async(ExprAsync { attrs, .. })
                    | Expr::Await(ExprAwait { attrs, .. })
                    | Expr::Block(ExprBlock { attrs, .. })
                    | Expr::Call(ExprCall { attrs, .. })
                    | Expr::Const(ExprConst { attrs, .. })
                    | Expr::Continue(ExprContinue { attrs, .. })
                    | Expr::Field(ExprField { attrs, .. })
                    | Expr::ForLoop(ExprForLoop { attrs, .. })
                    | Expr::Group(ExprGroup { attrs, .. })
                    | Expr::If(ExprIf { attrs, .. })
                    | Expr::Index(ExprIndex { attrs, .. })
                    | Expr::Infer(ExprInfer { attrs, .. })
                    | Expr::Lit(ExprLit { attrs, .. })
                    | Expr::Loop(ExprLoop { attrs, .. })
                    | Expr::Macro(ExprMacro { attrs, .. })
                    | Expr::Match(ExprMatch { attrs, .. })
                    | Expr::MethodCall(ExprMethodCall { attrs, .. })
                    | Expr::Paren(ExprParen { attrs, .. })
                    | Expr::Path(ExprPath { attrs, .. })
                    | Expr::Repeat(ExprRepeat { attrs, .. })
                    | Expr::Struct(ExprStruct { attrs, .. })
                    | Expr::Try(ExprTry { attrs, .. })
                    | Expr::TryBlock(ExprTryBlock { attrs, .. })
                    | Expr::Tuple(ExprTuple { attrs, .. })
                    | Expr::Unsafe(ExprUnsafe { attrs, .. })
                    | Expr::While(ExprWhile { attrs, .. }) => prefix_attrs(attrs),                    
                    
                    Expr::Verbatim(_) => Precedence::Unambiguous,
                }
            }
        }

        impl Copy for Precedence {}

        impl Clone for Precedence 
        {
            fn clone(&self) -> Self {
                *self
            }
        }

        impl PartialEq for Precedence 
        {
            fn eq(&self, other: &Self) -> bool
        {
                *self as u8 == *other as u8
            }
        }

        impl PartialOrd for Precedence 
        {
            fn partial_cmp(&self, other: &Self) -> Option<Ordering>
            {
                let this = *self as u8;
                let other = *other as u8;
                Some(this.cmp(&other))
            }
        }
    }
    
    pub mod print
    {
        use ::
        {
            process::macros::{ TokenStream },
            quote::{ ToTokens },
            *,
        };
        /*
        */
        pub struct TokensOrDefault<'a, T: 'a>(pub &'a Option<T>);

        impl<'a, T> ToTokens for TokensOrDefault<'a, T> where
            T: ToTokens + Default,
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                match self.0 {
                    Some(t) => t.to_tokens(tokens),
                    None => T::default().to_tokens(tokens),
                }
            }
        }
    }

    pub mod punctuated
    {
        //! A punctuated sequence of syntax tree nodes separated by punctuation.
        use ::
        {
            fmt::{ self, Debug },
            hash::{ Hash, Hasher },
            iter::{ FromIterator },
            ops::{ Index, IndexMut },
            syntax::
            {
                drops::{ NoDrop, TrivialDrop },
                error::{ Result },
                parse::{ Parse, ParseStream },
                token::{ Token },
            },
            *,
        };
        /*
        */
        /// A punctuated sequence of syntax tree nodes of type `T` separated by punctuation of type `P`.
        pub struct Punctuated<T, P> 
        {
            inner: Vec<(T, P)>,
            last: Option<Box<T>>,
        }

        impl<T, P> Punctuated<T, P> 
        {
            /// Creates an empty punctuated sequence.
            pub const fn new() -> Self {
                Punctuated {
                    inner: Vec::new(),
                    last: None,
                }
            }
            /// Determines whether this punctuated sequence is empty, meaning it
            /// contains no syntax tree nodes or punctuation.
            pub fn is_empty(&self) -> bool
            {
                self.inner.len() == 0 && self.last.is_none()
            }
            /// Returns the number of syntax tree nodes in this punctuated sequence.
            pub fn len(&self) -> usize
            {
                self.inner.len() + if self.last.is_some() { 1 } else { 0 }
            }
            /// Borrows the first element in this sequence.
            pub fn first(&self) -> Option<&T>
            {
                self.iter().next()
            }
            /// Mutably borrows the first element in this sequence.
            pub fn first_mut(&mut self) -> Option<&mut T>
            {
                self.iter_mut().next()
            }
            /// Borrows the last element in this sequence.
            pub fn last(&self) -> Option<&T>
            {
                self.iter().next_back()
            }
            /// Mutably borrows the last element in this sequence.
            pub fn last_mut(&mut self) -> Option<&mut T>
            {
                self.iter_mut().next_back()
            }
            /// Borrows the element at the given index.
            pub fn get(&self, index: usize) -> Option<&T> {
                if let Some((value, _punct)) = self.inner.get(index) {
                    Some(value)
                } else if index == self.inner.len() {
                    self.last.as_deref()
                } else {
                    None
                }
            }
            /// Mutably borrows the element at the given index.
            pub fn get_mut(&mut self, index: usize) -> Option<&mut T>
            {
                let inner_len = self.inner.len();
                if let Some((value, _punct)) = self.inner.get_mut(index) {
                    Some(value)
                } else if index == inner_len {
                    self.last.as_deref_mut()
                } else {
                    None
                }
            }
            /// Returns an iterator over borrowed syntax tree nodes of type `&T`.
            pub fn iter(&self) -> Iter<T> {
                Iter {
                    inner: Box::new(NoDrop::new(PrivateIter {
                        inner: self.inner.iter(),
                        last: self.last.as_ref().map(Box::as_ref).into_iter(),
                    })),
                }
            }
            /// Returns an iterator over mutably borrowed syntax tree nodes of type
            /// `&mut T`.
            pub fn iter_mut(&mut self) -> IterMut<T> {
                IterMut {
                    inner: Box::new(NoDrop::new(PrivateIterMut {
                        inner: self.inner.iter_mut(),
                        last: self.last.as_mut().map(Box::as_mut).into_iter(),
                    })),
                }
            }
            /// Returns an iterator over the contents of this sequence as borrowed
            /// punctuated pairs.
            pub fn pairs(&self) -> Pairs<T, P> {
                Pairs {
                    inner: self.inner.iter(),
                    last: self.last.as_ref().map(Box::as_ref).into_iter(),
                }
            }
            /// Returns an iterator over the contents of this sequence as mutably
            /// borrowed punctuated pairs.
            pub fn pairs_mut(&mut self) -> PairsMut<T, P> {
                PairsMut {
                    inner: self.inner.iter_mut(),
                    last: self.last.as_mut().map(Box::as_mut).into_iter(),
                }
            }
            /// Returns an iterator over the contents of this sequence as owned
            /// punctuated pairs.
            pub fn into_pairs(self) -> IntoPairs<T, P> {
                IntoPairs {
                    inner: self.inner.into_iter(),
                    last: self.last.map(|t| *t).into_iter(),
                }
            }
            /// Appends a syntax tree node onto the end of this punctuated sequence. The
            /// sequence must already have a trailing punctuation, or be empty.
            ///
            /// Panics if the sequence is nonempty and does not already have a trailing
            /// punctuation.
            pub fn push_value(&mut self, value: T) {
                assert!(
                    self.empty_or_trailing(),
                    "Punctuated::push_value: cannot push value if Punctuated is missing trailing punctuation",
                );

                self.last = Some(Box::new(value));
            }
            /// Appends a trailing punctuation onto the end of this punctuated sequence.
            /// The sequence must be non-empty and must not already have trailing
            /// punctuation.
            pub fn push_punct(&mut self, punctuation: P) {
                assert!(
                    self.last.is_some(),
                    "Punctuated::push_punct: cannot push punctuation if Punctuated is empty or already has trailing punctuation",
                );

                let last = self.last.take().unwrap();
                self.inner.push((*last, punctuation));
            }
            /// Removes the last punctuated pair from this sequence, or `None` if the
            /// sequence is empty.
            pub fn pop(&mut self) -> Option<Pair<T, P>> {
                if self.last.is_some() {
                    self.last.take().map(|t| Pair::End(*t))
                } else {
                    self.inner.pop().map(|(t, p)| Pair::Punctuated(t, p))
                }
            }
            /// Removes the trailing punctuation from this punctuated sequence, or
            /// `None` if there isn't any.
            pub fn pop_punct(&mut self) -> Option<P> {
                if self.last.is_some() {
                    None
                } else {
                    let (t, p) = self.inner.pop()?;
                    self.last = Some(Box::new(t));
                    Some(p)
                }
            }
            /// Determines whether this punctuated sequence ends with a trailing
            /// punctuation.
            pub fn trailing_punct(&self) -> bool
            {
                self.last.is_none() && !self.is_empty()
            }
            /// Returns true if either this `Punctuated` is empty, or it has a trailing
            /// punctuation.
            ///
            /// Equivalent to `punctuated.is_empty() || punctuated.trailing_punct()`.
            pub fn empty_or_trailing(&self) -> bool
            {
                self.last.is_none()
            }
            /// Appends a syntax tree node onto the end of this punctuated sequence.
            /// the given value of type `T`.
            pub fn push(&mut self, value: T) where
                P: Default,
            {
                if !self.empty_or_trailing() {
                    self.push_punct(Default::default());
                }
                self.push_value(value);
            }
            /// Inserts an element at position `index`.
            pub fn insert(&mut self, index: usize, value: T) where
                P: Default,
            {
                assert!(
                    index <= self.len(),
                    "Punctuated::insert: index out of range",
                );

                if index == self.len() {
                    self.push(value);
                } else {
                    self.inner.insert(index, (value, Default::default()));
                }
            }
            /// Clears the sequence of all values and punctuation, making it empty.
            pub fn clear(&mut self)
            {
                self.inner.clear();
                self.last = None;
            }
            /// Parses zero or more occurrences of `T` separated by punctuation of type
            /// `P`, with optional trailing punctuation.
             
                pub fn parse_terminated(input: ParseStream) -> Result<Self> where
                T: Parse,
                P: Parse,
            {
                Self::parse_terminated_with(input, T::parse)
            }
            /// Parses zero or more occurrences of `T` using the given parse function,
            /// separated by punctuation of type `P`, with optional trailing
            /// punctuation.
            ///
            /// [`parse_terminated`]: Punctuated::parse_terminated
             
                pub fn parse_terminated_with<'a>(
                input: ParseStream<'a>,
                parser: fn(ParseStream<'a>) -> Result<T>,
            ) -> Result<Self> where
                P: Parse,
            {
                let mut punctuated = Punctuated::new();

                loop {
                    if input.is_empty() {
                        break;
                    }
                    let value = parser(input)?;
                    punctuated.push_value(value);
                    if input.is_empty() {
                        break;
                    }
                    let punct = input.parse()?;
                    punctuated.push_punct(punct);
                }

                Ok(punctuated)
            }
            /// Parses one or more occurrences of `T` separated by punctuation of type
            /// `P`, not accepting trailing punctuation.
            /// is not followed by a `P`, even if there are remaining tokens in the
            /// stream.
             
                pub fn parse_separated_nonempty(input: ParseStream) -> Result<Self> where
                T: Parse,
                P: Token + Parse,
            {
                Self::parse_separated_nonempty_with(input, T::parse)
            }
            /// Parses one or more occurrences of `T` using the given parse function,
            /// separated by punctuation of type `P`, not accepting trailing
            /// punctuation.
            ///
            /// [`parse_separated_nonempty`]: Punctuated::parse_separated_nonempty
             
                pub fn parse_separated_nonempty_with<'a>(
                input: ParseStream<'a>,
                parser: fn(ParseStream<'a>) -> Result<T>,
            ) -> Result<Self> where
                P: Token + Parse,
            {
                let mut punctuated = Punctuated::new();

                loop {
                    let value = parser(input)?;
                    punctuated.push_value(value);
                    if !P::peek(input.cursor()) {
                        break;
                    }
                    let punct = input.parse()?;
                    punctuated.push_punct(punct);
                }

                Ok(punctuated)
            }
        }

        impl<T, P> Clone for Punctuated<T, P> where
        T: Clone,
        P: Clone,
        {
            fn clone(&self) -> Self {
                Punctuated {
                    inner: self.inner.clone(),
                    last: self.last.clone(),
                }
            }

            fn clone_from(&mut self, other: &Self)
            {
                self.inner.clone_from(&other.inner);
                self.last.clone_from(&other.last);
            }
        }

        impl<T, P> Eq for Punctuated<T, P> where
        T: Eq,
        P: Eq,
        {
        }

        impl<T, P> PartialEq for Punctuated<T, P> where
        T: PartialEq,
        P: PartialEq,
        {
            fn eq(&self, other: &Self) -> bool
        {
                let Punctuated { inner, last } = self;
                *inner == other.inner && *last == other.last
            }
        }

        impl<T, P> Hash for Punctuated<T, P> where
        T: Hash,
        P: Hash,
        {
            fn hash<H: Hasher>(&self, state: &mut H) {
                let Punctuated { inner, last } = self;
                inner.hash(state);
                last.hash(state);
            }
        }

        impl<T: Debug, P: Debug> Debug for Punctuated<T, P> 
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                let mut list = f.debug_list();
                for (t, p) in &self.inner {
                    list.entry(t);
                    list.entry(p);
                }
                if let Some(last) = &self.last {
                    list.entry(last);
                }
                list.finish()
            }
        }

        impl<T, P> FromIterator<T> for Punctuated<T, P> where
        P: Default,
        {
            fn from_iter<I: IntoIterator<Item = T>>(i: I) -> Self {
                let mut ret = Punctuated::new();
                ret.extend(i);
                ret
            }
        }

        impl<T, P> Extend<T> for Punctuated<T, P> where
        P: Default,
        {
            fn extend<I: IntoIterator<Item = T>>(&mut self, i: I) {
                for value in i {
                    self.push(value);
                }
            }
        }

        impl<T, P> FromIterator<Pair<T, P>> for Punctuated<T, P> 
        {
            fn from_iter<I: IntoIterator<Item = Pair<T, P>>>(i: I) -> Self {
                let mut ret = Punctuated::new();
                do_extend(&mut ret, i.into_iter());
                ret
            }
        }

        impl<T, P> Extend<Pair<T, P>> for Punctuated<T, P> where
        P: Default,
        {
            fn extend<I: IntoIterator<Item = Pair<T, P>>>(&mut self, i: I) {
                if !self.empty_or_trailing() {
                    self.push_punct(P::default());
                }
                do_extend(self, i.into_iter());
            }
        }

        fn do_extend<T, P, I>(punctuated: &mut Punctuated<T, P>, i: I) where
        I: Iterator<Item = Pair<T, P>>,
        {
            let mut nomore = false;
            for pair in i {
                if nomore {
                    panic!("punctuated extended with items after a Pair::End");
                }
                match pair {
                    Pair::Punctuated(a, b) => punctuated.inner.push((a, b)),
                    Pair::End(a) => {
                        punctuated.last = Some(Box::new(a));
                        nomore = true;
                    }
                }
            }
        }

        impl<T, P> IntoIterator for Punctuated<T, P> 
        {
            type Item = T;
            type IntoIter = IntoIter<T>;

            fn into_iter(self) -> Self::IntoIter {
                let mut elements = Vec::with_capacity(self.len());
                elements.extend(self.inner.into_iter().map(|pair| pair.0));
                elements.extend(self.last.map(|t| *t));

                IntoIter {
                    inner: elements.into_iter(),
                }
            }
        }

        impl<'a, T, P> IntoIterator for &'a Punctuated<T, P> 
        {
            type Item = &'a T;
            type IntoIter = Iter<'a, T>;

            fn into_iter(self) -> Self::IntoIter {
                Punctuated::iter(self)
            }
        }

        impl<'a, T, P> IntoIterator for &'a mut Punctuated<T, P> 
        {
            type Item = &'a mut T;
            type IntoIter = IterMut<'a, T>;

            fn into_iter(self) -> Self::IntoIter {
                Punctuated::iter_mut(self)
            }
        }

        impl<T, P> Default for Punctuated<T, P> 
        {
            fn default() -> Self {
                Punctuated::new()
            }
        }
        /// An iterator over borrowed pairs of type `Pair<&T, &P>`.
        pub struct Pairs<'a, T: 'a, P: 'a> 
        {
            inner: slice::Iter<'a, (T, P)>,
            last: option::IntoIter<&'a T>,
        }

        impl<'a, T, P> Iterator for Pairs<'a, T, P> 
        {
            type Item = Pair<&'a T, &'a P>;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|(t, p)| Pair::Punctuated(t, p))
                    .or_else(|| self.last.next().map(Pair::End))
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<'a, T, P> DoubleEndedIterator for Pairs<'a, T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .map(Pair::End)
                    .or_else(|| self.inner.next_back().map(|(t, p)| Pair::Punctuated(t, p)))
            }
        }

        impl<'a, T, P> ExactSizeIterator for Pairs<'a, T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }

        impl<'a, T, P> Clone for Pairs<'a, T, P> 
        {
            fn clone(&self) -> Self {
                Pairs {
                    inner: self.inner.clone(),
                    last: self.last.clone(),
                }
            }
        }
        /// An iterator over mutably borrowed pairs of type `Pair<&mut T, &mut P>`.
        pub struct PairsMut<'a, T: 'a, P: 'a> 
        {
            inner: slice::IterMut<'a, (T, P)>,
            last: option::IntoIter<&'a mut T>,
        }

        impl<'a, T, P> Iterator for PairsMut<'a, T, P> 
        {
            type Item = Pair<&'a mut T, &'a mut P>;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|(t, p)| Pair::Punctuated(t, p))
                    .or_else(|| self.last.next().map(Pair::End))
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<'a, T, P> DoubleEndedIterator for PairsMut<'a, T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .map(Pair::End)
                    .or_else(|| self.inner.next_back().map(|(t, p)| Pair::Punctuated(t, p)))
            }
        }

        impl<'a, T, P> ExactSizeIterator for PairsMut<'a, T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }
        /// An iterator over owned pairs of type `Pair<T, P>`.
        pub struct IntoPairs<T, P> 
        {
            inner: vec::IntoIter<(T, P)>,
            last: option::IntoIter<T>,
        }

        impl<T, P> Iterator for IntoPairs<T, P> 
        {
            type Item = Pair<T, P>;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|(t, p)| Pair::Punctuated(t, p))
                    .or_else(|| self.last.next().map(Pair::End))
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<T, P> DoubleEndedIterator for IntoPairs<T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .map(Pair::End)
                    .or_else(|| self.inner.next_back().map(|(t, p)| Pair::Punctuated(t, p)))
            }
        }

        impl<T, P> ExactSizeIterator for IntoPairs<T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }

        impl<T, P> Clone for IntoPairs<T, P> where
        T: Clone,
        P: Clone
        {
            fn clone(&self) -> Self {
                IntoPairs {
                    inner: self.inner.clone(),
                    last: self.last.clone(),
                }
            }
        }
        /// An iterator over owned values of type `T`.
        pub struct IntoIter<T> 
        {
            inner: vec::IntoIter<T>,
        }

        impl<T> Iterator for IntoIter<T> 
        {
            type Item = T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner.next()
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<T> DoubleEndedIterator for IntoIter<T> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.inner.next_back()
            }
        }

        impl<T> ExactSizeIterator for IntoIter<T> 
        {
            fn len(&self) -> usize
            {
                self.inner.len()
            }
        }

        impl<T> Clone for IntoIter<T> where
        T: Clone,
        {
            fn clone(&self) -> Self {
                IntoIter {
                    inner: self.inner.clone(),
                }
            }
        }
        /// An iterator over borrowed values of type `&T`.
        pub struct Iter<'a, T: 'a> 
        {
            inner: Box<NoDrop<dyn IterTrait<'a, T> + 'a>>,
        }

        trait IterTrait<'a, T: 'a>: Iterator<Item = &'a T> + DoubleEndedIterator + ExactSizeIterator 
        {
            fn clone_box(&self) -> Box<NoDrop<dyn IterTrait<'a, T> + 'a>>;
        }

        struct PrivateIter<'a, T: 'a, P: 'a> {
            inner: slice::Iter<'a, (T, P)>,
            last: option::IntoIter<&'a T>,
        }

        impl<'a, T, P> TrivialDrop for PrivateIter<'a, T, P> where
        slice::Iter<'a, (T, P)>: TrivialDrop,
        option::IntoIter<&'a T>: TrivialDrop,
        {}

        pub fn empty_punctuated_iter<'a, T>() -> Iter<'a, T> 
        {
            Iter {
                inner: Box::new(NoDrop::new(iter::empty())),
            }
        }

        impl<'a, T> Clone for Iter<'a, T> 
        {
            fn clone(&self) -> Self {
                Iter {
                    inner: self.inner.clone_box(),
                }
            }
        }

        impl<'a, T> Iterator for Iter<'a, T> 
        {
            type Item = &'a T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner.next()
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<'a, T> DoubleEndedIterator for Iter<'a, T> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.inner.next_back()
            }
        }

        impl<'a, T> ExactSizeIterator for Iter<'a, T> 
        {
            fn len(&self) -> usize
            {
                self.inner.len()
            }
        }

        impl<'a, T, P> Iterator for PrivateIter<'a, T, P> 
        {
            type Item = &'a T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|pair| &pair.0)
                    .or_else(|| self.last.next())
            }
        }

        impl<'a, T, P> DoubleEndedIterator for PrivateIter<'a, T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .or_else(|| self.inner.next_back().map(|pair| &pair.0))
            }
        }

        impl<'a, T, P> ExactSizeIterator for PrivateIter<'a, T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }

        impl<'a, T, P> Clone for PrivateIter<'a, T, P> 
        {
            fn clone(&self) -> Self {
                PrivateIter {
                    inner: self.inner.clone(),
                    last: self.last.clone(),
                }
            }
        }

        impl<'a, T, I> IterTrait<'a, T> for I where
        T: 'a,
        I: DoubleEndedIterator<Item = &'a T>
        + ExactSizeIterator<Item = &'a T>
        + Clone
        + TrivialDrop
        + 'a
        {
            fn clone_box(&self) -> Box<NoDrop<dyn IterTrait<'a, T> + 'a>> {
                Box::new(NoDrop::new(self.clone()))
            }
        }
        /// An iterator over mutably borrowed values of type `&mut T`.
        pub struct IterMut<'a, T: 'a>
        {
            inner: Box<NoDrop<dyn IterMutTrait<'a, T, Item = &'a mut T> + 'a>>,
        }

        trait IterMutTrait<'a, T: 'a>
        : DoubleEndedIterator<Item = &'a mut T> 
        + ExactSizeIterator<Item = &'a mut T>
        {
        }

        struct PrivateIterMut<'a, T: 'a, P: 'a>
        {
            inner: slice::IterMut<'a, (T, P)>,
            last: option::IntoIter<&'a mut T>,
        }

        impl<'a, T, P> TrivialDrop for PrivateIterMut<'a, T, P> where
        slice::IterMut<'a, (T, P)>: TrivialDrop,
        option::IntoIter<&'a mut T>: TrivialDrop
        {
        }

        pub fn empty_punctuated_iter_mut<'a, T>() -> IterMut<'a, T> 
        {
            IterMut {
                inner: Box::new(NoDrop::new(iter::empty())),
            }
        }

        impl<'a, T> Iterator for IterMut<'a, T> 
        {
            type Item = &'a mut T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner.next()
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (self.len(), Some(self.len()))
            }
        }

        impl<'a, T> DoubleEndedIterator for IterMut<'a, T> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.inner.next_back()
            }
        }

        impl<'a, T> ExactSizeIterator for IterMut<'a, T> 
        {
            fn len(&self) -> usize
            {
                self.inner.len()
            }
        }

        impl<'a, T, P> Iterator for PrivateIterMut<'a, T, P> 
        {
            type Item = &'a mut T;

            fn next(&mut self) -> Option<Self::Item>
            {
                self.inner
                    .next()
                    .map(|pair| &mut pair.0)
                    .or_else(|| self.last.next())
            }
        }

        impl<'a, T, P> DoubleEndedIterator for PrivateIterMut<'a, T, P> 
        {
            fn next_back(&mut self) -> Option<Self::Item>
            {
                self.last
                    .next()
                    .or_else(|| self.inner.next_back().map(|pair| &mut pair.0))
            }
        }

        impl<'a, T, P> ExactSizeIterator for PrivateIterMut<'a, T, P> 
        {
            fn len(&self) -> usize
            {
                self.inner.len() + self.last.len()
            }
        }

        impl<'a, T, I> IterMutTrait<'a, T> for I where
        T: 'a,
        I: DoubleEndedIterator<Item = &'a mut T> 
        + ExactSizeIterator<Item = &'a mut T> + 'a
        {
        }
        /// A single syntax tree node of type `T` followed by its trailing punctuation of type `P` if any.
        pub enum Pair<T, P> 
        {
            Punctuated(T, P),
            End(T),
        }

        impl<T, P> Pair<T, P> 
        {
            /// Extracts the syntax tree node from this punctuated pair, discarding the
            /// following punctuation.
            pub fn into_value(self) -> T {
                match self {
                    Pair::Punctuated(t, _) | Pair::End(t) => t,
                }
            }
            /// Borrows the syntax tree node from this punctuated pair.
            pub fn value(&self) -> &T {
                match self {
                    Pair::Punctuated(t, _) | Pair::End(t) => t,
                }
            }
            /// Mutably borrows the syntax tree node from this punctuated pair.
            pub fn value_mut(&mut self) -> &mut T {
                match self {
                    Pair::Punctuated(t, _) | Pair::End(t) => t,
                }
            }
            /// Borrows the punctuation from this punctuated pair, unless this pair is
            /// the final one and there is no trailing punctuation.
            pub fn punct(&self) -> Option<&P>
            {
                match self {
                    Pair::Punctuated(_, p) => Some(p),
                    Pair::End(_) => None,
                }
            }
            /// Mutably borrows the punctuation from this punctuated pair, unless the
            /// pair is the final one and there is no trailing punctuation.
            /// # use syn::punctuated::Punctuated;
            /// # use syn::{parse_quote, Token, TypeParamBound};
            /// #
            /// # let mut punctuated = Punctuated::<TypeParamBound, Token![+]>::new();
            /// # let span = Span::call_site();
            /// #
            /// punctuated.insert(0, parse_quote!('lifetime));
            /// if let Some(punct) = punctuated.pairs_mut().next().unwrap().punct_mut() {
            ///     punct.span = span;
            /// }
            /// ```
            pub fn punct_mut(&mut self) -> Option<&mut P>
            {
                match self {
                    Pair::Punctuated(_, p) => Some(p),
                    Pair::End(_) => None,
                }
            }
            /// Creates a punctuated pair out of a syntax tree node and an optional
            /// following punctuation.
            pub fn new(t: T, p: Option<P>) -> Self {
                match p {
                    Some(p) => Pair::Punctuated(t, p),
                    None => Pair::End(t),
                }
            }
            /// Produces this punctuated pair as a tuple of syntax tree node and
            /// optional following punctuation.
            pub fn into_tuple(self) -> (T, Option<P>) {
                match self {
                    Pair::Punctuated(t, p) => (t, Some(p)),
                    Pair::End(t) => (t, None),
                }
            }
        }

        impl<T, P> Pair<&T, &P> 
        {
            pub fn cloned(self) -> Pair<T, P> where
                T: Clone,
                P: Clone,
            {
                match self {
                    Pair::Punctuated(t, p) => Pair::Punctuated(t.clone(), p.clone()),
                    Pair::End(t) => Pair::End(t.clone()),
                }
            }
        }

        impl<T, P> Clone for Pair<T, P> where
        T: Clone,
        P: Clone
        {
            fn clone(&self) -> Self {
                match self {
                    Pair::Punctuated(t, p) => Pair::Punctuated(t.clone(), p.clone()),
                    Pair::End(t) => Pair::End(t.clone()),
                }
            }
        }

        impl<T, P> Copy for Pair<T, P> where
        T: Copy,
        P: Copy,
        {
        }

        impl<T, P> Index<usize> for Punctuated<T, P>
        {
            type Output = T;

            fn index(&self, index: usize) -> &Self::Output {
                if index == self.len() - 1 {
                    match &self.last {
                        Some(t) => t,
                        None => &self.inner[index].0,
                    }
                } else {
                    &self.inner[index].0
                }
            }
        }

        impl<T, P> IndexMut<usize> for Punctuated<T, P>
        {
            fn index_mut(&mut self, index: usize) -> &mut Self::Output {
                if index == self.len() - 1 {
                    match &mut self.last {
                        Some(t) => t,
                        None => &mut self.inner[index].0,
                    }
                } else {
                    &mut self.inner[index].0
                }
            }
        }
        
        pub fn fold<T, P, V, F>
        (
            punctuated: Punctuated<T, P>,
            fold: &mut V,
            mut f: F,
        ) -> Punctuated<T, P> where
        V: ?Sized,
        F: FnMut(&mut V, T) -> T,
        {
            Punctuated {
                inner: punctuated
                    .inner
                    .into_iter()
                    .map(|(t, p)| (f(fold, t), p))
                    .collect(),
                last: match punctuated.last {
                    Some(t) => Some(Box::new(f(fold, *t))),
                    None => None,
                },
            }
        }

        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::punctuated::{Pair, Punctuated},
                *,
            };
            
            impl<T, P> ToTokens for Punctuated<T, P> where
            T: ToTokens,
            P: ToTokens
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.pairs());
                }
            }

            impl<T, P> ToTokens for Pair<T, P> where
            T: ToTokens,
            P: ToTokens
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self
                    {
                        Pair::Punctuated(a, b) => {
                            a.to_tokens(tokens);
                            b.to_tokens(tokens);
                        }
                        Pair::End(a) => a.to_tokens(tokens),
                    }
                }
            }
        }
    }
    
    pub mod restriction
    {
        use ::
        {
            syntax::
            {
                path::{ Path },
                token,
            },
            *,
        };
        /*
        */
        ast_enum!
        {
            /// The visibility level of an item: inherited or `pub` or
            /// `pub(restricted)`.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            pub enum Visibility {
                /// A public visibility level: `pub`.
                Public(Token![pub]),
                /// A visibility level restricted to some path: `pub(self)` or
                /// `pub(super)` or `pub(crate)` or `pub(in some::module)`.
                Restricted(VisRestricted),
                /// An inherited visibility, which usually means private.
                Inherited,
            }
        }

        ast_struct!
        {
            /// A visibility level restricted to some path: `pub(self)` or
            /// `pub(super)` or `pub(crate)` or `pub(in some::module)`.
            pub struct VisRestricted {
                pub pub_token: Token![pub],
                pub paren_token: token::Paren,
                pub in_token: Option<Token![in]>,
                pub path: Box<Path>,
            }
        }

        ast_enum!
        {
            /// Unused, but reserved for RFC 3323 restrictions.
            #[non_exhaustive]
            pub enum FieldMutability {
                None,

               
                //
               
                //
               
               
               
               
               
               
            }
        }

        pub mod parsing 
        {
            use ::
            {
                syntax::
                {
                    error::Result,
                    ext::IdentExt as _,
                    ident::Ident,
                    parse::discouraged::Speculative as _,
                    parse::{Parse, ParseStream},
                    path::Path,
                    restriction::{VisRestricted, Visibility},
                    token,
                },
                *,
            };
            
            impl Parse for Visibility
            {
                fn parse(input: ParseStream) -> Result<Self> {
                   
                   
                    if input.peek(token::Group) {
                        let ahead = input.fork();
                        let group = ::syntax::group::parse_group(&ahead)?;
                        if group.content.is_empty() {
                            input.advance_to(&ahead);
                            return Ok(Visibility::Inherited);
                        }
                    }

                    if input.peek(Token![pub]) {
                        Self::parse_pub(input)
                    } else {
                        Ok(Visibility::Inherited)
                    }
                }
            }

            impl Visibility
            {
                fn parse_pub(input: ParseStream) -> Result<Self>
                {
                    let pub_token = input.parse::<Token![pub]>()?;

                    if input.peek(token::Paren) {
                        let ahead = input.fork();

                        let content;
                        let paren_token = parenthesized!(content in ahead);
                        if content.peek(Token![crate])
                            || content.peek(Token![self])
                            || content.peek(Token![super])
                        {
                            let path = content.call(Ident::parse_any)?;

                           
                           
                           
                           
                            if content.is_empty() {
                                input.advance_to(&ahead);
                                return Ok(Visibility::Restricted(VisRestricted {
                                    pub_token,
                                    paren_token,
                                    in_token: None,
                                    path: Box::new(Path::from(path)),
                                }));
                            }
                        } else if content.peek(Token![in]) {
                            let in_token: Token![in] = content.parse()?;
                            let path = content.call(Path::parse_mod_style)?;

                            input.advance_to(&ahead);
                            return Ok(Visibility::Restricted(VisRestricted {
                                pub_token,
                                paren_token,
                                in_token: Some(in_token),
                                path: Box::new(path),
                            }));
                        }
                    }

                    Ok(Visibility::Public(pub_token))
                }

                pub fn is_some(&self) -> bool
                {
                    match self
                    {
                        Visibility::Inherited => false,
                        _ => true,
                    }
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::TokenStream,
                quote::ToTokens,
                syntax::
                {
                    path,
                    path::printing::PathStyle,
                    restriction::{VisRestricted, Visibility},
                },
                *,
            };
            
            impl ToTokens for Visibility
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    match self
                    {
                        Visibility::Public(pub_token) => pub_token.to_tokens(tokens),
                        Visibility::Restricted(vis_restricted) => vis_restricted.to_tokens(tokens),
                        Visibility::Inherited => {}
                    }
                }
            }

            impl ToTokens for VisRestricted
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    self.pub_token.to_tokens(tokens);
                    self.paren_token.surround(tokens, |tokens|
                    {
                        self.in_token.to_tokens(tokens);
                        path::printing::print_path(tokens, &self.path, PathStyle::Mod);
                    });
                }
            }
        }
    } pub use self::restriction::{ FieldMutability, VisRestricted, Visibility };

    mod sealed
    {
        use ::
        {
            *,
        };
        /*
        */        
        pub mod lookahead
        {
            pub trait Sealed: Copy {}
        }
    }
    
    pub mod scan_expr
    {
        use ::
        {
            process::macros::{ Delimiter, Ident, Spacing, TokenTree },
            syntax::
            {
                parse::{ParseStream, Result},
                Token, AngleBracketedGenericArguments, BinOp, Expr, ExprPath, Lifetime, Lit, Type,
            },
            *,
        };
        /*
        */
        enum Input
        {
            Keyword(&'static str),
            Punct(&'static str),
            ConsumeAny,
            ConsumeBinOp,
            ConsumeBrace,
            ConsumeDelimiter,
            ConsumeIdent,
            ConsumeLifetime,
            ConsumeLiteral,
            ConsumeNestedBrace,
            ExpectPath,
            ExpectTurbofish,
            ExpectType,
            CanBeginExpr,
            Otherwise,
            Empty,
        } use self::Input::{ * };

        enum Action {
            SetState(&'static [(Input, Action)]),
            IncDepth,
            DecDepth,
            Finish,
        } use self::Action::{ * };

        static INIT: [(Input, Action); 28] = 
        [
            (ConsumeDelimiter, SetState(&POSTFIX)),
            (Keyword("async"), SetState(&ASYNC)),
            (Keyword("break"), SetState(&BREAK_LABEL)),
            (Keyword("const"), SetState(&CONST)),
            (Keyword("continue"), SetState(&CONTINUE)),
            (Keyword("for"), SetState(&FOR)),
            (Keyword("if"), IncDepth),
            (Keyword("let"), SetState(&PATTERN)),
            (Keyword("loop"), SetState(&BLOCK)),
            (Keyword("match"), IncDepth),
            (Keyword("move"), SetState(&CLOSURE)),
            (Keyword("return"), SetState(&RETURN)),
            (Keyword("static"), SetState(&CLOSURE)),
            (Keyword("unsafe"), SetState(&BLOCK)),
            (Keyword("while"), IncDepth),
            (Keyword("yield"), SetState(&RETURN)),
            (Keyword("_"), SetState(&POSTFIX)),
            (Punct("!"), SetState(&INIT)),
            (Punct("#"), SetState(&[(ConsumeDelimiter, SetState(&INIT))])),
            (Punct("&"), SetState(&REFERENCE)),
            (Punct("*"), SetState(&INIT)),
            (Punct("-"), SetState(&INIT)),
            (Punct("..="), SetState(&INIT)),
            (Punct(".."), SetState(&RANGE)),
            (Punct("|"), SetState(&CLOSURE_ARGS)),
            (ConsumeLifetime, SetState(&[(Punct(":"), SetState(&INIT))])),
            (ConsumeLiteral, SetState(&POSTFIX)),
            (ExpectPath, SetState(&PATH)),
        ];

        static POSTFIX: [(Input, Action); 10] = 
        [
            (Keyword("as"), SetState(&[(ExpectType, SetState(&POSTFIX))])),
            (Punct("..="), SetState(&INIT)),
            (Punct(".."), SetState(&RANGE)),
            (Punct("."), SetState(&DOT)),
            (Punct("?"), SetState(&POSTFIX)),
            (ConsumeBinOp, SetState(&INIT)),
            (Punct("="), SetState(&INIT)),
            (ConsumeNestedBrace, SetState(&IF_THEN)),
            (ConsumeDelimiter, SetState(&POSTFIX)),
            (Empty, Finish),
        ];

        static ASYNC: [(Input, Action); 3] = 
        [
            (Keyword("move"), SetState(&ASYNC)),
            (Punct("|"), SetState(&CLOSURE_ARGS)),
            (ConsumeBrace, SetState(&POSTFIX)),
        ];

        static BLOCK: [(Input, Action); 1] = [(ConsumeBrace, SetState(&POSTFIX))];

        static BREAK_LABEL: [(Input, Action); 2] =
        [
            (ConsumeLifetime, SetState(&BREAK_VALUE)),
            (Otherwise, SetState(&BREAK_VALUE)),
        ];

        static BREAK_VALUE: [(Input, Action); 3] =
        [
            (ConsumeNestedBrace, SetState(&IF_THEN)),
            (CanBeginExpr, SetState(&INIT)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        static CLOSURE: [(Input, Action); 7] =
        [
            (Keyword("async"), SetState(&CLOSURE)),
            (Keyword("move"), SetState(&CLOSURE)),
            (Punct(","), SetState(&CLOSURE)),
            (Punct(">"), SetState(&CLOSURE)),
            (Punct("|"), SetState(&CLOSURE_ARGS)),
            (ConsumeLifetime, SetState(&CLOSURE)),
            (ConsumeIdent, SetState(&CLOSURE)),
        ];

        static CLOSURE_ARGS: [(Input, Action); 2] =
        [
            (Punct("|"), SetState(&CLOSURE_RET)),
            (ConsumeAny, SetState(&CLOSURE_ARGS)),
        ];

        static CLOSURE_RET: [(Input, Action); 2] =
        [
            (Punct("->"), SetState(&[(ExpectType, SetState(&BLOCK))])),
            (Otherwise, SetState(&INIT)),
        ];

        static CONST: [(Input, Action); 2] =
        [
            (Punct("|"), SetState(&CLOSURE_ARGS)),
            (ConsumeBrace, SetState(&POSTFIX)),
        ];

        static CONTINUE: [(Input, Action); 2] =
        [
            (ConsumeLifetime, SetState(&POSTFIX)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        static DOT: [(Input, Action); 3] =
        [
            (Keyword("await"), SetState(&POSTFIX)),
            (ConsumeIdent, SetState(&METHOD)),
            (ConsumeLiteral, SetState(&POSTFIX)),
        ];

        static FOR: [(Input, Action); 2] =
        [
            (Punct("<"), SetState(&CLOSURE)),
            (Otherwise, SetState(&PATTERN)),
        ];

        static IF_ELSE: [(Input, Action); 2] = [(Keyword("if"), SetState(&INIT)), (ConsumeBrace, DecDepth)];
        static IF_THEN: [(Input, Action); 2] = [(Keyword("else"), SetState(&IF_ELSE)), (Otherwise, DecDepth)];

        static METHOD: [(Input, Action); 1] = [(ExpectTurbofish, SetState(&POSTFIX))];

        static PATH: [(Input, Action); 4] =
        [
            (Punct("!="), SetState(&INIT)),
            (Punct("!"), SetState(&INIT)),
            (ConsumeNestedBrace, SetState(&IF_THEN)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        static PATTERN: [(Input, Action); 15] =
        [
            (ConsumeDelimiter, SetState(&PATTERN)),
            (Keyword("box"), SetState(&PATTERN)),
            (Keyword("in"), IncDepth),
            (Keyword("mut"), SetState(&PATTERN)),
            (Keyword("ref"), SetState(&PATTERN)),
            (Keyword("_"), SetState(&PATTERN)),
            (Punct("!"), SetState(&PATTERN)),
            (Punct("&"), SetState(&PATTERN)),
            (Punct("..="), SetState(&PATTERN)),
            (Punct(".."), SetState(&PATTERN)),
            (Punct("="), SetState(&INIT)),
            (Punct("@"), SetState(&PATTERN)),
            (Punct("|"), SetState(&PATTERN)),
            (ConsumeLiteral, SetState(&PATTERN)),
            (ExpectPath, SetState(&PATTERN)),
        ];

        static RANGE: [(Input, Action); 6] =
        [
            (Punct("..="), SetState(&INIT)),
            (Punct(".."), SetState(&RANGE)),
            (Punct("."), SetState(&DOT)),
            (ConsumeNestedBrace, SetState(&IF_THEN)),
            (Empty, Finish),
            (Otherwise, SetState(&INIT)),
        ];

        static RAW: [(Input, Action); 3] =
        [
            (Keyword("const"), SetState(&INIT)),
            (Keyword("mut"), SetState(&INIT)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        static REFERENCE: [(Input, Action); 3] = 
        [
            (Keyword("mut"), SetState(&INIT)),
            (Keyword("raw"), SetState(&RAW)),
            (Otherwise, SetState(&INIT)),
        ];

        static RETURN: [(Input, Action); 2] = 
        [
            (CanBeginExpr, SetState(&INIT)),
            (Otherwise, SetState(&POSTFIX)),
        ];

        pub fn scan_expr(input: ParseStream) -> Result<()>
        {
            let mut state = INIT.as_slice();
            let mut depth = 0usize;
            'table: loop {
                for rule in state {
                    if match rule.0 {
                        Input::Keyword(expected) => input.step(|cursor| match cursor.ident() {
                            Some((ident, rest)) if ident == expected => Ok((true, rest)),
                            _ => Ok((false, *cursor)),
                        })?,
                        Input::Punct(expected) => input.step(|cursor| {
                            let begin = *cursor;
                            let mut cursor = begin;
                            for (i, ch) in expected.chars().enumerate() {
                                match cursor.punct() {
                                    Some((punct, _)) if punct.as_char() != ch => break,
                                    Some((_, rest)) if i == expected.len() - 1 => {
                                        return Ok((true, rest));
                                    }
                                    Some((punct, rest)) if punct.spacing() == Spacing::Joint => {
                                        cursor = rest;
                                    }
                                    _ => break,
                                }
                            }
                            Ok((false, begin))
                        })?,
                        Input::ConsumeAny => input.parse::<Option<TokenTree>>()?.is_some(),
                        Input::ConsumeBinOp => input.parse::<BinOp>().is_ok(),
                        Input::ConsumeBrace | Input::ConsumeNestedBrace => {
                            (matches!(rule.0, Input::ConsumeBrace) || depth > 0)
                                && input.step(|cursor| match cursor.group(Delimiter::Brace) {
                                    Some((_inside, _span, rest)) => Ok((true, rest)),
                                    None => Ok((false, *cursor)),
                                })?
                        }
                        Input::ConsumeDelimiter => input.step(|cursor| match cursor.any_group() {
                            Some((_inside, _delimiter, _span, rest)) => Ok((true, rest)),
                            None => Ok((false, *cursor)),
                        })?,
                        Input::ConsumeIdent => input.parse::<Option<Ident>>()?.is_some(),
                        Input::ConsumeLifetime => input.parse::<Option<Lifetime>>()?.is_some(),
                        Input::ConsumeLiteral => input.parse::<Option<Lit>>()?.is_some(),
                        Input::ExpectPath => {
                            input.parse::<ExprPath>()?;
                            true
                        }
                        Input::ExpectTurbofish => {
                            if input.peek(Token![::]) {
                                input.parse::<AngleBracketedGenericArguments>()?;
                            }
                            true
                        }
                        Input::ExpectType => {
                            Type::without_plus(input)?;
                            true
                        }
                        Input::CanBeginExpr => Expr::peek(input),
                        Input::Otherwise => true,
                        Input::Empty => input.is_empty() || input.peek(Token![,]),
                    } {
                        state = match rule.1 {
                            Action::SetState(next) => next,
                            Action::IncDepth => (depth += 1, &INIT).1,
                            Action::DecDepth => (depth -= 1, &POSTFIX).1,
                            Action::Finish => return if depth == 0 { Ok(()) } else { break },
                        };
                        continue 'table;
                    }
                }
                return Err(input.error("unsupported expression"));
            }
        }
    }

    pub mod span
    {
        use ::
        {
            process::macros::{ extra::DelimSpan, Delimiter, Group, Span, TokenStream },
            *,
        };
        /*
        */
        pub trait IntoSpans<S> 
        {
            fn into_spans(self) -> S;
        }

        impl IntoSpans<Span> for Span 
        {
            fn into_spans(self) -> Span { self }
        }

        impl IntoSpans<[Span; 1]> for Span 
        {
            fn into_spans(self) -> [Span; 1] { [self] }
        }

        impl IntoSpans<[Span; 2]> for Span 
        {
            fn into_spans(self) -> [Span; 2] { [self, self] }
        }

        impl IntoSpans<[Span; 3]> for Span 
        {
            fn into_spans(self) -> [Span; 3] { [self, self, self] }
        }

        impl IntoSpans<[Span; 1]> for [Span; 1] 
        {
            fn into_spans(self) -> [Span; 1] { self }
        }

        impl IntoSpans<[Span; 2]> for [Span; 2] 
        {
            fn into_spans(self) -> [Span; 2] { self }
        }

        impl IntoSpans<[Span; 3]> for [Span; 3] 
        {
            fn into_spans(self) -> [Span; 3] { self }
        }

        impl IntoSpans<DelimSpan> for Span 
        {
            fn into_spans(self) -> DelimSpan
            {
                let mut group = Group::new(Delimiter::None, TokenStream::new());
                group.set_span(self);
                group.delim_span()
            }
        }

        impl IntoSpans<DelimSpan> for DelimSpan 
        {
            fn into_spans(self) -> DelimSpan { self }
        }
    }
    
    pub mod spanned
    {
        /*!
        A trait that can provide the `Span` of the complete contents of a syntax tree nodes . */
        use ::
        {
            process::macros::Span,
            quote::spanned::{ Spanned as ToTokens },
            *,
        };
        /*
        */
        /// A trait that can provide the `Span` of the complete contents of a syntax tree node.
        pub trait Spanned: private::Sealed
        {
            /// Returns a `Span` covering the complete contents of this syntax tree node,
            /// or [`Span::call_site()`] if this node is empty.
            fn span(&self) -> Span;
        }

        impl<T: ?Sized + ToTokens> Spanned for T {
            fn span(&self) -> Span
            {
                self.__span()
            }
        }

        mod private
        {
            use ::
            {
                syntax::spanned::ToTokens,
                *,
            };
            
            pub trait Sealed {}
            impl<T: ?Sized + ToTokens> Sealed for T {}

                impl Sealed for ::syntax::QSelf {}
        }
    }
    
    pub mod stmt
    {
        use ::
        {
            syntax::
            {
                attr::Attribute,
                expr::Expr,
                item::Item,
                mac::Macro,
                pat::Pat,
                token,
            },
            *,
        };
        /*
        */
        ast_struct! 
        {
            /// A braced block containing Rust statements.
            pub struct Block
            {
                pub brace_token: token::Brace,
                /// Statements in a block
                pub stmts: Vec<Stmt>,
            }
        }

        ast_enum! 
        {
            /// A statement, usually ending in a semicolon.
            pub enum Stmt 
            {
                /// A local (let) binding.
                Local(Local),
                /// An item definition.
                Item(Item),
                /// Expression, with or without trailing semicolon.
                Expr(Expr, Option<Token![;]>),
                /// A macro invocation in statement position.
                ///
                /// Syntactically it's ambiguous which other kind of statement this
                /// macro would expand to. It can be any of local variable (`let`),
                /// item, or expression.
                Macro(StmtMacro),
            }
        }

        ast_struct! 
        {
            /// A local `let` binding: `let x: u64 = s.parse()?;`.
            pub struct Local
            {
                pub attrs: Vec<Attribute>,
                pub let_token: Token![let],
                pub pat: Pat,
                pub init: Option<LocalInit>,
                pub semi_token: Token![;],
            }
        }

        ast_struct! 
        {
            /// The expression assigned in a local `let` binding, including optional diverging `else` block.
            pub struct LocalInit {
                pub eq_token: Token![=],
                pub expr: Box<Expr>,
                pub diverge: Option<(Token![else], Box<Expr>)>,
            }
        }

        ast_struct! 
        {
            /// A macro invocation in statement position.
            pub struct StmtMacro
            {
                pub attrs: Vec<Attribute>,
                pub mac: Macro,
                pub semi_token: Option<Token![;]>,
            }
        }
        
        pub mod parsing
        {
            use ::
            {
                process::macros::TokenStream,
                syntax::
                {
                    attr::Attribute,
                    classify,
                    error::Result,
                    expr::{Expr, ExprBlock, ExprMacro},
                    ident::Ident,
                    item,
                    mac::{self, Macro},
                    parse::discouraged::Speculative as _,
                    parse::{Parse, ParseStream},
                    pat::{Pat, PatType},
                    path::Path,
                    stmt::{Block, Local, LocalInit, Stmt, StmtMacro},
                    token,
                    ty::Type,
                },
                *,
            };
            
            struct AllowNoSemi(bool);

            impl Block
            {
                /// Parse the body of a block as zero or more statements, possibly
                /// including one trailing expression.
                ///
                /// # Example
                ///
                /// ```
                /// use syn::{braced, token, Attribute, Block, Ident, Result, Stmt, Token};
                /// use syn::parse::{Parse, ParseStream};
                ///
                ///
                /// //
                ///
                ///
                ///
                ///
                ///
                /// struct MiniFunction {
                ///     attrs: Vec<Attribute>,
                ///     fn_token: Token![fn],
                ///     name: Ident,
                ///     brace_token: token::Brace,
                ///     stmts: Vec<Stmt>,
                /// }
                ///
                /// impl Parse for MiniFunction {
                ///     fn parse(input: ParseStream) -> Result<Self> {
                ///         let outer_attrs = input.call(Attribute::parse_outer)?;
                ///         let fn_token: Token![fn] = input.parse()?;
                ///         let name: Ident = input.parse()?;
                ///
                ///         let content;
                ///         let brace_token = braced!(content in input);
                ///         let inner_attrs = content.call(Attribute::parse_inner)?;
                ///         let stmts = content.call(Block::parse_within)?;
                ///
                ///         Ok(MiniFunction {
                ///             attrs: {
                ///                 let mut attrs = outer_attrs;
                ///                 attrs.extend(inner_attrs);
                ///                 attrs
                ///             },
                ///             fn_token,
                ///             name,
                ///             brace_token,
                ///             stmts,
                ///         })
                ///     }
                /// }
                /// ```
                    pub fn parse_within(input: ParseStream) -> Result<Vec<Stmt>> {
                    let mut stmts = Vec::new();
                    loop {
                        while let semi @ Some(_) = input.parse()? {
                            stmts.push(Stmt::Expr(Expr::Verbatim(TokenStream::new()), semi));
                        }
                        if input.is_empty() {
                            break;
                        }
                        let stmt = parse_stmt(input, AllowNoSemi(true))?;
                        let requires_semicolon = match &stmt {
                            Stmt::Expr(stmt, None) => classify::requires_semi_to_be_stmt(stmt),
                            Stmt::Macro(stmt) => {
                                stmt.semi_token.is_none() && !stmt.mac.delimiter.is_brace()
                            }
                            Stmt::Local(_) | Stmt::Item(_) | Stmt::Expr(_, Some(_)) => false,
                        };
                        stmts.push(stmt);
                        if input.is_empty() {
                            break;
                        } else if requires_semicolon {
                            return Err(input.error("unexpected token, expected `;`"));
                        }
                    }
                    Ok(stmts)
                }
            }

            impl Parse for Block
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(Block {
                        brace_token: braced!(content in input),
                        stmts: content.call(Block::parse_within)?,
                    })
                }
            }

            impl Parse for Stmt
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_nosemi = AllowNoSemi(false);
                    parse_stmt(input, allow_nosemi)
                }
            }

            fn parse_stmt(input: ParseStream, allow_nosemi: AllowNoSemi) -> Result<Stmt>
            {
                let begin = input.fork();
                let attrs = input.call(Attribute::parse_outer)?;

               
               
                let ahead = input.fork();
                let mut is_item_macro = false;
                if let Ok(path) = ahead.call(Path::parse_mod_style) {
                    if ahead.peek(Token![!]) {
                        if ahead.peek2(Ident) || ahead.peek2(Token![try]) {
                            is_item_macro = true;
                        } else if ahead.peek2(token::Brace)
                            && !(ahead.peek3(Token![.]) && !ahead.peek3(Token![..])
                                || ahead.peek3(Token![?]))
                        {
                            input.advance_to(&ahead);
                            return stmt_mac(input, attrs, path).map(Stmt::Macro);
                        }
                    }
                }

                if input.peek(Token![let]) && !input.peek(token::Group) {
                    stmt_local(input, attrs).map(Stmt::Local)
                } else if input.peek(Token![pub])
                    || input.peek(Token![crate]) && !input.peek2(Token![::])
                    || input.peek(Token![extern])
                    || input.peek(Token![use])
                    || input.peek(Token![static])
                        && (input.peek2(Token![mut])
                            || input.peek2(Ident)
                                && !(input.peek2(Token![async])
                                    && (input.peek3(Token![move]) || input.peek3(Token![|]))))
                    || input.peek(Token![const])
                        && !(input.peek2(token::Brace)
                            || input.peek2(Token![static])
                            || input.peek2(Token![async])
                                && !(input.peek3(Token![unsafe])
                                    || input.peek3(Token![extern])
                                    || input.peek3(Token![fn]))
                            || input.peek2(Token![move])
                            || input.peek2(Token![|]))
                    || input.peek(Token![unsafe]) && !input.peek2(token::Brace)
                    || input.peek(Token![async])
                        && (input.peek2(Token![unsafe])
                            || input.peek2(Token![extern])
                            || input.peek2(Token![fn]))
                    || input.peek(Token![fn])
                    || input.peek(Token![mod])
                    || input.peek(Token![type])
                    || input.peek(Token![struct])
                    || input.peek(Token![enum])
                    || input.peek(Token![union]) && input.peek2(Ident)
                    || input.peek(Token![auto]) && input.peek2(Token![trait])
                    || input.peek(Token![trait])
                    || input.peek(Token![default])
                        && (input.peek2(Token![unsafe]) || input.peek2(Token![impl]))
                    || input.peek(Token![impl])
                    || input.peek(Token![macro])
                    || is_item_macro
                {
                    let item = item::parsing::parse_rest_of_item(begin, attrs, input)?;
                    Ok(Stmt::Item(item))
                } else {
                    stmt_expr(input, allow_nosemi, attrs)
                }
            }

            fn stmt_mac(input: ParseStream, attrs: Vec<Attribute>, path: Path) -> Result<StmtMacro>
            {
                let bang_token: Token![!] = input.parse()?;
                let (delimiter, tokens) = mac::parse_delimiter(input)?;
                let semi_token: Option<Token![;]> = input.parse()?;

                Ok(StmtMacro {
                    attrs,
                    mac: Macro {
                        path,
                        bang_token,
                        delimiter,
                        tokens,
                    },
                    semi_token,
                })
            }

            fn stmt_local(input: ParseStream, attrs: Vec<Attribute>) -> Result<Local>
            {
                let let_token: Token![let] = input.parse()?;

                let mut pat = Pat::parse_single(input)?;
                if input.peek(Token![:]) {
                    let colon_token: Token![:] = input.parse()?;
                    let ty: Type = input.parse()?;
                    pat = Pat::Type(PatType {
                        attrs: Vec::new(),
                        pat: Box::new(pat),
                        colon_token,
                        ty: Box::new(ty),
                    });
                }

                let init = if let Some(eq_token) = input.parse()? {
                    let eq_token: Token![=] = eq_token;
                    let expr: Expr = input.parse()?;

                    let diverge = if !classify::expr_trailing_brace(&expr) && input.peek(Token![else]) {
                        let else_token: Token![else] = input.parse()?;
                        let diverge = ExprBlock {
                            attrs: Vec::new(),
                            label: None,
                            block: input.parse()?,
                        };
                        Some((else_token, Box::new(Expr::Block(diverge))))
                    } else {
                        None
                    };

                    Some(LocalInit {
                        eq_token,
                        expr: Box::new(expr),
                        diverge,
                    })
                } else {
                    None
                };

                let semi_token: Token![;] = input.parse()?;

                Ok(Local {
                    attrs,
                    let_token,
                    pat,
                    init,
                    semi_token,
                })
            }

            fn stmt_expr
            (
                input: ParseStream,
                allow_nosemi: AllowNoSemi,
                mut attrs: Vec<Attribute>,
            ) -> Result<Stmt>
            {
                let mut e = Expr::parse_with_earlier_boundary_rule(input)?;

                let mut attr_target = &mut e;
                loop {
                    attr_target = match attr_target {
                        Expr::Assign(e) => &mut e.left,
                        Expr::Binary(e) => &mut e.left,
                        Expr::Cast(e) => &mut e.expr,
                        Expr::Array(_)
                        | Expr::Async(_)
                        | Expr::Await(_)
                        | Expr::Block(_)
                        | Expr::Break(_)
                        | Expr::Call(_)
                        | Expr::Closure(_)
                        | Expr::Const(_)
                        | Expr::Continue(_)
                        | Expr::Field(_)
                        | Expr::ForLoop(_)
                        | Expr::Group(_)
                        | Expr::If(_)
                        | Expr::Index(_)
                        | Expr::Infer(_)
                        | Expr::Let(_)
                        | Expr::Lit(_)
                        | Expr::Loop(_)
                        | Expr::Macro(_)
                        | Expr::Match(_)
                        | Expr::MethodCall(_)
                        | Expr::Paren(_)
                        | Expr::Path(_)
                        | Expr::Range(_)
                        | Expr::RawAddr(_)
                        | Expr::Reference(_)
                        | Expr::Repeat(_)
                        | Expr::Return(_)
                        | Expr::Struct(_)
                        | Expr::Try(_)
                        | Expr::TryBlock(_)
                        | Expr::Tuple(_)
                        | Expr::Unary(_)
                        | Expr::Unsafe(_)
                        | Expr::While(_)
                        | Expr::Yield(_)
                        | Expr::Verbatim(_) => break,
                    };
                }
                attrs.extend(attr_target.replace_attrs(Vec::new()));
                attr_target.replace_attrs(attrs);

                let semi_token: Option<Token![;]> = input.parse()?;

                match e {
                    Expr::Macro(ExprMacro { attrs, mac })
                        if semi_token.is_some() || mac.delimiter.is_brace() =>
                    {
                        return Ok(Stmt::Macro(StmtMacro {
                            attrs,
                            mac,
                            semi_token,
                        }));
                    }
                    _ => {}
                }

                if semi_token.is_some() {
                    Ok(Stmt::Expr(e, semi_token))
                } else if allow_nosemi.0 || !classify::requires_semi_to_be_stmt(&e) {
                    Ok(Stmt::Expr(e, None))
                } else {
                    Err(input.error("expected semicolon"))
                }
            }
        }
        
        pub mod printing 
        {
            use ::
            {
                process::macros::TokenStream,
                quote::{ToTokens, TokenStreamExt},
                syntax::
                {
                    classify,
                    expr::{self, Expr},
                    fixup::FixupContext,
                    stmt::{Block, Local, Stmt, StmtMacro},
                    token,
                },
                *,
            };

            impl ToTokens for Block
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.brace_token.surround(tokens, |tokens| {
                        tokens.append_all(&self.stmts);
                    });
                }
            }

            impl ToTokens for Stmt
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        Stmt::Local(local) => local.to_tokens(tokens),
                        Stmt::Item(item) => item.to_tokens(tokens),
                        Stmt::Expr(expr, semi) => {
                            expr::printing::print_expr(expr, tokens, FixupContext::new_stmt());
                            semi.to_tokens(tokens);
                        }
                        Stmt::Macro(mac) => mac.to_tokens(tokens),
                    }
                }
            }

            impl ToTokens for Local
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    expr::printing::outer_attrs_to_tokens(&self.attrs, tokens);
                    self.let_token.to_tokens(tokens);
                    self.pat.to_tokens(tokens);
                    if let Some(init) = &self.init {
                        init.eq_token.to_tokens(tokens);
                        expr::printing::print_subexpression(
                            &init.expr,
                            init.diverge.is_some() && classify::expr_trailing_brace(&init.expr),
                            tokens,
                            FixupContext::NONE,
                        );
                        if let Some((else_token, diverge)) = &init.diverge {
                            else_token.to_tokens(tokens);
                            match &**diverge {
                                Expr::Block(diverge) => diverge.to_tokens(tokens),
                                _ => token::Brace::default().surround(tokens, |tokens| {
                                    expr::printing::print_expr(diverge, tokens, FixupContext::new_stmt());
                                }),
                            }
                        }
                    }
                    self.semi_token.to_tokens(tokens);
                }
            }

            impl ToTokens for StmtMacro
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    expr::printing::outer_attrs_to_tokens(&self.attrs, tokens);
                    self.mac.to_tokens(tokens);
                    self.semi_token.to_tokens(tokens);
                }
            }
        }
    } pub use self::stmt::{Block, Local, LocalInit, Stmt, StmtMacro};

    pub mod thread
    {
        use ::
        {
            fmt::{ self, Debug },
            thread::{ self, ThreadId },
            *,
        };
        /*
        */
        /// ThreadBound is a Sync-maker and Send-maker that allows accessing a value of type T 
        /// only from the original thread on which the ThreadBound was constructed.
        pub struct ThreadBound<T>
        {
            value: T,
            thread_id: ThreadId,
        }

        unsafe impl<T> Sync for ThreadBound<T> {}
        
        unsafe impl<T: Copy> Send for ThreadBound<T> {}

        impl<T> ThreadBound<T> 
        {
            pub fn new(value: T) -> Self {
                ThreadBound {
                    value,
                    thread_id: thread::current().id(),
                }
            }

            pub fn get(&self) -> Option<&T> {
                if thread::current().id() == self.thread_id {
                    Some(&self.value)
                } else {
                    None
                }
            }
        }

        impl<T: Debug> Debug for ThreadBound<T> 
        {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                match self.get() {
                    Some(value) => Debug::fmt(value, formatter),
                    None => formatter.write_str("unknown"),
                }
            }
        }
        
        impl<T: Copy> Copy for ThreadBound<T> {}

        impl<T: Copy> Clone for ThreadBound<T> 
        {
            fn clone(&self) -> Self {
                *self
            }
        }
    }
    
    pub mod tt    
    {
        use ::
        {
            hash::{ Hash, Hasher },
            process::macros::{ Delimiter, TokenStream, TokenTree },
            *,
        };
        /*
        */
        pub struct TokenTreeHelper<'a>(pub &'a TokenTree);

        impl<'a> PartialEq for TokenTreeHelper<'a>
        {
            fn eq(&self, other: &Self) -> bool
        {
                use ::process::macros::Spacing;

                match (self.0, other.0) {
                    (TokenTree::Group(g1), TokenTree::Group(g2)) => {
                        match (g1.delimiter(), g2.delimiter()) {
                            (Delimiter::Parenthesis, Delimiter::Parenthesis)
                            | (Delimiter::Brace, Delimiter::Brace)
                            | (Delimiter::Bracket, Delimiter::Bracket)
                            | (Delimiter::None, Delimiter::None) => {}
                            _ => return false,
                        }

                        let s1 = g1.stream().into_iter();
                        let mut s2 = g2.stream().into_iter();

                        for item1 in s1 {
                            let item2 = match s2.next() {
                                Some(item) => item,
                                None => return false,
                            };
                            if TokenTreeHelper(&item1) != TokenTreeHelper(&item2) {
                                return false;
                            }
                        }
                        s2.next().is_none()
                    }
                    (TokenTree::Punct(o1), TokenTree::Punct(o2)) => {
                        o1.as_char() == o2.as_char()
                            && match (o1.spacing(), o2.spacing()) {
                                (Spacing::Alone, Spacing::Alone) | (Spacing::Joint, Spacing::Joint) => true,
                                _ => false,
                            }
                    }
                    (TokenTree::Literal(l1), TokenTree::Literal(l2)) => l1.to_string() == l2.to_string(),
                    (TokenTree::Ident(s1), TokenTree::Ident(s2)) => s1 == s2,
                    _ => false,
                }
            }
        }

        impl<'a> Hash for TokenTreeHelper<'a>
        {
            fn hash<H: Hasher>(&self, h: &mut H) {
                use ::process::macros::Spacing;

                match self.0 {
                    TokenTree::Group(g) => {
                        0u8.hash(h);
                        match g.delimiter() {
                            Delimiter::Parenthesis => 0u8.hash(h),
                            Delimiter::Brace => 1u8.hash(h),
                            Delimiter::Bracket => 2u8.hash(h),
                            Delimiter::None => 3u8.hash(h),
                        }

                        for item in g.stream() {
                            TokenTreeHelper(&item).hash(h);
                        }
                        0xFFu8.hash(h);
                    }
                    TokenTree::Punct(op) => {
                        1u8.hash(h);
                        op.as_char().hash(h);
                        match op.spacing() {
                            Spacing::Alone => 0u8.hash(h),
                            Spacing::Joint => 1u8.hash(h),
                        }
                    }
                    TokenTree::Literal(lit) => (2u8, lit.to_string()).hash(h),
                    TokenTree::Ident(word) => (3u8, word).hash(h),
                }
            }
        }

        pub struct TokenStreamHelper<'a>(pub &'a TokenStream);

        impl<'a> PartialEq for TokenStreamHelper<'a>
        {
            fn eq(&self, other: &Self) -> bool
        {
                let left = self.0.clone().into_iter().collect::<Vec<_>>();
                let right = other.0.clone().into_iter().collect::<Vec<_>>();
                if left.len() != right.len() {
                    return false;
                }
                for (a, b) in left.into_iter().zip(right) {
                    if TokenTreeHelper(&a) != TokenTreeHelper(&b) {
                        return false;
                    }
                }
                true
            }
        }

        impl<'a> Hash for TokenStreamHelper<'a>
        {
            fn hash<H: Hasher>(&self, state: &mut H) {
                let tts = self.0.clone().into_iter().collect::<Vec<_>>();
                tts.len().hash(state);
                for tt in tts {
                    TokenTreeHelper(&tt).hash(state);
                }
            }
        }
    }
    
    pub mod ty
    {
        use ::
        {
            process::macros::{ TokenStream },
            syntax::
            {
                attr::Attribute,
                expr::Expr,
                generics::{BoundLifetimes, TypeParamBound},
                ident::Ident,
                lifetime::Lifetime,
                lit::LitStr,
                mac::Macro,
                path::{Path, QSelf},
                punctuated::Punctuated,
                token,
            },
            *,
        };
        /*
        */
        ast_enum_of_structs! 
        {
            /// The possible types that a Rust value could have.
            ///
            /// [syntax tree enum]: ::syntax::expr::Expr#syntax-tree-enums
            #[non_exhaustive]
            pub enum Type {
                /// A fixed size array type: `[T; n]`.
                Array(TypeArray),
                /// A bare function type: `fn(usize) -> bool`.
                BareFn(TypeBareFn),
                /// A type contained within invisible delimiters.
                Group(TypeGroup),
                /// An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or
                /// a lifetime.
                ImplTrait(TypeImplTrait),
                /// Indication that a type should be inferred by the compiler: `_`.
                Infer(TypeInfer),
                /// A macro in the type position.
                Macro(TypeMacro),
                /// The never type: `!`.
                Never(TypeNever),
                /// A parenthesized type equivalent to the inner type.
                Paren(TypeParen),
                /// A path like `std::slice::Iter`, optionally qualified with a
                /// self-type as in `<Vec<T> as SomeTrait>::Associated`.
                Path(TypePath),
                /// A raw pointer type: `*const T` or `*mut T`.
                Ptr(TypePtr),
                /// A reference type: `&'a T` or `&'a mut T`.
                Reference(TypeReference),
                /// A dynamically sized slice type: `[T]`.
                Slice(TypeSlice),
                /// A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a
                /// trait or a lifetime.
                TraitObject(TypeTraitObject),
                /// A tuple type: `(A, B, C, String)`.
                Tuple(TypeTuple),
                /// Tokens in type position not interpreted by Syn.
                Verbatim(TokenStream),

               
                //
               
               
                //
               
               
               
               
                //
               
               
                //
               
               
               
               
            }
        }

        ast_struct! {
            /// A fixed size array type: `[T; n]`.
            pub struct TypeArray {
                pub bracket_token: token::Bracket,
                pub elem: Box<Type>,
                pub semi_token: Token![;],
                pub len: Expr,
            }
        }

        ast_struct! {
            /// A bare function type: `fn(usize) -> bool`.
            pub struct TypeBareFn {
                pub lifetimes: Option<BoundLifetimes>,
                pub unsafety: Option<Token![unsafe]>,
                pub abi: Option<Abi>,
                pub fn_token: Token![fn],
                pub paren_token: token::Paren,
                pub inputs: Punctuated<BareFnArg, Token![,]>,
                pub variadic: Option<BareVariadic>,
                pub output: ReturnType,
            }
        }

        ast_struct! {
            /// A type contained within invisible delimiters.
            pub struct TypeGroup {
                pub group_token: token::Group,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// An `impl Bound1 + Bound2 + Bound3` type where `Bound` is a trait or
            /// a lifetime.
            pub struct TypeImplTrait {
                pub impl_token: Token![impl],
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
            }
        }

        ast_struct! {
            /// Indication that a type should be inferred by the compiler: `_`.
            pub struct TypeInfer {
                pub underscore_token: Token![_],
            }
        }

        ast_struct! {
            /// A macro in the type position.
            pub struct TypeMacro {
                pub mac: Macro,
            }
        }

        ast_struct! {
            /// The never type: `!`.
            pub struct TypeNever {
                pub bang_token: Token![!],
            }
        }

        ast_struct! {
            /// A parenthesized type equivalent to the inner type.
            pub struct TypeParen {
                pub paren_token: token::Paren,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// A path like `std::slice::Iter`, optionally qualified with a
            /// self-type as in `<Vec<T> as SomeTrait>::Associated`.
            pub struct TypePath {
                pub qself: Option<QSelf>,
                pub path: Path,
            }
        }

        ast_struct! {
            /// A raw pointer type: `*const T` or `*mut T`.
            pub struct TypePtr {
                pub star_token: Token![*],
                pub const_token: Option<Token![const]>,
                pub mutability: Option<Token![mut]>,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// A reference type: `&'a T` or `&'a mut T`.
            pub struct TypeReference {
                pub and_token: Token![&],
                pub lifetime: Option<Lifetime>,
                pub mutability: Option<Token![mut]>,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// A dynamically sized slice type: `[T]`.
            pub struct TypeSlice {
                pub bracket_token: token::Bracket,
                pub elem: Box<Type>,
            }
        }

        ast_struct! {
            /// A trait object type `dyn Bound1 + Bound2 + Bound3` where `Bound` is a
            /// trait or a lifetime.
            pub struct TypeTraitObject {
                pub dyn_token: Option<Token![dyn]>,
                pub bounds: Punctuated<TypeParamBound, Token![+]>,
            }
        }

        ast_struct! {
            /// A tuple type: `(A, B, C, String)`.
            pub struct TypeTuple {
                pub paren_token: token::Paren,
                pub elems: Punctuated<Type, Token![,]>,
            }
        }

        ast_struct! {
            /// The binary interface of a function: `extern "C"`.
            pub struct Abi {
                pub extern_token: Token![extern],
                pub name: Option<LitStr>,
            }
        }

        ast_struct! {
            /// An argument in a function type: the `usize` in `fn(usize) -> bool`.
            pub struct BareFnArg {
                pub attrs: Vec<Attribute>,
                pub name: Option<(Ident, Token![:])>,
                pub ty: Type,
            }
        }

        ast_struct! {
            /// The variadic argument of a function pointer like `fn(usize, ...)`.
            pub struct BareVariadic {
                pub attrs: Vec<Attribute>,
                pub name: Option<(Ident, Token![:])>,
                pub dots: Token![...],
                pub comma: Option<Token![,]>,
            }
        }

        ast_enum!
        {
            /// Return type of a function signature.
            pub enum ReturnType
            {
                /// Return type is not specified.
                Default,
                /// A particular type is returned.
                Type(Token![->], Box<Type>),
            }
        }
         
        pub mod parsing
        {
            use ::
            {
                process::macros::Span,
                syntax::
                {
                    attr::{ Attribute },
                    error::{ self, Result },
                    ext::{ IdentExt as _ },
                    generics::{ BoundLifetimes, TraitBound, TraitBoundModifier, TypeParamBound },
                    ident::{ Ident },
                    lifetime::{ Lifetime },
                    mac::{ self, Macro },
                    parse::{ Parse, ParseStream },
                    path::{ self, Path, PathArguments, QSelf },
                    punctuated::{ Punctuated },
                    ty::
                    {
                        Abi, BareFnArg, BareVariadic, ReturnType, Type, TypeArray, TypeBareFn, TypeGroup,
                        TypeImplTrait, TypeInfer, TypeMacro, TypeNever, TypeParen, TypePath, TypePtr,
                        TypeReference, TypeSlice, TypeTraitObject, TypeTuple,
                    },
                    token, verbatim,
                },
                *,
            };
            /*
            */
            impl Parse for Type
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = true;
                    let allow_group_generic = true;
                    ambig_ty(input, allow_plus, allow_group_generic)
                }
            }

            impl Type
            {
                /// In some positions, types may not contain the `+` character, to disambiguate them.
                pub fn without_plus(input: ParseStream) -> Result<Self>
                {
                    let allow_plus = false;
                    let allow_group_generic = true;
                    ambig_ty(input, allow_plus, allow_group_generic)
                }
            }

            pub fn ambig_ty(
                input: ParseStream,
                allow_plus: bool,
                allow_group_generic: bool,
            ) -> Result<Type>
            {
                let begin = input.fork();

                if input.peek(token::Group) {
                    let mut group: TypeGroup = input.parse()?;
                    if input.peek(Token![::]) && input.peek3(Ident::peek_any) {
                        if let Type::Path(mut ty) = *group.elem {
                            Path::parse_rest(input, &mut ty.path, false)?;
                            return Ok(Type::Path(ty));
                        } else {
                            return Ok(Type::Path(TypePath {
                                qself: Some(QSelf {
                                    lt_token: Token![<](group.group_token.span),
                                    position: 0,
                                    as_token: None,
                                    gt_token: Token![>](group.group_token.span),
                                    ty: group.elem,
                                }),
                                path: Path::parse_helper(input, false)?,
                            }));
                        }
                    } else if input.peek(Token![<]) && allow_group_generic
                        || input.peek(Token![::]) && input.peek3(Token![<])
                    {
                        if let Type::Path(mut ty) = *group.elem {
                            let arguments = &mut ty.path.segments.last_mut().unwrap().arguments;
                            if arguments.is_none() {
                                *arguments = PathArguments::AngleBracketed(input.parse()?);
                                Path::parse_rest(input, &mut ty.path, false)?;
                                return Ok(Type::Path(ty));
                            } else {
                                group.elem = Box::new(Type::Path(ty));
                            }
                        }
                    }
                    return Ok(Type::Group(group));
                }

                let mut lifetimes = None::<BoundLifetimes>;
                let mut lookahead = input.lookahead1();
                if lookahead.peek(Token![for]) {
                    lifetimes = input.parse()?;
                    lookahead = input.lookahead1();
                    if !lookahead.peek(Ident)
                        && !lookahead.peek(Token![fn])
                        && !lookahead.peek(Token![unsafe])
                        && !lookahead.peek(Token![extern])
                        && !lookahead.peek(Token![super])
                        && !lookahead.peek(Token![self])
                        && !lookahead.peek(Token![Self])
                        && !lookahead.peek(Token![crate])
                        || input.peek(Token![dyn])
                    {
                        return Err(lookahead.error());
                    }
                }

                if lookahead.peek(token::Paren) {
                    let content;
                    let paren_token = parenthesized!(content in input);
                    if content.is_empty() {
                        return Ok(Type::Tuple(TypeTuple {
                            paren_token,
                            elems: Punctuated::new(),
                        }));
                    }
                    if content.peek(Lifetime) {
                        return Ok(Type::Paren(TypeParen {
                            paren_token,
                            elem: Box::new(Type::TraitObject(content.parse()?)),
                        }));
                    }
                    if content.peek(Token![?]) {
                        return Ok(Type::TraitObject(TypeTraitObject {
                            dyn_token: None,
                            bounds: {
                                let mut bounds = Punctuated::new();
                                bounds.push_value(TypeParamBound::Trait(TraitBound {
                                    paren_token: Some(paren_token),
                                    ..content.parse()?
                                }));
                                while let Some(plus) = input.parse()? {
                                    bounds.push_punct(plus);
                                    bounds.push_value({
                                        let allow_precise_capture = false;
                                        let allow_const = false;
                                        TypeParamBound::parse_single(
                                            input,
                                            allow_precise_capture,
                                            allow_const,
                                        )?
                                    });
                                }
                                bounds
                            },
                        }));
                    }
                    let mut first: Type = content.parse()?;
                    if content.peek(Token![,]) {
                        return Ok(Type::Tuple(TypeTuple {
                            paren_token,
                            elems: {
                                let mut elems = Punctuated::new();
                                elems.push_value(first);
                                elems.push_punct(content.parse()?);
                                while !content.is_empty() {
                                    elems.push_value(content.parse()?);
                                    if content.is_empty() {
                                        break;
                                    }
                                    elems.push_punct(content.parse()?);
                                }
                                elems
                            },
                        }));
                    }
                    if allow_plus && input.peek(Token![+]) {
                        loop {
                            let first = match first {
                                Type::Path(TypePath { qself: None, path }) => {
                                    TypeParamBound::Trait(TraitBound {
                                        paren_token: Some(paren_token),
                                        modifier: TraitBoundModifier::None,
                                        lifetimes: None,
                                        path,
                                    })
                                }
                                Type::TraitObject(TypeTraitObject {
                                    dyn_token: None,
                                    bounds,
                                }) => {
                                    if bounds.len() > 1 || bounds.trailing_punct() {
                                        first = Type::TraitObject(TypeTraitObject {
                                            dyn_token: None,
                                            bounds,
                                        });
                                        break;
                                    }
                                    match bounds.into_iter().next().unwrap() {
                                        TypeParamBound::Trait(trait_bound) => {
                                            TypeParamBound::Trait(TraitBound {
                                                paren_token: Some(paren_token),
                                                ..trait_bound
                                            })
                                        }
                                        other @ (TypeParamBound::Lifetime(_)
                                        | TypeParamBound::PreciseCapture(_)
                                        | TypeParamBound::Verbatim(_)) => other,
                                    }
                                }
                                _ => break,
                            };
                            return Ok(Type::TraitObject(TypeTraitObject {
                                dyn_token: None,
                                bounds: {
                                    let mut bounds = Punctuated::new();
                                    bounds.push_value(first);
                                    while let Some(plus) = input.parse()? {
                                        bounds.push_punct(plus);
                                        bounds.push_value({
                                            let allow_precise_capture = false;
                                            let allow_const = false;
                                            TypeParamBound::parse_single(
                                                input,
                                                allow_precise_capture,
                                                allow_const,
                                            )?
                                        });
                                    }
                                    bounds
                                },
                            }));
                        }
                    }
                    Ok(Type::Paren(TypeParen {
                        paren_token,
                        elem: Box::new(first),
                    }))
                } else if lookahead.peek(Token![fn])
                    || lookahead.peek(Token![unsafe])
                    || lookahead.peek(Token![extern])
                {
                    let mut bare_fn: TypeBareFn = input.parse()?;
                    bare_fn.lifetimes = lifetimes;
                    Ok(Type::BareFn(bare_fn))
                } else if lookahead.peek(Ident)
                    || input.peek(Token![super])
                    || input.peek(Token![self])
                    || input.peek(Token![Self])
                    || input.peek(Token![crate])
                    || lookahead.peek(Token![::])
                    || lookahead.peek(Token![<])
                {
                    let ty: TypePath = input.parse()?;
                    if ty.qself.is_some() {
                        return Ok(Type::Path(ty));
                    }

                    if input.peek(Token![!]) && !input.peek(Token![!=]) && ty.path.is_mod_style() {
                        let bang_token: Token![!] = input.parse()?;
                        let (delimiter, tokens) = mac::parse_delimiter(input)?;
                        return Ok(Type::Macro(TypeMacro {
                            mac: Macro {
                                path: ty.path,
                                bang_token,
                                delimiter,
                                tokens,
                            },
                        }));
                    }

                    if lifetimes.is_some() || allow_plus && input.peek(Token![+]) {
                        let mut bounds = Punctuated::new();
                        bounds.push_value(TypeParamBound::Trait(TraitBound {
                            paren_token: None,
                            modifier: TraitBoundModifier::None,
                            lifetimes,
                            path: ty.path,
                        }));
                        if allow_plus {
                            while input.peek(Token![+]) {
                                bounds.push_punct(input.parse()?);
                                if !(input.peek(Ident::peek_any)
                                    || input.peek(Token![::])
                                    || input.peek(Token![?])
                                    || input.peek(Lifetime)
                                    || input.peek(token::Paren))
                                {
                                    break;
                                }
                                bounds.push_value({
                                    let allow_precise_capture = false;
                                    let allow_const = false;
                                    TypeParamBound::parse_single(input, allow_precise_capture, allow_const)?
                                });
                            }
                        }
                        return Ok(Type::TraitObject(TypeTraitObject {
                            dyn_token: None,
                            bounds,
                        }));
                    }

                    Ok(Type::Path(ty))
                } else if lookahead.peek(Token![dyn]) {
                    let dyn_token: Token![dyn] = input.parse()?;
                    let dyn_span = dyn_token.span;
                    let star_token: Option<Token![*]> = input.parse()?;
                    let bounds = TypeTraitObject::parse_bounds(dyn_span, input, allow_plus)?;
                    Ok(if star_token.is_some() {
                        Type::Verbatim(verbatim::between(&begin, input))
                    } else {
                        Type::TraitObject(TypeTraitObject {
                            dyn_token: Some(dyn_token),
                            bounds,
                        })
                    })
                } else if lookahead.peek(token::Bracket) {
                    let content;
                    let bracket_token = bracketed!(content in input);
                    let elem: Type = content.parse()?;
                    if content.peek(Token![;]) {
                        Ok(Type::Array(TypeArray {
                            bracket_token,
                            elem: Box::new(elem),
                            semi_token: content.parse()?,
                            len: content.parse()?,
                        }))
                    } else {
                        Ok(Type::Slice(TypeSlice {
                            bracket_token,
                            elem: Box::new(elem),
                        }))
                    }
                } else if lookahead.peek(Token![*]) {
                    input.parse().map(Type::Ptr)
                } else if lookahead.peek(Token![&]) {
                    input.parse().map(Type::Reference)
                } else if lookahead.peek(Token![!]) && !input.peek(Token![=]) {
                    input.parse().map(Type::Never)
                } else if lookahead.peek(Token![impl]) {
                    TypeImplTrait::parse(input, allow_plus).map(Type::ImplTrait)
                } else if lookahead.peek(Token![_]) {
                    input.parse().map(Type::Infer)
                } else if lookahead.peek(Lifetime) {
                    input.parse().map(Type::TraitObject)
                } else {
                    Err(lookahead.error())
                }
            }

            impl Parse for TypeSlice
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(TypeSlice {
                        bracket_token: bracketed!(content in input),
                        elem: content.parse()?,
                    })
                }
            }

            impl Parse for TypeArray
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    Ok(TypeArray {
                        bracket_token: bracketed!(content in input),
                        elem: content.parse()?,
                        semi_token: content.parse()?,
                        len: content.parse()?,
                    })
                }
            }

            impl Parse for TypePtr
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let star_token: Token![*] = input.parse()?;

                    let lookahead = input.lookahead1();
                    let (const_token, mutability) = if lookahead.peek(Token![const]) {
                        (Some(input.parse()?), None)
                    } else if lookahead.peek(Token![mut]) {
                        (None, Some(input.parse()?))
                    } else {
                        return Err(lookahead.error());
                    };

                    Ok(TypePtr {
                        star_token,
                        const_token,
                        mutability,
                        elem: Box::new(input.call(Type::without_plus)?),
                    })
                }
            }

            impl Parse for TypeReference
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (TypeReference {
                        and_token: input.parse()?,
                        lifetime: input.parse()?,
                        mutability: input.parse()?,
                       
                        elem: Box::new(input.call(Type::without_plus)?),
                    })
                }
            }

            impl Parse for TypeBareFn
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let args;
                    let mut variadic = None;

                    Ok(TypeBareFn {
                        lifetimes: input.parse()?,
                        unsafety: input.parse()?,
                        abi: input.parse()?,
                        fn_token: input.parse()?,
                        paren_token: parenthesized!(args in input),
                        inputs: {
                            let mut inputs = Punctuated::new();

                            while !args.is_empty() {
                                let attrs = args.call(Attribute::parse_outer)?;

                                if inputs.empty_or_trailing()
                                    && (args.peek(Token![...])
                                        || (args.peek(Ident) || args.peek(Token![_]))
                                            && args.peek2(Token![:])
                                            && args.peek3(Token![...]))
                                {
                                    variadic = Some(parse_bare_variadic(&args, attrs)?);
                                    break;
                                }

                                let allow_self = inputs.is_empty();
                                let arg = parse_bare_fn_arg(&args, allow_self)?;
                                inputs.push_value(BareFnArg { attrs, ..arg });
                                if args.is_empty() {
                                    break;
                                }

                                let comma = args.parse()?;
                                inputs.push_punct(comma);
                            }

                            inputs
                        },
                        variadic,
                        output: input.call(ReturnType::without_plus)?,
                    })
                }
            }

            impl Parse for TypeNever
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (TypeNever {
                        bang_token: input.parse()?,
                    })
                }
            }

            impl Parse for TypeInfer
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (TypeInfer {
                        underscore_token: input.parse()?,
                    })
                }
            }

            impl Parse for TypeTuple
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let content;
                    let paren_token = parenthesized!(content in input);

                    if content.is_empty() {
                        return Ok(TypeTuple {
                            paren_token,
                            elems: Punctuated::new(),
                        });
                    }

                    let first: Type = content.parse()?;
                    Ok(TypeTuple {
                        paren_token,
                        elems: {
                            let mut elems = Punctuated::new();
                            elems.push_value(first);
                            elems.push_punct(content.parse()?);
                            while !content.is_empty() {
                                elems.push_value(content.parse()?);
                                if content.is_empty() {
                                    break;
                                }
                                elems.push_punct(content.parse()?);
                            }
                            elems
                        },
                    })
                }
            }

            impl Parse for TypeMacro
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (TypeMacro {
                        mac: input.parse()?,
                    })
                }
            }

            impl Parse for TypePath
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let expr_style = false;
                    let (qself, path) = path::parsing::qpath(input, expr_style)?;
                    Ok(TypePath { qself, path })
                }
            }

            impl ReturnType {
                    pub fn without_plus(input: ParseStream) -> Result<Self> {
                    let allow_plus = false;
                    Self::parse(input, allow_plus)
                }

                pub fn parse(input: ParseStream, allow_plus: bool) -> Result<Self>
                {
                    if input.peek(Token![->]) {
                        let arrow = input.parse()?;
                        let allow_group_generic = true;
                        let ty = ambig_ty(input, allow_plus, allow_group_generic)?;
                        Ok(ReturnType::Type(arrow, Box::new(ty)))
                    } else {
                        Ok(ReturnType::Default)
                    }
                }
            }

            impl Parse for ReturnType
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = true;
                    Self::parse(input, allow_plus)
                }
            }

            impl Parse for TypeTraitObject
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = true;
                    Self::parse(input, allow_plus)
                }
            }

            impl TypeTraitObject {
                    pub fn without_plus(input: ParseStream) -> Result<Self> {
                    let allow_plus = false;
                    Self::parse(input, allow_plus)
                }

               
                pub fn parse(input: ParseStream, allow_plus: bool) -> Result<Self> {
                    let dyn_token: Option<Token![dyn]> = input.parse()?;
                    let dyn_span = match &dyn_token {
                        Some(token) => token.span,
                        None => input.span(),
                    };
                    let bounds = Self::parse_bounds(dyn_span, input, allow_plus)?;
                    Ok(TypeTraitObject { dyn_token, bounds })
                }

                fn parse_bounds(
                    dyn_span: Span,
                    input: ParseStream,
                    allow_plus: bool,
                ) -> Result<Punctuated<TypeParamBound, Token![+]>> {
                    let allow_precise_capture = false;
                    let allow_const = false;
                    let bounds = TypeParamBound::parse_multiple(
                        input,
                        allow_plus,
                        allow_precise_capture,
                        allow_const,
                    )?;
                    let mut last_lifetime_span = None;
                    let mut at_least_one_trait = false;
                    for bound in &bounds {
                        match bound {
                            TypeParamBound::Trait(_) => {
                                at_least_one_trait = true;
                                break;
                            }
                            TypeParamBound::Lifetime(lifetime) => {
                                last_lifetime_span = Some(lifetime.ident.span());
                            }
                            TypeParamBound::PreciseCapture(_) | TypeParamBound::Verbatim(_) => {
                                unreachable!()
                            }
                        }
                    }
                   
                    if !at_least_one_trait {
                        let msg = "at least one trait is required for an object type";
                        return Err(error::new2(dyn_span, last_lifetime_span.unwrap(), msg));
                    }
                    Ok(bounds)
                }
            }

            impl Parse for TypeImplTrait
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = true;
                    Self::parse(input, allow_plus)
                }
            }

            impl TypeImplTrait {
                    pub fn without_plus(input: ParseStream) -> Result<Self> {
                    let allow_plus = false;
                    Self::parse(input, allow_plus)
                }

                pub fn parse(input: ParseStream, allow_plus: bool) -> Result<Self> {
                    let impl_token: Token![impl] = input.parse()?;
                    let allow_precise_capture = true;
                    let allow_const = true;
                    let bounds = TypeParamBound::parse_multiple(
                        input,
                        allow_plus,
                        allow_precise_capture,
                        allow_const,
                    )?;
                    let mut last_nontrait_span = None;
                    let mut at_least_one_trait = false;
                    for bound in &bounds {
                        match bound {
                            TypeParamBound::Trait(_) => {
                                at_least_one_trait = true;
                                break;
                            }
                            TypeParamBound::Lifetime(lifetime) => {
                                last_nontrait_span = Some(lifetime.ident.span());
                            }
                            TypeParamBound::PreciseCapture(precise_capture) => { last_nontrait_span = Some(precise_capture.gt_token.span); }
                            TypeParamBound::Verbatim(_) => {
                               
                                at_least_one_trait = true;
                                break;
                            }
                        }
                    }
                    if !at_least_one_trait {
                        let msg = "at least one trait must be specified";
                        return Err(error::new2(
                            impl_token.span,
                            last_nontrait_span.unwrap(),
                            msg,
                        ));
                    }
                    Ok(TypeImplTrait { impl_token, bounds })
                }
            }

            impl Parse for TypeGroup
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let group = ::syntax::group::parse_group(input)?;
                    Ok(TypeGroup {
                        group_token: group.token,
                        elem: group.content.parse()?,
                    })
                }
            }

            impl Parse for TypeParen
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_plus = false;
                    Self::parse(input, allow_plus)
                }
            }

            impl TypeParen
            {
                fn parse(input: ParseStream, allow_plus: bool) -> Result<Self> {
                    let content;
                    Ok(TypeParen {
                        paren_token: parenthesized!(content in input),
                        elem: Box::new({
                            let allow_group_generic = true;
                            ambig_ty(&content, allow_plus, allow_group_generic)?
                        }),
                    })
                }
            }

            impl Parse for BareFnArg
            {
                fn parse(input: ParseStream) -> Result<Self> {
                    let allow_self = false;
                    parse_bare_fn_arg(input, allow_self)
                }
            }

            fn parse_bare_fn_arg(input: ParseStream, allow_self: bool) -> Result<BareFnArg>
            {
                let attrs = input.call(Attribute::parse_outer)?;

                let begin = input.fork();

                let has_mut_self = allow_self && input.peek(Token![mut]) && input.peek2(Token![self]);
                if has_mut_self {
                    input.parse::<Token![mut]>()?;
                }

                let mut has_self = false;
                let mut name = if (input.peek(Ident) || input.peek(Token![_]) || {
                    has_self = allow_self && input.peek(Token![self]);
                    has_self
                }) && input.peek2(Token![:])
                    && !input.peek2(Token![::])
                {
                    let name = input.call(Ident::parse_any)?;
                    let colon: Token![:] = input.parse()?;
                    Some((name, colon))
                } else {
                    has_self = false;
                    None
                };

                let ty = if allow_self && !has_self && input.peek(Token![mut]) && input.peek2(Token![self])
                {
                    input.parse::<Token![mut]>()?;
                    input.parse::<Token![self]>()?;
                    None
                } else if has_mut_self && name.is_none() {
                    input.parse::<Token![self]>()?;
                    None
                } else {
                    Some(input.parse()?)
                };

                let ty = match ty {
                    Some(ty) if !has_mut_self => ty,
                    _ => {
                        name = None;
                        Type::Verbatim(verbatim::between(&begin, input))
                    }
                };

                Ok(BareFnArg { attrs, name, ty })
            }

            fn parse_bare_variadic(input: ParseStream, attrs: Vec<Attribute>) -> Result<BareVariadic>
            {
                Ok
                (
                    BareVariadic 
                    {
                        attrs,
                        name: if input.peek(Ident) || input.peek(Token![_])
                        {
                            let name = input.call(Ident::parse_any)?;
                            let colon: Token![:] = input.parse()?;
                            Some((name, colon))
                        }
                        
                        else { None },
                        dots: input.parse()?,
                        comma: input.parse()?,
                    }
                )
            }

            impl Parse for Abi           
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    Ok
                    (
                        Abi
                        {
                            extern_token: input.parse()?,
                            name: input.parse()?,
                        }
                    )
                }
            }

            impl Parse for Option<Abi>           
            {
                fn parse(input: ParseStream) -> Result<Self>
                {
                    if input.peek(Token![extern]) { input.parse().map(Some) }
                    else { Ok(None) }
                }
            }
        }
        
        mod printing
        {
            use ::
            {
                process::macros::{ TokenStream },
                quote::{ ToTokens, TokenStreamExt },
                syntax::
                {
                    attr::{ FilterAttrs },
                    path::{ self, printing::PathStyle },
                    print::{ TokensOrDefault },
                    ty::
                    {
                        Abi, BareFnArg, BareVariadic, ReturnType, TypeArray, TypeBareFn, TypeGroup, TypeImplTrait, 
                        TypeInfer, TypeMacro, TypeNever, TypeParen, TypePath, TypePtr, TypeReference, TypeSlice, 
                        TypeTraitObject, TypeTuple,
                    },
                },
                *,
            };
            /*
            */
            impl ToTokens for TypeSlice 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.bracket_token.surround(tokens, |tokens| {
                        self.elem.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TypeArray 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.bracket_token.surround(tokens, |tokens| {
                        self.elem.to_tokens(tokens);
                        self.semi_token.to_tokens(tokens);
                        self.len.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TypePtr 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.star_token.to_tokens(tokens);
                    match &self.mutability {
                        Some(tok) => tok.to_tokens(tokens),
                        None => {
                            TokensOrDefault(&self.const_token).to_tokens(tokens);
                        }
                    }
                    self.elem.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeReference 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.and_token.to_tokens(tokens);
                    self.lifetime.to_tokens(tokens);
                    self.mutability.to_tokens(tokens);
                    self.elem.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeBareFn 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.lifetimes.to_tokens(tokens);
                    self.unsafety.to_tokens(tokens);
                    self.abi.to_tokens(tokens);
                    self.fn_token.to_tokens(tokens);
                    self.paren_token.surround(tokens, |tokens| {
                        self.inputs.to_tokens(tokens);
                        if let Some(variadic) = &self.variadic {
                            if !self.inputs.empty_or_trailing() {
                                let span = variadic.dots.spans[0];
                                Token![,](span).to_tokens(tokens);
                            }
                            variadic.to_tokens(tokens);
                        }
                    });
                    self.output.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeNever 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.bang_token.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeTuple 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.paren_token.surround(tokens, |tokens| {
                        self.elems.to_tokens(tokens);
                       
                       
                        if self.elems.len() == 1 && !self.elems.trailing_punct() {
                            <Token![,]>::default().to_tokens(tokens);
                        }
                    });
                }
            }

            impl ToTokens for TypePath 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    path::printing::print_qpath(tokens, &self.qself, &self.path, PathStyle::AsWritten);
                }
            }

            impl ToTokens for TypeTraitObject 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.dyn_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeImplTrait 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.impl_token.to_tokens(tokens);
                    self.bounds.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeGroup 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.group_token.surround(tokens, |tokens| {
                        self.elem.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TypeParen 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.paren_token.surround(tokens, |tokens| {
                        self.elem.to_tokens(tokens);
                    });
                }
            }

            impl ToTokens for TypeInfer 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.underscore_token.to_tokens(tokens);
                }
            }

            impl ToTokens for TypeMacro 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.mac.to_tokens(tokens);
                }
            }

            impl ToTokens for ReturnType 
            {
                fn to_tokens(&self, tokens: &mut TokenStream )
                {
                    match self {
                        ReturnType::Default => {}
                        ReturnType::Type(arrow, ty) => {
                            arrow.to_tokens(tokens);
                            ty.to_tokens(tokens);
                        }
                    }
                }
            }

            impl ToTokens for BareFnArg 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some((name, colon)) = &self.name {
                        name.to_tokens(tokens);
                        colon.to_tokens(tokens);
                    }
                    self.ty.to_tokens(tokens);
                }
            }

            impl ToTokens for BareVariadic 
            {
                fn to_tokens(&self, tokens: &mut TokenStream)
                {
                    tokens.append_all(self.attrs.outer());
                    if let Some((name, colon)) = &self.name {
                        name.to_tokens(tokens);
                        colon.to_tokens(tokens);
                    }
                    self.dots.to_tokens(tokens);
                    self.comma.to_tokens(tokens);
                }
            }

            impl ToTokens for Abi 
            {
                fn to_tokens(&self, tokens: &mut TokenStream) {
                    self.extern_token.to_tokens(tokens);
                    self.name.to_tokens(tokens);
                }
            }
        }
    } pub use self::ty::
    {
        Abi, BareFnArg, BareVariadic, ReturnType, Type, TypeArray, TypeBareFn, TypeGroup, TypeImplTrait, TypeInfer,
        TypeMacro, TypeNever, TypeParen, TypePath, TypePtr, TypeReference, TypeSlice, TypeTraitObject, TypeTuple,
    };
    
    pub mod verbatim
    {
        use ::
        {
            cmp::{ Ordering },
            syntax::parse::{ ParseStream },
            process::macros::{ Delimiter, TokenStream },
            *,
        };
        /*
        */
        pub fn between<'a>(begin: ParseStream<'a>, end: ParseStream<'a>) -> TokenStream
        {
            let end = end.cursor();
            let mut cursor = begin.cursor();
            assert!(::syntax::buffer::same_buffer(end, cursor));

            let mut tokens = TokenStream::new();
            while cursor != end {
                let (tt, next) = cursor.token_tree().unwrap();

                if ::syntax::buffer::cmp_assuming_same_buffer(end, next) == Ordering::Less {
                   
                   
                   
                   
                    if let Some((inside, _span, after)) = cursor.group(Delimiter::None) {
                        assert!(next == after);
                        cursor = inside;
                        continue;
                    } else {
                        panic!("verbatim end must not be inside a delimited group");
                    }
                }

                tokens.extend(iter::once(tt));
                cursor = next;
            }
            tokens
        }
    }
    
    pub mod whitespace
    {
        use ::
        {
            *,
        };
        /*
        */
        pub fn skip(mut s: &str) -> &str
        {
            'skip: while !s.is_empty() {
                let byte = s.as_bytes()[0];
                if byte == b'/' {
                    if s.starts_with("//")
                        && (!s.starts_with("///") || s.starts_with("////"))
                        && !s.starts_with("//!")
                    {
                        if let Some(i) = s.find('\n') {
                            s = &s[i + 1..];
                            continue;
                        } else {
                            return "";
                        }
                    } else if s.starts_with("/**/") {
                        s = &s[4..];
                        continue;
                    } else if s.starts_with("/*")
                        && (!s.starts_with("/**") || s.starts_with("/***"))
                        && !s.starts_with("/*!")
                    {
                        let mut depth = 0;
                        let bytes = s.as_bytes();
                        let mut i = 0;
                        let upper = bytes.len() - 1;
                        while i < upper {
                            if bytes[i] == b'/' && bytes[i + 1] == b'*' {
                                depth += 1;
                                i += 1;
                            } else if bytes[i] == b'*' && bytes[i + 1] == b'/' {
                                depth -= 1;
                                if depth == 0 {
                                    s = &s[i + 2..];
                                    continue 'skip;
                                }
                                i += 1;
                            }
                            i += 1;
                        }
                        return s;
                    }
                }
                match byte {
                    b' ' | 0x09..=0x0D => {
                        s = &s[1..];
                        continue;
                    }
                    b if b <= 0x7F => {}
                    _ => {
                        let ch = s.chars().next().unwrap();
                        if is_whitespace(ch) {
                            s = &s[ch.len_utf8()..];
                            continue;
                        }
                    }
                }
                return s;
            }
            s
        }

        fn is_whitespace(ch: char) -> bool {
           
            ch.is_whitespace() || ch == '\u{200e}' || ch == '\u{200f}'
        }
    }
    
    pub mod gen
    {
        /// Syntax tree traversal to transform the nodes of an owned syntax tree.
        pub mod fold
        {
            use ::
            {
                *,
            };
            /*
            */
            macro_rules! full {
                ($e:expr) => {
                    $e
                };
            }
            /// Syntax tree traversal to transform the nodes of an owned syntax tree.
            pub trait Fold {
                fn fold_abi(&mut self, i: ::syntax::Abi) -> ::syntax::Abi {
                    fold_abi(self, i)
                }
                
                fn fold_angle_bracketed_generic_arguments(
                    &mut self,
                    i: ::syntax::AngleBracketedGenericArguments,
                ) -> ::syntax::AngleBracketedGenericArguments {
                    fold_angle_bracketed_generic_arguments(self, i)
                }
                
                fn fold_arm(&mut self, i: ::syntax::Arm) -> ::syntax::Arm {
                    fold_arm(self, i)
                }
                
                fn fold_assoc_const(&mut self, i: ::syntax::AssocConst) -> ::syntax::AssocConst {
                    fold_assoc_const(self, i)
                }
                
                fn fold_assoc_type(&mut self, i: ::syntax::AssocType) -> ::syntax::AssocType {
                    fold_assoc_type(self, i)
                }
                
                fn fold_attr_style(&mut self, i: ::syntax::AttrStyle) -> ::syntax::AttrStyle {
                    fold_attr_style(self, i)
                }
                
                fn fold_attribute(&mut self, i: ::syntax::Attribute) -> ::syntax::Attribute {
                    fold_attribute(self, i)
                }
                
                fn fold_attributes(&mut self, i: Vec<::syntax::Attribute>) -> Vec<::syntax::Attribute> {
                    fold_vec(i, self, Self::fold_attribute)
                }
                
                fn fold_bare_fn_arg(&mut self, i: ::syntax::BareFnArg) -> ::syntax::BareFnArg {
                    fold_bare_fn_arg(self, i)
                }
                
                fn fold_bare_variadic(&mut self, i: ::syntax::BareVariadic) -> ::syntax::BareVariadic {
                    fold_bare_variadic(self, i)
                }
                
                fn fold_bin_op(&mut self, i: ::syntax::BinOp) -> ::syntax::BinOp {
                    fold_bin_op(self, i)
                }
                    fn fold_block(&mut self, i: ::syntax::Block) -> ::syntax::Block {
                    fold_block(self, i)
                }
                
                fn fold_bound_lifetimes(
                    &mut self,
                    i: ::syntax::BoundLifetimes,
                ) -> ::syntax::BoundLifetimes {
                    fold_bound_lifetimes(self, i)
                }
                    fn fold_captured_param(&mut self, i: ::syntax::CapturedParam) -> ::syntax::CapturedParam {
                    fold_captured_param(self, i)
                }
                
                fn fold_const_param(&mut self, i: ::syntax::ConstParam) -> ::syntax::ConstParam {
                    fold_const_param(self, i)
                }
                
                fn fold_constraint(&mut self, i: ::syntax::Constraint) -> ::syntax::Constraint {
                    fold_constraint(self, i)
                }
                
                fn fold_data(&mut self, i: ::syntax::Data) -> ::syntax::Data {
                    fold_data(self, i)
                }
                
                fn fold_data_enum(&mut self, i: ::syntax::DataEnum) -> ::syntax::DataEnum {
                    fold_data_enum(self, i)
                }
                
                fn fold_data_struct(&mut self, i: ::syntax::DataStruct) -> ::syntax::DataStruct {
                    fold_data_struct(self, i)
                }
                
                fn fold_data_union(&mut self, i: ::syntax::DataUnion) -> ::syntax::DataUnion {
                    fold_data_union(self, i)
                }
                
                fn fold_derive_input(&mut self, i: ::syntax::DeriveInput) -> ::syntax::DeriveInput {
                    fold_derive_input(self, i)
                }
                
                fn fold_expr(&mut self, i: ::syntax::Expr) -> ::syntax::Expr {
                    fold_expr(self, i)
                }
                    fn fold_expr_array(&mut self, i: ::syntax::ExprArray) -> ::syntax::ExprArray {
                    fold_expr_array(self, i)
                }
                    fn fold_expr_assign(&mut self, i: ::syntax::ExprAssign) -> ::syntax::ExprAssign {
                    fold_expr_assign(self, i)
                }
                    fn fold_expr_async(&mut self, i: ::syntax::ExprAsync) -> ::syntax::ExprAsync {
                    fold_expr_async(self, i)
                }
                    fn fold_expr_await(&mut self, i: ::syntax::ExprAwait) -> ::syntax::ExprAwait {
                    fold_expr_await(self, i)
                }
                
                fn fold_expr_binary(&mut self, i: ::syntax::ExprBinary) -> ::syntax::ExprBinary {
                    fold_expr_binary(self, i)
                }
                    fn fold_expr_block(&mut self, i: ::syntax::ExprBlock) -> ::syntax::ExprBlock {
                    fold_expr_block(self, i)
                }
                    fn fold_expr_break(&mut self, i: ::syntax::ExprBreak) -> ::syntax::ExprBreak {
                    fold_expr_break(self, i)
                }
                
                fn fold_expr_call(&mut self, i: ::syntax::ExprCall) -> ::syntax::ExprCall {
                    fold_expr_call(self, i)
                }
                
                fn fold_expr_cast(&mut self, i: ::syntax::ExprCast) -> ::syntax::ExprCast {
                    fold_expr_cast(self, i)
                }
                    fn fold_expr_closure(&mut self, i: ::syntax::ExprClosure) -> ::syntax::ExprClosure {
                    fold_expr_closure(self, i)
                }
                    fn fold_expr_const(&mut self, i: ::syntax::ExprConst) -> ::syntax::ExprConst {
                    fold_expr_const(self, i)
                }
                    fn fold_expr_continue(&mut self, i: ::syntax::ExprContinue) -> ::syntax::ExprContinue {
                    fold_expr_continue(self, i)
                }
                
                fn fold_expr_field(&mut self, i: ::syntax::ExprField) -> ::syntax::ExprField {
                    fold_expr_field(self, i)
                }
                    fn fold_expr_for_loop(&mut self, i: ::syntax::ExprForLoop) -> ::syntax::ExprForLoop {
                    fold_expr_for_loop(self, i)
                }
                
                fn fold_expr_group(&mut self, i: ::syntax::ExprGroup) -> ::syntax::ExprGroup {
                    fold_expr_group(self, i)
                }
                    fn fold_expr_if(&mut self, i: ::syntax::ExprIf) -> ::syntax::ExprIf {
                    fold_expr_if(self, i)
                }
                
                fn fold_expr_index(&mut self, i: ::syntax::ExprIndex) -> ::syntax::ExprIndex {
                    fold_expr_index(self, i)
                }
                    fn fold_expr_infer(&mut self, i: ::syntax::ExprInfer) -> ::syntax::ExprInfer {
                    fold_expr_infer(self, i)
                }
                    fn fold_expr_let(&mut self, i: ::syntax::ExprLet) -> ::syntax::ExprLet {
                    fold_expr_let(self, i)
                }
                
                fn fold_expr_lit(&mut self, i: ::syntax::ExprLit) -> ::syntax::ExprLit {
                    fold_expr_lit(self, i)
                }
                    fn fold_expr_loop(&mut self, i: ::syntax::ExprLoop) -> ::syntax::ExprLoop {
                    fold_expr_loop(self, i)
                }
                
                fn fold_expr_macro(&mut self, i: ::syntax::ExprMacro) -> ::syntax::ExprMacro {
                    fold_expr_macro(self, i)
                }
                    fn fold_expr_match(&mut self, i: ::syntax::ExprMatch) -> ::syntax::ExprMatch {
                    fold_expr_match(self, i)
                }
                
                fn fold_expr_method_call(
                    &mut self,
                    i: ::syntax::ExprMethodCall,
                ) -> ::syntax::ExprMethodCall {
                    fold_expr_method_call(self, i)
                }
                
                fn fold_expr_paren(&mut self, i: ::syntax::ExprParen) -> ::syntax::ExprParen {
                    fold_expr_paren(self, i)
                }
                
                fn fold_expr_path(&mut self, i: ::syntax::ExprPath) -> ::syntax::ExprPath {
                    fold_expr_path(self, i)
                }
                    fn fold_expr_range(&mut self, i: ::syntax::ExprRange) -> ::syntax::ExprRange {
                    fold_expr_range(self, i)
                }
                    fn fold_expr_raw_addr(&mut self, i: ::syntax::ExprRawAddr) -> ::syntax::ExprRawAddr {
                    fold_expr_raw_addr(self, i)
                }
                
                fn fold_expr_reference(&mut self, i: ::syntax::ExprReference) -> ::syntax::ExprReference {
                    fold_expr_reference(self, i)
                }
                    fn fold_expr_repeat(&mut self, i: ::syntax::ExprRepeat) -> ::syntax::ExprRepeat {
                    fold_expr_repeat(self, i)
                }
                    fn fold_expr_return(&mut self, i: ::syntax::ExprReturn) -> ::syntax::ExprReturn {
                    fold_expr_return(self, i)
                }
                
                fn fold_expr_struct(&mut self, i: ::syntax::ExprStruct) -> ::syntax::ExprStruct {
                    fold_expr_struct(self, i)
                }
                    fn fold_expr_try(&mut self, i: ::syntax::ExprTry) -> ::syntax::ExprTry {
                    fold_expr_try(self, i)
                }
                    fn fold_expr_try_block(&mut self, i: ::syntax::ExprTryBlock) -> ::syntax::ExprTryBlock {
                    fold_expr_try_block(self, i)
                }
                
                fn fold_expr_tuple(&mut self, i: ::syntax::ExprTuple) -> ::syntax::ExprTuple {
                    fold_expr_tuple(self, i)
                }
                
                fn fold_expr_unary(&mut self, i: ::syntax::ExprUnary) -> ::syntax::ExprUnary {
                    fold_expr_unary(self, i)
                }
                    fn fold_expr_unsafe(&mut self, i: ::syntax::ExprUnsafe) -> ::syntax::ExprUnsafe {
                    fold_expr_unsafe(self, i)
                }
                    fn fold_expr_while(&mut self, i: ::syntax::ExprWhile) -> ::syntax::ExprWhile {
                    fold_expr_while(self, i)
                }
                    fn fold_expr_yield(&mut self, i: ::syntax::ExprYield) -> ::syntax::ExprYield {
                    fold_expr_yield(self, i)
                }
                
                fn fold_field(&mut self, i: ::syntax::Field) -> ::syntax::Field {
                    fold_field(self, i)
                }
                
                fn fold_field_mutability(
                    &mut self,
                    i: ::syntax::FieldMutability,
                ) -> ::syntax::FieldMutability {
                    fold_field_mutability(self, i)
                }
                    fn fold_field_pat(&mut self, i: ::syntax::FieldPat) -> ::syntax::FieldPat {
                    fold_field_pat(self, i)
                }
                
                fn fold_field_value(&mut self, i: ::syntax::FieldValue) -> ::syntax::FieldValue {
                    fold_field_value(self, i)
                }
                
                fn fold_fields(&mut self, i: ::syntax::Fields) -> ::syntax::Fields {
                    fold_fields(self, i)
                }
                
                fn fold_fields_named(&mut self, i: ::syntax::FieldsNamed) -> ::syntax::FieldsNamed {
                    fold_fields_named(self, i)
                }
                
                fn fold_fields_unnamed(&mut self, i: ::syntax::FieldsUnnamed) -> ::syntax::FieldsUnnamed {
                    fold_fields_unnamed(self, i)
                }
                    fn fold_file(&mut self, i: ::syntax::File) -> ::syntax::File {
                    fold_file(self, i)
                }
                    fn fold_fn_arg(&mut self, i: ::syntax::FnArg) -> ::syntax::FnArg {
                    fold_fn_arg(self, i)
                }
                    fn fold_foreign_item(&mut self, i: ::syntax::ForeignItem) -> ::syntax::ForeignItem {
                    fold_foreign_item(self, i)
                }
                    fn fold_foreign_item_fn(&mut self, i: ::syntax::ForeignItemFn) -> ::syntax::ForeignItemFn {
                    fold_foreign_item_fn(self, i)
                }
                    fn fold_foreign_item_macro(
                    &mut self,
                    i: ::syntax::ForeignItemMacro,
                ) -> ::syntax::ForeignItemMacro {
                    fold_foreign_item_macro(self, i)
                }
                    fn fold_foreign_item_static(
                    &mut self,
                    i: ::syntax::ForeignItemStatic,
                ) -> ::syntax::ForeignItemStatic {
                    fold_foreign_item_static(self, i)
                }
                    fn fold_foreign_item_type(
                    &mut self,
                    i: ::syntax::ForeignItemType,
                ) -> ::syntax::ForeignItemType {
                    fold_foreign_item_type(self, i)
                }
                
                fn fold_generic_argument(
                    &mut self,
                    i: ::syntax::GenericArgument,
                ) -> ::syntax::GenericArgument {
                    fold_generic_argument(self, i)
                }
                
                fn fold_generic_param(&mut self, i: ::syntax::GenericParam) -> ::syntax::GenericParam {
                    fold_generic_param(self, i)
                }
                
                fn fold_generics(&mut self, i: ::syntax::Generics) -> ::syntax::Generics {
                    fold_generics(self, i)
                }
                
                fn fold_ident(&mut self, i: process::macros::Ident) -> process::macros::Ident {
                    fold_ident(self, i)
                }
                    fn fold_impl_item(&mut self, i: ::syntax::ImplItem) -> ::syntax::ImplItem {
                    fold_impl_item(self, i)
                }
                    fn fold_impl_item_const(&mut self, i: ::syntax::ImplItemConst) -> ::syntax::ImplItemConst {
                    fold_impl_item_const(self, i)
                }
                    fn fold_impl_item_fn(&mut self, i: ::syntax::ImplItemFn) -> ::syntax::ImplItemFn {
                    fold_impl_item_fn(self, i)
                }
                    fn fold_impl_item_macro(&mut self, i: ::syntax::ImplItemMacro) -> ::syntax::ImplItemMacro {
                    fold_impl_item_macro(self, i)
                }
                    fn fold_impl_item_type(&mut self, i: ::syntax::ImplItemType) -> ::syntax::ImplItemType {
                    fold_impl_item_type(self, i)
                }
                    fn fold_impl_restriction(
                    &mut self,
                    i: ::syntax::ImplRestriction,
                ) -> ::syntax::ImplRestriction {
                    fold_impl_restriction(self, i)
                }
                
                fn fold_index(&mut self, i: ::syntax::Index) -> ::syntax::Index {
                    fold_index(self, i)
                }
                    fn fold_item(&mut self, i: ::syntax::Item) -> ::syntax::Item {
                    fold_item(self, i)
                }
                    fn fold_item_const(&mut self, i: ::syntax::ItemConst) -> ::syntax::ItemConst {
                    fold_item_const(self, i)
                }
                    fn fold_item_enum(&mut self, i: ::syntax::ItemEnum) -> ::syntax::ItemEnum {
                    fold_item_enum(self, i)
                }
                    fn fold_item_extern_crate(
                    &mut self,
                    i: ::syntax::ItemExternCrate,
                ) -> ::syntax::ItemExternCrate {
                    fold_item_extern_crate(self, i)
                }
                    fn fold_item_fn(&mut self, i: ::syntax::ItemFn) -> ::syntax::ItemFn {
                    fold_item_fn(self, i)
                }
                    fn fold_item_foreign_mod(
                    &mut self,
                    i: ::syntax::ItemForeignMod,
                ) -> ::syntax::ItemForeignMod {
                    fold_item_foreign_mod(self, i)
                }
                    fn fold_item_impl(&mut self, i: ::syntax::ItemImpl) -> ::syntax::ItemImpl {
                    fold_item_impl(self, i)
                }
                    fn fold_item_macro(&mut self, i: ::syntax::ItemMacro) -> ::syntax::ItemMacro {
                    fold_item_macro(self, i)
                }
                    fn fold_item_mod(&mut self, i: ::syntax::ItemMod) -> ::syntax::ItemMod {
                    fold_item_mod(self, i)
                }
                    fn fold_item_static(&mut self, i: ::syntax::ItemStatic) -> ::syntax::ItemStatic {
                    fold_item_static(self, i)
                }
                    fn fold_item_struct(&mut self, i: ::syntax::ItemStruct) -> ::syntax::ItemStruct {
                    fold_item_struct(self, i)
                }
                    fn fold_item_trait(&mut self, i: ::syntax::ItemTrait) -> ::syntax::ItemTrait {
                    fold_item_trait(self, i)
                }
                    fn fold_item_trait_alias(
                    &mut self,
                    i: ::syntax::ItemTraitAlias,
                ) -> ::syntax::ItemTraitAlias {
                    fold_item_trait_alias(self, i)
                }
                    fn fold_item_type(&mut self, i: ::syntax::ItemType) -> ::syntax::ItemType {
                    fold_item_type(self, i)
                }
                    fn fold_item_union(&mut self, i: ::syntax::ItemUnion) -> ::syntax::ItemUnion {
                    fold_item_union(self, i)
                }
                    fn fold_item_use(&mut self, i: ::syntax::ItemUse) -> ::syntax::ItemUse {
                    fold_item_use(self, i)
                }
                    fn fold_label(&mut self, i: ::syntax::Label) -> ::syntax::Label {
                    fold_label(self, i)
                }
                
                fn fold_lifetime(&mut self, i: ::syntax::Lifetime) -> ::syntax::Lifetime {
                    fold_lifetime(self, i)
                }
                
                fn fold_lifetime_param(&mut self, i: ::syntax::LifetimeParam) -> ::syntax::LifetimeParam {
                    fold_lifetime_param(self, i)
                }
                
                fn fold_lit(&mut self, i: ::syntax::Lit) -> ::syntax::Lit {
                    fold_lit(self, i)
                }
                
                fn fold_lit_bool(&mut self, i: ::syntax::LitBool) -> ::syntax::LitBool {
                    fold_lit_bool(self, i)
                }
                
                fn fold_lit_byte(&mut self, i: ::syntax::LitByte) -> ::syntax::LitByte {
                    fold_lit_byte(self, i)
                }
                
                fn fold_lit_byte_str(&mut self, i: ::syntax::LitByteStr) -> ::syntax::LitByteStr {
                    fold_lit_byte_str(self, i)
                }
                
                fn fold_lit_cstr(&mut self, i: ::syntax::LitCStr) -> ::syntax::LitCStr {
                    fold_lit_cstr(self, i)
                }
                
                fn fold_lit_char(&mut self, i: ::syntax::LitChar) -> ::syntax::LitChar {
                    fold_lit_char(self, i)
                }
                
                fn fold_lit_float(&mut self, i: ::syntax::LitFloat) -> ::syntax::LitFloat {
                    fold_lit_float(self, i)
                }
                
                fn fold_lit_int(&mut self, i: ::syntax::LitInt) -> ::syntax::LitInt {
                    fold_lit_int(self, i)
                }
                
                fn fold_lit_str(&mut self, i: ::syntax::LitStr) -> ::syntax::LitStr {
                    fold_lit_str(self, i)
                }
                    fn fold_local(&mut self, i: ::syntax::Local) -> ::syntax::Local {
                    fold_local(self, i)
                }
                    fn fold_local_init(&mut self, i: ::syntax::LocalInit) -> ::syntax::LocalInit {
                    fold_local_init(self, i)
                }
                
                fn fold_macro(&mut self, i: ::syntax::Macro) -> ::syntax::Macro {
                    fold_macro(self, i)
                }
                
                fn fold_macro_delimiter(
                    &mut self,
                    i: ::syntax::MacroDelimiter,
                ) -> ::syntax::MacroDelimiter {
                    fold_macro_delimiter(self, i)
                }
                
                fn fold_member(&mut self, i: ::syntax::Member) -> ::syntax::Member {
                    fold_member(self, i)
                }
                
                fn fold_meta(&mut self, i: ::syntax::Meta) -> ::syntax::Meta {
                    fold_meta(self, i)
                }
                
                fn fold_meta_list(&mut self, i: ::syntax::MetaList) -> ::syntax::MetaList {
                    fold_meta_list(self, i)
                }
                
                fn fold_meta_name_value(&mut self, i: ::syntax::MetaNameValue) -> ::syntax::MetaNameValue {
                    fold_meta_name_value(self, i)
                }
                
                fn fold_parenthesized_generic_arguments(
                    &mut self,
                    i: ::syntax::ParenthesizedGenericArguments,
                ) -> ::syntax::ParenthesizedGenericArguments {
                    fold_parenthesized_generic_arguments(self, i)
                }
                    fn fold_pat(&mut self, i: ::syntax::Pat) -> ::syntax::Pat {
                    fold_pat(self, i)
                }
                    fn fold_pat_ident(&mut self, i: ::syntax::PatIdent) -> ::syntax::PatIdent {
                    fold_pat_ident(self, i)
                }
                    fn fold_pat_or(&mut self, i: ::syntax::PatOr) -> ::syntax::PatOr {
                    fold_pat_or(self, i)
                }
                    fn fold_pat_paren(&mut self, i: ::syntax::PatParen) -> ::syntax::PatParen {
                    fold_pat_paren(self, i)
                }
                    fn fold_pat_reference(&mut self, i: ::syntax::PatReference) -> ::syntax::PatReference {
                    fold_pat_reference(self, i)
                }
                    fn fold_pat_rest(&mut self, i: ::syntax::PatRest) -> ::syntax::PatRest {
                    fold_pat_rest(self, i)
                }
                    fn fold_pat_slice(&mut self, i: ::syntax::PatSlice) -> ::syntax::PatSlice {
                    fold_pat_slice(self, i)
                }
                    fn fold_pat_struct(&mut self, i: ::syntax::PatStruct) -> ::syntax::PatStruct {
                    fold_pat_struct(self, i)
                }
                    fn fold_pat_tuple(&mut self, i: ::syntax::PatTuple) -> ::syntax::PatTuple {
                    fold_pat_tuple(self, i)
                }
                    fn fold_pat_tuple_struct(
                    &mut self,
                    i: ::syntax::PatTupleStruct,
                ) -> ::syntax::PatTupleStruct {
                    fold_pat_tuple_struct(self, i)
                }
                    fn fold_pat_type(&mut self, i: ::syntax::PatType) -> ::syntax::PatType {
                    fold_pat_type(self, i)
                }
                    fn fold_pat_wild(&mut self, i: ::syntax::PatWild) -> ::syntax::PatWild {
                    fold_pat_wild(self, i)
                }
                
                fn fold_path(&mut self, i: ::syntax::Path) -> ::syntax::Path {
                    fold_path(self, i)
                }
                
                fn fold_path_arguments(&mut self, i: ::syntax::PathArguments) -> ::syntax::PathArguments {
                    fold_path_arguments(self, i)
                }
                
                fn fold_path_segment(&mut self, i: ::syntax::PathSegment) -> ::syntax::PathSegment {
                    fold_path_segment(self, i)
                }
                    fn fold_pointer_mutability(
                    &mut self,
                    i: ::syntax::PointerMutability,
                ) -> ::syntax::PointerMutability {
                    fold_pointer_mutability(self, i)
                }
                    fn fold_precise_capture(
                    &mut self,
                    i: ::syntax::PreciseCapture,
                ) -> ::syntax::PreciseCapture {
                    fold_precise_capture(self, i)
                }
                
                fn fold_predicate_lifetime(
                    &mut self,
                    i: ::syntax::PredicateLifetime,
                ) -> ::syntax::PredicateLifetime {
                    fold_predicate_lifetime(self, i)
                }
                
                fn fold_predicate_type(&mut self, i: ::syntax::PredicateType) -> ::syntax::PredicateType {
                    fold_predicate_type(self, i)
                }
                
                fn fold_qself(&mut self, i: ::syntax::QSelf) -> ::syntax::QSelf {
                    fold_qself(self, i)
                }
                    fn fold_range_limits(&mut self, i: ::syntax::RangeLimits) -> ::syntax::RangeLimits {
                    fold_range_limits(self, i)
                }
                    fn fold_receiver(&mut self, i: ::syntax::Receiver) -> ::syntax::Receiver {
                    fold_receiver(self, i)
                }
                
                fn fold_return_type(&mut self, i: ::syntax::ReturnType) -> ::syntax::ReturnType {
                    fold_return_type(self, i)
                }
                    fn fold_signature(&mut self, i: ::syntax::Signature) -> ::syntax::Signature {
                    fold_signature(self, i)
                }
                
                fn fold_span(&mut self, i: process::macros::Span) -> process::macros::Span {
                    i
                }
                    fn fold_static_mutability(
                    &mut self,
                    i: ::syntax::StaticMutability,
                ) -> ::syntax::StaticMutability {
                    fold_static_mutability(self, i)
                }
                    fn fold_stmt(&mut self, i: ::syntax::Stmt) -> ::syntax::Stmt {
                    fold_stmt(self, i)
                }
                    fn fold_stmt_macro(&mut self, i: ::syntax::StmtMacro) -> ::syntax::StmtMacro {
                    fold_stmt_macro(self, i)
                }
                
                fn fold_token_stream(
                    &mut self,
                    i: process::macros::TokenStream,
                ) -> process::macros::TokenStream {
                    i
                }
                
                fn fold_trait_bound(&mut self, i: ::syntax::TraitBound) -> ::syntax::TraitBound {
                    fold_trait_bound(self, i)
                }
                
                fn fold_trait_bound_modifier(
                    &mut self,
                    i: ::syntax::TraitBoundModifier,
                ) -> ::syntax::TraitBoundModifier {
                    fold_trait_bound_modifier(self, i)
                }
                    fn fold_trait_item(&mut self, i: ::syntax::TraitItem) -> ::syntax::TraitItem {
                    fold_trait_item(self, i)
                }
                    fn fold_trait_item_const(
                    &mut self,
                    i: ::syntax::TraitItemConst,
                ) -> ::syntax::TraitItemConst {
                    fold_trait_item_const(self, i)
                }
                    fn fold_trait_item_fn(&mut self, i: ::syntax::TraitItemFn) -> ::syntax::TraitItemFn {
                    fold_trait_item_fn(self, i)
                }
                    fn fold_trait_item_macro(
                    &mut self,
                    i: ::syntax::TraitItemMacro,
                ) -> ::syntax::TraitItemMacro {
                    fold_trait_item_macro(self, i)
                }
                    fn fold_trait_item_type(&mut self, i: ::syntax::TraitItemType) -> ::syntax::TraitItemType {
                    fold_trait_item_type(self, i)
                }
                
                fn fold_type(&mut self, i: ::syntax::Type) -> ::syntax::Type {
                    fold_type(self, i)
                }
                
                fn fold_type_array(&mut self, i: ::syntax::TypeArray) -> ::syntax::TypeArray {
                    fold_type_array(self, i)
                }
                
                fn fold_type_bare_fn(&mut self, i: ::syntax::TypeBareFn) -> ::syntax::TypeBareFn {
                    fold_type_bare_fn(self, i)
                }
                
                fn fold_type_group(&mut self, i: ::syntax::TypeGroup) -> ::syntax::TypeGroup {
                    fold_type_group(self, i)
                }
                
                fn fold_type_impl_trait(&mut self, i: ::syntax::TypeImplTrait) -> ::syntax::TypeImplTrait {
                    fold_type_impl_trait(self, i)
                }
                
                fn fold_type_infer(&mut self, i: ::syntax::TypeInfer) -> ::syntax::TypeInfer {
                    fold_type_infer(self, i)
                }
                
                fn fold_type_macro(&mut self, i: ::syntax::TypeMacro) -> ::syntax::TypeMacro {
                    fold_type_macro(self, i)
                }
                
                fn fold_type_never(&mut self, i: ::syntax::TypeNever) -> ::syntax::TypeNever {
                    fold_type_never(self, i)
                }
                
                fn fold_type_param(&mut self, i: ::syntax::TypeParam) -> ::syntax::TypeParam {
                    fold_type_param(self, i)
                }
                
                fn fold_type_param_bound(
                    &mut self,
                    i: ::syntax::TypeParamBound,
                ) -> ::syntax::TypeParamBound {
                    fold_type_param_bound(self, i)
                }
                
                fn fold_type_paren(&mut self, i: ::syntax::TypeParen) -> ::syntax::TypeParen {
                    fold_type_paren(self, i)
                }
                
                fn fold_type_path(&mut self, i: ::syntax::TypePath) -> ::syntax::TypePath {
                    fold_type_path(self, i)
                }
                
                fn fold_type_ptr(&mut self, i: ::syntax::TypePtr) -> ::syntax::TypePtr {
                    fold_type_ptr(self, i)
                }
                
                fn fold_type_reference(&mut self, i: ::syntax::TypeReference) -> ::syntax::TypeReference {
                    fold_type_reference(self, i)
                }
                
                fn fold_type_slice(&mut self, i: ::syntax::TypeSlice) -> ::syntax::TypeSlice {
                    fold_type_slice(self, i)
                }
                
                fn fold_type_trait_object(
                    &mut self,
                    i: ::syntax::TypeTraitObject,
                ) -> ::syntax::TypeTraitObject {
                    fold_type_trait_object(self, i)
                }
                
                fn fold_type_tuple(&mut self, i: ::syntax::TypeTuple) -> ::syntax::TypeTuple {
                    fold_type_tuple(self, i)
                }
                
                fn fold_un_op(&mut self, i: ::syntax::UnOp) -> ::syntax::UnOp {
                    fold_un_op(self, i)
                }
                    fn fold_use_glob(&mut self, i: ::syntax::UseGlob) -> ::syntax::UseGlob {
                    fold_use_glob(self, i)
                }
                    fn fold_use_group(&mut self, i: ::syntax::UseGroup) -> ::syntax::UseGroup {
                    fold_use_group(self, i)
                }
                    fn fold_use_name(&mut self, i: ::syntax::UseName) -> ::syntax::UseName {
                    fold_use_name(self, i)
                }
                    fn fold_use_path(&mut self, i: ::syntax::UsePath) -> ::syntax::UsePath {
                    fold_use_path(self, i)
                }
                    fn fold_use_rename(&mut self, i: ::syntax::UseRename) -> ::syntax::UseRename {
                    fold_use_rename(self, i)
                }
                    fn fold_use_tree(&mut self, i: ::syntax::UseTree) -> ::syntax::UseTree {
                    fold_use_tree(self, i)
                }
                    fn fold_variadic(&mut self, i: ::syntax::Variadic) -> ::syntax::Variadic {
                    fold_variadic(self, i)
                }
                
                fn fold_variant(&mut self, i: ::syntax::Variant) -> ::syntax::Variant {
                    fold_variant(self, i)
                }
                
                fn fold_vis_restricted(&mut self, i: ::syntax::VisRestricted) -> ::syntax::VisRestricted {
                    fold_vis_restricted(self, i)
                }
                
                fn fold_visibility(&mut self, i: ::syntax::Visibility) -> ::syntax::Visibility {
                    fold_visibility(self, i)
                }
                
                fn fold_where_clause(&mut self, i: ::syntax::WhereClause) -> ::syntax::WhereClause {
                    fold_where_clause(self, i)
                }
                
                fn fold_where_predicate(
                    &mut self,
                    i: ::syntax::WherePredicate,
                ) -> ::syntax::WherePredicate {
                    fold_where_predicate(self, i)
                }
            }
            pub fn fold_abi<F>(f: &mut F, node: ::syntax::Abi) -> ::syntax::Abi where
                F: Fold + ?Sized,
            {
                ::syntax::Abi {
                    extern_token: node.extern_token,
                    name: (node.name).map(|it| f.fold_lit_str(it)),
                }
            }
            pub fn fold_angle_bracketed_generic_arguments<F>(
                f: &mut F,
                node: ::syntax::AngleBracketedGenericArguments,
            ) -> ::syntax::AngleBracketedGenericArguments where
                F: Fold + ?Sized,
            {
                ::syntax::AngleBracketedGenericArguments {
                    colon2_token: node.colon2_token,
                    lt_token: node.lt_token,
                    args: ::syntax::punctuated::fold(node.args, f, F::fold_generic_argument),
                    gt_token: node.gt_token,
                }
            }
            pub fn fold_arm<F>(f: &mut F, node: ::syntax::Arm) -> ::syntax::Arm where
                F: Fold + ?Sized,
            {
                ::syntax::Arm {
                    attrs: f.fold_attributes(node.attrs),
                    pat: f.fold_pat(node.pat),
                    guard: (node.guard).map(|it| ((it).0, Box::new(f.fold_expr(*(it).1)))),
                    fat_arrow_token: node.fat_arrow_token,
                    body: Box::new(f.fold_expr(*node.body)),
                    comma: node.comma,
                }
            }
            pub fn fold_assoc_const<F>(f: &mut F, node: ::syntax::AssocConst) -> ::syntax::AssocConst where
                F: Fold + ?Sized,
            {
                ::syntax::AssocConst {
                    ident: f.fold_ident(node.ident),
                    generics: (node.generics).map(|it| f.fold_angle_bracketed_generic_arguments(it)),
                    eq_token: node.eq_token,
                    value: f.fold_expr(node.value),
                }
            }
            pub fn fold_assoc_type<F>(f: &mut F, node: ::syntax::AssocType) -> ::syntax::AssocType where
                F: Fold + ?Sized,
            {
                ::syntax::AssocType {
                    ident: f.fold_ident(node.ident),
                    generics: (node.generics).map(|it| f.fold_angle_bracketed_generic_arguments(it)),
                    eq_token: node.eq_token,
                    ty: f.fold_type(node.ty),
                }
            }
            pub fn fold_attr_style<F>(f: &mut F, node: ::syntax::AttrStyle) -> ::syntax::AttrStyle where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::AttrStyle::Outer => ::syntax::AttrStyle::Outer,
                    ::syntax::AttrStyle::Inner(_binding_0) => ::syntax::AttrStyle::Inner(_binding_0),
                }
            }
            pub fn fold_attribute<F>(f: &mut F, node: ::syntax::Attribute) -> ::syntax::Attribute where
                F: Fold + ?Sized,
            {
                ::syntax::Attribute {
                    pound_token: node.pound_token,
                    style: f.fold_attr_style(node.style),
                    bracket_token: node.bracket_token,
                    meta: f.fold_meta(node.meta),
                }
            }
            pub fn fold_bare_fn_arg<F>(f: &mut F, node: ::syntax::BareFnArg) -> ::syntax::BareFnArg where
                F: Fold + ?Sized,
            {
                ::syntax::BareFnArg {
                    attrs: f.fold_attributes(node.attrs),
                    name: (node.name).map(|it| (f.fold_ident((it).0), (it).1)),
                    ty: f.fold_type(node.ty),
                }
            }
            pub fn fold_bare_variadic<F>(f: &mut F, node: ::syntax::BareVariadic) -> ::syntax::BareVariadic where
                F: Fold + ?Sized,
            {
                ::syntax::BareVariadic {
                    attrs: f.fold_attributes(node.attrs),
                    name: (node.name).map(|it| (f.fold_ident((it).0), (it).1)),
                    dots: node.dots,
                    comma: node.comma,
                }
            }
            pub fn fold_bin_op<F>(f: &mut F, node: ::syntax::BinOp) -> ::syntax::BinOp where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::BinOp::Add(_binding_0) => ::syntax::BinOp::Add(_binding_0),
                    ::syntax::BinOp::Sub(_binding_0) => ::syntax::BinOp::Sub(_binding_0),
                    ::syntax::BinOp::Mul(_binding_0) => ::syntax::BinOp::Mul(_binding_0),
                    ::syntax::BinOp::Div(_binding_0) => ::syntax::BinOp::Div(_binding_0),
                    ::syntax::BinOp::Rem(_binding_0) => ::syntax::BinOp::Rem(_binding_0),
                    ::syntax::BinOp::And(_binding_0) => ::syntax::BinOp::And(_binding_0),
                    ::syntax::BinOp::Or(_binding_0) => ::syntax::BinOp::Or(_binding_0),
                    ::syntax::BinOp::BitXor(_binding_0) => ::syntax::BinOp::BitXor(_binding_0),
                    ::syntax::BinOp::BitAnd(_binding_0) => ::syntax::BinOp::BitAnd(_binding_0),
                    ::syntax::BinOp::BitOr(_binding_0) => ::syntax::BinOp::BitOr(_binding_0),
                    ::syntax::BinOp::Shl(_binding_0) => ::syntax::BinOp::Shl(_binding_0),
                    ::syntax::BinOp::Shr(_binding_0) => ::syntax::BinOp::Shr(_binding_0),
                    ::syntax::BinOp::Eq(_binding_0) => ::syntax::BinOp::Eq(_binding_0),
                    ::syntax::BinOp::Lt(_binding_0) => ::syntax::BinOp::Lt(_binding_0),
                    ::syntax::BinOp::Le(_binding_0) => ::syntax::BinOp::Le(_binding_0),
                    ::syntax::BinOp::Ne(_binding_0) => ::syntax::BinOp::Ne(_binding_0),
                    ::syntax::BinOp::Ge(_binding_0) => ::syntax::BinOp::Ge(_binding_0),
                    ::syntax::BinOp::Gt(_binding_0) => ::syntax::BinOp::Gt(_binding_0),
                    ::syntax::BinOp::AddAssign(_binding_0) => ::syntax::BinOp::AddAssign(_binding_0),
                    ::syntax::BinOp::SubAssign(_binding_0) => ::syntax::BinOp::SubAssign(_binding_0),
                    ::syntax::BinOp::MulAssign(_binding_0) => ::syntax::BinOp::MulAssign(_binding_0),
                    ::syntax::BinOp::DivAssign(_binding_0) => ::syntax::BinOp::DivAssign(_binding_0),
                    ::syntax::BinOp::RemAssign(_binding_0) => ::syntax::BinOp::RemAssign(_binding_0),
                    ::syntax::BinOp::BitXorAssign(_binding_0) => ::syntax::BinOp::BitXorAssign(_binding_0),
                    ::syntax::BinOp::BitAndAssign(_binding_0) => ::syntax::BinOp::BitAndAssign(_binding_0),
                    ::syntax::BinOp::BitOrAssign(_binding_0) => ::syntax::BinOp::BitOrAssign(_binding_0),
                    ::syntax::BinOp::ShlAssign(_binding_0) => ::syntax::BinOp::ShlAssign(_binding_0),
                    ::syntax::BinOp::ShrAssign(_binding_0) => ::syntax::BinOp::ShrAssign(_binding_0),
                }
            }
            pub fn fold_block<F>(f: &mut F, node: ::syntax::Block) -> ::syntax::Block where
                F: Fold + ?Sized,
            {
                ::syntax::Block {
                    brace_token: node.brace_token,
                    stmts: fold_vec(node.stmts, f, F::fold_stmt),
                }
            }
            pub fn fold_bound_lifetimes<F>(
                f: &mut F,
                node: ::syntax::BoundLifetimes,
            ) -> ::syntax::BoundLifetimes where
                F: Fold + ?Sized,
            {
                ::syntax::BoundLifetimes {
                    for_token: node.for_token,
                    lt_token: node.lt_token,
                    lifetimes: ::syntax::punctuated::fold(node.lifetimes, f, F::fold_generic_param),
                    gt_token: node.gt_token,
                }
            }
            pub fn fold_captured_param<F>(
                f: &mut F,
                node: ::syntax::CapturedParam,
            ) -> ::syntax::CapturedParam where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::CapturedParam::Lifetime(_binding_0) => {
                        ::syntax::CapturedParam::Lifetime(f.fold_lifetime(_binding_0))
                    }
                    ::syntax::CapturedParam::Ident(_binding_0) => {
                        ::syntax::CapturedParam::Ident(f.fold_ident(_binding_0))
                    }
                }
            }
            pub fn fold_const_param<F>(f: &mut F, node: ::syntax::ConstParam) -> ::syntax::ConstParam where
                F: Fold + ?Sized,
            {
                ::syntax::ConstParam {
                    attrs: f.fold_attributes(node.attrs),
                    const_token: node.const_token,
                    ident: f.fold_ident(node.ident),
                    colon_token: node.colon_token,
                    ty: f.fold_type(node.ty),
                    eq_token: node.eq_token,
                    default: (node.default).map(|it| f.fold_expr(it)),
                }
            }
            pub fn fold_constraint<F>(f: &mut F, node: ::syntax::Constraint) -> ::syntax::Constraint where
                F: Fold + ?Sized,
            {
                ::syntax::Constraint {
                    ident: f.fold_ident(node.ident),
                    generics: (node.generics).map(|it| f.fold_angle_bracketed_generic_arguments(it)),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                }
            }
            pub fn fold_data<F>(f: &mut F, node: ::syntax::Data) -> ::syntax::Data where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Data::Struct(_binding_0) => {
                        ::syntax::Data::Struct(f.fold_data_struct(_binding_0))
                    }
                    ::syntax::Data::Enum(_binding_0) => ::syntax::Data::Enum(f.fold_data_enum(_binding_0)),
                    ::syntax::Data::Union(_binding_0) => {
                        ::syntax::Data::Union(f.fold_data_union(_binding_0))
                    }
                }
            }
            pub fn fold_data_enum<F>(f: &mut F, node: ::syntax::DataEnum) -> ::syntax::DataEnum where
                F: Fold + ?Sized,
            {
                ::syntax::DataEnum {
                    enum_token: node.enum_token,
                    brace_token: node.brace_token,
                    variants: ::syntax::punctuated::fold(node.variants, f, F::fold_variant),
                }
            }
            pub fn fold_data_struct<F>(f: &mut F, node: ::syntax::DataStruct) -> ::syntax::DataStruct where
                F: Fold + ?Sized,
            {
                ::syntax::DataStruct {
                    struct_token: node.struct_token,
                    fields: f.fold_fields(node.fields),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_data_union<F>(f: &mut F, node: ::syntax::DataUnion) -> ::syntax::DataUnion where
                F: Fold + ?Sized,
            {
                ::syntax::DataUnion {
                    union_token: node.union_token,
                    fields: f.fold_fields_named(node.fields),
                }
            }
            pub fn fold_derive_input<F>(f: &mut F, node: ::syntax::DeriveInput) -> ::syntax::DeriveInput where
                F: Fold + ?Sized,
            {
                ::syntax::DeriveInput {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    data: f.fold_data(node.data),
                }
            }
            pub fn fold_expr<F>(f: &mut F, node: ::syntax::Expr) -> ::syntax::Expr where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Expr::Array(_binding_0) => {
                        ::syntax::Expr::Array(full!(f.fold_expr_array(_binding_0)))
                    }
                    ::syntax::Expr::Assign(_binding_0) => {
                        ::syntax::Expr::Assign(full!(f.fold_expr_assign(_binding_0)))
                    }
                    ::syntax::Expr::Async(_binding_0) => {
                        ::syntax::Expr::Async(full!(f.fold_expr_async(_binding_0)))
                    }
                    ::syntax::Expr::Await(_binding_0) => {
                        ::syntax::Expr::Await(full!(f.fold_expr_await(_binding_0)))
                    }
                    ::syntax::Expr::Binary(_binding_0) => {
                        ::syntax::Expr::Binary(f.fold_expr_binary(_binding_0))
                    }
                    ::syntax::Expr::Block(_binding_0) => {
                        ::syntax::Expr::Block(full!(f.fold_expr_block(_binding_0)))
                    }
                    ::syntax::Expr::Break(_binding_0) => {
                        ::syntax::Expr::Break(full!(f.fold_expr_break(_binding_0)))
                    }
                    ::syntax::Expr::Call(_binding_0) => ::syntax::Expr::Call(f.fold_expr_call(_binding_0)),
                    ::syntax::Expr::Cast(_binding_0) => ::syntax::Expr::Cast(f.fold_expr_cast(_binding_0)),
                    ::syntax::Expr::Closure(_binding_0) => {
                        ::syntax::Expr::Closure(full!(f.fold_expr_closure(_binding_0)))
                    }
                    ::syntax::Expr::Const(_binding_0) => {
                        ::syntax::Expr::Const(full!(f.fold_expr_const(_binding_0)))
                    }
                    ::syntax::Expr::Continue(_binding_0) => {
                        ::syntax::Expr::Continue(full!(f.fold_expr_continue(_binding_0)))
                    }
                    ::syntax::Expr::Field(_binding_0) => {
                        ::syntax::Expr::Field(f.fold_expr_field(_binding_0))
                    }
                    ::syntax::Expr::ForLoop(_binding_0) => {
                        ::syntax::Expr::ForLoop(full!(f.fold_expr_for_loop(_binding_0)))
                    }
                    ::syntax::Expr::Group(_binding_0) => {
                        ::syntax::Expr::Group(f.fold_expr_group(_binding_0))
                    }
                    ::syntax::Expr::If(_binding_0) => ::syntax::Expr::If(full!(f.fold_expr_if(_binding_0))),
                    ::syntax::Expr::Index(_binding_0) => {
                        ::syntax::Expr::Index(f.fold_expr_index(_binding_0))
                    }
                    ::syntax::Expr::Infer(_binding_0) => {
                        ::syntax::Expr::Infer(full!(f.fold_expr_infer(_binding_0)))
                    }
                    ::syntax::Expr::Let(_binding_0) => {
                        ::syntax::Expr::Let(full!(f.fold_expr_let(_binding_0)))
                    }
                    ::syntax::Expr::Lit(_binding_0) => ::syntax::Expr::Lit(f.fold_expr_lit(_binding_0)),
                    ::syntax::Expr::Loop(_binding_0) => {
                        ::syntax::Expr::Loop(full!(f.fold_expr_loop(_binding_0)))
                    }
                    ::syntax::Expr::Macro(_binding_0) => {
                        ::syntax::Expr::Macro(f.fold_expr_macro(_binding_0))
                    }
                    ::syntax::Expr::Match(_binding_0) => {
                        ::syntax::Expr::Match(full!(f.fold_expr_match(_binding_0)))
                    }
                    ::syntax::Expr::MethodCall(_binding_0) => {
                        ::syntax::Expr::MethodCall(f.fold_expr_method_call(_binding_0))
                    }
                    ::syntax::Expr::Paren(_binding_0) => {
                        ::syntax::Expr::Paren(f.fold_expr_paren(_binding_0))
                    }
                    ::syntax::Expr::Path(_binding_0) => ::syntax::Expr::Path(f.fold_expr_path(_binding_0)),
                    ::syntax::Expr::Range(_binding_0) => {
                        ::syntax::Expr::Range(full!(f.fold_expr_range(_binding_0)))
                    }
                    ::syntax::Expr::RawAddr(_binding_0) => {
                        ::syntax::Expr::RawAddr(full!(f.fold_expr_raw_addr(_binding_0)))
                    }
                    ::syntax::Expr::Reference(_binding_0) => {
                        ::syntax::Expr::Reference(f.fold_expr_reference(_binding_0))
                    }
                    ::syntax::Expr::Repeat(_binding_0) => {
                        ::syntax::Expr::Repeat(full!(f.fold_expr_repeat(_binding_0)))
                    }
                    ::syntax::Expr::Return(_binding_0) => {
                        ::syntax::Expr::Return(full!(f.fold_expr_return(_binding_0)))
                    }
                    ::syntax::Expr::Struct(_binding_0) => {
                        ::syntax::Expr::Struct(f.fold_expr_struct(_binding_0))
                    }
                    ::syntax::Expr::Try(_binding_0) => {
                        ::syntax::Expr::Try(full!(f.fold_expr_try(_binding_0)))
                    }
                    ::syntax::Expr::TryBlock(_binding_0) => {
                        ::syntax::Expr::TryBlock(full!(f.fold_expr_try_block(_binding_0)))
                    }
                    ::syntax::Expr::Tuple(_binding_0) => {
                        ::syntax::Expr::Tuple(f.fold_expr_tuple(_binding_0))
                    }
                    ::syntax::Expr::Unary(_binding_0) => {
                        ::syntax::Expr::Unary(f.fold_expr_unary(_binding_0))
                    }
                    ::syntax::Expr::Unsafe(_binding_0) => {
                        ::syntax::Expr::Unsafe(full!(f.fold_expr_unsafe(_binding_0)))
                    }
                    ::syntax::Expr::Verbatim(_binding_0) => {
                        ::syntax::Expr::Verbatim(f.fold_token_stream(_binding_0))
                    }
                    ::syntax::Expr::While(_binding_0) => {
                        ::syntax::Expr::While(full!(f.fold_expr_while(_binding_0)))
                    }
                    ::syntax::Expr::Yield(_binding_0) => {
                        ::syntax::Expr::Yield(full!(f.fold_expr_yield(_binding_0)))
                    }
                }
            }
            pub fn fold_expr_array<F>(f: &mut F, node: ::syntax::ExprArray) -> ::syntax::ExprArray where
                F: Fold + ?Sized,
            {
                ::syntax::ExprArray {
                    attrs: f.fold_attributes(node.attrs),
                    bracket_token: node.bracket_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_expr),
                }
            }
            pub fn fold_expr_assign<F>(f: &mut F, node: ::syntax::ExprAssign) -> ::syntax::ExprAssign where
                F: Fold + ?Sized,
            {
                ::syntax::ExprAssign {
                    attrs: f.fold_attributes(node.attrs),
                    left: Box::new(f.fold_expr(*node.left)),
                    eq_token: node.eq_token,
                    right: Box::new(f.fold_expr(*node.right)),
                }
            }
            pub fn fold_expr_async<F>(f: &mut F, node: ::syntax::ExprAsync) -> ::syntax::ExprAsync where
                F: Fold + ?Sized,
            {
                ::syntax::ExprAsync {
                    attrs: f.fold_attributes(node.attrs),
                    async_token: node.async_token,
                    capture: node.capture,
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_await<F>(f: &mut F, node: ::syntax::ExprAwait) -> ::syntax::ExprAwait where
                F: Fold + ?Sized,
            {
                ::syntax::ExprAwait {
                    attrs: f.fold_attributes(node.attrs),
                    base: Box::new(f.fold_expr(*node.base)),
                    dot_token: node.dot_token,
                    await_token: node.await_token,
                }
            }
            pub fn fold_expr_binary<F>(f: &mut F, node: ::syntax::ExprBinary) -> ::syntax::ExprBinary where
                F: Fold + ?Sized,
            {
                ::syntax::ExprBinary {
                    attrs: f.fold_attributes(node.attrs),
                    left: Box::new(f.fold_expr(*node.left)),
                    op: f.fold_bin_op(node.op),
                    right: Box::new(f.fold_expr(*node.right)),
                }
            }
            pub fn fold_expr_block<F>(f: &mut F, node: ::syntax::ExprBlock) -> ::syntax::ExprBlock where
                F: Fold + ?Sized,
            {
                ::syntax::ExprBlock {
                    attrs: f.fold_attributes(node.attrs),
                    label: (node.label).map(|it| f.fold_label(it)),
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_break<F>(f: &mut F, node: ::syntax::ExprBreak) -> ::syntax::ExprBreak where
                F: Fold + ?Sized,
            {
                ::syntax::ExprBreak {
                    attrs: f.fold_attributes(node.attrs),
                    break_token: node.break_token,
                    label: (node.label).map(|it| f.fold_lifetime(it)),
                    expr: (node.expr).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_expr_call<F>(f: &mut F, node: ::syntax::ExprCall) -> ::syntax::ExprCall where
                F: Fold + ?Sized,
            {
                ::syntax::ExprCall {
                    attrs: f.fold_attributes(node.attrs),
                    func: Box::new(f.fold_expr(*node.func)),
                    paren_token: node.paren_token,
                    args: ::syntax::punctuated::fold(node.args, f, F::fold_expr),
                }
            }
            pub fn fold_expr_cast<F>(f: &mut F, node: ::syntax::ExprCast) -> ::syntax::ExprCast where
                F: Fold + ?Sized,
            {
                ::syntax::ExprCast {
                    attrs: f.fold_attributes(node.attrs),
                    expr: Box::new(f.fold_expr(*node.expr)),
                    as_token: node.as_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                }
            }
            pub fn fold_expr_closure<F>(f: &mut F, node: ::syntax::ExprClosure) -> ::syntax::ExprClosure where
                F: Fold + ?Sized,
            {
                ::syntax::ExprClosure {
                    attrs: f.fold_attributes(node.attrs),
                    lifetimes: (node.lifetimes).map(|it| f.fold_bound_lifetimes(it)),
                    constness: node.constness,
                    movability: node.movability,
                    asyncness: node.asyncness,
                    capture: node.capture,
                    or1_token: node.or1_token,
                    inputs: ::syntax::punctuated::fold(node.inputs, f, F::fold_pat),
                    or2_token: node.or2_token,
                    output: f.fold_return_type(node.output),
                    body: Box::new(f.fold_expr(*node.body)),
                }
            }
            pub fn fold_expr_const<F>(f: &mut F, node: ::syntax::ExprConst) -> ::syntax::ExprConst where
                F: Fold + ?Sized,
            {
                ::syntax::ExprConst {
                    attrs: f.fold_attributes(node.attrs),
                    const_token: node.const_token,
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_continue<F>(f: &mut F, node: ::syntax::ExprContinue) -> ::syntax::ExprContinue where
                F: Fold + ?Sized,
            {
                ::syntax::ExprContinue {
                    attrs: f.fold_attributes(node.attrs),
                    continue_token: node.continue_token,
                    label: (node.label).map(|it| f.fold_lifetime(it)),
                }
            }
            pub fn fold_expr_field<F>(f: &mut F, node: ::syntax::ExprField) -> ::syntax::ExprField where
                F: Fold + ?Sized,
            {
                ::syntax::ExprField {
                    attrs: f.fold_attributes(node.attrs),
                    base: Box::new(f.fold_expr(*node.base)),
                    dot_token: node.dot_token,
                    member: f.fold_member(node.member),
                }
            }
            pub fn fold_expr_for_loop<F>(f: &mut F, node: ::syntax::ExprForLoop) -> ::syntax::ExprForLoop where
                F: Fold + ?Sized,
            {
                ::syntax::ExprForLoop {
                    attrs: f.fold_attributes(node.attrs),
                    label: (node.label).map(|it| f.fold_label(it)),
                    for_token: node.for_token,
                    pat: Box::new(f.fold_pat(*node.pat)),
                    in_token: node.in_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    body: f.fold_block(node.body),
                }
            }
            pub fn fold_expr_group<F>(f: &mut F, node: ::syntax::ExprGroup) -> ::syntax::ExprGroup where
                F: Fold + ?Sized,
            {
                ::syntax::ExprGroup {
                    attrs: f.fold_attributes(node.attrs),
                    group_token: node.group_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_if<F>(f: &mut F, node: ::syntax::ExprIf) -> ::syntax::ExprIf where
                F: Fold + ?Sized,
            {
                ::syntax::ExprIf {
                    attrs: f.fold_attributes(node.attrs),
                    if_token: node.if_token,
                    cond: Box::new(f.fold_expr(*node.cond)),
                    then_branch: f.fold_block(node.then_branch),
                    else_branch: (node.else_branch)
                        .map(|it| ((it).0, Box::new(f.fold_expr(*(it).1)))),
                }
            }
            pub fn fold_expr_index<F>(f: &mut F, node: ::syntax::ExprIndex) -> ::syntax::ExprIndex where
                F: Fold + ?Sized,
            {
                ::syntax::ExprIndex {
                    attrs: f.fold_attributes(node.attrs),
                    expr: Box::new(f.fold_expr(*node.expr)),
                    bracket_token: node.bracket_token,
                    index: Box::new(f.fold_expr(*node.index)),
                }
            }
            pub fn fold_expr_infer<F>(f: &mut F, node: ::syntax::ExprInfer) -> ::syntax::ExprInfer where
                F: Fold + ?Sized,
            {
                ::syntax::ExprInfer {
                    attrs: f.fold_attributes(node.attrs),
                    underscore_token: node.underscore_token,
                }
            }
            pub fn fold_expr_let<F>(f: &mut F, node: ::syntax::ExprLet) -> ::syntax::ExprLet where
                F: Fold + ?Sized,
            {
                ::syntax::ExprLet {
                    attrs: f.fold_attributes(node.attrs),
                    let_token: node.let_token,
                    pat: Box::new(f.fold_pat(*node.pat)),
                    eq_token: node.eq_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_lit<F>(f: &mut F, node: ::syntax::ExprLit) -> ::syntax::ExprLit where
                F: Fold + ?Sized,
            {
                ::syntax::ExprLit {
                    attrs: f.fold_attributes(node.attrs),
                    lit: f.fold_lit(node.lit),
                }
            }
            pub fn fold_expr_loop<F>(f: &mut F, node: ::syntax::ExprLoop) -> ::syntax::ExprLoop where
                F: Fold + ?Sized,
            {
                ::syntax::ExprLoop {
                    attrs: f.fold_attributes(node.attrs),
                    label: (node.label).map(|it| f.fold_label(it)),
                    loop_token: node.loop_token,
                    body: f.fold_block(node.body),
                }
            }
            pub fn fold_expr_macro<F>(f: &mut F, node: ::syntax::ExprMacro) -> ::syntax::ExprMacro where
                F: Fold + ?Sized,
            {
                ::syntax::ExprMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                }
            }
            pub fn fold_expr_match<F>(f: &mut F, node: ::syntax::ExprMatch) -> ::syntax::ExprMatch where
                F: Fold + ?Sized,
            {
                ::syntax::ExprMatch {
                    attrs: f.fold_attributes(node.attrs),
                    match_token: node.match_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    brace_token: node.brace_token,
                    arms: fold_vec(node.arms, f, F::fold_arm),
                }
            }
            pub fn fold_expr_method_call<F>(
                f: &mut F,
                node: ::syntax::ExprMethodCall,
            ) -> ::syntax::ExprMethodCall where
                F: Fold + ?Sized,
            {
                ::syntax::ExprMethodCall {
                    attrs: f.fold_attributes(node.attrs),
                    receiver: Box::new(f.fold_expr(*node.receiver)),
                    dot_token: node.dot_token,
                    method: f.fold_ident(node.method),
                    turbofish: (node.turbofish)
                        .map(|it| f.fold_angle_bracketed_generic_arguments(it)),
                    paren_token: node.paren_token,
                    args: ::syntax::punctuated::fold(node.args, f, F::fold_expr),
                }
            }
            pub fn fold_expr_paren<F>(f: &mut F, node: ::syntax::ExprParen) -> ::syntax::ExprParen where
                F: Fold + ?Sized,
            {
                ::syntax::ExprParen {
                    attrs: f.fold_attributes(node.attrs),
                    paren_token: node.paren_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_path<F>(f: &mut F, node: ::syntax::ExprPath) -> ::syntax::ExprPath where
                F: Fold + ?Sized,
            {
                ::syntax::ExprPath {
                    attrs: f.fold_attributes(node.attrs),
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                }
            }
            pub fn fold_expr_range<F>(f: &mut F, node: ::syntax::ExprRange) -> ::syntax::ExprRange where
                F: Fold + ?Sized,
            {
                ::syntax::ExprRange {
                    attrs: f.fold_attributes(node.attrs),
                    start: (node.start).map(|it| Box::new(f.fold_expr(*it))),
                    limits: f.fold_range_limits(node.limits),
                    end: (node.end).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_expr_raw_addr<F>(f: &mut F, node: ::syntax::ExprRawAddr) -> ::syntax::ExprRawAddr where
                F: Fold + ?Sized,
            {
                ::syntax::ExprRawAddr {
                    attrs: f.fold_attributes(node.attrs),
                    and_token: node.and_token,
                    raw: node.raw,
                    mutability: f.fold_pointer_mutability(node.mutability),
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_reference<F>(
                f: &mut F,
                node: ::syntax::ExprReference,
            ) -> ::syntax::ExprReference where
                F: Fold + ?Sized,
            {
                ::syntax::ExprReference {
                    attrs: f.fold_attributes(node.attrs),
                    and_token: node.and_token,
                    mutability: node.mutability,
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_repeat<F>(f: &mut F, node: ::syntax::ExprRepeat) -> ::syntax::ExprRepeat where
                F: Fold + ?Sized,
            {
                ::syntax::ExprRepeat {
                    attrs: f.fold_attributes(node.attrs),
                    bracket_token: node.bracket_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    semi_token: node.semi_token,
                    len: Box::new(f.fold_expr(*node.len)),
                }
            }
            pub fn fold_expr_return<F>(f: &mut F, node: ::syntax::ExprReturn) -> ::syntax::ExprReturn where
                F: Fold + ?Sized,
            {
                ::syntax::ExprReturn {
                    attrs: f.fold_attributes(node.attrs),
                    return_token: node.return_token,
                    expr: (node.expr).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_expr_struct<F>(f: &mut F, node: ::syntax::ExprStruct) -> ::syntax::ExprStruct where
                F: Fold + ?Sized,
            {
                ::syntax::ExprStruct {
                    attrs: f.fold_attributes(node.attrs),
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                    brace_token: node.brace_token,
                    fields: ::syntax::punctuated::fold(node.fields, f, F::fold_field_value),
                    dot2_token: node.dot2_token,
                    rest: (node.rest).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_expr_try<F>(f: &mut F, node: ::syntax::ExprTry) -> ::syntax::ExprTry where
                F: Fold + ?Sized,
            {
                ::syntax::ExprTry {
                    attrs: f.fold_attributes(node.attrs),
                    expr: Box::new(f.fold_expr(*node.expr)),
                    question_token: node.question_token,
                }
            }
            pub fn fold_expr_try_block<F>(
                f: &mut F,
                node: ::syntax::ExprTryBlock,
            ) -> ::syntax::ExprTryBlock where
                F: Fold + ?Sized,
            {
                ::syntax::ExprTryBlock {
                    attrs: f.fold_attributes(node.attrs),
                    try_token: node.try_token,
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_tuple<F>(f: &mut F, node: ::syntax::ExprTuple) -> ::syntax::ExprTuple where
                F: Fold + ?Sized,
            {
                ::syntax::ExprTuple {
                    attrs: f.fold_attributes(node.attrs),
                    paren_token: node.paren_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_expr),
                }
            }
            pub fn fold_expr_unary<F>(f: &mut F, node: ::syntax::ExprUnary) -> ::syntax::ExprUnary where
                F: Fold + ?Sized,
            {
                ::syntax::ExprUnary {
                    attrs: f.fold_attributes(node.attrs),
                    op: f.fold_un_op(node.op),
                    expr: Box::new(f.fold_expr(*node.expr)),
                }
            }
            pub fn fold_expr_unsafe<F>(f: &mut F, node: ::syntax::ExprUnsafe) -> ::syntax::ExprUnsafe where
                F: Fold + ?Sized,
            {
                ::syntax::ExprUnsafe {
                    attrs: f.fold_attributes(node.attrs),
                    unsafe_token: node.unsafe_token,
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_expr_while<F>(f: &mut F, node: ::syntax::ExprWhile) -> ::syntax::ExprWhile where
                F: Fold + ?Sized,
            {
                ::syntax::ExprWhile {
                    attrs: f.fold_attributes(node.attrs),
                    label: (node.label).map(|it| f.fold_label(it)),
                    while_token: node.while_token,
                    cond: Box::new(f.fold_expr(*node.cond)),
                    body: f.fold_block(node.body),
                }
            }
            pub fn fold_expr_yield<F>(f: &mut F, node: ::syntax::ExprYield) -> ::syntax::ExprYield where
                F: Fold + ?Sized,
            {
                ::syntax::ExprYield {
                    attrs: f.fold_attributes(node.attrs),
                    yield_token: node.yield_token,
                    expr: (node.expr).map(|it| Box::new(f.fold_expr(*it))),
                }
            }
            pub fn fold_field<F>(f: &mut F, node: ::syntax::Field) -> ::syntax::Field where
                F: Fold + ?Sized,
            {
                ::syntax::Field {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    mutability: f.fold_field_mutability(node.mutability),
                    ident: (node.ident).map(|it| f.fold_ident(it)),
                    colon_token: node.colon_token,
                    ty: f.fold_type(node.ty),
                }
            }
            pub fn fold_field_mutability<F>(
                f: &mut F,
                node: ::syntax::FieldMutability,
            ) -> ::syntax::FieldMutability where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::FieldMutability::None => ::syntax::FieldMutability::None,
                }
            }
            pub fn fold_field_pat<F>(f: &mut F, node: ::syntax::FieldPat) -> ::syntax::FieldPat where
                F: Fold + ?Sized,
            {
                ::syntax::FieldPat {
                    attrs: f.fold_attributes(node.attrs),
                    member: f.fold_member(node.member),
                    colon_token: node.colon_token,
                    pat: Box::new(f.fold_pat(*node.pat)),
                }
            }
            pub fn fold_field_value<F>(f: &mut F, node: ::syntax::FieldValue) -> ::syntax::FieldValue where
                F: Fold + ?Sized,
            {
                ::syntax::FieldValue {
                    attrs: f.fold_attributes(node.attrs),
                    member: f.fold_member(node.member),
                    colon_token: node.colon_token,
                    expr: f.fold_expr(node.expr),
                }
            }
            pub fn fold_fields<F>(f: &mut F, node: ::syntax::Fields) -> ::syntax::Fields where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Fields::Named(_binding_0) => {
                        ::syntax::Fields::Named(f.fold_fields_named(_binding_0))
                    }
                    ::syntax::Fields::Unnamed(_binding_0) => {
                        ::syntax::Fields::Unnamed(f.fold_fields_unnamed(_binding_0))
                    }
                    ::syntax::Fields::Unit => ::syntax::Fields::Unit,
                }
            }
            pub fn fold_fields_named<F>(f: &mut F, node: ::syntax::FieldsNamed) -> ::syntax::FieldsNamed where
                F: Fold + ?Sized,
            {
                ::syntax::FieldsNamed {
                    brace_token: node.brace_token,
                    named: ::syntax::punctuated::fold(node.named, f, F::fold_field),
                }
            }
            pub fn fold_fields_unnamed<F>(
                f: &mut F,
                node: ::syntax::FieldsUnnamed,
            ) -> ::syntax::FieldsUnnamed where
                F: Fold + ?Sized,
            {
                ::syntax::FieldsUnnamed {
                    paren_token: node.paren_token,
                    unnamed: ::syntax::punctuated::fold(node.unnamed, f, F::fold_field),
                }
            }
            pub fn fold_file<F>(f: &mut F, node: ::syntax::File) -> ::syntax::File where
                F: Fold + ?Sized,
            {
                ::syntax::File {
                    shebang: node.shebang,
                    attrs: f.fold_attributes(node.attrs),
                    items: fold_vec(node.items, f, F::fold_item),
                }
            }
            pub fn fold_fn_arg<F>(f: &mut F, node: ::syntax::FnArg) -> ::syntax::FnArg where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::FnArg::Receiver(_binding_0) => {
                        ::syntax::FnArg::Receiver(f.fold_receiver(_binding_0))
                    }
                    ::syntax::FnArg::Typed(_binding_0) => {
                        ::syntax::FnArg::Typed(f.fold_pat_type(_binding_0))
                    }
                }
            }
            pub fn fold_foreign_item<F>(f: &mut F, node: ::syntax::ForeignItem) -> ::syntax::ForeignItem where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::ForeignItem::Fn(_binding_0) => {
                        ::syntax::ForeignItem::Fn(f.fold_foreign_item_fn(_binding_0))
                    }
                    ::syntax::ForeignItem::Static(_binding_0) => {
                        ::syntax::ForeignItem::Static(f.fold_foreign_item_static(_binding_0))
                    }
                    ::syntax::ForeignItem::Type(_binding_0) => {
                        ::syntax::ForeignItem::Type(f.fold_foreign_item_type(_binding_0))
                    }
                    ::syntax::ForeignItem::Macro(_binding_0) => {
                        ::syntax::ForeignItem::Macro(f.fold_foreign_item_macro(_binding_0))
                    }
                    ::syntax::ForeignItem::Verbatim(_binding_0) => {
                        ::syntax::ForeignItem::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_foreign_item_fn<F>(
                f: &mut F,
                node: ::syntax::ForeignItemFn,
            ) -> ::syntax::ForeignItemFn where
                F: Fold + ?Sized,
            {
                ::syntax::ForeignItemFn {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    sig: f.fold_signature(node.sig),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_foreign_item_macro<F>(
                f: &mut F,
                node: ::syntax::ForeignItemMacro,
            ) -> ::syntax::ForeignItemMacro where
                F: Fold + ?Sized,
            {
                ::syntax::ForeignItemMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_foreign_item_static<F>(
                f: &mut F,
                node: ::syntax::ForeignItemStatic,
            ) -> ::syntax::ForeignItemStatic where
                F: Fold + ?Sized,
            {
                ::syntax::ForeignItemStatic {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    static_token: node.static_token,
                    mutability: f.fold_static_mutability(node.mutability),
                    ident: f.fold_ident(node.ident),
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_foreign_item_type<F>(
                f: &mut F,
                node: ::syntax::ForeignItemType,
            ) -> ::syntax::ForeignItemType where
                F: Fold + ?Sized,
            {
                ::syntax::ForeignItemType {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    type_token: node.type_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_generic_argument<F>(
                f: &mut F,
                node: ::syntax::GenericArgument,
            ) -> ::syntax::GenericArgument where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::GenericArgument::Lifetime(_binding_0) => {
                        ::syntax::GenericArgument::Lifetime(f.fold_lifetime(_binding_0))
                    }
                    ::syntax::GenericArgument::Type(_binding_0) => {
                        ::syntax::GenericArgument::Type(f.fold_type(_binding_0))
                    }
                    ::syntax::GenericArgument::Const(_binding_0) => {
                        ::syntax::GenericArgument::Const(f.fold_expr(_binding_0))
                    }
                    ::syntax::GenericArgument::AssocType(_binding_0) => {
                        ::syntax::GenericArgument::AssocType(f.fold_assoc_type(_binding_0))
                    }
                    ::syntax::GenericArgument::AssocConst(_binding_0) => {
                        ::syntax::GenericArgument::AssocConst(f.fold_assoc_const(_binding_0))
                    }
                    ::syntax::GenericArgument::Constraint(_binding_0) => {
                        ::syntax::GenericArgument::Constraint(f.fold_constraint(_binding_0))
                    }
                }
            }
            pub fn fold_generic_param<F>(f: &mut F, node: ::syntax::GenericParam) -> ::syntax::GenericParam where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::GenericParam::Lifetime(_binding_0) => {
                        ::syntax::GenericParam::Lifetime(f.fold_lifetime_param(_binding_0))
                    }
                    ::syntax::GenericParam::Type(_binding_0) => {
                        ::syntax::GenericParam::Type(f.fold_type_param(_binding_0))
                    }
                    ::syntax::GenericParam::Const(_binding_0) => {
                        ::syntax::GenericParam::Const(f.fold_const_param(_binding_0))
                    }
                }
            }
            pub fn fold_generics<F>(f: &mut F, node: ::syntax::Generics) -> ::syntax::Generics where
                F: Fold + ?Sized,
            {
                ::syntax::Generics {
                    lt_token: node.lt_token,
                    params: ::syntax::punctuated::fold(node.params, f, F::fold_generic_param),
                    gt_token: node.gt_token,
                    where_clause: (node.where_clause).map(|it| f.fold_where_clause(it)),
                }
            }
            pub fn fold_ident<F>(f: &mut F, node: process::macros::Ident) -> process::macros::Ident where
                F: Fold + ?Sized,
            {
                let mut node = node;
                let span = f.fold_span(node.span());
                node.set_span(span);
                node
            }
            pub fn fold_impl_item<F>(f: &mut F, node: ::syntax::ImplItem) -> ::syntax::ImplItem where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::ImplItem::Const(_binding_0) => {
                        ::syntax::ImplItem::Const(f.fold_impl_item_const(_binding_0))
                    }
                    ::syntax::ImplItem::Fn(_binding_0) => {
                        ::syntax::ImplItem::Fn(f.fold_impl_item_fn(_binding_0))
                    }
                    ::syntax::ImplItem::Type(_binding_0) => {
                        ::syntax::ImplItem::Type(f.fold_impl_item_type(_binding_0))
                    }
                    ::syntax::ImplItem::Macro(_binding_0) => {
                        ::syntax::ImplItem::Macro(f.fold_impl_item_macro(_binding_0))
                    }
                    ::syntax::ImplItem::Verbatim(_binding_0) => {
                        ::syntax::ImplItem::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_impl_item_const<F>(
                f: &mut F,
                node: ::syntax::ImplItemConst,
            ) -> ::syntax::ImplItemConst where
                F: Fold + ?Sized,
            {
                ::syntax::ImplItemConst {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    defaultness: node.defaultness,
                    const_token: node.const_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    ty: f.fold_type(node.ty),
                    eq_token: node.eq_token,
                    expr: f.fold_expr(node.expr),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_impl_item_fn<F>(f: &mut F, node: ::syntax::ImplItemFn) -> ::syntax::ImplItemFn where
                F: Fold + ?Sized,
            {
                ::syntax::ImplItemFn {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    defaultness: node.defaultness,
                    sig: f.fold_signature(node.sig),
                    block: f.fold_block(node.block),
                }
            }
            pub fn fold_impl_item_macro<F>(
                f: &mut F,
                node: ::syntax::ImplItemMacro,
            ) -> ::syntax::ImplItemMacro where
                F: Fold + ?Sized,
            {
                ::syntax::ImplItemMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_impl_item_type<F>(
                f: &mut F,
                node: ::syntax::ImplItemType,
            ) -> ::syntax::ImplItemType where
                F: Fold + ?Sized,
            {
                ::syntax::ImplItemType {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    defaultness: node.defaultness,
                    type_token: node.type_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    eq_token: node.eq_token,
                    ty: f.fold_type(node.ty),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_impl_restriction<F>(
                f: &mut F,
                node: ::syntax::ImplRestriction,
            ) -> ::syntax::ImplRestriction where
                F: Fold + ?Sized,
            {
                match node {}
            }
            pub fn fold_index<F>(f: &mut F, node: ::syntax::Index) -> ::syntax::Index where
                F: Fold + ?Sized,
            {
                ::syntax::Index {
                    index: node.index,
                    span: f.fold_span(node.span),
                }
            }
            pub fn fold_item<F>(f: &mut F, node: ::syntax::Item) -> ::syntax::Item where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Item::Const(_binding_0) => {
                        ::syntax::Item::Const(f.fold_item_const(_binding_0))
                    }
                    ::syntax::Item::Enum(_binding_0) => ::syntax::Item::Enum(f.fold_item_enum(_binding_0)),
                    ::syntax::Item::ExternCrate(_binding_0) => {
                        ::syntax::Item::ExternCrate(f.fold_item_extern_crate(_binding_0))
                    }
                    ::syntax::Item::Fn(_binding_0) => ::syntax::Item::Fn(f.fold_item_fn(_binding_0)),
                    ::syntax::Item::ForeignMod(_binding_0) => {
                        ::syntax::Item::ForeignMod(f.fold_item_foreign_mod(_binding_0))
                    }
                    ::syntax::Item::Impl(_binding_0) => ::syntax::Item::Impl(f.fold_item_impl(_binding_0)),
                    ::syntax::Item::Macro(_binding_0) => {
                        ::syntax::Item::Macro(f.fold_item_macro(_binding_0))
                    }
                    ::syntax::Item::Mod(_binding_0) => ::syntax::Item::Mod(f.fold_item_mod(_binding_0)),
                    ::syntax::Item::Static(_binding_0) => {
                        ::syntax::Item::Static(f.fold_item_static(_binding_0))
                    }
                    ::syntax::Item::Struct(_binding_0) => {
                        ::syntax::Item::Struct(f.fold_item_struct(_binding_0))
                    }
                    ::syntax::Item::Trait(_binding_0) => {
                        ::syntax::Item::Trait(f.fold_item_trait(_binding_0))
                    }
                    ::syntax::Item::TraitAlias(_binding_0) => {
                        ::syntax::Item::TraitAlias(f.fold_item_trait_alias(_binding_0))
                    }
                    ::syntax::Item::Type(_binding_0) => ::syntax::Item::Type(f.fold_item_type(_binding_0)),
                    ::syntax::Item::Union(_binding_0) => {
                        ::syntax::Item::Union(f.fold_item_union(_binding_0))
                    }
                    ::syntax::Item::Use(_binding_0) => ::syntax::Item::Use(f.fold_item_use(_binding_0)),
                    ::syntax::Item::Verbatim(_binding_0) => {
                        ::syntax::Item::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_item_const<F>(f: &mut F, node: ::syntax::ItemConst) -> ::syntax::ItemConst where
                F: Fold + ?Sized,
            {
                ::syntax::ItemConst {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    const_token: node.const_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    eq_token: node.eq_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_enum<F>(f: &mut F, node: ::syntax::ItemEnum) -> ::syntax::ItemEnum where
                F: Fold + ?Sized,
            {
                ::syntax::ItemEnum {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    enum_token: node.enum_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    brace_token: node.brace_token,
                    variants: ::syntax::punctuated::fold(node.variants, f, F::fold_variant),
                }
            }
            pub fn fold_item_extern_crate<F>(
                f: &mut F,
                node: ::syntax::ItemExternCrate,
            ) -> ::syntax::ItemExternCrate where
                F: Fold + ?Sized,
            {
                ::syntax::ItemExternCrate {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    extern_token: node.extern_token,
                    crate_token: node.crate_token,
                    ident: f.fold_ident(node.ident),
                    rename: (node.rename).map(|it| ((it).0, f.fold_ident((it).1))),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_fn<F>(f: &mut F, node: ::syntax::ItemFn) -> ::syntax::ItemFn where
                F: Fold + ?Sized,
            {
                ::syntax::ItemFn {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    sig: f.fold_signature(node.sig),
                    block: Box::new(f.fold_block(*node.block)),
                }
            }
            pub fn fold_item_foreign_mod<F>(
                f: &mut F,
                node: ::syntax::ItemForeignMod,
            ) -> ::syntax::ItemForeignMod where
                F: Fold + ?Sized,
            {
                ::syntax::ItemForeignMod {
                    attrs: f.fold_attributes(node.attrs),
                    unsafety: node.unsafety,
                    abi: f.fold_abi(node.abi),
                    brace_token: node.brace_token,
                    items: fold_vec(node.items, f, F::fold_foreign_item),
                }
            }
            pub fn fold_item_impl<F>(f: &mut F, node: ::syntax::ItemImpl) -> ::syntax::ItemImpl where
                F: Fold + ?Sized,
            {
                ::syntax::ItemImpl {
                    attrs: f.fold_attributes(node.attrs),
                    defaultness: node.defaultness,
                    unsafety: node.unsafety,
                    impl_token: node.impl_token,
                    generics: f.fold_generics(node.generics),
                    trait_: (node.trait_).map(|it| ((it).0, f.fold_path((it).1), (it).2)),
                    self_ty: Box::new(f.fold_type(*node.self_ty)),
                    brace_token: node.brace_token,
                    items: fold_vec(node.items, f, F::fold_impl_item),
                }
            }
            pub fn fold_item_macro<F>(f: &mut F, node: ::syntax::ItemMacro) -> ::syntax::ItemMacro where
                F: Fold + ?Sized,
            {
                ::syntax::ItemMacro {
                    attrs: f.fold_attributes(node.attrs),
                    ident: (node.ident).map(|it| f.fold_ident(it)),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_mod<F>(f: &mut F, node: ::syntax::ItemMod) -> ::syntax::ItemMod where
                F: Fold + ?Sized,
            {
                ::syntax::ItemMod {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    unsafety: node.unsafety,
                    mod_token: node.mod_token,
                    ident: f.fold_ident(node.ident),
                    content: (node.content).map(|it| ((it).0, fold_vec((it).1, f, F::fold_item))),
                    semi: node.semi,
                }
            }
            pub fn fold_item_static<F>(f: &mut F, node: ::syntax::ItemStatic) -> ::syntax::ItemStatic where
                F: Fold + ?Sized,
            {
                ::syntax::ItemStatic {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    static_token: node.static_token,
                    mutability: f.fold_static_mutability(node.mutability),
                    ident: f.fold_ident(node.ident),
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    eq_token: node.eq_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_struct<F>(f: &mut F, node: ::syntax::ItemStruct) -> ::syntax::ItemStruct where
                F: Fold + ?Sized,
            {
                ::syntax::ItemStruct {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    struct_token: node.struct_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    fields: f.fold_fields(node.fields),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_trait<F>(f: &mut F, node: ::syntax::ItemTrait) -> ::syntax::ItemTrait where
                F: Fold + ?Sized,
            {
                ::syntax::ItemTrait {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    unsafety: node.unsafety,
                    auto_token: node.auto_token,
                    restriction: (node.restriction).map(|it| f.fold_impl_restriction(it)),
                    trait_token: node.trait_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    supertraits: ::syntax::punctuated::fold(
                        node.supertraits,
                        f,
                        F::fold_type_param_bound,
                    ),
                    brace_token: node.brace_token,
                    items: fold_vec(node.items, f, F::fold_trait_item),
                }
            }
            pub fn fold_item_trait_alias<F>(
                f: &mut F,
                node: ::syntax::ItemTraitAlias,
            ) -> ::syntax::ItemTraitAlias where
                F: Fold + ?Sized,
            {
                ::syntax::ItemTraitAlias {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    trait_token: node.trait_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    eq_token: node.eq_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_type<F>(f: &mut F, node: ::syntax::ItemType) -> ::syntax::ItemType where
                F: Fold + ?Sized,
            {
                ::syntax::ItemType {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    type_token: node.type_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    eq_token: node.eq_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_item_union<F>(f: &mut F, node: ::syntax::ItemUnion) -> ::syntax::ItemUnion where
                F: Fold + ?Sized,
            {
                ::syntax::ItemUnion {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    union_token: node.union_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    fields: f.fold_fields_named(node.fields),
                }
            }
            pub fn fold_item_use<F>(f: &mut F, node: ::syntax::ItemUse) -> ::syntax::ItemUse where
                F: Fold + ?Sized,
            {
                ::syntax::ItemUse {
                    attrs: f.fold_attributes(node.attrs),
                    vis: f.fold_visibility(node.vis),
                    use_token: node.use_token,
                    leading_colon: node.leading_colon,
                    tree: f.fold_use_tree(node.tree),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_label<F>(f: &mut F, node: ::syntax::Label) -> ::syntax::Label where
                F: Fold + ?Sized,
            {
                ::syntax::Label {
                    name: f.fold_lifetime(node.name),
                    colon_token: node.colon_token,
                }
            }
            pub fn fold_lifetime<F>(f: &mut F, node: ::syntax::Lifetime) -> ::syntax::Lifetime where
                F: Fold + ?Sized,
            {
                ::syntax::Lifetime {
                    apostrophe: f.fold_span(node.apostrophe),
                    ident: f.fold_ident(node.ident),
                }
            }
            pub fn fold_lifetime_param<F>(
                f: &mut F,
                node: ::syntax::LifetimeParam,
            ) -> ::syntax::LifetimeParam where
                F: Fold + ?Sized,
            {
                ::syntax::LifetimeParam {
                    attrs: f.fold_attributes(node.attrs),
                    lifetime: f.fold_lifetime(node.lifetime),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_lifetime),
                }
            }
            pub fn fold_lit<F>(f: &mut F, node: ::syntax::Lit) -> ::syntax::Lit where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Lit::Str(_binding_0) => ::syntax::Lit::Str(f.fold_lit_str(_binding_0)),
                    ::syntax::Lit::ByteStr(_binding_0) => {
                        ::syntax::Lit::ByteStr(f.fold_lit_byte_str(_binding_0))
                    }
                    ::syntax::Lit::CStr(_binding_0) => ::syntax::Lit::CStr(f.fold_lit_cstr(_binding_0)),
                    ::syntax::Lit::Byte(_binding_0) => ::syntax::Lit::Byte(f.fold_lit_byte(_binding_0)),
                    ::syntax::Lit::Char(_binding_0) => ::syntax::Lit::Char(f.fold_lit_char(_binding_0)),
                    ::syntax::Lit::Int(_binding_0) => ::syntax::Lit::Int(f.fold_lit_int(_binding_0)),
                    ::syntax::Lit::Float(_binding_0) => ::syntax::Lit::Float(f.fold_lit_float(_binding_0)),
                    ::syntax::Lit::Bool(_binding_0) => ::syntax::Lit::Bool(f.fold_lit_bool(_binding_0)),
                    ::syntax::Lit::Verbatim(_binding_0) => ::syntax::Lit::Verbatim(_binding_0),
                }
            }
            pub fn fold_lit_bool<F>(f: &mut F, node: ::syntax::LitBool) -> ::syntax::LitBool where
                F: Fold + ?Sized,
            {
                ::syntax::LitBool {
                    value: node.value,
                    span: f.fold_span(node.span),
                }
            }
            pub fn fold_lit_byte<F>(f: &mut F, node: ::syntax::LitByte) -> ::syntax::LitByte where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_byte_str<F>(f: &mut F, node: ::syntax::LitByteStr) -> ::syntax::LitByteStr where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_cstr<F>(f: &mut F, node: ::syntax::LitCStr) -> ::syntax::LitCStr where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_char<F>(f: &mut F, node: ::syntax::LitChar) -> ::syntax::LitChar where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_float<F>(f: &mut F, node: ::syntax::LitFloat) -> ::syntax::LitFloat where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_int<F>(f: &mut F, node: ::syntax::LitInt) -> ::syntax::LitInt where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_lit_str<F>(f: &mut F, node: ::syntax::LitStr) -> ::syntax::LitStr where
                F: Fold + ?Sized,
            {
                let span = f.fold_span(node.span());
                let mut node = node;
                node.set_span(span);
                node
            }
            pub fn fold_local<F>(f: &mut F, node: ::syntax::Local) -> ::syntax::Local where
                F: Fold + ?Sized,
            {
                ::syntax::Local {
                    attrs: f.fold_attributes(node.attrs),
                    let_token: node.let_token,
                    pat: f.fold_pat(node.pat),
                    init: (node.init).map(|it| f.fold_local_init(it)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_local_init<F>(f: &mut F, node: ::syntax::LocalInit) -> ::syntax::LocalInit where
                F: Fold + ?Sized,
            {
                ::syntax::LocalInit {
                    eq_token: node.eq_token,
                    expr: Box::new(f.fold_expr(*node.expr)),
                    diverge: (node.diverge).map(|it| ((it).0, Box::new(f.fold_expr(*(it).1)))),
                }
            }
            pub fn fold_macro<F>(f: &mut F, node: ::syntax::Macro) -> ::syntax::Macro where
                F: Fold + ?Sized,
            {
                ::syntax::Macro {
                    path: f.fold_path(node.path),
                    bang_token: node.bang_token,
                    delimiter: f.fold_macro_delimiter(node.delimiter),
                    tokens: f.fold_token_stream(node.tokens),
                }
            }
            pub fn fold_macro_delimiter<F>(
                f: &mut F,
                node: ::syntax::MacroDelimiter,
            ) -> ::syntax::MacroDelimiter where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::MacroDelimiter::Paren(_binding_0) => {
                        ::syntax::MacroDelimiter::Paren(_binding_0)
                    }
                    ::syntax::MacroDelimiter::Brace(_binding_0) => {
                        ::syntax::MacroDelimiter::Brace(_binding_0)
                    }
                    ::syntax::MacroDelimiter::Bracket(_binding_0) => {
                        ::syntax::MacroDelimiter::Bracket(_binding_0)
                    }
                }
            }
            pub fn fold_member<F>(f: &mut F, node: ::syntax::Member) -> ::syntax::Member where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Member::Named(_binding_0) => {
                        ::syntax::Member::Named(f.fold_ident(_binding_0))
                    }
                    ::syntax::Member::Unnamed(_binding_0) => {
                        ::syntax::Member::Unnamed(f.fold_index(_binding_0))
                    }
                }
            }
            pub fn fold_meta<F>(f: &mut F, node: ::syntax::Meta) -> ::syntax::Meta where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Meta::Path(_binding_0) => ::syntax::Meta::Path(f.fold_path(_binding_0)),
                    ::syntax::Meta::List(_binding_0) => ::syntax::Meta::List(f.fold_meta_list(_binding_0)),
                    ::syntax::Meta::NameValue(_binding_0) => {
                        ::syntax::Meta::NameValue(f.fold_meta_name_value(_binding_0))
                    }
                }
            }
            pub fn fold_meta_list<F>(f: &mut F, node: ::syntax::MetaList) -> ::syntax::MetaList where
                F: Fold + ?Sized,
            {
                ::syntax::MetaList {
                    path: f.fold_path(node.path),
                    delimiter: f.fold_macro_delimiter(node.delimiter),
                    tokens: f.fold_token_stream(node.tokens),
                }
            }
            pub fn fold_meta_name_value<F>(
                f: &mut F,
                node: ::syntax::MetaNameValue,
            ) -> ::syntax::MetaNameValue where
                F: Fold + ?Sized,
            {
                ::syntax::MetaNameValue {
                    path: f.fold_path(node.path),
                    eq_token: node.eq_token,
                    value: f.fold_expr(node.value),
                }
            }
            pub fn fold_parenthesized_generic_arguments<F>(
                f: &mut F,
                node: ::syntax::ParenthesizedGenericArguments,
            ) -> ::syntax::ParenthesizedGenericArguments where
                F: Fold + ?Sized,
            {
                ::syntax::ParenthesizedGenericArguments {
                    paren_token: node.paren_token,
                    inputs: ::syntax::punctuated::fold(node.inputs, f, F::fold_type),
                    output: f.fold_return_type(node.output),
                }
            }
            pub fn fold_pat<F>(f: &mut F, node: ::syntax::Pat) -> ::syntax::Pat where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Pat::Const(_binding_0) => ::syntax::Pat::Const(f.fold_expr_const(_binding_0)),
                    ::syntax::Pat::Ident(_binding_0) => ::syntax::Pat::Ident(f.fold_pat_ident(_binding_0)),
                    ::syntax::Pat::Lit(_binding_0) => ::syntax::Pat::Lit(f.fold_expr_lit(_binding_0)),
                    ::syntax::Pat::Macro(_binding_0) => ::syntax::Pat::Macro(f.fold_expr_macro(_binding_0)),
                    ::syntax::Pat::Or(_binding_0) => ::syntax::Pat::Or(f.fold_pat_or(_binding_0)),
                    ::syntax::Pat::Paren(_binding_0) => ::syntax::Pat::Paren(f.fold_pat_paren(_binding_0)),
                    ::syntax::Pat::Path(_binding_0) => ::syntax::Pat::Path(f.fold_expr_path(_binding_0)),
                    ::syntax::Pat::Range(_binding_0) => ::syntax::Pat::Range(f.fold_expr_range(_binding_0)),
                    ::syntax::Pat::Reference(_binding_0) => {
                        ::syntax::Pat::Reference(f.fold_pat_reference(_binding_0))
                    }
                    ::syntax::Pat::Rest(_binding_0) => ::syntax::Pat::Rest(f.fold_pat_rest(_binding_0)),
                    ::syntax::Pat::Slice(_binding_0) => ::syntax::Pat::Slice(f.fold_pat_slice(_binding_0)),
                    ::syntax::Pat::Struct(_binding_0) => {
                        ::syntax::Pat::Struct(f.fold_pat_struct(_binding_0))
                    }
                    ::syntax::Pat::Tuple(_binding_0) => ::syntax::Pat::Tuple(f.fold_pat_tuple(_binding_0)),
                    ::syntax::Pat::TupleStruct(_binding_0) => {
                        ::syntax::Pat::TupleStruct(f.fold_pat_tuple_struct(_binding_0))
                    }
                    ::syntax::Pat::Type(_binding_0) => ::syntax::Pat::Type(f.fold_pat_type(_binding_0)),
                    ::syntax::Pat::Verbatim(_binding_0) => {
                        ::syntax::Pat::Verbatim(f.fold_token_stream(_binding_0))
                    }
                    ::syntax::Pat::Wild(_binding_0) => ::syntax::Pat::Wild(f.fold_pat_wild(_binding_0)),
                }
            }
            pub fn fold_pat_ident<F>(f: &mut F, node: ::syntax::PatIdent) -> ::syntax::PatIdent where
                F: Fold + ?Sized,
            {
                ::syntax::PatIdent {
                    attrs: f.fold_attributes(node.attrs),
                    by_ref: node.by_ref,
                    mutability: node.mutability,
                    ident: f.fold_ident(node.ident),
                    subpat: (node.subpat).map(|it| ((it).0, Box::new(f.fold_pat(*(it).1)))),
                }
            }
            pub fn fold_pat_or<F>(f: &mut F, node: ::syntax::PatOr) -> ::syntax::PatOr where
                F: Fold + ?Sized,
            {
                ::syntax::PatOr {
                    attrs: f.fold_attributes(node.attrs),
                    leading_vert: node.leading_vert,
                    cases: ::syntax::punctuated::fold(node.cases, f, F::fold_pat),
                }
            }
            pub fn fold_pat_paren<F>(f: &mut F, node: ::syntax::PatParen) -> ::syntax::PatParen where
                F: Fold + ?Sized,
            {
                ::syntax::PatParen {
                    attrs: f.fold_attributes(node.attrs),
                    paren_token: node.paren_token,
                    pat: Box::new(f.fold_pat(*node.pat)),
                }
            }
            pub fn fold_pat_reference<F>(f: &mut F, node: ::syntax::PatReference) -> ::syntax::PatReference where
                F: Fold + ?Sized,
            {
                ::syntax::PatReference {
                    attrs: f.fold_attributes(node.attrs),
                    and_token: node.and_token,
                    mutability: node.mutability,
                    pat: Box::new(f.fold_pat(*node.pat)),
                }
            }
            pub fn fold_pat_rest<F>(f: &mut F, node: ::syntax::PatRest) -> ::syntax::PatRest where
                F: Fold + ?Sized,
            {
                ::syntax::PatRest {
                    attrs: f.fold_attributes(node.attrs),
                    dot2_token: node.dot2_token,
                }
            }
            pub fn fold_pat_slice<F>(f: &mut F, node: ::syntax::PatSlice) -> ::syntax::PatSlice where
                F: Fold + ?Sized,
            {
                ::syntax::PatSlice {
                    attrs: f.fold_attributes(node.attrs),
                    bracket_token: node.bracket_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_pat),
                }
            }
            pub fn fold_pat_struct<F>(f: &mut F, node: ::syntax::PatStruct) -> ::syntax::PatStruct where
                F: Fold + ?Sized,
            {
                ::syntax::PatStruct {
                    attrs: f.fold_attributes(node.attrs),
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                    brace_token: node.brace_token,
                    fields: ::syntax::punctuated::fold(node.fields, f, F::fold_field_pat),
                    rest: (node.rest).map(|it| f.fold_pat_rest(it)),
                }
            }
            pub fn fold_pat_tuple<F>(f: &mut F, node: ::syntax::PatTuple) -> ::syntax::PatTuple where
                F: Fold + ?Sized,
            {
                ::syntax::PatTuple {
                    attrs: f.fold_attributes(node.attrs),
                    paren_token: node.paren_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_pat),
                }
            }
            pub fn fold_pat_tuple_struct<F>(
                f: &mut F,
                node: ::syntax::PatTupleStruct,
            ) -> ::syntax::PatTupleStruct where
                F: Fold + ?Sized,
            {
                ::syntax::PatTupleStruct {
                    attrs: f.fold_attributes(node.attrs),
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                    paren_token: node.paren_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_pat),
                }
            }
            pub fn fold_pat_type<F>(f: &mut F, node: ::syntax::PatType) -> ::syntax::PatType where
                F: Fold + ?Sized,
            {
                ::syntax::PatType {
                    attrs: f.fold_attributes(node.attrs),
                    pat: Box::new(f.fold_pat(*node.pat)),
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                }
            }
            pub fn fold_pat_wild<F>(f: &mut F, node: ::syntax::PatWild) -> ::syntax::PatWild where
                F: Fold + ?Sized,
            {
                ::syntax::PatWild {
                    attrs: f.fold_attributes(node.attrs),
                    underscore_token: node.underscore_token,
                }
            }
            pub fn fold_path<F>(f: &mut F, node: ::syntax::Path) -> ::syntax::Path where
                F: Fold + ?Sized,
            {
                ::syntax::Path {
                    leading_colon: node.leading_colon,
                    segments: ::syntax::punctuated::fold(node.segments, f, F::fold_path_segment),
                }
            }
            pub fn fold_path_arguments<F>(
                f: &mut F,
                node: ::syntax::PathArguments,
            ) -> ::syntax::PathArguments where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::PathArguments::None => ::syntax::PathArguments::None,
                    ::syntax::PathArguments::AngleBracketed(_binding_0) => {
                        ::syntax::PathArguments::AngleBracketed(
                            f.fold_angle_bracketed_generic_arguments(_binding_0),
                        )
                    }
                    ::syntax::PathArguments::Parenthesized(_binding_0) => {
                        ::syntax::PathArguments::Parenthesized(
                            f.fold_parenthesized_generic_arguments(_binding_0),
                        )
                    }
                }
            }
            pub fn fold_path_segment<F>(f: &mut F, node: ::syntax::PathSegment) -> ::syntax::PathSegment where
                F: Fold + ?Sized,
            {
                ::syntax::PathSegment {
                    ident: f.fold_ident(node.ident),
                    arguments: f.fold_path_arguments(node.arguments),
                }
            }
            pub fn fold_pointer_mutability<F>(
                f: &mut F,
                node: ::syntax::PointerMutability,
            ) -> ::syntax::PointerMutability where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::PointerMutability::Const(_binding_0) => {
                        ::syntax::PointerMutability::Const(_binding_0)
                    }
                    ::syntax::PointerMutability::Mut(_binding_0) => {
                        ::syntax::PointerMutability::Mut(_binding_0)
                    }
                }
            }
            pub fn fold_precise_capture<F>(
                f: &mut F,
                node: ::syntax::PreciseCapture,
            ) -> ::syntax::PreciseCapture where
                F: Fold + ?Sized,
            {
                ::syntax::PreciseCapture {
                    use_token: node.use_token,
                    lt_token: node.lt_token,
                    params: ::syntax::punctuated::fold(node.params, f, F::fold_captured_param),
                    gt_token: node.gt_token,
                }
            }
            pub fn fold_predicate_lifetime<F>(
                f: &mut F,
                node: ::syntax::PredicateLifetime,
            ) -> ::syntax::PredicateLifetime where
                F: Fold + ?Sized,
            {
                ::syntax::PredicateLifetime {
                    lifetime: f.fold_lifetime(node.lifetime),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_lifetime),
                }
            }
            pub fn fold_predicate_type<F>(
                f: &mut F,
                node: ::syntax::PredicateType,
            ) -> ::syntax::PredicateType where
                F: Fold + ?Sized,
            {
                ::syntax::PredicateType {
                    lifetimes: (node.lifetimes).map(|it| f.fold_bound_lifetimes(it)),
                    bounded_ty: f.fold_type(node.bounded_ty),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                }
            }
            pub fn fold_qself<F>(f: &mut F, node: ::syntax::QSelf) -> ::syntax::QSelf where
                F: Fold + ?Sized,
            {
                ::syntax::QSelf {
                    lt_token: node.lt_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                    position: node.position,
                    as_token: node.as_token,
                    gt_token: node.gt_token,
                }
            }
            pub fn fold_range_limits<F>(f: &mut F, node: ::syntax::RangeLimits) -> ::syntax::RangeLimits where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::RangeLimits::HalfOpen(_binding_0) => {
                        ::syntax::RangeLimits::HalfOpen(_binding_0)
                    }
                    ::syntax::RangeLimits::Closed(_binding_0) => ::syntax::RangeLimits::Closed(_binding_0),
                }
            }
            pub fn fold_receiver<F>(f: &mut F, node: ::syntax::Receiver) -> ::syntax::Receiver where
                F: Fold + ?Sized,
            {
                ::syntax::Receiver {
                    attrs: f.fold_attributes(node.attrs),
                    reference: (node.reference)
                        .map(|it| ((it).0, ((it).1).map(|it| f.fold_lifetime(it)))),
                    mutability: node.mutability,
                    self_token: node.self_token,
                    colon_token: node.colon_token,
                    ty: Box::new(f.fold_type(*node.ty)),
                }
            }
            pub fn fold_return_type<F>(f: &mut F, node: ::syntax::ReturnType) -> ::syntax::ReturnType where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::ReturnType::Default => ::syntax::ReturnType::Default,
                    ::syntax::ReturnType::Type(_binding_0, _binding_1) => {
                        ::syntax::ReturnType::Type(_binding_0, Box::new(f.fold_type(*_binding_1)))
                    }
                }
            }
            pub fn fold_signature<F>(f: &mut F, node: ::syntax::Signature) -> ::syntax::Signature where
                F: Fold + ?Sized,
            {
                ::syntax::Signature {
                    constness: node.constness,
                    asyncness: node.asyncness,
                    unsafety: node.unsafety,
                    abi: (node.abi).map(|it| f.fold_abi(it)),
                    fn_token: node.fn_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    paren_token: node.paren_token,
                    inputs: ::syntax::punctuated::fold(node.inputs, f, F::fold_fn_arg),
                    variadic: (node.variadic).map(|it| f.fold_variadic(it)),
                    output: f.fold_return_type(node.output),
                }
            }
            pub fn fold_span<F>(f: &mut F, node: process::macros::Span) -> process::macros::Span where
                F: Fold + ?Sized,
            {
                node
            }
            pub fn fold_static_mutability<F>(
                f: &mut F,
                node: ::syntax::StaticMutability,
            ) -> ::syntax::StaticMutability where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::StaticMutability::Mut(_binding_0) => {
                        ::syntax::StaticMutability::Mut(_binding_0)
                    }
                    ::syntax::StaticMutability::None => ::syntax::StaticMutability::None,
                }
            }
            pub fn fold_stmt<F>(f: &mut F, node: ::syntax::Stmt) -> ::syntax::Stmt where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Stmt::Local(_binding_0) => ::syntax::Stmt::Local(f.fold_local(_binding_0)),
                    ::syntax::Stmt::Item(_binding_0) => ::syntax::Stmt::Item(f.fold_item(_binding_0)),
                    ::syntax::Stmt::Expr(_binding_0, _binding_1) => {
                        ::syntax::Stmt::Expr(f.fold_expr(_binding_0), _binding_1)
                    }
                    ::syntax::Stmt::Macro(_binding_0) => {
                        ::syntax::Stmt::Macro(f.fold_stmt_macro(_binding_0))
                    }
                }
            }
            pub fn fold_stmt_macro<F>(f: &mut F, node: ::syntax::StmtMacro) -> ::syntax::StmtMacro where
                F: Fold + ?Sized,
            {
                ::syntax::StmtMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_trait_bound<F>(f: &mut F, node: ::syntax::TraitBound) -> ::syntax::TraitBound where
                F: Fold + ?Sized,
            {
                ::syntax::TraitBound {
                    paren_token: node.paren_token,
                    modifier: f.fold_trait_bound_modifier(node.modifier),
                    lifetimes: (node.lifetimes).map(|it| f.fold_bound_lifetimes(it)),
                    path: f.fold_path(node.path),
                }
            }
            pub fn fold_trait_bound_modifier<F>(
                f: &mut F,
                node: ::syntax::TraitBoundModifier,
            ) -> ::syntax::TraitBoundModifier where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::TraitBoundModifier::None => ::syntax::TraitBoundModifier::None,
                    ::syntax::TraitBoundModifier::Maybe(_binding_0) => {
                        ::syntax::TraitBoundModifier::Maybe(_binding_0)
                    }
                }
            }
            pub fn fold_trait_item<F>(f: &mut F, node: ::syntax::TraitItem) -> ::syntax::TraitItem where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::TraitItem::Const(_binding_0) => {
                        ::syntax::TraitItem::Const(f.fold_trait_item_const(_binding_0))
                    }
                    ::syntax::TraitItem::Fn(_binding_0) => {
                        ::syntax::TraitItem::Fn(f.fold_trait_item_fn(_binding_0))
                    }
                    ::syntax::TraitItem::Type(_binding_0) => {
                        ::syntax::TraitItem::Type(f.fold_trait_item_type(_binding_0))
                    }
                    ::syntax::TraitItem::Macro(_binding_0) => {
                        ::syntax::TraitItem::Macro(f.fold_trait_item_macro(_binding_0))
                    }
                    ::syntax::TraitItem::Verbatim(_binding_0) => {
                        ::syntax::TraitItem::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_trait_item_const<F>(
                f: &mut F,
                node: ::syntax::TraitItemConst,
            ) -> ::syntax::TraitItemConst where
                F: Fold + ?Sized,
            {
                ::syntax::TraitItemConst {
                    attrs: f.fold_attributes(node.attrs),
                    const_token: node.const_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    ty: f.fold_type(node.ty),
                    default: (node.default).map(|it| ((it).0, f.fold_expr((it).1))),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_trait_item_fn<F>(f: &mut F, node: ::syntax::TraitItemFn) -> ::syntax::TraitItemFn where
                F: Fold + ?Sized,
            {
                ::syntax::TraitItemFn {
                    attrs: f.fold_attributes(node.attrs),
                    sig: f.fold_signature(node.sig),
                    default: (node.default).map(|it| f.fold_block(it)),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_trait_item_macro<F>(
                f: &mut F,
                node: ::syntax::TraitItemMacro,
            ) -> ::syntax::TraitItemMacro where
                F: Fold + ?Sized,
            {
                ::syntax::TraitItemMacro {
                    attrs: f.fold_attributes(node.attrs),
                    mac: f.fold_macro(node.mac),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_trait_item_type<F>(
                f: &mut F,
                node: ::syntax::TraitItemType,
            ) -> ::syntax::TraitItemType where
                F: Fold + ?Sized,
            {
                ::syntax::TraitItemType {
                    attrs: f.fold_attributes(node.attrs),
                    type_token: node.type_token,
                    ident: f.fold_ident(node.ident),
                    generics: f.fold_generics(node.generics),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                    default: (node.default).map(|it| ((it).0, f.fold_type((it).1))),
                    semi_token: node.semi_token,
                }
            }
            pub fn fold_type<F>(f: &mut F, node: ::syntax::Type) -> ::syntax::Type where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Type::Array(_binding_0) => {
                        ::syntax::Type::Array(f.fold_type_array(_binding_0))
                    }
                    ::syntax::Type::BareFn(_binding_0) => {
                        ::syntax::Type::BareFn(f.fold_type_bare_fn(_binding_0))
                    }
                    ::syntax::Type::Group(_binding_0) => {
                        ::syntax::Type::Group(f.fold_type_group(_binding_0))
                    }
                    ::syntax::Type::ImplTrait(_binding_0) => {
                        ::syntax::Type::ImplTrait(f.fold_type_impl_trait(_binding_0))
                    }
                    ::syntax::Type::Infer(_binding_0) => {
                        ::syntax::Type::Infer(f.fold_type_infer(_binding_0))
                    }
                    ::syntax::Type::Macro(_binding_0) => {
                        ::syntax::Type::Macro(f.fold_type_macro(_binding_0))
                    }
                    ::syntax::Type::Never(_binding_0) => {
                        ::syntax::Type::Never(f.fold_type_never(_binding_0))
                    }
                    ::syntax::Type::Paren(_binding_0) => {
                        ::syntax::Type::Paren(f.fold_type_paren(_binding_0))
                    }
                    ::syntax::Type::Path(_binding_0) => ::syntax::Type::Path(f.fold_type_path(_binding_0)),
                    ::syntax::Type::Ptr(_binding_0) => ::syntax::Type::Ptr(f.fold_type_ptr(_binding_0)),
                    ::syntax::Type::Reference(_binding_0) => {
                        ::syntax::Type::Reference(f.fold_type_reference(_binding_0))
                    }
                    ::syntax::Type::Slice(_binding_0) => {
                        ::syntax::Type::Slice(f.fold_type_slice(_binding_0))
                    }
                    ::syntax::Type::TraitObject(_binding_0) => {
                        ::syntax::Type::TraitObject(f.fold_type_trait_object(_binding_0))
                    }
                    ::syntax::Type::Tuple(_binding_0) => {
                        ::syntax::Type::Tuple(f.fold_type_tuple(_binding_0))
                    }
                    ::syntax::Type::Verbatim(_binding_0) => {
                        ::syntax::Type::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_type_array<F>(f: &mut F, node: ::syntax::TypeArray) -> ::syntax::TypeArray where
                F: Fold + ?Sized,
            {
                ::syntax::TypeArray {
                    bracket_token: node.bracket_token,
                    elem: Box::new(f.fold_type(*node.elem)),
                    semi_token: node.semi_token,
                    len: f.fold_expr(node.len),
                }
            }
            pub fn fold_type_bare_fn<F>(f: &mut F, node: ::syntax::TypeBareFn) -> ::syntax::TypeBareFn where
                F: Fold + ?Sized,
            {
                ::syntax::TypeBareFn {
                    lifetimes: (node.lifetimes).map(|it| f.fold_bound_lifetimes(it)),
                    unsafety: node.unsafety,
                    abi: (node.abi).map(|it| f.fold_abi(it)),
                    fn_token: node.fn_token,
                    paren_token: node.paren_token,
                    inputs: ::syntax::punctuated::fold(node.inputs, f, F::fold_bare_fn_arg),
                    variadic: (node.variadic).map(|it| f.fold_bare_variadic(it)),
                    output: f.fold_return_type(node.output),
                }
            }
            pub fn fold_type_group<F>(f: &mut F, node: ::syntax::TypeGroup) -> ::syntax::TypeGroup where
                F: Fold + ?Sized,
            {
                ::syntax::TypeGroup {
                    group_token: node.group_token,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_impl_trait<F>(
                f: &mut F,
                node: ::syntax::TypeImplTrait,
            ) -> ::syntax::TypeImplTrait where
                F: Fold + ?Sized,
            {
                ::syntax::TypeImplTrait {
                    impl_token: node.impl_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                }
            }
            pub fn fold_type_infer<F>(f: &mut F, node: ::syntax::TypeInfer) -> ::syntax::TypeInfer where
                F: Fold + ?Sized,
            {
                ::syntax::TypeInfer {
                    underscore_token: node.underscore_token,
                }
            }
            pub fn fold_type_macro<F>(f: &mut F, node: ::syntax::TypeMacro) -> ::syntax::TypeMacro where
                F: Fold + ?Sized,
            {
                ::syntax::TypeMacro {
                    mac: f.fold_macro(node.mac),
                }
            }
            pub fn fold_type_never<F>(f: &mut F, node: ::syntax::TypeNever) -> ::syntax::TypeNever where
                F: Fold + ?Sized,
            {
                ::syntax::TypeNever {
                    bang_token: node.bang_token,
                }
            }
            pub fn fold_type_param<F>(f: &mut F, node: ::syntax::TypeParam) -> ::syntax::TypeParam where
                F: Fold + ?Sized,
            {
                ::syntax::TypeParam {
                    attrs: f.fold_attributes(node.attrs),
                    ident: f.fold_ident(node.ident),
                    colon_token: node.colon_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                    eq_token: node.eq_token,
                    default: (node.default).map(|it| f.fold_type(it)),
                }
            }
            pub fn fold_type_param_bound<F>(
                f: &mut F,
                node: ::syntax::TypeParamBound,
            ) -> ::syntax::TypeParamBound where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::TypeParamBound::Trait(_binding_0) => {
                        ::syntax::TypeParamBound::Trait(f.fold_trait_bound(_binding_0))
                    }
                    ::syntax::TypeParamBound::Lifetime(_binding_0) => {
                        ::syntax::TypeParamBound::Lifetime(f.fold_lifetime(_binding_0))
                    }
                    ::syntax::TypeParamBound::PreciseCapture(_binding_0) => {
                        ::syntax::TypeParamBound::PreciseCapture(
                            full!(f.fold_precise_capture(_binding_0)),
                        )
                    }
                    ::syntax::TypeParamBound::Verbatim(_binding_0) => {
                        ::syntax::TypeParamBound::Verbatim(f.fold_token_stream(_binding_0))
                    }
                }
            }
            pub fn fold_type_paren<F>(f: &mut F, node: ::syntax::TypeParen) -> ::syntax::TypeParen where
                F: Fold + ?Sized,
            {
                ::syntax::TypeParen {
                    paren_token: node.paren_token,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_path<F>(f: &mut F, node: ::syntax::TypePath) -> ::syntax::TypePath where
                F: Fold + ?Sized,
            {
                ::syntax::TypePath {
                    qself: (node.qself).map(|it| f.fold_qself(it)),
                    path: f.fold_path(node.path),
                }
            }
            pub fn fold_type_ptr<F>(f: &mut F, node: ::syntax::TypePtr) -> ::syntax::TypePtr where
                F: Fold + ?Sized,
            {
                ::syntax::TypePtr {
                    star_token: node.star_token,
                    const_token: node.const_token,
                    mutability: node.mutability,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_reference<F>(
                f: &mut F,
                node: ::syntax::TypeReference,
            ) -> ::syntax::TypeReference where
                F: Fold + ?Sized,
            {
                ::syntax::TypeReference {
                    and_token: node.and_token,
                    lifetime: (node.lifetime).map(|it| f.fold_lifetime(it)),
                    mutability: node.mutability,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_slice<F>(f: &mut F, node: ::syntax::TypeSlice) -> ::syntax::TypeSlice where
                F: Fold + ?Sized,
            {
                ::syntax::TypeSlice {
                    bracket_token: node.bracket_token,
                    elem: Box::new(f.fold_type(*node.elem)),
                }
            }
            pub fn fold_type_trait_object<F>(
                f: &mut F,
                node: ::syntax::TypeTraitObject,
            ) -> ::syntax::TypeTraitObject where
                F: Fold + ?Sized,
            {
                ::syntax::TypeTraitObject {
                    dyn_token: node.dyn_token,
                    bounds: ::syntax::punctuated::fold(node.bounds, f, F::fold_type_param_bound),
                }
            }
            pub fn fold_type_tuple<F>(f: &mut F, node: ::syntax::TypeTuple) -> ::syntax::TypeTuple where
                F: Fold + ?Sized,
            {
                ::syntax::TypeTuple {
                    paren_token: node.paren_token,
                    elems: ::syntax::punctuated::fold(node.elems, f, F::fold_type),
                }
            }
            pub fn fold_un_op<F>(f: &mut F, node: ::syntax::UnOp) -> ::syntax::UnOp where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::UnOp::Deref(_binding_0) => ::syntax::UnOp::Deref(_binding_0),
                    ::syntax::UnOp::Not(_binding_0) => ::syntax::UnOp::Not(_binding_0),
                    ::syntax::UnOp::Neg(_binding_0) => ::syntax::UnOp::Neg(_binding_0),
                }
            }
            pub fn fold_use_glob<F>(f: &mut F, node: ::syntax::UseGlob) -> ::syntax::UseGlob where
                F: Fold + ?Sized,
            {
                ::syntax::UseGlob {
                    star_token: node.star_token,
                }
            }
            pub fn fold_use_group<F>(f: &mut F, node: ::syntax::UseGroup) -> ::syntax::UseGroup where
                F: Fold + ?Sized,
            {
                ::syntax::UseGroup {
                    brace_token: node.brace_token,
                    items: ::syntax::punctuated::fold(node.items, f, F::fold_use_tree),
                }
            }
            pub fn fold_use_name<F>(f: &mut F, node: ::syntax::UseName) -> ::syntax::UseName where
                F: Fold + ?Sized,
            {
                ::syntax::UseName {
                    ident: f.fold_ident(node.ident),
                }
            }
            pub fn fold_use_path<F>(f: &mut F, node: ::syntax::UsePath) -> ::syntax::UsePath where
                F: Fold + ?Sized,
            {
                ::syntax::UsePath {
                    ident: f.fold_ident(node.ident),
                    colon2_token: node.colon2_token,
                    tree: Box::new(f.fold_use_tree(*node.tree)),
                }
            }
            pub fn fold_use_rename<F>(f: &mut F, node: ::syntax::UseRename) -> ::syntax::UseRename where
                F: Fold + ?Sized,
            {
                ::syntax::UseRename {
                    ident: f.fold_ident(node.ident),
                    as_token: node.as_token,
                    rename: f.fold_ident(node.rename),
                }
            }
            pub fn fold_use_tree<F>(f: &mut F, node: ::syntax::UseTree) -> ::syntax::UseTree where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::UseTree::Path(_binding_0) => {
                        ::syntax::UseTree::Path(f.fold_use_path(_binding_0))
                    }
                    ::syntax::UseTree::Name(_binding_0) => {
                        ::syntax::UseTree::Name(f.fold_use_name(_binding_0))
                    }
                    ::syntax::UseTree::Rename(_binding_0) => {
                        ::syntax::UseTree::Rename(f.fold_use_rename(_binding_0))
                    }
                    ::syntax::UseTree::Glob(_binding_0) => {
                        ::syntax::UseTree::Glob(f.fold_use_glob(_binding_0))
                    }
                    ::syntax::UseTree::Group(_binding_0) => {
                        ::syntax::UseTree::Group(f.fold_use_group(_binding_0))
                    }
                }
            }
            pub fn fold_variadic<F>(f: &mut F, node: ::syntax::Variadic) -> ::syntax::Variadic where
                F: Fold + ?Sized,
            {
                ::syntax::Variadic {
                    attrs: f.fold_attributes(node.attrs),
                    pat: (node.pat).map(|it| (Box::new(f.fold_pat(*(it).0)), (it).1)),
                    dots: node.dots,
                    comma: node.comma,
                }
            }
            pub fn fold_variant<F>(f: &mut F, node: ::syntax::Variant) -> ::syntax::Variant where
                F: Fold + ?Sized,
            {
                ::syntax::Variant {
                    attrs: f.fold_attributes(node.attrs),
                    ident: f.fold_ident(node.ident),
                    fields: f.fold_fields(node.fields),
                    discriminant: (node.discriminant).map(|it| ((it).0, f.fold_expr((it).1))),
                }
            }
            pub fn fold_vis_restricted<F>(
                f: &mut F,
                node: ::syntax::VisRestricted,
            ) -> ::syntax::VisRestricted where
                F: Fold + ?Sized,
            {
                ::syntax::VisRestricted {
                    pub_token: node.pub_token,
                    paren_token: node.paren_token,
                    in_token: node.in_token,
                    path: Box::new(f.fold_path(*node.path)),
                }
            }
            pub fn fold_visibility<F>(f: &mut F, node: ::syntax::Visibility) -> ::syntax::Visibility where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::Visibility::Public(_binding_0) => ::syntax::Visibility::Public(_binding_0),
                    ::syntax::Visibility::Restricted(_binding_0) => {
                        ::syntax::Visibility::Restricted(f.fold_vis_restricted(_binding_0))
                    }
                    ::syntax::Visibility::Inherited => ::syntax::Visibility::Inherited,
                }
            }
            pub fn fold_where_clause<F>(f: &mut F, node: ::syntax::WhereClause) -> ::syntax::WhereClause where
                F: Fold + ?Sized,
            {
                ::syntax::WhereClause {
                    where_token: node.where_token,
                    predicates: ::syntax::punctuated::fold(node.predicates, f, F::fold_where_predicate),
                }
            }
            pub fn fold_where_predicate<F>(
                f: &mut F,
                node: ::syntax::WherePredicate,
            ) -> ::syntax::WherePredicate where
                F: Fold + ?Sized,
            {
                match node {
                    ::syntax::WherePredicate::Lifetime(_binding_0) => {
                        ::syntax::WherePredicate::Lifetime(f.fold_predicate_lifetime(_binding_0))
                    }
                    ::syntax::WherePredicate::Type(_binding_0) => {
                        ::syntax::WherePredicate::Type(f.fold_predicate_type(_binding_0))
                    }
                }
            }
            fn fold_vec<T, V, F>(vec: Vec<T>, fold: &mut V, mut f: F) -> Vec<T> where
                V: ?Sized,
                F: FnMut(&mut V, T) -> T,
            {
                vec.into_iter().map(|it| f(fold, it)).collect()
            }
        }
        /// Syntax tree traversal to walk a shared borrow of a syntax tree.
        pub mod visit
        {
            use ::
            {
                syntax::punctuated::Punctuated,
                *,
            };
            /*
            */
            macro_rules! full {
                ($e:expr) => {
                    $e
                };
            }
            
            macro_rules! skip {
                ($($tt:tt)*) => {};
            }
            /// Syntax tree traversal to walk a shared borrow of a syntax tree.
            pub trait Visit<'ast> {
                        fn visit_abi(&mut self, i: &'ast ::syntax::Abi) {
                    visit_abi(self, i);
                }
                        fn visit_angle_bracketed_generic_arguments(
                    &mut self,
                    i: &'ast ::syntax::AngleBracketedGenericArguments,
                ) {
                    visit_angle_bracketed_generic_arguments(self, i);
                }
                            fn visit_arm(&mut self, i: &'ast ::syntax::Arm) {
                    visit_arm(self, i);
                }
                        fn visit_assoc_const(&mut self, i: &'ast ::syntax::AssocConst) {
                    visit_assoc_const(self, i);
                }
                        fn visit_assoc_type(&mut self, i: &'ast ::syntax::AssocType) {
                    visit_assoc_type(self, i);
                }
                        fn visit_attr_style(&mut self, i: &'ast ::syntax::AttrStyle) {
                    visit_attr_style(self, i);
                }
                        fn visit_attribute(&mut self, i: &'ast ::syntax::Attribute) {
                    visit_attribute(self, i);
                }
                        fn visit_bare_fn_arg(&mut self, i: &'ast ::syntax::BareFnArg) {
                    visit_bare_fn_arg(self, i);
                }
                        fn visit_bare_variadic(&mut self, i: &'ast ::syntax::BareVariadic) {
                    visit_bare_variadic(self, i);
                }
                        fn visit_bin_op(&mut self, i: &'ast ::syntax::BinOp) {
                    visit_bin_op(self, i);
                }
                            fn visit_block(&mut self, i: &'ast ::syntax::Block) {
                    visit_block(self, i);
                }
                        fn visit_bound_lifetimes(&mut self, i: &'ast ::syntax::BoundLifetimes) {
                    visit_bound_lifetimes(self, i);
                }
                            fn visit_captured_param(&mut self, i: &'ast ::syntax::CapturedParam) {
                    visit_captured_param(self, i);
                }
                        fn visit_const_param(&mut self, i: &'ast ::syntax::ConstParam) {
                    visit_const_param(self, i);
                }
                        fn visit_constraint(&mut self, i: &'ast ::syntax::Constraint) {
                    visit_constraint(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data(&mut self, i: &'ast ::syntax::Data) {
                    visit_data(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_enum(&mut self, i: &'ast ::syntax::DataEnum) {
                    visit_data_enum(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_struct(&mut self, i: &'ast ::syntax::DataStruct) {
                    visit_data_struct(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_union(&mut self, i: &'ast ::syntax::DataUnion) {
                    visit_data_union(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_derive_input(&mut self, i: &'ast ::syntax::DeriveInput) {
                    visit_derive_input(self, i);
                }
                        fn visit_expr(&mut self, i: &'ast ::syntax::Expr) {
                    visit_expr(self, i);
                }
                            fn visit_expr_array(&mut self, i: &'ast ::syntax::ExprArray) {
                    visit_expr_array(self, i);
                }
                            fn visit_expr_assign(&mut self, i: &'ast ::syntax::ExprAssign) {
                    visit_expr_assign(self, i);
                }
                            fn visit_expr_async(&mut self, i: &'ast ::syntax::ExprAsync) {
                    visit_expr_async(self, i);
                }
                            fn visit_expr_await(&mut self, i: &'ast ::syntax::ExprAwait) {
                    visit_expr_await(self, i);
                }
                        fn visit_expr_binary(&mut self, i: &'ast ::syntax::ExprBinary) {
                    visit_expr_binary(self, i);
                }
                            fn visit_expr_block(&mut self, i: &'ast ::syntax::ExprBlock) {
                    visit_expr_block(self, i);
                }
                            fn visit_expr_break(&mut self, i: &'ast ::syntax::ExprBreak) {
                    visit_expr_break(self, i);
                }
                        fn visit_expr_call(&mut self, i: &'ast ::syntax::ExprCall) {
                    visit_expr_call(self, i);
                }
                        fn visit_expr_cast(&mut self, i: &'ast ::syntax::ExprCast) {
                    visit_expr_cast(self, i);
                }
                            fn visit_expr_closure(&mut self, i: &'ast ::syntax::ExprClosure) {
                    visit_expr_closure(self, i);
                }
                            fn visit_expr_const(&mut self, i: &'ast ::syntax::ExprConst) {
                    visit_expr_const(self, i);
                }
                            fn visit_expr_continue(&mut self, i: &'ast ::syntax::ExprContinue) {
                    visit_expr_continue(self, i);
                }
                        fn visit_expr_field(&mut self, i: &'ast ::syntax::ExprField) {
                    visit_expr_field(self, i);
                }
                            fn visit_expr_for_loop(&mut self, i: &'ast ::syntax::ExprForLoop) {
                    visit_expr_for_loop(self, i);
                }
                        fn visit_expr_group(&mut self, i: &'ast ::syntax::ExprGroup) {
                    visit_expr_group(self, i);
                }
                            fn visit_expr_if(&mut self, i: &'ast ::syntax::ExprIf) {
                    visit_expr_if(self, i);
                }
                        fn visit_expr_index(&mut self, i: &'ast ::syntax::ExprIndex) {
                    visit_expr_index(self, i);
                }
                            fn visit_expr_infer(&mut self, i: &'ast ::syntax::ExprInfer) {
                    visit_expr_infer(self, i);
                }
                            fn visit_expr_let(&mut self, i: &'ast ::syntax::ExprLet) {
                    visit_expr_let(self, i);
                }
                        fn visit_expr_lit(&mut self, i: &'ast ::syntax::ExprLit) {
                    visit_expr_lit(self, i);
                }
                            fn visit_expr_loop(&mut self, i: &'ast ::syntax::ExprLoop) {
                    visit_expr_loop(self, i);
                }
                        fn visit_expr_macro(&mut self, i: &'ast ::syntax::ExprMacro) {
                    visit_expr_macro(self, i);
                }
                            fn visit_expr_match(&mut self, i: &'ast ::syntax::ExprMatch) {
                    visit_expr_match(self, i);
                }
                        fn visit_expr_method_call(&mut self, i: &'ast ::syntax::ExprMethodCall) {
                    visit_expr_method_call(self, i);
                }
                        fn visit_expr_paren(&mut self, i: &'ast ::syntax::ExprParen) {
                    visit_expr_paren(self, i);
                }
                        fn visit_expr_path(&mut self, i: &'ast ::syntax::ExprPath) {
                    visit_expr_path(self, i);
                }
                            fn visit_expr_range(&mut self, i: &'ast ::syntax::ExprRange) {
                    visit_expr_range(self, i);
                }
                            fn visit_expr_raw_addr(&mut self, i: &'ast ::syntax::ExprRawAddr) {
                    visit_expr_raw_addr(self, i);
                }
                        fn visit_expr_reference(&mut self, i: &'ast ::syntax::ExprReference) {
                    visit_expr_reference(self, i);
                }
                            fn visit_expr_repeat(&mut self, i: &'ast ::syntax::ExprRepeat) {
                    visit_expr_repeat(self, i);
                }
                            fn visit_expr_return(&mut self, i: &'ast ::syntax::ExprReturn) {
                    visit_expr_return(self, i);
                }
                        fn visit_expr_struct(&mut self, i: &'ast ::syntax::ExprStruct) {
                    visit_expr_struct(self, i);
                }
                            fn visit_expr_try(&mut self, i: &'ast ::syntax::ExprTry) {
                    visit_expr_try(self, i);
                }
                            fn visit_expr_try_block(&mut self, i: &'ast ::syntax::ExprTryBlock) {
                    visit_expr_try_block(self, i);
                }
                        fn visit_expr_tuple(&mut self, i: &'ast ::syntax::ExprTuple) {
                    visit_expr_tuple(self, i);
                }
                        fn visit_expr_unary(&mut self, i: &'ast ::syntax::ExprUnary) {
                    visit_expr_unary(self, i);
                }
                            fn visit_expr_unsafe(&mut self, i: &'ast ::syntax::ExprUnsafe) {
                    visit_expr_unsafe(self, i);
                }
                            fn visit_expr_while(&mut self, i: &'ast ::syntax::ExprWhile) {
                    visit_expr_while(self, i);
                }
                            fn visit_expr_yield(&mut self, i: &'ast ::syntax::ExprYield) {
                    visit_expr_yield(self, i);
                }
                        fn visit_field(&mut self, i: &'ast ::syntax::Field) {
                    visit_field(self, i);
                }
                        fn visit_field_mutability(&mut self, i: &'ast ::syntax::FieldMutability) {
                    visit_field_mutability(self, i);
                }
                            fn visit_field_pat(&mut self, i: &'ast ::syntax::FieldPat) {
                    visit_field_pat(self, i);
                }
                        fn visit_field_value(&mut self, i: &'ast ::syntax::FieldValue) {
                    visit_field_value(self, i);
                }
                        fn visit_fields(&mut self, i: &'ast ::syntax::Fields) {
                    visit_fields(self, i);
                }
                        fn visit_fields_named(&mut self, i: &'ast ::syntax::FieldsNamed) {
                    visit_fields_named(self, i);
                }
                        fn visit_fields_unnamed(&mut self, i: &'ast ::syntax::FieldsUnnamed) {
                    visit_fields_unnamed(self, i);
                }
                            fn visit_file(&mut self, i: &'ast ::syntax::File) {
                    visit_file(self, i);
                }
                            fn visit_fn_arg(&mut self, i: &'ast ::syntax::FnArg) {
                    visit_fn_arg(self, i);
                }
                            fn visit_foreign_item(&mut self, i: &'ast ::syntax::ForeignItem) {
                    visit_foreign_item(self, i);
                }
                            fn visit_foreign_item_fn(&mut self, i: &'ast ::syntax::ForeignItemFn) {
                    visit_foreign_item_fn(self, i);
                }
                            fn visit_foreign_item_macro(&mut self, i: &'ast ::syntax::ForeignItemMacro) {
                    visit_foreign_item_macro(self, i);
                }
                            fn visit_foreign_item_static(&mut self, i: &'ast ::syntax::ForeignItemStatic) {
                    visit_foreign_item_static(self, i);
                }
                            fn visit_foreign_item_type(&mut self, i: &'ast ::syntax::ForeignItemType) {
                    visit_foreign_item_type(self, i);
                }
                        fn visit_generic_argument(&mut self, i: &'ast ::syntax::GenericArgument) {
                    visit_generic_argument(self, i);
                }
                        fn visit_generic_param(&mut self, i: &'ast ::syntax::GenericParam) {
                    visit_generic_param(self, i);
                }
                        fn visit_generics(&mut self, i: &'ast ::syntax::Generics) {
                    visit_generics(self, i);
                }
                fn visit_ident(&mut self, i: &'ast process::macros::Ident) {
                    visit_ident(self, i);
                }
                            fn visit_impl_item(&mut self, i: &'ast ::syntax::ImplItem) {
                    visit_impl_item(self, i);
                }
                            fn visit_impl_item_const(&mut self, i: &'ast ::syntax::ImplItemConst) {
                    visit_impl_item_const(self, i);
                }
                            fn visit_impl_item_fn(&mut self, i: &'ast ::syntax::ImplItemFn) {
                    visit_impl_item_fn(self, i);
                }
                            fn visit_impl_item_macro(&mut self, i: &'ast ::syntax::ImplItemMacro) {
                    visit_impl_item_macro(self, i);
                }
                            fn visit_impl_item_type(&mut self, i: &'ast ::syntax::ImplItemType) {
                    visit_impl_item_type(self, i);
                }
                            fn visit_impl_restriction(&mut self, i: &'ast ::syntax::ImplRestriction) {
                    visit_impl_restriction(self, i);
                }
                        fn visit_index(&mut self, i: &'ast ::syntax::Index) {
                    visit_index(self, i);
                }
                            fn visit_item(&mut self, i: &'ast ::syntax::Item) {
                    visit_item(self, i);
                }
                            fn visit_item_const(&mut self, i: &'ast ::syntax::ItemConst) {
                    visit_item_const(self, i);
                }
                            fn visit_item_enum(&mut self, i: &'ast ::syntax::ItemEnum) {
                    visit_item_enum(self, i);
                }
                            fn visit_item_extern_crate(&mut self, i: &'ast ::syntax::ItemExternCrate) {
                    visit_item_extern_crate(self, i);
                }
                            fn visit_item_fn(&mut self, i: &'ast ::syntax::ItemFn) {
                    visit_item_fn(self, i);
                }
                            fn visit_item_foreign_mod(&mut self, i: &'ast ::syntax::ItemForeignMod) {
                    visit_item_foreign_mod(self, i);
                }
                            fn visit_item_impl(&mut self, i: &'ast ::syntax::ItemImpl) {
                    visit_item_impl(self, i);
                }
                            fn visit_item_macro(&mut self, i: &'ast ::syntax::ItemMacro) {
                    visit_item_macro(self, i);
                }
                            fn visit_item_mod(&mut self, i: &'ast ::syntax::ItemMod) {
                    visit_item_mod(self, i);
                }
                            fn visit_item_static(&mut self, i: &'ast ::syntax::ItemStatic) {
                    visit_item_static(self, i);
                }
                            fn visit_item_struct(&mut self, i: &'ast ::syntax::ItemStruct) {
                    visit_item_struct(self, i);
                }
                            fn visit_item_trait(&mut self, i: &'ast ::syntax::ItemTrait) {
                    visit_item_trait(self, i);
                }
                            fn visit_item_trait_alias(&mut self, i: &'ast ::syntax::ItemTraitAlias) {
                    visit_item_trait_alias(self, i);
                }
                            fn visit_item_type(&mut self, i: &'ast ::syntax::ItemType) {
                    visit_item_type(self, i);
                }
                            fn visit_item_union(&mut self, i: &'ast ::syntax::ItemUnion) {
                    visit_item_union(self, i);
                }
                            fn visit_item_use(&mut self, i: &'ast ::syntax::ItemUse) {
                    visit_item_use(self, i);
                }
                            fn visit_label(&mut self, i: &'ast ::syntax::Label) {
                    visit_label(self, i);
                }
                fn visit_lifetime(&mut self, i: &'ast ::syntax::Lifetime) {
                    visit_lifetime(self, i);
                }
                        fn visit_lifetime_param(&mut self, i: &'ast ::syntax::LifetimeParam) {
                    visit_lifetime_param(self, i);
                }
                fn visit_lit(&mut self, i: &'ast ::syntax::Lit) {
                    visit_lit(self, i);
                }
                fn visit_lit_bool(&mut self, i: &'ast ::syntax::LitBool) {
                    visit_lit_bool(self, i);
                }
                fn visit_lit_byte(&mut self, i: &'ast ::syntax::LitByte) {
                    visit_lit_byte(self, i);
                }
                fn visit_lit_byte_str(&mut self, i: &'ast ::syntax::LitByteStr) {
                    visit_lit_byte_str(self, i);
                }
                fn visit_lit_cstr(&mut self, i: &'ast ::syntax::LitCStr) {
                    visit_lit_cstr(self, i);
                }
                fn visit_lit_char(&mut self, i: &'ast ::syntax::LitChar) {
                    visit_lit_char(self, i);
                }
                fn visit_lit_float(&mut self, i: &'ast ::syntax::LitFloat) {
                    visit_lit_float(self, i);
                }
                fn visit_lit_int(&mut self, i: &'ast ::syntax::LitInt) {
                    visit_lit_int(self, i);
                }
                fn visit_lit_str(&mut self, i: &'ast ::syntax::LitStr) {
                    visit_lit_str(self, i);
                }
                            fn visit_local(&mut self, i: &'ast ::syntax::Local) {
                    visit_local(self, i);
                }
                            fn visit_local_init(&mut self, i: &'ast ::syntax::LocalInit) {
                    visit_local_init(self, i);
                }
                        fn visit_macro(&mut self, i: &'ast ::syntax::Macro) {
                    visit_macro(self, i);
                }
                        fn visit_macro_delimiter(&mut self, i: &'ast ::syntax::MacroDelimiter) {
                    visit_macro_delimiter(self, i);
                }
                        fn visit_member(&mut self, i: &'ast ::syntax::Member) {
                    visit_member(self, i);
                }
                        fn visit_meta(&mut self, i: &'ast ::syntax::Meta) {
                    visit_meta(self, i);
                }
                        fn visit_meta_list(&mut self, i: &'ast ::syntax::MetaList) {
                    visit_meta_list(self, i);
                }
                        fn visit_meta_name_value(&mut self, i: &'ast ::syntax::MetaNameValue) {
                    visit_meta_name_value(self, i);
                }
                        fn visit_parenthesized_generic_arguments(
                    &mut self,
                    i: &'ast ::syntax::ParenthesizedGenericArguments,
                ) {
                    visit_parenthesized_generic_arguments(self, i);
                }
                            fn visit_pat(&mut self, i: &'ast ::syntax::Pat) {
                    visit_pat(self, i);
                }
                            fn visit_pat_ident(&mut self, i: &'ast ::syntax::PatIdent) {
                    visit_pat_ident(self, i);
                }
                            fn visit_pat_or(&mut self, i: &'ast ::syntax::PatOr) {
                    visit_pat_or(self, i);
                }
                            fn visit_pat_paren(&mut self, i: &'ast ::syntax::PatParen) {
                    visit_pat_paren(self, i);
                }
                            fn visit_pat_reference(&mut self, i: &'ast ::syntax::PatReference) {
                    visit_pat_reference(self, i);
                }
                            fn visit_pat_rest(&mut self, i: &'ast ::syntax::PatRest) {
                    visit_pat_rest(self, i);
                }
                            fn visit_pat_slice(&mut self, i: &'ast ::syntax::PatSlice) {
                    visit_pat_slice(self, i);
                }
                            fn visit_pat_struct(&mut self, i: &'ast ::syntax::PatStruct) {
                    visit_pat_struct(self, i);
                }
                            fn visit_pat_tuple(&mut self, i: &'ast ::syntax::PatTuple) {
                    visit_pat_tuple(self, i);
                }
                            fn visit_pat_tuple_struct(&mut self, i: &'ast ::syntax::PatTupleStruct) {
                    visit_pat_tuple_struct(self, i);
                }
                            fn visit_pat_type(&mut self, i: &'ast ::syntax::PatType) {
                    visit_pat_type(self, i);
                }
                            fn visit_pat_wild(&mut self, i: &'ast ::syntax::PatWild) {
                    visit_pat_wild(self, i);
                }
                        fn visit_path(&mut self, i: &'ast ::syntax::Path) {
                    visit_path(self, i);
                }
                        fn visit_path_arguments(&mut self, i: &'ast ::syntax::PathArguments) {
                    visit_path_arguments(self, i);
                }
                        fn visit_path_segment(&mut self, i: &'ast ::syntax::PathSegment) {
                    visit_path_segment(self, i);
                }
                            fn visit_pointer_mutability(&mut self, i: &'ast ::syntax::PointerMutability) {
                    visit_pointer_mutability(self, i);
                }
                            fn visit_precise_capture(&mut self, i: &'ast ::syntax::PreciseCapture) {
                    visit_precise_capture(self, i);
                }
                        fn visit_predicate_lifetime(&mut self, i: &'ast ::syntax::PredicateLifetime) {
                    visit_predicate_lifetime(self, i);
                }
                        fn visit_predicate_type(&mut self, i: &'ast ::syntax::PredicateType) {
                    visit_predicate_type(self, i);
                }
                        fn visit_qself(&mut self, i: &'ast ::syntax::QSelf) {
                    visit_qself(self, i);
                }
                            fn visit_range_limits(&mut self, i: &'ast ::syntax::RangeLimits) {
                    visit_range_limits(self, i);
                }
                            fn visit_receiver(&mut self, i: &'ast ::syntax::Receiver) {
                    visit_receiver(self, i);
                }
                        fn visit_return_type(&mut self, i: &'ast ::syntax::ReturnType) {
                    visit_return_type(self, i);
                }
                            fn visit_signature(&mut self, i: &'ast ::syntax::Signature) {
                    visit_signature(self, i);
                }
                fn visit_span(&mut self, i: &process::macros::Span) {}
                            fn visit_static_mutability(&mut self, i: &'ast ::syntax::StaticMutability) {
                    visit_static_mutability(self, i);
                }
                            fn visit_stmt(&mut self, i: &'ast ::syntax::Stmt) {
                    visit_stmt(self, i);
                }
                            fn visit_stmt_macro(&mut self, i: &'ast ::syntax::StmtMacro) {
                    visit_stmt_macro(self, i);
                }
                fn visit_token_stream(&mut self, i: &'ast process::macros::TokenStream) {}
                        fn visit_trait_bound(&mut self, i: &'ast ::syntax::TraitBound) {
                    visit_trait_bound(self, i);
                }
                        fn visit_trait_bound_modifier(&mut self, i: &'ast ::syntax::TraitBoundModifier) {
                    visit_trait_bound_modifier(self, i);
                }
                            fn visit_trait_item(&mut self, i: &'ast ::syntax::TraitItem) {
                    visit_trait_item(self, i);
                }
                            fn visit_trait_item_const(&mut self, i: &'ast ::syntax::TraitItemConst) {
                    visit_trait_item_const(self, i);
                }
                            fn visit_trait_item_fn(&mut self, i: &'ast ::syntax::TraitItemFn) {
                    visit_trait_item_fn(self, i);
                }
                            fn visit_trait_item_macro(&mut self, i: &'ast ::syntax::TraitItemMacro) {
                    visit_trait_item_macro(self, i);
                }
                            fn visit_trait_item_type(&mut self, i: &'ast ::syntax::TraitItemType) {
                    visit_trait_item_type(self, i);
                }
                        fn visit_type(&mut self, i: &'ast ::syntax::Type) {
                    visit_type(self, i);
                }
                        fn visit_type_array(&mut self, i: &'ast ::syntax::TypeArray) {
                    visit_type_array(self, i);
                }
                        fn visit_type_bare_fn(&mut self, i: &'ast ::syntax::TypeBareFn) {
                    visit_type_bare_fn(self, i);
                }
                        fn visit_type_group(&mut self, i: &'ast ::syntax::TypeGroup) {
                    visit_type_group(self, i);
                }
                        fn visit_type_impl_trait(&mut self, i: &'ast ::syntax::TypeImplTrait) {
                    visit_type_impl_trait(self, i);
                }
                        fn visit_type_infer(&mut self, i: &'ast ::syntax::TypeInfer) {
                    visit_type_infer(self, i);
                }
                        fn visit_type_macro(&mut self, i: &'ast ::syntax::TypeMacro) {
                    visit_type_macro(self, i);
                }
                        fn visit_type_never(&mut self, i: &'ast ::syntax::TypeNever) {
                    visit_type_never(self, i);
                }
                        fn visit_type_param(&mut self, i: &'ast ::syntax::TypeParam) {
                    visit_type_param(self, i);
                }
                        fn visit_type_param_bound(&mut self, i: &'ast ::syntax::TypeParamBound) {
                    visit_type_param_bound(self, i);
                }
                        fn visit_type_paren(&mut self, i: &'ast ::syntax::TypeParen) {
                    visit_type_paren(self, i);
                }
                        fn visit_type_path(&mut self, i: &'ast ::syntax::TypePath) {
                    visit_type_path(self, i);
                }
                        fn visit_type_ptr(&mut self, i: &'ast ::syntax::TypePtr) {
                    visit_type_ptr(self, i);
                }
                        fn visit_type_reference(&mut self, i: &'ast ::syntax::TypeReference) {
                    visit_type_reference(self, i);
                }
                        fn visit_type_slice(&mut self, i: &'ast ::syntax::TypeSlice) {
                    visit_type_slice(self, i);
                }
                        fn visit_type_trait_object(&mut self, i: &'ast ::syntax::TypeTraitObject) {
                    visit_type_trait_object(self, i);
                }
                        fn visit_type_tuple(&mut self, i: &'ast ::syntax::TypeTuple) {
                    visit_type_tuple(self, i);
                }
                        fn visit_un_op(&mut self, i: &'ast ::syntax::UnOp) {
                    visit_un_op(self, i);
                }
                            fn visit_use_glob(&mut self, i: &'ast ::syntax::UseGlob) {
                    visit_use_glob(self, i);
                }
                            fn visit_use_group(&mut self, i: &'ast ::syntax::UseGroup) {
                    visit_use_group(self, i);
                }
                            fn visit_use_name(&mut self, i: &'ast ::syntax::UseName) {
                    visit_use_name(self, i);
                }
                            fn visit_use_path(&mut self, i: &'ast ::syntax::UsePath) {
                    visit_use_path(self, i);
                }
                            fn visit_use_rename(&mut self, i: &'ast ::syntax::UseRename) {
                    visit_use_rename(self, i);
                }
                            fn visit_use_tree(&mut self, i: &'ast ::syntax::UseTree) {
                    visit_use_tree(self, i);
                }
                            fn visit_variadic(&mut self, i: &'ast ::syntax::Variadic) {
                    visit_variadic(self, i);
                }
                        fn visit_variant(&mut self, i: &'ast ::syntax::Variant) {
                    visit_variant(self, i);
                }
                        fn visit_vis_restricted(&mut self, i: &'ast ::syntax::VisRestricted) {
                    visit_vis_restricted(self, i);
                }
                        fn visit_visibility(&mut self, i: &'ast ::syntax::Visibility) {
                    visit_visibility(self, i);
                }
                        fn visit_where_clause(&mut self, i: &'ast ::syntax::WhereClause) {
                    visit_where_clause(self, i);
                }
                        fn visit_where_predicate(&mut self, i: &'ast ::syntax::WherePredicate) {
                    visit_where_predicate(self, i);
                }
            }
            pub fn visit_abi<'ast, V>(v: &mut V, node: &'ast ::syntax::Abi) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.extern_token);
                if let Some(it) = &node.name {
                    v.visit_lit_str(it);
                }
            }
            pub fn visit_angle_bracketed_generic_arguments<'ast, V>(
                v: &mut V,
                node: &'ast ::syntax::AngleBracketedGenericArguments,
            ) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.colon2_token);
                skip!(node.lt_token);
                for el in Punctuated::pairs(&node.args) {
                    let it = el.value();
                    v.visit_generic_argument(it);
                }
                skip!(node.gt_token);
            }
                pub fn visit_arm<'ast, V>(v: &mut V, node: &'ast ::syntax::Arm) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_pat(&node.pat);
                if let Some(it) = &node.guard {
                    skip!((it).0);
                    v.visit_expr(&*(it).1);
                }
                skip!(node.fat_arrow_token);
                v.visit_expr(&*node.body);
                skip!(node.comma);
            }
            pub fn visit_assoc_const<'ast, V>(v: &mut V, node: &'ast ::syntax::AssocConst) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                if let Some(it) = &node.generics {
                    v.visit_angle_bracketed_generic_arguments(it);
                }
                skip!(node.eq_token);
                v.visit_expr(&node.value);
            }
            pub fn visit_assoc_type<'ast, V>(v: &mut V, node: &'ast ::syntax::AssocType) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                if let Some(it) = &node.generics {
                    v.visit_angle_bracketed_generic_arguments(it);
                }
                skip!(node.eq_token);
                v.visit_type(&node.ty);
            }
            pub fn visit_attr_style<'ast, V>(v: &mut V, node: &'ast ::syntax::AttrStyle) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::AttrStyle::Outer => {}
                    ::syntax::AttrStyle::Inner(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_attribute<'ast, V>(v: &mut V, node: &'ast ::syntax::Attribute) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.pound_token);
                v.visit_attr_style(&node.style);
                skip!(node.bracket_token);
                v.visit_meta(&node.meta);
            }
            pub fn visit_bare_fn_arg<'ast, V>(v: &mut V, node: &'ast ::syntax::BareFnArg) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.name {
                    v.visit_ident(&(it).0);
                    skip!((it).1);
                }
                v.visit_type(&node.ty);
            }
            pub fn visit_bare_variadic<'ast, V>(v: &mut V, node: &'ast ::syntax::BareVariadic) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.name {
                    v.visit_ident(&(it).0);
                    skip!((it).1);
                }
                skip!(node.dots);
                skip!(node.comma);
            }
            pub fn visit_bin_op<'ast, V>(v: &mut V, node: &'ast ::syntax::BinOp) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::BinOp::Add(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Sub(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Mul(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Div(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Rem(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::And(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Or(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitXor(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitAnd(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitOr(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Shl(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Shr(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Eq(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Lt(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Le(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Ne(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Ge(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Gt(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::AddAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::SubAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::MulAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::DivAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::RemAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitXorAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitAndAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitOrAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::ShlAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::ShrAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_block<'ast, V>(v: &mut V, node: &'ast ::syntax::Block) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.brace_token);
                for it in &node.stmts {
                    v.visit_stmt(it);
                }
            }
            pub fn visit_bound_lifetimes<'ast, V>(v: &mut V, node: &'ast ::syntax::BoundLifetimes) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.for_token);
                skip!(node.lt_token);
                for el in Punctuated::pairs(&node.lifetimes) {
                    let it = el.value();
                    v.visit_generic_param(it);
                }
                skip!(node.gt_token);
            }
                pub fn visit_captured_param<'ast, V>(v: &mut V, node: &'ast ::syntax::CapturedParam) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::CapturedParam::Lifetime(_binding_0) => {
                        v.visit_lifetime(_binding_0);
                    }
                    ::syntax::CapturedParam::Ident(_binding_0) => {
                        v.visit_ident(_binding_0);
                    }
                }
            }
            pub fn visit_const_param<'ast, V>(v: &mut V, node: &'ast ::syntax::ConstParam) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.const_token);
                v.visit_ident(&node.ident);
                skip!(node.colon_token);
                v.visit_type(&node.ty);
                skip!(node.eq_token);
                if let Some(it) = &node.default {
                    v.visit_expr(it);
                }
            }
            pub fn visit_constraint<'ast, V>(v: &mut V, node: &'ast ::syntax::Constraint) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                if let Some(it) = &node.generics {
                    v.visit_angle_bracketed_generic_arguments(it);
                }
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
            }
            pub fn visit_data<'ast, V>(v: &mut V, node: &'ast ::syntax::Data) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Data::Struct(_binding_0) => {
                        v.visit_data_struct(_binding_0);
                    }
                    ::syntax::Data::Enum(_binding_0) => {
                        v.visit_data_enum(_binding_0);
                    }
                    ::syntax::Data::Union(_binding_0) => {
                        v.visit_data_union(_binding_0);
                    }
                }
            }
            pub fn visit_data_enum<'ast, V>(v: &mut V, node: &'ast ::syntax::DataEnum) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.enum_token);
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.variants) {
                    let it = el.value();
                    v.visit_variant(it);
                }
            }
            pub fn visit_data_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::DataStruct) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.struct_token);
                v.visit_fields(&node.fields);
                skip!(node.semi_token);
            }
            pub fn visit_data_union<'ast, V>(v: &mut V, node: &'ast ::syntax::DataUnion) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.union_token);
                v.visit_fields_named(&node.fields);
            }
            pub fn visit_derive_input<'ast, V>(v: &mut V, node: &'ast ::syntax::DeriveInput) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                v.visit_data(&node.data);
            }
            pub fn visit_expr<'ast, V>(v: &mut V, node: &'ast ::syntax::Expr) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Expr::Array(_binding_0) => {
                        full!(v.visit_expr_array(_binding_0));
                    }
                    ::syntax::Expr::Assign(_binding_0) => {
                        full!(v.visit_expr_assign(_binding_0));
                    }
                    ::syntax::Expr::Async(_binding_0) => {
                        full!(v.visit_expr_async(_binding_0));
                    }
                    ::syntax::Expr::Await(_binding_0) => {
                        full!(v.visit_expr_await(_binding_0));
                    }
                    ::syntax::Expr::Binary(_binding_0) => {
                        v.visit_expr_binary(_binding_0);
                    }
                    ::syntax::Expr::Block(_binding_0) => {
                        full!(v.visit_expr_block(_binding_0));
                    }
                    ::syntax::Expr::Break(_binding_0) => {
                        full!(v.visit_expr_break(_binding_0));
                    }
                    ::syntax::Expr::Call(_binding_0) => {
                        v.visit_expr_call(_binding_0);
                    }
                    ::syntax::Expr::Cast(_binding_0) => {
                        v.visit_expr_cast(_binding_0);
                    }
                    ::syntax::Expr::Closure(_binding_0) => {
                        full!(v.visit_expr_closure(_binding_0));
                    }
                    ::syntax::Expr::Const(_binding_0) => {
                        full!(v.visit_expr_const(_binding_0));
                    }
                    ::syntax::Expr::Continue(_binding_0) => {
                        full!(v.visit_expr_continue(_binding_0));
                    }
                    ::syntax::Expr::Field(_binding_0) => {
                        v.visit_expr_field(_binding_0);
                    }
                    ::syntax::Expr::ForLoop(_binding_0) => {
                        full!(v.visit_expr_for_loop(_binding_0));
                    }
                    ::syntax::Expr::Group(_binding_0) => {
                        v.visit_expr_group(_binding_0);
                    }
                    ::syntax::Expr::If(_binding_0) => {
                        full!(v.visit_expr_if(_binding_0));
                    }
                    ::syntax::Expr::Index(_binding_0) => {
                        v.visit_expr_index(_binding_0);
                    }
                    ::syntax::Expr::Infer(_binding_0) => {
                        full!(v.visit_expr_infer(_binding_0));
                    }
                    ::syntax::Expr::Let(_binding_0) => {
                        full!(v.visit_expr_let(_binding_0));
                    }
                    ::syntax::Expr::Lit(_binding_0) => {
                        v.visit_expr_lit(_binding_0);
                    }
                    ::syntax::Expr::Loop(_binding_0) => {
                        full!(v.visit_expr_loop(_binding_0));
                    }
                    ::syntax::Expr::Macro(_binding_0) => {
                        v.visit_expr_macro(_binding_0);
                    }
                    ::syntax::Expr::Match(_binding_0) => {
                        full!(v.visit_expr_match(_binding_0));
                    }
                    ::syntax::Expr::MethodCall(_binding_0) => {
                        v.visit_expr_method_call(_binding_0);
                    }
                    ::syntax::Expr::Paren(_binding_0) => {
                        v.visit_expr_paren(_binding_0);
                    }
                    ::syntax::Expr::Path(_binding_0) => {
                        v.visit_expr_path(_binding_0);
                    }
                    ::syntax::Expr::Range(_binding_0) => {
                        full!(v.visit_expr_range(_binding_0));
                    }
                    ::syntax::Expr::RawAddr(_binding_0) => {
                        full!(v.visit_expr_raw_addr(_binding_0));
                    }
                    ::syntax::Expr::Reference(_binding_0) => {
                        v.visit_expr_reference(_binding_0);
                    }
                    ::syntax::Expr::Repeat(_binding_0) => {
                        full!(v.visit_expr_repeat(_binding_0));
                    }
                    ::syntax::Expr::Return(_binding_0) => {
                        full!(v.visit_expr_return(_binding_0));
                    }
                    ::syntax::Expr::Struct(_binding_0) => {
                        v.visit_expr_struct(_binding_0);
                    }
                    ::syntax::Expr::Try(_binding_0) => {
                        full!(v.visit_expr_try(_binding_0));
                    }
                    ::syntax::Expr::TryBlock(_binding_0) => {
                        full!(v.visit_expr_try_block(_binding_0));
                    }
                    ::syntax::Expr::Tuple(_binding_0) => {
                        v.visit_expr_tuple(_binding_0);
                    }
                    ::syntax::Expr::Unary(_binding_0) => {
                        v.visit_expr_unary(_binding_0);
                    }
                    ::syntax::Expr::Unsafe(_binding_0) => {
                        full!(v.visit_expr_unsafe(_binding_0));
                    }
                    ::syntax::Expr::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                    ::syntax::Expr::While(_binding_0) => {
                        full!(v.visit_expr_while(_binding_0));
                    }
                    ::syntax::Expr::Yield(_binding_0) => {
                        full!(v.visit_expr_yield(_binding_0));
                    }
                }
            }
                pub fn visit_expr_array<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprArray) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.bracket_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_expr(it);
                }
            }
                pub fn visit_expr_assign<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprAssign) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.left);
                skip!(node.eq_token);
                v.visit_expr(&*node.right);
            }
                pub fn visit_expr_async<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprAsync) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.async_token);
                skip!(node.capture);
                v.visit_block(&node.block);
            }
                pub fn visit_expr_await<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprAwait) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.base);
                skip!(node.dot_token);
                skip!(node.await_token);
            }
            pub fn visit_expr_binary<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprBinary) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.left);
                v.visit_bin_op(&node.op);
                v.visit_expr(&*node.right);
            }
                pub fn visit_expr_block<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprBlock) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.label {
                    v.visit_label(it);
                }
                v.visit_block(&node.block);
            }
                pub fn visit_expr_break<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprBreak) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.break_token);
                if let Some(it) = &node.label {
                    v.visit_lifetime(it);
                }
                if let Some(it) = &node.expr {
                    v.visit_expr(&**it);
                }
            }
            pub fn visit_expr_call<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprCall) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.func);
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.args) {
                    let it = el.value();
                    v.visit_expr(it);
                }
            }
            pub fn visit_expr_cast<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprCast) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.expr);
                skip!(node.as_token);
                v.visit_type(&*node.ty);
            }
                pub fn visit_expr_closure<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprClosure) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.lifetimes {
                    v.visit_bound_lifetimes(it);
                }
                skip!(node.constness);
                skip!(node.movability);
                skip!(node.asyncness);
                skip!(node.capture);
                skip!(node.or1_token);
                for el in Punctuated::pairs(&node.inputs) {
                    let it = el.value();
                    v.visit_pat(it);
                }
                skip!(node.or2_token);
                v.visit_return_type(&node.output);
                v.visit_expr(&*node.body);
            }
                pub fn visit_expr_const<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprConst) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.const_token);
                v.visit_block(&node.block);
            }
                pub fn visit_expr_continue<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprContinue) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.continue_token);
                if let Some(it) = &node.label {
                    v.visit_lifetime(it);
                }
            }
            pub fn visit_expr_field<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprField) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.base);
                skip!(node.dot_token);
                v.visit_member(&node.member);
            }
                pub fn visit_expr_for_loop<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprForLoop) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.label {
                    v.visit_label(it);
                }
                skip!(node.for_token);
                v.visit_pat(&*node.pat);
                skip!(node.in_token);
                v.visit_expr(&*node.expr);
                v.visit_block(&node.body);
            }
            pub fn visit_expr_group<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprGroup) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.group_token);
                v.visit_expr(&*node.expr);
            }
                pub fn visit_expr_if<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprIf) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.if_token);
                v.visit_expr(&*node.cond);
                v.visit_block(&node.then_branch);
                if let Some(it) = &node.else_branch {
                    skip!((it).0);
                    v.visit_expr(&*(it).1);
                }
            }
            pub fn visit_expr_index<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprIndex) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.expr);
                skip!(node.bracket_token);
                v.visit_expr(&*node.index);
            }
                pub fn visit_expr_infer<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprInfer) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.underscore_token);
            }
                pub fn visit_expr_let<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprLet) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.let_token);
                v.visit_pat(&*node.pat);
                skip!(node.eq_token);
                v.visit_expr(&*node.expr);
            }
            pub fn visit_expr_lit<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprLit) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_lit(&node.lit);
            }
                pub fn visit_expr_loop<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprLoop) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.label {
                    v.visit_label(it);
                }
                skip!(node.loop_token);
                v.visit_block(&node.body);
            }
            pub fn visit_expr_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
            }
                pub fn visit_expr_match<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprMatch) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.match_token);
                v.visit_expr(&*node.expr);
                skip!(node.brace_token);
                for it in &node.arms {
                    v.visit_arm(it);
                }
            }
            pub fn visit_expr_method_call<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprMethodCall) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.receiver);
                skip!(node.dot_token);
                v.visit_ident(&node.method);
                if let Some(it) = &node.turbofish {
                    v.visit_angle_bracketed_generic_arguments(it);
                }
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.args) {
                    let it = el.value();
                    v.visit_expr(it);
                }
            }
            pub fn visit_expr_paren<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprParen) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.paren_token);
                v.visit_expr(&*node.expr);
            }
            pub fn visit_expr_path<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprPath) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
            }
                pub fn visit_expr_range<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprRange) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.start {
                    v.visit_expr(&**it);
                }
                v.visit_range_limits(&node.limits);
                if let Some(it) = &node.end {
                    v.visit_expr(&**it);
                }
            }
                pub fn visit_expr_raw_addr<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprRawAddr) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.and_token);
                skip!(node.raw);
                v.visit_pointer_mutability(&node.mutability);
                v.visit_expr(&*node.expr);
            }
            pub fn visit_expr_reference<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprReference) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.and_token);
                skip!(node.mutability);
                v.visit_expr(&*node.expr);
            }
                pub fn visit_expr_repeat<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprRepeat) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.bracket_token);
                v.visit_expr(&*node.expr);
                skip!(node.semi_token);
                v.visit_expr(&*node.len);
            }
                pub fn visit_expr_return<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprReturn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.return_token);
                if let Some(it) = &node.expr {
                    v.visit_expr(&**it);
                }
            }
            pub fn visit_expr_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprStruct) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.fields) {
                    let it = el.value();
                    v.visit_field_value(it);
                }
                skip!(node.dot2_token);
                if let Some(it) = &node.rest {
                    v.visit_expr(&**it);
                }
            }
                pub fn visit_expr_try<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprTry) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_expr(&*node.expr);
                skip!(node.question_token);
            }
                pub fn visit_expr_try_block<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprTryBlock) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.try_token);
                v.visit_block(&node.block);
            }
            pub fn visit_expr_tuple<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprTuple) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_expr(it);
                }
            }
            pub fn visit_expr_unary<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprUnary) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_un_op(&node.op);
                v.visit_expr(&*node.expr);
            }
                pub fn visit_expr_unsafe<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprUnsafe) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.unsafe_token);
                v.visit_block(&node.block);
            }
                pub fn visit_expr_while<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprWhile) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.label {
                    v.visit_label(it);
                }
                skip!(node.while_token);
                v.visit_expr(&*node.cond);
                v.visit_block(&node.body);
            }
                pub fn visit_expr_yield<'ast, V>(v: &mut V, node: &'ast ::syntax::ExprYield) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.yield_token);
                if let Some(it) = &node.expr {
                    v.visit_expr(&**it);
                }
            }
            pub fn visit_field<'ast, V>(v: &mut V, node: &'ast ::syntax::Field) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                v.visit_field_mutability(&node.mutability);
                if let Some(it) = &node.ident {
                    v.visit_ident(it);
                }
                skip!(node.colon_token);
                v.visit_type(&node.ty);
            }
            pub fn visit_field_mutability<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldMutability) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::FieldMutability::None => {}
                }
            }
                pub fn visit_field_pat<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldPat) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_member(&node.member);
                skip!(node.colon_token);
                v.visit_pat(&*node.pat);
            }
            pub fn visit_field_value<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldValue) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_member(&node.member);
                skip!(node.colon_token);
                v.visit_expr(&node.expr);
            }
            pub fn visit_fields<'ast, V>(v: &mut V, node: &'ast ::syntax::Fields) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Fields::Named(_binding_0) => {
                        v.visit_fields_named(_binding_0);
                    }
                    ::syntax::Fields::Unnamed(_binding_0) => {
                        v.visit_fields_unnamed(_binding_0);
                    }
                    ::syntax::Fields::Unit => {}
                }
            }
            pub fn visit_fields_named<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldsNamed) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.named) {
                    let it = el.value();
                    v.visit_field(it);
                }
            }
            pub fn visit_fields_unnamed<'ast, V>(v: &mut V, node: &'ast ::syntax::FieldsUnnamed) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.unnamed) {
                    let it = el.value();
                    v.visit_field(it);
                }
            }
                pub fn visit_file<'ast, V>(v: &mut V, node: &'ast ::syntax::File) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.shebang);
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                for it in &node.items {
                    v.visit_item(it);
                }
            }
                pub fn visit_fn_arg<'ast, V>(v: &mut V, node: &'ast ::syntax::FnArg) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::FnArg::Receiver(_binding_0) => {
                        v.visit_receiver(_binding_0);
                    }
                    ::syntax::FnArg::Typed(_binding_0) => {
                        v.visit_pat_type(_binding_0);
                    }
                }
            }
                pub fn visit_foreign_item<'ast, V>(v: &mut V, node: &'ast ::syntax::ForeignItem) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::ForeignItem::Fn(_binding_0) => {
                        v.visit_foreign_item_fn(_binding_0);
                    }
                    ::syntax::ForeignItem::Static(_binding_0) => {
                        v.visit_foreign_item_static(_binding_0);
                    }
                    ::syntax::ForeignItem::Type(_binding_0) => {
                        v.visit_foreign_item_type(_binding_0);
                    }
                    ::syntax::ForeignItem::Macro(_binding_0) => {
                        v.visit_foreign_item_macro(_binding_0);
                    }
                    ::syntax::ForeignItem::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
                pub fn visit_foreign_item_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::ForeignItemFn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                v.visit_signature(&node.sig);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::ForeignItemMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_static<'ast, V>(
                v: &mut V,
                node: &'ast ::syntax::ForeignItemStatic,
            ) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.static_token);
                v.visit_static_mutability(&node.mutability);
                v.visit_ident(&node.ident);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_type<'ast, V>(v: &mut V, node: &'ast ::syntax::ForeignItemType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.type_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.semi_token);
            }
            pub fn visit_generic_argument<'ast, V>(v: &mut V, node: &'ast ::syntax::GenericArgument) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::GenericArgument::Lifetime(_binding_0) => {
                        v.visit_lifetime(_binding_0);
                    }
                    ::syntax::GenericArgument::Type(_binding_0) => {
                        v.visit_type(_binding_0);
                    }
                    ::syntax::GenericArgument::Const(_binding_0) => {
                        v.visit_expr(_binding_0);
                    }
                    ::syntax::GenericArgument::AssocType(_binding_0) => {
                        v.visit_assoc_type(_binding_0);
                    }
                    ::syntax::GenericArgument::AssocConst(_binding_0) => {
                        v.visit_assoc_const(_binding_0);
                    }
                    ::syntax::GenericArgument::Constraint(_binding_0) => {
                        v.visit_constraint(_binding_0);
                    }
                }
            }
            pub fn visit_generic_param<'ast, V>(v: &mut V, node: &'ast ::syntax::GenericParam) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::GenericParam::Lifetime(_binding_0) => {
                        v.visit_lifetime_param(_binding_0);
                    }
                    ::syntax::GenericParam::Type(_binding_0) => {
                        v.visit_type_param(_binding_0);
                    }
                    ::syntax::GenericParam::Const(_binding_0) => {
                        v.visit_const_param(_binding_0);
                    }
                }
            }
            pub fn visit_generics<'ast, V>(v: &mut V, node: &'ast ::syntax::Generics) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.lt_token);
                for el in Punctuated::pairs(&node.params) {
                    let it = el.value();
                    v.visit_generic_param(it);
                }
                skip!(node.gt_token);
                if let Some(it) = &node.where_clause {
                    v.visit_where_clause(it);
                }
            }
            pub fn visit_ident<'ast, V>(v: &mut V, node: &'ast process::macros::Ident) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_span(&node.span());
            }
                pub fn visit_impl_item<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItem) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::ImplItem::Const(_binding_0) => {
                        v.visit_impl_item_const(_binding_0);
                    }
                    ::syntax::ImplItem::Fn(_binding_0) => {
                        v.visit_impl_item_fn(_binding_0);
                    }
                    ::syntax::ImplItem::Type(_binding_0) => {
                        v.visit_impl_item_type(_binding_0);
                    }
                    ::syntax::ImplItem::Macro(_binding_0) => {
                        v.visit_impl_item_macro(_binding_0);
                    }
                    ::syntax::ImplItem::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
                pub fn visit_impl_item_const<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItemConst) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.defaultness);
                skip!(node.const_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                v.visit_type(&node.ty);
                skip!(node.eq_token);
                v.visit_expr(&node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_impl_item_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItemFn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.defaultness);
                v.visit_signature(&node.sig);
                v.visit_block(&node.block);
            }
                pub fn visit_impl_item_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItemMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_impl_item_type<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplItemType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.defaultness);
                skip!(node.type_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.eq_token);
                v.visit_type(&node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_impl_restriction<'ast, V>(v: &mut V, node: &'ast ::syntax::ImplRestriction) where
                V: Visit<'ast> + ?Sized,
            {
                match *node {}
            }
            pub fn visit_index<'ast, V>(v: &mut V, node: &'ast ::syntax::Index) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.index);
                v.visit_span(&node.span);
            }
                pub fn visit_item<'ast, V>(v: &mut V, node: &'ast ::syntax::Item) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Item::Const(_binding_0) => {
                        v.visit_item_const(_binding_0);
                    }
                    ::syntax::Item::Enum(_binding_0) => {
                        v.visit_item_enum(_binding_0);
                    }
                    ::syntax::Item::ExternCrate(_binding_0) => {
                        v.visit_item_extern_crate(_binding_0);
                    }
                    ::syntax::Item::Fn(_binding_0) => {
                        v.visit_item_fn(_binding_0);
                    }
                    ::syntax::Item::ForeignMod(_binding_0) => {
                        v.visit_item_foreign_mod(_binding_0);
                    }
                    ::syntax::Item::Impl(_binding_0) => {
                        v.visit_item_impl(_binding_0);
                    }
                    ::syntax::Item::Macro(_binding_0) => {
                        v.visit_item_macro(_binding_0);
                    }
                    ::syntax::Item::Mod(_binding_0) => {
                        v.visit_item_mod(_binding_0);
                    }
                    ::syntax::Item::Static(_binding_0) => {
                        v.visit_item_static(_binding_0);
                    }
                    ::syntax::Item::Struct(_binding_0) => {
                        v.visit_item_struct(_binding_0);
                    }
                    ::syntax::Item::Trait(_binding_0) => {
                        v.visit_item_trait(_binding_0);
                    }
                    ::syntax::Item::TraitAlias(_binding_0) => {
                        v.visit_item_trait_alias(_binding_0);
                    }
                    ::syntax::Item::Type(_binding_0) => {
                        v.visit_item_type(_binding_0);
                    }
                    ::syntax::Item::Union(_binding_0) => {
                        v.visit_item_union(_binding_0);
                    }
                    ::syntax::Item::Use(_binding_0) => {
                        v.visit_item_use(_binding_0);
                    }
                    ::syntax::Item::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
                pub fn visit_item_const<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemConst) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.const_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
                skip!(node.eq_token);
                v.visit_expr(&*node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_item_enum<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemEnum) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.enum_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.variants) {
                    let it = el.value();
                    v.visit_variant(it);
                }
            }
                pub fn visit_item_extern_crate<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemExternCrate) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.extern_token);
                skip!(node.crate_token);
                v.visit_ident(&node.ident);
                if let Some(it) = &node.rename {
                    skip!((it).0);
                    v.visit_ident(&(it).1);
                }
                skip!(node.semi_token);
            }
                pub fn visit_item_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemFn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                v.visit_signature(&node.sig);
                v.visit_block(&*node.block);
            }
                pub fn visit_item_foreign_mod<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemForeignMod) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.unsafety);
                v.visit_abi(&node.abi);
                skip!(node.brace_token);
                for it in &node.items {
                    v.visit_foreign_item(it);
                }
            }
                pub fn visit_item_impl<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemImpl) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.defaultness);
                skip!(node.unsafety);
                skip!(node.impl_token);
                v.visit_generics(&node.generics);
                if let Some(it) = &node.trait_ {
                    skip!((it).0);
                    v.visit_path(&(it).1);
                    skip!((it).2);
                }
                v.visit_type(&*node.self_ty);
                skip!(node.brace_token);
                for it in &node.items {
                    v.visit_impl_item(it);
                }
            }
                pub fn visit_item_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.ident {
                    v.visit_ident(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_item_mod<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemMod) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.unsafety);
                skip!(node.mod_token);
                v.visit_ident(&node.ident);
                if let Some(it) = &node.content {
                    skip!((it).0);
                    for it in &(it).1 {
                        v.visit_item(it);
                    }
                }
                skip!(node.semi);
            }
                pub fn visit_item_static<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemStatic) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.static_token);
                v.visit_static_mutability(&node.mutability);
                v.visit_ident(&node.ident);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
                skip!(node.eq_token);
                v.visit_expr(&*node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_item_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemStruct) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.struct_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                v.visit_fields(&node.fields);
                skip!(node.semi_token);
            }
                pub fn visit_item_trait<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemTrait) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.unsafety);
                skip!(node.auto_token);
                if let Some(it) = &node.restriction {
                    v.visit_impl_restriction(it);
                }
                skip!(node.trait_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.supertraits) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
                skip!(node.brace_token);
                for it in &node.items {
                    v.visit_trait_item(it);
                }
            }
                pub fn visit_item_trait_alias<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemTraitAlias) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.trait_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.eq_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_item_type<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.type_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.eq_token);
                v.visit_type(&*node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_item_union<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemUnion) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.union_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                v.visit_fields_named(&node.fields);
            }
                pub fn visit_item_use<'ast, V>(v: &mut V, node: &'ast ::syntax::ItemUse) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_visibility(&node.vis);
                skip!(node.use_token);
                skip!(node.leading_colon);
                v.visit_use_tree(&node.tree);
                skip!(node.semi_token);
            }
                pub fn visit_label<'ast, V>(v: &mut V, node: &'ast ::syntax::Label) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_lifetime(&node.name);
                skip!(node.colon_token);
            }
            pub fn visit_lifetime<'ast, V>(v: &mut V, node: &'ast ::syntax::Lifetime) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_span(&node.apostrophe);
                v.visit_ident(&node.ident);
            }
            pub fn visit_lifetime_param<'ast, V>(v: &mut V, node: &'ast ::syntax::LifetimeParam) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_lifetime(&node.lifetime);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_lifetime(it);
                }
            }
            pub fn visit_lit<'ast, V>(v: &mut V, node: &'ast ::syntax::Lit) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Lit::Str(_binding_0) => {
                        v.visit_lit_str(_binding_0);
                    }
                    ::syntax::Lit::ByteStr(_binding_0) => {
                        v.visit_lit_byte_str(_binding_0);
                    }
                    ::syntax::Lit::CStr(_binding_0) => {
                        v.visit_lit_cstr(_binding_0);
                    }
                    ::syntax::Lit::Byte(_binding_0) => {
                        v.visit_lit_byte(_binding_0);
                    }
                    ::syntax::Lit::Char(_binding_0) => {
                        v.visit_lit_char(_binding_0);
                    }
                    ::syntax::Lit::Int(_binding_0) => {
                        v.visit_lit_int(_binding_0);
                    }
                    ::syntax::Lit::Float(_binding_0) => {
                        v.visit_lit_float(_binding_0);
                    }
                    ::syntax::Lit::Bool(_binding_0) => {
                        v.visit_lit_bool(_binding_0);
                    }
                    ::syntax::Lit::Verbatim(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_lit_bool<'ast, V>(v: &mut V, node: &'ast ::syntax::LitBool) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.value);
                v.visit_span(&node.span);
            }
            pub fn visit_lit_byte<'ast, V>(v: &mut V, node: &'ast ::syntax::LitByte) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_byte_str<'ast, V>(v: &mut V, node: &'ast ::syntax::LitByteStr) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_cstr<'ast, V>(v: &mut V, node: &'ast ::syntax::LitCStr) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_char<'ast, V>(v: &mut V, node: &'ast ::syntax::LitChar) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_float<'ast, V>(v: &mut V, node: &'ast ::syntax::LitFloat) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_int<'ast, V>(v: &mut V, node: &'ast ::syntax::LitInt) where
                V: Visit<'ast> + ?Sized,
            {}
            pub fn visit_lit_str<'ast, V>(v: &mut V, node: &'ast ::syntax::LitStr) where
                V: Visit<'ast> + ?Sized,
            {}
                pub fn visit_local<'ast, V>(v: &mut V, node: &'ast ::syntax::Local) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.let_token);
                v.visit_pat(&node.pat);
                if let Some(it) = &node.init {
                    v.visit_local_init(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_local_init<'ast, V>(v: &mut V, node: &'ast ::syntax::LocalInit) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.eq_token);
                v.visit_expr(&*node.expr);
                if let Some(it) = &node.diverge {
                    skip!((it).0);
                    v.visit_expr(&*(it).1);
                }
            }
            pub fn visit_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::Macro) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_path(&node.path);
                skip!(node.bang_token);
                v.visit_macro_delimiter(&node.delimiter);
                v.visit_token_stream(&node.tokens);
            }
            pub fn visit_macro_delimiter<'ast, V>(v: &mut V, node: &'ast ::syntax::MacroDelimiter) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::MacroDelimiter::Paren(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::MacroDelimiter::Brace(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::MacroDelimiter::Bracket(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_member<'ast, V>(v: &mut V, node: &'ast ::syntax::Member) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Member::Named(_binding_0) => {
                        v.visit_ident(_binding_0);
                    }
                    ::syntax::Member::Unnamed(_binding_0) => {
                        v.visit_index(_binding_0);
                    }
                }
            }
            pub fn visit_meta<'ast, V>(v: &mut V, node: &'ast ::syntax::Meta) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Meta::Path(_binding_0) => {
                        v.visit_path(_binding_0);
                    }
                    ::syntax::Meta::List(_binding_0) => {
                        v.visit_meta_list(_binding_0);
                    }
                    ::syntax::Meta::NameValue(_binding_0) => {
                        v.visit_meta_name_value(_binding_0);
                    }
                }
            }
            pub fn visit_meta_list<'ast, V>(v: &mut V, node: &'ast ::syntax::MetaList) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_path(&node.path);
                v.visit_macro_delimiter(&node.delimiter);
                v.visit_token_stream(&node.tokens);
            }
            pub fn visit_meta_name_value<'ast, V>(v: &mut V, node: &'ast ::syntax::MetaNameValue) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_path(&node.path);
                skip!(node.eq_token);
                v.visit_expr(&node.value);
            }
            pub fn visit_parenthesized_generic_arguments<'ast, V>(
                v: &mut V,
                node: &'ast ::syntax::ParenthesizedGenericArguments,
            ) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.inputs) {
                    let it = el.value();
                    v.visit_type(it);
                }
                v.visit_return_type(&node.output);
            }
                pub fn visit_pat<'ast, V>(v: &mut V, node: &'ast ::syntax::Pat) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Pat::Const(_binding_0) => {
                        v.visit_expr_const(_binding_0);
                    }
                    ::syntax::Pat::Ident(_binding_0) => {
                        v.visit_pat_ident(_binding_0);
                    }
                    ::syntax::Pat::Lit(_binding_0) => {
                        v.visit_expr_lit(_binding_0);
                    }
                    ::syntax::Pat::Macro(_binding_0) => {
                        v.visit_expr_macro(_binding_0);
                    }
                    ::syntax::Pat::Or(_binding_0) => {
                        v.visit_pat_or(_binding_0);
                    }
                    ::syntax::Pat::Paren(_binding_0) => {
                        v.visit_pat_paren(_binding_0);
                    }
                    ::syntax::Pat::Path(_binding_0) => {
                        v.visit_expr_path(_binding_0);
                    }
                    ::syntax::Pat::Range(_binding_0) => {
                        v.visit_expr_range(_binding_0);
                    }
                    ::syntax::Pat::Reference(_binding_0) => {
                        v.visit_pat_reference(_binding_0);
                    }
                    ::syntax::Pat::Rest(_binding_0) => {
                        v.visit_pat_rest(_binding_0);
                    }
                    ::syntax::Pat::Slice(_binding_0) => {
                        v.visit_pat_slice(_binding_0);
                    }
                    ::syntax::Pat::Struct(_binding_0) => {
                        v.visit_pat_struct(_binding_0);
                    }
                    ::syntax::Pat::Tuple(_binding_0) => {
                        v.visit_pat_tuple(_binding_0);
                    }
                    ::syntax::Pat::TupleStruct(_binding_0) => {
                        v.visit_pat_tuple_struct(_binding_0);
                    }
                    ::syntax::Pat::Type(_binding_0) => {
                        v.visit_pat_type(_binding_0);
                    }
                    ::syntax::Pat::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                    ::syntax::Pat::Wild(_binding_0) => {
                        v.visit_pat_wild(_binding_0);
                    }
                }
            }
                pub fn visit_pat_ident<'ast, V>(v: &mut V, node: &'ast ::syntax::PatIdent) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.by_ref);
                skip!(node.mutability);
                v.visit_ident(&node.ident);
                if let Some(it) = &node.subpat {
                    skip!((it).0);
                    v.visit_pat(&*(it).1);
                }
            }
                pub fn visit_pat_or<'ast, V>(v: &mut V, node: &'ast ::syntax::PatOr) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.leading_vert);
                for el in Punctuated::pairs(&node.cases) {
                    let it = el.value();
                    v.visit_pat(it);
                }
            }
                pub fn visit_pat_paren<'ast, V>(v: &mut V, node: &'ast ::syntax::PatParen) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.paren_token);
                v.visit_pat(&*node.pat);
            }
                pub fn visit_pat_reference<'ast, V>(v: &mut V, node: &'ast ::syntax::PatReference) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.and_token);
                skip!(node.mutability);
                v.visit_pat(&*node.pat);
            }
                pub fn visit_pat_rest<'ast, V>(v: &mut V, node: &'ast ::syntax::PatRest) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.dot2_token);
            }
                pub fn visit_pat_slice<'ast, V>(v: &mut V, node: &'ast ::syntax::PatSlice) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.bracket_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_pat(it);
                }
            }
                pub fn visit_pat_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::PatStruct) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.fields) {
                    let it = el.value();
                    v.visit_field_pat(it);
                }
                if let Some(it) = &node.rest {
                    v.visit_pat_rest(it);
                }
            }
                pub fn visit_pat_tuple<'ast, V>(v: &mut V, node: &'ast ::syntax::PatTuple) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_pat(it);
                }
            }
                pub fn visit_pat_tuple_struct<'ast, V>(v: &mut V, node: &'ast ::syntax::PatTupleStruct) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_pat(it);
                }
            }
                pub fn visit_pat_type<'ast, V>(v: &mut V, node: &'ast ::syntax::PatType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_pat(&*node.pat);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
            }
                pub fn visit_pat_wild<'ast, V>(v: &mut V, node: &'ast ::syntax::PatWild) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.underscore_token);
            }
            pub fn visit_path<'ast, V>(v: &mut V, node: &'ast ::syntax::Path) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.leading_colon);
                for el in Punctuated::pairs(&node.segments) {
                    let it = el.value();
                    v.visit_path_segment(it);
                }
            }
            pub fn visit_path_arguments<'ast, V>(v: &mut V, node: &'ast ::syntax::PathArguments) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::PathArguments::None => {}
                    ::syntax::PathArguments::AngleBracketed(_binding_0) => {
                        v.visit_angle_bracketed_generic_arguments(_binding_0);
                    }
                    ::syntax::PathArguments::Parenthesized(_binding_0) => {
                        v.visit_parenthesized_generic_arguments(_binding_0);
                    }
                }
            }
            pub fn visit_path_segment<'ast, V>(v: &mut V, node: &'ast ::syntax::PathSegment) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                v.visit_path_arguments(&node.arguments);
            }
                pub fn visit_pointer_mutability<'ast, V>(v: &mut V, node: &'ast ::syntax::PointerMutability) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::PointerMutability::Const(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::PointerMutability::Mut(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_precise_capture<'ast, V>(v: &mut V, node: &'ast ::syntax::PreciseCapture) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.use_token);
                skip!(node.lt_token);
                for el in Punctuated::pairs(&node.params) {
                    let it = el.value();
                    v.visit_captured_param(it);
                }
                skip!(node.gt_token);
            }
            pub fn visit_predicate_lifetime<'ast, V>(v: &mut V, node: &'ast ::syntax::PredicateLifetime) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_lifetime(&node.lifetime);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_lifetime(it);
                }
            }
            pub fn visit_predicate_type<'ast, V>(v: &mut V, node: &'ast ::syntax::PredicateType) where
                V: Visit<'ast> + ?Sized,
            {
                if let Some(it) = &node.lifetimes {
                    v.visit_bound_lifetimes(it);
                }
                v.visit_type(&node.bounded_ty);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
            }
            pub fn visit_qself<'ast, V>(v: &mut V, node: &'ast ::syntax::QSelf) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.lt_token);
                v.visit_type(&*node.ty);
                skip!(node.position);
                skip!(node.as_token);
                skip!(node.gt_token);
            }
                pub fn visit_range_limits<'ast, V>(v: &mut V, node: &'ast ::syntax::RangeLimits) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::RangeLimits::HalfOpen(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::RangeLimits::Closed(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_receiver<'ast, V>(v: &mut V, node: &'ast ::syntax::Receiver) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.reference {
                    skip!((it).0);
                    if let Some(it) = &(it).1 {
                        v.visit_lifetime(it);
                    }
                }
                skip!(node.mutability);
                skip!(node.self_token);
                skip!(node.colon_token);
                v.visit_type(&*node.ty);
            }
            pub fn visit_return_type<'ast, V>(v: &mut V, node: &'ast ::syntax::ReturnType) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::ReturnType::Default => {}
                    ::syntax::ReturnType::Type(_binding_0, _binding_1) => {
                        skip!(_binding_0);
                        v.visit_type(&**_binding_1);
                    }
                }
            }
                pub fn visit_signature<'ast, V>(v: &mut V, node: &'ast ::syntax::Signature) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.constness);
                skip!(node.asyncness);
                skip!(node.unsafety);
                if let Some(it) = &node.abi {
                    v.visit_abi(it);
                }
                skip!(node.fn_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.inputs) {
                    let it = el.value();
                    v.visit_fn_arg(it);
                }
                if let Some(it) = &node.variadic {
                    v.visit_variadic(it);
                }
                v.visit_return_type(&node.output);
            }
            pub fn visit_span<'ast, V>(v: &mut V, node: &process::macros::Span) where
                V: Visit<'ast> + ?Sized,
            {}
                pub fn visit_static_mutability<'ast, V>(v: &mut V, node: &'ast ::syntax::StaticMutability) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::StaticMutability::Mut(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::StaticMutability::None => {}
                }
            }
                pub fn visit_stmt<'ast, V>(v: &mut V, node: &'ast ::syntax::Stmt) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Stmt::Local(_binding_0) => {
                        v.visit_local(_binding_0);
                    }
                    ::syntax::Stmt::Item(_binding_0) => {
                        v.visit_item(_binding_0);
                    }
                    ::syntax::Stmt::Expr(_binding_0, _binding_1) => {
                        v.visit_expr(_binding_0);
                        skip!(_binding_1);
                    }
                    ::syntax::Stmt::Macro(_binding_0) => {
                        v.visit_stmt_macro(_binding_0);
                    }
                }
            }
                pub fn visit_stmt_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::StmtMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
            pub fn visit_trait_bound<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitBound) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                v.visit_trait_bound_modifier(&node.modifier);
                if let Some(it) = &node.lifetimes {
                    v.visit_bound_lifetimes(it);
                }
                v.visit_path(&node.path);
            }
            pub fn visit_trait_bound_modifier<'ast, V>(
                v: &mut V,
                node: &'ast ::syntax::TraitBoundModifier,
            ) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::TraitBoundModifier::None => {}
                    ::syntax::TraitBoundModifier::Maybe(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_trait_item<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItem) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::TraitItem::Const(_binding_0) => {
                        v.visit_trait_item_const(_binding_0);
                    }
                    ::syntax::TraitItem::Fn(_binding_0) => {
                        v.visit_trait_item_fn(_binding_0);
                    }
                    ::syntax::TraitItem::Type(_binding_0) => {
                        v.visit_trait_item_type(_binding_0);
                    }
                    ::syntax::TraitItem::Macro(_binding_0) => {
                        v.visit_trait_item_macro(_binding_0);
                    }
                    ::syntax::TraitItem::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
                pub fn visit_trait_item_const<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItemConst) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.const_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                v.visit_type(&node.ty);
                if let Some(it) = &node.default {
                    skip!((it).0);
                    v.visit_expr(&(it).1);
                }
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItemFn) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_signature(&node.sig);
                if let Some(it) = &node.default {
                    v.visit_block(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItemMacro) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_macro(&node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_type<'ast, V>(v: &mut V, node: &'ast ::syntax::TraitItemType) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                skip!(node.type_token);
                v.visit_ident(&node.ident);
                v.visit_generics(&node.generics);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
                if let Some(it) = &node.default {
                    skip!((it).0);
                    v.visit_type(&(it).1);
                }
                skip!(node.semi_token);
            }
            pub fn visit_type<'ast, V>(v: &mut V, node: &'ast ::syntax::Type) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Type::Array(_binding_0) => {
                        v.visit_type_array(_binding_0);
                    }
                    ::syntax::Type::BareFn(_binding_0) => {
                        v.visit_type_bare_fn(_binding_0);
                    }
                    ::syntax::Type::Group(_binding_0) => {
                        v.visit_type_group(_binding_0);
                    }
                    ::syntax::Type::ImplTrait(_binding_0) => {
                        v.visit_type_impl_trait(_binding_0);
                    }
                    ::syntax::Type::Infer(_binding_0) => {
                        v.visit_type_infer(_binding_0);
                    }
                    ::syntax::Type::Macro(_binding_0) => {
                        v.visit_type_macro(_binding_0);
                    }
                    ::syntax::Type::Never(_binding_0) => {
                        v.visit_type_never(_binding_0);
                    }
                    ::syntax::Type::Paren(_binding_0) => {
                        v.visit_type_paren(_binding_0);
                    }
                    ::syntax::Type::Path(_binding_0) => {
                        v.visit_type_path(_binding_0);
                    }
                    ::syntax::Type::Ptr(_binding_0) => {
                        v.visit_type_ptr(_binding_0);
                    }
                    ::syntax::Type::Reference(_binding_0) => {
                        v.visit_type_reference(_binding_0);
                    }
                    ::syntax::Type::Slice(_binding_0) => {
                        v.visit_type_slice(_binding_0);
                    }
                    ::syntax::Type::TraitObject(_binding_0) => {
                        v.visit_type_trait_object(_binding_0);
                    }
                    ::syntax::Type::Tuple(_binding_0) => {
                        v.visit_type_tuple(_binding_0);
                    }
                    ::syntax::Type::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
            pub fn visit_type_array<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeArray) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.bracket_token);
                v.visit_type(&*node.elem);
                skip!(node.semi_token);
                v.visit_expr(&node.len);
            }
            pub fn visit_type_bare_fn<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeBareFn) where
                V: Visit<'ast> + ?Sized,
            {
                if let Some(it) = &node.lifetimes {
                    v.visit_bound_lifetimes(it);
                }
                skip!(node.unsafety);
                if let Some(it) = &node.abi {
                    v.visit_abi(it);
                }
                skip!(node.fn_token);
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.inputs) {
                    let it = el.value();
                    v.visit_bare_fn_arg(it);
                }
                if let Some(it) = &node.variadic {
                    v.visit_bare_variadic(it);
                }
                v.visit_return_type(&node.output);
            }
            pub fn visit_type_group<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeGroup) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.group_token);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_impl_trait<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeImplTrait) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.impl_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
            }
            pub fn visit_type_infer<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeInfer) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.underscore_token);
            }
            pub fn visit_type_macro<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeMacro) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_macro(&node.mac);
            }
            pub fn visit_type_never<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeNever) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.bang_token);
            }
            pub fn visit_type_param<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeParam) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_ident(&node.ident);
                skip!(node.colon_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
                skip!(node.eq_token);
                if let Some(it) = &node.default {
                    v.visit_type(it);
                }
            }
            pub fn visit_type_param_bound<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeParamBound) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::TypeParamBound::Trait(_binding_0) => {
                        v.visit_trait_bound(_binding_0);
                    }
                    ::syntax::TypeParamBound::Lifetime(_binding_0) => {
                        v.visit_lifetime(_binding_0);
                    }
                    ::syntax::TypeParamBound::PreciseCapture(_binding_0) => {
                        full!(v.visit_precise_capture(_binding_0));
                    }
                    ::syntax::TypeParamBound::Verbatim(_binding_0) => {
                        v.visit_token_stream(_binding_0);
                    }
                }
            }
            pub fn visit_type_paren<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeParen) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_path<'ast, V>(v: &mut V, node: &'ast ::syntax::TypePath) where
                V: Visit<'ast> + ?Sized,
            {
                if let Some(it) = &node.qself {
                    v.visit_qself(it);
                }
                v.visit_path(&node.path);
            }
            pub fn visit_type_ptr<'ast, V>(v: &mut V, node: &'ast ::syntax::TypePtr) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.star_token);
                skip!(node.const_token);
                skip!(node.mutability);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_reference<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeReference) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.and_token);
                if let Some(it) = &node.lifetime {
                    v.visit_lifetime(it);
                }
                skip!(node.mutability);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_slice<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeSlice) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.bracket_token);
                v.visit_type(&*node.elem);
            }
            pub fn visit_type_trait_object<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeTraitObject) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.dyn_token);
                for el in Punctuated::pairs(&node.bounds) {
                    let it = el.value();
                    v.visit_type_param_bound(it);
                }
            }
            pub fn visit_type_tuple<'ast, V>(v: &mut V, node: &'ast ::syntax::TypeTuple) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.paren_token);
                for el in Punctuated::pairs(&node.elems) {
                    let it = el.value();
                    v.visit_type(it);
                }
            }
            pub fn visit_un_op<'ast, V>(v: &mut V, node: &'ast ::syntax::UnOp) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::UnOp::Deref(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::UnOp::Not(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::UnOp::Neg(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_use_glob<'ast, V>(v: &mut V, node: &'ast ::syntax::UseGlob) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.star_token);
            }
                pub fn visit_use_group<'ast, V>(v: &mut V, node: &'ast ::syntax::UseGroup) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.brace_token);
                for el in Punctuated::pairs(&node.items) {
                    let it = el.value();
                    v.visit_use_tree(it);
                }
            }
                pub fn visit_use_name<'ast, V>(v: &mut V, node: &'ast ::syntax::UseName) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
            }
                pub fn visit_use_path<'ast, V>(v: &mut V, node: &'ast ::syntax::UsePath) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                skip!(node.colon2_token);
                v.visit_use_tree(&*node.tree);
            }
                pub fn visit_use_rename<'ast, V>(v: &mut V, node: &'ast ::syntax::UseRename) where
                V: Visit<'ast> + ?Sized,
            {
                v.visit_ident(&node.ident);
                skip!(node.as_token);
                v.visit_ident(&node.rename);
            }
                pub fn visit_use_tree<'ast, V>(v: &mut V, node: &'ast ::syntax::UseTree) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::UseTree::Path(_binding_0) => {
                        v.visit_use_path(_binding_0);
                    }
                    ::syntax::UseTree::Name(_binding_0) => {
                        v.visit_use_name(_binding_0);
                    }
                    ::syntax::UseTree::Rename(_binding_0) => {
                        v.visit_use_rename(_binding_0);
                    }
                    ::syntax::UseTree::Glob(_binding_0) => {
                        v.visit_use_glob(_binding_0);
                    }
                    ::syntax::UseTree::Group(_binding_0) => {
                        v.visit_use_group(_binding_0);
                    }
                }
            }
                pub fn visit_variadic<'ast, V>(v: &mut V, node: &'ast ::syntax::Variadic) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                if let Some(it) = &node.pat {
                    v.visit_pat(&*(it).0);
                    skip!((it).1);
                }
                skip!(node.dots);
                skip!(node.comma);
            }
            pub fn visit_variant<'ast, V>(v: &mut V, node: &'ast ::syntax::Variant) where
                V: Visit<'ast> + ?Sized,
            {
                for it in &node.attrs {
                    v.visit_attribute(it);
                }
                v.visit_ident(&node.ident);
                v.visit_fields(&node.fields);
                if let Some(it) = &node.discriminant {
                    skip!((it).0);
                    v.visit_expr(&(it).1);
                }
            }
            pub fn visit_vis_restricted<'ast, V>(v: &mut V, node: &'ast ::syntax::VisRestricted) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.pub_token);
                skip!(node.paren_token);
                skip!(node.in_token);
                v.visit_path(&*node.path);
            }
            pub fn visit_visibility<'ast, V>(v: &mut V, node: &'ast ::syntax::Visibility) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::Visibility::Public(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::Visibility::Restricted(_binding_0) => {
                        v.visit_vis_restricted(_binding_0);
                    }
                    ::syntax::Visibility::Inherited => {}
                }
            }
            pub fn visit_where_clause<'ast, V>(v: &mut V, node: &'ast ::syntax::WhereClause) where
                V: Visit<'ast> + ?Sized,
            {
                skip!(node.where_token);
                for el in Punctuated::pairs(&node.predicates) {
                    let it = el.value();
                    v.visit_where_predicate(it);
                }
            }
            pub fn visit_where_predicate<'ast, V>(v: &mut V, node: &'ast ::syntax::WherePredicate) where
                V: Visit<'ast> + ?Sized,
            {
                match node {
                    ::syntax::WherePredicate::Lifetime(_binding_0) => {
                        v.visit_predicate_lifetime(_binding_0);
                    }
                    ::syntax::WherePredicate::Type(_binding_0) => {
                        v.visit_predicate_type(_binding_0);
                    }
                }
            }
        }
        /// Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.
        pub mod visit_mut
        {
            use ::
            {
                syntax::
                {
                    punctuated::{ Punctuated },
                },
                *,
            };
            /*
            */
            macro_rules! full
            {
                ($e:expr) => {
                    $e
                };
            }
            
            macro_rules! skip {
                ($($tt:tt)*) => {};
            }
            /// Syntax tree traversal to mutate an exclusive borrow of a syntax tree in place.
            pub trait VisitMut {
                        fn visit_abi_mut(&mut self, i: &mut ::syntax::Abi) {
                    visit_abi_mut(self, i);
                }
                        fn visit_angle_bracketed_generic_arguments_mut(
                    &mut self,
                    i: &mut ::syntax::AngleBracketedGenericArguments,
                ) {
                    visit_angle_bracketed_generic_arguments_mut(self, i);
                }
                            fn visit_arm_mut(&mut self, i: &mut ::syntax::Arm) {
                    visit_arm_mut(self, i);
                }
                        fn visit_assoc_const_mut(&mut self, i: &mut ::syntax::AssocConst) {
                    visit_assoc_const_mut(self, i);
                }
                        fn visit_assoc_type_mut(&mut self, i: &mut ::syntax::AssocType) {
                    visit_assoc_type_mut(self, i);
                }
                        fn visit_attr_style_mut(&mut self, i: &mut ::syntax::AttrStyle) {
                    visit_attr_style_mut(self, i);
                }
                        fn visit_attribute_mut(&mut self, i: &mut ::syntax::Attribute) {
                    visit_attribute_mut(self, i);
                }
                        fn visit_attributes_mut(&mut self, i: &mut Vec<::syntax::Attribute>) {
                    for attr in i {
                        self.visit_attribute_mut(attr);
                    }
                }
                        fn visit_bare_fn_arg_mut(&mut self, i: &mut ::syntax::BareFnArg) {
                    visit_bare_fn_arg_mut(self, i);
                }
                        fn visit_bare_variadic_mut(&mut self, i: &mut ::syntax::BareVariadic) {
                    visit_bare_variadic_mut(self, i);
                }
                        fn visit_bin_op_mut(&mut self, i: &mut ::syntax::BinOp) {
                    visit_bin_op_mut(self, i);
                }
                            fn visit_block_mut(&mut self, i: &mut ::syntax::Block) {
                    visit_block_mut(self, i);
                }
                        fn visit_bound_lifetimes_mut(&mut self, i: &mut ::syntax::BoundLifetimes) {
                    visit_bound_lifetimes_mut(self, i);
                }
                            fn visit_captured_param_mut(&mut self, i: &mut ::syntax::CapturedParam) {
                    visit_captured_param_mut(self, i);
                }
                        fn visit_const_param_mut(&mut self, i: &mut ::syntax::ConstParam) {
                    visit_const_param_mut(self, i);
                }
                        fn visit_constraint_mut(&mut self, i: &mut ::syntax::Constraint) {
                    visit_constraint_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_mut(&mut self, i: &mut ::syntax::Data) {
                    visit_data_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_enum_mut(&mut self, i: &mut ::syntax::DataEnum) {
                    visit_data_enum_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_struct_mut(&mut self, i: &mut ::syntax::DataStruct) {
                    visit_data_struct_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_data_union_mut(&mut self, i: &mut ::syntax::DataUnion) {
                    visit_data_union_mut(self, i);
                }
                
                #[cfg_attr(docsrs, doc(cfg(feature = "derive")))]
                fn visit_derive_input_mut(&mut self, i: &mut ::syntax::DeriveInput) {
                    visit_derive_input_mut(self, i);
                }
                        fn visit_expr_mut(&mut self, i: &mut ::syntax::Expr) {
                    visit_expr_mut(self, i);
                }
                            fn visit_expr_array_mut(&mut self, i: &mut ::syntax::ExprArray) {
                    visit_expr_array_mut(self, i);
                }
                            fn visit_expr_assign_mut(&mut self, i: &mut ::syntax::ExprAssign) {
                    visit_expr_assign_mut(self, i);
                }
                            fn visit_expr_async_mut(&mut self, i: &mut ::syntax::ExprAsync) {
                    visit_expr_async_mut(self, i);
                }
                            fn visit_expr_await_mut(&mut self, i: &mut ::syntax::ExprAwait) {
                    visit_expr_await_mut(self, i);
                }
                        fn visit_expr_binary_mut(&mut self, i: &mut ::syntax::ExprBinary) {
                    visit_expr_binary_mut(self, i);
                }
                            fn visit_expr_block_mut(&mut self, i: &mut ::syntax::ExprBlock) {
                    visit_expr_block_mut(self, i);
                }
                            fn visit_expr_break_mut(&mut self, i: &mut ::syntax::ExprBreak) {
                    visit_expr_break_mut(self, i);
                }
                        fn visit_expr_call_mut(&mut self, i: &mut ::syntax::ExprCall) {
                    visit_expr_call_mut(self, i);
                }
                        fn visit_expr_cast_mut(&mut self, i: &mut ::syntax::ExprCast) {
                    visit_expr_cast_mut(self, i);
                }
                            fn visit_expr_closure_mut(&mut self, i: &mut ::syntax::ExprClosure) {
                    visit_expr_closure_mut(self, i);
                }
                            fn visit_expr_const_mut(&mut self, i: &mut ::syntax::ExprConst) {
                    visit_expr_const_mut(self, i);
                }
                            fn visit_expr_continue_mut(&mut self, i: &mut ::syntax::ExprContinue) {
                    visit_expr_continue_mut(self, i);
                }
                        fn visit_expr_field_mut(&mut self, i: &mut ::syntax::ExprField) {
                    visit_expr_field_mut(self, i);
                }
                            fn visit_expr_for_loop_mut(&mut self, i: &mut ::syntax::ExprForLoop) {
                    visit_expr_for_loop_mut(self, i);
                }
                        fn visit_expr_group_mut(&mut self, i: &mut ::syntax::ExprGroup) {
                    visit_expr_group_mut(self, i);
                }
                            fn visit_expr_if_mut(&mut self, i: &mut ::syntax::ExprIf) {
                    visit_expr_if_mut(self, i);
                }
                        fn visit_expr_index_mut(&mut self, i: &mut ::syntax::ExprIndex) {
                    visit_expr_index_mut(self, i);
                }
                            fn visit_expr_infer_mut(&mut self, i: &mut ::syntax::ExprInfer) {
                    visit_expr_infer_mut(self, i);
                }
                            fn visit_expr_let_mut(&mut self, i: &mut ::syntax::ExprLet) {
                    visit_expr_let_mut(self, i);
                }
                        fn visit_expr_lit_mut(&mut self, i: &mut ::syntax::ExprLit) {
                    visit_expr_lit_mut(self, i);
                }
                            fn visit_expr_loop_mut(&mut self, i: &mut ::syntax::ExprLoop) {
                    visit_expr_loop_mut(self, i);
                }
                        fn visit_expr_macro_mut(&mut self, i: &mut ::syntax::ExprMacro) {
                    visit_expr_macro_mut(self, i);
                }
                            fn visit_expr_match_mut(&mut self, i: &mut ::syntax::ExprMatch) {
                    visit_expr_match_mut(self, i);
                }
                        fn visit_expr_method_call_mut(&mut self, i: &mut ::syntax::ExprMethodCall) {
                    visit_expr_method_call_mut(self, i);
                }
                        fn visit_expr_paren_mut(&mut self, i: &mut ::syntax::ExprParen) {
                    visit_expr_paren_mut(self, i);
                }
                        fn visit_expr_path_mut(&mut self, i: &mut ::syntax::ExprPath) {
                    visit_expr_path_mut(self, i);
                }
                            fn visit_expr_range_mut(&mut self, i: &mut ::syntax::ExprRange) {
                    visit_expr_range_mut(self, i);
                }
                            fn visit_expr_raw_addr_mut(&mut self, i: &mut ::syntax::ExprRawAddr) {
                    visit_expr_raw_addr_mut(self, i);
                }
                        fn visit_expr_reference_mut(&mut self, i: &mut ::syntax::ExprReference) {
                    visit_expr_reference_mut(self, i);
                }
                            fn visit_expr_repeat_mut(&mut self, i: &mut ::syntax::ExprRepeat) {
                    visit_expr_repeat_mut(self, i);
                }
                            fn visit_expr_return_mut(&mut self, i: &mut ::syntax::ExprReturn) {
                    visit_expr_return_mut(self, i);
                }
                        fn visit_expr_struct_mut(&mut self, i: &mut ::syntax::ExprStruct) {
                    visit_expr_struct_mut(self, i);
                }
                            fn visit_expr_try_mut(&mut self, i: &mut ::syntax::ExprTry) {
                    visit_expr_try_mut(self, i);
                }
                            fn visit_expr_try_block_mut(&mut self, i: &mut ::syntax::ExprTryBlock) {
                    visit_expr_try_block_mut(self, i);
                }
                        fn visit_expr_tuple_mut(&mut self, i: &mut ::syntax::ExprTuple) {
                    visit_expr_tuple_mut(self, i);
                }
                        fn visit_expr_unary_mut(&mut self, i: &mut ::syntax::ExprUnary) {
                    visit_expr_unary_mut(self, i);
                }
                            fn visit_expr_unsafe_mut(&mut self, i: &mut ::syntax::ExprUnsafe) {
                    visit_expr_unsafe_mut(self, i);
                }
                            fn visit_expr_while_mut(&mut self, i: &mut ::syntax::ExprWhile) {
                    visit_expr_while_mut(self, i);
                }
                            fn visit_expr_yield_mut(&mut self, i: &mut ::syntax::ExprYield) {
                    visit_expr_yield_mut(self, i);
                }
                        fn visit_field_mut(&mut self, i: &mut ::syntax::Field) {
                    visit_field_mut(self, i);
                }
                        fn visit_field_mutability_mut(&mut self, i: &mut ::syntax::FieldMutability) {
                    visit_field_mutability_mut(self, i);
                }
                            fn visit_field_pat_mut(&mut self, i: &mut ::syntax::FieldPat) {
                    visit_field_pat_mut(self, i);
                }
                        fn visit_field_value_mut(&mut self, i: &mut ::syntax::FieldValue) {
                    visit_field_value_mut(self, i);
                }
                        fn visit_fields_mut(&mut self, i: &mut ::syntax::Fields) {
                    visit_fields_mut(self, i);
                }
                        fn visit_fields_named_mut(&mut self, i: &mut ::syntax::FieldsNamed) {
                    visit_fields_named_mut(self, i);
                }
                        fn visit_fields_unnamed_mut(&mut self, i: &mut ::syntax::FieldsUnnamed) {
                    visit_fields_unnamed_mut(self, i);
                }
                            fn visit_file_mut(&mut self, i: &mut ::syntax::File) {
                    visit_file_mut(self, i);
                }
                            fn visit_fn_arg_mut(&mut self, i: &mut ::syntax::FnArg) {
                    visit_fn_arg_mut(self, i);
                }
                            fn visit_foreign_item_mut(&mut self, i: &mut ::syntax::ForeignItem) {
                    visit_foreign_item_mut(self, i);
                }
                            fn visit_foreign_item_fn_mut(&mut self, i: &mut ::syntax::ForeignItemFn) {
                    visit_foreign_item_fn_mut(self, i);
                }
                            fn visit_foreign_item_macro_mut(&mut self, i: &mut ::syntax::ForeignItemMacro) {
                    visit_foreign_item_macro_mut(self, i);
                }
                            fn visit_foreign_item_static_mut(&mut self, i: &mut ::syntax::ForeignItemStatic) {
                    visit_foreign_item_static_mut(self, i);
                }
                            fn visit_foreign_item_type_mut(&mut self, i: &mut ::syntax::ForeignItemType) {
                    visit_foreign_item_type_mut(self, i);
                }
                        fn visit_generic_argument_mut(&mut self, i: &mut ::syntax::GenericArgument) {
                    visit_generic_argument_mut(self, i);
                }
                        fn visit_generic_param_mut(&mut self, i: &mut ::syntax::GenericParam) {
                    visit_generic_param_mut(self, i);
                }
                        fn visit_generics_mut(&mut self, i: &mut ::syntax::Generics) {
                    visit_generics_mut(self, i);
                }
                fn visit_ident_mut(&mut self, i: &mut process::macros::Ident) {
                    visit_ident_mut(self, i);
                }
                            fn visit_impl_item_mut(&mut self, i: &mut ::syntax::ImplItem) {
                    visit_impl_item_mut(self, i);
                }
                            fn visit_impl_item_const_mut(&mut self, i: &mut ::syntax::ImplItemConst) {
                    visit_impl_item_const_mut(self, i);
                }
                            fn visit_impl_item_fn_mut(&mut self, i: &mut ::syntax::ImplItemFn) {
                    visit_impl_item_fn_mut(self, i);
                }
                            fn visit_impl_item_macro_mut(&mut self, i: &mut ::syntax::ImplItemMacro) {
                    visit_impl_item_macro_mut(self, i);
                }
                            fn visit_impl_item_type_mut(&mut self, i: &mut ::syntax::ImplItemType) {
                    visit_impl_item_type_mut(self, i);
                }
                            fn visit_impl_restriction_mut(&mut self, i: &mut ::syntax::ImplRestriction) {
                    visit_impl_restriction_mut(self, i);
                }
                        fn visit_index_mut(&mut self, i: &mut ::syntax::Index) {
                    visit_index_mut(self, i);
                }
                            fn visit_item_mut(&mut self, i: &mut ::syntax::Item) {
                    visit_item_mut(self, i);
                }
                            fn visit_item_const_mut(&mut self, i: &mut ::syntax::ItemConst) {
                    visit_item_const_mut(self, i);
                }
                            fn visit_item_enum_mut(&mut self, i: &mut ::syntax::ItemEnum) {
                    visit_item_enum_mut(self, i);
                }
                            fn visit_item_extern_crate_mut(&mut self, i: &mut ::syntax::ItemExternCrate) {
                    visit_item_extern_crate_mut(self, i);
                }
                            fn visit_item_fn_mut(&mut self, i: &mut ::syntax::ItemFn) {
                    visit_item_fn_mut(self, i);
                }
                            fn visit_item_foreign_mod_mut(&mut self, i: &mut ::syntax::ItemForeignMod) {
                    visit_item_foreign_mod_mut(self, i);
                }
                            fn visit_item_impl_mut(&mut self, i: &mut ::syntax::ItemImpl) {
                    visit_item_impl_mut(self, i);
                }
                            fn visit_item_macro_mut(&mut self, i: &mut ::syntax::ItemMacro) {
                    visit_item_macro_mut(self, i);
                }
                            fn visit_item_mod_mut(&mut self, i: &mut ::syntax::ItemMod) {
                    visit_item_mod_mut(self, i);
                }
                            fn visit_item_static_mut(&mut self, i: &mut ::syntax::ItemStatic) {
                    visit_item_static_mut(self, i);
                }
                            fn visit_item_struct_mut(&mut self, i: &mut ::syntax::ItemStruct) {
                    visit_item_struct_mut(self, i);
                }
                            fn visit_item_trait_mut(&mut self, i: &mut ::syntax::ItemTrait) {
                    visit_item_trait_mut(self, i);
                }
                            fn visit_item_trait_alias_mut(&mut self, i: &mut ::syntax::ItemTraitAlias) {
                    visit_item_trait_alias_mut(self, i);
                }
                            fn visit_item_type_mut(&mut self, i: &mut ::syntax::ItemType) {
                    visit_item_type_mut(self, i);
                }
                            fn visit_item_union_mut(&mut self, i: &mut ::syntax::ItemUnion) {
                    visit_item_union_mut(self, i);
                }
                            fn visit_item_use_mut(&mut self, i: &mut ::syntax::ItemUse) {
                    visit_item_use_mut(self, i);
                }
                            fn visit_label_mut(&mut self, i: &mut ::syntax::Label) {
                    visit_label_mut(self, i);
                }
                fn visit_lifetime_mut(&mut self, i: &mut ::syntax::Lifetime) {
                    visit_lifetime_mut(self, i);
                }
                        fn visit_lifetime_param_mut(&mut self, i: &mut ::syntax::LifetimeParam) {
                    visit_lifetime_param_mut(self, i);
                }
                fn visit_lit_mut(&mut self, i: &mut ::syntax::Lit) {
                    visit_lit_mut(self, i);
                }
                fn visit_lit_bool_mut(&mut self, i: &mut ::syntax::LitBool) {
                    visit_lit_bool_mut(self, i);
                }
                fn visit_lit_byte_mut(&mut self, i: &mut ::syntax::LitByte) {
                    visit_lit_byte_mut(self, i);
                }
                fn visit_lit_byte_str_mut(&mut self, i: &mut ::syntax::LitByteStr) {
                    visit_lit_byte_str_mut(self, i);
                }
                fn visit_lit_cstr_mut(&mut self, i: &mut ::syntax::LitCStr) {
                    visit_lit_cstr_mut(self, i);
                }
                fn visit_lit_char_mut(&mut self, i: &mut ::syntax::LitChar) {
                    visit_lit_char_mut(self, i);
                }
                fn visit_lit_float_mut(&mut self, i: &mut ::syntax::LitFloat) {
                    visit_lit_float_mut(self, i);
                }
                fn visit_lit_int_mut(&mut self, i: &mut ::syntax::LitInt) {
                    visit_lit_int_mut(self, i);
                }
                fn visit_lit_str_mut(&mut self, i: &mut ::syntax::LitStr) {
                    visit_lit_str_mut(self, i);
                }
                            fn visit_local_mut(&mut self, i: &mut ::syntax::Local) {
                    visit_local_mut(self, i);
                }
                            fn visit_local_init_mut(&mut self, i: &mut ::syntax::LocalInit) {
                    visit_local_init_mut(self, i);
                }
                        fn visit_macro_mut(&mut self, i: &mut ::syntax::Macro) {
                    visit_macro_mut(self, i);
                }
                        fn visit_macro_delimiter_mut(&mut self, i: &mut ::syntax::MacroDelimiter) {
                    visit_macro_delimiter_mut(self, i);
                }
                        fn visit_member_mut(&mut self, i: &mut ::syntax::Member) {
                    visit_member_mut(self, i);
                }
                        fn visit_meta_mut(&mut self, i: &mut ::syntax::Meta) {
                    visit_meta_mut(self, i);
                }
                        fn visit_meta_list_mut(&mut self, i: &mut ::syntax::MetaList) {
                    visit_meta_list_mut(self, i);
                }
                        fn visit_meta_name_value_mut(&mut self, i: &mut ::syntax::MetaNameValue) {
                    visit_meta_name_value_mut(self, i);
                }
                        fn visit_parenthesized_generic_arguments_mut(
                    &mut self,
                    i: &mut ::syntax::ParenthesizedGenericArguments,
                ) {
                    visit_parenthesized_generic_arguments_mut(self, i);
                }
                            fn visit_pat_mut(&mut self, i: &mut ::syntax::Pat) {
                    visit_pat_mut(self, i);
                }
                            fn visit_pat_ident_mut(&mut self, i: &mut ::syntax::PatIdent) {
                    visit_pat_ident_mut(self, i);
                }
                            fn visit_pat_or_mut(&mut self, i: &mut ::syntax::PatOr) {
                    visit_pat_or_mut(self, i);
                }
                            fn visit_pat_paren_mut(&mut self, i: &mut ::syntax::PatParen) {
                    visit_pat_paren_mut(self, i);
                }
                            fn visit_pat_reference_mut(&mut self, i: &mut ::syntax::PatReference) {
                    visit_pat_reference_mut(self, i);
                }
                            fn visit_pat_rest_mut(&mut self, i: &mut ::syntax::PatRest) {
                    visit_pat_rest_mut(self, i);
                }
                            fn visit_pat_slice_mut(&mut self, i: &mut ::syntax::PatSlice) {
                    visit_pat_slice_mut(self, i);
                }
                            fn visit_pat_struct_mut(&mut self, i: &mut ::syntax::PatStruct) {
                    visit_pat_struct_mut(self, i);
                }
                            fn visit_pat_tuple_mut(&mut self, i: &mut ::syntax::PatTuple) {
                    visit_pat_tuple_mut(self, i);
                }
                            fn visit_pat_tuple_struct_mut(&mut self, i: &mut ::syntax::PatTupleStruct) {
                    visit_pat_tuple_struct_mut(self, i);
                }
                            fn visit_pat_type_mut(&mut self, i: &mut ::syntax::PatType) {
                    visit_pat_type_mut(self, i);
                }
                            fn visit_pat_wild_mut(&mut self, i: &mut ::syntax::PatWild) {
                    visit_pat_wild_mut(self, i);
                }
                        fn visit_path_mut(&mut self, i: &mut ::syntax::Path) {
                    visit_path_mut(self, i);
                }
                        fn visit_path_arguments_mut(&mut self, i: &mut ::syntax::PathArguments) {
                    visit_path_arguments_mut(self, i);
                }
                        fn visit_path_segment_mut(&mut self, i: &mut ::syntax::PathSegment) {
                    visit_path_segment_mut(self, i);
                }
                            fn visit_pointer_mutability_mut(&mut self, i: &mut ::syntax::PointerMutability) {
                    visit_pointer_mutability_mut(self, i);
                }
                            fn visit_precise_capture_mut(&mut self, i: &mut ::syntax::PreciseCapture) {
                    visit_precise_capture_mut(self, i);
                }
                        fn visit_predicate_lifetime_mut(&mut self, i: &mut ::syntax::PredicateLifetime) {
                    visit_predicate_lifetime_mut(self, i);
                }
                        fn visit_predicate_type_mut(&mut self, i: &mut ::syntax::PredicateType) {
                    visit_predicate_type_mut(self, i);
                }
                        fn visit_qself_mut(&mut self, i: &mut ::syntax::QSelf) {
                    visit_qself_mut(self, i);
                }
                            fn visit_range_limits_mut(&mut self, i: &mut ::syntax::RangeLimits) {
                    visit_range_limits_mut(self, i);
                }
                            fn visit_receiver_mut(&mut self, i: &mut ::syntax::Receiver) {
                    visit_receiver_mut(self, i);
                }
                        fn visit_return_type_mut(&mut self, i: &mut ::syntax::ReturnType) {
                    visit_return_type_mut(self, i);
                }
                            fn visit_signature_mut(&mut self, i: &mut ::syntax::Signature) {
                    visit_signature_mut(self, i);
                }
                fn visit_span_mut(&mut self, i: &mut process::macros::Span) {}
                            fn visit_static_mutability_mut(&mut self, i: &mut ::syntax::StaticMutability) {
                    visit_static_mutability_mut(self, i);
                }
                            fn visit_stmt_mut(&mut self, i: &mut ::syntax::Stmt) {
                    visit_stmt_mut(self, i);
                }
                            fn visit_stmt_macro_mut(&mut self, i: &mut ::syntax::StmtMacro) {
                    visit_stmt_macro_mut(self, i);
                }
                fn visit_token_stream_mut(&mut self, i: &mut process::macros::TokenStream) {}
                        fn visit_trait_bound_mut(&mut self, i: &mut ::syntax::TraitBound) {
                    visit_trait_bound_mut(self, i);
                }
                        fn visit_trait_bound_modifier_mut(&mut self, i: &mut ::syntax::TraitBoundModifier) {
                    visit_trait_bound_modifier_mut(self, i);
                }
                            fn visit_trait_item_mut(&mut self, i: &mut ::syntax::TraitItem) {
                    visit_trait_item_mut(self, i);
                }
                            fn visit_trait_item_const_mut(&mut self, i: &mut ::syntax::TraitItemConst) {
                    visit_trait_item_const_mut(self, i);
                }
                            fn visit_trait_item_fn_mut(&mut self, i: &mut ::syntax::TraitItemFn) {
                    visit_trait_item_fn_mut(self, i);
                }
                            fn visit_trait_item_macro_mut(&mut self, i: &mut ::syntax::TraitItemMacro) {
                    visit_trait_item_macro_mut(self, i);
                }
                            fn visit_trait_item_type_mut(&mut self, i: &mut ::syntax::TraitItemType) {
                    visit_trait_item_type_mut(self, i);
                }
                        fn visit_type_mut(&mut self, i: &mut ::syntax::Type) {
                    visit_type_mut(self, i);
                }
                        fn visit_type_array_mut(&mut self, i: &mut ::syntax::TypeArray) {
                    visit_type_array_mut(self, i);
                }
                        fn visit_type_bare_fn_mut(&mut self, i: &mut ::syntax::TypeBareFn) {
                    visit_type_bare_fn_mut(self, i);
                }
                        fn visit_type_group_mut(&mut self, i: &mut ::syntax::TypeGroup) {
                    visit_type_group_mut(self, i);
                }
                        fn visit_type_impl_trait_mut(&mut self, i: &mut ::syntax::TypeImplTrait) {
                    visit_type_impl_trait_mut(self, i);
                }
                        fn visit_type_infer_mut(&mut self, i: &mut ::syntax::TypeInfer) {
                    visit_type_infer_mut(self, i);
                }
                        fn visit_type_macro_mut(&mut self, i: &mut ::syntax::TypeMacro) {
                    visit_type_macro_mut(self, i);
                }
                        fn visit_type_never_mut(&mut self, i: &mut ::syntax::TypeNever) {
                    visit_type_never_mut(self, i);
                }
                        fn visit_type_param_mut(&mut self, i: &mut ::syntax::TypeParam) {
                    visit_type_param_mut(self, i);
                }
                        fn visit_type_param_bound_mut(&mut self, i: &mut ::syntax::TypeParamBound) {
                    visit_type_param_bound_mut(self, i);
                }
                        fn visit_type_paren_mut(&mut self, i: &mut ::syntax::TypeParen) {
                    visit_type_paren_mut(self, i);
                }
                        fn visit_type_path_mut(&mut self, i: &mut ::syntax::TypePath) {
                    visit_type_path_mut(self, i);
                }
                        fn visit_type_ptr_mut(&mut self, i: &mut ::syntax::TypePtr) {
                    visit_type_ptr_mut(self, i);
                }
                        fn visit_type_reference_mut(&mut self, i: &mut ::syntax::TypeReference) {
                    visit_type_reference_mut(self, i);
                }
                        fn visit_type_slice_mut(&mut self, i: &mut ::syntax::TypeSlice) {
                    visit_type_slice_mut(self, i);
                }
                        fn visit_type_trait_object_mut(&mut self, i: &mut ::syntax::TypeTraitObject) {
                    visit_type_trait_object_mut(self, i);
                }
                        fn visit_type_tuple_mut(&mut self, i: &mut ::syntax::TypeTuple) {
                    visit_type_tuple_mut(self, i);
                }
                        fn visit_un_op_mut(&mut self, i: &mut ::syntax::UnOp) {
                    visit_un_op_mut(self, i);
                }
                            fn visit_use_glob_mut(&mut self, i: &mut ::syntax::UseGlob) {
                    visit_use_glob_mut(self, i);
                }
                            fn visit_use_group_mut(&mut self, i: &mut ::syntax::UseGroup) {
                    visit_use_group_mut(self, i);
                }
                            fn visit_use_name_mut(&mut self, i: &mut ::syntax::UseName) {
                    visit_use_name_mut(self, i);
                }
                            fn visit_use_path_mut(&mut self, i: &mut ::syntax::UsePath) {
                    visit_use_path_mut(self, i);
                }
                            fn visit_use_rename_mut(&mut self, i: &mut ::syntax::UseRename) {
                    visit_use_rename_mut(self, i);
                }
                            fn visit_use_tree_mut(&mut self, i: &mut ::syntax::UseTree) {
                    visit_use_tree_mut(self, i);
                }
                            fn visit_variadic_mut(&mut self, i: &mut ::syntax::Variadic) {
                    visit_variadic_mut(self, i);
                }
                        fn visit_variant_mut(&mut self, i: &mut ::syntax::Variant) {
                    visit_variant_mut(self, i);
                }
                        fn visit_vis_restricted_mut(&mut self, i: &mut ::syntax::VisRestricted) {
                    visit_vis_restricted_mut(self, i);
                }
                        fn visit_visibility_mut(&mut self, i: &mut ::syntax::Visibility) {
                    visit_visibility_mut(self, i);
                }
                        fn visit_where_clause_mut(&mut self, i: &mut ::syntax::WhereClause) {
                    visit_where_clause_mut(self, i);
                }
                        fn visit_where_predicate_mut(&mut self, i: &mut ::syntax::WherePredicate) {
                    visit_where_predicate_mut(self, i);
                }
            }
            pub fn visit_abi_mut<V>(v: &mut V, node: &mut ::syntax::Abi) where
                V: VisitMut + ?Sized,
            {
                skip!(node.extern_token);
                if let Some(it) = &mut node.name {
                    v.visit_lit_str_mut(it);
                }
            }
            pub fn visit_angle_bracketed_generic_arguments_mut<V>(
                v: &mut V,
                node: &mut ::syntax::AngleBracketedGenericArguments,
            ) where
                V: VisitMut + ?Sized,
            {
                skip!(node.colon2_token);
                skip!(node.lt_token);
                for mut el in Punctuated::pairs_mut(&mut node.args) {
                    let it = el.value_mut();
                    v.visit_generic_argument_mut(it);
                }
                skip!(node.gt_token);
            }
                pub fn visit_arm_mut<V>(v: &mut V, node: &mut ::syntax::Arm) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_pat_mut(&mut node.pat);
                if let Some(it) = &mut node.guard {
                    skip!((it).0);
                    v.visit_expr_mut(&mut *(it).1);
                }
                skip!(node.fat_arrow_token);
                v.visit_expr_mut(&mut *node.body);
                skip!(node.comma);
            }
            pub fn visit_assoc_const_mut<V>(v: &mut V, node: &mut ::syntax::AssocConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.generics {
                    v.visit_angle_bracketed_generic_arguments_mut(it);
                }
                skip!(node.eq_token);
                v.visit_expr_mut(&mut node.value);
            }
            pub fn visit_assoc_type_mut<V>(v: &mut V, node: &mut ::syntax::AssocType) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.generics {
                    v.visit_angle_bracketed_generic_arguments_mut(it);
                }
                skip!(node.eq_token);
                v.visit_type_mut(&mut node.ty);
            }
            pub fn visit_attr_style_mut<V>(v: &mut V, node: &mut ::syntax::AttrStyle) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::AttrStyle::Outer => {}
                    ::syntax::AttrStyle::Inner(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_attribute_mut<V>(v: &mut V, node: &mut ::syntax::Attribute) where
                V: VisitMut + ?Sized,
            {
                skip!(node.pound_token);
                v.visit_attr_style_mut(&mut node.style);
                skip!(node.bracket_token);
                v.visit_meta_mut(&mut node.meta);
            }
            pub fn visit_bare_fn_arg_mut<V>(v: &mut V, node: &mut ::syntax::BareFnArg) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.name {
                    v.visit_ident_mut(&mut (it).0);
                    skip!((it).1);
                }
                v.visit_type_mut(&mut node.ty);
            }
            pub fn visit_bare_variadic_mut<V>(v: &mut V, node: &mut ::syntax::BareVariadic) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.name {
                    v.visit_ident_mut(&mut (it).0);
                    skip!((it).1);
                }
                skip!(node.dots);
                skip!(node.comma);
            }
            pub fn visit_bin_op_mut<V>(v: &mut V, node: &mut ::syntax::BinOp) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::BinOp::Add(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Sub(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Mul(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Div(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Rem(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::And(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Or(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitXor(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitAnd(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitOr(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Shl(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Shr(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Eq(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Lt(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Le(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Ne(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Ge(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::Gt(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::AddAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::SubAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::MulAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::DivAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::RemAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitXorAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitAndAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::BitOrAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::ShlAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::BinOp::ShrAssign(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_block_mut<V>(v: &mut V, node: &mut ::syntax::Block) where
                V: VisitMut + ?Sized,
            {
                skip!(node.brace_token);
                for it in &mut node.stmts {
                    v.visit_stmt_mut(it);
                }
            }
            pub fn visit_bound_lifetimes_mut<V>(v: &mut V, node: &mut ::syntax::BoundLifetimes) where
                V: VisitMut + ?Sized,
            {
                skip!(node.for_token);
                skip!(node.lt_token);
                for mut el in Punctuated::pairs_mut(&mut node.lifetimes) {
                    let it = el.value_mut();
                    v.visit_generic_param_mut(it);
                }
                skip!(node.gt_token);
            }
                pub fn visit_captured_param_mut<V>(v: &mut V, node: &mut ::syntax::CapturedParam) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::CapturedParam::Lifetime(_binding_0) => {
                        v.visit_lifetime_mut(_binding_0);
                    }
                    ::syntax::CapturedParam::Ident(_binding_0) => {
                        v.visit_ident_mut(_binding_0);
                    }
                }
            }
            pub fn visit_const_param_mut<V>(v: &mut V, node: &mut ::syntax::ConstParam) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.const_token);
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon_token);
                v.visit_type_mut(&mut node.ty);
                skip!(node.eq_token);
                if let Some(it) = &mut node.default {
                    v.visit_expr_mut(it);
                }
            }
            pub fn visit_constraint_mut<V>(v: &mut V, node: &mut ::syntax::Constraint) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.generics {
                    v.visit_angle_bracketed_generic_arguments_mut(it);
                }
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
            }
            pub fn visit_data_mut<V>(v: &mut V, node: &mut ::syntax::Data) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Data::Struct(_binding_0) => {
                        v.visit_data_struct_mut(_binding_0);
                    }
                    ::syntax::Data::Enum(_binding_0) => {
                        v.visit_data_enum_mut(_binding_0);
                    }
                    ::syntax::Data::Union(_binding_0) => {
                        v.visit_data_union_mut(_binding_0);
                    }
                }
            }
            pub fn visit_data_enum_mut<V>(v: &mut V, node: &mut ::syntax::DataEnum) where
                V: VisitMut + ?Sized,
            {
                skip!(node.enum_token);
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.variants) {
                    let it = el.value_mut();
                    v.visit_variant_mut(it);
                }
            }
            pub fn visit_data_struct_mut<V>(v: &mut V, node: &mut ::syntax::DataStruct) where
                V: VisitMut + ?Sized,
            {
                skip!(node.struct_token);
                v.visit_fields_mut(&mut node.fields);
                skip!(node.semi_token);
            }
            pub fn visit_data_union_mut<V>(v: &mut V, node: &mut ::syntax::DataUnion) where
                V: VisitMut + ?Sized,
            {
                skip!(node.union_token);
                v.visit_fields_named_mut(&mut node.fields);
            }
            pub fn visit_derive_input_mut<V>(v: &mut V, node: &mut ::syntax::DeriveInput) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                v.visit_data_mut(&mut node.data);
            }
            pub fn visit_expr_mut<V>(v: &mut V, node: &mut ::syntax::Expr) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Expr::Array(_binding_0) => {
                        full!(v.visit_expr_array_mut(_binding_0));
                    }
                    ::syntax::Expr::Assign(_binding_0) => {
                        full!(v.visit_expr_assign_mut(_binding_0));
                    }
                    ::syntax::Expr::Async(_binding_0) => {
                        full!(v.visit_expr_async_mut(_binding_0));
                    }
                    ::syntax::Expr::Await(_binding_0) => {
                        full!(v.visit_expr_await_mut(_binding_0));
                    }
                    ::syntax::Expr::Binary(_binding_0) => {
                        v.visit_expr_binary_mut(_binding_0);
                    }
                    ::syntax::Expr::Block(_binding_0) => {
                        full!(v.visit_expr_block_mut(_binding_0));
                    }
                    ::syntax::Expr::Break(_binding_0) => {
                        full!(v.visit_expr_break_mut(_binding_0));
                    }
                    ::syntax::Expr::Call(_binding_0) => {
                        v.visit_expr_call_mut(_binding_0);
                    }
                    ::syntax::Expr::Cast(_binding_0) => {
                        v.visit_expr_cast_mut(_binding_0);
                    }
                    ::syntax::Expr::Closure(_binding_0) => {
                        full!(v.visit_expr_closure_mut(_binding_0));
                    }
                    ::syntax::Expr::Const(_binding_0) => {
                        full!(v.visit_expr_const_mut(_binding_0));
                    }
                    ::syntax::Expr::Continue(_binding_0) => {
                        full!(v.visit_expr_continue_mut(_binding_0));
                    }
                    ::syntax::Expr::Field(_binding_0) => {
                        v.visit_expr_field_mut(_binding_0);
                    }
                    ::syntax::Expr::ForLoop(_binding_0) => {
                        full!(v.visit_expr_for_loop_mut(_binding_0));
                    }
                    ::syntax::Expr::Group(_binding_0) => {
                        v.visit_expr_group_mut(_binding_0);
                    }
                    ::syntax::Expr::If(_binding_0) => {
                        full!(v.visit_expr_if_mut(_binding_0));
                    }
                    ::syntax::Expr::Index(_binding_0) => {
                        v.visit_expr_index_mut(_binding_0);
                    }
                    ::syntax::Expr::Infer(_binding_0) => {
                        full!(v.visit_expr_infer_mut(_binding_0));
                    }
                    ::syntax::Expr::Let(_binding_0) => {
                        full!(v.visit_expr_let_mut(_binding_0));
                    }
                    ::syntax::Expr::Lit(_binding_0) => {
                        v.visit_expr_lit_mut(_binding_0);
                    }
                    ::syntax::Expr::Loop(_binding_0) => {
                        full!(v.visit_expr_loop_mut(_binding_0));
                    }
                    ::syntax::Expr::Macro(_binding_0) => {
                        v.visit_expr_macro_mut(_binding_0);
                    }
                    ::syntax::Expr::Match(_binding_0) => {
                        full!(v.visit_expr_match_mut(_binding_0));
                    }
                    ::syntax::Expr::MethodCall(_binding_0) => {
                        v.visit_expr_method_call_mut(_binding_0);
                    }
                    ::syntax::Expr::Paren(_binding_0) => {
                        v.visit_expr_paren_mut(_binding_0);
                    }
                    ::syntax::Expr::Path(_binding_0) => {
                        v.visit_expr_path_mut(_binding_0);
                    }
                    ::syntax::Expr::Range(_binding_0) => {
                        full!(v.visit_expr_range_mut(_binding_0));
                    }
                    ::syntax::Expr::RawAddr(_binding_0) => {
                        full!(v.visit_expr_raw_addr_mut(_binding_0));
                    }
                    ::syntax::Expr::Reference(_binding_0) => {
                        v.visit_expr_reference_mut(_binding_0);
                    }
                    ::syntax::Expr::Repeat(_binding_0) => {
                        full!(v.visit_expr_repeat_mut(_binding_0));
                    }
                    ::syntax::Expr::Return(_binding_0) => {
                        full!(v.visit_expr_return_mut(_binding_0));
                    }
                    ::syntax::Expr::Struct(_binding_0) => {
                        v.visit_expr_struct_mut(_binding_0);
                    }
                    ::syntax::Expr::Try(_binding_0) => {
                        full!(v.visit_expr_try_mut(_binding_0));
                    }
                    ::syntax::Expr::TryBlock(_binding_0) => {
                        full!(v.visit_expr_try_block_mut(_binding_0));
                    }
                    ::syntax::Expr::Tuple(_binding_0) => {
                        v.visit_expr_tuple_mut(_binding_0);
                    }
                    ::syntax::Expr::Unary(_binding_0) => {
                        v.visit_expr_unary_mut(_binding_0);
                    }
                    ::syntax::Expr::Unsafe(_binding_0) => {
                        full!(v.visit_expr_unsafe_mut(_binding_0));
                    }
                    ::syntax::Expr::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                    ::syntax::Expr::While(_binding_0) => {
                        full!(v.visit_expr_while_mut(_binding_0));
                    }
                    ::syntax::Expr::Yield(_binding_0) => {
                        full!(v.visit_expr_yield_mut(_binding_0));
                    }
                }
            }
                pub fn visit_expr_array_mut<V>(v: &mut V, node: &mut ::syntax::ExprArray) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.bracket_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_expr_mut(it);
                }
            }
                pub fn visit_expr_assign_mut<V>(v: &mut V, node: &mut ::syntax::ExprAssign) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.left);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.right);
            }
                pub fn visit_expr_async_mut<V>(v: &mut V, node: &mut ::syntax::ExprAsync) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.async_token);
                skip!(node.capture);
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_expr_await_mut<V>(v: &mut V, node: &mut ::syntax::ExprAwait) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.base);
                skip!(node.dot_token);
                skip!(node.await_token);
            }
            pub fn visit_expr_binary_mut<V>(v: &mut V, node: &mut ::syntax::ExprBinary) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.left);
                v.visit_bin_op_mut(&mut node.op);
                v.visit_expr_mut(&mut *node.right);
            }
                pub fn visit_expr_block_mut<V>(v: &mut V, node: &mut ::syntax::ExprBlock) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.label {
                    v.visit_label_mut(it);
                }
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_expr_break_mut<V>(v: &mut V, node: &mut ::syntax::ExprBreak) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.break_token);
                if let Some(it) = &mut node.label {
                    v.visit_lifetime_mut(it);
                }
                if let Some(it) = &mut node.expr {
                    v.visit_expr_mut(&mut **it);
                }
            }
            pub fn visit_expr_call_mut<V>(v: &mut V, node: &mut ::syntax::ExprCall) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.func);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.args) {
                    let it = el.value_mut();
                    v.visit_expr_mut(it);
                }
            }
            pub fn visit_expr_cast_mut<V>(v: &mut V, node: &mut ::syntax::ExprCast) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.as_token);
                v.visit_type_mut(&mut *node.ty);
            }
                pub fn visit_expr_closure_mut<V>(v: &mut V, node: &mut ::syntax::ExprClosure) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.lifetimes {
                    v.visit_bound_lifetimes_mut(it);
                }
                skip!(node.constness);
                skip!(node.movability);
                skip!(node.asyncness);
                skip!(node.capture);
                skip!(node.or1_token);
                for mut el in Punctuated::pairs_mut(&mut node.inputs) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
                skip!(node.or2_token);
                v.visit_return_type_mut(&mut node.output);
                v.visit_expr_mut(&mut *node.body);
            }
                pub fn visit_expr_const_mut<V>(v: &mut V, node: &mut ::syntax::ExprConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.const_token);
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_expr_continue_mut<V>(v: &mut V, node: &mut ::syntax::ExprContinue) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.continue_token);
                if let Some(it) = &mut node.label {
                    v.visit_lifetime_mut(it);
                }
            }
            pub fn visit_expr_field_mut<V>(v: &mut V, node: &mut ::syntax::ExprField) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.base);
                skip!(node.dot_token);
                v.visit_member_mut(&mut node.member);
            }
                pub fn visit_expr_for_loop_mut<V>(v: &mut V, node: &mut ::syntax::ExprForLoop) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.label {
                    v.visit_label_mut(it);
                }
                skip!(node.for_token);
                v.visit_pat_mut(&mut *node.pat);
                skip!(node.in_token);
                v.visit_expr_mut(&mut *node.expr);
                v.visit_block_mut(&mut node.body);
            }
            pub fn visit_expr_group_mut<V>(v: &mut V, node: &mut ::syntax::ExprGroup) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.group_token);
                v.visit_expr_mut(&mut *node.expr);
            }
                pub fn visit_expr_if_mut<V>(v: &mut V, node: &mut ::syntax::ExprIf) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.if_token);
                v.visit_expr_mut(&mut *node.cond);
                v.visit_block_mut(&mut node.then_branch);
                if let Some(it) = &mut node.else_branch {
                    skip!((it).0);
                    v.visit_expr_mut(&mut *(it).1);
                }
            }
            pub fn visit_expr_index_mut<V>(v: &mut V, node: &mut ::syntax::ExprIndex) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.bracket_token);
                v.visit_expr_mut(&mut *node.index);
            }
                pub fn visit_expr_infer_mut<V>(v: &mut V, node: &mut ::syntax::ExprInfer) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.underscore_token);
            }
                pub fn visit_expr_let_mut<V>(v: &mut V, node: &mut ::syntax::ExprLet) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.let_token);
                v.visit_pat_mut(&mut *node.pat);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.expr);
            }
            pub fn visit_expr_lit_mut<V>(v: &mut V, node: &mut ::syntax::ExprLit) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_lit_mut(&mut node.lit);
            }
                pub fn visit_expr_loop_mut<V>(v: &mut V, node: &mut ::syntax::ExprLoop) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.label {
                    v.visit_label_mut(it);
                }
                skip!(node.loop_token);
                v.visit_block_mut(&mut node.body);
            }
            pub fn visit_expr_macro_mut<V>(v: &mut V, node: &mut ::syntax::ExprMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
            }
                pub fn visit_expr_match_mut<V>(v: &mut V, node: &mut ::syntax::ExprMatch) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.match_token);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.brace_token);
                for it in &mut node.arms {
                    v.visit_arm_mut(it);
                }
            }
            pub fn visit_expr_method_call_mut<V>(v: &mut V, node: &mut ::syntax::ExprMethodCall) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.receiver);
                skip!(node.dot_token);
                v.visit_ident_mut(&mut node.method);
                if let Some(it) = &mut node.turbofish {
                    v.visit_angle_bracketed_generic_arguments_mut(it);
                }
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.args) {
                    let it = el.value_mut();
                    v.visit_expr_mut(it);
                }
            }
            pub fn visit_expr_paren_mut<V>(v: &mut V, node: &mut ::syntax::ExprParen) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.paren_token);
                v.visit_expr_mut(&mut *node.expr);
            }
            pub fn visit_expr_path_mut<V>(v: &mut V, node: &mut ::syntax::ExprPath) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
            }
                pub fn visit_expr_range_mut<V>(v: &mut V, node: &mut ::syntax::ExprRange) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.start {
                    v.visit_expr_mut(&mut **it);
                }
                v.visit_range_limits_mut(&mut node.limits);
                if let Some(it) = &mut node.end {
                    v.visit_expr_mut(&mut **it);
                }
            }
                pub fn visit_expr_raw_addr_mut<V>(v: &mut V, node: &mut ::syntax::ExprRawAddr) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.and_token);
                skip!(node.raw);
                v.visit_pointer_mutability_mut(&mut node.mutability);
                v.visit_expr_mut(&mut *node.expr);
            }
            pub fn visit_expr_reference_mut<V>(v: &mut V, node: &mut ::syntax::ExprReference) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.and_token);
                skip!(node.mutability);
                v.visit_expr_mut(&mut *node.expr);
            }
                pub fn visit_expr_repeat_mut<V>(v: &mut V, node: &mut ::syntax::ExprRepeat) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.bracket_token);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.semi_token);
                v.visit_expr_mut(&mut *node.len);
            }
                pub fn visit_expr_return_mut<V>(v: &mut V, node: &mut ::syntax::ExprReturn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.return_token);
                if let Some(it) = &mut node.expr {
                    v.visit_expr_mut(&mut **it);
                }
            }
            pub fn visit_expr_struct_mut<V>(v: &mut V, node: &mut ::syntax::ExprStruct) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.fields) {
                    let it = el.value_mut();
                    v.visit_field_value_mut(it);
                }
                skip!(node.dot2_token);
                if let Some(it) = &mut node.rest {
                    v.visit_expr_mut(&mut **it);
                }
            }
                pub fn visit_expr_try_mut<V>(v: &mut V, node: &mut ::syntax::ExprTry) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.question_token);
            }
                pub fn visit_expr_try_block_mut<V>(v: &mut V, node: &mut ::syntax::ExprTryBlock) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.try_token);
                v.visit_block_mut(&mut node.block);
            }
            pub fn visit_expr_tuple_mut<V>(v: &mut V, node: &mut ::syntax::ExprTuple) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_expr_mut(it);
                }
            }
            pub fn visit_expr_unary_mut<V>(v: &mut V, node: &mut ::syntax::ExprUnary) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_un_op_mut(&mut node.op);
                v.visit_expr_mut(&mut *node.expr);
            }
                pub fn visit_expr_unsafe_mut<V>(v: &mut V, node: &mut ::syntax::ExprUnsafe) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.unsafe_token);
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_expr_while_mut<V>(v: &mut V, node: &mut ::syntax::ExprWhile) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.label {
                    v.visit_label_mut(it);
                }
                skip!(node.while_token);
                v.visit_expr_mut(&mut *node.cond);
                v.visit_block_mut(&mut node.body);
            }
                pub fn visit_expr_yield_mut<V>(v: &mut V, node: &mut ::syntax::ExprYield) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.yield_token);
                if let Some(it) = &mut node.expr {
                    v.visit_expr_mut(&mut **it);
                }
            }
            pub fn visit_field_mut<V>(v: &mut V, node: &mut ::syntax::Field) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                v.visit_field_mutability_mut(&mut node.mutability);
                if let Some(it) = &mut node.ident {
                    v.visit_ident_mut(it);
                }
                skip!(node.colon_token);
                v.visit_type_mut(&mut node.ty);
            }
            pub fn visit_field_mutability_mut<V>(v: &mut V, node: &mut ::syntax::FieldMutability) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::FieldMutability::None => {}
                }
            }
                pub fn visit_field_pat_mut<V>(v: &mut V, node: &mut ::syntax::FieldPat) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_member_mut(&mut node.member);
                skip!(node.colon_token);
                v.visit_pat_mut(&mut *node.pat);
            }
            pub fn visit_field_value_mut<V>(v: &mut V, node: &mut ::syntax::FieldValue) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_member_mut(&mut node.member);
                skip!(node.colon_token);
                v.visit_expr_mut(&mut node.expr);
            }
            pub fn visit_fields_mut<V>(v: &mut V, node: &mut ::syntax::Fields) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Fields::Named(_binding_0) => {
                        v.visit_fields_named_mut(_binding_0);
                    }
                    ::syntax::Fields::Unnamed(_binding_0) => {
                        v.visit_fields_unnamed_mut(_binding_0);
                    }
                    ::syntax::Fields::Unit => {}
                }
            }
            pub fn visit_fields_named_mut<V>(v: &mut V, node: &mut ::syntax::FieldsNamed) where
                V: VisitMut + ?Sized,
            {
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.named) {
                    let it = el.value_mut();
                    v.visit_field_mut(it);
                }
            }
            pub fn visit_fields_unnamed_mut<V>(v: &mut V, node: &mut ::syntax::FieldsUnnamed) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.unnamed) {
                    let it = el.value_mut();
                    v.visit_field_mut(it);
                }
            }
                pub fn visit_file_mut<V>(v: &mut V, node: &mut ::syntax::File) where
                V: VisitMut + ?Sized,
            {
                skip!(node.shebang);
                v.visit_attributes_mut(&mut node.attrs);
                for it in &mut node.items {
                    v.visit_item_mut(it);
                }
            }
                pub fn visit_fn_arg_mut<V>(v: &mut V, node: &mut ::syntax::FnArg) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::FnArg::Receiver(_binding_0) => {
                        v.visit_receiver_mut(_binding_0);
                    }
                    ::syntax::FnArg::Typed(_binding_0) => {
                        v.visit_pat_type_mut(_binding_0);
                    }
                }
            }
                pub fn visit_foreign_item_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItem) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::ForeignItem::Fn(_binding_0) => {
                        v.visit_foreign_item_fn_mut(_binding_0);
                    }
                    ::syntax::ForeignItem::Static(_binding_0) => {
                        v.visit_foreign_item_static_mut(_binding_0);
                    }
                    ::syntax::ForeignItem::Type(_binding_0) => {
                        v.visit_foreign_item_type_mut(_binding_0);
                    }
                    ::syntax::ForeignItem::Macro(_binding_0) => {
                        v.visit_foreign_item_macro_mut(_binding_0);
                    }
                    ::syntax::ForeignItem::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
                pub fn visit_foreign_item_fn_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItemFn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                v.visit_signature_mut(&mut node.sig);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_macro_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItemMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_static_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItemStatic) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.static_token);
                v.visit_static_mutability_mut(&mut node.mutability);
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_foreign_item_type_mut<V>(v: &mut V, node: &mut ::syntax::ForeignItemType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.type_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.semi_token);
            }
            pub fn visit_generic_argument_mut<V>(v: &mut V, node: &mut ::syntax::GenericArgument) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::GenericArgument::Lifetime(_binding_0) => {
                        v.visit_lifetime_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::Type(_binding_0) => {
                        v.visit_type_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::Const(_binding_0) => {
                        v.visit_expr_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::AssocType(_binding_0) => {
                        v.visit_assoc_type_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::AssocConst(_binding_0) => {
                        v.visit_assoc_const_mut(_binding_0);
                    }
                    ::syntax::GenericArgument::Constraint(_binding_0) => {
                        v.visit_constraint_mut(_binding_0);
                    }
                }
            }
            pub fn visit_generic_param_mut<V>(v: &mut V, node: &mut ::syntax::GenericParam) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::GenericParam::Lifetime(_binding_0) => {
                        v.visit_lifetime_param_mut(_binding_0);
                    }
                    ::syntax::GenericParam::Type(_binding_0) => {
                        v.visit_type_param_mut(_binding_0);
                    }
                    ::syntax::GenericParam::Const(_binding_0) => {
                        v.visit_const_param_mut(_binding_0);
                    }
                }
            }
            pub fn visit_generics_mut<V>(v: &mut V, node: &mut ::syntax::Generics) where
                V: VisitMut + ?Sized,
            {
                skip!(node.lt_token);
                for mut el in Punctuated::pairs_mut(&mut node.params) {
                    let it = el.value_mut();
                    v.visit_generic_param_mut(it);
                }
                skip!(node.gt_token);
                if let Some(it) = &mut node.where_clause {
                    v.visit_where_clause_mut(it);
                }
            }
            pub fn visit_ident_mut<V>(v: &mut V, node: &mut process::macros::Ident) where
                V: VisitMut + ?Sized,
            {
                let mut span = node.span();
                v.visit_span_mut(&mut span);
                node.set_span(span);
            }
                pub fn visit_impl_item_mut<V>(v: &mut V, node: &mut ::syntax::ImplItem) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::ImplItem::Const(_binding_0) => {
                        v.visit_impl_item_const_mut(_binding_0);
                    }
                    ::syntax::ImplItem::Fn(_binding_0) => {
                        v.visit_impl_item_fn_mut(_binding_0);
                    }
                    ::syntax::ImplItem::Type(_binding_0) => {
                        v.visit_impl_item_type_mut(_binding_0);
                    }
                    ::syntax::ImplItem::Macro(_binding_0) => {
                        v.visit_impl_item_macro_mut(_binding_0);
                    }
                    ::syntax::ImplItem::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
                pub fn visit_impl_item_const_mut<V>(v: &mut V, node: &mut ::syntax::ImplItemConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.defaultness);
                skip!(node.const_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                v.visit_type_mut(&mut node.ty);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_impl_item_fn_mut<V>(v: &mut V, node: &mut ::syntax::ImplItemFn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.defaultness);
                v.visit_signature_mut(&mut node.sig);
                v.visit_block_mut(&mut node.block);
            }
                pub fn visit_impl_item_macro_mut<V>(v: &mut V, node: &mut ::syntax::ImplItemMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_impl_item_type_mut<V>(v: &mut V, node: &mut ::syntax::ImplItemType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.defaultness);
                skip!(node.type_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.eq_token);
                v.visit_type_mut(&mut node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_impl_restriction_mut<V>(v: &mut V, node: &mut ::syntax::ImplRestriction) where
                V: VisitMut + ?Sized,
            {
                match *node {}
            }
            pub fn visit_index_mut<V>(v: &mut V, node: &mut ::syntax::Index) where
                V: VisitMut + ?Sized,
            {
                skip!(node.index);
                v.visit_span_mut(&mut node.span);
            }
                pub fn visit_item_mut<V>(v: &mut V, node: &mut ::syntax::Item) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Item::Const(_binding_0) => {
                        v.visit_item_const_mut(_binding_0);
                    }
                    ::syntax::Item::Enum(_binding_0) => {
                        v.visit_item_enum_mut(_binding_0);
                    }
                    ::syntax::Item::ExternCrate(_binding_0) => {
                        v.visit_item_extern_crate_mut(_binding_0);
                    }
                    ::syntax::Item::Fn(_binding_0) => {
                        v.visit_item_fn_mut(_binding_0);
                    }
                    ::syntax::Item::ForeignMod(_binding_0) => {
                        v.visit_item_foreign_mod_mut(_binding_0);
                    }
                    ::syntax::Item::Impl(_binding_0) => {
                        v.visit_item_impl_mut(_binding_0);
                    }
                    ::syntax::Item::Macro(_binding_0) => {
                        v.visit_item_macro_mut(_binding_0);
                    }
                    ::syntax::Item::Mod(_binding_0) => {
                        v.visit_item_mod_mut(_binding_0);
                    }
                    ::syntax::Item::Static(_binding_0) => {
                        v.visit_item_static_mut(_binding_0);
                    }
                    ::syntax::Item::Struct(_binding_0) => {
                        v.visit_item_struct_mut(_binding_0);
                    }
                    ::syntax::Item::Trait(_binding_0) => {
                        v.visit_item_trait_mut(_binding_0);
                    }
                    ::syntax::Item::TraitAlias(_binding_0) => {
                        v.visit_item_trait_alias_mut(_binding_0);
                    }
                    ::syntax::Item::Type(_binding_0) => {
                        v.visit_item_type_mut(_binding_0);
                    }
                    ::syntax::Item::Union(_binding_0) => {
                        v.visit_item_union_mut(_binding_0);
                    }
                    ::syntax::Item::Use(_binding_0) => {
                        v.visit_item_use_mut(_binding_0);
                    }
                    ::syntax::Item::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
                pub fn visit_item_const_mut<V>(v: &mut V, node: &mut ::syntax::ItemConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.const_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_item_enum_mut<V>(v: &mut V, node: &mut ::syntax::ItemEnum) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.enum_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.variants) {
                    let it = el.value_mut();
                    v.visit_variant_mut(it);
                }
            }
                pub fn visit_item_extern_crate_mut<V>(v: &mut V, node: &mut ::syntax::ItemExternCrate) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.extern_token);
                skip!(node.crate_token);
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.rename {
                    skip!((it).0);
                    v.visit_ident_mut(&mut (it).1);
                }
                skip!(node.semi_token);
            }
                pub fn visit_item_fn_mut<V>(v: &mut V, node: &mut ::syntax::ItemFn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                v.visit_signature_mut(&mut node.sig);
                v.visit_block_mut(&mut *node.block);
            }
                pub fn visit_item_foreign_mod_mut<V>(v: &mut V, node: &mut ::syntax::ItemForeignMod) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.unsafety);
                v.visit_abi_mut(&mut node.abi);
                skip!(node.brace_token);
                for it in &mut node.items {
                    v.visit_foreign_item_mut(it);
                }
            }
                pub fn visit_item_impl_mut<V>(v: &mut V, node: &mut ::syntax::ItemImpl) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.defaultness);
                skip!(node.unsafety);
                skip!(node.impl_token);
                v.visit_generics_mut(&mut node.generics);
                if let Some(it) = &mut node.trait_ {
                    skip!((it).0);
                    v.visit_path_mut(&mut (it).1);
                    skip!((it).2);
                }
                v.visit_type_mut(&mut *node.self_ty);
                skip!(node.brace_token);
                for it in &mut node.items {
                    v.visit_impl_item_mut(it);
                }
            }
                pub fn visit_item_macro_mut<V>(v: &mut V, node: &mut ::syntax::ItemMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.ident {
                    v.visit_ident_mut(it);
                }
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_item_mod_mut<V>(v: &mut V, node: &mut ::syntax::ItemMod) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.unsafety);
                skip!(node.mod_token);
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.content {
                    skip!((it).0);
                    for it in &mut (it).1 {
                        v.visit_item_mut(it);
                    }
                }
                skip!(node.semi);
            }
                pub fn visit_item_static_mut<V>(v: &mut V, node: &mut ::syntax::ItemStatic) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.static_token);
                v.visit_static_mutability_mut(&mut node.mutability);
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.expr);
                skip!(node.semi_token);
            }
                pub fn visit_item_struct_mut<V>(v: &mut V, node: &mut ::syntax::ItemStruct) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.struct_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                v.visit_fields_mut(&mut node.fields);
                skip!(node.semi_token);
            }
                pub fn visit_item_trait_mut<V>(v: &mut V, node: &mut ::syntax::ItemTrait) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.unsafety);
                skip!(node.auto_token);
                if let Some(it) = &mut node.restriction {
                    v.visit_impl_restriction_mut(it);
                }
                skip!(node.trait_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.supertraits) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
                skip!(node.brace_token);
                for it in &mut node.items {
                    v.visit_trait_item_mut(it);
                }
            }
                pub fn visit_item_trait_alias_mut<V>(v: &mut V, node: &mut ::syntax::ItemTraitAlias) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.trait_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.eq_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_item_type_mut<V>(v: &mut V, node: &mut ::syntax::ItemType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.type_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.eq_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.semi_token);
            }
                pub fn visit_item_union_mut<V>(v: &mut V, node: &mut ::syntax::ItemUnion) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.union_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                v.visit_fields_named_mut(&mut node.fields);
            }
                pub fn visit_item_use_mut<V>(v: &mut V, node: &mut ::syntax::ItemUse) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_visibility_mut(&mut node.vis);
                skip!(node.use_token);
                skip!(node.leading_colon);
                v.visit_use_tree_mut(&mut node.tree);
                skip!(node.semi_token);
            }
                pub fn visit_label_mut<V>(v: &mut V, node: &mut ::syntax::Label) where
                V: VisitMut + ?Sized,
            {
                v.visit_lifetime_mut(&mut node.name);
                skip!(node.colon_token);
            }
            pub fn visit_lifetime_mut<V>(v: &mut V, node: &mut ::syntax::Lifetime) where
                V: VisitMut + ?Sized,
            {
                v.visit_span_mut(&mut node.apostrophe);
                v.visit_ident_mut(&mut node.ident);
            }
            pub fn visit_lifetime_param_mut<V>(v: &mut V, node: &mut ::syntax::LifetimeParam) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_lifetime_mut(&mut node.lifetime);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_lifetime_mut(it);
                }
            }
            pub fn visit_lit_mut<V>(v: &mut V, node: &mut ::syntax::Lit) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Lit::Str(_binding_0) => {
                        v.visit_lit_str_mut(_binding_0);
                    }
                    ::syntax::Lit::ByteStr(_binding_0) => {
                        v.visit_lit_byte_str_mut(_binding_0);
                    }
                    ::syntax::Lit::CStr(_binding_0) => {
                        v.visit_lit_cstr_mut(_binding_0);
                    }
                    ::syntax::Lit::Byte(_binding_0) => {
                        v.visit_lit_byte_mut(_binding_0);
                    }
                    ::syntax::Lit::Char(_binding_0) => {
                        v.visit_lit_char_mut(_binding_0);
                    }
                    ::syntax::Lit::Int(_binding_0) => {
                        v.visit_lit_int_mut(_binding_0);
                    }
                    ::syntax::Lit::Float(_binding_0) => {
                        v.visit_lit_float_mut(_binding_0);
                    }
                    ::syntax::Lit::Bool(_binding_0) => {
                        v.visit_lit_bool_mut(_binding_0);
                    }
                    ::syntax::Lit::Verbatim(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_lit_bool_mut<V>(v: &mut V, node: &mut ::syntax::LitBool) where
                V: VisitMut + ?Sized,
            {
                skip!(node.value);
                v.visit_span_mut(&mut node.span);
            }
            pub fn visit_lit_byte_mut<V>(v: &mut V, node: &mut ::syntax::LitByte) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_byte_str_mut<V>(v: &mut V, node: &mut ::syntax::LitByteStr) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_cstr_mut<V>(v: &mut V, node: &mut ::syntax::LitCStr) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_char_mut<V>(v: &mut V, node: &mut ::syntax::LitChar) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_float_mut<V>(v: &mut V, node: &mut ::syntax::LitFloat) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_int_mut<V>(v: &mut V, node: &mut ::syntax::LitInt) where
                V: VisitMut + ?Sized,
            {}
            pub fn visit_lit_str_mut<V>(v: &mut V, node: &mut ::syntax::LitStr) where
                V: VisitMut + ?Sized,
            {}
                pub fn visit_local_mut<V>(v: &mut V, node: &mut ::syntax::Local) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.let_token);
                v.visit_pat_mut(&mut node.pat);
                if let Some(it) = &mut node.init {
                    v.visit_local_init_mut(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_local_init_mut<V>(v: &mut V, node: &mut ::syntax::LocalInit) where
                V: VisitMut + ?Sized,
            {
                skip!(node.eq_token);
                v.visit_expr_mut(&mut *node.expr);
                if let Some(it) = &mut node.diverge {
                    skip!((it).0);
                    v.visit_expr_mut(&mut *(it).1);
                }
            }
            pub fn visit_macro_mut<V>(v: &mut V, node: &mut ::syntax::Macro) where
                V: VisitMut + ?Sized,
            {
                v.visit_path_mut(&mut node.path);
                skip!(node.bang_token);
                v.visit_macro_delimiter_mut(&mut node.delimiter);
                v.visit_token_stream_mut(&mut node.tokens);
            }
            pub fn visit_macro_delimiter_mut<V>(v: &mut V, node: &mut ::syntax::MacroDelimiter) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::MacroDelimiter::Paren(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::MacroDelimiter::Brace(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::MacroDelimiter::Bracket(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
            pub fn visit_member_mut<V>(v: &mut V, node: &mut ::syntax::Member) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Member::Named(_binding_0) => {
                        v.visit_ident_mut(_binding_0);
                    }
                    ::syntax::Member::Unnamed(_binding_0) => {
                        v.visit_index_mut(_binding_0);
                    }
                }
            }
            pub fn visit_meta_mut<V>(v: &mut V, node: &mut ::syntax::Meta) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Meta::Path(_binding_0) => {
                        v.visit_path_mut(_binding_0);
                    }
                    ::syntax::Meta::List(_binding_0) => {
                        v.visit_meta_list_mut(_binding_0);
                    }
                    ::syntax::Meta::NameValue(_binding_0) => {
                        v.visit_meta_name_value_mut(_binding_0);
                    }
                }
            }
            pub fn visit_meta_list_mut<V>(v: &mut V, node: &mut ::syntax::MetaList) where
                V: VisitMut + ?Sized,
            {
                v.visit_path_mut(&mut node.path);
                v.visit_macro_delimiter_mut(&mut node.delimiter);
                v.visit_token_stream_mut(&mut node.tokens);
            }
            pub fn visit_meta_name_value_mut<V>(v: &mut V, node: &mut ::syntax::MetaNameValue) where
                V: VisitMut + ?Sized,
            {
                v.visit_path_mut(&mut node.path);
                skip!(node.eq_token);
                v.visit_expr_mut(&mut node.value);
            }
            pub fn visit_parenthesized_generic_arguments_mut<V>(
                v: &mut V,
                node: &mut ::syntax::ParenthesizedGenericArguments,
            ) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.inputs) {
                    let it = el.value_mut();
                    v.visit_type_mut(it);
                }
                v.visit_return_type_mut(&mut node.output);
            }
                pub fn visit_pat_mut<V>(v: &mut V, node: &mut ::syntax::Pat) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Pat::Const(_binding_0) => {
                        v.visit_expr_const_mut(_binding_0);
                    }
                    ::syntax::Pat::Ident(_binding_0) => {
                        v.visit_pat_ident_mut(_binding_0);
                    }
                    ::syntax::Pat::Lit(_binding_0) => {
                        v.visit_expr_lit_mut(_binding_0);
                    }
                    ::syntax::Pat::Macro(_binding_0) => {
                        v.visit_expr_macro_mut(_binding_0);
                    }
                    ::syntax::Pat::Or(_binding_0) => {
                        v.visit_pat_or_mut(_binding_0);
                    }
                    ::syntax::Pat::Paren(_binding_0) => {
                        v.visit_pat_paren_mut(_binding_0);
                    }
                    ::syntax::Pat::Path(_binding_0) => {
                        v.visit_expr_path_mut(_binding_0);
                    }
                    ::syntax::Pat::Range(_binding_0) => {
                        v.visit_expr_range_mut(_binding_0);
                    }
                    ::syntax::Pat::Reference(_binding_0) => {
                        v.visit_pat_reference_mut(_binding_0);
                    }
                    ::syntax::Pat::Rest(_binding_0) => {
                        v.visit_pat_rest_mut(_binding_0);
                    }
                    ::syntax::Pat::Slice(_binding_0) => {
                        v.visit_pat_slice_mut(_binding_0);
                    }
                    ::syntax::Pat::Struct(_binding_0) => {
                        v.visit_pat_struct_mut(_binding_0);
                    }
                    ::syntax::Pat::Tuple(_binding_0) => {
                        v.visit_pat_tuple_mut(_binding_0);
                    }
                    ::syntax::Pat::TupleStruct(_binding_0) => {
                        v.visit_pat_tuple_struct_mut(_binding_0);
                    }
                    ::syntax::Pat::Type(_binding_0) => {
                        v.visit_pat_type_mut(_binding_0);
                    }
                    ::syntax::Pat::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                    ::syntax::Pat::Wild(_binding_0) => {
                        v.visit_pat_wild_mut(_binding_0);
                    }
                }
            }
                pub fn visit_pat_ident_mut<V>(v: &mut V, node: &mut ::syntax::PatIdent) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.by_ref);
                skip!(node.mutability);
                v.visit_ident_mut(&mut node.ident);
                if let Some(it) = &mut node.subpat {
                    skip!((it).0);
                    v.visit_pat_mut(&mut *(it).1);
                }
            }
                pub fn visit_pat_or_mut<V>(v: &mut V, node: &mut ::syntax::PatOr) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.leading_vert);
                for mut el in Punctuated::pairs_mut(&mut node.cases) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
            }
                pub fn visit_pat_paren_mut<V>(v: &mut V, node: &mut ::syntax::PatParen) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.paren_token);
                v.visit_pat_mut(&mut *node.pat);
            }
                pub fn visit_pat_reference_mut<V>(v: &mut V, node: &mut ::syntax::PatReference) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.and_token);
                skip!(node.mutability);
                v.visit_pat_mut(&mut *node.pat);
            }
                pub fn visit_pat_rest_mut<V>(v: &mut V, node: &mut ::syntax::PatRest) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.dot2_token);
            }
                pub fn visit_pat_slice_mut<V>(v: &mut V, node: &mut ::syntax::PatSlice) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.bracket_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
            }
                pub fn visit_pat_struct_mut<V>(v: &mut V, node: &mut ::syntax::PatStruct) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.fields) {
                    let it = el.value_mut();
                    v.visit_field_pat_mut(it);
                }
                if let Some(it) = &mut node.rest {
                    v.visit_pat_rest_mut(it);
                }
            }
                pub fn visit_pat_tuple_mut<V>(v: &mut V, node: &mut ::syntax::PatTuple) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
            }
                pub fn visit_pat_tuple_struct_mut<V>(v: &mut V, node: &mut ::syntax::PatTupleStruct) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_pat_mut(it);
                }
            }
                pub fn visit_pat_type_mut<V>(v: &mut V, node: &mut ::syntax::PatType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_pat_mut(&mut *node.pat);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
            }
                pub fn visit_pat_wild_mut<V>(v: &mut V, node: &mut ::syntax::PatWild) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.underscore_token);
            }
            pub fn visit_path_mut<V>(v: &mut V, node: &mut ::syntax::Path) where
                V: VisitMut + ?Sized,
            {
                skip!(node.leading_colon);
                for mut el in Punctuated::pairs_mut(&mut node.segments) {
                    let it = el.value_mut();
                    v.visit_path_segment_mut(it);
                }
            }
            pub fn visit_path_arguments_mut<V>(v: &mut V, node: &mut ::syntax::PathArguments) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::PathArguments::None => {}
                    ::syntax::PathArguments::AngleBracketed(_binding_0) => {
                        v.visit_angle_bracketed_generic_arguments_mut(_binding_0);
                    }
                    ::syntax::PathArguments::Parenthesized(_binding_0) => {
                        v.visit_parenthesized_generic_arguments_mut(_binding_0);
                    }
                }
            }
            pub fn visit_path_segment_mut<V>(v: &mut V, node: &mut ::syntax::PathSegment) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                v.visit_path_arguments_mut(&mut node.arguments);
            }
                pub fn visit_pointer_mutability_mut<V>(v: &mut V, node: &mut ::syntax::PointerMutability) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::PointerMutability::Const(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::PointerMutability::Mut(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_precise_capture_mut<V>(v: &mut V, node: &mut ::syntax::PreciseCapture) where
                V: VisitMut + ?Sized,
            {
                skip!(node.use_token);
                skip!(node.lt_token);
                for mut el in Punctuated::pairs_mut(&mut node.params) {
                    let it = el.value_mut();
                    v.visit_captured_param_mut(it);
                }
                skip!(node.gt_token);
            }
            pub fn visit_predicate_lifetime_mut<V>(v: &mut V, node: &mut ::syntax::PredicateLifetime) where
                V: VisitMut + ?Sized,
            {
                v.visit_lifetime_mut(&mut node.lifetime);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_lifetime_mut(it);
                }
            }
            pub fn visit_predicate_type_mut<V>(v: &mut V, node: &mut ::syntax::PredicateType) where
                V: VisitMut + ?Sized,
            {
                if let Some(it) = &mut node.lifetimes {
                    v.visit_bound_lifetimes_mut(it);
                }
                v.visit_type_mut(&mut node.bounded_ty);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
            }
            pub fn visit_qself_mut<V>(v: &mut V, node: &mut ::syntax::QSelf) where
                V: VisitMut + ?Sized,
            {
                skip!(node.lt_token);
                v.visit_type_mut(&mut *node.ty);
                skip!(node.position);
                skip!(node.as_token);
                skip!(node.gt_token);
            }
                pub fn visit_range_limits_mut<V>(v: &mut V, node: &mut ::syntax::RangeLimits) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::RangeLimits::HalfOpen(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::RangeLimits::Closed(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_receiver_mut<V>(v: &mut V, node: &mut ::syntax::Receiver) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.reference {
                    skip!((it).0);
                    if let Some(it) = &mut (it).1 {
                        v.visit_lifetime_mut(it);
                    }
                }
                skip!(node.mutability);
                skip!(node.self_token);
                skip!(node.colon_token);
                v.visit_type_mut(&mut *node.ty);
            }
            pub fn visit_return_type_mut<V>(v: &mut V, node: &mut ::syntax::ReturnType) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::ReturnType::Default => {}
                    ::syntax::ReturnType::Type(_binding_0, _binding_1) => {
                        skip!(_binding_0);
                        v.visit_type_mut(&mut **_binding_1);
                    }
                }
            }
                pub fn visit_signature_mut<V>(v: &mut V, node: &mut ::syntax::Signature) where
                V: VisitMut + ?Sized,
            {
                skip!(node.constness);
                skip!(node.asyncness);
                skip!(node.unsafety);
                if let Some(it) = &mut node.abi {
                    v.visit_abi_mut(it);
                }
                skip!(node.fn_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.inputs) {
                    let it = el.value_mut();
                    v.visit_fn_arg_mut(it);
                }
                if let Some(it) = &mut node.variadic {
                    v.visit_variadic_mut(it);
                }
                v.visit_return_type_mut(&mut node.output);
            }
            pub fn visit_span_mut<V>(v: &mut V, node: &mut process::macros::Span) where
                V: VisitMut + ?Sized,
            {}
                pub fn visit_static_mutability_mut<V>(v: &mut V, node: &mut ::syntax::StaticMutability) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::StaticMutability::Mut(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::StaticMutability::None => {}
                }
            }
                pub fn visit_stmt_mut<V>(v: &mut V, node: &mut ::syntax::Stmt) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Stmt::Local(_binding_0) => {
                        v.visit_local_mut(_binding_0);
                    }
                    ::syntax::Stmt::Item(_binding_0) => {
                        v.visit_item_mut(_binding_0);
                    }
                    ::syntax::Stmt::Expr(_binding_0, _binding_1) => {
                        v.visit_expr_mut(_binding_0);
                        skip!(_binding_1);
                    }
                    ::syntax::Stmt::Macro(_binding_0) => {
                        v.visit_stmt_macro_mut(_binding_0);
                    }
                }
            }
                pub fn visit_stmt_macro_mut<V>(v: &mut V, node: &mut ::syntax::StmtMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
            pub fn visit_trait_bound_mut<V>(v: &mut V, node: &mut ::syntax::TraitBound) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                v.visit_trait_bound_modifier_mut(&mut node.modifier);
                if let Some(it) = &mut node.lifetimes {
                    v.visit_bound_lifetimes_mut(it);
                }
                v.visit_path_mut(&mut node.path);
            }
            pub fn visit_trait_bound_modifier_mut<V>(v: &mut V, node: &mut ::syntax::TraitBoundModifier) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::TraitBoundModifier::None => {}
                    ::syntax::TraitBoundModifier::Maybe(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_trait_item_mut<V>(v: &mut V, node: &mut ::syntax::TraitItem) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::TraitItem::Const(_binding_0) => {
                        v.visit_trait_item_const_mut(_binding_0);
                    }
                    ::syntax::TraitItem::Fn(_binding_0) => {
                        v.visit_trait_item_fn_mut(_binding_0);
                    }
                    ::syntax::TraitItem::Type(_binding_0) => {
                        v.visit_trait_item_type_mut(_binding_0);
                    }
                    ::syntax::TraitItem::Macro(_binding_0) => {
                        v.visit_trait_item_macro_mut(_binding_0);
                    }
                    ::syntax::TraitItem::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
                pub fn visit_trait_item_const_mut<V>(v: &mut V, node: &mut ::syntax::TraitItemConst) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.const_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                v.visit_type_mut(&mut node.ty);
                if let Some(it) = &mut node.default {
                    skip!((it).0);
                    v.visit_expr_mut(&mut (it).1);
                }
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_fn_mut<V>(v: &mut V, node: &mut ::syntax::TraitItemFn) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_signature_mut(&mut node.sig);
                if let Some(it) = &mut node.default {
                    v.visit_block_mut(it);
                }
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_macro_mut<V>(v: &mut V, node: &mut ::syntax::TraitItemMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_macro_mut(&mut node.mac);
                skip!(node.semi_token);
            }
                pub fn visit_trait_item_type_mut<V>(v: &mut V, node: &mut ::syntax::TraitItemType) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                skip!(node.type_token);
                v.visit_ident_mut(&mut node.ident);
                v.visit_generics_mut(&mut node.generics);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
                if let Some(it) = &mut node.default {
                    skip!((it).0);
                    v.visit_type_mut(&mut (it).1);
                }
                skip!(node.semi_token);
            }
            pub fn visit_type_mut<V>(v: &mut V, node: &mut ::syntax::Type) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Type::Array(_binding_0) => {
                        v.visit_type_array_mut(_binding_0);
                    }
                    ::syntax::Type::BareFn(_binding_0) => {
                        v.visit_type_bare_fn_mut(_binding_0);
                    }
                    ::syntax::Type::Group(_binding_0) => {
                        v.visit_type_group_mut(_binding_0);
                    }
                    ::syntax::Type::ImplTrait(_binding_0) => {
                        v.visit_type_impl_trait_mut(_binding_0);
                    }
                    ::syntax::Type::Infer(_binding_0) => {
                        v.visit_type_infer_mut(_binding_0);
                    }
                    ::syntax::Type::Macro(_binding_0) => {
                        v.visit_type_macro_mut(_binding_0);
                    }
                    ::syntax::Type::Never(_binding_0) => {
                        v.visit_type_never_mut(_binding_0);
                    }
                    ::syntax::Type::Paren(_binding_0) => {
                        v.visit_type_paren_mut(_binding_0);
                    }
                    ::syntax::Type::Path(_binding_0) => {
                        v.visit_type_path_mut(_binding_0);
                    }
                    ::syntax::Type::Ptr(_binding_0) => {
                        v.visit_type_ptr_mut(_binding_0);
                    }
                    ::syntax::Type::Reference(_binding_0) => {
                        v.visit_type_reference_mut(_binding_0);
                    }
                    ::syntax::Type::Slice(_binding_0) => {
                        v.visit_type_slice_mut(_binding_0);
                    }
                    ::syntax::Type::TraitObject(_binding_0) => {
                        v.visit_type_trait_object_mut(_binding_0);
                    }
                    ::syntax::Type::Tuple(_binding_0) => {
                        v.visit_type_tuple_mut(_binding_0);
                    }
                    ::syntax::Type::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
            pub fn visit_type_array_mut<V>(v: &mut V, node: &mut ::syntax::TypeArray) where
                V: VisitMut + ?Sized,
            {
                skip!(node.bracket_token);
                v.visit_type_mut(&mut *node.elem);
                skip!(node.semi_token);
                v.visit_expr_mut(&mut node.len);
            }
            pub fn visit_type_bare_fn_mut<V>(v: &mut V, node: &mut ::syntax::TypeBareFn) where
                V: VisitMut + ?Sized,
            {
                if let Some(it) = &mut node.lifetimes {
                    v.visit_bound_lifetimes_mut(it);
                }
                skip!(node.unsafety);
                if let Some(it) = &mut node.abi {
                    v.visit_abi_mut(it);
                }
                skip!(node.fn_token);
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.inputs) {
                    let it = el.value_mut();
                    v.visit_bare_fn_arg_mut(it);
                }
                if let Some(it) = &mut node.variadic {
                    v.visit_bare_variadic_mut(it);
                }
                v.visit_return_type_mut(&mut node.output);
            }
            pub fn visit_type_group_mut<V>(v: &mut V, node: &mut ::syntax::TypeGroup) where
                V: VisitMut + ?Sized,
            {
                skip!(node.group_token);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_impl_trait_mut<V>(v: &mut V, node: &mut ::syntax::TypeImplTrait) where
                V: VisitMut + ?Sized,
            {
                skip!(node.impl_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
            }
            pub fn visit_type_infer_mut<V>(v: &mut V, node: &mut ::syntax::TypeInfer) where
                V: VisitMut + ?Sized,
            {
                skip!(node.underscore_token);
            }
            pub fn visit_type_macro_mut<V>(v: &mut V, node: &mut ::syntax::TypeMacro) where
                V: VisitMut + ?Sized,
            {
                v.visit_macro_mut(&mut node.mac);
            }
            pub fn visit_type_never_mut<V>(v: &mut V, node: &mut ::syntax::TypeNever) where
                V: VisitMut + ?Sized,
            {
                skip!(node.bang_token);
            }
            pub fn visit_type_param_mut<V>(v: &mut V, node: &mut ::syntax::TypeParam) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
                skip!(node.eq_token);
                if let Some(it) = &mut node.default {
                    v.visit_type_mut(it);
                }
            }
            pub fn visit_type_param_bound_mut<V>(v: &mut V, node: &mut ::syntax::TypeParamBound) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::TypeParamBound::Trait(_binding_0) => {
                        v.visit_trait_bound_mut(_binding_0);
                    }
                    ::syntax::TypeParamBound::Lifetime(_binding_0) => {
                        v.visit_lifetime_mut(_binding_0);
                    }
                    ::syntax::TypeParamBound::PreciseCapture(_binding_0) => {
                        full!(v.visit_precise_capture_mut(_binding_0));
                    }
                    ::syntax::TypeParamBound::Verbatim(_binding_0) => {
                        v.visit_token_stream_mut(_binding_0);
                    }
                }
            }
            pub fn visit_type_paren_mut<V>(v: &mut V, node: &mut ::syntax::TypeParen) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_path_mut<V>(v: &mut V, node: &mut ::syntax::TypePath) where
                V: VisitMut + ?Sized,
            {
                if let Some(it) = &mut node.qself {
                    v.visit_qself_mut(it);
                }
                v.visit_path_mut(&mut node.path);
            }
            pub fn visit_type_ptr_mut<V>(v: &mut V, node: &mut ::syntax::TypePtr) where
                V: VisitMut + ?Sized,
            {
                skip!(node.star_token);
                skip!(node.const_token);
                skip!(node.mutability);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_reference_mut<V>(v: &mut V, node: &mut ::syntax::TypeReference) where
                V: VisitMut + ?Sized,
            {
                skip!(node.and_token);
                if let Some(it) = &mut node.lifetime {
                    v.visit_lifetime_mut(it);
                }
                skip!(node.mutability);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_slice_mut<V>(v: &mut V, node: &mut ::syntax::TypeSlice) where
                V: VisitMut + ?Sized,
            {
                skip!(node.bracket_token);
                v.visit_type_mut(&mut *node.elem);
            }
            pub fn visit_type_trait_object_mut<V>(v: &mut V, node: &mut ::syntax::TypeTraitObject) where
                V: VisitMut + ?Sized,
            {
                skip!(node.dyn_token);
                for mut el in Punctuated::pairs_mut(&mut node.bounds) {
                    let it = el.value_mut();
                    v.visit_type_param_bound_mut(it);
                }
            }
            pub fn visit_type_tuple_mut<V>(v: &mut V, node: &mut ::syntax::TypeTuple) where
                V: VisitMut + ?Sized,
            {
                skip!(node.paren_token);
                for mut el in Punctuated::pairs_mut(&mut node.elems) {
                    let it = el.value_mut();
                    v.visit_type_mut(it);
                }
            }
            pub fn visit_un_op_mut<V>(v: &mut V, node: &mut ::syntax::UnOp) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::UnOp::Deref(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::UnOp::Not(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::UnOp::Neg(_binding_0) => {
                        skip!(_binding_0);
                    }
                }
            }
                pub fn visit_use_glob_mut<V>(v: &mut V, node: &mut ::syntax::UseGlob) where
                V: VisitMut + ?Sized,
            {
                skip!(node.star_token);
            }
                pub fn visit_use_group_mut<V>(v: &mut V, node: &mut ::syntax::UseGroup) where
                V: VisitMut + ?Sized,
            {
                skip!(node.brace_token);
                for mut el in Punctuated::pairs_mut(&mut node.items) {
                    let it = el.value_mut();
                    v.visit_use_tree_mut(it);
                }
            }
                pub fn visit_use_name_mut<V>(v: &mut V, node: &mut ::syntax::UseName) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
            }
                pub fn visit_use_path_mut<V>(v: &mut V, node: &mut ::syntax::UsePath) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                skip!(node.colon2_token);
                v.visit_use_tree_mut(&mut *node.tree);
            }
                pub fn visit_use_rename_mut<V>(v: &mut V, node: &mut ::syntax::UseRename) where
                V: VisitMut + ?Sized,
            {
                v.visit_ident_mut(&mut node.ident);
                skip!(node.as_token);
                v.visit_ident_mut(&mut node.rename);
            }
                pub fn visit_use_tree_mut<V>(v: &mut V, node: &mut ::syntax::UseTree) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::UseTree::Path(_binding_0) => {
                        v.visit_use_path_mut(_binding_0);
                    }
                    ::syntax::UseTree::Name(_binding_0) => {
                        v.visit_use_name_mut(_binding_0);
                    }
                    ::syntax::UseTree::Rename(_binding_0) => {
                        v.visit_use_rename_mut(_binding_0);
                    }
                    ::syntax::UseTree::Glob(_binding_0) => {
                        v.visit_use_glob_mut(_binding_0);
                    }
                    ::syntax::UseTree::Group(_binding_0) => {
                        v.visit_use_group_mut(_binding_0);
                    }
                }
            }
                pub fn visit_variadic_mut<V>(v: &mut V, node: &mut ::syntax::Variadic) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                if let Some(it) = &mut node.pat {
                    v.visit_pat_mut(&mut *(it).0);
                    skip!((it).1);
                }
                skip!(node.dots);
                skip!(node.comma);
            }
            pub fn visit_variant_mut<V>(v: &mut V, node: &mut ::syntax::Variant) where
                V: VisitMut + ?Sized,
            {
                v.visit_attributes_mut(&mut node.attrs);
                v.visit_ident_mut(&mut node.ident);
                v.visit_fields_mut(&mut node.fields);
                if let Some(it) = &mut node.discriminant {
                    skip!((it).0);
                    v.visit_expr_mut(&mut (it).1);
                }
            }
            pub fn visit_vis_restricted_mut<V>(v: &mut V, node: &mut ::syntax::VisRestricted) where
                V: VisitMut + ?Sized,
            {
                skip!(node.pub_token);
                skip!(node.paren_token);
                skip!(node.in_token);
                v.visit_path_mut(&mut *node.path);
            }
            pub fn visit_visibility_mut<V>(v: &mut V, node: &mut ::syntax::Visibility) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::Visibility::Public(_binding_0) => {
                        skip!(_binding_0);
                    }
                    ::syntax::Visibility::Restricted(_binding_0) => {
                        v.visit_vis_restricted_mut(_binding_0);
                    }
                    ::syntax::Visibility::Inherited => {}
                }
            }
            pub fn visit_where_clause_mut<V>(v: &mut V, node: &mut ::syntax::WhereClause) where
                V: VisitMut + ?Sized,
            {
                skip!(node.where_token);
                for mut el in Punctuated::pairs_mut(&mut node.predicates) {
                    let it = el.value_mut();
                    v.visit_where_predicate_mut(it);
                }
            }
            pub fn visit_where_predicate_mut<V>(v: &mut V, node: &mut ::syntax::WherePredicate) where
                V: VisitMut + ?Sized,
            {
                match node {
                    ::syntax::WherePredicate::Lifetime(_binding_0) => {
                        v.visit_predicate_lifetime_mut(_binding_0);
                    }
                    ::syntax::WherePredicate::Type(_binding_0) => {
                        v.visit_predicate_type_mut(_binding_0);
                    }
                }
            }
        }

        pub mod clone
        {
            use ::
            {
                *,
            };
            /*
            */
             
            impl Clone for ::syntax::Abi {
                fn clone(&self) -> Self {
                    ::syntax::Abi {
                        extern_token: self.extern_token.clone(),
                        name: self.name.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::AngleBracketedGenericArguments {
                fn clone(&self) -> Self {
                    ::syntax::AngleBracketedGenericArguments {
                        colon2_token: self.colon2_token.clone(),
                        lt_token: self.lt_token.clone(),
                        args: self.args.clone(),
                        gt_token: self.gt_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Arm {
                fn clone(&self) -> Self {
                    ::syntax::Arm {
                        attrs: self.attrs.clone(),
                        pat: self.pat.clone(),
                        guard: self.guard.clone(),
                        fat_arrow_token: self.fat_arrow_token.clone(),
                        body: self.body.clone(),
                        comma: self.comma.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::AssocConst {
                fn clone(&self) -> Self {
                    ::syntax::AssocConst {
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        value: self.value.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::AssocType {
                fn clone(&self) -> Self {
                    ::syntax::AssocType {
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::AttrStyle {}
             
            impl Clone for ::syntax::AttrStyle {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::Attribute {
                fn clone(&self) -> Self {
                    ::syntax::Attribute {
                        pound_token: self.pound_token.clone(),
                        style: self.style.clone(),
                        bracket_token: self.bracket_token.clone(),
                        meta: self.meta.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::BareFnArg {
                fn clone(&self) -> Self {
                    ::syntax::BareFnArg {
                        attrs: self.attrs.clone(),
                        name: self.name.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::BareVariadic {
                fn clone(&self) -> Self {
                    ::syntax::BareVariadic {
                        attrs: self.attrs.clone(),
                        name: self.name.clone(),
                        dots: self.dots.clone(),
                        comma: self.comma.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::BinOp {}
             
            impl Clone for ::syntax::BinOp {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::Block {
                fn clone(&self) -> Self {
                    ::syntax::Block {
                        brace_token: self.brace_token.clone(),
                        stmts: self.stmts.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::BoundLifetimes {
                fn clone(&self) -> Self {
                    ::syntax::BoundLifetimes {
                        for_token: self.for_token.clone(),
                        lt_token: self.lt_token.clone(),
                        lifetimes: self.lifetimes.clone(),
                        gt_token: self.gt_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::CapturedParam {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::CapturedParam::Lifetime(v0) => {
                            ::syntax::CapturedParam::Lifetime(v0.clone())
                        }
                        ::syntax::CapturedParam::Ident(v0) => ::syntax::CapturedParam::Ident(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ConstParam {
                fn clone(&self) -> Self {
                    ::syntax::ConstParam {
                        attrs: self.attrs.clone(),
                        const_token: self.const_token.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        eq_token: self.eq_token.clone(),
                        default: self.default.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Constraint {
                fn clone(&self) -> Self {
                    ::syntax::Constraint {
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Data {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Data::Struct(v0) => ::syntax::Data::Struct(v0.clone()),
                        ::syntax::Data::Enum(v0) => ::syntax::Data::Enum(v0.clone()),
                        ::syntax::Data::Union(v0) => ::syntax::Data::Union(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::DataEnum {
                fn clone(&self) -> Self {
                    ::syntax::DataEnum {
                        enum_token: self.enum_token.clone(),
                        brace_token: self.brace_token.clone(),
                        variants: self.variants.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::DataStruct {
                fn clone(&self) -> Self {
                    ::syntax::DataStruct {
                        struct_token: self.struct_token.clone(),
                        fields: self.fields.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::DataUnion {
                fn clone(&self) -> Self {
                    ::syntax::DataUnion {
                        union_token: self.union_token.clone(),
                        fields: self.fields.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::DeriveInput {
                fn clone(&self) -> Self {
                    ::syntax::DeriveInput {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        data: self.data.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Expr {
                fn clone(&self) -> Self {
                    match self {
                                        ::syntax::Expr::Array(v0) => ::syntax::Expr::Array(v0.clone()),
                                        ::syntax::Expr::Assign(v0) => ::syntax::Expr::Assign(v0.clone()),
                                        ::syntax::Expr::Async(v0) => ::syntax::Expr::Async(v0.clone()),
                                        ::syntax::Expr::Await(v0) => ::syntax::Expr::Await(v0.clone()),
                        ::syntax::Expr::Binary(v0) => ::syntax::Expr::Binary(v0.clone()),
                                        ::syntax::Expr::Block(v0) => ::syntax::Expr::Block(v0.clone()),
                                        ::syntax::Expr::Break(v0) => ::syntax::Expr::Break(v0.clone()),
                        ::syntax::Expr::Call(v0) => ::syntax::Expr::Call(v0.clone()),
                        ::syntax::Expr::Cast(v0) => ::syntax::Expr::Cast(v0.clone()),
                                        ::syntax::Expr::Closure(v0) => ::syntax::Expr::Closure(v0.clone()),
                                        ::syntax::Expr::Const(v0) => ::syntax::Expr::Const(v0.clone()),
                                        ::syntax::Expr::Continue(v0) => ::syntax::Expr::Continue(v0.clone()),
                        ::syntax::Expr::Field(v0) => ::syntax::Expr::Field(v0.clone()),
                                        ::syntax::Expr::ForLoop(v0) => ::syntax::Expr::ForLoop(v0.clone()),
                        ::syntax::Expr::Group(v0) => ::syntax::Expr::Group(v0.clone()),
                                        ::syntax::Expr::If(v0) => ::syntax::Expr::If(v0.clone()),
                        ::syntax::Expr::Index(v0) => ::syntax::Expr::Index(v0.clone()),
                                        ::syntax::Expr::Infer(v0) => ::syntax::Expr::Infer(v0.clone()),
                                        ::syntax::Expr::Let(v0) => ::syntax::Expr::Let(v0.clone()),
                        ::syntax::Expr::Lit(v0) => ::syntax::Expr::Lit(v0.clone()),
                                        ::syntax::Expr::Loop(v0) => ::syntax::Expr::Loop(v0.clone()),
                        ::syntax::Expr::Macro(v0) => ::syntax::Expr::Macro(v0.clone()),
                                        ::syntax::Expr::Match(v0) => ::syntax::Expr::Match(v0.clone()),
                        ::syntax::Expr::MethodCall(v0) => ::syntax::Expr::MethodCall(v0.clone()),
                        ::syntax::Expr::Paren(v0) => ::syntax::Expr::Paren(v0.clone()),
                        ::syntax::Expr::Path(v0) => ::syntax::Expr::Path(v0.clone()),
                                        ::syntax::Expr::Range(v0) => ::syntax::Expr::Range(v0.clone()),
                                        ::syntax::Expr::RawAddr(v0) => ::syntax::Expr::RawAddr(v0.clone()),
                        ::syntax::Expr::Reference(v0) => ::syntax::Expr::Reference(v0.clone()),
                                        ::syntax::Expr::Repeat(v0) => ::syntax::Expr::Repeat(v0.clone()),
                                        ::syntax::Expr::Return(v0) => ::syntax::Expr::Return(v0.clone()),
                        ::syntax::Expr::Struct(v0) => ::syntax::Expr::Struct(v0.clone()),
                                        ::syntax::Expr::Try(v0) => ::syntax::Expr::Try(v0.clone()),
                                        ::syntax::Expr::TryBlock(v0) => ::syntax::Expr::TryBlock(v0.clone()),
                        ::syntax::Expr::Tuple(v0) => ::syntax::Expr::Tuple(v0.clone()),
                        ::syntax::Expr::Unary(v0) => ::syntax::Expr::Unary(v0.clone()),
                                        ::syntax::Expr::Unsafe(v0) => ::syntax::Expr::Unsafe(v0.clone()),
                        ::syntax::Expr::Verbatim(v0) => ::syntax::Expr::Verbatim(v0.clone()),
                        ::syntax::Expr::While(v0) => ::syntax::Expr::While(v0.clone()),
                        ::syntax::Expr::Yield(v0) => ::syntax::Expr::Yield(v0.clone()),
                                        
                    }
                }
            }
             
            impl Clone for ::syntax::ExprArray {
                fn clone(&self) -> Self {
                    ::syntax::ExprArray {
                        attrs: self.attrs.clone(),
                        bracket_token: self.bracket_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprAssign {
                fn clone(&self) -> Self {
                    ::syntax::ExprAssign {
                        attrs: self.attrs.clone(),
                        left: self.left.clone(),
                        eq_token: self.eq_token.clone(),
                        right: self.right.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprAsync {
                fn clone(&self) -> Self {
                    ::syntax::ExprAsync {
                        attrs: self.attrs.clone(),
                        async_token: self.async_token.clone(),
                        capture: self.capture.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprAwait {
                fn clone(&self) -> Self {
                    ::syntax::ExprAwait {
                        attrs: self.attrs.clone(),
                        base: self.base.clone(),
                        dot_token: self.dot_token.clone(),
                        await_token: self.await_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprBinary {
                fn clone(&self) -> Self {
                    ::syntax::ExprBinary {
                        attrs: self.attrs.clone(),
                        left: self.left.clone(),
                        op: self.op.clone(),
                        right: self.right.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprBlock {
                fn clone(&self) -> Self {
                    ::syntax::ExprBlock {
                        attrs: self.attrs.clone(),
                        label: self.label.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprBreak {
                fn clone(&self) -> Self {
                    ::syntax::ExprBreak {
                        attrs: self.attrs.clone(),
                        break_token: self.break_token.clone(),
                        label: self.label.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprCall {
                fn clone(&self) -> Self {
                    ::syntax::ExprCall {
                        attrs: self.attrs.clone(),
                        func: self.func.clone(),
                        paren_token: self.paren_token.clone(),
                        args: self.args.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprCast {
                fn clone(&self) -> Self {
                    ::syntax::ExprCast {
                        attrs: self.attrs.clone(),
                        expr: self.expr.clone(),
                        as_token: self.as_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprClosure {
                fn clone(&self) -> Self {
                    ::syntax::ExprClosure {
                        attrs: self.attrs.clone(),
                        lifetimes: self.lifetimes.clone(),
                        constness: self.constness.clone(),
                        movability: self.movability.clone(),
                        asyncness: self.asyncness.clone(),
                        capture: self.capture.clone(),
                        or1_token: self.or1_token.clone(),
                        inputs: self.inputs.clone(),
                        or2_token: self.or2_token.clone(),
                        output: self.output.clone(),
                        body: self.body.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprConst {
                fn clone(&self) -> Self {
                    ::syntax::ExprConst {
                        attrs: self.attrs.clone(),
                        const_token: self.const_token.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprContinue {
                fn clone(&self) -> Self {
                    ::syntax::ExprContinue {
                        attrs: self.attrs.clone(),
                        continue_token: self.continue_token.clone(),
                        label: self.label.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprField {
                fn clone(&self) -> Self {
                    ::syntax::ExprField {
                        attrs: self.attrs.clone(),
                        base: self.base.clone(),
                        dot_token: self.dot_token.clone(),
                        member: self.member.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprForLoop {
                fn clone(&self) -> Self {
                    ::syntax::ExprForLoop {
                        attrs: self.attrs.clone(),
                        label: self.label.clone(),
                        for_token: self.for_token.clone(),
                        pat: self.pat.clone(),
                        in_token: self.in_token.clone(),
                        expr: self.expr.clone(),
                        body: self.body.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprGroup {
                fn clone(&self) -> Self {
                    ::syntax::ExprGroup {
                        attrs: self.attrs.clone(),
                        group_token: self.group_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprIf {
                fn clone(&self) -> Self {
                    ::syntax::ExprIf {
                        attrs: self.attrs.clone(),
                        if_token: self.if_token.clone(),
                        cond: self.cond.clone(),
                        then_branch: self.then_branch.clone(),
                        else_branch: self.else_branch.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprIndex {
                fn clone(&self) -> Self {
                    ::syntax::ExprIndex {
                        attrs: self.attrs.clone(),
                        expr: self.expr.clone(),
                        bracket_token: self.bracket_token.clone(),
                        index: self.index.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprInfer {
                fn clone(&self) -> Self {
                    ::syntax::ExprInfer {
                        attrs: self.attrs.clone(),
                        underscore_token: self.underscore_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprLet {
                fn clone(&self) -> Self {
                    ::syntax::ExprLet {
                        attrs: self.attrs.clone(),
                        let_token: self.let_token.clone(),
                        pat: self.pat.clone(),
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprLit {
                fn clone(&self) -> Self {
                    ::syntax::ExprLit {
                        attrs: self.attrs.clone(),
                        lit: self.lit.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprLoop {
                fn clone(&self) -> Self {
                    ::syntax::ExprLoop {
                        attrs: self.attrs.clone(),
                        label: self.label.clone(),
                        loop_token: self.loop_token.clone(),
                        body: self.body.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprMacro {
                fn clone(&self) -> Self {
                    ::syntax::ExprMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprMatch {
                fn clone(&self) -> Self {
                    ::syntax::ExprMatch {
                        attrs: self.attrs.clone(),
                        match_token: self.match_token.clone(),
                        expr: self.expr.clone(),
                        brace_token: self.brace_token.clone(),
                        arms: self.arms.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprMethodCall {
                fn clone(&self) -> Self {
                    ::syntax::ExprMethodCall {
                        attrs: self.attrs.clone(),
                        receiver: self.receiver.clone(),
                        dot_token: self.dot_token.clone(),
                        method: self.method.clone(),
                        turbofish: self.turbofish.clone(),
                        paren_token: self.paren_token.clone(),
                        args: self.args.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprParen {
                fn clone(&self) -> Self {
                    ::syntax::ExprParen {
                        attrs: self.attrs.clone(),
                        paren_token: self.paren_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprPath {
                fn clone(&self) -> Self {
                    ::syntax::ExprPath {
                        attrs: self.attrs.clone(),
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprRange {
                fn clone(&self) -> Self {
                    ::syntax::ExprRange {
                        attrs: self.attrs.clone(),
                        start: self.start.clone(),
                        limits: self.limits.clone(),
                        end: self.end.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprRawAddr {
                fn clone(&self) -> Self {
                    ::syntax::ExprRawAddr {
                        attrs: self.attrs.clone(),
                        and_token: self.and_token.clone(),
                        raw: self.raw.clone(),
                        mutability: self.mutability.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprReference {
                fn clone(&self) -> Self {
                    ::syntax::ExprReference {
                        attrs: self.attrs.clone(),
                        and_token: self.and_token.clone(),
                        mutability: self.mutability.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprRepeat {
                fn clone(&self) -> Self {
                    ::syntax::ExprRepeat {
                        attrs: self.attrs.clone(),
                        bracket_token: self.bracket_token.clone(),
                        expr: self.expr.clone(),
                        semi_token: self.semi_token.clone(),
                        len: self.len.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprReturn {
                fn clone(&self) -> Self {
                    ::syntax::ExprReturn {
                        attrs: self.attrs.clone(),
                        return_token: self.return_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprStruct {
                fn clone(&self) -> Self {
                    ::syntax::ExprStruct {
                        attrs: self.attrs.clone(),
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                        brace_token: self.brace_token.clone(),
                        fields: self.fields.clone(),
                        dot2_token: self.dot2_token.clone(),
                        rest: self.rest.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprTry {
                fn clone(&self) -> Self {
                    ::syntax::ExprTry {
                        attrs: self.attrs.clone(),
                        expr: self.expr.clone(),
                        question_token: self.question_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprTryBlock {
                fn clone(&self) -> Self {
                    ::syntax::ExprTryBlock {
                        attrs: self.attrs.clone(),
                        try_token: self.try_token.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprTuple {
                fn clone(&self) -> Self {
                    ::syntax::ExprTuple {
                        attrs: self.attrs.clone(),
                        paren_token: self.paren_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprUnary {
                fn clone(&self) -> Self {
                    ::syntax::ExprUnary {
                        attrs: self.attrs.clone(),
                        op: self.op.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprUnsafe {
                fn clone(&self) -> Self {
                    ::syntax::ExprUnsafe {
                        attrs: self.attrs.clone(),
                        unsafe_token: self.unsafe_token.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprWhile {
                fn clone(&self) -> Self {
                    ::syntax::ExprWhile {
                        attrs: self.attrs.clone(),
                        label: self.label.clone(),
                        while_token: self.while_token.clone(),
                        cond: self.cond.clone(),
                        body: self.body.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ExprYield {
                fn clone(&self) -> Self {
                    ::syntax::ExprYield {
                        attrs: self.attrs.clone(),
                        yield_token: self.yield_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Field {
                fn clone(&self) -> Self {
                    ::syntax::Field {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        mutability: self.mutability.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::FieldMutability {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::FieldMutability::None => ::syntax::FieldMutability::None,
                    }
                }
            }
             
            impl Clone for ::syntax::FieldPat {
                fn clone(&self) -> Self {
                    ::syntax::FieldPat {
                        attrs: self.attrs.clone(),
                        member: self.member.clone(),
                        colon_token: self.colon_token.clone(),
                        pat: self.pat.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::FieldValue {
                fn clone(&self) -> Self {
                    ::syntax::FieldValue {
                        attrs: self.attrs.clone(),
                        member: self.member.clone(),
                        colon_token: self.colon_token.clone(),
                        expr: self.expr.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Fields {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Fields::Named(v0) => ::syntax::Fields::Named(v0.clone()),
                        ::syntax::Fields::Unnamed(v0) => ::syntax::Fields::Unnamed(v0.clone()),
                        ::syntax::Fields::Unit => ::syntax::Fields::Unit,
                    }
                }
            }
             
            impl Clone for ::syntax::FieldsNamed {
                fn clone(&self) -> Self {
                    ::syntax::FieldsNamed {
                        brace_token: self.brace_token.clone(),
                        named: self.named.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::FieldsUnnamed {
                fn clone(&self) -> Self {
                    ::syntax::FieldsUnnamed {
                        paren_token: self.paren_token.clone(),
                        unnamed: self.unnamed.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::File {
                fn clone(&self) -> Self {
                    ::syntax::File {
                        shebang: self.shebang.clone(),
                        attrs: self.attrs.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::FnArg {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::FnArg::Receiver(v0) => ::syntax::FnArg::Receiver(v0.clone()),
                        ::syntax::FnArg::Typed(v0) => ::syntax::FnArg::Typed(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItem {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::ForeignItem::Fn(v0) => ::syntax::ForeignItem::Fn(v0.clone()),
                        ::syntax::ForeignItem::Static(v0) => ::syntax::ForeignItem::Static(v0.clone()),
                        ::syntax::ForeignItem::Type(v0) => ::syntax::ForeignItem::Type(v0.clone()),
                        ::syntax::ForeignItem::Macro(v0) => ::syntax::ForeignItem::Macro(v0.clone()),
                        ::syntax::ForeignItem::Verbatim(v0) => ::syntax::ForeignItem::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItemFn {
                fn clone(&self) -> Self {
                    ::syntax::ForeignItemFn {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        sig: self.sig.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItemMacro {
                fn clone(&self) -> Self {
                    ::syntax::ForeignItemMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItemStatic {
                fn clone(&self) -> Self {
                    ::syntax::ForeignItemStatic {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        static_token: self.static_token.clone(),
                        mutability: self.mutability.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ForeignItemType {
                fn clone(&self) -> Self {
                    ::syntax::ForeignItemType {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        type_token: self.type_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::GenericArgument {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::GenericArgument::Lifetime(v0) => {
                            ::syntax::GenericArgument::Lifetime(v0.clone())
                        }
                        ::syntax::GenericArgument::Type(v0) => ::syntax::GenericArgument::Type(v0.clone()),
                        ::syntax::GenericArgument::Const(v0) => {
                            ::syntax::GenericArgument::Const(v0.clone())
                        }
                        ::syntax::GenericArgument::AssocType(v0) => {
                            ::syntax::GenericArgument::AssocType(v0.clone())
                        }
                        ::syntax::GenericArgument::AssocConst(v0) => {
                            ::syntax::GenericArgument::AssocConst(v0.clone())
                        }
                        ::syntax::GenericArgument::Constraint(v0) => {
                            ::syntax::GenericArgument::Constraint(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::GenericParam {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::GenericParam::Lifetime(v0) => {
                            ::syntax::GenericParam::Lifetime(v0.clone())
                        }
                        ::syntax::GenericParam::Type(v0) => ::syntax::GenericParam::Type(v0.clone()),
                        ::syntax::GenericParam::Const(v0) => ::syntax::GenericParam::Const(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::Generics {
                fn clone(&self) -> Self {
                    ::syntax::Generics {
                        lt_token: self.lt_token.clone(),
                        params: self.params.clone(),
                        gt_token: self.gt_token.clone(),
                        where_clause: self.where_clause.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItem {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::ImplItem::Const(v0) => ::syntax::ImplItem::Const(v0.clone()),
                        ::syntax::ImplItem::Fn(v0) => ::syntax::ImplItem::Fn(v0.clone()),
                        ::syntax::ImplItem::Type(v0) => ::syntax::ImplItem::Type(v0.clone()),
                        ::syntax::ImplItem::Macro(v0) => ::syntax::ImplItem::Macro(v0.clone()),
                        ::syntax::ImplItem::Verbatim(v0) => ::syntax::ImplItem::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItemConst {
                fn clone(&self) -> Self {
                    ::syntax::ImplItemConst {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        defaultness: self.defaultness.clone(),
                        const_token: self.const_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItemFn {
                fn clone(&self) -> Self {
                    ::syntax::ImplItemFn {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        defaultness: self.defaultness.clone(),
                        sig: self.sig.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItemMacro {
                fn clone(&self) -> Self {
                    ::syntax::ImplItemMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplItemType {
                fn clone(&self) -> Self {
                    ::syntax::ImplItemType {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        defaultness: self.defaultness.clone(),
                        type_token: self.type_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        ty: self.ty.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ImplRestriction {
                fn clone(&self) -> Self {
                    match *self {}
                }
            }
             
            impl Clone for ::syntax::Index {
                fn clone(&self) -> Self {
                    ::syntax::Index {
                        index: self.index.clone(),
                        span: self.span.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Item {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Item::Const(v0) => ::syntax::Item::Const(v0.clone()),
                        ::syntax::Item::Enum(v0) => ::syntax::Item::Enum(v0.clone()),
                        ::syntax::Item::ExternCrate(v0) => ::syntax::Item::ExternCrate(v0.clone()),
                        ::syntax::Item::Fn(v0) => ::syntax::Item::Fn(v0.clone()),
                        ::syntax::Item::ForeignMod(v0) => ::syntax::Item::ForeignMod(v0.clone()),
                        ::syntax::Item::Impl(v0) => ::syntax::Item::Impl(v0.clone()),
                        ::syntax::Item::Macro(v0) => ::syntax::Item::Macro(v0.clone()),
                        ::syntax::Item::Mod(v0) => ::syntax::Item::Mod(v0.clone()),
                        ::syntax::Item::Static(v0) => ::syntax::Item::Static(v0.clone()),
                        ::syntax::Item::Struct(v0) => ::syntax::Item::Struct(v0.clone()),
                        ::syntax::Item::Trait(v0) => ::syntax::Item::Trait(v0.clone()),
                        ::syntax::Item::TraitAlias(v0) => ::syntax::Item::TraitAlias(v0.clone()),
                        ::syntax::Item::Type(v0) => ::syntax::Item::Type(v0.clone()),
                        ::syntax::Item::Union(v0) => ::syntax::Item::Union(v0.clone()),
                        ::syntax::Item::Use(v0) => ::syntax::Item::Use(v0.clone()),
                        ::syntax::Item::Verbatim(v0) => ::syntax::Item::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemConst {
                fn clone(&self) -> Self {
                    ::syntax::ItemConst {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        const_token: self.const_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemEnum {
                fn clone(&self) -> Self {
                    ::syntax::ItemEnum {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        enum_token: self.enum_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        brace_token: self.brace_token.clone(),
                        variants: self.variants.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemExternCrate {
                fn clone(&self) -> Self {
                    ::syntax::ItemExternCrate {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        extern_token: self.extern_token.clone(),
                        crate_token: self.crate_token.clone(),
                        ident: self.ident.clone(),
                        rename: self.rename.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemFn {
                fn clone(&self) -> Self {
                    ::syntax::ItemFn {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        sig: self.sig.clone(),
                        block: self.block.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemForeignMod {
                fn clone(&self) -> Self {
                    ::syntax::ItemForeignMod {
                        attrs: self.attrs.clone(),
                        unsafety: self.unsafety.clone(),
                        abi: self.abi.clone(),
                        brace_token: self.brace_token.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemImpl {
                fn clone(&self) -> Self {
                    ::syntax::ItemImpl {
                        attrs: self.attrs.clone(),
                        defaultness: self.defaultness.clone(),
                        unsafety: self.unsafety.clone(),
                        impl_token: self.impl_token.clone(),
                        generics: self.generics.clone(),
                        trait_: self.trait_.clone(),
                        self_ty: self.self_ty.clone(),
                        brace_token: self.brace_token.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemMacro {
                fn clone(&self) -> Self {
                    ::syntax::ItemMacro {
                        attrs: self.attrs.clone(),
                        ident: self.ident.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemMod {
                fn clone(&self) -> Self {
                    ::syntax::ItemMod {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        unsafety: self.unsafety.clone(),
                        mod_token: self.mod_token.clone(),
                        ident: self.ident.clone(),
                        content: self.content.clone(),
                        semi: self.semi.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemStatic {
                fn clone(&self) -> Self {
                    ::syntax::ItemStatic {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        static_token: self.static_token.clone(),
                        mutability: self.mutability.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemStruct {
                fn clone(&self) -> Self {
                    ::syntax::ItemStruct {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        struct_token: self.struct_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        fields: self.fields.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemTrait {
                fn clone(&self) -> Self {
                    ::syntax::ItemTrait {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        unsafety: self.unsafety.clone(),
                        auto_token: self.auto_token.clone(),
                        restriction: self.restriction.clone(),
                        trait_token: self.trait_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        supertraits: self.supertraits.clone(),
                        brace_token: self.brace_token.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemTraitAlias {
                fn clone(&self) -> Self {
                    ::syntax::ItemTraitAlias {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        trait_token: self.trait_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        bounds: self.bounds.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemType {
                fn clone(&self) -> Self {
                    ::syntax::ItemType {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        type_token: self.type_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        eq_token: self.eq_token.clone(),
                        ty: self.ty.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemUnion {
                fn clone(&self) -> Self {
                    ::syntax::ItemUnion {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        union_token: self.union_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        fields: self.fields.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ItemUse {
                fn clone(&self) -> Self {
                    ::syntax::ItemUse {
                        attrs: self.attrs.clone(),
                        vis: self.vis.clone(),
                        use_token: self.use_token.clone(),
                        leading_colon: self.leading_colon.clone(),
                        tree: self.tree.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Label {
                fn clone(&self) -> Self {
                    ::syntax::Label {
                        name: self.name.clone(),
                        colon_token: self.colon_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::LifetimeParam {
                fn clone(&self) -> Self {
                    ::syntax::LifetimeParam {
                        attrs: self.attrs.clone(),
                        lifetime: self.lifetime.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Lit {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Lit::Str(v0) => ::syntax::Lit::Str(v0.clone()),
                        ::syntax::Lit::ByteStr(v0) => ::syntax::Lit::ByteStr(v0.clone()),
                        ::syntax::Lit::CStr(v0) => ::syntax::Lit::CStr(v0.clone()),
                        ::syntax::Lit::Byte(v0) => ::syntax::Lit::Byte(v0.clone()),
                        ::syntax::Lit::Char(v0) => ::syntax::Lit::Char(v0.clone()),
                        ::syntax::Lit::Int(v0) => ::syntax::Lit::Int(v0.clone()),
                        ::syntax::Lit::Float(v0) => ::syntax::Lit::Float(v0.clone()),
                        ::syntax::Lit::Bool(v0) => ::syntax::Lit::Bool(v0.clone()),
                        ::syntax::Lit::Verbatim(v0) => ::syntax::Lit::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::LitBool {
                fn clone(&self) -> Self {
                    ::syntax::LitBool {
                        value: self.value.clone(),
                        span: self.span.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Local {
                fn clone(&self) -> Self {
                    ::syntax::Local {
                        attrs: self.attrs.clone(),
                        let_token: self.let_token.clone(),
                        pat: self.pat.clone(),
                        init: self.init.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::LocalInit {
                fn clone(&self) -> Self {
                    ::syntax::LocalInit {
                        eq_token: self.eq_token.clone(),
                        expr: self.expr.clone(),
                        diverge: self.diverge.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Macro {
                fn clone(&self) -> Self {
                    ::syntax::Macro {
                        path: self.path.clone(),
                        bang_token: self.bang_token.clone(),
                        delimiter: self.delimiter.clone(),
                        tokens: self.tokens.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::MacroDelimiter {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::MacroDelimiter::Paren(v0) => ::syntax::MacroDelimiter::Paren(v0.clone()),
                        ::syntax::MacroDelimiter::Brace(v0) => ::syntax::MacroDelimiter::Brace(v0.clone()),
                        ::syntax::MacroDelimiter::Bracket(v0) => {
                            ::syntax::MacroDelimiter::Bracket(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::Member {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Member::Named(v0) => ::syntax::Member::Named(v0.clone()),
                        ::syntax::Member::Unnamed(v0) => ::syntax::Member::Unnamed(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::Meta {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Meta::Path(v0) => ::syntax::Meta::Path(v0.clone()),
                        ::syntax::Meta::List(v0) => ::syntax::Meta::List(v0.clone()),
                        ::syntax::Meta::NameValue(v0) => ::syntax::Meta::NameValue(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::MetaList {
                fn clone(&self) -> Self {
                    ::syntax::MetaList {
                        path: self.path.clone(),
                        delimiter: self.delimiter.clone(),
                        tokens: self.tokens.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::MetaNameValue {
                fn clone(&self) -> Self {
                    ::syntax::MetaNameValue {
                        path: self.path.clone(),
                        eq_token: self.eq_token.clone(),
                        value: self.value.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ParenthesizedGenericArguments {
                fn clone(&self) -> Self {
                    ::syntax::ParenthesizedGenericArguments {
                        paren_token: self.paren_token.clone(),
                        inputs: self.inputs.clone(),
                        output: self.output.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Pat {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Pat::Const(v0) => ::syntax::Pat::Const(v0.clone()),
                        ::syntax::Pat::Ident(v0) => ::syntax::Pat::Ident(v0.clone()),
                        ::syntax::Pat::Lit(v0) => ::syntax::Pat::Lit(v0.clone()),
                        ::syntax::Pat::Macro(v0) => ::syntax::Pat::Macro(v0.clone()),
                        ::syntax::Pat::Or(v0) => ::syntax::Pat::Or(v0.clone()),
                        ::syntax::Pat::Paren(v0) => ::syntax::Pat::Paren(v0.clone()),
                        ::syntax::Pat::Path(v0) => ::syntax::Pat::Path(v0.clone()),
                        ::syntax::Pat::Range(v0) => ::syntax::Pat::Range(v0.clone()),
                        ::syntax::Pat::Reference(v0) => ::syntax::Pat::Reference(v0.clone()),
                        ::syntax::Pat::Rest(v0) => ::syntax::Pat::Rest(v0.clone()),
                        ::syntax::Pat::Slice(v0) => ::syntax::Pat::Slice(v0.clone()),
                        ::syntax::Pat::Struct(v0) => ::syntax::Pat::Struct(v0.clone()),
                        ::syntax::Pat::Tuple(v0) => ::syntax::Pat::Tuple(v0.clone()),
                        ::syntax::Pat::TupleStruct(v0) => ::syntax::Pat::TupleStruct(v0.clone()),
                        ::syntax::Pat::Type(v0) => ::syntax::Pat::Type(v0.clone()),
                        ::syntax::Pat::Verbatim(v0) => ::syntax::Pat::Verbatim(v0.clone()),
                        ::syntax::Pat::Wild(v0) => ::syntax::Pat::Wild(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::PatIdent {
                fn clone(&self) -> Self {
                    ::syntax::PatIdent {
                        attrs: self.attrs.clone(),
                        by_ref: self.by_ref.clone(),
                        mutability: self.mutability.clone(),
                        ident: self.ident.clone(),
                        subpat: self.subpat.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatOr {
                fn clone(&self) -> Self {
                    ::syntax::PatOr {
                        attrs: self.attrs.clone(),
                        leading_vert: self.leading_vert.clone(),
                        cases: self.cases.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatParen {
                fn clone(&self) -> Self {
                    ::syntax::PatParen {
                        attrs: self.attrs.clone(),
                        paren_token: self.paren_token.clone(),
                        pat: self.pat.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatReference {
                fn clone(&self) -> Self {
                    ::syntax::PatReference {
                        attrs: self.attrs.clone(),
                        and_token: self.and_token.clone(),
                        mutability: self.mutability.clone(),
                        pat: self.pat.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatRest {
                fn clone(&self) -> Self {
                    ::syntax::PatRest {
                        attrs: self.attrs.clone(),
                        dot2_token: self.dot2_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatSlice {
                fn clone(&self) -> Self {
                    ::syntax::PatSlice {
                        attrs: self.attrs.clone(),
                        bracket_token: self.bracket_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatStruct {
                fn clone(&self) -> Self {
                    ::syntax::PatStruct {
                        attrs: self.attrs.clone(),
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                        brace_token: self.brace_token.clone(),
                        fields: self.fields.clone(),
                        rest: self.rest.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatTuple {
                fn clone(&self) -> Self {
                    ::syntax::PatTuple {
                        attrs: self.attrs.clone(),
                        paren_token: self.paren_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatTupleStruct {
                fn clone(&self) -> Self {
                    ::syntax::PatTupleStruct {
                        attrs: self.attrs.clone(),
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                        paren_token: self.paren_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatType {
                fn clone(&self) -> Self {
                    ::syntax::PatType {
                        attrs: self.attrs.clone(),
                        pat: self.pat.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PatWild {
                fn clone(&self) -> Self {
                    ::syntax::PatWild {
                        attrs: self.attrs.clone(),
                        underscore_token: self.underscore_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Path {
                fn clone(&self) -> Self {
                    ::syntax::Path {
                        leading_colon: self.leading_colon.clone(),
                        segments: self.segments.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PathArguments {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::PathArguments::None => ::syntax::PathArguments::None,
                        ::syntax::PathArguments::AngleBracketed(v0) => {
                            ::syntax::PathArguments::AngleBracketed(v0.clone())
                        }
                        ::syntax::PathArguments::Parenthesized(v0) => {
                            ::syntax::PathArguments::Parenthesized(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::PathSegment {
                fn clone(&self) -> Self {
                    ::syntax::PathSegment {
                        ident: self.ident.clone(),
                        arguments: self.arguments.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PointerMutability {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::PointerMutability::Const(v0) => {
                            ::syntax::PointerMutability::Const(v0.clone())
                        }
                        ::syntax::PointerMutability::Mut(v0) => {
                            ::syntax::PointerMutability::Mut(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::PreciseCapture {
                fn clone(&self) -> Self {
                    ::syntax::PreciseCapture {
                        use_token: self.use_token.clone(),
                        lt_token: self.lt_token.clone(),
                        params: self.params.clone(),
                        gt_token: self.gt_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PredicateLifetime {
                fn clone(&self) -> Self {
                    ::syntax::PredicateLifetime {
                        lifetime: self.lifetime.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::PredicateType {
                fn clone(&self) -> Self {
                    ::syntax::PredicateType {
                        lifetimes: self.lifetimes.clone(),
                        bounded_ty: self.bounded_ty.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::QSelf {
                fn clone(&self) -> Self {
                    ::syntax::QSelf {
                        lt_token: self.lt_token.clone(),
                        ty: self.ty.clone(),
                        position: self.position.clone(),
                        as_token: self.as_token.clone(),
                        gt_token: self.gt_token.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::RangeLimits {}
             
            impl Clone for ::syntax::RangeLimits {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::Receiver {
                fn clone(&self) -> Self {
                    ::syntax::Receiver {
                        attrs: self.attrs.clone(),
                        reference: self.reference.clone(),
                        mutability: self.mutability.clone(),
                        self_token: self.self_token.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::ReturnType {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::ReturnType::Default => ::syntax::ReturnType::Default,
                        ::syntax::ReturnType::Type(v0, v1) => {
                            ::syntax::ReturnType::Type(v0.clone(), v1.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::Signature {
                fn clone(&self) -> Self {
                    ::syntax::Signature {
                        constness: self.constness.clone(),
                        asyncness: self.asyncness.clone(),
                        unsafety: self.unsafety.clone(),
                        abi: self.abi.clone(),
                        fn_token: self.fn_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        paren_token: self.paren_token.clone(),
                        inputs: self.inputs.clone(),
                        variadic: self.variadic.clone(),
                        output: self.output.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::StaticMutability {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::StaticMutability::Mut(v0) => ::syntax::StaticMutability::Mut(v0.clone()),
                        ::syntax::StaticMutability::None => ::syntax::StaticMutability::None,
                    }
                }
            }
             
            impl Clone for ::syntax::Stmt {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Stmt::Local(v0) => ::syntax::Stmt::Local(v0.clone()),
                        ::syntax::Stmt::Item(v0) => ::syntax::Stmt::Item(v0.clone()),
                        ::syntax::Stmt::Expr(v0, v1) => ::syntax::Stmt::Expr(v0.clone(), v1.clone()),
                        ::syntax::Stmt::Macro(v0) => ::syntax::Stmt::Macro(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::StmtMacro {
                fn clone(&self) -> Self {
                    ::syntax::StmtMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitBound {
                fn clone(&self) -> Self {
                    ::syntax::TraitBound {
                        paren_token: self.paren_token.clone(),
                        modifier: self.modifier.clone(),
                        lifetimes: self.lifetimes.clone(),
                        path: self.path.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::TraitBoundModifier {}
             
            impl Clone for ::syntax::TraitBoundModifier {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::TraitItem {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::TraitItem::Const(v0) => ::syntax::TraitItem::Const(v0.clone()),
                        ::syntax::TraitItem::Fn(v0) => ::syntax::TraitItem::Fn(v0.clone()),
                        ::syntax::TraitItem::Type(v0) => ::syntax::TraitItem::Type(v0.clone()),
                        ::syntax::TraitItem::Macro(v0) => ::syntax::TraitItem::Macro(v0.clone()),
                        ::syntax::TraitItem::Verbatim(v0) => ::syntax::TraitItem::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitItemConst {
                fn clone(&self) -> Self {
                    ::syntax::TraitItemConst {
                        attrs: self.attrs.clone(),
                        const_token: self.const_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        ty: self.ty.clone(),
                        default: self.default.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitItemFn {
                fn clone(&self) -> Self {
                    ::syntax::TraitItemFn {
                        attrs: self.attrs.clone(),
                        sig: self.sig.clone(),
                        default: self.default.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitItemMacro {
                fn clone(&self) -> Self {
                    ::syntax::TraitItemMacro {
                        attrs: self.attrs.clone(),
                        mac: self.mac.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TraitItemType {
                fn clone(&self) -> Self {
                    ::syntax::TraitItemType {
                        attrs: self.attrs.clone(),
                        type_token: self.type_token.clone(),
                        ident: self.ident.clone(),
                        generics: self.generics.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                        default: self.default.clone(),
                        semi_token: self.semi_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Type {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Type::Array(v0) => ::syntax::Type::Array(v0.clone()),
                        ::syntax::Type::BareFn(v0) => ::syntax::Type::BareFn(v0.clone()),
                        ::syntax::Type::Group(v0) => ::syntax::Type::Group(v0.clone()),
                        ::syntax::Type::ImplTrait(v0) => ::syntax::Type::ImplTrait(v0.clone()),
                        ::syntax::Type::Infer(v0) => ::syntax::Type::Infer(v0.clone()),
                        ::syntax::Type::Macro(v0) => ::syntax::Type::Macro(v0.clone()),
                        ::syntax::Type::Never(v0) => ::syntax::Type::Never(v0.clone()),
                        ::syntax::Type::Paren(v0) => ::syntax::Type::Paren(v0.clone()),
                        ::syntax::Type::Path(v0) => ::syntax::Type::Path(v0.clone()),
                        ::syntax::Type::Ptr(v0) => ::syntax::Type::Ptr(v0.clone()),
                        ::syntax::Type::Reference(v0) => ::syntax::Type::Reference(v0.clone()),
                        ::syntax::Type::Slice(v0) => ::syntax::Type::Slice(v0.clone()),
                        ::syntax::Type::TraitObject(v0) => ::syntax::Type::TraitObject(v0.clone()),
                        ::syntax::Type::Tuple(v0) => ::syntax::Type::Tuple(v0.clone()),
                        ::syntax::Type::Verbatim(v0) => ::syntax::Type::Verbatim(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeArray {
                fn clone(&self) -> Self {
                    ::syntax::TypeArray {
                        bracket_token: self.bracket_token.clone(),
                        elem: self.elem.clone(),
                        semi_token: self.semi_token.clone(),
                        len: self.len.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeBareFn {
                fn clone(&self) -> Self {
                    ::syntax::TypeBareFn {
                        lifetimes: self.lifetimes.clone(),
                        unsafety: self.unsafety.clone(),
                        abi: self.abi.clone(),
                        fn_token: self.fn_token.clone(),
                        paren_token: self.paren_token.clone(),
                        inputs: self.inputs.clone(),
                        variadic: self.variadic.clone(),
                        output: self.output.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeGroup {
                fn clone(&self) -> Self {
                    ::syntax::TypeGroup {
                        group_token: self.group_token.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeImplTrait {
                fn clone(&self) -> Self {
                    ::syntax::TypeImplTrait {
                        impl_token: self.impl_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeInfer {
                fn clone(&self) -> Self {
                    ::syntax::TypeInfer {
                        underscore_token: self.underscore_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeMacro {
                fn clone(&self) -> Self {
                    ::syntax::TypeMacro {
                        mac: self.mac.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeNever {
                fn clone(&self) -> Self {
                    ::syntax::TypeNever {
                        bang_token: self.bang_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeParam {
                fn clone(&self) -> Self {
                    ::syntax::TypeParam {
                        attrs: self.attrs.clone(),
                        ident: self.ident.clone(),
                        colon_token: self.colon_token.clone(),
                        bounds: self.bounds.clone(),
                        eq_token: self.eq_token.clone(),
                        default: self.default.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeParamBound {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::TypeParamBound::Trait(v0) => ::syntax::TypeParamBound::Trait(v0.clone()),
                        ::syntax::TypeParamBound::Lifetime(v0) => {
                            ::syntax::TypeParamBound::Lifetime(v0.clone())
                        }
                                        ::syntax::TypeParamBound::PreciseCapture(v0) => {
                            ::syntax::TypeParamBound::PreciseCapture(v0.clone())
                        }
                        ::syntax::TypeParamBound::Verbatim(v0) => {
                            ::syntax::TypeParamBound::Verbatim(v0.clone())
                        }
                    }
                }
            }
             
            impl Clone for ::syntax::TypeParen {
                fn clone(&self) -> Self {
                    ::syntax::TypeParen {
                        paren_token: self.paren_token.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypePath {
                fn clone(&self) -> Self {
                    ::syntax::TypePath {
                        qself: self.qself.clone(),
                        path: self.path.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypePtr {
                fn clone(&self) -> Self {
                    ::syntax::TypePtr {
                        star_token: self.star_token.clone(),
                        const_token: self.const_token.clone(),
                        mutability: self.mutability.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeReference {
                fn clone(&self) -> Self {
                    ::syntax::TypeReference {
                        and_token: self.and_token.clone(),
                        lifetime: self.lifetime.clone(),
                        mutability: self.mutability.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeSlice {
                fn clone(&self) -> Self {
                    ::syntax::TypeSlice {
                        bracket_token: self.bracket_token.clone(),
                        elem: self.elem.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeTraitObject {
                fn clone(&self) -> Self {
                    ::syntax::TypeTraitObject {
                        dyn_token: self.dyn_token.clone(),
                        bounds: self.bounds.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::TypeTuple {
                fn clone(&self) -> Self {
                    ::syntax::TypeTuple {
                        paren_token: self.paren_token.clone(),
                        elems: self.elems.clone(),
                    }
                }
            }
             
            impl Copy for ::syntax::UnOp {}
             
            impl Clone for ::syntax::UnOp {
                fn clone(&self) -> Self {
                    *self
                }
            }
             
            impl Clone for ::syntax::UseGlob {
                fn clone(&self) -> Self {
                    ::syntax::UseGlob {
                        star_token: self.star_token.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UseGroup {
                fn clone(&self) -> Self {
                    ::syntax::UseGroup {
                        brace_token: self.brace_token.clone(),
                        items: self.items.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UseName {
                fn clone(&self) -> Self {
                    ::syntax::UseName {
                        ident: self.ident.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UsePath {
                fn clone(&self) -> Self {
                    ::syntax::UsePath {
                        ident: self.ident.clone(),
                        colon2_token: self.colon2_token.clone(),
                        tree: self.tree.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UseRename {
                fn clone(&self) -> Self {
                    ::syntax::UseRename {
                        ident: self.ident.clone(),
                        as_token: self.as_token.clone(),
                        rename: self.rename.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::UseTree {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::UseTree::Path(v0) => ::syntax::UseTree::Path(v0.clone()),
                        ::syntax::UseTree::Name(v0) => ::syntax::UseTree::Name(v0.clone()),
                        ::syntax::UseTree::Rename(v0) => ::syntax::UseTree::Rename(v0.clone()),
                        ::syntax::UseTree::Glob(v0) => ::syntax::UseTree::Glob(v0.clone()),
                        ::syntax::UseTree::Group(v0) => ::syntax::UseTree::Group(v0.clone()),
                    }
                }
            }
             
            impl Clone for ::syntax::Variadic {
                fn clone(&self) -> Self {
                    ::syntax::Variadic {
                        attrs: self.attrs.clone(),
                        pat: self.pat.clone(),
                        dots: self.dots.clone(),
                        comma: self.comma.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Variant {
                fn clone(&self) -> Self {
                    ::syntax::Variant {
                        attrs: self.attrs.clone(),
                        ident: self.ident.clone(),
                        fields: self.fields.clone(),
                        discriminant: self.discriminant.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::VisRestricted {
                fn clone(&self) -> Self {
                    ::syntax::VisRestricted {
                        pub_token: self.pub_token.clone(),
                        paren_token: self.paren_token.clone(),
                        in_token: self.in_token.clone(),
                        path: self.path.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::Visibility {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::Visibility::Public(v0) => ::syntax::Visibility::Public(v0.clone()),
                        ::syntax::Visibility::Restricted(v0) => {
                            ::syntax::Visibility::Restricted(v0.clone())
                        }
                        ::syntax::Visibility::Inherited => ::syntax::Visibility::Inherited,
                    }
                }
            }
             
            impl Clone for ::syntax::WhereClause {
                fn clone(&self) -> Self {
                    ::syntax::WhereClause {
                        where_token: self.where_token.clone(),
                        predicates: self.predicates.clone(),
                    }
                }
            }
             
            impl Clone for ::syntax::WherePredicate {
                fn clone(&self) -> Self {
                    match self {
                        ::syntax::WherePredicate::Lifetime(v0) => {
                            ::syntax::WherePredicate::Lifetime(v0.clone())
                        }
                        ::syntax::WherePredicate::Type(v0) => ::syntax::WherePredicate::Type(v0.clone()),
                    }
                }
            }
        }

        pub mod debug
        {
            use ::
            {
                fmt::{self, Debug},
                *,
            };
            /*
            #![allow(unknown_lints, non_local_definitions)]
            */
            impl Debug for ::syntax::Abi {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Abi");
                    formatter.field("extern_token", &self.extern_token);
                    formatter.field("name", &self.name);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::AngleBracketedGenericArguments {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "AngleBracketedGenericArguments")
                }
            }
            impl ::syntax::AngleBracketedGenericArguments {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("colon2_token", &self.colon2_token);
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("args", &self.args);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::Arm {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Arm");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("pat", &self.pat);
                    formatter.field("guard", &self.guard);
                    formatter.field("fat_arrow_token", &self.fat_arrow_token);
                    formatter.field("body", &self.body);
                    formatter.field("comma", &self.comma);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::AssocConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("AssocConst");
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("value", &self.value);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::AssocType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("AssocType");
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::AttrStyle {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("AttrStyle::")?;
                    match self {
                        ::syntax::AttrStyle::Outer => formatter.write_str("Outer"),
                        ::syntax::AttrStyle::Inner(v0) => {
                            let mut formatter = formatter.debug_tuple("Inner");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::Attribute {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Attribute");
                    formatter.field("pound_token", &self.pound_token);
                    formatter.field("style", &self.style);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("meta", &self.meta);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::BareFnArg {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("BareFnArg");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("name", &self.name);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::BareVariadic {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("BareVariadic");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("name", &self.name);
                    formatter.field("dots", &self.dots);
                    formatter.field("comma", &self.comma);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::BinOp {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("BinOp::")?;
                    match self {
                        ::syntax::BinOp::Add(v0) => {
                            let mut formatter = formatter.debug_tuple("Add");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Sub(v0) => {
                            let mut formatter = formatter.debug_tuple("Sub");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Mul(v0) => {
                            let mut formatter = formatter.debug_tuple("Mul");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Div(v0) => {
                            let mut formatter = formatter.debug_tuple("Div");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Rem(v0) => {
                            let mut formatter = formatter.debug_tuple("Rem");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::And(v0) => {
                            let mut formatter = formatter.debug_tuple("And");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Or(v0) => {
                            let mut formatter = formatter.debug_tuple("Or");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitXor(v0) => {
                            let mut formatter = formatter.debug_tuple("BitXor");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitAnd(v0) => {
                            let mut formatter = formatter.debug_tuple("BitAnd");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitOr(v0) => {
                            let mut formatter = formatter.debug_tuple("BitOr");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Shl(v0) => {
                            let mut formatter = formatter.debug_tuple("Shl");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Shr(v0) => {
                            let mut formatter = formatter.debug_tuple("Shr");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Eq(v0) => {
                            let mut formatter = formatter.debug_tuple("Eq");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Lt(v0) => {
                            let mut formatter = formatter.debug_tuple("Lt");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Le(v0) => {
                            let mut formatter = formatter.debug_tuple("Le");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Ne(v0) => {
                            let mut formatter = formatter.debug_tuple("Ne");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Ge(v0) => {
                            let mut formatter = formatter.debug_tuple("Ge");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::Gt(v0) => {
                            let mut formatter = formatter.debug_tuple("Gt");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::AddAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("AddAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::SubAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("SubAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::MulAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("MulAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::DivAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("DivAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::RemAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("RemAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitXorAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("BitXorAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitAndAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("BitAndAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::BitOrAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("BitOrAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::ShlAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("ShlAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::BinOp::ShrAssign(v0) => {
                            let mut formatter = formatter.debug_tuple("ShrAssign");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Block {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Block");
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("stmts", &self.stmts);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::BoundLifetimes {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("BoundLifetimes");
                    formatter.field("for_token", &self.for_token);
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::CapturedParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("CapturedParam::")?;
                    match self {
                        ::syntax::CapturedParam::Lifetime(v0) => {
                            let mut formatter = formatter.debug_tuple("Lifetime");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::CapturedParam::Ident(v0) => {
                            let mut formatter = formatter.debug_tuple("Ident");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::ConstParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("ConstParam");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("default", &self.default);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Constraint {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Constraint");
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            
            impl  Debug for ::syntax::Data {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Data::")?;
                    match self {
                        ::syntax::Data::Struct(v0) => v0.debug(formatter, "Struct"),
                        ::syntax::Data::Enum(v0) => v0.debug(formatter, "Enum"),
                        ::syntax::Data::Union(v0) => v0.debug(formatter, "Union"),
                    }
                }
            }
            
            impl  Debug for ::syntax::DataEnum {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "DataEnum")
                }
            }
            
            impl ::syntax::DataEnum {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("enum_token", &self.enum_token);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("variants", &self.variants);
                    formatter.finish()
                }
            }
            
            impl  Debug for ::syntax::DataStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "DataStruct")
                }
            }
            
            impl ::syntax::DataStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("struct_token", &self.struct_token);
                    formatter.field("fields", &self.fields);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
            
            impl  Debug for ::syntax::DataUnion {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "DataUnion")
                }
            }
            
            impl ::syntax::DataUnion {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("union_token", &self.union_token);
                    formatter.field("fields", &self.fields);
                    formatter.finish()
                }
            }
            
            impl  Debug for ::syntax::DeriveInput {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("DeriveInput");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("data", &self.data);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Expr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Expr::")?;
                    match self {
                                        ::syntax::Expr::Array(v0) => v0.debug(formatter, "Array"),
                                        ::syntax::Expr::Assign(v0) => v0.debug(formatter, "Assign"),
                                        ::syntax::Expr::Async(v0) => v0.debug(formatter, "Async"),
                                        ::syntax::Expr::Await(v0) => v0.debug(formatter, "Await"),
                        ::syntax::Expr::Binary(v0) => v0.debug(formatter, "Binary"),
                                        ::syntax::Expr::Block(v0) => v0.debug(formatter, "Block"),
                                        ::syntax::Expr::Break(v0) => v0.debug(formatter, "Break"),
                        ::syntax::Expr::Call(v0) => v0.debug(formatter, "Call"),
                        ::syntax::Expr::Cast(v0) => v0.debug(formatter, "Cast"),
                                        ::syntax::Expr::Closure(v0) => v0.debug(formatter, "Closure"),
                                        ::syntax::Expr::Const(v0) => v0.debug(formatter, "Const"),
                                        ::syntax::Expr::Continue(v0) => v0.debug(formatter, "Continue"),
                        ::syntax::Expr::Field(v0) => v0.debug(formatter, "Field"),
                                        ::syntax::Expr::ForLoop(v0) => v0.debug(formatter, "ForLoop"),
                        ::syntax::Expr::Group(v0) => v0.debug(formatter, "Group"),
                                        ::syntax::Expr::If(v0) => v0.debug(formatter, "If"),
                        ::syntax::Expr::Index(v0) => v0.debug(formatter, "Index"),
                                        ::syntax::Expr::Infer(v0) => v0.debug(formatter, "Infer"),
                                        ::syntax::Expr::Let(v0) => v0.debug(formatter, "Let"),
                        ::syntax::Expr::Lit(v0) => v0.debug(formatter, "Lit"),
                                        ::syntax::Expr::Loop(v0) => v0.debug(formatter, "Loop"),
                        ::syntax::Expr::Macro(v0) => v0.debug(formatter, "Macro"),
                                        ::syntax::Expr::Match(v0) => v0.debug(formatter, "Match"),
                        ::syntax::Expr::MethodCall(v0) => v0.debug(formatter, "MethodCall"),
                        ::syntax::Expr::Paren(v0) => v0.debug(formatter, "Paren"),
                        ::syntax::Expr::Path(v0) => v0.debug(formatter, "Path"),
                                        ::syntax::Expr::Range(v0) => v0.debug(formatter, "Range"),
                                        ::syntax::Expr::RawAddr(v0) => v0.debug(formatter, "RawAddr"),
                        ::syntax::Expr::Reference(v0) => v0.debug(formatter, "Reference"),
                                        ::syntax::Expr::Repeat(v0) => v0.debug(formatter, "Repeat"),
                                        ::syntax::Expr::Return(v0) => v0.debug(formatter, "Return"),
                        ::syntax::Expr::Struct(v0) => v0.debug(formatter, "Struct"),
                                        ::syntax::Expr::Try(v0) => v0.debug(formatter, "Try"),
                                        ::syntax::Expr::TryBlock(v0) => v0.debug(formatter, "TryBlock"),
                        ::syntax::Expr::Tuple(v0) => v0.debug(formatter, "Tuple"),
                        ::syntax::Expr::Unary(v0) => v0.debug(formatter, "Unary"),
                                        ::syntax::Expr::Unsafe(v0) => v0.debug(formatter, "Unsafe"),
                        ::syntax::Expr::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        
                        ::syntax::Expr::While(v0) => v0.debug(formatter, "While"),
                        ::syntax::Expr::Yield(v0) => v0.debug(formatter, "Yield"),
                    }
                }
            }
                impl  Debug for ::syntax::ExprArray {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprArray")
                }
            }
                impl ::syntax::ExprArray {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprAssign {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprAssign")
                }
            }
                impl ::syntax::ExprAssign {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("left", &self.left);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("right", &self.right);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprAsync {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprAsync")
                }
            }
                impl ::syntax::ExprAsync {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("async_token", &self.async_token);
                    formatter.field("capture", &self.capture);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprAwait {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprAwait")
                }
            }
                impl ::syntax::ExprAwait {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("base", &self.base);
                    formatter.field("dot_token", &self.dot_token);
                    formatter.field("await_token", &self.await_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprBinary {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprBinary")
                }
            }
            impl ::syntax::ExprBinary {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("left", &self.left);
                    formatter.field("op", &self.op);
                    formatter.field("right", &self.right);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprBlock {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprBlock")
                }
            }
                impl ::syntax::ExprBlock {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("label", &self.label);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprBreak {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprBreak")
                }
            }
                impl ::syntax::ExprBreak {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("break_token", &self.break_token);
                    formatter.field("label", &self.label);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprCall {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprCall")
                }
            }
            impl ::syntax::ExprCall {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("func", &self.func);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("args", &self.args);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprCast {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprCast")
                }
            }
            impl ::syntax::ExprCast {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("expr", &self.expr);
                    formatter.field("as_token", &self.as_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprClosure {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprClosure")
                }
            }
                impl ::syntax::ExprClosure {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("constness", &self.constness);
                    formatter.field("movability", &self.movability);
                    formatter.field("asyncness", &self.asyncness);
                    formatter.field("capture", &self.capture);
                    formatter.field("or1_token", &self.or1_token);
                    formatter.field("inputs", &self.inputs);
                    formatter.field("or2_token", &self.or2_token);
                    formatter.field("output", &self.output);
                    formatter.field("body", &self.body);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprConst")
                }
            }
                impl ::syntax::ExprConst {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprContinue {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprContinue")
                }
            }
                impl ::syntax::ExprContinue {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("continue_token", &self.continue_token);
                    formatter.field("label", &self.label);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprField {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprField")
                }
            }
            impl ::syntax::ExprField {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("base", &self.base);
                    formatter.field("dot_token", &self.dot_token);
                    formatter.field("member", &self.member);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprForLoop {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprForLoop")
                }
            }
                impl ::syntax::ExprForLoop {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("label", &self.label);
                    formatter.field("for_token", &self.for_token);
                    formatter.field("pat", &self.pat);
                    formatter.field("in_token", &self.in_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("body", &self.body);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprGroup {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprGroup")
                }
            }
            impl ::syntax::ExprGroup {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("group_token", &self.group_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprIf {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprIf")
                }
            }
                impl ::syntax::ExprIf {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("if_token", &self.if_token);
                    formatter.field("cond", &self.cond);
                    formatter.field("then_branch", &self.then_branch);
                    formatter.field("else_branch", &self.else_branch);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprIndex {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprIndex")
                }
            }
            impl ::syntax::ExprIndex {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("expr", &self.expr);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("index", &self.index);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprInfer {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprInfer")
                }
            }
                impl ::syntax::ExprInfer {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("underscore_token", &self.underscore_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprLet {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprLet")
                }
            }
                impl ::syntax::ExprLet {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("let_token", &self.let_token);
                    formatter.field("pat", &self.pat);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprLit {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprLit")
                }
            }
            impl ::syntax::ExprLit {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("lit", &self.lit);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprLoop {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprLoop")
                }
            }
                impl ::syntax::ExprLoop {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("label", &self.label);
                    formatter.field("loop_token", &self.loop_token);
                    formatter.field("body", &self.body);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprMacro")
                }
            }
            impl ::syntax::ExprMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprMatch {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprMatch")
                }
            }
                impl ::syntax::ExprMatch {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("match_token", &self.match_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("arms", &self.arms);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprMethodCall {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprMethodCall")
                }
            }
            impl ::syntax::ExprMethodCall {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("receiver", &self.receiver);
                    formatter.field("dot_token", &self.dot_token);
                    formatter.field("method", &self.method);
                    formatter.field("turbofish", &self.turbofish);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("args", &self.args);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprParen {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprParen")
                }
            }
            impl ::syntax::ExprParen {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprPath {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprPath")
                }
            }
            impl ::syntax::ExprPath {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprRange {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprRange")
                }
            }
                impl ::syntax::ExprRange {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("start", &self.start);
                    formatter.field("limits", &self.limits);
                    formatter.field("end", &self.end);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprRawAddr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprRawAddr")
                }
            }
                impl ::syntax::ExprRawAddr {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("and_token", &self.and_token);
                    formatter.field("raw", &self.raw);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprReference {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprReference")
                }
            }
            impl ::syntax::ExprReference {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("and_token", &self.and_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprRepeat {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprRepeat")
                }
            }
                impl ::syntax::ExprRepeat {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.field("len", &self.len);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprReturn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprReturn")
                }
            }
                impl ::syntax::ExprReturn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("return_token", &self.return_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprStruct")
                }
            }
            impl ::syntax::ExprStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("fields", &self.fields);
                    formatter.field("dot2_token", &self.dot2_token);
                    formatter.field("rest", &self.rest);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprTry {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprTry")
                }
            }
                impl ::syntax::ExprTry {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("expr", &self.expr);
                    formatter.field("question_token", &self.question_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprTryBlock {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprTryBlock")
                }
            }
                impl ::syntax::ExprTryBlock {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("try_token", &self.try_token);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprTuple {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprTuple")
                }
            }
            impl ::syntax::ExprTuple {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ExprUnary {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprUnary")
                }
            }
            impl ::syntax::ExprUnary {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("op", &self.op);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprUnsafe {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprUnsafe")
                }
            }
                impl ::syntax::ExprUnsafe {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("unsafe_token", &self.unsafe_token);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprWhile {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprWhile")
                }
            }
                impl ::syntax::ExprWhile {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("label", &self.label);
                    formatter.field("while_token", &self.while_token);
                    formatter.field("cond", &self.cond);
                    formatter.field("body", &self.body);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ExprYield {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ExprYield")
                }
            }
                impl ::syntax::ExprYield {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("yield_token", &self.yield_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Field {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Field");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::FieldMutability {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("FieldMutability::")?;
                    match self {
                        ::syntax::FieldMutability::None => formatter.write_str("None"),
                    }
                }
            }
                impl  Debug for ::syntax::FieldPat {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("FieldPat");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("member", &self.member);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("pat", &self.pat);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::FieldValue {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("FieldValue");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("member", &self.member);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("expr", &self.expr);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Fields {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Fields::")?;
                    match self {
                        ::syntax::Fields::Named(v0) => v0.debug(formatter, "Named"),
                        ::syntax::Fields::Unnamed(v0) => v0.debug(formatter, "Unnamed"),
                        ::syntax::Fields::Unit => formatter.write_str("Unit"),
                    }
                }
            }
            impl Debug for ::syntax::FieldsNamed {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "FieldsNamed")
                }
            }
            impl ::syntax::FieldsNamed {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("named", &self.named);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::FieldsUnnamed {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "FieldsUnnamed")
                }
            }
            impl ::syntax::FieldsUnnamed {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("unnamed", &self.unnamed);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::File {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("File");
                    formatter.field("shebang", &self.shebang);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::FnArg {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("FnArg::")?;
                    match self {
                        ::syntax::FnArg::Receiver(v0) => {
                            let mut formatter = formatter.debug_tuple("Receiver");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::FnArg::Typed(v0) => {
                            let mut formatter = formatter.debug_tuple("Typed");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::ForeignItem {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("ForeignItem::")?;
                    match self {
                        ::syntax::ForeignItem::Fn(v0) => v0.debug(formatter, "Fn"),
                        ::syntax::ForeignItem::Static(v0) => v0.debug(formatter, "Static"),
                        ::syntax::ForeignItem::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::ForeignItem::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::ForeignItem::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::ForeignItemFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ForeignItemFn")
                }
            }
                impl ::syntax::ForeignItemFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("sig", &self.sig);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ForeignItemMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ForeignItemMacro")
                }
            }
                impl ::syntax::ForeignItemMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ForeignItemStatic {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ForeignItemStatic")
                }
            }
                impl ::syntax::ForeignItemStatic {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("static_token", &self.static_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ForeignItemType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ForeignItemType")
                }
            }
                impl ::syntax::ForeignItemType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("type_token", &self.type_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::GenericArgument {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("GenericArgument::")?;
                    match self {
                        ::syntax::GenericArgument::Lifetime(v0) => {
                            let mut formatter = formatter.debug_tuple("Lifetime");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::Type(v0) => {
                            let mut formatter = formatter.debug_tuple("Type");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::Const(v0) => {
                            let mut formatter = formatter.debug_tuple("Const");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::AssocType(v0) => {
                            let mut formatter = formatter.debug_tuple("AssocType");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::AssocConst(v0) => {
                            let mut formatter = formatter.debug_tuple("AssocConst");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericArgument::Constraint(v0) => {
                            let mut formatter = formatter.debug_tuple("Constraint");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::GenericParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("GenericParam::")?;
                    match self {
                        ::syntax::GenericParam::Lifetime(v0) => {
                            let mut formatter = formatter.debug_tuple("Lifetime");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericParam::Type(v0) => {
                            let mut formatter = formatter.debug_tuple("Type");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::GenericParam::Const(v0) => {
                            let mut formatter = formatter.debug_tuple("Const");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::Generics {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Generics");
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("params", &self.params);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.field("where_clause", &self.where_clause);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplItem {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("ImplItem::")?;
                    match self {
                        ::syntax::ImplItem::Const(v0) => v0.debug(formatter, "Const"),
                        ::syntax::ImplItem::Fn(v0) => v0.debug(formatter, "Fn"),
                        ::syntax::ImplItem::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::ImplItem::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::ImplItem::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::ImplItemConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ImplItemConst")
                }
            }
                impl ::syntax::ImplItemConst {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("defaultness", &self.defaultness);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplItemFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ImplItemFn")
                }
            }
                impl ::syntax::ImplItemFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("defaultness", &self.defaultness);
                    formatter.field("sig", &self.sig);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplItemMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ImplItemMacro")
                }
            }
                impl ::syntax::ImplItemMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplItemType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ImplItemType")
                }
            }
                impl ::syntax::ImplItemType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("defaultness", &self.defaultness);
                    formatter.field("type_token", &self.type_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ImplRestriction {
                fn fmt(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {
                    match *self {}
                }
            }
            impl Debug for ::syntax::Index {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Index");
                    formatter.field("index", &self.index);
                    formatter.field("span", &self.span);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::Item {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Item::")?;
                    match self {
                        ::syntax::Item::Const(v0) => v0.debug(formatter, "Const"),
                        ::syntax::Item::Enum(v0) => v0.debug(formatter, "Enum"),
                        ::syntax::Item::ExternCrate(v0) => v0.debug(formatter, "ExternCrate"),
                        ::syntax::Item::Fn(v0) => v0.debug(formatter, "Fn"),
                        ::syntax::Item::ForeignMod(v0) => v0.debug(formatter, "ForeignMod"),
                        ::syntax::Item::Impl(v0) => v0.debug(formatter, "Impl"),
                        ::syntax::Item::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::Item::Mod(v0) => v0.debug(formatter, "Mod"),
                        ::syntax::Item::Static(v0) => v0.debug(formatter, "Static"),
                        ::syntax::Item::Struct(v0) => v0.debug(formatter, "Struct"),
                        ::syntax::Item::Trait(v0) => v0.debug(formatter, "Trait"),
                        ::syntax::Item::TraitAlias(v0) => v0.debug(formatter, "TraitAlias"),
                        ::syntax::Item::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::Item::Union(v0) => v0.debug(formatter, "Union"),
                        ::syntax::Item::Use(v0) => v0.debug(formatter, "Use"),
                        ::syntax::Item::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::ItemConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemConst")
                }
            }
                impl ::syntax::ItemConst {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemEnum {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemEnum")
                }
            }
                impl ::syntax::ItemEnum {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("enum_token", &self.enum_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("variants", &self.variants);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemExternCrate {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemExternCrate")
                }
            }
                impl ::syntax::ItemExternCrate {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("extern_token", &self.extern_token);
                    formatter.field("crate_token", &self.crate_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("rename", &self.rename);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemFn")
                }
            }
                impl ::syntax::ItemFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("sig", &self.sig);
                    formatter.field("block", &self.block);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemForeignMod {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemForeignMod")
                }
            }
                impl ::syntax::ItemForeignMod {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("abi", &self.abi);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemImpl {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemImpl")
                }
            }
                impl ::syntax::ItemImpl {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("defaultness", &self.defaultness);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("impl_token", &self.impl_token);
                    formatter.field("generics", &self.generics);
                    formatter.field("trait_", &self.trait_);
                    formatter.field("self_ty", &self.self_ty);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemMacro")
                }
            }
                impl ::syntax::ItemMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("ident", &self.ident);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemMod {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemMod")
                }
            }
                impl ::syntax::ItemMod {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("mod_token", &self.mod_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("content", &self.content);
                    formatter.field("semi", &self.semi);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemStatic {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemStatic")
                }
            }
                impl ::syntax::ItemStatic {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("static_token", &self.static_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemStruct")
                }
            }
                impl ::syntax::ItemStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("struct_token", &self.struct_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("fields", &self.fields);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemTrait {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemTrait")
                }
            }
                impl ::syntax::ItemTrait {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("auto_token", &self.auto_token);
                    formatter.field("restriction", &self.restriction);
                    formatter.field("trait_token", &self.trait_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("supertraits", &self.supertraits);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemTraitAlias {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemTraitAlias")
                }
            }
                impl ::syntax::ItemTraitAlias {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("trait_token", &self.trait_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemType")
                }
            }
                impl ::syntax::ItemType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("type_token", &self.type_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemUnion {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemUnion")
                }
            }
                impl ::syntax::ItemUnion {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("union_token", &self.union_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("fields", &self.fields);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::ItemUse {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ItemUse")
                }
            }
                impl ::syntax::ItemUse {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("vis", &self.vis);
                    formatter.field("use_token", &self.use_token);
                    formatter.field("leading_colon", &self.leading_colon);
                    formatter.field("tree", &self.tree);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::Label {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Label");
                    formatter.field("name", &self.name);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.finish()
                }
            }
            impl  Debug for ::syntax::Lifetime {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "Lifetime")
                }
            }
            impl ::syntax::Lifetime {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("apostrophe", &self.apostrophe);
                    formatter.field("ident", &self.ident);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::LifetimeParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("LifetimeParam");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("lifetime", &self.lifetime);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl  Debug for ::syntax::Lit {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Lit::")?;
                    match self {
                        ::syntax::Lit::Str(v0) => v0.debug(formatter, "Str"),
                        ::syntax::Lit::ByteStr(v0) => v0.debug(formatter, "ByteStr"),
                        ::syntax::Lit::CStr(v0) => v0.debug(formatter, "CStr"),
                        ::syntax::Lit::Byte(v0) => v0.debug(formatter, "Byte"),
                        ::syntax::Lit::Char(v0) => v0.debug(formatter, "Char"),
                        ::syntax::Lit::Int(v0) => v0.debug(formatter, "Int"),
                        ::syntax::Lit::Float(v0) => v0.debug(formatter, "Float"),
                        ::syntax::Lit::Bool(v0) => v0.debug(formatter, "Bool"),
                        ::syntax::Lit::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Local {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "Local")
                }
            }
                impl ::syntax::Local {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("let_token", &self.let_token);
                    formatter.field("pat", &self.pat);
                    formatter.field("init", &self.init);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::LocalInit {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("LocalInit");
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("expr", &self.expr);
                    formatter.field("diverge", &self.diverge);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Macro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Macro");
                    formatter.field("path", &self.path);
                    formatter.field("bang_token", &self.bang_token);
                    formatter.field("delimiter", &self.delimiter);
                    formatter.field("tokens", &self.tokens);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::MacroDelimiter {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("MacroDelimiter::")?;
                    match self {
                        ::syntax::MacroDelimiter::Paren(v0) => {
                            let mut formatter = formatter.debug_tuple("Paren");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::MacroDelimiter::Brace(v0) => {
                            let mut formatter = formatter.debug_tuple("Brace");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::MacroDelimiter::Bracket(v0) => {
                            let mut formatter = formatter.debug_tuple("Bracket");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::Member {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Member::")?;
                    match self {
                        ::syntax::Member::Named(v0) => {
                            let mut formatter = formatter.debug_tuple("Named");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::Member::Unnamed(v0) => {
                            let mut formatter = formatter.debug_tuple("Unnamed");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::Meta {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Meta::")?;
                    match self {
                        ::syntax::Meta::Path(v0) => v0.debug(formatter, "Path"),
                        ::syntax::Meta::List(v0) => v0.debug(formatter, "List"),
                        ::syntax::Meta::NameValue(v0) => v0.debug(formatter, "NameValue"),
                    }
                }
            }
            impl Debug for ::syntax::MetaList {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "MetaList")
                }
            }
            impl ::syntax::MetaList {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("path", &self.path);
                    formatter.field("delimiter", &self.delimiter);
                    formatter.field("tokens", &self.tokens);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::MetaNameValue {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "MetaNameValue")
                }
            }
            impl ::syntax::MetaNameValue {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("path", &self.path);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("value", &self.value);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ParenthesizedGenericArguments {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "ParenthesizedGenericArguments")
                }
            }
            impl ::syntax::ParenthesizedGenericArguments {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("inputs", &self.inputs);
                    formatter.field("output", &self.output);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::Pat {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Pat::")?;
                    match self {
                        ::syntax::Pat::Const(v0) => v0.debug(formatter, "Const"),
                        ::syntax::Pat::Ident(v0) => v0.debug(formatter, "Ident"),
                        ::syntax::Pat::Lit(v0) => v0.debug(formatter, "Lit"),
                        ::syntax::Pat::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::Pat::Or(v0) => v0.debug(formatter, "Or"),
                        ::syntax::Pat::Paren(v0) => v0.debug(formatter, "Paren"),
                        ::syntax::Pat::Path(v0) => v0.debug(formatter, "Path"),
                        ::syntax::Pat::Range(v0) => v0.debug(formatter, "Range"),
                        ::syntax::Pat::Reference(v0) => v0.debug(formatter, "Reference"),
                        ::syntax::Pat::Rest(v0) => v0.debug(formatter, "Rest"),
                        ::syntax::Pat::Slice(v0) => v0.debug(formatter, "Slice"),
                        ::syntax::Pat::Struct(v0) => v0.debug(formatter, "Struct"),
                        ::syntax::Pat::Tuple(v0) => v0.debug(formatter, "Tuple"),
                        ::syntax::Pat::TupleStruct(v0) => v0.debug(formatter, "TupleStruct"),
                        ::syntax::Pat::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::Pat::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::Pat::Wild(v0) => v0.debug(formatter, "Wild"),
                    }
                }
            }
                impl  Debug for ::syntax::PatIdent {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatIdent")
                }
            }
                impl ::syntax::PatIdent {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("by_ref", &self.by_ref);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("ident", &self.ident);
                    formatter.field("subpat", &self.subpat);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatOr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatOr")
                }
            }
                impl ::syntax::PatOr {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("leading_vert", &self.leading_vert);
                    formatter.field("cases", &self.cases);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatParen {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatParen")
                }
            }
                impl ::syntax::PatParen {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("pat", &self.pat);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatReference {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatReference")
                }
            }
                impl ::syntax::PatReference {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("and_token", &self.and_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("pat", &self.pat);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatRest {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatRest")
                }
            }
                impl ::syntax::PatRest {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("dot2_token", &self.dot2_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatSlice {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatSlice")
                }
            }
                impl ::syntax::PatSlice {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatStruct")
                }
            }
                impl ::syntax::PatStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("fields", &self.fields);
                    formatter.field("rest", &self.rest);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatTuple {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatTuple")
                }
            }
                impl ::syntax::PatTuple {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatTupleStruct {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatTupleStruct")
                }
            }
                impl ::syntax::PatTupleStruct {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatType")
                }
            }
                impl ::syntax::PatType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("pat", &self.pat);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PatWild {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "PatWild")
                }
            }
                impl ::syntax::PatWild {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("underscore_token", &self.underscore_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Path {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "Path")
                }
            }
            impl ::syntax::Path {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("leading_colon", &self.leading_colon);
                    formatter.field("segments", &self.segments);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::PathArguments {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("PathArguments::")?;
                    match self {
                        ::syntax::PathArguments::None => formatter.write_str("None"),
                        ::syntax::PathArguments::AngleBracketed(v0) => {
                            v0.debug(formatter, "AngleBracketed")
                        }
                        ::syntax::PathArguments::Parenthesized(v0) => {
                            v0.debug(formatter, "Parenthesized")
                        }
                    }
                }
            }
            impl Debug for ::syntax::PathSegment {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("PathSegment");
                    formatter.field("ident", &self.ident);
                    formatter.field("arguments", &self.arguments);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::PointerMutability {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("PointerMutability::")?;
                    match self {
                        ::syntax::PointerMutability::Const(v0) => {
                            let mut formatter = formatter.debug_tuple("Const");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::PointerMutability::Mut(v0) => {
                            let mut formatter = formatter.debug_tuple("Mut");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::PreciseCapture {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("PreciseCapture");
                    formatter.field("use_token", &self.use_token);
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("params", &self.params);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::PredicateLifetime {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("PredicateLifetime");
                    formatter.field("lifetime", &self.lifetime);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::PredicateType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("PredicateType");
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("bounded_ty", &self.bounded_ty);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::QSelf {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("QSelf");
                    formatter.field("lt_token", &self.lt_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("position", &self.position);
                    formatter.field("as_token", &self.as_token);
                    formatter.field("gt_token", &self.gt_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::RangeLimits {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("RangeLimits::")?;
                    match self {
                        ::syntax::RangeLimits::HalfOpen(v0) => {
                            let mut formatter = formatter.debug_tuple("HalfOpen");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::RangeLimits::Closed(v0) => {
                            let mut formatter = formatter.debug_tuple("Closed");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Receiver {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Receiver");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("reference", &self.reference);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("self_token", &self.self_token);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::ReturnType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("ReturnType::")?;
                    match self {
                        ::syntax::ReturnType::Default => formatter.write_str("Default"),
                        ::syntax::ReturnType::Type(v0, v1) => {
                            let mut formatter = formatter.debug_tuple("Type");
                            formatter.field(v0);
                            formatter.field(v1);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Signature {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Signature");
                    formatter.field("constness", &self.constness);
                    formatter.field("asyncness", &self.asyncness);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("abi", &self.abi);
                    formatter.field("fn_token", &self.fn_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("inputs", &self.inputs);
                    formatter.field("variadic", &self.variadic);
                    formatter.field("output", &self.output);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::StaticMutability {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("StaticMutability::")?;
                    match self {
                        ::syntax::StaticMutability::Mut(v0) => {
                            let mut formatter = formatter.debug_tuple("Mut");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::StaticMutability::None => formatter.write_str("None"),
                    }
                }
            }
                impl  Debug for ::syntax::Stmt {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Stmt::")?;
                    match self {
                        ::syntax::Stmt::Local(v0) => v0.debug(formatter, "Local"),
                        ::syntax::Stmt::Item(v0) => {
                            let mut formatter = formatter.debug_tuple("Item");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::Stmt::Expr(v0, v1) => {
                            let mut formatter = formatter.debug_tuple("Expr");
                            formatter.field(v0);
                            formatter.field(v1);
                            formatter.finish()
                        }
                        ::syntax::Stmt::Macro(v0) => v0.debug(formatter, "Macro"),
                    }
                }
            }
                impl  Debug for ::syntax::StmtMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "StmtMacro")
                }
            }
                impl ::syntax::StmtMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TraitBound {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("TraitBound");
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("modifier", &self.modifier);
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("path", &self.path);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TraitBoundModifier {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("TraitBoundModifier::")?;
                    match self {
                        ::syntax::TraitBoundModifier::None => formatter.write_str("None"),
                        ::syntax::TraitBoundModifier::Maybe(v0) => {
                            let mut formatter = formatter.debug_tuple("Maybe");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::TraitItem {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("TraitItem::")?;
                    match self {
                        ::syntax::TraitItem::Const(v0) => v0.debug(formatter, "Const"),
                        ::syntax::TraitItem::Fn(v0) => v0.debug(formatter, "Fn"),
                        ::syntax::TraitItem::Type(v0) => v0.debug(formatter, "Type"),
                        ::syntax::TraitItem::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::TraitItem::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::TraitItemConst {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TraitItemConst")
                }
            }
                impl ::syntax::TraitItemConst {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("ty", &self.ty);
                    formatter.field("default", &self.default);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::TraitItemFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TraitItemFn")
                }
            }
                impl ::syntax::TraitItemFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("sig", &self.sig);
                    formatter.field("default", &self.default);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::TraitItemMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TraitItemMacro")
                }
            }
                impl ::syntax::TraitItemMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("mac", &self.mac);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::TraitItemType {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TraitItemType")
                }
            }
                impl ::syntax::TraitItemType {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("attrs", &self.attrs);
                    formatter.field("type_token", &self.type_token);
                    formatter.field("ident", &self.ident);
                    formatter.field("generics", &self.generics);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.field("default", &self.default);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Type {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Type::")?;
                    match self {
                        ::syntax::Type::Array(v0) => v0.debug(formatter, "Array"),
                        ::syntax::Type::BareFn(v0) => v0.debug(formatter, "BareFn"),
                        ::syntax::Type::Group(v0) => v0.debug(formatter, "Group"),
                        ::syntax::Type::ImplTrait(v0) => v0.debug(formatter, "ImplTrait"),
                        ::syntax::Type::Infer(v0) => v0.debug(formatter, "Infer"),
                        ::syntax::Type::Macro(v0) => v0.debug(formatter, "Macro"),
                        ::syntax::Type::Never(v0) => v0.debug(formatter, "Never"),
                        ::syntax::Type::Paren(v0) => v0.debug(formatter, "Paren"),
                        ::syntax::Type::Path(v0) => v0.debug(formatter, "Path"),
                        ::syntax::Type::Ptr(v0) => v0.debug(formatter, "Ptr"),
                        ::syntax::Type::Reference(v0) => v0.debug(formatter, "Reference"),
                        ::syntax::Type::Slice(v0) => v0.debug(formatter, "Slice"),
                        ::syntax::Type::TraitObject(v0) => v0.debug(formatter, "TraitObject"),
                        ::syntax::Type::Tuple(v0) => v0.debug(formatter, "Tuple"),
                        ::syntax::Type::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::TypeArray {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeArray")
                }
            }
            impl ::syntax::TypeArray {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("elem", &self.elem);
                    formatter.field("semi_token", &self.semi_token);
                    formatter.field("len", &self.len);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeBareFn {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeBareFn")
                }
            }
            impl ::syntax::TypeBareFn {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("lifetimes", &self.lifetimes);
                    formatter.field("unsafety", &self.unsafety);
                    formatter.field("abi", &self.abi);
                    formatter.field("fn_token", &self.fn_token);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("inputs", &self.inputs);
                    formatter.field("variadic", &self.variadic);
                    formatter.field("output", &self.output);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeGroup {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeGroup")
                }
            }
            impl ::syntax::TypeGroup {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("group_token", &self.group_token);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeImplTrait {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeImplTrait")
                }
            }
            impl ::syntax::TypeImplTrait {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("impl_token", &self.impl_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeInfer {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeInfer")
                }
            }
            impl ::syntax::TypeInfer {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("underscore_token", &self.underscore_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeMacro {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeMacro")
                }
            }
            impl ::syntax::TypeMacro {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("mac", &self.mac);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeNever {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeNever")
                }
            }
            impl ::syntax::TypeNever {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("bang_token", &self.bang_token);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeParam {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("TypeParam");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("ident", &self.ident);
                    formatter.field("colon_token", &self.colon_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.field("eq_token", &self.eq_token);
                    formatter.field("default", &self.default);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeParamBound {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("TypeParamBound::")?;
                    match self {
                        ::syntax::TypeParamBound::Trait(v0) => {
                            let mut formatter = formatter.debug_tuple("Trait");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::TypeParamBound::Lifetime(v0) => v0.debug(formatter, "Lifetime"),
                                        ::syntax::TypeParamBound::PreciseCapture(v0) => {
                            let mut formatter = formatter.debug_tuple("PreciseCapture");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::TypeParamBound::Verbatim(v0) => {
                            let mut formatter = formatter.debug_tuple("Verbatim");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
            impl Debug for ::syntax::TypeParen {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeParen")
                }
            }
            impl ::syntax::TypeParen {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypePath {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypePath")
                }
            }
            impl ::syntax::TypePath {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("qself", &self.qself);
                    formatter.field("path", &self.path);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypePtr {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypePtr")
                }
            }
            impl ::syntax::TypePtr {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("star_token", &self.star_token);
                    formatter.field("const_token", &self.const_token);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeReference {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeReference")
                }
            }
            impl ::syntax::TypeReference {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("and_token", &self.and_token);
                    formatter.field("lifetime", &self.lifetime);
                    formatter.field("mutability", &self.mutability);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeSlice {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeSlice")
                }
            }
            impl ::syntax::TypeSlice {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("bracket_token", &self.bracket_token);
                    formatter.field("elem", &self.elem);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeTraitObject {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeTraitObject")
                }
            }
            impl ::syntax::TypeTraitObject {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("dyn_token", &self.dyn_token);
                    formatter.field("bounds", &self.bounds);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::TypeTuple {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "TypeTuple")
                }
            }
            impl ::syntax::TypeTuple {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("elems", &self.elems);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::UnOp {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("UnOp::")?;
                    match self {
                        ::syntax::UnOp::Deref(v0) => {
                            let mut formatter = formatter.debug_tuple("Deref");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UnOp::Not(v0) => {
                            let mut formatter = formatter.debug_tuple("Not");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UnOp::Neg(v0) => {
                            let mut formatter = formatter.debug_tuple("Neg");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::UseGlob {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UseGlob");
                    formatter.field("star_token", &self.star_token);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UseGroup {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UseGroup");
                    formatter.field("brace_token", &self.brace_token);
                    formatter.field("items", &self.items);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UseName {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UseName");
                    formatter.field("ident", &self.ident);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UsePath {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UsePath");
                    formatter.field("ident", &self.ident);
                    formatter.field("colon2_token", &self.colon2_token);
                    formatter.field("tree", &self.tree);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UseRename {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("UseRename");
                    formatter.field("ident", &self.ident);
                    formatter.field("as_token", &self.as_token);
                    formatter.field("rename", &self.rename);
                    formatter.finish()
                }
            }
                impl  Debug for ::syntax::UseTree {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("UseTree::")?;
                    match self {
                        ::syntax::UseTree::Path(v0) => {
                            let mut formatter = formatter.debug_tuple("Path");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UseTree::Name(v0) => {
                            let mut formatter = formatter.debug_tuple("Name");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UseTree::Rename(v0) => {
                            let mut formatter = formatter.debug_tuple("Rename");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UseTree::Glob(v0) => {
                            let mut formatter = formatter.debug_tuple("Glob");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::UseTree::Group(v0) => {
                            let mut formatter = formatter.debug_tuple("Group");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
                impl  Debug for ::syntax::Variadic {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Variadic");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("pat", &self.pat);
                    formatter.field("dots", &self.dots);
                    formatter.field("comma", &self.comma);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Variant {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("Variant");
                    formatter.field("attrs", &self.attrs);
                    formatter.field("ident", &self.ident);
                    formatter.field("fields", &self.fields);
                    formatter.field("discriminant", &self.discriminant);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::VisRestricted {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    self.debug(formatter, "VisRestricted")
                }
            }
            impl ::syntax::VisRestricted {
                fn debug(&self, formatter: &mut fmt::Formatter, name: &str) -> fmt::Result {
                    let mut formatter = formatter.debug_struct(name);
                    formatter.field("pub_token", &self.pub_token);
                    formatter.field("paren_token", &self.paren_token);
                    formatter.field("in_token", &self.in_token);
                    formatter.field("path", &self.path);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::Visibility {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("Visibility::")?;
                    match self {
                        ::syntax::Visibility::Public(v0) => {
                            let mut formatter = formatter.debug_tuple("Public");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::Visibility::Restricted(v0) => v0.debug(formatter, "Restricted"),
                        ::syntax::Visibility::Inherited => formatter.write_str("Inherited"),
                    }
                }
            }
            impl Debug for ::syntax::WhereClause {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    let mut formatter = formatter.debug_struct("WhereClause");
                    formatter.field("where_token", &self.where_token);
                    formatter.field("predicates", &self.predicates);
                    formatter.finish()
                }
            }
            impl Debug for ::syntax::WherePredicate {
                fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                    formatter.write_str("WherePredicate::")?;
                    match self {
                        ::syntax::WherePredicate::Lifetime(v0) => {
                            let mut formatter = formatter.debug_tuple("Lifetime");
                            formatter.field(v0);
                            formatter.finish()
                        }
                        ::syntax::WherePredicate::Type(v0) => {
                            let mut formatter = formatter.debug_tuple("Type");
                            formatter.field(v0);
                            formatter.finish()
                        }
                    }
                }
            }
        }

        pub mod eq
        {
            use ::
            {
                syntax::tt::TokenStreamHelper,
                *,
            };
            /*
            */
            impl Eq for ::syntax::Abi {}
            impl PartialEq for ::syntax::Abi {
                fn eq(&self, other: &Self) -> bool
        {
                    self.name == other.name
                }
            }
            impl Eq for ::syntax::AngleBracketedGenericArguments {}
            impl PartialEq for ::syntax::AngleBracketedGenericArguments {
                fn eq(&self, other: &Self) -> bool
        {
                    self.colon2_token == other.colon2_token && self.args == other.args
                }
            }
                impl  Eq for ::syntax::Arm {}
                impl  PartialEq for ::syntax::Arm {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.guard == other.guard
                        && self.body == other.body && self.comma == other.comma
                }
            }
            impl Eq for ::syntax::AssocConst {}
            impl PartialEq for ::syntax::AssocConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.generics == other.generics
                        && self.value == other.value
                }
            }
            impl Eq for ::syntax::AssocType {}
            impl PartialEq for ::syntax::AssocType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.generics == other.generics
                        && self.ty == other.ty
                }
            }
            impl Eq for ::syntax::AttrStyle {}
            impl PartialEq for ::syntax::AttrStyle {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::AttrStyle::Outer, ::syntax::AttrStyle::Outer) => true,
                        (::syntax::AttrStyle::Inner(_), ::syntax::AttrStyle::Inner(_)) => true,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::Attribute {}
            impl PartialEq for ::syntax::Attribute {
                fn eq(&self, other: &Self) -> bool
        {
                    self.style == other.style && self.meta == other.meta
                }
            }
            impl Eq for ::syntax::BareFnArg {}
            impl PartialEq for ::syntax::BareFnArg {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.name == other.name && self.ty == other.ty
                }
            }
            impl Eq for ::syntax::BareVariadic {}
            impl PartialEq for ::syntax::BareVariadic {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.name == other.name && self.comma == other.comma
                }
            }
            impl Eq for ::syntax::BinOp {}
            impl PartialEq for ::syntax::BinOp {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::BinOp::Add(_), ::syntax::BinOp::Add(_)) => true,
                        (::syntax::BinOp::Sub(_), ::syntax::BinOp::Sub(_)) => true,
                        (::syntax::BinOp::Mul(_), ::syntax::BinOp::Mul(_)) => true,
                        (::syntax::BinOp::Div(_), ::syntax::BinOp::Div(_)) => true,
                        (::syntax::BinOp::Rem(_), ::syntax::BinOp::Rem(_)) => true,
                        (::syntax::BinOp::And(_), ::syntax::BinOp::And(_)) => true,
                        (::syntax::BinOp::Or(_), ::syntax::BinOp::Or(_)) => true,
                        (::syntax::BinOp::BitXor(_), ::syntax::BinOp::BitXor(_)) => true,
                        (::syntax::BinOp::BitAnd(_), ::syntax::BinOp::BitAnd(_)) => true,
                        (::syntax::BinOp::BitOr(_), ::syntax::BinOp::BitOr(_)) => true,
                        (::syntax::BinOp::Shl(_), ::syntax::BinOp::Shl(_)) => true,
                        (::syntax::BinOp::Shr(_), ::syntax::BinOp::Shr(_)) => true,
                        (::syntax::BinOp::Eq(_), ::syntax::BinOp::Eq(_)) => true,
                        (::syntax::BinOp::Lt(_), ::syntax::BinOp::Lt(_)) => true,
                        (::syntax::BinOp::Le(_), ::syntax::BinOp::Le(_)) => true,
                        (::syntax::BinOp::Ne(_), ::syntax::BinOp::Ne(_)) => true,
                        (::syntax::BinOp::Ge(_), ::syntax::BinOp::Ge(_)) => true,
                        (::syntax::BinOp::Gt(_), ::syntax::BinOp::Gt(_)) => true,
                        (::syntax::BinOp::AddAssign(_), ::syntax::BinOp::AddAssign(_)) => true,
                        (::syntax::BinOp::SubAssign(_), ::syntax::BinOp::SubAssign(_)) => true,
                        (::syntax::BinOp::MulAssign(_), ::syntax::BinOp::MulAssign(_)) => true,
                        (::syntax::BinOp::DivAssign(_), ::syntax::BinOp::DivAssign(_)) => true,
                        (::syntax::BinOp::RemAssign(_), ::syntax::BinOp::RemAssign(_)) => true,
                        (::syntax::BinOp::BitXorAssign(_), ::syntax::BinOp::BitXorAssign(_)) => true,
                        (::syntax::BinOp::BitAndAssign(_), ::syntax::BinOp::BitAndAssign(_)) => true,
                        (::syntax::BinOp::BitOrAssign(_), ::syntax::BinOp::BitOrAssign(_)) => true,
                        (::syntax::BinOp::ShlAssign(_), ::syntax::BinOp::ShlAssign(_)) => true,
                        (::syntax::BinOp::ShrAssign(_), ::syntax::BinOp::ShrAssign(_)) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Block {}
                impl  PartialEq for ::syntax::Block {
                fn eq(&self, other: &Self) -> bool
        {
                    self.stmts == other.stmts
                }
            }
            impl Eq for ::syntax::BoundLifetimes {}
            impl PartialEq for ::syntax::BoundLifetimes {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetimes == other.lifetimes
                }
            }
                impl  Eq for ::syntax::CapturedParam {}
                impl  PartialEq for ::syntax::CapturedParam {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::CapturedParam::Lifetime(self0),
                            ::syntax::CapturedParam::Lifetime(other0),
                        ) => self0 == other0,
                        (::syntax::CapturedParam::Ident(self0), ::syntax::CapturedParam::Ident(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::ConstParam {}
            impl PartialEq for ::syntax::ConstParam {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident && self.ty == other.ty
                        && self.eq_token == other.eq_token && self.default == other.default
                }
            }
            impl Eq for ::syntax::Constraint {}
            impl PartialEq for ::syntax::Constraint {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.generics == other.generics
                        && self.bounds == other.bounds
                }
            }
            
            impl  Eq for ::syntax::Data {}
            
            impl  PartialEq for ::syntax::Data {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Data::Struct(self0), ::syntax::Data::Struct(other0)) => self0 == other0,
                        (::syntax::Data::Enum(self0), ::syntax::Data::Enum(other0)) => self0 == other0,
                        (::syntax::Data::Union(self0), ::syntax::Data::Union(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
            
            impl  Eq for ::syntax::DataEnum {}
            
            impl  PartialEq for ::syntax::DataEnum {
                fn eq(&self, other: &Self) -> bool
        {
                    self.variants == other.variants
                }
            }
            
            impl  Eq for ::syntax::DataStruct {}
            
            impl  PartialEq for ::syntax::DataStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.fields == other.fields && self.semi_token == other.semi_token
                }
            }
            
            impl  Eq for ::syntax::DataUnion {}
            
            impl  PartialEq for ::syntax::DataUnion {
                fn eq(&self, other: &Self) -> bool
        {
                    self.fields == other.fields
                }
            }
            
            impl  Eq for ::syntax::DeriveInput {}
            
            impl  PartialEq for ::syntax::DeriveInput {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.data == other.data
                }
            }
            impl Eq for ::syntax::Expr {}
            impl PartialEq for ::syntax::Expr {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                                        (::syntax::Expr::Array(self0), ::syntax::Expr::Array(other0)) => self0 == other0,
                                        (::syntax::Expr::Assign(self0), ::syntax::Expr::Assign(other0)) => self0 == other0,
                                        (::syntax::Expr::Async(self0), ::syntax::Expr::Async(other0)) => self0 == other0,
                                        (::syntax::Expr::Await(self0), ::syntax::Expr::Await(other0)) => self0 == other0,
                        (::syntax::Expr::Binary(self0), ::syntax::Expr::Binary(other0)) => self0 == other0,
                                        (::syntax::Expr::Block(self0), ::syntax::Expr::Block(other0)) => self0 == other0,
                                        (::syntax::Expr::Break(self0), ::syntax::Expr::Break(other0)) => self0 == other0,
                        (::syntax::Expr::Call(self0), ::syntax::Expr::Call(other0)) => self0 == other0,
                        (::syntax::Expr::Cast(self0), ::syntax::Expr::Cast(other0)) => self0 == other0,
                                        (::syntax::Expr::Closure(self0), ::syntax::Expr::Closure(other0)) => {
                            self0 == other0
                        }
                                        (::syntax::Expr::Const(self0), ::syntax::Expr::Const(other0)) => self0 == other0,
                                        (::syntax::Expr::Continue(self0), ::syntax::Expr::Continue(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Field(self0), ::syntax::Expr::Field(other0)) => self0 == other0,
                                        (::syntax::Expr::ForLoop(self0), ::syntax::Expr::ForLoop(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Group(self0), ::syntax::Expr::Group(other0)) => self0 == other0,
                                        (::syntax::Expr::If(self0), ::syntax::Expr::If(other0)) => self0 == other0,
                        (::syntax::Expr::Index(self0), ::syntax::Expr::Index(other0)) => self0 == other0,
                                        (::syntax::Expr::Infer(self0), ::syntax::Expr::Infer(other0)) => self0 == other0,
                                        (::syntax::Expr::Let(self0), ::syntax::Expr::Let(other0)) => self0 == other0,
                        (::syntax::Expr::Lit(self0), ::syntax::Expr::Lit(other0)) => self0 == other0,
                                        (::syntax::Expr::Loop(self0), ::syntax::Expr::Loop(other0)) => self0 == other0,
                        (::syntax::Expr::Macro(self0), ::syntax::Expr::Macro(other0)) => self0 == other0,
                                        (::syntax::Expr::Match(self0), ::syntax::Expr::Match(other0)) => self0 == other0,
                        (::syntax::Expr::MethodCall(self0), ::syntax::Expr::MethodCall(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Paren(self0), ::syntax::Expr::Paren(other0)) => self0 == other0,
                        (::syntax::Expr::Path(self0), ::syntax::Expr::Path(other0)) => self0 == other0,
                                        (::syntax::Expr::Range(self0), ::syntax::Expr::Range(other0)) => self0 == other0,
                                        (::syntax::Expr::RawAddr(self0), ::syntax::Expr::RawAddr(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Reference(self0), ::syntax::Expr::Reference(other0)) => {
                            self0 == other0
                        }
                                        (::syntax::Expr::Repeat(self0), ::syntax::Expr::Repeat(other0)) => self0 == other0,
                                        (::syntax::Expr::Return(self0), ::syntax::Expr::Return(other0)) => self0 == other0,
                        (::syntax::Expr::Struct(self0), ::syntax::Expr::Struct(other0)) => self0 == other0,
                                        (::syntax::Expr::Try(self0), ::syntax::Expr::Try(other0)) => self0 == other0,
                                        (::syntax::Expr::TryBlock(self0), ::syntax::Expr::TryBlock(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Expr::Tuple(self0), ::syntax::Expr::Tuple(other0)) => self0 == other0,
                        (::syntax::Expr::Unary(self0), ::syntax::Expr::Unary(other0)) => self0 == other0,
                                        (::syntax::Expr::Unsafe(self0), ::syntax::Expr::Unsafe(other0)) => self0 == other0,
                        (::syntax::Expr::Verbatim(self0), ::syntax::Expr::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                                        (::syntax::Expr::While(self0), ::syntax::Expr::While(other0)) => self0 == other0,
                                        (::syntax::Expr::Yield(self0), ::syntax::Expr::Yield(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ExprArray {}
                impl  PartialEq for ::syntax::ExprArray {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.elems == other.elems
                }
            }
                impl  Eq for ::syntax::ExprAssign {}
                impl  PartialEq for ::syntax::ExprAssign {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.left == other.left && self.right == other.right
                }
            }
                impl  Eq for ::syntax::ExprAsync {}
                impl  PartialEq for ::syntax::ExprAsync {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.capture == other.capture
                        && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ExprAwait {}
                impl  PartialEq for ::syntax::ExprAwait {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.base == other.base
                }
            }
            impl Eq for ::syntax::ExprBinary {}
            impl PartialEq for ::syntax::ExprBinary {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.left == other.left && self.op == other.op
                        && self.right == other.right
                }
            }
                impl  Eq for ::syntax::ExprBlock {}
                impl  PartialEq for ::syntax::ExprBlock {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label
                        && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ExprBreak {}
                impl  PartialEq for ::syntax::ExprBreak {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprCall {}
            impl PartialEq for ::syntax::ExprCall {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.func == other.func && self.args == other.args
                }
            }
            impl Eq for ::syntax::ExprCast {}
            impl PartialEq for ::syntax::ExprCast {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::ExprClosure {}
                impl  PartialEq for ::syntax::ExprClosure {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.lifetimes == other.lifetimes
                        && self.constness == other.constness && self.movability == other.movability
                        && self.asyncness == other.asyncness && self.capture == other.capture
                        && self.inputs == other.inputs && self.output == other.output
                        && self.body == other.body
                }
            }
                impl  Eq for ::syntax::ExprConst {}
                impl  PartialEq for ::syntax::ExprConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ExprContinue {}
                impl  PartialEq for ::syntax::ExprContinue {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label
                }
            }
            impl Eq for ::syntax::ExprField {}
            impl PartialEq for ::syntax::ExprField {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.base == other.base
                        && self.member == other.member
                }
            }
                impl  Eq for ::syntax::ExprForLoop {}
                impl  PartialEq for ::syntax::ExprForLoop {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label && self.pat == other.pat
                        && self.expr == other.expr && self.body == other.body
                }
            }
            impl Eq for ::syntax::ExprGroup {}
            impl PartialEq for ::syntax::ExprGroup {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ExprIf {}
                impl  PartialEq for ::syntax::ExprIf {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.cond == other.cond
                        && self.then_branch == other.then_branch
                        && self.else_branch == other.else_branch
                }
            }
            impl Eq for ::syntax::ExprIndex {}
            impl PartialEq for ::syntax::ExprIndex {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr && self.index == other.index
                }
            }
                impl  Eq for ::syntax::ExprInfer {}
                impl  PartialEq for ::syntax::ExprInfer {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs
                }
            }
                impl  Eq for ::syntax::ExprLet {}
                impl  PartialEq for ::syntax::ExprLet {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprLit {}
            impl PartialEq for ::syntax::ExprLit {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.lit == other.lit
                }
            }
                impl  Eq for ::syntax::ExprLoop {}
                impl  PartialEq for ::syntax::ExprLoop {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label && self.body == other.body
                }
            }
            impl Eq for ::syntax::ExprMacro {}
            impl PartialEq for ::syntax::ExprMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                }
            }
                impl  Eq for ::syntax::ExprMatch {}
                impl  PartialEq for ::syntax::ExprMatch {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr && self.arms == other.arms
                }
            }
            impl Eq for ::syntax::ExprMethodCall {}
            impl PartialEq for ::syntax::ExprMethodCall {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.receiver == other.receiver
                        && self.method == other.method && self.turbofish == other.turbofish
                        && self.args == other.args
                }
            }
            impl Eq for ::syntax::ExprParen {}
            impl PartialEq for ::syntax::ExprParen {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprPath {}
            impl PartialEq for ::syntax::ExprPath {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.qself == other.qself && self.path == other.path
                }
            }
                impl  Eq for ::syntax::ExprRange {}
                impl  PartialEq for ::syntax::ExprRange {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.start == other.start
                        && self.limits == other.limits && self.end == other.end
                }
            }
                impl  Eq for ::syntax::ExprRawAddr {}
                impl  PartialEq for ::syntax::ExprRawAddr {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mutability == other.mutability
                        && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprReference {}
            impl PartialEq for ::syntax::ExprReference {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mutability == other.mutability
                        && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ExprRepeat {}
                impl  PartialEq for ::syntax::ExprRepeat {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr && self.len == other.len
                }
            }
                impl  Eq for ::syntax::ExprReturn {}
                impl  PartialEq for ::syntax::ExprReturn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::ExprStruct {}
            impl PartialEq for ::syntax::ExprStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.qself == other.qself && self.path == other.path
                        && self.fields == other.fields && self.dot2_token == other.dot2_token
                        && self.rest == other.rest
                }
            }
                impl  Eq for ::syntax::ExprTry {}
                impl  PartialEq for ::syntax::ExprTry {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ExprTryBlock {}
                impl  PartialEq for ::syntax::ExprTryBlock {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.block == other.block
                }
            }
            impl Eq for ::syntax::ExprTuple {}
            impl PartialEq for ::syntax::ExprTuple {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.elems == other.elems
                }
            }
            impl Eq for ::syntax::ExprUnary {}
            impl PartialEq for ::syntax::ExprUnary {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.op == other.op && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ExprUnsafe {}
                impl  PartialEq for ::syntax::ExprUnsafe {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ExprWhile {}
                impl  PartialEq for ::syntax::ExprWhile {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.label == other.label && self.cond == other.cond
                        && self.body == other.body
                }
            }
                impl  Eq for ::syntax::ExprYield {}
                impl  PartialEq for ::syntax::ExprYield {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::Field {}
            impl PartialEq for ::syntax::Field {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.mutability == other.mutability && self.ident == other.ident
                        && self.colon_token == other.colon_token && self.ty == other.ty
                }
            }
            impl Eq for ::syntax::FieldMutability {}
            impl PartialEq for ::syntax::FieldMutability {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::FieldMutability::None, ::syntax::FieldMutability::None) => true,
                    }
                }
            }
                impl  Eq for ::syntax::FieldPat {}
                impl  PartialEq for ::syntax::FieldPat {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.member == other.member
                        && self.colon_token == other.colon_token && self.pat == other.pat
                }
            }
            impl Eq for ::syntax::FieldValue {}
            impl PartialEq for ::syntax::FieldValue {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.member == other.member
                        && self.colon_token == other.colon_token && self.expr == other.expr
                }
            }
            impl Eq for ::syntax::Fields {}
            impl PartialEq for ::syntax::Fields {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Fields::Named(self0), ::syntax::Fields::Named(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Fields::Unnamed(self0), ::syntax::Fields::Unnamed(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Fields::Unit, ::syntax::Fields::Unit) => true,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::FieldsNamed {}
            impl PartialEq for ::syntax::FieldsNamed {
                fn eq(&self, other: &Self) -> bool
        {
                    self.named == other.named
                }
            }
            impl Eq for ::syntax::FieldsUnnamed {}
            impl PartialEq for ::syntax::FieldsUnnamed {
                fn eq(&self, other: &Self) -> bool
        {
                    self.unnamed == other.unnamed
                }
            }
                impl  Eq for ::syntax::File {}
                impl  PartialEq for ::syntax::File {
                fn eq(&self, other: &Self) -> bool
        {
                    self.shebang == other.shebang && self.attrs == other.attrs
                        && self.items == other.items
                }
            }
                impl  Eq for ::syntax::FnArg {}
                impl  PartialEq for ::syntax::FnArg {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::FnArg::Receiver(self0), ::syntax::FnArg::Receiver(other0)) => {
                            self0 == other0
                        }
                        (::syntax::FnArg::Typed(self0), ::syntax::FnArg::Typed(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ForeignItem {}
                impl  PartialEq for ::syntax::ForeignItem {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::ForeignItem::Fn(self0), ::syntax::ForeignItem::Fn(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ForeignItem::Static(self0), ::syntax::ForeignItem::Static(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ForeignItem::Type(self0), ::syntax::ForeignItem::Type(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ForeignItem::Macro(self0), ::syntax::ForeignItem::Macro(other0)) => {
                            self0 == other0
                        }
                        (
                            ::syntax::ForeignItem::Verbatim(self0),
                            ::syntax::ForeignItem::Verbatim(other0),
                        ) => TokenStreamHelper(self0) == TokenStreamHelper(other0),
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ForeignItemFn {}
                impl  PartialEq for ::syntax::ForeignItemFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.sig == other.sig
                }
            }
                impl  Eq for ::syntax::ForeignItemMacro {}
                impl  PartialEq for ::syntax::ForeignItemMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::ForeignItemStatic {}
                impl  PartialEq for ::syntax::ForeignItemStatic {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.mutability == other.mutability && self.ident == other.ident
                        && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::ForeignItemType {}
                impl  PartialEq for ::syntax::ForeignItemType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics
                }
            }
            impl Eq for ::syntax::GenericArgument {}
            impl PartialEq for ::syntax::GenericArgument {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::GenericArgument::Lifetime(self0),
                            ::syntax::GenericArgument::Lifetime(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::Type(self0),
                            ::syntax::GenericArgument::Type(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::Const(self0),
                            ::syntax::GenericArgument::Const(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::AssocType(self0),
                            ::syntax::GenericArgument::AssocType(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::AssocConst(self0),
                            ::syntax::GenericArgument::AssocConst(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::GenericArgument::Constraint(self0),
                            ::syntax::GenericArgument::Constraint(other0),
                        ) => self0 == other0,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::GenericParam {}
            impl PartialEq for ::syntax::GenericParam {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::GenericParam::Lifetime(self0),
                            ::syntax::GenericParam::Lifetime(other0),
                        ) => self0 == other0,
                        (::syntax::GenericParam::Type(self0), ::syntax::GenericParam::Type(other0)) => {
                            self0 == other0
                        }
                        (::syntax::GenericParam::Const(self0), ::syntax::GenericParam::Const(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::Generics {}
            impl PartialEq for ::syntax::Generics {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lt_token == other.lt_token && self.params == other.params
                        && self.gt_token == other.gt_token && self.where_clause == other.where_clause
                }
            }
                impl  Eq for ::syntax::ImplItem {}
                impl  PartialEq for ::syntax::ImplItem {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::ImplItem::Const(self0), ::syntax::ImplItem::Const(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ImplItem::Fn(self0), ::syntax::ImplItem::Fn(other0)) => self0 == other0,
                        (::syntax::ImplItem::Type(self0), ::syntax::ImplItem::Type(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ImplItem::Macro(self0), ::syntax::ImplItem::Macro(other0)) => {
                            self0 == other0
                        }
                        (::syntax::ImplItem::Verbatim(self0), ::syntax::ImplItem::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ImplItemConst {}
                impl  PartialEq for ::syntax::ImplItemConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.defaultness == other.defaultness && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                        && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ImplItemFn {}
                impl  PartialEq for ::syntax::ImplItemFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.defaultness == other.defaultness && self.sig == other.sig
                        && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ImplItemMacro {}
                impl  PartialEq for ::syntax::ImplItemMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::ImplItemType {}
                impl  PartialEq for ::syntax::ImplItemType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.defaultness == other.defaultness && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::ImplRestriction {}
                impl  PartialEq for ::syntax::ImplRestriction {
                fn eq(&self, _other: &Self) -> bool
        {
                    match *self {}
                }
            }
                impl  Eq for ::syntax::Item {}
                impl  PartialEq for ::syntax::Item {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Item::Const(self0), ::syntax::Item::Const(other0)) => self0 == other0,
                        (::syntax::Item::Enum(self0), ::syntax::Item::Enum(other0)) => self0 == other0,
                        (::syntax::Item::ExternCrate(self0), ::syntax::Item::ExternCrate(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Item::Fn(self0), ::syntax::Item::Fn(other0)) => self0 == other0,
                        (::syntax::Item::ForeignMod(self0), ::syntax::Item::ForeignMod(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Item::Impl(self0), ::syntax::Item::Impl(other0)) => self0 == other0,
                        (::syntax::Item::Macro(self0), ::syntax::Item::Macro(other0)) => self0 == other0,
                        (::syntax::Item::Mod(self0), ::syntax::Item::Mod(other0)) => self0 == other0,
                        (::syntax::Item::Static(self0), ::syntax::Item::Static(other0)) => self0 == other0,
                        (::syntax::Item::Struct(self0), ::syntax::Item::Struct(other0)) => self0 == other0,
                        (::syntax::Item::Trait(self0), ::syntax::Item::Trait(other0)) => self0 == other0,
                        (::syntax::Item::TraitAlias(self0), ::syntax::Item::TraitAlias(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Item::Type(self0), ::syntax::Item::Type(other0)) => self0 == other0,
                        (::syntax::Item::Union(self0), ::syntax::Item::Union(other0)) => self0 == other0,
                        (::syntax::Item::Use(self0), ::syntax::Item::Use(other0)) => self0 == other0,
                        (::syntax::Item::Verbatim(self0), ::syntax::Item::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::ItemConst {}
                impl  PartialEq for ::syntax::ItemConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                        && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ItemEnum {}
                impl  PartialEq for ::syntax::ItemEnum {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.variants == other.variants
                }
            }
                impl  Eq for ::syntax::ItemExternCrate {}
                impl  PartialEq for ::syntax::ItemExternCrate {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.rename == other.rename
                }
            }
                impl  Eq for ::syntax::ItemFn {}
                impl  PartialEq for ::syntax::ItemFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.sig == other.sig
                        && self.block == other.block
                }
            }
                impl  Eq for ::syntax::ItemForeignMod {}
                impl  PartialEq for ::syntax::ItemForeignMod {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.unsafety == other.unsafety
                        && self.abi == other.abi && self.items == other.items
                }
            }
                impl  Eq for ::syntax::ItemImpl {}
                impl  PartialEq for ::syntax::ItemImpl {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.defaultness == other.defaultness
                        && self.unsafety == other.unsafety && self.generics == other.generics
                        && self.trait_ == other.trait_ && self.self_ty == other.self_ty
                        && self.items == other.items
                }
            }
                impl  Eq for ::syntax::ItemMacro {}
                impl  PartialEq for ::syntax::ItemMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::ItemMod {}
                impl  PartialEq for ::syntax::ItemMod {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.unsafety == other.unsafety && self.ident == other.ident
                        && self.content == other.content && self.semi == other.semi
                }
            }
                impl  Eq for ::syntax::ItemStatic {}
                impl  PartialEq for ::syntax::ItemStatic {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.mutability == other.mutability && self.ident == other.ident
                        && self.ty == other.ty && self.expr == other.expr
                }
            }
                impl  Eq for ::syntax::ItemStruct {}
                impl  PartialEq for ::syntax::ItemStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.fields == other.fields
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::ItemTrait {}
                impl  PartialEq for ::syntax::ItemTrait {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.unsafety == other.unsafety && self.auto_token == other.auto_token
                        && self.restriction == other.restriction && self.ident == other.ident
                        && self.generics == other.generics && self.colon_token == other.colon_token
                        && self.supertraits == other.supertraits && self.items == other.items
                }
            }
                impl  Eq for ::syntax::ItemTraitAlias {}
                impl  PartialEq for ::syntax::ItemTraitAlias {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.bounds == other.bounds
                }
            }
                impl  Eq for ::syntax::ItemType {}
                impl  PartialEq for ::syntax::ItemType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::ItemUnion {}
                impl  PartialEq for ::syntax::ItemUnion {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis && self.ident == other.ident
                        && self.generics == other.generics && self.fields == other.fields
                }
            }
                impl  Eq for ::syntax::ItemUse {}
                impl  PartialEq for ::syntax::ItemUse {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.vis == other.vis
                        && self.leading_colon == other.leading_colon && self.tree == other.tree
                }
            }
                impl  Eq for ::syntax::Label {}
                impl  PartialEq for ::syntax::Label {
                fn eq(&self, other: &Self) -> bool
        {
                    self.name == other.name
                }
            }
            impl Eq for ::syntax::LifetimeParam {}
            impl PartialEq for ::syntax::LifetimeParam {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.lifetime == other.lifetime
                        && self.colon_token == other.colon_token && self.bounds == other.bounds
                }
            }
            impl  Eq for ::syntax::Lit {}
            impl  PartialEq for ::syntax::Lit {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Lit::Str(self0), ::syntax::Lit::Str(other0)) => self0 == other0,
                        (::syntax::Lit::ByteStr(self0), ::syntax::Lit::ByteStr(other0)) => self0 == other0,
                        (::syntax::Lit::CStr(self0), ::syntax::Lit::CStr(other0)) => self0 == other0,
                        (::syntax::Lit::Byte(self0), ::syntax::Lit::Byte(other0)) => self0 == other0,
                        (::syntax::Lit::Char(self0), ::syntax::Lit::Char(other0)) => self0 == other0,
                        (::syntax::Lit::Int(self0), ::syntax::Lit::Int(other0)) => self0 == other0,
                        (::syntax::Lit::Float(self0), ::syntax::Lit::Float(other0)) => self0 == other0,
                        (::syntax::Lit::Bool(self0), ::syntax::Lit::Bool(other0)) => self0 == other0,
                        (::syntax::Lit::Verbatim(self0), ::syntax::Lit::Verbatim(other0)) => {
                            self0.to_string() == other0.to_string()
                        }
                        _ => false,
                    }
                }
            }
            impl  Eq for ::syntax::LitBool {}
            impl  PartialEq for ::syntax::LitBool {
                fn eq(&self, other: &Self) -> bool
        {
                    self.value == other.value
                }
            }
            impl  Eq for ::syntax::LitByte {}
            impl  Eq for ::syntax::LitByteStr {}
            impl  Eq for ::syntax::LitCStr {}
            impl  Eq for ::syntax::LitChar {}
            impl  Eq for ::syntax::LitFloat {}
            impl  Eq for ::syntax::LitInt {}
            impl  Eq for ::syntax::LitStr {}
                impl  Eq for ::syntax::Local {}
                impl  PartialEq for ::syntax::Local {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.init == other.init
                }
            }
                impl  Eq for ::syntax::LocalInit {}
                impl  PartialEq for ::syntax::LocalInit {
                fn eq(&self, other: &Self) -> bool
        {
                    self.expr == other.expr && self.diverge == other.diverge
                }
            }
            impl Eq for ::syntax::Macro {}
            impl PartialEq for ::syntax::Macro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.path == other.path && self.delimiter == other.delimiter
                        && TokenStreamHelper(&self.tokens) == TokenStreamHelper(&other.tokens)
                }
            }
            impl Eq for ::syntax::MacroDelimiter {}
            impl PartialEq for ::syntax::MacroDelimiter {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::MacroDelimiter::Paren(_), ::syntax::MacroDelimiter::Paren(_)) => true,
                        (::syntax::MacroDelimiter::Brace(_), ::syntax::MacroDelimiter::Brace(_)) => true,
                        (::syntax::MacroDelimiter::Bracket(_), ::syntax::MacroDelimiter::Bracket(_)) => {
                            true
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::Meta {}
            impl PartialEq for ::syntax::Meta {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Meta::Path(self0), ::syntax::Meta::Path(other0)) => self0 == other0,
                        (::syntax::Meta::List(self0), ::syntax::Meta::List(other0)) => self0 == other0,
                        (::syntax::Meta::NameValue(self0), ::syntax::Meta::NameValue(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::MetaList {}
            impl PartialEq for ::syntax::MetaList {
                fn eq(&self, other: &Self) -> bool
        {
                    self.path == other.path && self.delimiter == other.delimiter
                        && TokenStreamHelper(&self.tokens) == TokenStreamHelper(&other.tokens)
                }
            }
            impl Eq for ::syntax::MetaNameValue {}
            impl PartialEq for ::syntax::MetaNameValue {
                fn eq(&self, other: &Self) -> bool
        {
                    self.path == other.path && self.value == other.value
                }
            }
            impl Eq for ::syntax::ParenthesizedGenericArguments {}
            impl PartialEq for ::syntax::ParenthesizedGenericArguments {
                fn eq(&self, other: &Self) -> bool
        {
                    self.inputs == other.inputs && self.output == other.output
                }
            }
                impl  Eq for ::syntax::Pat {}
                impl  PartialEq for ::syntax::Pat {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Pat::Const(self0), ::syntax::Pat::Const(other0)) => self0 == other0,
                        (::syntax::Pat::Ident(self0), ::syntax::Pat::Ident(other0)) => self0 == other0,
                        (::syntax::Pat::Lit(self0), ::syntax::Pat::Lit(other0)) => self0 == other0,
                        (::syntax::Pat::Macro(self0), ::syntax::Pat::Macro(other0)) => self0 == other0,
                        (::syntax::Pat::Or(self0), ::syntax::Pat::Or(other0)) => self0 == other0,
                        (::syntax::Pat::Paren(self0), ::syntax::Pat::Paren(other0)) => self0 == other0,
                        (::syntax::Pat::Path(self0), ::syntax::Pat::Path(other0)) => self0 == other0,
                        (::syntax::Pat::Range(self0), ::syntax::Pat::Range(other0)) => self0 == other0,
                        (::syntax::Pat::Reference(self0), ::syntax::Pat::Reference(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Pat::Rest(self0), ::syntax::Pat::Rest(other0)) => self0 == other0,
                        (::syntax::Pat::Slice(self0), ::syntax::Pat::Slice(other0)) => self0 == other0,
                        (::syntax::Pat::Struct(self0), ::syntax::Pat::Struct(other0)) => self0 == other0,
                        (::syntax::Pat::Tuple(self0), ::syntax::Pat::Tuple(other0)) => self0 == other0,
                        (::syntax::Pat::TupleStruct(self0), ::syntax::Pat::TupleStruct(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Pat::Type(self0), ::syntax::Pat::Type(other0)) => self0 == other0,
                        (::syntax::Pat::Verbatim(self0), ::syntax::Pat::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        (::syntax::Pat::Wild(self0), ::syntax::Pat::Wild(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::PatIdent {}
                impl  PartialEq for ::syntax::PatIdent {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.by_ref == other.by_ref
                        && self.mutability == other.mutability && self.ident == other.ident
                        && self.subpat == other.subpat
                }
            }
                impl  Eq for ::syntax::PatOr {}
                impl  PartialEq for ::syntax::PatOr {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.leading_vert == other.leading_vert
                        && self.cases == other.cases
                }
            }
                impl  Eq for ::syntax::PatParen {}
                impl  PartialEq for ::syntax::PatParen {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat
                }
            }
                impl  Eq for ::syntax::PatReference {}
                impl  PartialEq for ::syntax::PatReference {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mutability == other.mutability
                        && self.pat == other.pat
                }
            }
                impl  Eq for ::syntax::PatRest {}
                impl  PartialEq for ::syntax::PatRest {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs
                }
            }
                impl  Eq for ::syntax::PatSlice {}
                impl  PartialEq for ::syntax::PatSlice {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.elems == other.elems
                }
            }
                impl  Eq for ::syntax::PatStruct {}
                impl  PartialEq for ::syntax::PatStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.qself == other.qself && self.path == other.path
                        && self.fields == other.fields && self.rest == other.rest
                }
            }
                impl  Eq for ::syntax::PatTuple {}
                impl  PartialEq for ::syntax::PatTuple {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.elems == other.elems
                }
            }
                impl  Eq for ::syntax::PatTupleStruct {}
                impl  PartialEq for ::syntax::PatTupleStruct {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.qself == other.qself && self.path == other.path
                        && self.elems == other.elems
                }
            }
                impl  Eq for ::syntax::PatType {}
                impl  PartialEq for ::syntax::PatType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.ty == other.ty
                }
            }
                impl  Eq for ::syntax::PatWild {}
                impl  PartialEq for ::syntax::PatWild {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs
                }
            }
            impl Eq for ::syntax::Path {}
            impl PartialEq for ::syntax::Path {
                fn eq(&self, other: &Self) -> bool
        {
                    self.leading_colon == other.leading_colon && self.segments == other.segments
                }
            }
            impl Eq for ::syntax::PathArguments {}
            impl PartialEq for ::syntax::PathArguments {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::PathArguments::None, ::syntax::PathArguments::None) => true,
                        (
                            ::syntax::PathArguments::AngleBracketed(self0),
                            ::syntax::PathArguments::AngleBracketed(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::PathArguments::Parenthesized(self0),
                            ::syntax::PathArguments::Parenthesized(other0),
                        ) => self0 == other0,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::PathSegment {}
            impl PartialEq for ::syntax::PathSegment {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.arguments == other.arguments
                }
            }
                impl  Eq for ::syntax::PointerMutability {}
                impl  PartialEq for ::syntax::PointerMutability {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::PointerMutability::Const(_), ::syntax::PointerMutability::Const(_)) => {
                            true
                        }
                        (::syntax::PointerMutability::Mut(_), ::syntax::PointerMutability::Mut(_)) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::PreciseCapture {}
                impl  PartialEq for ::syntax::PreciseCapture {
                fn eq(&self, other: &Self) -> bool
        {
                    self.params == other.params
                }
            }
            impl Eq for ::syntax::PredicateLifetime {}
            impl PartialEq for ::syntax::PredicateLifetime {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetime == other.lifetime && self.bounds == other.bounds
                }
            }
            impl Eq for ::syntax::PredicateType {}
            impl PartialEq for ::syntax::PredicateType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetimes == other.lifetimes && self.bounded_ty == other.bounded_ty
                        && self.bounds == other.bounds
                }
            }
            impl Eq for ::syntax::QSelf {}
            impl PartialEq for ::syntax::QSelf {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ty == other.ty && self.position == other.position
                        && self.as_token == other.as_token
                }
            }
                impl  Eq for ::syntax::RangeLimits {}
                impl  PartialEq for ::syntax::RangeLimits {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::RangeLimits::HalfOpen(_), ::syntax::RangeLimits::HalfOpen(_)) => true,
                        (::syntax::RangeLimits::Closed(_), ::syntax::RangeLimits::Closed(_)) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Receiver {}
                impl  PartialEq for ::syntax::Receiver {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.reference == other.reference
                        && self.mutability == other.mutability
                        && self.colon_token == other.colon_token && self.ty == other.ty
                }
            }
            impl Eq for ::syntax::ReturnType {}
            impl PartialEq for ::syntax::ReturnType {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::ReturnType::Default, ::syntax::ReturnType::Default) => true,
                        (::syntax::ReturnType::Type(_, self1), ::syntax::ReturnType::Type(_, other1)) => {
                            self1 == other1
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Signature {}
                impl  PartialEq for ::syntax::Signature {
                fn eq(&self, other: &Self) -> bool
        {
                    self.constness == other.constness && self.asyncness == other.asyncness
                        && self.unsafety == other.unsafety && self.abi == other.abi
                        && self.ident == other.ident && self.generics == other.generics
                        && self.inputs == other.inputs && self.variadic == other.variadic
                        && self.output == other.output
                }
            }
                impl  Eq for ::syntax::StaticMutability {}
                impl  PartialEq for ::syntax::StaticMutability {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::StaticMutability::Mut(_), ::syntax::StaticMutability::Mut(_)) => true,
                        (::syntax::StaticMutability::None, ::syntax::StaticMutability::None) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Stmt {}
                impl  PartialEq for ::syntax::Stmt {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Stmt::Local(self0), ::syntax::Stmt::Local(other0)) => self0 == other0,
                        (::syntax::Stmt::Item(self0), ::syntax::Stmt::Item(other0)) => self0 == other0,
                        (::syntax::Stmt::Expr(self0, self1), ::syntax::Stmt::Expr(other0, other1)) => {
                            self0 == other0 && self1 == other1
                        }
                        (::syntax::Stmt::Macro(self0), ::syntax::Stmt::Macro(other0)) => self0 == other0,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::StmtMacro {}
                impl  PartialEq for ::syntax::StmtMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
            impl Eq for ::syntax::TraitBound {}
            impl PartialEq for ::syntax::TraitBound {
                fn eq(&self, other: &Self) -> bool
        {
                    self.paren_token == other.paren_token && self.modifier == other.modifier
                        && self.lifetimes == other.lifetimes && self.path == other.path
                }
            }
            impl Eq for ::syntax::TraitBoundModifier {}
            impl PartialEq for ::syntax::TraitBoundModifier {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::TraitBoundModifier::None, ::syntax::TraitBoundModifier::None) => true,
                        (
                            ::syntax::TraitBoundModifier::Maybe(_),
                            ::syntax::TraitBoundModifier::Maybe(_),
                        ) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::TraitItem {}
                impl  PartialEq for ::syntax::TraitItem {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::TraitItem::Const(self0), ::syntax::TraitItem::Const(other0)) => {
                            self0 == other0
                        }
                        (::syntax::TraitItem::Fn(self0), ::syntax::TraitItem::Fn(other0)) => {
                            self0 == other0
                        }
                        (::syntax::TraitItem::Type(self0), ::syntax::TraitItem::Type(other0)) => {
                            self0 == other0
                        }
                        (::syntax::TraitItem::Macro(self0), ::syntax::TraitItem::Macro(other0)) => {
                            self0 == other0
                        }
                        (::syntax::TraitItem::Verbatim(self0), ::syntax::TraitItem::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::TraitItemConst {}
                impl  PartialEq for ::syntax::TraitItemConst {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident
                        && self.generics == other.generics && self.ty == other.ty
                        && self.default == other.default
                }
            }
                impl  Eq for ::syntax::TraitItemFn {}
                impl  PartialEq for ::syntax::TraitItemFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.sig == other.sig
                        && self.default == other.default && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::TraitItemMacro {}
                impl  PartialEq for ::syntax::TraitItemMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.mac == other.mac
                        && self.semi_token == other.semi_token
                }
            }
                impl  Eq for ::syntax::TraitItemType {}
                impl  PartialEq for ::syntax::TraitItemType {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident
                        && self.generics == other.generics && self.colon_token == other.colon_token
                        && self.bounds == other.bounds && self.default == other.default
                }
            }
            impl Eq for ::syntax::Type {}
            impl PartialEq for ::syntax::Type {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Type::Array(self0), ::syntax::Type::Array(other0)) => self0 == other0,
                        (::syntax::Type::BareFn(self0), ::syntax::Type::BareFn(other0)) => self0 == other0,
                        (::syntax::Type::Group(self0), ::syntax::Type::Group(other0)) => self0 == other0,
                        (::syntax::Type::ImplTrait(self0), ::syntax::Type::ImplTrait(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Type::Infer(self0), ::syntax::Type::Infer(other0)) => self0 == other0,
                        (::syntax::Type::Macro(self0), ::syntax::Type::Macro(other0)) => self0 == other0,
                        (::syntax::Type::Never(self0), ::syntax::Type::Never(other0)) => self0 == other0,
                        (::syntax::Type::Paren(self0), ::syntax::Type::Paren(other0)) => self0 == other0,
                        (::syntax::Type::Path(self0), ::syntax::Type::Path(other0)) => self0 == other0,
                        (::syntax::Type::Ptr(self0), ::syntax::Type::Ptr(other0)) => self0 == other0,
                        (::syntax::Type::Reference(self0), ::syntax::Type::Reference(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Type::Slice(self0), ::syntax::Type::Slice(other0)) => self0 == other0,
                        (::syntax::Type::TraitObject(self0), ::syntax::Type::TraitObject(other0)) => {
                            self0 == other0
                        }
                        (::syntax::Type::Tuple(self0), ::syntax::Type::Tuple(other0)) => self0 == other0,
                        (::syntax::Type::Verbatim(self0), ::syntax::Type::Verbatim(other0)) => {
                            TokenStreamHelper(self0) == TokenStreamHelper(other0)
                        }
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::TypeArray {}
            impl PartialEq for ::syntax::TypeArray {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elem == other.elem && self.len == other.len
                }
            }
            impl Eq for ::syntax::TypeBareFn {}
            impl PartialEq for ::syntax::TypeBareFn {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetimes == other.lifetimes && self.unsafety == other.unsafety
                        && self.abi == other.abi && self.inputs == other.inputs
                        && self.variadic == other.variadic && self.output == other.output
                }
            }
            impl Eq for ::syntax::TypeGroup {}
            impl PartialEq for ::syntax::TypeGroup {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypeImplTrait {}
            impl PartialEq for ::syntax::TypeImplTrait {
                fn eq(&self, other: &Self) -> bool
        {
                    self.bounds == other.bounds
                }
            }
            impl Eq for ::syntax::TypeInfer {}
            impl PartialEq for ::syntax::TypeInfer {
                fn eq(&self, _other: &Self) -> bool
        {
                    true
                }
            }
            impl Eq for ::syntax::TypeMacro {}
            impl PartialEq for ::syntax::TypeMacro {
                fn eq(&self, other: &Self) -> bool
        {
                    self.mac == other.mac
                }
            }
            impl Eq for ::syntax::TypeNever {}
            impl PartialEq for ::syntax::TypeNever {
                fn eq(&self, _other: &Self) -> bool
        {
                    true
                }
            }
            impl Eq for ::syntax::TypeParam {}
            impl PartialEq for ::syntax::TypeParam {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident
                        && self.colon_token == other.colon_token && self.bounds == other.bounds
                        && self.eq_token == other.eq_token && self.default == other.default
                }
            }
            impl Eq for ::syntax::TypeParamBound {}
            impl PartialEq for ::syntax::TypeParamBound {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::TypeParamBound::Trait(self0),
                            ::syntax::TypeParamBound::Trait(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::TypeParamBound::Lifetime(self0),
                            ::syntax::TypeParamBound::Lifetime(other0),
                        ) => self0 == other0,
                                        (
                            ::syntax::TypeParamBound::PreciseCapture(self0),
                            ::syntax::TypeParamBound::PreciseCapture(other0),
                        ) => self0 == other0,
                        (
                            ::syntax::TypeParamBound::Verbatim(self0),
                            ::syntax::TypeParamBound::Verbatim(other0),
                        ) => TokenStreamHelper(self0) == TokenStreamHelper(other0),
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::TypeParen {}
            impl PartialEq for ::syntax::TypeParen {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypePath {}
            impl PartialEq for ::syntax::TypePath {
                fn eq(&self, other: &Self) -> bool
        {
                    self.qself == other.qself && self.path == other.path
                }
            }
            impl Eq for ::syntax::TypePtr {}
            impl PartialEq for ::syntax::TypePtr {
                fn eq(&self, other: &Self) -> bool
        {
                    self.const_token == other.const_token && self.mutability == other.mutability
                        && self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypeReference {}
            impl PartialEq for ::syntax::TypeReference {
                fn eq(&self, other: &Self) -> bool
        {
                    self.lifetime == other.lifetime && self.mutability == other.mutability
                        && self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypeSlice {}
            impl PartialEq for ::syntax::TypeSlice {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elem == other.elem
                }
            }
            impl Eq for ::syntax::TypeTraitObject {}
            impl PartialEq for ::syntax::TypeTraitObject {
                fn eq(&self, other: &Self) -> bool
        {
                    self.dyn_token == other.dyn_token && self.bounds == other.bounds
                }
            }
            impl Eq for ::syntax::TypeTuple {}
            impl PartialEq for ::syntax::TypeTuple {
                fn eq(&self, other: &Self) -> bool
        {
                    self.elems == other.elems
                }
            }
            impl Eq for ::syntax::UnOp {}
            impl PartialEq for ::syntax::UnOp {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::UnOp::Deref(_), ::syntax::UnOp::Deref(_)) => true,
                        (::syntax::UnOp::Not(_), ::syntax::UnOp::Not(_)) => true,
                        (::syntax::UnOp::Neg(_), ::syntax::UnOp::Neg(_)) => true,
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::UseGlob {}
                impl  PartialEq for ::syntax::UseGlob {
                fn eq(&self, _other: &Self) -> bool
        {
                    true
                }
            }
                impl  Eq for ::syntax::UseGroup {}
                impl  PartialEq for ::syntax::UseGroup {
                fn eq(&self, other: &Self) -> bool
        {
                    self.items == other.items
                }
            }
                impl  Eq for ::syntax::UseName {}
                impl  PartialEq for ::syntax::UseName {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident
                }
            }
                impl  Eq for ::syntax::UsePath {}
                impl  PartialEq for ::syntax::UsePath {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.tree == other.tree
                }
            }
                impl  Eq for ::syntax::UseRename {}
                impl  PartialEq for ::syntax::UseRename {
                fn eq(&self, other: &Self) -> bool
        {
                    self.ident == other.ident && self.rename == other.rename
                }
            }
                impl  Eq for ::syntax::UseTree {}
                impl  PartialEq for ::syntax::UseTree {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::UseTree::Path(self0), ::syntax::UseTree::Path(other0)) => {
                            self0 == other0
                        }
                        (::syntax::UseTree::Name(self0), ::syntax::UseTree::Name(other0)) => {
                            self0 == other0
                        }
                        (::syntax::UseTree::Rename(self0), ::syntax::UseTree::Rename(other0)) => {
                            self0 == other0
                        }
                        (::syntax::UseTree::Glob(self0), ::syntax::UseTree::Glob(other0)) => {
                            self0 == other0
                        }
                        (::syntax::UseTree::Group(self0), ::syntax::UseTree::Group(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
                impl  Eq for ::syntax::Variadic {}
                impl  PartialEq for ::syntax::Variadic {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.pat == other.pat && self.comma == other.comma
                }
            }
            impl Eq for ::syntax::Variant {}
            impl PartialEq for ::syntax::Variant {
                fn eq(&self, other: &Self) -> bool
        {
                    self.attrs == other.attrs && self.ident == other.ident
                        && self.fields == other.fields && self.discriminant == other.discriminant
                }
            }
            impl Eq for ::syntax::VisRestricted {}
            impl PartialEq for ::syntax::VisRestricted {
                fn eq(&self, other: &Self) -> bool
        {
                    self.in_token == other.in_token && self.path == other.path
                }
            }
            impl Eq for ::syntax::Visibility {}
            impl PartialEq for ::syntax::Visibility {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (::syntax::Visibility::Public(_), ::syntax::Visibility::Public(_)) => true,
                        (
                            ::syntax::Visibility::Restricted(self0),
                            ::syntax::Visibility::Restricted(other0),
                        ) => self0 == other0,
                        (::syntax::Visibility::Inherited, ::syntax::Visibility::Inherited) => true,
                        _ => false,
                    }
                }
            }
            impl Eq for ::syntax::WhereClause {}
            impl PartialEq for ::syntax::WhereClause {
                fn eq(&self, other: &Self) -> bool
        {
                    self.predicates == other.predicates
                }
            }
            impl Eq for ::syntax::WherePredicate {}
            impl PartialEq for ::syntax::WherePredicate {
                fn eq(&self, other: &Self) -> bool
        {
                    match (self, other) {
                        (
                            ::syntax::WherePredicate::Lifetime(self0),
                            ::syntax::WherePredicate::Lifetime(other0),
                        ) => self0 == other0,
                        (::syntax::WherePredicate::Type(self0), ::syntax::WherePredicate::Type(other0)) => {
                            self0 == other0
                        }
                        _ => false,
                    }
                }
            }
        }

        pub mod hash
        {
            use ::
            {
                hash::{ Hash, Hasher },
                syntax::tt::{ TokenStreamHelper },
                *,
            };
            /*
            */
            impl Hash for ::syntax::Abi
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.name.hash(state);
                }
            }
            
            impl Hash for ::syntax::AngleBracketedGenericArguments
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.colon2_token.hash(state);
                    self.args.hash(state);
                }
            }
            
            impl Hash for ::syntax::Arm
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.guard.hash(state);
                    self.body.hash(state);
                    self.comma.hash(state);
                }
            }
            
            impl Hash for ::syntax::AssocConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.value.hash(state);
                }
            }
            
            impl Hash for ::syntax::AssocType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::AttrStyle
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::AttrStyle::Outer => {
                            state.write_u8(0u8);
                        }
                        ::syntax::AttrStyle::Inner(_) =>
                        {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Attribute
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.style.hash(state);
                    self.meta.hash(state);
                }
            }
            
            impl Hash for ::syntax::BareFnArg
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.name.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::BareVariadic
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.name.hash(state);
                    self.comma.hash(state);
                }
            }
            
            impl Hash for ::syntax::BinOp
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::BinOp::Add(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::BinOp::Sub(_) =>
                        {
                            state.write_u8(1u8);
                        }
                        ::syntax::BinOp::Mul(_) =>
                        {
                            state.write_u8(2u8);
                        }
                        ::syntax::BinOp::Div(_) =>
                        {
                            state.write_u8(3u8);
                        }
                        ::syntax::BinOp::Rem(_) =>
                        {
                            state.write_u8(4u8);
                        }
                        ::syntax::BinOp::And(_) =>
                        {
                            state.write_u8(5u8);
                        }
                        ::syntax::BinOp::Or(_) =>
                        {
                            state.write_u8(6u8);
                        }
                        ::syntax::BinOp::BitXor(_) =>
                        {
                            state.write_u8(7u8);
                        }
                        ::syntax::BinOp::BitAnd(_) =>
                        {
                            state.write_u8(8u8);
                        }
                        ::syntax::BinOp::BitOr(_) =>
                        {
                            state.write_u8(9u8);
                        }
                        ::syntax::BinOp::Shl(_) =>
                        {
                            state.write_u8(10u8);
                        }
                        ::syntax::BinOp::Shr(_) =>
                        {
                            state.write_u8(11u8);
                        }
                        ::syntax::BinOp::Eq(_) =>
                        {
                            state.write_u8(12u8);
                        }
                        ::syntax::BinOp::Lt(_) =>
                        {
                            state.write_u8(13u8);
                        }
                        ::syntax::BinOp::Le(_) =>
                        {
                            state.write_u8(14u8);
                        }
                        ::syntax::BinOp::Ne(_) =>
                        {
                            state.write_u8(15u8);
                        }
                        ::syntax::BinOp::Ge(_) =>
                        {
                            state.write_u8(16u8);
                        }
                        ::syntax::BinOp::Gt(_) =>
                        {
                            state.write_u8(17u8);
                        }
                        ::syntax::BinOp::AddAssign(_) =>
                        {
                            state.write_u8(18u8);
                        }
                        ::syntax::BinOp::SubAssign(_) =>
                        {
                            state.write_u8(19u8);
                        }
                        ::syntax::BinOp::MulAssign(_) =>
                        {
                            state.write_u8(20u8);
                        }
                        ::syntax::BinOp::DivAssign(_) =>
                        {
                            state.write_u8(21u8);
                        }
                        ::syntax::BinOp::RemAssign(_) =>
                        {
                            state.write_u8(22u8);
                        }
                        ::syntax::BinOp::BitXorAssign(_) =>
                        {
                            state.write_u8(23u8);
                        }
                        ::syntax::BinOp::BitAndAssign(_) =>
                        {
                            state.write_u8(24u8);
                        }
                        ::syntax::BinOp::BitOrAssign(_) =>
                        {
                            state.write_u8(25u8);
                        }
                        ::syntax::BinOp::ShlAssign(_) =>
                        {
                            state.write_u8(26u8);
                        }
                        ::syntax::BinOp::ShrAssign(_) =>
                        {
                            state.write_u8(27u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Block
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.stmts.hash(state);
                }
            }
            
            impl Hash for ::syntax::BoundLifetimes
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetimes.hash(state);
                }
            }
            
            impl Hash for ::syntax::CapturedParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::CapturedParam::Lifetime(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::CapturedParam::Ident(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ConstParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.ty.hash(state);
                    self.eq_token.hash(state);
                    self.default.hash(state);
                }
            }
            
            impl Hash for ::syntax::Constraint
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::Data
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Data::Struct(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Data::Enum(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Data::Union(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::DataEnum
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.variants.hash(state);
                }
            }
            
            impl Hash for ::syntax::DataStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.fields.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::DataUnion
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.fields.hash(state);
                }
            }
            
            impl Hash for ::syntax::DeriveInput
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.data.hash(state);
                }
            }
            
            impl Hash for ::syntax::Expr
           
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self
                    {
                        ::syntax::Expr::Array(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Assign(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Async(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Await(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Binary(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Block(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Break(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Call(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }

                        ::syntax::Expr::Cast(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Closure(v0) =>
                        {
                            state.write_u8(9u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Const(v0) =>
                        {
                            state.write_u8(10u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Continue(v0) =>
                        {
                            state.write_u8(11u8);
                            v0.hash(state);
                        }

                        ::syntax::Expr::Field(v0) =>
                        {
                            state.write_u8(12u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::ForLoop(v0) =>
                        {
                            state.write_u8(13u8);
                            v0.hash(state);
                        }

                        ::syntax::Expr::Group(v0) =>
                        {
                            state.write_u8(14u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::If(v0) =>
                        {
                            state.write_u8(15u8);
                            v0.hash(state);
                        }

                        ::syntax::Expr::Index(v0) =>
                        {
                            state.write_u8(16u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Infer(v0) =>
                        {
                            state.write_u8(17u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Let(v0) =>
                        {
                            state.write_u8(18u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Lit(v0) =>
                        {
                            state.write_u8(19u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Loop(v0) =>
                        {
                            state.write_u8(20u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Macro(v0) =>
                        {
                            state.write_u8(21u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Match(v0) =>
                        {
                            state.write_u8(22u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::MethodCall(v0) =>
                        {
                            state.write_u8(23u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Paren(v0) =>
                        {
                            state.write_u8(24u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Path(v0) =>
                        {
                            state.write_u8(25u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Range(v0) =>
                        {
                            state.write_u8(26u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::RawAddr(v0) =>
                        {
                            state.write_u8(27u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Reference(v0) =>
                        {
                            state.write_u8(28u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Repeat(v0) =>
                        {
                            state.write_u8(29u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Return(v0) =>
                        {
                            state.write_u8(30u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Struct(v0) =>
                        {
                            state.write_u8(31u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Try(v0) =>
                        {
                            state.write_u8(32u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::TryBlock(v0) =>
                        {
                            state.write_u8(33u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Tuple(v0) =>
                        {
                            state.write_u8(34u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Unary(v0) =>
                        {
                            state.write_u8(35u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Unsafe(v0) =>
                        {
                            state.write_u8(36u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Verbatim(v0) =>
                        {
                            state.write_u8(37u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                        
                        ::syntax::Expr::While(v0) =>
                        {
                            state.write_u8(38u8);
                            v0.hash(state);
                        }
                        
                        ::syntax::Expr::Yield(v0) =>
                        {
                            state.write_u8(39u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ExprArray
           
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprAssign
           
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.left.hash(state);
                    self.right.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprAsync
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.capture.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprAwait
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.base.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprBinary
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.left.hash(state);
                    self.op.hash(state);
                    self.right.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprBlock
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprBreak
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprCall
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.func.hash(state);
                    self.args.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprCast
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprClosure
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.lifetimes.hash(state);
                    self.constness.hash(state);
                    self.movability.hash(state);
                    self.asyncness.hash(state);
                    self.capture.hash(state);
                    self.inputs.hash(state);
                    self.output.hash(state);
                    self.body.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprContinue
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprField
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.base.hash(state);
                    self.member.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprForLoop
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.pat.hash(state);
                    self.expr.hash(state);
                    self.body.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprGroup
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprIf
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.cond.hash(state);
                    self.then_branch.hash(state);
                    self.else_branch.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprIndex
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                    self.index.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprInfer
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprLet
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprLit
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.lit.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprLoop
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.body.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprMatch
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                    self.arms.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprMethodCall
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.receiver.hash(state);
                    self.method.hash(state);
                    self.turbofish.hash(state);
                    self.args.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprParen
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprPath
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.qself.hash(state);
                    self.path.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprRange
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.start.hash(state);
                    self.limits.hash(state);
                    self.end.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprRawAddr
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mutability.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprReference
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mutability.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprRepeat
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                    self.len.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprReturn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.qself.hash(state);
                    self.path.hash(state);
                    self.fields.hash(state);
                    self.dot2_token.hash(state);
                    self.rest.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprTry
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprTryBlock
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprTuple
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprUnary
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.op.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprUnsafe
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprWhile
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.label.hash(state);
                    self.cond.hash(state);
                    self.body.hash(state);
                }
            }
            
            impl Hash for ::syntax::ExprYield
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::Field
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.mutability.hash(state);
                    self.ident.hash(state);
                    self.colon_token.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::FieldMutability
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::FieldMutability::None => {
                            state.write_u8(0u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::FieldPat
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.member.hash(state);
                    self.colon_token.hash(state);
                    self.pat.hash(state);
                }
            }
            
            impl Hash for ::syntax::FieldValue
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.member.hash(state);
                    self.colon_token.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::Fields
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Fields::Named(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Fields::Unnamed(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Fields::Unit => {
                            state.write_u8(2u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::FieldsNamed
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.named.hash(state);
                }
            }
            
            impl Hash for ::syntax::FieldsUnnamed
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.unnamed.hash(state);
                }
            }
            
            impl Hash for ::syntax::File
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.shebang.hash(state);
                    self.attrs.hash(state);
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::FnArg
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::FnArg::Receiver(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::FnArg::Typed(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ForeignItem
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::ForeignItem::Fn(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::ForeignItem::Static(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::ForeignItem::Type(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::ForeignItem::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::ForeignItem::Verbatim(v0) =>
                        {
                            state.write_u8(4u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ForeignItemFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.sig.hash(state);
                }
            }
            
            impl Hash for ::syntax::ForeignItemMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::ForeignItemStatic
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.mutability.hash(state);
                    self.ident.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ForeignItemType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                }
            }
            
            impl Hash for ::syntax::GenericArgument
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::GenericArgument::Lifetime(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::Type(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::Const(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::AssocType(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::AssocConst(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericArgument::Constraint(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::GenericParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::GenericParam::Lifetime(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericParam::Type(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::GenericParam::Const(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Generics
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lt_token.hash(state);
                    self.params.hash(state);
                    self.gt_token.hash(state);
                    self.where_clause.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplItem
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::ImplItem::Const(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::ImplItem::Fn(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::ImplItem::Type(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::ImplItem::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::ImplItem::Verbatim(v0) =>
                        {
                            state.write_u8(4u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ImplItemConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.defaultness.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplItemFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.defaultness.hash(state);
                    self.sig.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplItemMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplItemType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.defaultness.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ImplRestriction
            {
                fn hash<H>(&self, _state: &mut H) where
                H: Hasher
                {
                    match *self {}
                }
            }
            
            impl Hash for ::syntax::Item
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Item::Const(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Enum(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::ExternCrate(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Fn(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::ForeignMod(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Impl(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Macro(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Mod(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Static(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Struct(v0) =>
                        {
                            state.write_u8(9u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Trait(v0) =>
                        {
                            state.write_u8(10u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::TraitAlias(v0) =>
                        {
                            state.write_u8(11u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Type(v0) =>
                        {
                            state.write_u8(12u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Union(v0) =>
                        {
                            state.write_u8(13u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Use(v0) =>
                        {
                            state.write_u8(14u8);
                            v0.hash(state);
                        }
                        ::syntax::Item::Verbatim(v0) =>
                        {
                            state.write_u8(15u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::ItemConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemEnum
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.variants.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemExternCrate
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.rename.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.sig.hash(state);
                    self.block.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemForeignMod
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.unsafety.hash(state);
                    self.abi.hash(state);
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemImpl
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.defaultness.hash(state);
                    self.unsafety.hash(state);
                    self.generics.hash(state);
                    self.trait_.hash(state);
                    self.self_ty.hash(state);
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemMod
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.unsafety.hash(state);
                    self.ident.hash(state);
                    self.content.hash(state);
                    self.semi.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemStatic
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.mutability.hash(state);
                    self.ident.hash(state);
                    self.ty.hash(state);
                    self.expr.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.fields.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemTrait
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.unsafety.hash(state);
                    self.auto_token.hash(state);
                    self.restriction.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.colon_token.hash(state);
                    self.supertraits.hash(state);
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemTraitAlias
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemUnion
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.fields.hash(state);
                }
            }
            
            impl Hash for ::syntax::ItemUse
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.vis.hash(state);
                    self.leading_colon.hash(state);
                    self.tree.hash(state);
                }
            }
            
            impl Hash for ::syntax::Label
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.name.hash(state);
                }
            }
            
            impl Hash for ::syntax::LifetimeParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.lifetime.hash(state);
                    self.colon_token.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::Lit
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Lit::Str(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::ByteStr(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::CStr(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Byte(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Char(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Int(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Float(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Bool(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }
                        ::syntax::Lit::Verbatim(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.to_string().hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::LitBool
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.value.hash(state);
                }
            }
            
            impl Hash for ::syntax::Local
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.init.hash(state);
                }
            }
            
            impl Hash for ::syntax::LocalInit
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.expr.hash(state);
                    self.diverge.hash(state);
                }
            }
            
            impl Hash for ::syntax::Macro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.path.hash(state);
                    self.delimiter.hash(state);
                    TokenStreamHelper(&self.tokens).hash(state);
                }
            }
            
            impl Hash for ::syntax::MacroDelimiter
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::MacroDelimiter::Paren(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::MacroDelimiter::Brace(_) =>
                        {
                            state.write_u8(1u8);
                        }
                        ::syntax::MacroDelimiter::Bracket(_) =>
                        {
                            state.write_u8(2u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Meta
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Meta::Path(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Meta::List(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Meta::NameValue(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::MetaList
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.path.hash(state);
                    self.delimiter.hash(state);
                    TokenStreamHelper(&self.tokens).hash(state);
                }
            }
            
            impl Hash for ::syntax::MetaNameValue
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.path.hash(state);
                    self.value.hash(state);
                }
            }
            
            impl Hash for ::syntax::ParenthesizedGenericArguments
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.inputs.hash(state);
                    self.output.hash(state);
                }
            }
            
            impl Hash for ::syntax::Pat
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Pat::Const(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Ident(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Lit(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Or(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Paren(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Path(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Range(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Reference(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Rest(v0) =>
                        {
                            state.write_u8(9u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Slice(v0) =>
                        {
                            state.write_u8(10u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Struct(v0) =>
                        {
                            state.write_u8(11u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Tuple(v0) =>
                        {
                            state.write_u8(12u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::TupleStruct(v0) =>
                        {
                            state.write_u8(13u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Type(v0) =>
                        {
                            state.write_u8(14u8);
                            v0.hash(state);
                        }
                        ::syntax::Pat::Verbatim(v0) =>
                        {
                            state.write_u8(15u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                        ::syntax::Pat::Wild(v0) =>
                        {
                            state.write_u8(16u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::PatIdent
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.by_ref.hash(state);
                    self.mutability.hash(state);
                    self.ident.hash(state);
                    self.subpat.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatOr
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.leading_vert.hash(state);
                    self.cases.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatParen
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatReference
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mutability.hash(state);
                    self.pat.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatRest
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatSlice
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.qself.hash(state);
                    self.path.hash(state);
                    self.fields.hash(state);
                    self.rest.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatTuple
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatTupleStruct
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.qself.hash(state);
                    self.path.hash(state);
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::PatWild
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                }
            }
            
            impl Hash for ::syntax::Path
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.leading_colon.hash(state);
                    self.segments.hash(state);
                }
            }
            
            impl Hash for ::syntax::PathArguments
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::PathArguments::None => {
                            state.write_u8(0u8);
                        }
                        ::syntax::PathArguments::AngleBracketed(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::PathArguments::Parenthesized(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::PathSegment
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.arguments.hash(state);
                }
            }
            
            impl Hash for ::syntax::PointerMutability
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::PointerMutability::Const(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::PointerMutability::Mut(_) =>
                        {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::PreciseCapture
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.params.hash(state);
                }
            }
            
            impl Hash for ::syntax::PredicateLifetime
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetime.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::PredicateType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetimes.hash(state);
                    self.bounded_ty.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::QSelf
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ty.hash(state);
                    self.position.hash(state);
                    self.as_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::RangeLimits
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::RangeLimits::HalfOpen(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::RangeLimits::Closed(_) =>
                        {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Receiver
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.reference.hash(state);
                    self.mutability.hash(state);
                    self.colon_token.hash(state);
                    self.ty.hash(state);
                }
            }
            
            impl Hash for ::syntax::ReturnType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::ReturnType::Default => {
                            state.write_u8(0u8);
                        }
                        ::syntax::ReturnType::Type(_, v1) =>
                        {
                            state.write_u8(1u8);
                            v1.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Signature
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.constness.hash(state);
                    self.asyncness.hash(state);
                    self.unsafety.hash(state);
                    self.abi.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.inputs.hash(state);
                    self.variadic.hash(state);
                    self.output.hash(state);
                }
            }
            
            impl Hash for ::syntax::StaticMutability
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::StaticMutability::Mut(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::StaticMutability::None => {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Stmt
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Stmt::Local(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Stmt::Item(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Stmt::Expr(v0, v1) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                            v1.hash(state);
                        }
                        ::syntax::Stmt::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::StmtMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitBound
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.paren_token.hash(state);
                    self.modifier.hash(state);
                    self.lifetimes.hash(state);
                    self.path.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitBoundModifier
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::TraitBoundModifier::None => {
                            state.write_u8(0u8);
                        }
                        ::syntax::TraitBoundModifier::Maybe(_) =>
                        {
                            state.write_u8(1u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::TraitItem
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::TraitItem::Const(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::TraitItem::Fn(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::TraitItem::Type(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::TraitItem::Macro(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::TraitItem::Verbatim(v0) =>
                        {
                            state.write_u8(4u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::TraitItemConst
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.ty.hash(state);
                    self.default.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitItemFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.sig.hash(state);
                    self.default.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitItemMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.mac.hash(state);
                    self.semi_token.hash(state);
                }
            }
            
            impl Hash for ::syntax::TraitItemType
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.generics.hash(state);
                    self.colon_token.hash(state);
                    self.bounds.hash(state);
                    self.default.hash(state);
                }
            }
            
            impl Hash for ::syntax::Type
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Type::Array(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::BareFn(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Group(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::ImplTrait(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Infer(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Macro(v0) =>
                        {
                            state.write_u8(5u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Never(v0) =>
                        {
                            state.write_u8(6u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Paren(v0) =>
                        {
                            state.write_u8(7u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Path(v0) =>
                        {
                            state.write_u8(8u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Ptr(v0) =>
                        {
                            state.write_u8(9u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Reference(v0) =>
                        {
                            state.write_u8(10u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Slice(v0) =>
                        {
                            state.write_u8(11u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::TraitObject(v0) =>
                        {
                            state.write_u8(12u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Tuple(v0) =>
                        {
                            state.write_u8(13u8);
                            v0.hash(state);
                        }
                        ::syntax::Type::Verbatim(v0) =>
                        {
                            state.write_u8(14u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::TypeArray
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elem.hash(state);
                    self.len.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeBareFn
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetimes.hash(state);
                    self.unsafety.hash(state);
                    self.abi.hash(state);
                    self.inputs.hash(state);
                    self.variadic.hash(state);
                    self.output.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeGroup
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeImplTrait
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeInfer
            {
                fn hash<H>(&self, _state: &mut H) where
                H: Hasher
                {}
            }
            
            impl Hash for ::syntax::TypeMacro
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.mac.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeNever
            {
                fn hash<H>(&self, _state: &mut H) where
                H: Hasher
                {}
            }
            
            impl Hash for ::syntax::TypeParam
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.colon_token.hash(state);
                    self.bounds.hash(state);
                    self.eq_token.hash(state);
                    self.default.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeParamBound
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self 
                    {
                        ::syntax::TypeParamBound::Trait(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::TypeParamBound::Lifetime(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                                        ::syntax::TypeParamBound::PreciseCapture(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::TypeParamBound::Verbatim(v0) =>
                        {
                            state.write_u8(3u8);
                            TokenStreamHelper(v0).hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::TypeParen
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypePath
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.qself.hash(state);
                    self.path.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypePtr
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.const_token.hash(state);
                    self.mutability.hash(state);
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeReference
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.lifetime.hash(state);
                    self.mutability.hash(state);
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeSlice
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elem.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeTraitObject
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.dyn_token.hash(state);
                    self.bounds.hash(state);
                }
            }
            
            impl Hash for ::syntax::TypeTuple
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.elems.hash(state);
                }
            }
            
            impl Hash for ::syntax::UnOp
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::UnOp::Deref(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::UnOp::Not(_) =>
                        {
                            state.write_u8(1u8);
                        }
                        ::syntax::UnOp::Neg(_) =>
                        {
                            state.write_u8(2u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::UseGlob
            {
                fn hash<H>(&self, _state: &mut H) where
                H: Hasher
                {}
            }
            
            impl Hash for ::syntax::UseGroup
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.items.hash(state);
                }
            }
            
            impl Hash for ::syntax::UseName
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                }
            }
            
            impl Hash for ::syntax::UsePath
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.tree.hash(state);
                }
            }
            
            impl Hash for ::syntax::UseRename
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.ident.hash(state);
                    self.rename.hash(state);
                }
            }
            
            impl Hash for ::syntax::UseTree
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::UseTree::Path(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::UseTree::Name(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::UseTree::Rename(v0) =>
                        {
                            state.write_u8(2u8);
                            v0.hash(state);
                        }
                        ::syntax::UseTree::Glob(v0) =>
                        {
                            state.write_u8(3u8);
                            v0.hash(state);
                        }
                        ::syntax::UseTree::Group(v0) =>
                        {
                            state.write_u8(4u8);
                            v0.hash(state);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::Variadic
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.pat.hash(state);
                    self.comma.hash(state);
                }
            }
            
            impl Hash for ::syntax::Variant
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.attrs.hash(state);
                    self.ident.hash(state);
                    self.fields.hash(state);
                    self.discriminant.hash(state);
                }
            }
            
            impl Hash for ::syntax::VisRestricted
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.in_token.hash(state);
                    self.path.hash(state);
                }
            }
            
            impl Hash for ::syntax::Visibility
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::Visibility::Public(_) =>
                        {
                            state.write_u8(0u8);
                        }
                        ::syntax::Visibility::Restricted(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                        ::syntax::Visibility::Inherited => {
                            state.write_u8(2u8);
                        }
                    }
                }
            }
            
            impl Hash for ::syntax::WhereClause
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    self.predicates.hash(state);
                }
            }
            
            impl Hash for ::syntax::WherePredicate           
            {
                fn hash<H>(&self, state: &mut H) where
                H: Hasher
                {
                    match self {
                        ::syntax::WherePredicate::Lifetime(v0) =>
                        {
                            state.write_u8(0u8);
                            v0.hash(state);
                        }
                        ::syntax::WherePredicate::Type(v0) =>
                        {
                            state.write_u8(1u8);
                            v0.hash(state);
                        }
                    }
                }
            }
        }
    } pub use self::gen::{ fold, visit, visit_mut };
    
    pub mod __private
    {
        pub use ::
        {
            clone::{ Clone },
            cmp::{ Eq, PartialEq },
            default::{ Default },
            fmt::{ Debug },
            hash::{ Hash, Hasher },
            marker::{ Copy },
            option::Option::{ None, Some },
            result::Result::{ Err, Ok },
            quote::
            {
                self, ToTokens, TokenStreamExt
            },
            syntax::
            {
                group::{ parse_braces, parse_brackets, parse_parens },
                span::{ IntoSpans },
                parse_quote::{ parse as parse_quote },
                token::
                {
                    parsing::{ peek_punct, punct as parse_punct },
                    printing::{ punct as print_punct },
                    private::{ CustomToken },
                },
            },
            *,
        };
        /*
        */
        pub type TokenStream = proc_macro::TokenStream;
        pub type Span = process::macros::Span;
        pub type TokenStream2 = process::macros::TokenStream;
        pub type Formatter<'a> = ::fmt::Formatter<'a>;
        pub type FmtResult = ::fmt::Result;
        pub type bool = ::primitive::bool;
        pub type str = ::primitive::str;
        pub struct private(pub ());
    }
    /// Parse tokens of source code into the chosen syntax tree node.
    pub fn parse<T: parse::Parse>(tokens: proc_macro::TokenStream) -> Result<T>
    {
        parse::Parser::parse(T::parse, tokens)
    }
    /// Parse a proc-macro2 token stream into the chosen syntax tree node.
    pub fn parse2<T: parse::Parse>(tokens: process::macros::TokenStream) -> Result<T>
    {
        parse::Parser::parse2(T::parse, tokens)
    }
    /// Parse a string of Rust code into the chosen syntax tree node.
    pub fn parse_str<T: parse::Parse>(s: &str) -> Result<T>
    {
        parse::Parser::parse_str(T::parse, s)
    }
    /// Parse the content of a file of Rust code.
    pub fn parse_file(mut content: &str) -> Result<File>
    {
        const BOM: &str = "\u{feff}";
        if content.starts_with(BOM) { content = &content[BOM.len()..]; }

        let mut shebang = None;
        
        if content.starts_with("#!")
        {
            let rest = whitespace::skip(&content[2..]);

            if !rest.starts_with('[')
            {
                if let Some(idx) = content.find('\n')
                {
                    shebang = Some(content[..idx].to_string());
                    content = &content[idx..];
                }
                
                else
                {
                    shebang = Some(content.to_string());
                    content = "";
                }
            }
        }

        let mut file: File = parse_str(content)?;
        file.shebang = shebang;
        
        Ok(file)
    }
}

pub mod thread
{
    pub use std::thread::{ * };
}

pub mod vec
{
    pub use std::vec::{ * };
}
// 50210 /////////////////////////////////////////////////////////////////////////////////////////////////////////////
