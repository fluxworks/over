//! Implementation of Unicode Standard Annex #31 for 
//! determining which `char` values are valid in programming language identifiers.
#![feature
(
    
)]

#![allow
(
    bare_trait_objects,
    deprecated,
    mismatched_lifetime_syntaxes,
    non_camel_case_types,
    non_fmt_panics,
    non_snake_case,
    non_upper_case_globals,
    unused_attributes,
    unused_imports,
    unused_variables,
)]
/*
pub mod _
{
    pub use std::_::{ * };
}

pub mod __
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
}
*/
extern crate proc_macro;

#[macro_use] pub mod macros
{
    /// Performs variable interpolation against the input and produces it as [`process::macros::TokenStream`].
    #[macro_export] macro_rules! quote
    {
        () =>
        {
            ::__private::TokenStream::new()
        };
       
        ($tt:tt) => 
        {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt _s}
            _s
        }};
       
        
        (# $var:ident) => 
        {{
            let mut _s = ::__private::TokenStream::new();
            ::ToTokens::to_tokens(&$var, &mut _s);
            _s
        }};
        
        ($tt1:tt $tt2:tt) =>
        {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt1 _s}
            ::quote_token!{$tt2 _s}
            _s
        }};
       
        ($($tt:tt)*) => {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_each_token!{_s $($tt)*}
            _s
        }};
    }
    /// Same as `quote!`, but applies a given span to all tokens originating within the macro invocation.
    #[macro_export] macro_rules! quote_spanned
    {
        ($span:expr=>) => {{
            let _: ::__private::Span = ::__private::get_span($span).__into_span();
            ::__private::TokenStream::new()
        }};
       
        ($span:expr=> $tt:tt) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span($span).__into_span();
            ::quote_token_spanned!{$tt _s _span}
            _s
        }};
       
        ($span:expr=> # $var:ident) => {{
            let mut _s = ::__private::TokenStream::new();
            let _: ::__private::Span = ::__private::get_span($span).__into_span();
            ::ToTokens::to_tokens(&$var, &mut _s);
            _s
        }};
        ($span:expr=> $tt1:tt $tt2:tt) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span($span).__into_span();
            ::quote_token_spanned!{$tt1 _s _span}
            ::quote_token_spanned!{$tt2 _s _span}
            _s
        }};
       
        ($span:expr=> $($tt:tt)*) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span($span).__into_span();
            ::quote_each_token_spanned!{_s _span $($tt)*}
            _s
        }};
    }
   
    #[macro_export] macro_rules! pounded_var_names
    {
        ($call:ident! $extra:tt $($tts:tt)*) => {
            ::pounded_var_names_with_context!{$call! $extra
                (@ $($tts)*)
                ($($tts)* @)
            }
        };
    }

    #[macro_export] macro_rules! pounded_var_names_with_context
    {
        ($call:ident! $extra:tt ($($b1:tt)*) ($($curr:tt)*)) => {
            $(
                ::pounded_var_with_context!{$call! $extra $b1 $curr}
            )*
        };
    }

    #[macro_export] macro_rules! pounded_var_with_context
    {
        ($call:ident! $extra:tt $b1:tt ( $($inner:tt)* )) => {
            ::pounded_var_names!{$call! $extra $($inner)*}
        };

        ($call:ident! $extra:tt $b1:tt [ $($inner:tt)* ]) => {
            ::pounded_var_names!{$call! $extra $($inner)*}
        };

        ($call:ident! $extra:tt $b1:tt { $($inner:tt)* }) => {
            ::pounded_var_names!{$call! $extra $($inner)*}
        };

        ($call:ident!($($extra:tt)*) # $var:ident) => {
            ::$call!($($extra)* $var);
        };

        ($call:ident! $extra:tt $b1:tt $curr:tt) => {};
    }

    #[macro_export] macro_rules! quote_bind_into_iter 
    {
        ($has_iter:ident $var:ident) => {
           
            #[allow(unused_mut)]
            let (mut $var, i) = $var.quote_into_iter();
            let $has_iter = $has_iter | i;
        };
    }

    #[macro_export] macro_rules! quote_bind_next_or_break 
    {
        ($var:ident) => {
            let $var = match $var.next() {
                Some(_x) => ::__private::RepInterp(_x),
                None => break,
            };
        };
    }
    
    #[macro_export] macro_rules! quote_each_token 
    {
        ($tokens:ident $($tts:tt)*) => {
            ::quote_tokens_with_context!{$tokens
                (@ @ @ @ @ @ $($tts)*)
                (@ @ @ @ @ $($tts)* @)
                (@ @ @ @ $($tts)* @ @)
                (@ @ @ $(($tts))* @ @ @)
                (@ @ $($tts)* @ @ @ @)
                (@ $($tts)* @ @ @ @ @)
                ($($tts)* @ @ @ @ @ @)
            }
        };
    }

    #[macro_export] macro_rules! quote_each_token_spanned 
    {
        ($tokens:ident $span:ident $($tts:tt)*) => {
            ::quote_tokens_with_context_spanned!{$tokens $span
                (@ @ @ @ @ @ $($tts)*)
                (@ @ @ @ @ $($tts)* @)
                (@ @ @ @ $($tts)* @ @)
                (@ @ @ $(($tts))* @ @ @)
                (@ @ $($tts)* @ @ @ @)
                (@ $($tts)* @ @ @ @ @)
                ($($tts)* @ @ @ @ @ @)
            }
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context
    {
        ($tokens:ident
            ($($b3:tt)*) ($($b2:tt)*) ($($b1:tt)*)
            ($($curr:tt)*)
            ($($a1:tt)*) ($($a2:tt)*) ($($a3:tt)*)
        ) => {
            $(
                ::quote_token_with_context!{$tokens $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context_spanned
    {
        ($tokens:ident $span:ident
            ($($b3:tt)*) ($($b2:tt)*) ($($b1:tt)*)
            ($($curr:tt)*)
            ($($a1:tt)*) ($($a2:tt)*) ($($a3:tt)*)
        ) => {
            $(
                ::quote_token_with_context_spanned!{$tokens $span $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_token_with_context
    {  
        ($tokens:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) * $a3:tt) => 
        {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            
            while true 
            {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                ::quote_each_token!{$tokens $($inner)*}
            }
        }};
       
        ($tokens:ident $b3:tt $b2:tt # (( $($inner:tt)* )) * $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt # ( $($inner:tt)* ) (*) $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) $sep:tt *) => 
        {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                if _i > 0 {
                    ::quote_token!{$sep $tokens}
                }
                _i += 1;
                ::quote_each_token!{$tokens $($inner)*}
            }
        }};
       
        ($tokens:ident $b3:tt $b2:tt # (( $($inner:tt)* )) $sep:tt * $a3:tt) => {};
       
        ($tokens:ident $b3:tt # ( $($inner:tt)* ) ($sep:tt) * $a2:tt $a3:tt) => {};
       
       
        ($tokens:ident # ( $($inner:tt)* ) * (*) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token!{* $tokens}
        };
       
        ($tokens:ident # ( $($inner:tt)* ) $sep:tt (*) $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt (#) $var:ident $a2:tt $a3:tt) => {
            ::ToTokens::to_tokens(&$var, &mut $tokens);
        };
       
        ($tokens:ident $b3:tt $b2:tt # ($var:ident) $a1:tt $a2:tt $a3:tt) => {};
       
        ($tokens:ident $b3:tt $b2:tt $b1:tt ($curr:tt) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token!{$curr $tokens}
        };
    }
    
    #[macro_export] macro_rules! quote_token_with_context_spanned 
    {
        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) * $a3:tt) => {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                ::quote_each_token_spanned!{$tokens $span $($inner)*}
            }
        }};
        ($tokens:ident $span:ident $b3:tt $b2:tt # (( $($inner:tt)* )) * $a2:tt $a3:tt) => {};
        ($tokens:ident $span:ident $b3:tt # ( $($inner:tt)* ) (*) $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt (#) ( $($inner:tt)* ) $sep:tt *) => {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!(has_iter) () $($inner)*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $($inner)*}
                if _i > 0 {
                    ::quote_token_spanned!{$sep $tokens $span}
                }
                _i += 1;
                ::quote_each_token_spanned!{$tokens $span $($inner)*}
            }
        }};
        ($tokens:ident $span:ident $b3:tt $b2:tt # (( $($inner:tt)* )) $sep:tt * $a3:tt) => {};
        ($tokens:ident $span:ident $b3:tt # ( $($inner:tt)* ) ($sep:tt) * $a2:tt $a3:tt) => {};
        ($tokens:ident $span:ident # ( $($inner:tt)* ) * (*) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token_spanned!{* $tokens $span}
        };
        ($tokens:ident $span:ident # ( $($inner:tt)* ) $sep:tt (*) $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt (#) $var:ident $a2:tt $a3:tt) => {
            ::ToTokens::to_tokens(&$var, &mut $tokens);
        };
        ($tokens:ident $span:ident $b3:tt $b2:tt # ($var:ident) $a1:tt $a2:tt $a3:tt) => {};

        ($tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ($curr:tt) $a1:tt $a2:tt $a3:tt) => {
            ::quote_token_spanned!{$curr $tokens $span}
        };
    }
    
    #[macro_export] macro_rules! quote_token
    {
        ($ident:ident $tokens:ident) =>
        {
            ::__private::push_ident(&mut $tokens, stringify!($ident));
        };

        (:: $tokens:ident) =>
        {
            ::__private::push_colon2(&mut $tokens);
        };

        (( $($inner:tt)* ) $tokens:ident) =>
        {
            ::__private::push_group
            (
                &mut $tokens,
                ::__private::Delimiter::Parenthesis,
                ::quote!($($inner)*),
            );
        };

        ([ $($inner:tt)* ] $tokens:ident) =>
        {
            ::__private::push_group
            (
                &mut $tokens,
                ::__private::Delimiter::Bracket,
                ::quote!($($inner)*),
            );
        };

        ({ $($inner:tt)* } $tokens:ident) =>
        {
            ::__private::push_group
            (
                &mut $tokens,
                ::__private::Delimiter::Brace,
                ::quote!($($inner)*),
            );
        };

        (# $tokens:ident) =>
        {
            ::__private::push_pound(&mut $tokens);
        };

        (, $tokens:ident) =>
        {
            ::__private::push_comma(&mut $tokens);
        };

        (. $tokens:ident) =>
        {
            ::__private::push_dot(&mut $tokens);
        };

        (; $tokens:ident) =>
        {
            ::__private::push_semi(&mut $tokens);
        };

        (: $tokens:ident) =>
        {
            ::__private::push_colon(&mut $tokens);
        };

        (+ $tokens:ident) =>
        {
            ::__private::push_add(&mut $tokens);
        };

        (+= $tokens:ident) =>
        {
            ::__private::push_add_eq(&mut $tokens);
        };

        (& $tokens:ident) =>
        {
            ::__private::push_and(&mut $tokens);
        };

        (&& $tokens:ident) =>
        {
            ::__private::push_and_and(&mut $tokens);
        };

        (&= $tokens:ident) =>
        {
            ::__private::push_and_eq(&mut $tokens);
        };

        (@ $tokens:ident) =>
        {
            ::__private::push_at(&mut $tokens);
        };

        (! $tokens:ident) =>
        {
            ::__private::push_bang(&mut $tokens);
        };

        (^ $tokens:ident) =>
        {
            ::__private::push_caret(&mut $tokens);
        };

        (^= $tokens:ident) =>
        {
            ::__private::push_caret_eq(&mut $tokens);
        };

        (/ $tokens:ident) =>
        {
            ::__private::push_div(&mut $tokens);
        };

        (/= $tokens:ident) =>
        {
            ::__private::push_div_eq(&mut $tokens);
        };

        (.. $tokens:ident) =>
        {
            ::__private::push_dot2(&mut $tokens);
        };

        (... $tokens:ident) =>
        {
            ::__private::push_dot3(&mut $tokens);
        };

        (..= $tokens:ident) =>
        {
            ::__private::push_dot_dot_eq(&mut $tokens);
        };

        (= $tokens:ident) =>
        {
            ::__private::push_eq(&mut $tokens);
        };

        (== $tokens:ident) =>
        {
            ::__private::push_eq_eq(&mut $tokens);
        };

        (>= $tokens:ident) =>
        {
            ::__private::push_ge(&mut $tokens);
        };

        (> $tokens:ident) =>
        {
            ::__private::push_gt(&mut $tokens);
        };

        (<= $tokens:ident) =>
        {
            ::__private::push_le(&mut $tokens);
        };

        (< $tokens:ident) =>
        {
            ::__private::push_lt(&mut $tokens);
        };

        (*= $tokens:ident) =>
        {
            ::__private::push_mul_eq(&mut $tokens);
        };

        (!= $tokens:ident) =>
        {
            ::__private::push_ne(&mut $tokens);
        };

        (| $tokens:ident) =>
        {
            ::__private::push_or(&mut $tokens);
        };

        (|= $tokens:ident) =>
        {
            ::__private::push_or_eq(&mut $tokens);
        };

        (|| $tokens:ident) =>
        {
            ::__private::push_or_or(&mut $tokens);
        };

        (? $tokens:ident) =>
        {
            ::__private::push_question(&mut $tokens);
        };

        (-> $tokens:ident) =>
        {
            ::__private::push_rarrow(&mut $tokens);
        };

        (<- $tokens:ident) =>
        {
            ::__private::push_larrow(&mut $tokens);
        };

        (% $tokens:ident) =>
        {
            ::__private::push_rem(&mut $tokens);
        };

        (%= $tokens:ident) =>
        {
            ::__private::push_rem_eq(&mut $tokens);
        };

        (=> $tokens:ident) =>
        {
            ::__private::push_fat_arrow(&mut $tokens);
        };

        (<< $tokens:ident) =>
        {
            ::__private::push_shl(&mut $tokens);
        };

        (<<= $tokens:ident) =>
        {
            ::__private::push_shl_eq(&mut $tokens);
        };

        (>> $tokens:ident) =>
        {
            ::__private::push_shr(&mut $tokens);
        };

        (>>= $tokens:ident) =>
        {
            ::__private::push_shr_eq(&mut $tokens);
        };

        (* $tokens:ident) =>
        {
            ::__private::push_star(&mut $tokens);
        };

        (- $tokens:ident) =>
        {
            ::__private::push_sub(&mut $tokens);
        };

        (-= $tokens:ident) =>
        {
            ::__private::push_sub_eq(&mut $tokens);
        };

        ($lifetime:lifetime $tokens:ident) =>
        {
            ::__private::push_lifetime(&mut $tokens, stringify!($lifetime));
        };

        (_ $tokens:ident) =>
        {
            ::__private::push_underscore(&mut $tokens);
        };

        ($other:tt $tokens:ident) =>
        {
            ::__private::parse(&mut $tokens, stringify!($other));
        };
    }

    #[macro_export] macro_rules! quote_token_spanned
    {
        ($ident:ident $tokens:ident $span:ident) =>
        {
            ::__private::push_ident_spanned(&mut $tokens, $span, stringify!($ident));
        };

        (:: $tokens:ident $span:ident) =>
        {
            ::__private::push_colon2_spanned(&mut $tokens, $span);
        };

        (( $($inner:tt)* ) $tokens:ident $span:ident) =>
        {
            ::__private::push_group_spanned            
            (
                &mut $tokens,
                $span,
                ::__private::Delimiter::Parenthesis,
                ::quote_spanned!($span=> $($inner)*),
            );
        };

        ([ $($inner:tt)* ] $tokens:ident $span:ident) =>
        {
            ::__private::push_group_spanned
            (
                &mut $tokens,
                $span,
                ::__private::Delimiter::Bracket,
                ::quote_spanned!($span=> $($inner)*),
            );
        };

        ({ $($inner:tt)* } $tokens:ident $span:ident) =>
        {
            ::__private::push_group_spanned
            
            (
                &mut $tokens,
                $span,
                ::__private::Delimiter::Brace,
                ::quote_spanned!($span=> $($inner)*),
            );
        };

        (# $tokens:ident $span:ident) =>
        {
            ::__private::push_pound_spanned(&mut $tokens, $span);
        };

        (, $tokens:ident $span:ident) =>
        {
            ::__private::push_comma_spanned(&mut $tokens, $span);
        };

        (. $tokens:ident $span:ident) =>
        {
            ::__private::push_dot_spanned(&mut $tokens, $span);
        };

        (; $tokens:ident $span:ident) =>
        {
            ::__private::push_semi_spanned(&mut $tokens, $span);
        };

        (: $tokens:ident $span:ident) =>
        {
            ::__private::push_colon_spanned(&mut $tokens, $span);
        };

        (+ $tokens:ident $span:ident) =>
        {
            ::__private::push_add_spanned(&mut $tokens, $span);
        };

        (+= $tokens:ident $span:ident) =>
        {
            ::__private::push_add_eq_spanned(&mut $tokens, $span);
        };

        (& $tokens:ident $span:ident) =>
        {
            ::__private::push_and_spanned(&mut $tokens, $span);
        };

        (&& $tokens:ident $span:ident) =>
        {
            ::__private::push_and_and_spanned(&mut $tokens, $span);
        };

        (&= $tokens:ident $span:ident) =>
        {
            ::__private::push_and_eq_spanned(&mut $tokens, $span);
        };

        (@ $tokens:ident $span:ident) =>
        {
            ::__private::push_at_spanned(&mut $tokens, $span);
        };

        (! $tokens:ident $span:ident) =>
        {
            ::__private::push_bang_spanned(&mut $tokens, $span);
        };

        (^ $tokens:ident $span:ident) =>
        {
            ::__private::push_caret_spanned(&mut $tokens, $span);
        };

        (^= $tokens:ident $span:ident) =>
        {
            ::__private::push_caret_eq_spanned(&mut $tokens, $span);
        };

        (/ $tokens:ident $span:ident) =>
        {
            ::__private::push_div_spanned(&mut $tokens, $span);
        };

        (/= $tokens:ident $span:ident) =>
        {
            ::__private::push_div_eq_spanned(&mut $tokens, $span);
        };

        (.. $tokens:ident $span:ident) =>
        {
            ::__private::push_dot2_spanned(&mut $tokens, $span);
        };

        (... $tokens:ident $span:ident) =>
        {
            ::__private::push_dot3_spanned(&mut $tokens, $span);
        };

        (..= $tokens:ident $span:ident) =>
        {
            ::__private::push_dot_dot_eq_spanned(&mut $tokens, $span);
        };

        (= $tokens:ident $span:ident) =>
        {
            ::__private::push_eq_spanned(&mut $tokens, $span);
        };

        (== $tokens:ident $span:ident) =>
        {
            ::__private::push_eq_eq_spanned(&mut $tokens, $span);
        };

        (>= $tokens:ident $span:ident) =>
        {
            ::__private::push_ge_spanned(&mut $tokens, $span);
        };

        (> $tokens:ident $span:ident) =>
        {
            ::__private::push_gt_spanned(&mut $tokens, $span);
        };

        (<= $tokens:ident $span:ident) =>
        {
            ::__private::push_le_spanned(&mut $tokens, $span);
        };

        (< $tokens:ident $span:ident) =>
        {
            ::__private::push_lt_spanned(&mut $tokens, $span);
        };

        (*= $tokens:ident $span:ident) =>
        {
            ::__private::push_mul_eq_spanned(&mut $tokens, $span);
        };

        (!= $tokens:ident $span:ident) =>
        {
            ::__private::push_ne_spanned(&mut $tokens, $span);
        };

        (| $tokens:ident $span:ident) =>
        {
            ::__private::push_or_spanned(&mut $tokens, $span);
        };

        (|= $tokens:ident $span:ident) =>
        {
            ::__private::push_or_eq_spanned(&mut $tokens, $span);
        };

        (|| $tokens:ident $span:ident) =>
        {
            ::__private::push_or_or_spanned(&mut $tokens, $span);
        };

        (? $tokens:ident $span:ident) =>
        {
            ::__private::push_question_spanned(&mut $tokens, $span);
        };

        (-> $tokens:ident $span:ident) =>
        {
            ::__private::push_rarrow_spanned(&mut $tokens, $span);
        };

        (<- $tokens:ident $span:ident) =>
        {
            ::__private::push_larrow_spanned(&mut $tokens, $span);
        };

        (% $tokens:ident $span:ident) =>
        {
            ::__private::push_rem_spanned(&mut $tokens, $span);
        };

        (%= $tokens:ident $span:ident) =>
        {
            ::__private::push_rem_eq_spanned(&mut $tokens, $span);
        };

        (=> $tokens:ident $span:ident) =>
        {
            ::__private::push_fat_arrow_spanned(&mut $tokens, $span);
        };

        (<< $tokens:ident $span:ident) =>
        {
            ::__private::push_shl_spanned(&mut $tokens, $span);
        };

        (<<= $tokens:ident $span:ident) =>
        {
            ::__private::push_shl_eq_spanned(&mut $tokens, $span);
        };

        (>> $tokens:ident $span:ident) =>
        {
            ::__private::push_shr_spanned(&mut $tokens, $span);
        };

        (>>= $tokens:ident $span:ident) =>
        {
            ::__private::push_shr_eq_spanned(&mut $tokens, $span);
        };

        (* $tokens:ident $span:ident) =>
        {
            ::__private::push_star_spanned(&mut $tokens, $span);
        };

        (- $tokens:ident $span:ident) =>
        {
            ::__private::push_sub_spanned(&mut $tokens, $span);
        };

        (-= $tokens:ident $span:ident) =>
        {
            ::__private::push_sub_eq_spanned(&mut $tokens, $span);
        };

        ($lifetime:lifetime $tokens:ident $span:ident) =>
        {
            ::__private::push_lifetime_spanned(&mut $tokens, $span, stringify!($lifetime));
        };

        (_ $tokens:ident $span:ident) =>
        {
            ::__private::push_underscore_spanned(&mut $tokens, $span);
        };

        ($other:tt $tokens:ident $span:ident) =>
        {
            ::__private::parse_spanned(&mut $tokens, $span, stringify!($other));
        };
    }

    #[macro_export] macro_rules! format_ident
    {
        ($fmt:expr) => {
            format_ident_impl!([
                ::quote::__private::Option::None,
                $fmt
            ])
        };

        ($fmt:expr, $($rest:tt)*) => {
            format_ident_impl!([
                ::quote::__private::Option::None,
                $fmt
            ] $($rest)*)
        };
    }

    #[macro_export] macro_rules! format_ident_impl
    {
       
        ([$span:expr, $($fmt:tt)*]) => {
            ::quote::__private::mk_ident(
                &::quote::__private::format!($($fmt)*),
                $span,
            )
        };

       
        ([$old:expr, $($fmt:tt)*] span = $span:expr) => {
            format_ident_impl!([$old, $($fmt)*] span = $span,)
        };
        ([$old:expr, $($fmt:tt)*] span = $span:expr, $($rest:tt)*) => {
            format_ident_impl!([
                ::quote::__private::Option::Some::<::quote::__private::Span>($span),
                $($fmt)*
            ] $($rest)*)
        };

       
        ([$span:expr, $($fmt:tt)*] $name:ident = $arg:expr) => {
            format_ident_impl!([$span, $($fmt)*] $name = $arg,)
        };
        ([$span:expr, $($fmt:tt)*] $name:ident = $arg:expr, $($rest:tt)*) => {
            match ::quote::__private::IdentFragmentAdapter(&$arg) {
                arg => format_ident_impl!([$span.or(arg.span()), $($fmt)*, $name = arg] $($rest)*),
            }
        };

       
        ([$span:expr, $($fmt:tt)*] $arg:expr) => {
            format_ident_impl!([$span, $($fmt)*] $arg,)
        };
        ([$span:expr, $($fmt:tt)*] $arg:expr, $($rest:tt)*) => {
            match ::quote::__private::IdentFragmentAdapter(&$arg) {
                arg => format_ident_impl!([$span.or(arg.span()), $($fmt)*, arg] $($rest)*),
            }
        };
    }

    #[macro_export] macro_rules! ast_struct 
    {
        (
            $(#[$attr:meta])*
            $pub:ident $struct:ident $name:ident #full $body:tt
        ) =>
        {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(struct $struct);
            $(#[$attr])* $pub $struct $name $body
        };

        (
            $(#[$attr:meta])*
            $pub:ident $struct:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(struct $struct);

            $(#[$attr])* $pub $struct $name $body
        };
    }
    
    #[macro_export] macro_rules! ast_enum
    {
        (
            $(#[$enum_attr:meta])*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(enum $enum);

            $(#[$enum_attr])* $pub $enum $name $body
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs
    {
        (
            $(#[$enum_attr:meta])*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!(pub $pub);
            check_keyword_matches!(enum $enum);

            $(#[$enum_attr])* $pub $enum $name $body

            ast_enum_of_structs_impl!($name $body);

                generate_to_tokens!(() tokens $name $body);
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs_impl
    {
        (
            $name:ident {
                $(
                    $(#[cfg $cfg_attr:tt])*
                    $(#[doc $($doc_attr:tt)*])*
                    $variant:ident $( ($member:ident) )*,
                )*
            }
        ) => {
            $($(
                ast_enum_from_struct!($name::$variant, $member);
            )*)*
        };
    }

    #[macro_export] macro_rules! ast_enum_from_struct
    {
        ($name:ident::Verbatim, $member:ident) => {};

        ($name:ident::$variant:ident, $member:ident) =>
        {
            impl From<$member> for $name
            {
                fn from(e: $member) -> $name {
                    $name::$variant(e)
                }
            }
        };
    }
    
    #[macro_export] macro_rules! generate_to_tokens
    {
        (
            ($($arms:tt)*) $tokens:ident $name:ident {
                $(#[cfg $cfg_attr:tt])*
                $(#[doc $($doc_attr:tt)*])*
                $variant:ident,
                $($next:tt)*
            }
        ) => {
            generate_to_tokens!(
                ($($arms)* $(#[cfg $cfg_attr])* $name::$variant => {})
                $tokens $name { $($next)* }
            );
        };

        (
            ($($arms:tt)*) $tokens:ident $name:ident {
                $(#[cfg $cfg_attr:tt])*
                $(#[doc $($doc_attr:tt)*])*
                $variant:ident($member:ident),
                $($next:tt)*
            }
        ) => {
            generate_to_tokens!(
                ($($arms)* $(#[cfg $cfg_attr])* $name::$variant(_e) => _e.to_tokens($tokens),)
                $tokens $name { $($next)* }
            );
        };

        (($($arms:tt)*) $tokens:ident $name:ident {}) => {
            impl ::quote::ToTokens for $name {
                fn to_tokens(&self, $tokens:&mut ::process::macros::TokenStream )
                {
                    match self {
                        $($arms)*
                    }
                }
            }
        };
    }
    
    #[macro_export] macro_rules! pub_if_not_doc
    {
        ($(#[$m:meta])* $pub:ident $($item:tt)*) => {
            check_keyword_matches!(pub $pub);

            $(#[$m])*
            $pub $($item)*
        };
    }

    #[macro_export] macro_rules! check_keyword_matches 
    {
        (enum enum) => {};
        (pub pub) => {};
        (struct struct) => {};
    }

    #[macro_export] macro_rules! return_impl_trait
    {
        (
            $(#[$attr:meta])*
            $vis:vis fn $name:ident $args:tt -> $impl_trait:ty [$concrete:ty] $body:block
        ) => {
            #[cfg(not(docsrs))]
            $(#[$attr])*
            $vis fn $name $args -> $concrete $body

            #[cfg(docsrs)]
            $(#[$attr])*
            $vis fn $name $args -> $impl_trait $body
        };
    }
    /// Parse a set of parentheses and expose their content to subsequent parsers.
    #[macro_export] macro_rules! parenthesized
    {
        ($content:ident in $cursor:expr) => {
            match ::syntax::__private::parse_parens(&$cursor) {
                ::syntax::__private::Ok(parens) => {
                    $content = parens.content;
                    parens.token
                }
                ::syntax::__private::Err(error) => {
                    return ::syntax::__private::Err(error);
                }
            }
        };
    }
    /// Parse a set of curly braces and expose their content to subsequent parsers.
    #[macro_export] macro_rules! braced
    {
        ($content:ident in $cursor:expr) => 
        {
            match ::syntax::__private::parse_braces(&$cursor) {
                ::syntax::__private::Ok(braces) => {
                    $content = braces.content;
                    braces.token
                }
                ::syntax::__private::Err(error) => {
                    return ::syntax::__private::Err(error);
                }
            }
        };
    }
    /// Parse a set of square brackets and expose their content to subsequent parsers.
    #[macro_export] macro_rules! bracketed
    {
        ($content:ident in $cursor:expr) =>
        {
            match ::syntax::__private::parse_brackets(&$cursor)
            {
                ::syntax::__private::Ok(brackets) => {
                    $content = brackets.content;
                    brackets.token
                }
                ::syntax::__private::Err(error) => {
                    return ::syntax::__private::Err(error);
                }
            }
        };
    }

    #[macro_export] macro_rules! parse_quote
    {
        ($($tt:tt)*) =>
        {
            ::syntax::__private::parse_quote(::syntax::__private::quote::quote!($($tt)*))
        };
    }
    /// This macro is [`parse_quote!`] + [`quote_spanned!`][quote::quote_spanned].
    #[macro_export] macro_rules! parse_quote_spanned
    {
        ($span:expr=> $($tt:tt)*) =>
        {
            ::syntax::__private::parse_quote(::syntax::__private::quote::quote_spanned!($span=> $($tt)*))
        };
    }
    
    #[macro_export] macro_rules! parse_macro_input
    {
        ($tokenstream:ident as $ty:ty) => {
            match ::syntax::parse::<$ty>($tokenstream) {
                ::syntax::__private::Ok(data) => data,
                ::syntax::__private::Err(err) => {
                    return ::syntax::__private::TokenStream::from(err.to_compile_error());
                }
            }
        };
        ($tokenstream:ident with $parser:path) => {
            match ::syntax::parse::Parser::parse($parser, $tokenstream) {
                ::syntax::__private::Ok(data) => data,
                ::syntax::__private::Err(err) => {
                    return ::syntax::__private::TokenStream::from(err.to_compile_error());
                }
            }
        };
        ($tokenstream:ident) => {
            ::syntax::parse_macro_input!($tokenstream as _)
        };
    }

    #[macro_export] macro_rules! custom_punctuation
    {
        ($ident:ident, $($tt:tt)+) =>
        {
            pub struct $ident {
                #[allow(dead_code)]
                pub spans: ::syntax::custom_punctuation_repr!($($tt)+),
            }

                #[allow(dead_code, non_snake_case)]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::custom_punctuation_repr!($($tt)+)>>(
                spans: __S,
            ) -> $ident {
                let _validate_len = 0 $(+ ::syntax::custom_punctuation_len!(strict, $tt))*;
                $ident {
                    spans: ::syntax::__private::IntoSpans::into_spans(spans)
                }
            }

            const _: () = {
                impl ::syntax::__private::Default for $ident {
                    fn default() -> Self {
                        $ident(::syntax::__private::Span::call_site())
                    }
                }

                ::syntax::impl_parse_for_custom_punctuation!($ident, $($tt)+);
                ::syntax::impl_to_tokens_for_custom_punctuation!($ident, $($tt)+);
                ::syntax::impl_clone_for_custom_punctuation!($ident, $($tt)+);
                ::syntax::impl_extra_traits_for_custom_punctuation!($ident, $($tt)+);
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_punctuation
    {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::CustomToken for $ident {
                fn peek(cursor: ::syntax::buffer::Cursor) -> ::syntax::__private::bool {
                    ::syntax::__private::peek_punct(cursor, ::syntax::stringify_punct!($($tt)+))
                }

                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!("`", ::syntax::stringify_punct!($($tt)+), "`")
                }
            }

            impl ::syntax::parse::Parse for $ident
            {
                fn parse(input: ::syntax::parse::ParseStream) -> ::syntax::parse::Result<$ident> {
                    let spans: ::syntax::custom_punctuation_repr!($($tt)+) =
                        ::syntax::__private::parse_punct(input, ::syntax::stringify_punct!($($tt)+))?;
                    Ok($ident(spans))
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_punctuation
    {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens(&self, tokens: &mut ::syntax::__private::TokenStream2) {
                    ::syntax::__private::print_punct(::syntax::stringify_punct!($($tt)+), &self.spans, tokens)
                }
            }
        };
    }
        
    #[macro_export] macro_rules! impl_clone_for_custom_punctuation
    {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::Copy for $ident {}

            #[allow(clippy::expl_impl_clone_on_copy)]
            impl ::syntax::__private::Clone for $ident {
                fn clone(&self) -> Self {
                    *self
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_punctuation
    {
        ($ident:ident, $($tt:tt)+) => {
            impl ::syntax::__private::Debug for $ident {
                fn fmt(&self, f: &mut ::syntax::__private::Formatter) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str(f, ::syntax::__private::stringify!($ident))
                }
            }

            impl ::syntax::__private::Eq for $ident {}

            impl ::syntax::__private::PartialEq for $ident {
                fn eq(&self, _other: &Self) -> ::syntax::__private::bool {
                    true
                }
            }

            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>(&self, _state: &mut __H) {}
            }
        };
    }
        
    #[macro_export] macro_rules! custom_punctuation_repr
    {
        ($($tt:tt)+) => {
            [::syntax::__private::Span; 0 $(+ ::syntax::custom_punctuation_len!(lenient, $tt))+]
        };
    }
    
    #[macro_export] macro_rules! custom_punctuation_len
    {
        ($mode:ident, &)     => { 1 };
        ($mode:ident, &&)    => { 2 };
        ($mode:ident, &=)    => { 2 };
        ($mode:ident, @)     => { 1 };
        ($mode:ident, ^)     => { 1 };
        ($mode:ident, ^=)    => { 2 };
        ($mode:ident, :)     => { 1 };
        ($mode:ident, ,)     => { 1 };
        ($mode:ident, $)     => { 1 };
        ($mode:ident, .)     => { 1 };
        ($mode:ident, ..)    => { 2 };
        ($mode:ident, ...)   => { 3 };
        ($mode:ident, ..=)   => { 3 };
        ($mode:ident, =)     => { 1 };
        ($mode:ident, ==)    => { 2 };
        ($mode:ident, =>)    => { 2 };
        ($mode:ident, >=)    => { 2 };
        ($mode:ident, >)     => { 1 };
        ($mode:ident, <-)    => { 2 };
        ($mode:ident, <=)    => { 2 };
        ($mode:ident, <)     => { 1 };
        ($mode:ident, -)     => { 1 };
        ($mode:ident, -=)    => { 2 };
        ($mode:ident, !=)    => { 2 };
        ($mode:ident, !)     => { 1 };
        ($mode:ident, |)     => { 1 };
        ($mode:ident, |=)    => { 2 };
        ($mode:ident, ||)    => { 2 };
        ($mode:ident, ::)    => { 2 };
        ($mode:ident, %)     => { 1 };
        ($mode:ident, %=)    => { 2 };
        ($mode:ident, +)     => { 1 };
        ($mode:ident, +=)    => { 2 };
        ($mode:ident, #)     => { 1 };
        ($mode:ident, ?)     => { 1 };
        ($mode:ident, ->)    => { 2 };
        ($mode:ident, ;)     => { 1 };
        ($mode:ident, <<)    => { 2 };
        ($mode:ident, <<=)   => { 3 };
        ($mode:ident, >>)    => { 2 };
        ($mode:ident, >>=)   => { 3 };
        ($mode:ident, /)     => { 1 };
        ($mode:ident, /=)    => { 2 };
        ($mode:ident, *)     => { 1 };
        ($mode:ident, *=)    => { 2 };
        ($mode:ident, ~)     => { 1 };
        (lenient, $tt:tt)    => { 0 };
        (strict, $tt:tt)     => {{ ::syntax::custom_punctuation_unexpected!($tt); 0 }};
    }
    
    #[macro_export] macro_rules! custom_punctuation_unexpected
    {
        () => {};
    }
    
    #[macro_export] macro_rules! stringify_punct
    {
        ($($tt:tt)+) => {
            ::syntax::__private::concat!($(::syntax::__private::stringify!($tt)),+)
        };
    }

    #[macro_export] macro_rules! custom_keyword
    {
        ($ident:ident) => {
            #[allow(non_camel_case_types)]
            pub struct $ident {
                #[allow(dead_code)]
                pub span: ::syntax::__private::Span,
            }

                #[allow(dead_code, non_snake_case)]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::__private::Span>>(
                span: __S,
            ) -> $ident {
                $ident {
                    span: ::syntax::__private::IntoSpans::into_spans(span),
                }
            }

            const _: () = {
                impl ::syntax::__private::Default for $ident {
                    fn default() -> Self {
                        $ident {
                            span: ::syntax::__private::Span::call_site(),
                        }
                    }
                }

                ::syntax::impl_parse_for_custom_keyword!($ident);
                ::syntax::impl_to_tokens_for_custom_keyword!($ident);
                ::syntax::impl_clone_for_custom_keyword!($ident);
                ::syntax::impl_extra_traits_for_custom_keyword!($ident);
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_keyword
    {
        ($ident:ident) => {
           
            impl ::syntax::__private::CustomToken for $ident {
                fn peek(cursor: ::syntax::buffer::Cursor) -> ::syntax::__private::bool {
                    if let ::syntax::__private::Some((ident, _rest)) = cursor.ident() {
                        ident == ::syntax::__private::stringify!($ident)
                    } else {
                        false
                    }
                }

                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!("`", ::syntax::__private::stringify!($ident), "`")
                }
            }

            impl ::syntax::parse::Parse for $ident
            {
                fn parse(input: ::syntax::parse::ParseStream) -> ::syntax::parse::Result<$ident> {
                    input.step(|cursor| {
                        if let ::syntax::__private::Some((ident, rest)) = cursor.ident() {
                            if ident == ::syntax::__private::stringify!($ident) {
                                return ::syntax::__private::Ok(($ident { span: ident.span() }, rest));
                            }
                        }
                        ::syntax::__private::Err(cursor.error(::syntax::__private::concat!(
                            "expected `",
                            ::syntax::__private::stringify!($ident),
                            "`",
                        )))
                    })
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_keyword
    {
        ($ident:ident) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens(&self, tokens: &mut ::syntax::__private::TokenStream2) {
                    let ident = ::syntax::Ident::new(::syntax::__private::stringify!($ident), self.span);
                    ::syntax::__private::TokenStreamExt::append(tokens, ident);
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_clone_for_custom_keyword
    {
        ($ident:ident) => {
            impl ::syntax::__private::Copy for $ident {}

            #[allow(clippy::expl_impl_clone_on_copy)]
            impl ::syntax::__private::Clone for $ident {
                fn clone(&self) -> Self {
                    *self
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_keyword 
    {
        ($ident:ident) => {
            impl ::syntax::__private::Debug for $ident {
                fn fmt(&self, f: &mut ::syntax::__private::Formatter) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str(
                        f,
                        ::syntax::__private::concat!(
                            "Keyword [",
                            ::syntax::__private::stringify!($ident),
                            "]",
                        ),
                    )
                }
            }

            impl ::syntax::__private::Eq for $ident {}

            impl ::syntax::__private::PartialEq for $ident {
                fn eq(&self, _other: &Self) -> ::syntax::__private::bool {
                    true
                }
            }

            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>(&self, _state: &mut __H) {}
            }
        };
    }
    /// Forward a method to an inherent method or a base trait method.
    #[macro_export] macro_rules! forward
    {
        ($( Self :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
            => {$(
                #[inline]
                fn $method(self $( , $arg : $ty )* ) -> $ret {
                    Self::$method(self $( , $arg )* )
                }
            )*};
        ($( $base:ident :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
            => {$(
                #[inline]
                fn $method(self $( , $arg : $ty )* ) -> $ret {
                    <Self as $base>::$method(self $( , $arg )* )
                }
            )*};
        ($( $base:ident :: $method:ident ( $( $arg:ident : $ty:ty ),* ) -> $ret:ty ; )*)
            => {$(
                #[inline]
                fn $method( $( $arg : $ty ),* ) -> $ret {
                    <Self as $base>::$method( $( $arg ),* )
                }
            )*};
        ($( $imp:path as $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )*)
            => {$(
                #[inline]
                fn $method(self $( , $arg : $ty )* ) -> $ret {
                    $imp(self $( , $arg )* )
                }
            )*};
    }

    #[macro_export] macro_rules! constant
    {
        ($( $method:ident () -> $ret:expr ; )*)
            => {$(
                #[inline]
                fn $method() -> Self {
                    $ret
                }
            )*};
    }
    
    #[macro_export] macro_rules! forward_ref_ref_binop
    {
        (impl $imp:ident, $method:ident) => {
            impl<'a, 'b, T: Clone + Integer> $imp<&'b Ratio<T>> for &'a Ratio<T> {
                type Output = Ratio<T>;

                #[inline]
                fn $method(self, other: &'b Ratio<T>) -> Ratio<T> {
                    self.clone().$method(other.clone())
                }
            }
            impl<'a, 'b, T: Clone + Integer> $imp<&'b T> for &'a Ratio<T> {
                type Output = Ratio<T>;

                #[inline]
                fn $method(self, other: &'b T) -> Ratio<T> {
                    self.clone().$method(other.clone())
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_ref_val_binop
    {
        (impl $imp:ident, $method:ident) => {
            impl<'a, T> $imp<Ratio<T>> for &'a Ratio<T> where
                T: Clone + Integer,
            {
                type Output = Ratio<T>;

                #[inline]
                fn $method(self, other: Ratio<T>) -> Ratio<T> {
                    self.clone().$method(other)
                }
            }
            impl<'a, T> $imp<T> for &'a Ratio<T> where
                T: Clone + Integer,
            {
                type Output = Ratio<T>;

                #[inline]
                fn $method(self, other: T) -> Ratio<T> {
                    self.clone().$method(other)
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_val_ref_binop
    {
        (impl $imp:ident, $method:ident) => {
            impl<'a, T> $imp<&'a Ratio<T>> for Ratio<T> where
                T: Clone + Integer,
            {
                type Output = Ratio<T>;

                #[inline]
                fn $method(self, other: &Ratio<T>) -> Ratio<T> {
                    self.$method(other.clone())
                }
            }
            impl<'a, T> $imp<&'a T> for Ratio<T> where
                T: Clone + Integer,
            {
                type Output = Ratio<T>;

                #[inline]
                fn $method(self, other: &T) -> Ratio<T> {
                    self.$method(other.clone())
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_all_binop
    {
        (impl $imp:ident, $method:ident) => {
            forward_ref_ref_binop!(impl $imp, $method);
            forward_ref_val_binop!(impl $imp, $method);
            forward_val_ref_binop!(impl $imp, $method);
        };
    }
}

pub mod arch
{
    pub use std::arch::{ * };
}

pub mod ascii
{
    pub use std::ascii::{ * };
    
    const T: bool = true;
    const F: bool = false;

    #[repr(C, align(8))]
    pub struct Align8<T>(pub T);
    #[repr(C, align(64))]
    pub struct Align64<T>(pub T);

    pub static ASCII_START: Align64<[bool; 128]> = Align64
    ([
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ]);

    pub static ASCII_CONTINUE: Align64<[bool; 128]> = Align64
    ([
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, 
        F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, T, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ]);

    pub const CHUNK: usize = 64;

    pub static TRIE_START: Align8<[u8; 411]> = Align8
    ([
        0x04, 0x0B, 0x0F, 0x13, 0x17, 0x1B, 0x1F, 0x23, 0x27, 0x2D, 0x31, 0x34, 0x38, 0x3C, 0x40, 0x02, 0x45, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x4D, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x51, 0x54, 0x58, 0x5C, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x60, 
        0x64, 0x66, 0x6A, 0x6E, 0x72, 0x28, 0x76, 0x78, 0x7C, 0x80, 0x84, 0x88, 0x8C, 0x90, 0x94, 0x98, 0x9C, 0xA0, 
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xA8, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x00, 
        0x05, 0xB2, 0xB6, 0xBA, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xD1, 0xD3, 0x00, 0x00, 0x00, 0xC9, 0xD9, 0xDD, 0xE1, 0xE5, 0xE9, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7,
    ]);

    pub static TRIE_CONTINUE: Align8<[u8; 1793]> = Align8
    ([
        0x08, 0x0D, 0x11, 0x15, 0x19, 0x1D, 0x21, 0x25, 0x2A, 0x2F, 0x31, 0x36, 0x3A, 0x3E, 0x42, 0x02,0x47, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x4F, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x51, 0x56, 0x5A, 0x5E, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62, 
        0x64, 0x68,0x6C, 0x70, 0x74, 0x28, 0x76, 0x7A, 0x7E, 0x82, 0x86, 0x8A, 0x8E, 0x92, 0x96, 0x9A, 0x9E, 0xA2,
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xAB, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xB0, 0x00, 0x00, 0x00, 
        0x05, 0xB4, 0xB8, 0xBC, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xC3, 0xC6, 0xCE, 
        0xD1, 0xD5, 0x00, 0xD7, 0x00, 0xC9,0xDB, 0xDF, 0xE3, 0xE7, 0xEB, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xCC, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xCF,
    ]);

    pub static LEAF: Align64<[u8; 7968]> = Align64
    ([
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xAA, 
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x5F, 0xDC, 0x1F, 0xCF, 0x0F, 0xFF, 0x1F, 
        0xDC, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xA0, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 
        0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0xDF, 0xB8, 0x40, 0xD7, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xB8, 0xC0, 0xD7, 0xFF, 0xFF,
        0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
        0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0x87, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFB, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xB6, 0x00, 0xFF, 0xFF, 0xFF, 0x87, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC0, 0xFE, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2F, 0x00, 0x60, 0xC0, 0x00, 0x9C,
        0x00, 0x00, 0xFD, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x02, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x07, 0x30, 0x04,
        0x00, 0x00, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0x9F, 0xFF, 0xFD, 0xFF, 0x9F,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x24,
        0xFF, 0xFF, 0x3F, 0x04, 0x10, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0x01, 0xFF, 0x03, 0x00, 0xFE, 0xFF,
        0xE1, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0x23, 0x00, 0x40, 0x00, 0xB0, 0x03, 0x00, 0x03, 0x10,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFE, 0xFF,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0xF3, 0x9F, 0x79, 0x80, 0xB0, 0xCF, 0xFF, 0x03, 0x50,
        0xE0, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0x03, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x00, 0x1C, 0x00,
        0xE0, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x02,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x02, 0x00,
        0xE8, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEE, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0xD3, 0x87, 0x39, 0x02, 0x5E, 0xC0, 0xFF, 0x3F, 0x00,
        0xEE, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0xBF, 0x3B, 0x01, 0x00, 0xCF, 0xFF, 0x00, 0xFE,
        0xEE, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0x9F, 0x39, 0xE0, 0xB0, 0xCF, 0xFF, 0x02, 0x00,
        0xEC, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0xC3, 0xC7, 0x3D, 0x81, 0x00, 0xC0, 0xFF, 0x00, 0x00,
        0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0x23, 0x00, 0x00, 0x00, 0x37, 0x03, 0x00, 0x00, 0x00,
        0xE1, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x23, 0x00, 0x00, 0x00, 0x70, 0x03, 0x00, 0x06, 0x00,
        0xF0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x27, 0x00, 0x40, 0x70, 0x80, 0x03, 0x00, 0x00, 0xFC,
        0xE0, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0xF3, 0xDF, 0x3D, 0x60, 0x37, 0xCF, 0xFF, 0x00, 0x00,
        0xEF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0xF3, 0xDF, 0x3D, 0x60, 0x70, 0xCF, 0xFF, 0x0E, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x7D, 0xF0, 0x80, 0xCF, 0xFF, 0x00, 0xFC,
        0xEE, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x84, 0x5F, 0xFF, 0xC0, 0xFF, 0x0C, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0x05, 0x20, 0x5F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x7F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0xFF, 0x3F, 0x5F, 0x7F, 0xFF, 0xF3, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x03, 0xFF, 0x03, 0xA0, 0xC2, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0xFE, 0xFF,
        0xDF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x80, 0x00, 0x00, 0x3F, 0x3C, 0x62, 0xC0, 0xE1, 0xFF,
        0x03, 0x40, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0xFE, 0x03, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x03, 0x80, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xDF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF, 0x1F, 0x00, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xDF, 0x0D, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F, 0x30, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xB8, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x0F, 0xFF, 0x0F, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x01, 0xC0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x9F,
        0xFF, 0x03, 0xFF, 0x03, 0x80, 0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x0F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03, 0x00, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDE, 0x6F, 0x04,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x27, 0x00, 0xF0, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x1F, 0xE2, 0xFF, 0x01, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x78, 0x0C, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x80,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE6, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0x00, 0x0C, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xBF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xBB, 0xF7, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x68,
        0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x80, 0x00, 0x00, 0xDF, 0xFF, 0x00, 0x7C,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xE8,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x80, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0xF7, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0xC4,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x62, 0x3E, 0x05, 0x00, 0x00, 0x38, 0xFF, 0x07, 0x1C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0x7F, 0xFC,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x38, 0xFF, 0xFF, 0x7C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x37, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xA0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xE0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0xFF, 0xFF, 0x07, 0xC0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0xFF, 0x03, 0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07, 0xE0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0x3F, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x91, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x37, 0x00,
        0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x6F, 0xF0, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x87, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xBE, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1B, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x90, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x47, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x3F, 0x80,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x4F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xDE, 0xFF, 0x17, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0x0F, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0xE0, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x03,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xFB, 0x9F, 0x39, 0x81, 0xE0, 0xCF, 0x1F, 0x1F, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xA5, 0xF7, 0x0F, 0x00, 0x06, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x80, 0x07, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xC3, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x01, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0x0F, 0xFF, 0x03, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0xBF, 0xF9, 0x0F, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x1B, 0x00, 0x00, 0x00,
        0x01, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0x00, 0x01, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x20, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0x03,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x01, 0x00, 0xFF, 0x03, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFE, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xB4, 0xFF, 0x00, 0xFF, 0x03, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x7F, 0xFB, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xF4, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x07, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x0F, 0x00, 0xFF, 0x03, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x7C, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x80, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x6F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE3, 0x07, 0xF8,
        0xE7, 0x0F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xE0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xDF, 0x64, 0xDE, 0xFF, 0xEB, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xBF, 0xE7, 0xDF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7B, 0x5F, 0xFC, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x20, 0x00,
        0x10, 0x00, 0x00, 0xF8, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x3F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFF, 0xFF, 0xF9, 0xDB, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x3F, 0xFF, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xB7, 0x3F, 0x1F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x3F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEF, 0xFF, 0xFF, 0xFF, 0x96, 0xFE, 0xF7, 0x0A, 0x84, 0xEA, 0x96, 0xAA, 0x96, 0xF7, 0xF7, 0x5E,
        0xFF, 0xFB, 0xFF, 0x0F, 0xEE, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]);
}

pub mod backtrace
{
    pub use std::backtrace::{ * };
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod boxed
{
    pub use std::boxed::{ * };
}

pub mod cell
{
    pub use std::cell::{ * };
}

pub mod char
{
    pub use std::char::{ * };
}

pub mod clone
{
    pub use std::clone::{ * };
}

pub mod cmp
{
    pub use std::cmp::{ * };
}

pub mod collections
{
    pub use std::collections::{ * };
}

pub mod convert
{
    pub use std::convert::{ * };
}

pub mod default
{
    pub use std::default::{ * };
}

pub mod error
{
    pub use std::error::{ * };
}

pub mod f32
{
    pub use std::f32::{ * };
}

pub mod f64
{
    pub use std::f64::{ * };
}

pub mod ffi
{
    pub use std::ffi::{ * };
}

pub mod fmt
{
    pub use std::fmt::{ * };
}

pub mod hash
{
    pub use std::hash::{ * };
}

pub mod i8
{
    pub use std::i8::{ * };
}

pub mod i16
{
    pub use std::i16::{ * };
}

pub mod i32
{
    pub use std::i32::{ * };
}

pub mod i64
{
    pub use std::i64::{ * };
}

pub mod isize
{
    pub use std::isize::{ * };
}

pub mod i128
{
    pub use std::i128::{ * };
}

pub mod io
{
    pub use std::io::{ * };
}

pub mod is
{
    use ::
    {
        *,
    };
    /// Whether the character has the Unicode property XID\_Start.
    /*
    pub fn is_xid_start( ... ) -> bool*/
    pub fn xid_start( ch:char ) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_START.0[ch as usize]; }
        let chunk = * ::ascii::TRIE_START.0.get(ch as usize / 8 / ::ascii::CHUNK).unwrap_or(&0);
        let offset = chunk as usize *  ::ascii::CHUNK / 2 + ch as usize / 8 %  ::ascii::CHUNK;
        unsafe {  ::ascii::LEAF.0.get_unchecked(offset) }.wrapping_shr(ch as u32 % 8) & 1 != 0
    }
    /// Whether the character has the Unicode property XID\_Continue.
    /*
    pub fn is_xid_continue(ch: char) -> bool */
    pub fn xid_continue(ch: char) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_CONTINUE.0[ch as usize]; }
        let chunk = *::ascii::TRIE_CONTINUE.0.get(ch as usize / 8 / ::ascii::CHUNK).unwrap_or(&0);
        let offset = chunk as usize * ::ascii::CHUNK / 2 + ch as usize / 8 % ::ascii::CHUNK;
        unsafe { ::ascii::LEAF.0.get_unchecked(offset) }.wrapping_shr(ch as u32 % 8) & 1 != 0
    }
    /*
    fn is_whitespace(ch: char) -> bool*/
    pub fn whitespace(ch: char) -> bool
    {
        ch.is_whitespace() || ch == '\u{200e}' || ch == '\u{200f}'
    }
    /*
    pub fn is_ident_start(c: char) -> bool*/
    pub fn ident_start(c: char) -> bool
    {
        c == '_' || ::is::xid_start(c)
    }
    /*
    pub fn is_ident_continue(c: char) -> bool */
    pub fn ident_continue(c: char) -> bool
    {
        xid_continue(c)
    }
}

pub mod iter
{
    pub use std::iter::{ * };
}

pub mod marker
{
    pub use std::marker::{ * };
    use ::
    {
        rc::{ Rc },
        panic::{ RefUnwindSafe, UnwindSafe },
        *,
    };
    /*
    use alloc::rc::Rc;
    use ::marker::PhantomData;
    use ::panic::{RefUnwindSafe, UnwindSafe};
    */
    pub const MARKER: ProcMacroAutoTraits = ProcMacroAutoTraits(PhantomData);
    /// Zero sized marker with the correct set of autotrait impls we want all proc macro types to have.
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct ProcMacroAutoTraits( pub PhantomData<Rc<()>> );
    impl UnwindSafe for ProcMacroAutoTraits {}
    impl RefUnwindSafe for ProcMacroAutoTraits {}
}

pub mod num
{
    pub use std::num::{ * };
    use ::
    {
        *,
    };
    /*
    */
    pub mod traits
    {
        //! Numeric traits for generic mathematics
        use ::
        {
            num::{ Wrapping },
            ops::{ Add, Div, Mul, Rem, Sub, AddAssign, DivAssign, MulAssign, RemAssign, SubAssign },
            *,
        };
        /*
        */
        pub mod bounds
        {
            use ::
            {
                num::
                {
                    NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize, NonZeroU128,
                    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize,
                },
                *,
            };
            /*
            */
            /// Numbers which have upper and lower bounds
            pub trait Bounded
            {
               
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }
            /// Numbers which have lower bounds
            pub trait LowerBounded
            {
                /// Returns the smallest finite number this type can represent
                fn min_value() -> Self;
            }
           
            impl<T: Bounded> LowerBounded for T
            {
                fn min_value() -> T {
                    Bounded::min_value()
                }
            }
            /// Numbers which have upper bounds
            pub trait UpperBounded
            {
                /// Returns the largest finite number this type can represent
                fn max_value() -> Self;
            }
           
            impl<T: Bounded> UpperBounded for T
            {
                fn max_value() -> T {
                    Bounded::max_value()
                }
            }

            macro_rules! bounded_impl
            {
                ($t:ty, $min:expr, $max:expr) =>
                {
                    impl Bounded for $t {
                        #[inline]
                        fn min_value() -> $t {
                            $min
                        }

                        #[inline]
                        fn max_value() -> $t {
                            $max
                        }
                    }
                };
            }

            bounded_impl!(usize, usize::MIN, usize::MAX);
            bounded_impl!(u8, u8::MIN, u8::MAX);
            bounded_impl!(u16, u16::MIN, u16::MAX);
            bounded_impl!(u32, u32::MIN, u32::MAX);
            bounded_impl!(u64, u64::MIN, u64::MAX);
            bounded_impl!(u128, u128::MIN, u128::MAX);

            bounded_impl!(isize, isize::MIN, isize::MAX);
            bounded_impl!(i8, i8::MIN, i8::MAX);
            bounded_impl!(i16, i16::MIN, i16::MAX);
            bounded_impl!(i32, i32::MIN, i32::MAX);
            bounded_impl!(i64, i64::MIN, i64::MAX);
            bounded_impl!(i128, i128::MIN, i128::MAX);

            macro_rules! bounded_impl_nonzero_const 
            {
                ($t:ty, $v:expr, $i:ident) => {
                    const $i: $t = match <$t>::new($v) {
                        Some(nz) => nz,
                        None => panic!("bad nonzero bound!"),
                    };
                };
            }

            macro_rules! bounded_impl_nonzero 
            {
                ($t:ty, $min:expr, $max:expr) => {
                    impl Bounded for $t {
                        #[inline]
                        fn min_value() -> $t {
                           
                            bounded_impl_nonzero_const!($t, $min, MIN);
                            MIN
                        }

                        #[inline]
                        fn max_value() -> $t {
                           
                            bounded_impl_nonzero_const!($t, $max, MAX);
                            MAX
                        }
                    }
                };
            }

            bounded_impl_nonzero!(NonZeroUsize, 1, usize::MAX);
            bounded_impl_nonzero!(NonZeroU8, 1, u8::MAX);
            bounded_impl_nonzero!(NonZeroU16, 1, u16::MAX);
            bounded_impl_nonzero!(NonZeroU32, 1, u32::MAX);
            bounded_impl_nonzero!(NonZeroU64, 1, u64::MAX);
            bounded_impl_nonzero!(NonZeroU128, 1, u128::MAX);

            bounded_impl_nonzero!(NonZeroIsize, isize::MIN, isize::MAX);
            bounded_impl_nonzero!(NonZeroI8, i8::MIN, i8::MAX);
            bounded_impl_nonzero!(NonZeroI16, i16::MIN, i16::MAX);
            bounded_impl_nonzero!(NonZeroI32, i32::MIN, i32::MAX);
            bounded_impl_nonzero!(NonZeroI64, i64::MIN, i64::MAX);
            bounded_impl_nonzero!(NonZeroI128, i128::MIN, i128::MAX);

            impl<T: Bounded> Bounded for Wrapping<T> 
            {
                fn min_value() -> Self {
                    Wrapping(T::min_value())
                }
                fn max_value() -> Self {
                    Wrapping(T::max_value())
                }
            }

            bounded_impl!(f32, f32::MIN, f32::MAX);

            macro_rules! for_each_tuple_ 
            {
                ( $m:ident !! ) => (
                    $m! { }
                );
                ( $m:ident !! $h:ident, $($t:ident,)* ) => (
                    $m! { $h $($t)* }
                    for_each_tuple_! { $m !! $($t,)* }
                );
            }

            macro_rules! for_each_tuple 
            {
                ($m:ident) => {
                    for_each_tuple_! { $m !! A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, }
                };
            }

            macro_rules! bounded_tuple 
            {
                ( $($name:ident)* ) => (
                    impl<$($name: Bounded,)*> Bounded for ($($name,)*) {
                        #[inline]
                        fn min_value() -> Self {
                            ($($name::min_value(),)*)
                        }
                        #[inline]
                        fn max_value() -> Self {
                            ($($name::max_value(),)*)
                        }
                    }
                );
            }

            for_each_tuple!(bounded_tuple);
            bounded_impl!(f64, f64::MIN, f64::MAX);
        } pub use self::bounds::Bounded;

        pub mod cast
        {
            use ::
            {
                mem::{ size_of },
                num::
                {
                    NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize, NonZeroU128,
                    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize, Wrapping,
                },
                *,
            };
            /*
            */
            /// A generic trait for converting a value to a number.
            pub trait ToPrimitive {
                /// Converts the value of `self` to an `isize`. If the value cannot be
                /// represented by an `isize`, then `None` is returned.
                #[inline]
                fn to_isize(&self) -> Option<isize> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_isize)
                }

                /// Converts the value of `self` to an `i8`. If the value cannot be
                /// represented by an `i8`, then `None` is returned.
                #[inline]
                fn to_i8(&self) -> Option<i8> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i8)
                }

                /// Converts the value of `self` to an `i16`. If the value cannot be
                /// represented by an `i16`, then `None` is returned.
                #[inline]
                fn to_i16(&self) -> Option<i16> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i16)
                }

                /// Converts the value of `self` to an `i32`. If the value cannot be
                /// represented by an `i32`, then `None` is returned.
                #[inline]
                fn to_i32(&self) -> Option<i32> {
                    self.to_i64().as_ref().and_then(ToPrimitive::to_i32)
                }

                /// Converts the value of `self` to an `i64`. If the value cannot be
                /// represented by an `i64`, then `None` is returned.
                fn to_i64(&self) -> Option<i64>;

                /// Converts the value of `self` to an `i128`. If the value cannot be
                /// represented by an `i128` (`i64` under the default implementation), then
                /// `None` is returned.
                ///
                /// The default implementation converts through `to_i64()`. Types implementing
                /// this trait should override this method if they can represent a greater range.
                #[inline]
                fn to_i128(&self) -> Option<i128> {
                    self.to_i64().map(From::from)
                }

                /// Converts the value of `self` to a `usize`. If the value cannot be
                /// represented by a `usize`, then `None` is returned.
                #[inline]
                fn to_usize(&self) -> Option<usize> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_usize)
                }

                /// Converts the value of `self` to a `u8`. If the value cannot be
                /// represented by a `u8`, then `None` is returned.
                #[inline]
                fn to_u8(&self) -> Option<u8> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u8)
                }

                /// Converts the value of `self` to a `u16`. If the value cannot be
                /// represented by a `u16`, then `None` is returned.
                #[inline]
                fn to_u16(&self) -> Option<u16> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u16)
                }

                /// Converts the value of `self` to a `u32`. If the value cannot be
                /// represented by a `u32`, then `None` is returned.
                #[inline]
                fn to_u32(&self) -> Option<u32> {
                    self.to_u64().as_ref().and_then(ToPrimitive::to_u32)
                }

                /// Converts the value of `self` to a `u64`. If the value cannot be
                /// represented by a `u64`, then `None` is returned.
                fn to_u64(&self) -> Option<u64>;

                /// Converts the value of `self` to a `u128`. If the value cannot be
                /// represented by a `u128` (`u64` under the default implementation), then
                /// `None` is returned.
                ///
                /// The default implementation converts through `to_u64()`. Types implementing
                /// this trait should override this method if they can represent a greater range.
                #[inline]
                fn to_u128(&self) -> Option<u128> {
                    self.to_u64().map(From::from)
                }

                /// Converts the value of `self` to an `f32`. Overflows may map to positive
                /// or negative inifinity, otherwise `None` is returned if the value cannot
                /// be represented by an `f32`.
                #[inline]
                fn to_f32(&self) -> Option<f32> {
                    self.to_f64().as_ref().and_then(ToPrimitive::to_f32)
                }

                /// Converts the value of `self` to an `f64`. Overflows may map to positive
                /// or negative inifinity, otherwise `None` is returned if the value cannot
                /// be represented by an `f64`.
                ///
                /// The default implementation tries to convert through `to_i64()`, and
                /// failing that through `to_u64()`. Types implementing this trait should
                /// override this method if they can represent a greater range.
                #[inline]
                fn to_f64(&self) -> Option<f64> {
                    match self.to_i64() {
                        Some(i) => i.to_f64(),
                        None => self.to_u64().as_ref().and_then(ToPrimitive::to_f64),
                    }
                }
            }

            macro_rules! impl_to_primitive_int_to_int {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        let min = $DstT::MIN as $SrcT;
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || (min <= *self && *self <= max) {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_int_to_uint {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if 0 <= *self && (size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max) {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_int {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_int_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_int_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline]
                        fn to_f32(&self) -> Option<f32> {
                            Some(*self as f32)
                        }
                        #[inline]
                        fn to_f64(&self) -> Option<f64> {
                            Some(*self as f64)
                        }
                    }
                };
            }

            impl_to_primitive_int!(isize);
            impl_to_primitive_int!(i8);
            impl_to_primitive_int!(i16);
            impl_to_primitive_int!(i32);
            impl_to_primitive_int!(i64);
            impl_to_primitive_int!(i128);

            macro_rules! impl_to_primitive_uint_to_int {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_uint_to_uint {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {
                            Some(*self as $DstT)
                        } else {
                            None
                        }
                    }
                )*}
            }

            macro_rules! impl_to_primitive_uint {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_uint_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_uint_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline]
                        fn to_f32(&self) -> Option<f32> {
                            Some(*self as f32)
                        }
                        #[inline]
                        fn to_f64(&self) -> Option<f64> {
                            Some(*self as f64)
                        }
                    }
                };
            }

            impl_to_primitive_uint!(usize);
            impl_to_primitive_uint!(u8);
            impl_to_primitive_uint!(u16);
            impl_to_primitive_uint!(u32);
            impl_to_primitive_uint!(u64);
            impl_to_primitive_uint!(u128);

            macro_rules! impl_to_primitive_nonzero_to_method {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                        self.get().$method()
                    }
                )*}
            }

            macro_rules! impl_to_primitive_nonzero {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_nonzero_to_method! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;

                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;

                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }

            impl_to_primitive_nonzero!(NonZeroUsize);
            impl_to_primitive_nonzero!(NonZeroU8);
            impl_to_primitive_nonzero!(NonZeroU16);
            impl_to_primitive_nonzero!(NonZeroU32);
            impl_to_primitive_nonzero!(NonZeroU64);
            impl_to_primitive_nonzero!(NonZeroU128);

            impl_to_primitive_nonzero!(NonZeroIsize);
            impl_to_primitive_nonzero!(NonZeroI8);
            impl_to_primitive_nonzero!(NonZeroI16);
            impl_to_primitive_nonzero!(NonZeroI32);
            impl_to_primitive_nonzero!(NonZeroI64);
            impl_to_primitive_nonzero!(NonZeroI128);

            macro_rules! impl_to_primitive_float_to_float {
                ($SrcT:ident : $( fn $method:ident -> $DstT:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$DstT> {
                       
                       
                        Some(*self as $DstT)
                    }
                )*}
            }

            macro_rules! float_to_int_unchecked {
               
               
                ($float:expr => $int:ty) => {
                    unsafe { $float.to_int_unchecked::<$int>() }
                };
            }

            macro_rules! impl_to_primitive_float_to_signed_int {
                ($f:ident : $( fn $method:ident -> $i:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$i> {
                       
                       
                        if size_of::<$f>() > size_of::<$i>() {
                           
                            const MIN_M1: $f = $i::MIN as $f - 1.0;
                            const MAX_P1: $f = $i::MAX as $f + 1.0;
                            if *self > MIN_M1 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $i));
                            }
                        } else {
                           
                           
                            const MIN: $f = $i::MIN as $f;
                           
                           
                            const MAX_P1: $f = $i::MAX as $f;
                            if *self >= MIN && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $i));
                            }
                        }
                        None
                    }
                )*}
            }

            macro_rules! impl_to_primitive_float_to_unsigned_int {
                ($f:ident : $( fn $method:ident -> $u:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$u> {
                       
                       
                        if size_of::<$f>() > size_of::<$u>() {
                           
                            const MAX_P1: $f = $u::MAX as $f + 1.0;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $u));
                            }
                        } else {
                           
                           
                           
                            const MAX_P1: $f = $u::MAX as $f;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some(float_to_int_unchecked!(*self => $u));
                            }
                        }
                        None
                    }
                )*}
            }

            macro_rules! impl_to_primitive_float {
                ($T:ident) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_float_to_signed_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }

                        impl_to_primitive_float_to_unsigned_int! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        impl_to_primitive_float_to_float! { $T:
                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }

            impl_to_primitive_float!(f32);
            impl_to_primitive_float!(f64);
            /// A generic trait for converting a number to a value.
            pub trait FromPrimitive: Sized {
                /// Converts an `isize` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_isize(n: isize) -> Option<Self> {
                    n.to_i64().and_then(FromPrimitive::from_i64)
                }

                /// Converts an `i8` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_i8(n: i8) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }

                /// Converts an `i16` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_i16(n: i16) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }

                /// Converts an `i32` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_i32(n: i32) -> Option<Self> {
                    FromPrimitive::from_i64(From::from(n))
                }

                /// Converts an `i64` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                fn from_i64(n: i64) -> Option<Self>;

                /// Converts an `i128` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                ///
                /// The default implementation converts through `from_i64()`. Types implementing
                /// this trait should override this method if they can represent a greater range.
                #[inline]
                fn from_i128(n: i128) -> Option<Self> {
                    n.to_i64().and_then(FromPrimitive::from_i64)
                }

                /// Converts a `usize` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_usize(n: usize) -> Option<Self> {
                    n.to_u64().and_then(FromPrimitive::from_u64)
                }

                /// Converts an `u8` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_u8(n: u8) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }

                /// Converts an `u16` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_u16(n: u16) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }

                /// Converts an `u32` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_u32(n: u32) -> Option<Self> {
                    FromPrimitive::from_u64(From::from(n))
                }

                /// Converts an `u64` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                fn from_u64(n: u64) -> Option<Self>;

                /// Converts an `u128` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                ///
                /// The default implementation converts through `from_u64()`. Types implementing
                /// this trait should override this method if they can represent a greater range.
                #[inline]
                fn from_u128(n: u128) -> Option<Self> {
                    n.to_u64().and_then(FromPrimitive::from_u64)
                }

                /// Converts a `f32` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                #[inline]
                fn from_f32(n: f32) -> Option<Self> {
                    FromPrimitive::from_f64(From::from(n))
                }

                /// Converts a `f64` to return an optional value of this type. If the
                /// value cannot be represented by this type, then `None` is returned.
                ///
                /// The default implementation tries to convert through `from_i64()`, and
                /// failing that through `from_u64()`. Types implementing this trait should
                /// override this method if they can represent a greater range.
                #[inline]
                fn from_f64(n: f64) -> Option<Self> {
                    match n.to_i64() {
                        Some(i) => FromPrimitive::from_i64(i),
                        None => n.to_u64().and_then(FromPrimitive::from_u64),
                    }
                }
            }

            macro_rules! impl_from_primitive {
                ($T:ty, $to_ty:ident) => {
                    impl FromPrimitive for $T {
                        #[inline]
                        fn from_isize(n: isize) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i8(n: i8) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i16(n: i16) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i32(n: i32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i64(n: i64) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_i128(n: i128) -> Option<$T> {
                            n.$to_ty()
                        }

                        #[inline]
                        fn from_usize(n: usize) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u8(n: u8) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u16(n: u16) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u32(n: u32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u64(n: u64) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_u128(n: u128) -> Option<$T> {
                            n.$to_ty()
                        }

                        #[inline]
                        fn from_f32(n: f32) -> Option<$T> {
                            n.$to_ty()
                        }
                        #[inline]
                        fn from_f64(n: f64) -> Option<$T> {
                            n.$to_ty()
                        }
                    }
                };
            }

            impl_from_primitive!(isize, to_isize);
            impl_from_primitive!(i8, to_i8);
            impl_from_primitive!(i16, to_i16);
            impl_from_primitive!(i32, to_i32);
            impl_from_primitive!(i64, to_i64);
            impl_from_primitive!(i128, to_i128);
            impl_from_primitive!(usize, to_usize);
            impl_from_primitive!(u8, to_u8);
            impl_from_primitive!(u16, to_u16);
            impl_from_primitive!(u32, to_u32);
            impl_from_primitive!(u64, to_u64);
            impl_from_primitive!(u128, to_u128);
            impl_from_primitive!(f32, to_f32);
            impl_from_primitive!(f64, to_f64);

            macro_rules! impl_from_primitive_nonzero {
                ($T:ty, $to_ty:ident) => {
                    impl FromPrimitive for $T {
                        #[inline]
                        fn from_isize(n: isize) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i8(n: i8) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i16(n: i16) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i32(n: i32) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i64(n: i64) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_i128(n: i128) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }

                        #[inline]
                        fn from_usize(n: usize) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u8(n: u8) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u16(n: u16) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u32(n: u32) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u64(n: u64) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_u128(n: u128) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }

                        #[inline]
                        fn from_f32(n: f32) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                        #[inline]
                        fn from_f64(n: f64) -> Option<$T> {
                            n.$to_ty().and_then(Self::new)
                        }
                    }
                };
            }

            impl_from_primitive_nonzero!(NonZeroIsize, to_isize);
            impl_from_primitive_nonzero!(NonZeroI8, to_i8);
            impl_from_primitive_nonzero!(NonZeroI16, to_i16);
            impl_from_primitive_nonzero!(NonZeroI32, to_i32);
            impl_from_primitive_nonzero!(NonZeroI64, to_i64);
            impl_from_primitive_nonzero!(NonZeroI128, to_i128);
            impl_from_primitive_nonzero!(NonZeroUsize, to_usize);
            impl_from_primitive_nonzero!(NonZeroU8, to_u8);
            impl_from_primitive_nonzero!(NonZeroU16, to_u16);
            impl_from_primitive_nonzero!(NonZeroU32, to_u32);
            impl_from_primitive_nonzero!(NonZeroU64, to_u64);
            impl_from_primitive_nonzero!(NonZeroU128, to_u128);

            macro_rules! impl_to_primitive_wrapping {
                ($( fn $method:ident -> $i:ident ; )*) => {$(
                    #[inline]
                    fn $method(&self) -> Option<$i> {
                        (self.0).$method()
                    }
                )*}
            }

            impl<T: ToPrimitive> ToPrimitive for Wrapping<T> {
                impl_to_primitive_wrapping! {
                    fn to_isize -> isize;
                    fn to_i8 -> i8;
                    fn to_i16 -> i16;
                    fn to_i32 -> i32;
                    fn to_i64 -> i64;
                    fn to_i128 -> i128;

                    fn to_usize -> usize;
                    fn to_u8 -> u8;
                    fn to_u16 -> u16;
                    fn to_u32 -> u32;
                    fn to_u64 -> u64;
                    fn to_u128 -> u128;

                    fn to_f32 -> f32;
                    fn to_f64 -> f64;
                }
            }

            macro_rules! impl_from_primitive_wrapping {
                ($( fn $method:ident ( $i:ident ); )*) => {$(
                    #[inline]
                    fn $method(n: $i) -> Option<Self> {
                        T::$method(n).map(Wrapping)
                    }
                )*}
            }

            impl<T: FromPrimitive> FromPrimitive for Wrapping<T> {
                impl_from_primitive_wrapping! {
                    fn from_isize(isize);
                    fn from_i8(i8);
                    fn from_i16(i16);
                    fn from_i32(i32);
                    fn from_i64(i64);
                    fn from_i128(i128);

                    fn from_usize(usize);
                    fn from_u8(u8);
                    fn from_u16(u16);
                    fn from_u32(u32);
                    fn from_u64(u64);
                    fn from_u128(u128);

                    fn from_f32(f32);
                    fn from_f64(f64);
                }
            }
            /// Cast from one machine scalar to another.
            ///
            #[inline]
            pub fn cast<T: NumCast, U: NumCast>(n: T) -> Option<U> {
                NumCast::from(n)
            }
            /// An interface for casting between machine scalars.
            pub trait NumCast: Sized + ToPrimitive {
                /// Creates a number from another value that can be converted into
                /// a primitive via the `ToPrimitive` trait. If the source value cannot be
                /// represented by the target type, then `None` is returned.
                ///
                /// A value can be represented by the target type when it lies within
                /// the range of scalars supported by the target type.
                /// For example, a negative integer cannot be represented by an unsigned
                /// integer type, and an `i64` with a very high magnitude might not be
                /// convertible to an `i32`.
                /// On the other hand, conversions with possible precision loss or truncation
                /// are admitted, like an `f32` with a decimal part to an integer type, or
                /// even a large `f64` saturating to `f32` infinity.
                fn from<T: ToPrimitive>(n: T) -> Option<Self>;
            }

            macro_rules! impl_num_cast {
                ($T:ty, $conv:ident) => {
                    impl NumCast for $T {
                        #[inline]
                        fn from<N: ToPrimitive>(n: N) -> Option<$T> {
                            n.$conv()
                        }
                    }
                };
            }

            impl_num_cast!(u8, to_u8);
            impl_num_cast!(u16, to_u16);
            impl_num_cast!(u32, to_u32);
            impl_num_cast!(u64, to_u64);
            impl_num_cast!(u128, to_u128);
            impl_num_cast!(usize, to_usize);
            impl_num_cast!(i8, to_i8);
            impl_num_cast!(i16, to_i16);
            impl_num_cast!(i32, to_i32);
            impl_num_cast!(i64, to_i64);
            impl_num_cast!(i128, to_i128);
            impl_num_cast!(isize, to_isize);
            impl_num_cast!(f32, to_f32);
            impl_num_cast!(f64, to_f64);

            macro_rules! impl_num_cast_nonzero {
                ($T:ty, $conv:ident) => {
                    impl NumCast for $T {
                        #[inline]
                        fn from<N: ToPrimitive>(n: N) -> Option<$T> {
                            n.$conv().and_then(Self::new)
                        }
                    }
                };
            }

            impl_num_cast_nonzero!(NonZeroUsize, to_usize);
            impl_num_cast_nonzero!(NonZeroU8, to_u8);
            impl_num_cast_nonzero!(NonZeroU16, to_u16);
            impl_num_cast_nonzero!(NonZeroU32, to_u32);
            impl_num_cast_nonzero!(NonZeroU64, to_u64);
            impl_num_cast_nonzero!(NonZeroU128, to_u128);

            impl_num_cast_nonzero!(NonZeroIsize, to_isize);
            impl_num_cast_nonzero!(NonZeroI8, to_i8);
            impl_num_cast_nonzero!(NonZeroI16, to_i16);
            impl_num_cast_nonzero!(NonZeroI32, to_i32);
            impl_num_cast_nonzero!(NonZeroI64, to_i64);
            impl_num_cast_nonzero!(NonZeroI128, to_i128);

            impl<T: NumCast> NumCast for Wrapping<T>
            {
                fn from<U: ToPrimitive>(n: U) -> Option<Self> {
                    T::from(n).map(Wrapping)
                }
            }
            /// Generic interface for casting between machine scalars with the `as` operator, 
            /// which admits narrowing and precision loss.
            pub trait AsPrimitive<T>: 'static + Copy where
            T: 'static + Copy,
            {
                /// Convert a value to another, using the `as` operator.
                fn as_(self) -> T;
            }

            macro_rules! impl_as_primitive {
                (@ $T: ty =>  impl $U: ty ) => {
                    impl AsPrimitive<$U> for $T {
                        #[inline] fn as_(self) -> $U { self as $U }
                    }
                };
                (@ $T: ty => { $( $U: ty ),* } ) => {$(
                    impl_as_primitive!(@ $T => impl $U);
                )*};
                ($T: ty => { $( $U: ty ),* } ) => {
                    impl_as_primitive!(@ $T => { $( $U ),* });
                    impl_as_primitive!(@ $T => { u8, u16, u32, u64, u128, usize });
                    impl_as_primitive!(@ $T => { i8, i16, i32, i64, i128, isize });
                };
            }

            impl_as_primitive!(u8 => { char, f32, f64 });
            impl_as_primitive!(i8 => { f32, f64 });
            impl_as_primitive!(u16 => { f32, f64 });
            impl_as_primitive!(i16 => { f32, f64 });
            impl_as_primitive!(u32 => { f32, f64 });
            impl_as_primitive!(i32 => { f32, f64 });
            impl_as_primitive!(u64 => { f32, f64 });
            impl_as_primitive!(i64 => { f32, f64 });
            impl_as_primitive!(u128 => { f32, f64 });
            impl_as_primitive!(i128 => { f32, f64 });
            impl_as_primitive!(usize => { f32, f64 });
            impl_as_primitive!(isize => { f32, f64 });
            impl_as_primitive!(f32 => { f32, f64 });
            impl_as_primitive!(f64 => { f32, f64 });
            impl_as_primitive!(char => { char });
            impl_as_primitive!(bool => {});

        } pub use self::cast::{cast, AsPrimitive, FromPrimitive, NumCast, ToPrimitive};

        pub mod float
        {
            use ::
            {
                cmp::{ Ordering },
                num::
                {
                    traits::{ Num, NumCast, ToPrimitive },
                    FpCategory
                },
                ops::{ Add, Div, Neg },
                *,
            };
            /*
            */
            /// Generic trait for floating point numbers that works with `no_std`.
            pub trait FloatCore: Num + NumCast + Neg<Output = Self> + PartialOrd + Copy {
                /// Returns positive infinity.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::infinity() == x);
                /// }
                ///
                /// check(f32::INFINITY);
                /// check(f64::INFINITY);
                /// ```
                fn infinity() -> Self;

                /// Returns negative infinity.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::neg_infinity() == x);
                /// }
                ///
                /// check(f32::NEG_INFINITY);
                /// check(f64::NEG_INFINITY);
                /// ```
                fn neg_infinity() -> Self;

                /// Returns NaN.
                /// use num_traits::float::FloatCore;
                ///
                /// fn check<T: FloatCore>() {
                ///     let n = T::nan();
                ///     assert!(n != n);
                /// }
                ///
                /// check::<f32>();
                /// check::<f64>();
                /// ```
                fn nan() -> Self;

                /// Returns `-0.0`.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(n: T) {
                ///     let z = T::neg_zero();
                ///     assert!(z.is_zero());
                ///     assert!(T::one() / z == n);
                /// }
                ///
                /// check(f32::NEG_INFINITY);
                /// check(f64::NEG_INFINITY);
                /// ```
                fn neg_zero() -> Self;

                /// Returns the smallest finite value that this type can represent.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::min_value() == x);
                /// }
                ///
                /// check(f32::MIN);
                /// check(f64::MIN);
                /// ```
                fn min_value() -> Self;

                /// Returns the smallest positive, normalized value that this type can represent.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::min_positive_value() == x);
                /// }
                ///
                /// check(f32::MIN_POSITIVE);
                /// check(f64::MIN_POSITIVE);
                /// ```
                fn min_positive_value() -> Self;

                /// Returns epsilon, a small positive value.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::epsilon() == x);
                /// }
                ///
                /// check(f32::EPSILON);
                /// check(f64::EPSILON);
                /// ```
                fn epsilon() -> Self;

                /// Returns the largest finite value that this type can represent.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T) {
                ///     assert!(T::max_value() == x);
                /// }
                ///
                /// check(f32::MAX);
                /// check(f64::MAX);
                /// ```
                fn max_value() -> Self;

                /// Returns `true` if the number is NaN.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_nan() == p);
                /// }
                ///
                /// check(f32::NAN, true);
                /// check(f32::INFINITY, false);
                /// check(f64::NAN, true);
                /// check(0.0f64, false);
                /// ```
                #[inline]
                #[allow(clippy::eq_op)]
                fn is_nan(self) -> bool {
                    self != self
                }

                /// Returns `true` if the number is infinite.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_infinite() == p);
                /// }
                ///
                /// check(f32::INFINITY, true);
                /// check(f32::NEG_INFINITY, true);
                /// check(f32::NAN, false);
                /// check(f64::INFINITY, true);
                /// check(f64::NEG_INFINITY, true);
                /// check(0.0f64, false);
                /// ```
                #[inline]
                fn is_infinite(self) -> bool {
                    self == Self::infinity() || self == Self::neg_infinity()
                }

                /// Returns `true` if the number is neither infinite or NaN.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_finite() == p);
                /// }
                ///
                /// check(f32::INFINITY, false);
                /// check(f32::MAX, true);
                /// check(f64::NEG_INFINITY, false);
                /// check(f64::MIN_POSITIVE, true);
                /// check(f64::NAN, false);
                /// ```
                #[inline]
                fn is_finite(self) -> bool {
                    !(self.is_nan() || self.is_infinite())
                }

                /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_normal() == p);
                /// }
                ///
                /// check(f32::INFINITY, false);
                /// check(f32::MAX, true);
                /// check(f64::NEG_INFINITY, false);
                /// check(f64::MIN_POSITIVE, true);
                /// check(0.0f64, false);
                /// ```
                #[inline]
                fn is_normal(self) -> bool {
                    self.classify() == FpCategory::Normal
                }

                /// Returns `true` if the number is [subnormal].
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use ::f64;
                ///
                /// let min = f64::MIN_POSITIVE;
                /// let max = f64::MAX;
                /// let lower_than_min = 1.0e-308_f64;
                /// let zero = 0.0_f64;
                ///
                /// assert!(!min.is_subnormal());
                /// assert!(!max.is_subnormal());
                ///
                /// assert!(!zero.is_subnormal());
                /// assert!(!f64::NAN.is_subnormal());
                /// assert!(!f64::INFINITY.is_subnormal());
                ///
                /// assert!(lower_than_min.is_subnormal());
                /// ```
                /// [subnormal]: https://en.wikipedia.org/wiki/Subnormal_number
                #[inline]
                fn is_subnormal(self) -> bool {
                    self.classify() == FpCategory::Subnormal
                }

                /// Returns the floating point category of the number. If only one property
                /// is going to be tested, it is generally faster to use the specific
                /// predicate instead.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                /// use ::num::FpCategory;
                ///
                /// fn check<T: FloatCore>(x: T, c: FpCategory) {
                ///     assert!(x.classify() == c);
                /// }
                ///
                /// check(f32::INFINITY, FpCategory::Infinite);
                /// check(f32::MAX, FpCategory::Normal);
                /// check(f64::NAN, FpCategory::Nan);
                /// check(f64::MIN_POSITIVE, FpCategory::Normal);
                /// check(f64::MIN_POSITIVE / 2.0, FpCategory::Subnormal);
                /// check(0.0f64, FpCategory::Zero);
                /// ```
                fn classify(self) -> FpCategory;

                /// Returns the largest integer less than or equal to a number.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.floor() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(0.9f32, 0.0);
                /// check(1.0f32, 1.0);
                /// check(1.1f32, 1.0);
                /// check(-0.0f64, 0.0);
                /// check(-0.9f64, -1.0);
                /// check(-1.0f64, -1.0);
                /// check(-1.1f64, -2.0);
                /// check(f64::MIN, f64::MIN);
                /// ```
                #[inline]
                fn floor(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self < Self::zero() {
                        self - f - Self::one()
                    } else {
                        self - f
                    }
                }

                /// Returns the smallest integer greater than or equal to a number.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.ceil() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(0.9f32, 1.0);
                /// check(1.0f32, 1.0);
                /// check(1.1f32, 2.0);
                /// check(-0.0f64, 0.0);
                /// check(-0.9f64, -0.0);
                /// check(-1.0f64, -1.0);
                /// check(-1.1f64, -1.0);
                /// check(f64::MIN, f64::MIN);
                /// ```
                #[inline]
                fn ceil(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        self - f + Self::one()
                    } else {
                        self - f
                    }
                }

                /// Returns the nearest integer to a number. Round half-way cases away from `0.0`.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.round() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(0.4f32, 0.0);
                /// check(0.5f32, 1.0);
                /// check(0.6f32, 1.0);
                /// check(-0.4f64, 0.0);
                /// check(-0.5f64, -1.0);
                /// check(-0.6f64, -1.0);
                /// check(f64::MIN, f64::MIN);
                /// ```
                #[inline]
                fn round(self) -> Self {
                    let one = Self::one();
                    let h = Self::from(0.5).expect("Unable to cast from 0.5");
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        if f < h {
                            self - f
                        } else {
                            self - f + one
                        }
                    } else if -f < h {
                        self - f
                    } else {
                        self - f - one
                    }
                }

                /// Return the integer part of a number.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.trunc() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(0.9f32, 0.0);
                /// check(1.0f32, 1.0);
                /// check(1.1f32, 1.0);
                /// check(-0.0f64, 0.0);
                /// check(-0.9f64, -0.0);
                /// check(-1.0f64, -1.0);
                /// check(-1.1f64, -1.0);
                /// check(f64::MIN, f64::MIN);
                /// ```
                #[inline]
                fn trunc(self) -> Self {
                    let f = self.fract();
                    if f.is_nan() {
                        self
                    } else {
                        self - f
                    }
                }

                /// Returns the fractional part of a number.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.fract() == y);
                /// }
                ///
                /// check(f32::MAX, 0.0);
                /// check(0.75f32, 0.75);
                /// check(1.0f32, 0.0);
                /// check(1.25f32, 0.25);
                /// check(-0.0f64, 0.0);
                /// check(-0.75f64, -0.75);
                /// check(-1.0f64, 0.0);
                /// check(-1.25f64, -0.25);
                /// check(f64::MIN, 0.0);
                /// ```
                #[inline]
                fn fract(self) -> Self {
                    if self.is_zero() {
                        Self::zero()
                    } else {
                        self % Self::one()
                    }
                }

                /// Computes the absolute value of `self`. Returns `Float::nan()` if the
                /// number is `Float::nan()`.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.abs() == y);
                /// }
                ///
                /// check(f32::INFINITY, f32::INFINITY);
                /// check(1.0f32, 1.0);
                /// check(0.0f64, 0.0);
                /// check(-0.0f64, 0.0);
                /// check(-1.0f64, 1.0);
                /// check(f64::MIN, f64::MAX);
                /// ```
                #[inline]
                fn abs(self) -> Self {
                    if self.is_sign_positive() {
                        return self;
                    }
                    if self.is_sign_negative() {
                        return -self;
                    }
                    Self::nan()
                }

                /// Returns a number that represents the sign of `self`.
                ///
                /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`
                /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`
                /// - `Float::nan()` if the number is `Float::nan()`
                ///
                /// # Examples
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.signum() == y);
                /// }
                ///
                /// check(f32::INFINITY, 1.0);
                /// check(3.0f32, 1.0);
                /// check(0.0f32, 1.0);
                /// check(-0.0f64, -1.0);
                /// check(-3.0f64, -1.0);
                /// check(f64::MIN, -1.0);
                /// ```
                #[inline]
                fn signum(self) -> Self {
                    if self.is_nan() {
                        Self::nan()
                    } else if self.is_sign_negative() {
                        -Self::one()
                    } else {
                        Self::one()
                    }
                }

                /// Returns `true` if `self` is positive, including `+0.0` and
                /// `Float::infinity()`, and `Float::nan()`.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_sign_positive() == p);
                /// }
                ///
                /// check(f32::INFINITY, true);
                /// check(f32::MAX, true);
                /// check(0.0f32, true);
                /// check(-0.0f64, false);
                /// check(f64::NEG_INFINITY, false);
                /// check(f64::MIN_POSITIVE, true);
                /// check(f64::NAN, true);
                /// check(-f64::NAN, false);
                /// ```
                #[inline]
                fn is_sign_positive(self) -> bool {
                    !self.is_sign_negative()
                }

                /// Returns `true` if `self` is negative, including `-0.0` and
                /// `Float::neg_infinity()`, and `-Float::nan()`.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, p: bool) {
                ///     assert!(x.is_sign_negative() == p);
                /// }
                ///
                /// check(f32::INFINITY, false);
                /// check(f32::MAX, false);
                /// check(0.0f32, false);
                /// check(-0.0f64, true);
                /// check(f64::NEG_INFINITY, true);
                /// check(f64::MIN_POSITIVE, false);
                /// check(f64::NAN, false);
                /// check(-f64::NAN, true);
                /// ```
                #[inline]
                fn is_sign_negative(self) -> bool {
                    let (_, _, sign) = self.integer_decode();
                    sign < 0
                }

                /// Returns the minimum of the two numbers.
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T, min: T) {
                ///     assert!(x.min(y) == min);
                /// }
                ///
                /// check(1.0f32, 2.0, 1.0);
                /// check(f32::NAN, 2.0, 2.0);
                /// check(1.0f64, -2.0, -2.0);
                /// check(1.0f64, f64::NAN, 1.0);
                /// ```
                #[inline]
                fn min(self, other: Self) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self < other {
                        self
                    } else {
                        other
                    }
                }

                /// Returns the maximum of the two numbers.
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T, max: T) {
                ///     assert!(x.max(y) == max);
                /// }
                ///
                /// check(1.0f32, 2.0, 2.0);
                /// check(1.0f32, f32::NAN, 1.0);
                /// check(-1.0f64, 2.0, 2.0);
                /// check(-1.0f64, f64::NAN, -1.0);
                /// ```
                #[inline]
                fn max(self, other: Self) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self > other {
                        self
                    } else {
                        other
                    }
                }

                /// A value bounded by a minimum and a maximum
                ///
                ///  If input is less than min then this returns min.
                ///  If input is greater than max then this returns max.
                ///  Otherwise this returns input.
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                ///
                /// fn check<T: FloatCore>(val: T, min: T, max: T, expected: T) {
                ///     assert!(val.clamp(min, max) == expected);
                /// }
                ///
                ///
                /// check(1.0f32, 0.0, 2.0, 1.0);
                /// check(1.0f32, 2.0, 3.0, 2.0);
                /// check(3.0f32, 0.0, 2.0, 2.0);
                ///
                /// check(1.0f64, 0.0, 2.0, 1.0);
                /// check(1.0f64, 2.0, 3.0, 2.0);
                /// check(3.0f64, 0.0, 2.0, 2.0);
                /// ```
                fn clamp(self, min: Self, max: Self) -> Self {
                    crate::clamp(self, min, max)
                }

                /// Returns the reciprocal (multiplicative inverse) of the number.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, y: T) {
                ///     assert!(x.recip() == y);
                ///     assert!(y.recip() == x);
                /// }
                ///
                /// check(f32::INFINITY, 0.0);
                /// check(2.0f32, 0.5);
                /// check(-0.25f64, -4.0);
                /// check(-0.0f64, f64::NEG_INFINITY);
                /// ```
                #[inline]
                fn recip(self) -> Self {
                    Self::one() / self
                }

                /// Raise a number to an integer power.
                ///
                /// ```
                /// use num_traits::float::FloatCore;
                ///
                /// fn check<T: FloatCore>(x: T, exp: i32, powi: T) {
                ///     assert!(x.powi(exp) == powi);
                /// }
                ///
                /// check(9.0f32, 2, 81.0);
                /// check(1.0f32, -2, 1.0);
                /// check(10.0f64, 20, 1e20);
                /// check(4.0f64, -2, 0.0625);
                /// check(-1.0f64, ::i32::MIN, 1.0);
                /// ```
                #[inline]
                fn powi(mut self, mut exp: i32) -> Self {
                    if exp < 0 {
                        exp = exp.wrapping_neg();
                        self = self.recip();
                    }
                   
                   
                   
                    super::pow(self, (exp as u32).to_usize().unwrap())
                }

                /// Converts to degrees, assuming the number is in radians.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(rad: T, deg: T) {
                ///     assert!(rad.to_degrees() == deg);
                /// }
                ///
                /// check(0.0f32, 0.0);
                /// check(f32::consts::PI, 180.0);
                /// check(f64::consts::FRAC_PI_4, 45.0);
                /// check(f64::INFINITY, f64::INFINITY);
                /// ```
                fn to_degrees(self) -> Self;

                /// Converts to radians, assuming the number is in degrees.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(deg: T, rad: T) {
                ///     assert!(deg.to_radians() == rad);
                /// }
                ///
                /// check(0.0f32, 0.0);
                /// check(180.0, f32::consts::PI);
                /// check(45.0, f64::consts::FRAC_PI_4);
                /// check(f64::INFINITY, f64::INFINITY);
                /// ```
                fn to_radians(self) -> Self;

                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.
                /// use num_traits::float::FloatCore;
                /// use ::{f32, f64};
                ///
                /// fn check<T: FloatCore>(x: T, m: u64, e: i16, s:i8) {
                ///     let (mantissa, exponent, sign) = x.integer_decode();
                ///     assert_eq!(mantissa, m);
                ///     assert_eq!(exponent, e);
                ///     assert_eq!(sign, s);
                /// }
                ///
                /// check(2.0f32, 1 << 23, -22, 1);
                /// check(-2.0f32, 1 << 23, -22, -1);
                /// check(f32::INFINITY, 1 << 23, 105, 1);
                /// check(f64::NEG_INFINITY, 1 << 52, 972, -1);
                /// ```
                fn integer_decode(self) -> (u64, i16, i8);
            }

            impl FloatCore for f32 {
                constant! {
                    infinity() -> f32::INFINITY;
                    neg_infinity() -> f32::NEG_INFINITY;
                    nan() -> f32::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f32::MIN;
                    min_positive_value() -> f32::MIN_POSITIVE;
                    epsilon() -> f32::EPSILON;
                    max_value() -> f32::MAX;
                }

                #[inline]
                fn integer_decode(self) -> (u64, i16, i8) {
                    integer_decode_f32(self)
                }

                forward! {
                    Self::is_nan(self) -> bool;
                    Self::is_infinite(self) -> bool;
                    Self::is_finite(self) -> bool;
                    Self::is_normal(self) -> bool;
                    Self::is_subnormal(self) -> bool;
                    Self::clamp(self, min: Self, max: Self) -> Self;
                    Self::classify(self) -> FpCategory;
                    Self::is_sign_positive(self) -> bool;
                    Self::is_sign_negative(self) -> bool;
                    Self::min(self, other: Self) -> Self;
                    Self::max(self, other: Self) -> Self;
                    Self::recip(self) -> Self;
                    Self::to_degrees(self) -> Self;
                    Self::to_radians(self) -> Self;
                }

                    forward! {
                    Self::floor(self) -> Self;
                    Self::ceil(self) -> Self;
                    Self::round(self) -> Self;
                    Self::trunc(self) -> Self;
                    Self::fract(self) -> Self;
                    Self::abs(self) -> Self;
                    Self::signum(self) -> Self;
                    Self::powi(self, n: i32) -> Self;
                }

                #[cfg(all(not(feature = "std"), feature = "libm"))]
                forward! {
                    libm::floorf as floor(self) -> Self;
                    libm::ceilf as ceil(self) -> Self;
                    libm::roundf as round(self) -> Self;
                    libm::truncf as trunc(self) -> Self;
                    libm::fabsf as abs(self) -> Self;
                }

                #[cfg(all(not(feature = "std"), feature = "libm"))]
                #[inline]
                fn fract(self) -> Self {
                    self - libm::truncf(self)
                }
            }

            impl FloatCore for f64 {
                constant! {
                    infinity() -> f64::INFINITY;
                    neg_infinity() -> f64::NEG_INFINITY;
                    nan() -> f64::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f64::MIN;
                    min_positive_value() -> f64::MIN_POSITIVE;
                    epsilon() -> f64::EPSILON;
                    max_value() -> f64::MAX;
                }

                #[inline]
                fn integer_decode(self) -> (u64, i16, i8) {
                    integer_decode_f64(self)
                }

                forward! {
                    Self::is_nan(self) -> bool;
                    Self::is_infinite(self) -> bool;
                    Self::is_finite(self) -> bool;
                    Self::is_normal(self) -> bool;
                    Self::is_subnormal(self) -> bool;
                    Self::clamp(self, min: Self, max: Self) -> Self;
                    Self::classify(self) -> FpCategory;
                    Self::is_sign_positive(self) -> bool;
                    Self::is_sign_negative(self) -> bool;
                    Self::min(self, other: Self) -> Self;
                    Self::max(self, other: Self) -> Self;
                    Self::recip(self) -> Self;
                    Self::to_degrees(self) -> Self;
                    Self::to_radians(self) -> Self;
                }

                    forward! {
                    Self::floor(self) -> Self;
                    Self::ceil(self) -> Self;
                    Self::round(self) -> Self;
                    Self::trunc(self) -> Self;
                    Self::fract(self) -> Self;
                    Self::abs(self) -> Self;
                    Self::signum(self) -> Self;
                    Self::powi(self, n: i32) -> Self;
                }

                #[cfg(all(not(feature = "std"), feature = "libm"))]
                forward! {
                    libm::floor as floor(self) -> Self;
                    libm::ceil as ceil(self) -> Self;
                    libm::round as round(self) -> Self;
                    libm::trunc as trunc(self) -> Self;
                    libm::fabs as abs(self) -> Self;
                }

                #[cfg(all(not(feature = "std"), feature = "libm"))]
                #[inline]
                fn fract(self) -> Self {
                    self - libm::trunc(self)
                }
            }
            /// Generic trait for floating point numbers
            ///
            /// This trait is only available with the `std` feature, or with the `libm` feature otherwise.
            pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {
                /// Returns the `NaN` value.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let nan: f32 = Float::nan();
                ///
                /// assert!(nan.is_nan());
                /// ```
                fn nan() -> Self;
                /// Returns the infinite value.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f32;
                ///
                /// let infinity: f32 = Float::infinity();
                ///
                /// assert!(infinity.is_infinite());
                /// assert!(!infinity.is_finite());
                /// assert!(infinity > f32::MAX);
                /// ```
                fn infinity() -> Self;
                /// Returns the negative infinite value.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f32;
                ///
                /// let neg_infinity: f32 = Float::neg_infinity();
                ///
                /// assert!(neg_infinity.is_infinite());
                /// assert!(!neg_infinity.is_finite());
                /// assert!(neg_infinity < f32::MIN);
                /// ```
                fn neg_infinity() -> Self;
                /// Returns `-0.0`.
                ///
                /// ```
                /// use num_traits::{Zero, Float};
                ///
                /// let inf: f32 = Float::infinity();
                /// let zero: f32 = Zero::zero();
                /// let neg_zero: f32 = Float::neg_zero();
                ///
                /// assert_eq!(zero, neg_zero);
                /// assert_eq!(7.0f32/inf, zero);
                /// assert_eq!(zero * 10.0, zero);
                /// ```
                fn neg_zero() -> Self;

                /// Returns the smallest finite value that this type can represent.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x: f64 = Float::min_value();
                ///
                /// assert_eq!(x, f64::MIN);
                /// ```
                fn min_value() -> Self;

                /// Returns the smallest positive, normalized value that this type can represent.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x: f64 = Float::min_positive_value();
                ///
                /// assert_eq!(x, f64::MIN_POSITIVE);
                /// ```
                fn min_positive_value() -> Self;

                /// Returns epsilon, a small positive value.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x: f64 = Float::epsilon();
                ///
                /// assert_eq!(x, f64::EPSILON);
                /// ```
                ///
                /// # Panics
                ///
                /// The default implementation will panic if `f32::EPSILON` cannot
                /// be cast to `Self`.
                fn epsilon() -> Self {
                    Self::from(f32::EPSILON).expect("Unable to cast from f32::EPSILON")
                }

                /// Returns the largest finite value that this type can represent.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x: f64 = Float::max_value();
                /// assert_eq!(x, f64::MAX);
                /// ```
                fn max_value() -> Self;

                /// Returns `true` if this value is `NaN` and false otherwise.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let nan = f64::NAN;
                /// let f = 7.0;
                ///
                /// assert!(nan.is_nan());
                /// assert!(!f.is_nan());
                /// ```
                fn is_nan(self) -> bool;

                /// Returns `true` if this value is positive infinity or negative infinity and
                /// false otherwise.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f32;
                ///
                /// let f = 7.0f32;
                /// let inf: f32 = Float::infinity();
                /// let neg_inf: f32 = Float::neg_infinity();
                /// let nan: f32 = f32::NAN;
                ///
                /// assert!(!f.is_infinite());
                /// assert!(!nan.is_infinite());
                ///
                /// assert!(inf.is_infinite());
                /// assert!(neg_inf.is_infinite());
                /// ```
                fn is_infinite(self) -> bool;

                /// Returns `true` if this number is neither infinite nor `NaN`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f32;
                ///
                /// let f = 7.0f32;
                /// let inf: f32 = Float::infinity();
                /// let neg_inf: f32 = Float::neg_infinity();
                /// let nan: f32 = f32::NAN;
                ///
                /// assert!(f.is_finite());
                ///
                /// assert!(!nan.is_finite());
                /// assert!(!inf.is_finite());
                /// assert!(!neg_inf.is_finite());
                /// ```
                fn is_finite(self) -> bool;

                /// Returns `true` if the number is neither zero, infinite,
                /// [subnormal][subnormal], or `NaN`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f32;
                ///
                /// let min = f32::MIN_POSITIVE;
                /// let max = f32::MAX;
                /// let lower_than_min = 1.0e-40_f32;
                /// let zero = 0.0f32;
                ///
                /// assert!(min.is_normal());
                /// assert!(max.is_normal());
                ///
                /// assert!(!zero.is_normal());
                /// assert!(!f32::NAN.is_normal());
                /// assert!(!f32::INFINITY.is_normal());
                ///
                /// assert!(!lower_than_min.is_normal());
                /// ```
                /// [subnormal]: http://en.wikipedia.org/wiki/Subnormal_number
                fn is_normal(self) -> bool;

                /// Returns `true` if the number is [subnormal].
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let min = f64::MIN_POSITIVE;
                /// let max = f64::MAX;
                /// let lower_than_min = 1.0e-308_f64;
                /// let zero = 0.0_f64;
                ///
                /// assert!(!min.is_subnormal());
                /// assert!(!max.is_subnormal());
                ///
                /// assert!(!zero.is_subnormal());
                /// assert!(!f64::NAN.is_subnormal());
                /// assert!(!f64::INFINITY.is_subnormal());
                ///
                /// assert!(lower_than_min.is_subnormal());
                /// ```
                /// [subnormal]: https://en.wikipedia.org/wiki/Subnormal_number
                #[inline]
                fn is_subnormal(self) -> bool {
                    self.classify() == FpCategory::Subnormal
                }

                /// Returns the floating point category of the number. If only one property
                /// is going to be tested, it is generally faster to use the specific
                /// predicate instead.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::num::FpCategory;
                /// use ::f32;
                ///
                /// let num = 12.4f32;
                /// let inf = f32::INFINITY;
                ///
                /// assert_eq!(num.classify(), FpCategory::Normal);
                /// assert_eq!(inf.classify(), FpCategory::Infinite);
                /// ```
                fn classify(self) -> FpCategory;

                /// Returns the largest integer less than or equal to a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 3.99;
                /// let g = 3.0;
                ///
                /// assert_eq!(f.floor(), 3.0);
                /// assert_eq!(g.floor(), 3.0);
                /// ```
                fn floor(self) -> Self;

                /// Returns the smallest integer greater than or equal to a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 3.01;
                /// let g = 4.0;
                ///
                /// assert_eq!(f.ceil(), 4.0);
                /// assert_eq!(g.ceil(), 4.0);
                /// ```
                fn ceil(self) -> Self;

                /// Returns the nearest integer to a number. Round half-way cases away from
                /// `0.0`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 3.3;
                /// let g = -3.3;
                ///
                /// assert_eq!(f.round(), 3.0);
                /// assert_eq!(g.round(), -3.0);
                /// ```
                fn round(self) -> Self;

                /// Return the integer part of a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 3.3;
                /// let g = -3.7;
                ///
                /// assert_eq!(f.trunc(), 3.0);
                /// assert_eq!(g.trunc(), -3.0);
                /// ```
                fn trunc(self) -> Self;

                /// Returns the fractional part of a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 3.5;
                /// let y = -3.5;
                /// let abs_difference_x = (x.fract() - 0.5).abs();
                /// let abs_difference_y = (y.fract() - (-0.5)).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                /// ```
                fn fract(self) -> Self;

                /// Computes the absolute value of `self`. Returns `Float::nan()` if the
                /// number is `Float::nan()`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x = 3.5;
                /// let y = -3.5;
                ///
                /// let abs_difference_x = (x.abs() - x).abs();
                /// let abs_difference_y = (y.abs() - (-y)).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                ///
                /// assert!(f64::NAN.abs().is_nan());
                /// ```
                fn abs(self) -> Self;

                /// Returns a number that represents the sign of `self`.
                ///
                /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`
                /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`
                /// - `Float::nan()` if the number is `Float::nan()`
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let f = 3.5;
                ///
                /// assert_eq!(f.signum(), 1.0);
                /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);
                ///
                /// assert!(f64::NAN.signum().is_nan());
                /// ```
                fn signum(self) -> Self;

                /// Returns `true` if `self` is positive, including `+0.0`,
                /// `Float::infinity()`, and `Float::nan()`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let nan: f64 = f64::NAN;
                /// let neg_nan: f64 = -f64::NAN;
                ///
                /// let f = 7.0;
                /// let g = -7.0;
                ///
                /// assert!(f.is_sign_positive());
                /// assert!(!g.is_sign_positive());
                /// assert!(nan.is_sign_positive());
                /// assert!(!neg_nan.is_sign_positive());
                /// ```
                fn is_sign_positive(self) -> bool;

                /// Returns `true` if `self` is negative, including `-0.0`,
                /// `Float::neg_infinity()`, and `-Float::nan()`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let nan: f64 = f64::NAN;
                /// let neg_nan: f64 = -f64::NAN;
                ///
                /// let f = 7.0;
                /// let g = -7.0;
                ///
                /// assert!(!f.is_sign_negative());
                /// assert!(g.is_sign_negative());
                /// assert!(!nan.is_sign_negative());
                /// assert!(neg_nan.is_sign_negative());
                /// ```
                fn is_sign_negative(self) -> bool;

                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                ///
                /// Using `mul_add` can be more performant than an unfused multiply-add if
                /// the target architecture has a dedicated `fma` CPU instruction.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let m = 10.0;
                /// let x = 4.0;
                /// let b = 60.0;
                ///
                ///
                /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn mul_add(self, a: Self, b: Self) -> Self;
                /// Take the reciprocal (inverse) of a number, `1/x`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.recip() - (1.0/x)).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn recip(self) -> Self;

                /// Raise a number to an integer power.
                /// use num_traits::Float;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.powi(2) - x*x).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn powi(self, n: i32) -> Self;

                /// Raise a number to a floating point power.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.powf(2.0) - x*x).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn powf(self, n: Self) -> Self;

                /// Take the square root of a number.
                /// use num_traits::Float;
                ///
                /// let positive = 4.0;
                /// let negative = -4.0;
                ///
                /// let abs_difference = (positive.sqrt() - 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// assert!(negative.sqrt().is_nan());
                /// ```
                fn sqrt(self) -> Self;

                /// Returns `e^(self)`, (the exponential function).
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let one = 1.0;
                ///
                /// let e = one.exp();
                ///
                ///
                /// let abs_difference = (e.ln() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp(self) -> Self;

                /// Returns `2^(self)`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 2.0;
                ///
                ///
                /// let abs_difference = (f.exp2() - 4.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp2(self) -> Self;

                /// Returns the natural logarithm of the number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let one = 1.0;
                ///
                /// let e = one.exp();
                ///
                ///
                /// let abs_difference = (e.ln() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn ln(self) -> Self;

                /// Returns the logarithm of the number with respect to an arbitrary base.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let ten = 10.0;
                /// let two = 2.0;
                ///
                ///
                /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();
                ///
                ///
                /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();
                ///
                /// assert!(abs_difference_10 < 1e-10);
                /// assert!(abs_difference_2 < 1e-10);
                /// ```
                fn log(self, base: Self) -> Self;

                /// Returns the base 2 logarithm of the number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let two = 2.0;
                ///
                ///
                /// let abs_difference = (two.log2() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn log2(self) -> Self;

                /// Returns the base 10 logarithm of the number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let ten = 10.0;
                ///
                ///
                /// let abs_difference = (ten.log10() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn log10(self) -> Self;

                /// Converts radians to degrees.
                ///
                /// ```
                /// use ::f64::consts;
                ///
                /// let angle = consts::PI;
                ///
                /// let abs_difference = (angle.to_degrees() - 180.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                #[inline]
                fn to_degrees(self) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from(90u8).unwrap();
                    self * ninety / halfpi
                }

                /// Converts degrees to radians.
                ///
                /// ```
                /// use ::f64::consts;
                ///
                /// let angle = 180.0_f64;
                ///
                /// let abs_difference = (angle.to_radians() - consts::PI).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                #[inline]
                fn to_radians(self) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from(90u8).unwrap();
                    self * halfpi / ninety
                }

                /// Returns the maximum of the two numbers.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                ///
                /// assert_eq!(x.max(y), y);
                /// ```
                fn max(self, other: Self) -> Self;

                /// Returns the minimum of the two numbers.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                ///
                /// assert_eq!(x.min(y), x);
                /// ```
                fn min(self, other: Self) -> Self;

                /// Clamps a value between a min and max.
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                /// let z = 3.0;
                ///
                /// assert_eq!(x.clamp(y, z), 2.0);
                /// ```
                fn clamp(self, min: Self, max: Self) -> Self {
                    crate::clamp(self, min, max)
                }

                /// The positive difference of two numbers.
                ///
                /// * If `self <= other`: `0:0`
                /// * Else: `self - other`
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 3.0;
                /// let y = -3.0;
                ///
                /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();
                /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                /// ```
                fn abs_sub(self, other: Self) -> Self;

                /// Take the cubic root of a number.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 8.0;
                ///
                ///
                /// let abs_difference = (x.cbrt() - 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn cbrt(self) -> Self;

                /// Calculate the length of the hypotenuse of a right-angle triangle given
                /// legs of length `x` and `y`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 2.0;
                /// let y = 3.0;
                ///
                ///
                /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn hypot(self, other: Self) -> Self;

                /// Computes the sine of a number (in radians).
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x = f64::consts::PI/2.0;
                ///
                /// let abs_difference = (x.sin() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn sin(self) -> Self;

                /// Computes the cosine of a number (in radians).
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x = 2.0*f64::consts::PI;
                ///
                /// let abs_difference = (x.cos() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn cos(self) -> Self;

                /// Computes the tangent of a number (in radians).
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x = f64::consts::PI/4.0;
                /// let abs_difference = (x.tan() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-14);
                /// ```
                fn tan(self) -> Self;

                /// Computes the arcsine of a number. Return value is in radians in
                /// the range [-pi/2, pi/2] or NaN if the number is outside the range
                /// [-1, 1].
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let f = f64::consts::PI / 2.0;
                ///
                ///
                /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn asin(self) -> Self;

                /// Computes the arccosine of a number. Return value is in radians in
                /// the range [0, pi] or NaN if the number is outside the range
                /// [-1, 1].
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let f = f64::consts::PI / 4.0;
                ///
                ///
                /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn acos(self) -> Self;

                /// Computes the arctangent of a number. Return value is in radians in the
                /// range [-pi/2, pi/2];
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let f = 1.0;
                ///
                ///
                /// let abs_difference = (f.tan().atan() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn atan(self) -> Self;

                /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).
                ///
                /// * `x = 0`, `y = 0`: `0`
                /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`
                /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`
                /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let pi = f64::consts::PI;
                ///
                ///
                /// let x1 = 3.0;
                /// let y1 = -3.0;
                ///
                ///
                /// let x2 = -3.0;
                /// let y2 = 3.0;
                ///
                /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();
                /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();
                ///
                /// assert!(abs_difference_1 < 1e-10);
                /// assert!(abs_difference_2 < 1e-10);
                /// ```
                fn atan2(self, other: Self) -> Self;

                /// Simultaneously computes the sine and cosine of the number, `x`. Returns
                /// `(sin(x), cos(x))`.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x = f64::consts::PI/4.0;
                /// let f = x.sin_cos();
                ///
                /// let abs_difference_0 = (f.0 - x.sin()).abs();
                /// let abs_difference_1 = (f.1 - x.cos()).abs();
                ///
                /// assert!(abs_difference_0 < 1e-10);
                /// assert!(abs_difference_0 < 1e-10);
                /// ```
                fn sin_cos(self) -> (Self, Self);

                /// Returns `e^(self) - 1` in a way that is accurate even if the
                /// number is close to zero.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 7.0;
                ///
                ///
                /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp_m1(self) -> Self;

                /// Returns `ln(1+n)` (natural logarithm) more accurately than if
                /// the operations were performed separately.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let x = f64::consts::E - 1.0;
                ///
                ///
                /// let abs_difference = (x.ln_1p() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn ln_1p(self) -> Self;

                /// Hyperbolic sine function.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                ///
                /// let f = x.sinh();
                ///
                /// let g = (e*e - 1.0)/(2.0*e);
                /// let abs_difference = (f - g).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn sinh(self) -> Self;

                /// Hyperbolic cosine function.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                /// let f = x.cosh();
                ///
                /// let g = (e*e + 1.0)/(2.0*e);
                /// let abs_difference = (f - g).abs();
                ///
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn cosh(self) -> Self;

                /// Hyperbolic tangent function.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                ///
                /// let f = x.tanh();
                ///
                /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));
                /// let abs_difference = (f - g).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn tanh(self) -> Self;

                /// Inverse hyperbolic sine function.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let f = x.sinh().asinh();
                ///
                /// let abs_difference = (f - x).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn asinh(self) -> Self;

                /// Inverse hyperbolic cosine function.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let x = 1.0;
                /// let f = x.cosh().acosh();
                ///
                /// let abs_difference = (f - x).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn acosh(self) -> Self;

                /// Inverse hyperbolic tangent function.
                ///
                /// ```
                /// use num_traits::Float;
                /// use ::f64;
                ///
                /// let e = f64::consts::E;
                /// let f = e.tanh().atanh();
                ///
                /// let abs_difference = (f - e).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn atanh(self) -> Self;

                /// Returns the mantissa, base 2 exponent, and sign as integers, respectively.
                /// The original number can be recovered by `sign * mantissa * 2 ^ exponent`.
                ///
                /// ```
                /// use num_traits::Float;
                ///
                /// let num = 42_f32;
                ///
                ///
                /// let (mantissa, exponent, sign) = Float::integer_decode(num);
                /// let sign_f = sign as f32;
                /// let mantissa_f = mantissa as f32;
                /// let exponent_f = exponent as f32;
                ///
                ///
                /// let abs_difference = (sign_f * mantissa_f * exponent_f.exp2() - num).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn integer_decode(self) -> (u64, i16, i8);

                /// Returns a number composed of the magnitude of `self` and the sign of
                /// `sign`.
                ///
                /// Equal to `self` if the sign of `self` and `sign` are the same, otherwise
                /// equal to `-self`. If `self` is a `NAN`, then a `NAN` with the sign of
                /// `sign` is returned.
                /// use num_traits::Float;
                ///
                /// let f = 3.5_f32;
                ///
                /// assert_eq!(f.copysign(0.42), 3.5_f32);
                /// assert_eq!(f.copysign(-0.42), -3.5_f32);
                /// assert_eq!((-f).copysign(0.42), 3.5_f32);
                /// assert_eq!((-f).copysign(-0.42), -3.5_f32);
                ///
                /// assert!(f32::nan().copysign(1.0).is_nan());
                /// ```
                fn copysign(self, sign: Self) -> Self {
                    if self.is_sign_negative() == sign.is_sign_negative() {
                        self
                    } else {
                        self.neg()
                    }
                }
            }

            macro_rules! float_impl_std {
                ($T:ident $decode:ident) => {
                    impl Float for $T {
                        constant! {
                            nan() -> $T::NAN;
                            infinity() -> $T::INFINITY;
                            neg_infinity() -> $T::NEG_INFINITY;
                            neg_zero() -> -0.0;
                            min_value() -> $T::MIN;
                            min_positive_value() -> $T::MIN_POSITIVE;
                            epsilon() -> $T::EPSILON;
                            max_value() -> $T::MAX;
                        }

                        #[inline]
                        #[allow(deprecated)]
                        fn abs_sub(self, other: Self) -> Self {
                            <$T>::abs_sub(self, other)
                        }

                        #[inline]
                        fn integer_decode(self) -> (u64, i16, i8) {
                            $decode(self)
                        }

                        forward! {
                            Self::is_nan(self) -> bool;
                            Self::is_infinite(self) -> bool;
                            Self::is_finite(self) -> bool;
                            Self::is_normal(self) -> bool;
                            Self::is_subnormal(self) -> bool;
                            Self::classify(self) -> FpCategory;
                            Self::clamp(self, min: Self, max: Self) -> Self;
                            Self::floor(self) -> Self;
                            Self::ceil(self) -> Self;
                            Self::round(self) -> Self;
                            Self::trunc(self) -> Self;
                            Self::fract(self) -> Self;
                            Self::abs(self) -> Self;
                            Self::signum(self) -> Self;
                            Self::is_sign_positive(self) -> bool;
                            Self::is_sign_negative(self) -> bool;
                            Self::mul_add(self, a: Self, b: Self) -> Self;
                            Self::recip(self) -> Self;
                            Self::powi(self, n: i32) -> Self;
                            Self::powf(self, n: Self) -> Self;
                            Self::sqrt(self) -> Self;
                            Self::exp(self) -> Self;
                            Self::exp2(self) -> Self;
                            Self::ln(self) -> Self;
                            Self::log(self, base: Self) -> Self;
                            Self::log2(self) -> Self;
                            Self::log10(self) -> Self;
                            Self::to_degrees(self) -> Self;
                            Self::to_radians(self) -> Self;
                            Self::max(self, other: Self) -> Self;
                            Self::min(self, other: Self) -> Self;
                            Self::cbrt(self) -> Self;
                            Self::hypot(self, other: Self) -> Self;
                            Self::sin(self) -> Self;
                            Self::cos(self) -> Self;
                            Self::tan(self) -> Self;
                            Self::asin(self) -> Self;
                            Self::acos(self) -> Self;
                            Self::atan(self) -> Self;
                            Self::atan2(self, other: Self) -> Self;
                            Self::sin_cos(self) -> (Self, Self);
                            Self::exp_m1(self) -> Self;
                            Self::ln_1p(self) -> Self;
                            Self::sinh(self) -> Self;
                            Self::cosh(self) -> Self;
                            Self::tanh(self) -> Self;
                            Self::asinh(self) -> Self;
                            Self::acosh(self) -> Self;
                            Self::atanh(self) -> Self;
                            Self::copysign(self, sign: Self) -> Self;
                        }
                    }
                };
            }
            
            fn integer_decode_f32(f: f32) -> (u64, i16, i8) {
                let bits: u32 = f.to_bits();
                let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;
                let mantissa = if exponent == 0 {
                    (bits & 0x7fffff) << 1
                } else {
                    (bits & 0x7fffff) | 0x800000
                };
               
                exponent -= 127 + 23;
                (mantissa as u64, exponent, sign)
            }

            fn integer_decode_f64(f: f64) -> (u64, i16, i8) {
                let bits: u64 = f.to_bits();
                let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;
                let mantissa = if exponent == 0 {
                    (bits & 0xfffffffffffff) << 1
                } else {
                    (bits & 0xfffffffffffff) | 0x10000000000000
                };
               
                exponent -= 1023 + 52;
                (mantissa, exponent, sign)
            }

            float_impl_std!(f32 integer_decode_f32);
            float_impl_std!(f64 integer_decode_f64);
            
            macro_rules! float_const_impl {
                ($(#[$doc:meta] $constant:ident,)+) => (
                    #[allow(non_snake_case)]
                    pub trait FloatConst {
                        $(#[$doc] fn $constant() -> Self;)+
                        #[doc = "Return the full circle constant `τ`."]
                        #[inline]
                        fn TAU() -> Self where Self: Sized + Add<Self, Output = Self> {
                            Self::PI() + Self::PI()
                        }
                        #[doc = "Return `log10(2.0)`."]
                        #[inline]
                        fn LOG10_2() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_2() / Self::LN_10()
                        }
                        #[doc = "Return `log2(10.0)`."]
                        #[inline]
                        fn LOG2_10() -> Self where Self: Sized + Div<Self, Output = Self> {
                            Self::LN_10() / Self::LN_2()
                        }
                    }
                    float_const_impl! { @float f32, $($constant,)+ }
                    float_const_impl! { @float f64, $($constant,)+ }
                );
                (@float $T:ident, $($constant:ident,)+) => (
                    impl FloatConst for $T {
                        constant! {
                            $( $constant() -> $T::consts::$constant; )+
                            TAU() -> 6.28318530717958647692528676655900577;
                            LOG10_2() -> 0.301029995663981195213738894724493027;
                            LOG2_10() -> 3.32192809488736234787031942948939018;
                        }
                    }
                );
            }

            float_const_impl! {
                #[doc = "Return Euler’s number."]
                E,
                #[doc = "Return `1.0 / π`."]
                FRAC_1_PI,
                #[doc = "Return `1.0 / sqrt(2.0)`."]
                FRAC_1_SQRT_2,
                #[doc = "Return `2.0 / π`."]
                FRAC_2_PI,
                #[doc = "Return `2.0 / sqrt(π)`."]
                FRAC_2_SQRT_PI,
                #[doc = "Return `π / 2.0`."]
                FRAC_PI_2,
                #[doc = "Return `π / 3.0`."]
                FRAC_PI_3,
                #[doc = "Return `π / 4.0`."]
                FRAC_PI_4,
                #[doc = "Return `π / 6.0`."]
                FRAC_PI_6,
                #[doc = "Return `π / 8.0`."]
                FRAC_PI_8,
                #[doc = "Return `ln(10.0)`."]
                LN_10,
                #[doc = "Return `ln(2.0)`."]
                LN_2,
                #[doc = "Return `log10(e)`."]
                LOG10_E,
                #[doc = "Return `log2(e)`."]
                LOG2_E,
                #[doc = "Return Archimedes’ constant `π`."]
                PI,
                #[doc = "Return `sqrt(2.0)`."]
                SQRT_2,
            }
            /// Trait for floating point numbers that provide an implementation
            /// of the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)
            /// floating point standard.
            pub trait TotalOrder {
                /// Return the ordering between `self` and `other`.
                ///
                /// Unlike the standard partial comparison between floating point numbers,
                /// this comparison always produces an ordering in accordance to
                /// the `totalOrder` predicate as defined in the IEEE 754 (2008 revision)
                /// floating point standard. The values are ordered in the following sequence:
                ///
                /// - negative quiet NaN
                /// - negative signaling NaN
                /// - negative infinity
                /// - negative numbers
                /// - negative subnormal numbers
                /// - negative zero
                /// - positive zero
                /// - positive subnormal numbers
                /// - positive numbers
                /// - positive infinity
                /// - positive signaling NaN
                /// - positive quiet NaN.
                ///
                /// The ordering established by this function does not always agree with the
                /// [`PartialOrd`] and [`PartialEq`] implementations. For example,
                /// they consider negative and positive zero equal, while `total_cmp`
                /// doesn't.
                ///
                /// The interpretation of the signaling NaN bit follows the definition in
                /// the IEEE 754 standard, which may not match the interpretation by some of
                /// the older, non-conformant (e.g. MIPS) hardware implementations.
                ///
                /// # Examples
                /// ```
                /// use num_traits::float::TotalOrder;
                /// use ::cmp::Ordering;
                /// use ::{f32, f64};
                ///
                /// fn check_eq<T: TotalOrder>(x: T, y: T) {
                ///     assert_eq!(x.total_cmp(&y), Ordering::Equal);
                /// }
                ///
                /// check_eq(f64::NAN, f64::NAN);
                /// check_eq(f32::NAN, f32::NAN);
                ///
                /// fn check_lt<T: TotalOrder>(x: T, y: T) {
                ///     assert_eq!(x.total_cmp(&y), Ordering::Less);
                /// }
                ///
                /// check_lt(-f64::NAN, f64::NAN);
                /// check_lt(f64::INFINITY, f64::NAN);
                /// check_lt(-0.0_f64, 0.0_f64);
                /// ```
                fn total_cmp(&self, other: &Self) -> Ordering;
            }
            macro_rules! totalorder_impl {
                ($T:ident, $I:ident, $U:ident, $bits:expr) => {
                    impl TotalOrder for $T {
                        #[inline]
                        #[cfg(has_total_cmp)]
                        fn total_cmp(&self, other: &Self) -> Ordering {
                           
                            Self::total_cmp(&self, other)
                        }
                        #[inline]
                        #[cfg(not(has_total_cmp))]
                        fn total_cmp(&self, other: &Self) -> Ordering {
                           
                            let mut left = self.to_bits() as $I;
                            let mut right = other.to_bits() as $I;

                            left ^= (((left >> ($bits - 1)) as $U) >> 1) as $I;
                            right ^= (((right >> ($bits - 1)) as $U) >> 1) as $I;

                            left.cmp(&right)
                        }
                    }
                };
            }
            totalorder_impl!(f64, i64, u64, 64);
            totalorder_impl!(f32, i32, u32, 32);
        } pub use self::float::{ Float, FloatConst };

        pub mod identities
        {
            use ::
            {
                *,
            };
            /*
                use ::num::Wrapping;
                use ::ops::{Add, Mul};

                #[cfg(has_num_saturating)]
                use ::num::Saturating;
            */
            /// Defines an additive identity element for `Self`.
            /// a + 0 = a       ∀ a ∈ Self
            /// 0 + a = a       ∀ a ∈ Self
            /// ```
            pub trait Zero: Sized + Add<Self, Output = Self> {
                /// Returns the additive identity element of `Self`, `0`.
                /// # Purity
                ///
                /// This function should return the same result at all times regardless of
                /// external mutable state, for example values stored in TLS or in
                /// `static mut`s.
               
                fn zero() -> Self;

                /// Sets `self` to the additive identity element of `Self`, `0`.
                fn set_zero(&mut self) {
                    *self = Zero::zero();
                }

                /// Returns `true` if `self` is equal to the additive identity.
                fn is_zero(&self) -> bool;
            }
            /// Defines an associated constant representing the additive identity element
            /// for `Self`.
            pub trait ConstZero: Zero {
                /// The additive identity element of `Self`, `0`.
                const ZERO: Self;
            }

            macro_rules! zero_impl {
                ($t:ty, $v:expr) => {
                    impl Zero for $t {
                        #[inline]
                        fn zero() -> $t {
                            $v
                        }
                        #[inline]
                        fn is_zero(&self) -> bool {
                            *self == $v
                        }
                    }

                    impl ConstZero for $t {
                        const ZERO: Self = $v;
                    }
                };
            }

            zero_impl!(usize, 0);
            zero_impl!(u8, 0);
            zero_impl!(u16, 0);
            zero_impl!(u32, 0);
            zero_impl!(u64, 0);
            zero_impl!(u128, 0);

            zero_impl!(isize, 0);
            zero_impl!(i8, 0);
            zero_impl!(i16, 0);
            zero_impl!(i32, 0);
            zero_impl!(i64, 0);
            zero_impl!(i128, 0);

            zero_impl!(f32, 0.0);
            zero_impl!(f64, 0.0);

            impl<T: Zero> Zero for Wrapping<T> where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                fn is_zero(&self) -> bool {
                    self.0.is_zero()
                }

                fn set_zero(&mut self) {
                    self.0.set_zero();
                }

                fn zero() -> Self {
                    Wrapping(T::zero())
                }
            }

            impl<T: ConstZero> ConstZero for Wrapping<T> where
                Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                const ZERO: Self = Wrapping(T::ZERO);
            }

            #[cfg(has_num_saturating)]
            impl<T: Zero> Zero for Saturating<T> where
                Saturating<T>: Add<Output = Saturating<T>>,
            {
                fn is_zero(&self) -> bool {
                    self.0.is_zero()
                }

                fn set_zero(&mut self) {
                    self.0.set_zero();
                }

                fn zero() -> Self {
                    Saturating(T::zero())
                }
            }

            #[cfg(has_num_saturating)]
            impl<T: ConstZero> ConstZero for Saturating<T> where
                Saturating<T>: Add<Output = Saturating<T>>,
            {
                const ZERO: Self = Saturating(T::ZERO);
            }
            /// Defines a multiplicative identity element for `Self`.
            /// a * 1 = a       ∀ a ∈ Self
            /// 1 * a = a       ∀ a ∈ Self
            /// ```
            pub trait One: Sized + Mul<Self, Output = Self> {
                /// Returns the multiplicative identity element of `Self`, `1`.
                /// external mutable state, for example values stored in TLS or in
                /// `static mut`s.
               
                fn one() -> Self;

                /// Sets `self` to the multiplicative identity element of `Self`, `1`.
                fn set_one(&mut self) {
                    *self = One::one();
                }

                /// Returns `true` if `self` is equal to the multiplicative identity.
                ///
                /// For performance reasons, it's best to implement this manually.
                /// After a semver bump, this method will be required, and the
                /// `where Self: PartialEq` bound will be removed.
                #[inline]
                fn is_one(&self) -> bool
                where
                    Self: PartialEq,
                {
                    *self == Self::one()
                }
            }
            /// Defines an associated constant representing the multiplicative identity
            /// element for `Self`.
            pub trait ConstOne: One {
                /// The multiplicative identity element of `Self`, `1`.
                const ONE: Self;
            }

            macro_rules! one_impl {
                ($t:ty, $v:expr) => {
                    impl One for $t {
                        #[inline]
                        fn one() -> $t {
                            $v
                        }
                        #[inline]
                        fn is_one(&self) -> bool {
                            *self == $v
                        }
                    }

                    impl ConstOne for $t {
                        const ONE: Self = $v;
                    }
                };
            }

            one_impl!(usize, 1);
            one_impl!(u8, 1);
            one_impl!(u16, 1);
            one_impl!(u32, 1);
            one_impl!(u64, 1);
            one_impl!(u128, 1);

            one_impl!(isize, 1);
            one_impl!(i8, 1);
            one_impl!(i16, 1);
            one_impl!(i32, 1);
            one_impl!(i64, 1);
            one_impl!(i128, 1);

            one_impl!(f32, 1.0);
            one_impl!(f64, 1.0);

            impl<T: One> One for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                fn set_one(&mut self) {
                    self.0.set_one();
                }

                fn one() -> Self {
                    Wrapping(T::one())
                }
            }

            impl<T: ConstOne> ConstOne for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                const ONE: Self = Wrapping(T::ONE);
            }

            #[cfg(has_num_saturating)]
            impl<T: One> One for Saturating<T> where
                Saturating<T>: Mul<Output = Saturating<T>>,
            {
                fn set_one(&mut self) {
                    self.0.set_one();
                }

                fn one() -> Self {
                    Saturating(T::one())
                }
            }

            #[cfg(has_num_saturating)]
            impl<T: ConstOne> ConstOne for Saturating<T> where
                Saturating<T>: Mul<Output = Saturating<T>>,
            {
                const ONE: Self = Saturating(T::ONE);
            }

           

            /// Returns the additive identity, `0`.
            #[inline( always )] pub fn zero<T: Zero>() -> T {
                Zero::zero()
            }
            /// Returns the multiplicative identity, `1`.
            #[inline( always )] pub fn one<T: One>() -> T {
                One::one()
            }
        } pub use self::identities::{one, zero, ConstOne, ConstZero, One, Zero};

        pub mod int
        {
            use ::
            {
                num::
                {
                    traits::
                    {
                        bounds::Bounded,
                        ops::
                        {
                            checked::*,
                            saturating::Saturating,
                        },
                        Num, NumCast,
                    },
                },
                ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr},
                *,
            };
            /*
            */
            /// Generic trait for primitive integers.
            pub trait PrimInt:
                Sized
                + Copy
                + Num
                + NumCast
                + Bounded
                + PartialOrd
                + Ord
                + Eq
                + Not<Output = Self>
                + BitAnd<Output = Self>
                + BitOr<Output = Self>
                + BitXor<Output = Self>
                + Shl<usize, Output = Self>
                + Shr<usize, Output = Self>
                + CheckedAdd<Output = Self>
                + CheckedSub<Output = Self>
                + CheckedMul<Output = Self>
                + CheckedDiv<Output = Self>
                + Saturating
            {
                /// Returns the number of ones in the binary representation of `self`.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0b01001100u8;
                ///
                /// assert_eq!(n.count_ones(), 3);
                /// ```
                fn count_ones(self) -> u32;

                /// Returns the number of zeros in the binary representation of `self`.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0b01001100u8;
                ///
                /// assert_eq!(n.count_zeros(), 5);
                /// ```
                fn count_zeros(self) -> u32;

                /// Returns the number of leading ones in the binary representation
                /// of `self`.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0xF00Du16;
                ///
                /// assert_eq!(n.leading_ones(), 4);
                /// ```
                fn leading_ones(self) -> u32 {
                    (!self).leading_zeros()
                }

                /// Returns the number of leading zeros in the binary representation
                /// of `self`.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0b0101000u16;
                ///
                /// assert_eq!(n.leading_zeros(), 10);
                /// ```
                fn leading_zeros(self) -> u32;

                /// Returns the number of trailing ones in the binary representation
                /// of `self`.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0xBEEFu16;
                ///
                /// assert_eq!(n.trailing_ones(), 4);
                /// ```
                fn trailing_ones(self) -> u32 {
                    (!self).trailing_zeros()
                }

                /// Returns the number of trailing zeros in the binary representation
                /// of `self`.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0b0101000u16;
                ///
                /// assert_eq!(n.trailing_zeros(), 3);
                /// ```
                fn trailing_zeros(self) -> u32;

                /// Shifts the bits to the left by a specified amount, `n`, wrapping
                /// the truncated bits to the end of the resulting integer.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                /// let m = 0x3456789ABCDEF012u64;
                ///
                /// assert_eq!(n.rotate_left(12), m);
                /// ```
                fn rotate_left(self, n: u32) -> Self;

                /// Shifts the bits to the right by a specified amount, `n`, wrapping
                /// the truncated bits to the beginning of the resulting integer.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                /// let m = 0xDEF0123456789ABCu64;
                ///
                /// assert_eq!(n.rotate_right(12), m);
                /// ```
                fn rotate_right(self, n: u32) -> Self;

                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                /// let m = 0x3456789ABCDEF000u64;
                ///
                /// assert_eq!(n.signed_shl(12), m);
                /// ```
                fn signed_shl(self, n: u32) -> Self;

                /// Shifts the bits to the right by a specified amount, `n`, copying
                /// the "sign bit" in the most significant bits even for unsigned types.
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0xFEDCBA9876543210u64;
                /// let m = 0xFFFFEDCBA9876543u64;
                ///
                /// assert_eq!(n.signed_shr(12), m);
                /// ```
                fn signed_shr(self, n: u32) -> Self;

                /// Shifts the bits to the left by a specified amount, `n`, filling
                /// zeros in the least significant bits.
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFi64;
                /// let m = 0x3456789ABCDEF000i64;
                ///
                /// assert_eq!(n.unsigned_shl(12), m);
                /// ```
                fn unsigned_shl(self, n: u32) -> Self;

                /// Shifts the bits to the right by a specified amount, `n`, filling
                /// zeros in the most significant bits.
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = -8i8;
                /// let m = 62i8;
                ///
                /// assert_eq!(n.unsigned_shr(2), m);
                /// ```
                fn unsigned_shr(self, n: u32) -> Self;

                /// Reverses the byte order of the integer.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                /// let m = 0xEFCDAB8967452301u64;
                ///
                /// assert_eq!(n.swap_bytes(), m);
                /// ```
                fn swap_bytes(self) -> Self;

                /// Reverses the order of bits in the integer.
                ///
                /// The least significant bit becomes the most significant bit, second least-significant bit
                /// becomes second most-significant bit, etc.
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x12345678u32;
                /// let m = 0x1e6a2c48u32;
                ///
                /// assert_eq!(n.reverse_bits(), m);
                /// assert_eq!(0u32.reverse_bits(), 0);
                /// ```
                fn reverse_bits(self) -> Self {
                    reverse_bits_fallback(self)
                }

                /// Convert an integer from big endian to the target's endianness.
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                ///
                /// if cfg!(target_endian = "big") {
                ///     assert_eq!(u64::from_be(n), n)
                /// } else {
                ///     assert_eq!(u64::from_be(n), n.swap_bytes())
                /// }
                /// ```
                fn from_be(x: Self) -> Self;

                /// Convert an integer from little endian to the target's endianness.
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                ///
                /// if cfg!(target_endian = "little") {
                ///     assert_eq!(u64::from_le(n), n)
                /// } else {
                ///     assert_eq!(u64::from_le(n), n.swap_bytes())
                /// }
                /// ```
                fn from_le(x: Self) -> Self;

                /// Convert `self` to big endian from the target's endianness.
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                ///
                /// if cfg!(target_endian = "big") {
                ///     assert_eq!(n.to_be(), n)
                /// } else {
                ///     assert_eq!(n.to_be(), n.swap_bytes())
                /// }
                /// ```
                fn to_be(self) -> Self;

                /// Convert `self` to little endian from the target's endianness.
                ///
                /// ```
                /// use num_traits::PrimInt;
                ///
                /// let n = 0x0123456789ABCDEFu64;
                ///
                /// if cfg!(target_endian = "little") {
                ///     assert_eq!(n.to_le(), n)
                /// } else {
                ///     assert_eq!(n.to_le(), n.swap_bytes())
                /// }
                /// ```
                fn to_le(self) -> Self;

                /// Raises self to the power of `exp`, using exponentiation by squaring.
                /// use num_traits::PrimInt;
                ///
                /// assert_eq!(2i32.pow(4), 16);
                /// ```
                fn pow(self, exp: u32) -> Self;
            }

            fn one_per_byte<P: PrimInt>() -> P {
               
               
               
               
                let mut ret = P::one();
                let mut shift = 8;
                let mut b = ret.count_zeros() >> 3;
                while b != 0 {
                    ret = (ret << shift) | ret;
                    shift <<= 1;
                    b >>= 1;
                }
                ret
            }

            fn reverse_bits_fallback<P: PrimInt>(i: P) -> P {
                let rep_01: P = one_per_byte();
                let rep_03 = (rep_01 << 1) | rep_01;
                let rep_05 = (rep_01 << 2) | rep_01;
                let rep_0f = (rep_03 << 2) | rep_03;
                let rep_33 = (rep_03 << 4) | rep_03;
                let rep_55 = (rep_05 << 4) | rep_05;

               
               
                let mut ret = i.swap_bytes();
                ret = ((ret & rep_0f) << 4) | ((ret >> 4) & rep_0f);
                ret = ((ret & rep_33) << 2) | ((ret >> 2) & rep_33);
                ret = ((ret & rep_55) << 1) | ((ret >> 1) & rep_55);
                ret
            }

            macro_rules! prim_int_impl {
                ($T:ty, $S:ty, $U:ty) => {
                    impl PrimInt for $T {
                        #[inline]
                        fn count_ones(self) -> u32 {
                            <$T>::count_ones(self)
                        }

                        #[inline]
                        fn count_zeros(self) -> u32 {
                            <$T>::count_zeros(self)
                        }

                        #[inline]
                        fn leading_ones(self) -> u32 {
                            <$T>::leading_ones(self)
                        }

                        #[inline]
                        fn leading_zeros(self) -> u32 {
                            <$T>::leading_zeros(self)
                        }

                        #[inline]
                        fn trailing_ones(self) -> u32 {
                            <$T>::trailing_ones(self)
                        }

                        #[inline]
                        fn trailing_zeros(self) -> u32 {
                            <$T>::trailing_zeros(self)
                        }

                        #[inline]
                        fn rotate_left(self, n: u32) -> Self {
                            <$T>::rotate_left(self, n)
                        }

                        #[inline]
                        fn rotate_right(self, n: u32) -> Self {
                            <$T>::rotate_right(self, n)
                        }

                        #[inline]
                        fn signed_shl(self, n: u32) -> Self {
                            ((self as $S) << n) as $T
                        }

                        #[inline]
                        fn signed_shr(self, n: u32) -> Self {
                            ((self as $S) >> n) as $T
                        }

                        #[inline]
                        fn unsigned_shl(self, n: u32) -> Self {
                            ((self as $U) << n) as $T
                        }

                        #[inline]
                        fn unsigned_shr(self, n: u32) -> Self {
                            ((self as $U) >> n) as $T
                        }

                        #[inline]
                        fn swap_bytes(self) -> Self {
                            <$T>::swap_bytes(self)
                        }

                        #[inline]
                        fn reverse_bits(self) -> Self {
                            <$T>::reverse_bits(self)
                        }

                        #[inline]
                        fn from_be(x: Self) -> Self {
                            <$T>::from_be(x)
                        }

                        #[inline]
                        fn from_le(x: Self) -> Self {
                            <$T>::from_le(x)
                        }

                        #[inline]
                        fn to_be(self) -> Self {
                            <$T>::to_be(self)
                        }

                        #[inline]
                        fn to_le(self) -> Self {
                            <$T>::to_le(self)
                        }

                        #[inline]
                        fn pow(self, exp: u32) -> Self {
                            <$T>::pow(self, exp)
                        }
                    }
                };
            }
            
            prim_int_impl!(u8, i8, u8);
            prim_int_impl!(u16, i16, u16);
            prim_int_impl!(u32, i32, u32);
            prim_int_impl!(u64, i64, u64);
            prim_int_impl!(u128, i128, u128);
            prim_int_impl!(usize, isize, usize);
            prim_int_impl!(i8, i8, u8);
            prim_int_impl!(i16, i16, u16);
            prim_int_impl!(i32, i32, u32);
            prim_int_impl!(i64, i64, u64);
            prim_int_impl!(i128, i128, u128);
            prim_int_impl!(isize, isize, usize);
        } pub use self::int::PrimInt;

        pub mod ops
        {
            use ::
            {
                *,
            };
            /*
            */
            pub mod bytes
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use ::borrow::{Borrow, BorrowMut};
                    use ::cmp::{Eq, Ord, PartialEq, PartialOrd};
                    use ::fmt::Debug;
                    use ::hash::Hash;
                */
                pub trait NumBytes:
                    Debug
                    + AsRef<[u8]>
                    + AsMut<[u8]>
                    + PartialEq
                    + Eq
                    + PartialOrd
                    + Ord
                    + Hash
                    + Borrow<[u8]>
                    + BorrowMut<[u8]>
                {
                }

                impl<T> NumBytes for T where
                    T: Debug
                        + AsRef<[u8]>
                        + AsMut<[u8]>
                        + PartialEq
                        + Eq
                        + PartialOrd
                        + Ord
                        + Hash
                        + Borrow<[u8]>
                        + BorrowMut<[u8]>
                        + ?Sized
                {
                }

                pub trait ToBytes {
                    type Bytes: NumBytes;

                    /// Return the memory representation of this number as a byte array in big-endian byte order.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::ToBytes;
                    ///
                    /// let bytes = ToBytes::to_be_bytes(&0x12345678u32);
                    /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);
                    /// ```
                    fn to_be_bytes(&self) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in little-endian byte order.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::ToBytes;
                    ///
                    /// let bytes = ToBytes::to_le_bytes(&0x12345678u32);
                    /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);
                    /// ```
                    fn to_le_bytes(&self) -> Self::Bytes;

                    /// Return the memory representation of this number as a byte array in native byte order.
                    ///
                    /// As the target platform's native endianness is used,
                    /// portable code should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate, instead.
                    ///
                    /// [`to_be_bytes`]: #method.to_be_bytes
                    /// [`to_le_bytes`]: #method.to_le_bytes
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::ToBytes;
                    ///
                    /// #[cfg(target_endian = "big")]
                    /// let expected = [0x12, 0x34, 0x56, 0x78];
                    ///
                    /// #[cfg(target_endian = "little")]
                    /// let expected = [0x78, 0x56, 0x34, 0x12];
                    ///
                    /// let bytes = ToBytes::to_ne_bytes(&0x12345678u32);
                    /// assert_eq!(bytes, expected)
                    /// ```
                    fn to_ne_bytes(&self) -> Self::Bytes {
                        #[cfg(target_endian = "big")]
                        let bytes = self.to_be_bytes();
                        #[cfg(target_endian = "little")]
                        let bytes = self.to_le_bytes();
                        bytes
                    }
                }

                pub trait FromBytes: Sized {
                    type Bytes: NumBytes + ?Sized;

                    /// Create a number from its representation as a byte array in big endian.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::FromBytes;
                    ///
                    /// let value: u32 = FromBytes::from_be_bytes(&[0x12, 0x34, 0x56, 0x78]);
                    /// assert_eq!(value, 0x12345678);
                    /// ```
                    fn from_be_bytes(bytes: &Self::Bytes) -> Self;

                    /// Create a number from its representation as a byte array in little endian.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::FromBytes;
                    ///
                    /// let value: u32 = FromBytes::from_le_bytes(&[0x78, 0x56, 0x34, 0x12]);
                    /// assert_eq!(value, 0x12345678);
                    /// ```
                    fn from_le_bytes(bytes: &Self::Bytes) -> Self;

                    /// Create a number from its memory representation as a byte array in native endianness.
                    ///
                    /// As the target platform's native endianness is used,
                    /// portable code likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as appropriate instead.
                    ///
                    /// [`from_be_bytes`]: #method.from_be_bytes
                    /// [`from_le_bytes`]: #method.from_le_bytes
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::FromBytes;
                    ///
                    /// #[cfg(target_endian = "big")]
                    /// let bytes = [0x12, 0x34, 0x56, 0x78];
                    ///
                    /// #[cfg(target_endian = "little")]
                    /// let bytes = [0x78, 0x56, 0x34, 0x12];
                    ///
                    /// let value: u32 = FromBytes::from_ne_bytes(&bytes);
                    /// assert_eq!(value, 0x12345678)
                    /// ```
                    fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                        #[cfg(target_endian = "big")]
                        let this = Self::from_be_bytes(bytes);
                        #[cfg(target_endian = "little")]
                        let this = Self::from_le_bytes(bytes);
                        this
                    }
                }

                macro_rules! float_to_from_bytes_impl {
                    ($T:ty, $L:expr) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes(&self) -> Self::Bytes {
                                <$T>::to_be_bytes(*self)
                            }

                            #[inline]
                            fn to_le_bytes(&self) -> Self::Bytes {
                                <$T>::to_le_bytes(*self)
                            }

                            #[inline]
                            fn to_ne_bytes(&self) -> Self::Bytes {
                                <$T>::to_ne_bytes(*self)
                            }
                        }

                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_be_bytes(*bytes)
                            }

                            #[inline]
                            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_le_bytes(*bytes)
                            }

                            #[inline]
                            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_ne_bytes(*bytes)
                            }
                        }
                    };
                }

                macro_rules! int_to_from_bytes_impl {
                    ($T:ty, $L:expr) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes(&self) -> Self::Bytes {
                                <$T>::to_be_bytes(*self)
                            }

                            #[inline]
                            fn to_le_bytes(&self) -> Self::Bytes {
                                <$T>::to_le_bytes(*self)
                            }

                            #[inline]
                            fn to_ne_bytes(&self) -> Self::Bytes {
                                <$T>::to_ne_bytes(*self)
                            }
                        }

                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_be_bytes(*bytes)
                            }

                            #[inline]
                            fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_le_bytes(*bytes)
                            }

                            #[inline]
                            fn from_ne_bytes(bytes: &Self::Bytes) -> Self {
                                <$T>::from_ne_bytes(*bytes)
                            }
                        }
                    };
                }

                int_to_from_bytes_impl!(u8, 1);
                int_to_from_bytes_impl!(u16, 2);
                int_to_from_bytes_impl!(u32, 4);
                int_to_from_bytes_impl!(u64, 8);
                int_to_from_bytes_impl!(u128, 16);
                #[cfg(target_pointer_width = "64")]
                int_to_from_bytes_impl!(usize, 8);
                #[cfg(target_pointer_width = "32")]
                int_to_from_bytes_impl!(usize, 4);

                int_to_from_bytes_impl!(i8, 1);
                int_to_from_bytes_impl!(i16, 2);
                int_to_from_bytes_impl!(i32, 4);
                int_to_from_bytes_impl!(i64, 8);
                int_to_from_bytes_impl!(i128, 16);
                #[cfg(target_pointer_width = "64")]
                int_to_from_bytes_impl!(isize, 8);
                #[cfg(target_pointer_width = "32")]
                int_to_from_bytes_impl!(isize, 4);

                float_to_from_bytes_impl!(f32, 4);
                float_to_from_bytes_impl!(f64, 8);
            }
            
            pub mod checked
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use ::ops::{Add, Div, Mul, Rem, Shl, Shr, Sub};
                */
                /// Performs addition, returning `None` if overflow occurred.
                pub trait CheckedAdd: Sized + Add<Self, Output = Self> {
                    /// Adds two numbers, checking for overflow. If overflow happens, `None` is
                    /// returned.
                    fn checked_add(&self, v: &Self) -> Option<Self>;
                }

                macro_rules! checked_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &$t) -> Option<$t> {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                checked_impl!(CheckedAdd, checked_add, u8);
                checked_impl!(CheckedAdd, checked_add, u16);
                checked_impl!(CheckedAdd, checked_add, u32);
                checked_impl!(CheckedAdd, checked_add, u64);
                checked_impl!(CheckedAdd, checked_add, usize);
                checked_impl!(CheckedAdd, checked_add, u128);

                checked_impl!(CheckedAdd, checked_add, i8);
                checked_impl!(CheckedAdd, checked_add, i16);
                checked_impl!(CheckedAdd, checked_add, i32);
                checked_impl!(CheckedAdd, checked_add, i64);
                checked_impl!(CheckedAdd, checked_add, isize);
                checked_impl!(CheckedAdd, checked_add, i128);

                /// Performs subtraction, returning `None` if overflow occurred.
                pub trait CheckedSub: Sized + Sub<Self, Output = Self> {
                    /// Subtracts two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_sub(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedSub, checked_sub, u8);
                checked_impl!(CheckedSub, checked_sub, u16);
                checked_impl!(CheckedSub, checked_sub, u32);
                checked_impl!(CheckedSub, checked_sub, u64);
                checked_impl!(CheckedSub, checked_sub, usize);
                checked_impl!(CheckedSub, checked_sub, u128);

                checked_impl!(CheckedSub, checked_sub, i8);
                checked_impl!(CheckedSub, checked_sub, i16);
                checked_impl!(CheckedSub, checked_sub, i32);
                checked_impl!(CheckedSub, checked_sub, i64);
                checked_impl!(CheckedSub, checked_sub, isize);
                checked_impl!(CheckedSub, checked_sub, i128);

                /// Performs multiplication, returning `None` if overflow occurred.
                pub trait CheckedMul: Sized + Mul<Self, Output = Self> {
                    /// Multiplies two numbers, checking for overflow. If overflow happens,
                    /// `None` is returned.
                    fn checked_mul(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedMul, checked_mul, u8);
                checked_impl!(CheckedMul, checked_mul, u16);
                checked_impl!(CheckedMul, checked_mul, u32);
                checked_impl!(CheckedMul, checked_mul, u64);
                checked_impl!(CheckedMul, checked_mul, usize);
                checked_impl!(CheckedMul, checked_mul, u128);

                checked_impl!(CheckedMul, checked_mul, i8);
                checked_impl!(CheckedMul, checked_mul, i16);
                checked_impl!(CheckedMul, checked_mul, i32);
                checked_impl!(CheckedMul, checked_mul, i64);
                checked_impl!(CheckedMul, checked_mul, isize);
                checked_impl!(CheckedMul, checked_mul, i128);

                /// Performs division, returning `None` on division by zero or if overflow
                /// occurred.
                pub trait CheckedDiv: Sized + Div<Self, Output = Self> {
                    /// Divides two numbers, checking for overflow and division by
                    /// zero. If any of that happens, `None` is returned.
                    fn checked_div(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedDiv, checked_div, u8);
                checked_impl!(CheckedDiv, checked_div, u16);
                checked_impl!(CheckedDiv, checked_div, u32);
                checked_impl!(CheckedDiv, checked_div, u64);
                checked_impl!(CheckedDiv, checked_div, usize);
                checked_impl!(CheckedDiv, checked_div, u128);

                checked_impl!(CheckedDiv, checked_div, i8);
                checked_impl!(CheckedDiv, checked_div, i16);
                checked_impl!(CheckedDiv, checked_div, i32);
                checked_impl!(CheckedDiv, checked_div, i64);
                checked_impl!(CheckedDiv, checked_div, isize);
                checked_impl!(CheckedDiv, checked_div, i128);

                /// Performs integral remainder, returning `None` on division by zero or if
                /// overflow occurred.
                pub trait CheckedRem: Sized + Rem<Self, Output = Self> {
                    /// Finds the remainder of dividing two numbers, checking for overflow and
                    /// division by zero. If any of that happens, `None` is returned.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::CheckedRem;
                    /// use ::i32::MIN;
                    ///
                    /// assert_eq!(CheckedRem::checked_rem(&10, &7), Some(3));
                    /// assert_eq!(CheckedRem::checked_rem(&10, &-7), Some(3));
                    /// assert_eq!(CheckedRem::checked_rem(&-10, &7), Some(-3));
                    /// assert_eq!(CheckedRem::checked_rem(&-10, &-7), Some(-3));
                    ///
                    /// assert_eq!(CheckedRem::checked_rem(&10, &0), None);
                    ///
                    /// assert_eq!(CheckedRem::checked_rem(&MIN, &1), Some(0));
                    /// assert_eq!(CheckedRem::checked_rem(&MIN, &-1), None);
                    /// ```
                    fn checked_rem(&self, v: &Self) -> Option<Self>;
                }

                checked_impl!(CheckedRem, checked_rem, u8);
                checked_impl!(CheckedRem, checked_rem, u16);
                checked_impl!(CheckedRem, checked_rem, u32);
                checked_impl!(CheckedRem, checked_rem, u64);
                checked_impl!(CheckedRem, checked_rem, usize);
                checked_impl!(CheckedRem, checked_rem, u128);

                checked_impl!(CheckedRem, checked_rem, i8);
                checked_impl!(CheckedRem, checked_rem, i16);
                checked_impl!(CheckedRem, checked_rem, i32);
                checked_impl!(CheckedRem, checked_rem, i64);
                checked_impl!(CheckedRem, checked_rem, isize);
                checked_impl!(CheckedRem, checked_rem, i128);

                macro_rules! checked_impl_unary {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self) -> Option<$t> {
                                <$t>::$method(*self)
                            }
                        }
                    };
                }

                /// Performs negation, returning `None` if the result can't be represented.
                pub trait CheckedNeg: Sized {
                    /// Negates a number, returning `None` for results that can't be represented, like signed `MIN`
                    /// values that can't be positive, or non-zero unsigned values that can't be negative.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::CheckedNeg;
                    /// use ::i32::MIN;
                    ///
                    /// assert_eq!(CheckedNeg::checked_neg(&1_i32), Some(-1));
                    /// assert_eq!(CheckedNeg::checked_neg(&-1_i32), Some(1));
                    /// assert_eq!(CheckedNeg::checked_neg(&MIN), None);
                    ///
                    /// assert_eq!(CheckedNeg::checked_neg(&0_u32), Some(0));
                    /// assert_eq!(CheckedNeg::checked_neg(&1_u32), None);
                    /// ```
                    fn checked_neg(&self) -> Option<Self>;
                }

                checked_impl_unary!(CheckedNeg, checked_neg, u8);
                checked_impl_unary!(CheckedNeg, checked_neg, u16);
                checked_impl_unary!(CheckedNeg, checked_neg, u32);
                checked_impl_unary!(CheckedNeg, checked_neg, u64);
                checked_impl_unary!(CheckedNeg, checked_neg, usize);
                checked_impl_unary!(CheckedNeg, checked_neg, u128);

                checked_impl_unary!(CheckedNeg, checked_neg, i8);
                checked_impl_unary!(CheckedNeg, checked_neg, i16);
                checked_impl_unary!(CheckedNeg, checked_neg, i32);
                checked_impl_unary!(CheckedNeg, checked_neg, i64);
                checked_impl_unary!(CheckedNeg, checked_neg, isize);
                checked_impl_unary!(CheckedNeg, checked_neg, i128);

                /// Performs shift left, returning `None` on shifts larger than or equal to
                /// the type width.
                pub trait CheckedShl: Sized + Shl<u32, Output = Self> {
                    /// Checked shift left. Computes `self << rhs`, returning `None`
                    /// if `rhs` is larger than or equal to the number of bits in `self`.
                    ///
                    /// ```
                    /// use num_traits::CheckedShl;
                    ///
                    /// let x: u16 = 0x0001;
                    ///
                    /// assert_eq!(CheckedShl::checked_shl(&x, 0),  Some(0x0001));
                    /// assert_eq!(CheckedShl::checked_shl(&x, 1),  Some(0x0002));
                    /// assert_eq!(CheckedShl::checked_shl(&x, 15), Some(0x8000));
                    /// assert_eq!(CheckedShl::checked_shl(&x, 16), None);
                    /// ```
                    fn checked_shl(&self, rhs: u32) -> Option<Self>;
                }

                macro_rules! checked_shift_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, rhs: u32) -> Option<$t> {
                                <$t>::$method(*self, rhs)
                            }
                        }
                    };
                }

                checked_shift_impl!(CheckedShl, checked_shl, u8);
                checked_shift_impl!(CheckedShl, checked_shl, u16);
                checked_shift_impl!(CheckedShl, checked_shl, u32);
                checked_shift_impl!(CheckedShl, checked_shl, u64);
                checked_shift_impl!(CheckedShl, checked_shl, usize);
                checked_shift_impl!(CheckedShl, checked_shl, u128);

                checked_shift_impl!(CheckedShl, checked_shl, i8);
                checked_shift_impl!(CheckedShl, checked_shl, i16);
                checked_shift_impl!(CheckedShl, checked_shl, i32);
                checked_shift_impl!(CheckedShl, checked_shl, i64);
                checked_shift_impl!(CheckedShl, checked_shl, isize);
                checked_shift_impl!(CheckedShl, checked_shl, i128);

                /// Performs shift right, returning `None` on shifts larger than or equal to
                /// the type width.
                pub trait CheckedShr: Sized + Shr<u32, Output = Self> {
                    /// Checked shift right. Computes `self >> rhs`, returning `None`
                    /// if `rhs` is larger than or equal to the number of bits in `self`.
                    ///
                    /// ```
                    /// use num_traits::CheckedShr;
                    ///
                    /// let x: u16 = 0x8000;
                    ///
                    /// assert_eq!(CheckedShr::checked_shr(&x, 0),  Some(0x8000));
                    /// assert_eq!(CheckedShr::checked_shr(&x, 1),  Some(0x4000));
                    /// assert_eq!(CheckedShr::checked_shr(&x, 15), Some(0x0001));
                    /// assert_eq!(CheckedShr::checked_shr(&x, 16), None);
                    /// ```
                    fn checked_shr(&self, rhs: u32) -> Option<Self>;
                }

                checked_shift_impl!(CheckedShr, checked_shr, u8);
                checked_shift_impl!(CheckedShr, checked_shr, u16);
                checked_shift_impl!(CheckedShr, checked_shr, u32);
                checked_shift_impl!(CheckedShr, checked_shr, u64);
                checked_shift_impl!(CheckedShr, checked_shr, usize);
                checked_shift_impl!(CheckedShr, checked_shr, u128);

                checked_shift_impl!(CheckedShr, checked_shr, i8);
                checked_shift_impl!(CheckedShr, checked_shr, i16);
                checked_shift_impl!(CheckedShr, checked_shr, i32);
                checked_shift_impl!(CheckedShr, checked_shr, i64);
                checked_shift_impl!(CheckedShr, checked_shr, isize);
                checked_shift_impl!(CheckedShr, checked_shr, i128);

            }
            
            pub mod euclid
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use ::ops::{Div, Rem};
                */
                pub trait Euclid: Sized + Div<Self, Output = Self> + Rem<Self, Output = Self> {
                    /// Calculates Euclidean division, the matching method for `rem_euclid`.
                    ///
                    /// This computes the integer `n` such that
                    /// `self = n * v + self.rem_euclid(v)`.
                    /// In other words, the result is `self / v` rounded to the integer `n`
                    /// such that `self >= n * v`.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::Euclid;
                    ///
                    /// let a: i32 = 7;
                    /// let b: i32 = 4;
                    /// assert_eq!(Euclid::div_euclid(&a, &b), 1);
                    /// assert_eq!(Euclid::div_euclid(&-a, &b), -2);
                    /// assert_eq!(Euclid::div_euclid(&a, &-b), -1);
                    /// assert_eq!(Euclid::div_euclid(&-a, &-b), 2);
                    /// ```
                    fn div_euclid(&self, v: &Self) -> Self;

                    /// Calculates the least nonnegative remainder of `self (mod v)`.
                    ///
                    /// In particular, the return value `r` satisfies `0.0 <= r < v.abs()` in
                    /// most cases. However, due to a floating point round-off error it can
                    /// result in `r == v.abs()`, violating the mathematical definition, if
                    /// `self` is much smaller than `v.abs()` in magnitude and `self < 0.0`.
                    /// This result is not an element of the function's codomain, but it is the
                    /// closest floating point number in the real numbers and thus fulfills the
                    /// property `self == self.div_euclid(v) * v + self.rem_euclid(v)`
                    /// approximatively.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use num_traits::Euclid;
                    ///
                    /// let a: i32 = 7;
                    /// let b: i32 = 4;
                    /// assert_eq!(Euclid::rem_euclid(&a, &b), 3);
                    /// assert_eq!(Euclid::rem_euclid(&-a, &b), 1);
                    /// assert_eq!(Euclid::rem_euclid(&a, &-b), 3);
                    /// assert_eq!(Euclid::rem_euclid(&-a, &-b), 1);
                    /// ```
                    fn rem_euclid(&self, v: &Self) -> Self;

                    /// Returns both the quotient and remainder from Euclidean division.
                    ///
                    /// By default, it internally calls both `Euclid::div_euclid` and `Euclid::rem_euclid`,
                    /// but it can be overridden in order to implement some optimization.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// # use num_traits::Euclid;
                    /// let x = 5u8;
                    /// let y = 3u8;
                    ///
                    /// let div = Euclid::div_euclid(&x, &y);
                    /// let rem = Euclid::rem_euclid(&x, &y);
                    ///
                    /// assert_eq!((div, rem), Euclid::div_rem_euclid(&x, &y));
                    /// ```
                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                        (self.div_euclid(v), self.rem_euclid(v))
                    }
                }

                macro_rules! euclid_forward_impl {
                    ($($t:ty)*) => {$(
                        impl Euclid for $t {
                            #[inline]
                            fn div_euclid(&self, v: &$t) -> Self {
                                <$t>::div_euclid(*self, *v)
                            }

                            #[inline]
                            fn rem_euclid(&self, v: &$t) -> Self {
                                <$t>::rem_euclid(*self, *v)
                            }
                        }
                    )*}
                }

                euclid_forward_impl!(isize i8 i16 i32 i64 i128);
                euclid_forward_impl!(usize u8 u16 u32 u64 u128);
                euclid_forward_impl!(f32 f64);

                pub trait CheckedEuclid: Euclid {
                    /// Performs euclid division, returning `None` on division by zero or if
                    /// overflow occurred.
                    fn checked_div_euclid(&self, v: &Self) -> Option<Self>;

                    /// Finds the euclid remainder of dividing two numbers, returning `None` on
                    /// division by zero or if overflow occurred.
                    fn checked_rem_euclid(&self, v: &Self) -> Option<Self>;

                    /// Returns both the quotient and remainder from checked Euclidean division,
                    /// returning `None` on division by zero or if overflow occurred.
                    ///
                    /// By default, it internally calls both `CheckedEuclid::checked_div_euclid` and `CheckedEuclid::checked_rem_euclid`,
                    /// but it can be overridden in order to implement some optimization.
                    /// # Examples
                    ///
                    /// ```
                    /// # use num_traits::CheckedEuclid;
                    /// let x = 5u8;
                    /// let y = 3u8;
                    ///
                    /// let div = CheckedEuclid::checked_div_euclid(&x, &y);
                    /// let rem = CheckedEuclid::checked_rem_euclid(&x, &y);
                    ///
                    /// assert_eq!(Some((div.unwrap(), rem.unwrap())), CheckedEuclid::checked_div_rem_euclid(&x, &y));
                    /// ```
                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some((self.checked_div_euclid(v)?, self.checked_rem_euclid(v)?))
                    }
                }

                macro_rules! checked_euclid_forward_impl {
                    ($($t:ty)*) => {$(
                        impl CheckedEuclid for $t {
                            #[inline]
                            fn checked_div_euclid(&self, v: &$t) -> Option<Self> {
                                <$t>::checked_div_euclid(*self, *v)
                            }

                            #[inline]
                            fn checked_rem_euclid(&self, v: &$t) -> Option<Self> {
                                <$t>::checked_rem_euclid(*self, *v)
                            }
                        }
                    )*}
                }

                checked_euclid_forward_impl!(isize i8 i16 i32 i64 i128);
                checked_euclid_forward_impl!(usize u8 u16 u32 u64 u128);
            }
            
            pub mod inv
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                /// Unary operator for retrieving the multiplicative inverse, or reciprocal, of a value.
                pub trait Inv {
                    /// The result after applying the operator.
                    type Output;

                    /// Returns the multiplicative inverse of `self`.
                    ///
                    /// # Examples
                    ///
                    /// ```
                    /// use ::f64::INFINITY;
                    /// use num_traits::Inv;
                    ///
                    /// assert_eq!(7.0.inv() * 7.0, 1.0);
                    /// assert_eq!((-0.0).inv(), -INFINITY);
                    /// ```
                    fn inv(self) -> Self::Output;
                }

                impl Inv for f32 {
                    type Output = f32;
                    #[inline]
                    fn inv(self) -> f32 {
                        1.0 / self
                    }
                }
                impl Inv for f64 {
                    type Output = f64;
                    #[inline]
                    fn inv(self) -> f64 {
                        1.0 / self
                    }
                }
                impl<'a> Inv for &'a f32 {
                    type Output = f32;
                    #[inline]
                    fn inv(self) -> f32 {
                        1.0 / *self
                    }
                }
                impl<'a> Inv for &'a f64 {
                    type Output = f64;
                    #[inline]
                    fn inv(self) -> f64 {
                        1.0 / *self
                    }
                }

            }
            
            pub mod mul_add
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                ///
                /// Using `mul_add` can be more performant than an unfused multiply-add if
                /// the target architecture has a dedicated `fma` CPU instruction.
                ///
                /// ```
                /// use ::f32;
                ///
                /// let m = 10.0_f32;
                /// let x = 4.0_f32;
                /// let b = 60.0_f32;
                ///
                ///
                /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();
                ///
                /// assert!(abs_difference <= 100.0 * f32::EPSILON);
                /// ```
                pub trait MulAdd<A = Self, B = Self> {
                    /// The resulting type after applying the fused multiply-add.
                    type Output;

                    /// Performs the fused multiply-add operation `(self * a) + b`
                    fn mul_add(self, a: A, b: B) -> Self::Output;
                }

                /// The fused multiply-add assignment operation `*self = (*self * a) + b`
                pub trait MulAddAssign<A = Self, B = Self> {
                    /// Performs the fused multiply-add assignment operation `*self = (*self * a) + b`
                    fn mul_add_assign(&mut self, a: A, b: B);
                }

                    impl MulAdd<f32, f32> for f32 {
                    type Output = Self;

                    #[inline]
                    fn mul_add(self, a: Self, b: Self) -> Self::Output {
                        <Self as crate::Float>::mul_add(self, a, b)
                    }
                }

                    impl MulAdd<f64, f64> for f64 {
                    type Output = Self;

                    #[inline]
                    fn mul_add(self, a: Self, b: Self) -> Self::Output {
                        <Self as crate::Float>::mul_add(self, a, b)
                    }
                }

                macro_rules! mul_add_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            type Output = Self;

                            #[inline]
                            fn mul_add(self, a: Self, b: Self) -> Self::Output {
                                (self * a) + b
                            }
                        }
                    )*}
                }

                mul_add_impl!(MulAdd for isize i8 i16 i32 i64 i128);
                mul_add_impl!(MulAdd for usize u8 u16 u32 u64 u128);

                    impl MulAddAssign<f32, f32> for f32 {
                    #[inline]
                    fn mul_add_assign(&mut self, a: Self, b: Self) {
                        *self = <Self as crate::Float>::mul_add(*self, a, b)
                    }
                }

                    impl MulAddAssign<f64, f64> for f64 {
                    #[inline]
                    fn mul_add_assign(&mut self, a: Self, b: Self) {
                        *self = <Self as crate::Float>::mul_add(*self, a, b)
                    }
                }

                macro_rules! mul_add_assign_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            #[inline]
                            fn mul_add_assign(&mut self, a: Self, b: Self) {
                                *self = (*self * a) + b
                            }
                        }
                    )*}
                }

                mul_add_assign_impl!(MulAddAssign for isize i8 i16 i32 i64 i128);
                mul_add_assign_impl!(MulAddAssign for usize u8 u16 u32 u64 u128);
            }
            
            pub mod overflowing
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use ::ops::{Add, Mul, Sub};
                    use ::{i128, i16, i32, i64, i8, isize};
                    use ::{u128, u16, u32, u64, u8, usize};
                */
                macro_rules! overflowing_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> (Self, bool) {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                /// Performs addition with a flag for overflow.
                pub trait OverflowingAdd: Sized + Add<Self, Output = Self> {
                    /// Returns a tuple of the sum along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_add(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingAdd, overflowing_add, u8);
                overflowing_impl!(OverflowingAdd, overflowing_add, u16);
                overflowing_impl!(OverflowingAdd, overflowing_add, u32);
                overflowing_impl!(OverflowingAdd, overflowing_add, u64);
                overflowing_impl!(OverflowingAdd, overflowing_add, usize);
                overflowing_impl!(OverflowingAdd, overflowing_add, u128);

                overflowing_impl!(OverflowingAdd, overflowing_add, i8);
                overflowing_impl!(OverflowingAdd, overflowing_add, i16);
                overflowing_impl!(OverflowingAdd, overflowing_add, i32);
                overflowing_impl!(OverflowingAdd, overflowing_add, i64);
                overflowing_impl!(OverflowingAdd, overflowing_add, isize);
                overflowing_impl!(OverflowingAdd, overflowing_add, i128);

                /// Performs substraction with a flag for overflow.
                pub trait OverflowingSub: Sized + Sub<Self, Output = Self> {
                    /// Returns a tuple of the difference along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_sub(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingSub, overflowing_sub, u8);
                overflowing_impl!(OverflowingSub, overflowing_sub, u16);
                overflowing_impl!(OverflowingSub, overflowing_sub, u32);
                overflowing_impl!(OverflowingSub, overflowing_sub, u64);
                overflowing_impl!(OverflowingSub, overflowing_sub, usize);
                overflowing_impl!(OverflowingSub, overflowing_sub, u128);

                overflowing_impl!(OverflowingSub, overflowing_sub, i8);
                overflowing_impl!(OverflowingSub, overflowing_sub, i16);
                overflowing_impl!(OverflowingSub, overflowing_sub, i32);
                overflowing_impl!(OverflowingSub, overflowing_sub, i64);
                overflowing_impl!(OverflowingSub, overflowing_sub, isize);
                overflowing_impl!(OverflowingSub, overflowing_sub, i128);

                /// Performs multiplication with a flag for overflow.
                pub trait OverflowingMul: Sized + Mul<Self, Output = Self> {
                    /// Returns a tuple of the product along with a boolean indicating whether an arithmetic overflow would occur.
                    /// If an overflow would have occurred then the wrapped value is returned.
                    fn overflowing_mul(&self, v: &Self) -> (Self, bool);
                }

                overflowing_impl!(OverflowingMul, overflowing_mul, u8);
                overflowing_impl!(OverflowingMul, overflowing_mul, u16);
                overflowing_impl!(OverflowingMul, overflowing_mul, u32);
                overflowing_impl!(OverflowingMul, overflowing_mul, u64);
                overflowing_impl!(OverflowingMul, overflowing_mul, usize);
                overflowing_impl!(OverflowingMul, overflowing_mul, u128);

                overflowing_impl!(OverflowingMul, overflowing_mul, i8);
                overflowing_impl!(OverflowingMul, overflowing_mul, i16);
                overflowing_impl!(OverflowingMul, overflowing_mul, i32);
                overflowing_impl!(OverflowingMul, overflowing_mul, i64);
                overflowing_impl!(OverflowingMul, overflowing_mul, isize);
                overflowing_impl!(OverflowingMul, overflowing_mul, i128);
            }
            
            pub mod saturating
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use ::ops::{Add, Mul, Sub};
                */
                /// Saturating math operations. Deprecated, use `SaturatingAdd`, `SaturatingSub` and
                /// `SaturatingMul` instead.
                pub trait Saturating {
                    /// Saturating addition operator.
                    /// Returns a+b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_add(self, v: Self) -> Self;

                    /// Saturating subtraction operator.
                    /// Returns a-b, saturating at the numeric bounds instead of overflowing.
                    fn saturating_sub(self, v: Self) -> Self;
                }

                macro_rules! deprecated_saturating_impl {
                    ($trait_name:ident for $($t:ty)*) => {$(
                        impl $trait_name for $t {
                            #[inline]
                            fn saturating_add(self, v: Self) -> Self {
                                Self::saturating_add(self, v)
                            }

                            #[inline]
                            fn saturating_sub(self, v: Self) -> Self {
                                Self::saturating_sub(self, v)
                            }
                        }
                    )*}
                }

                deprecated_saturating_impl!(Saturating for isize i8 i16 i32 i64 i128);
                deprecated_saturating_impl!(Saturating for usize u8 u16 u32 u64 u128);

                macro_rules! saturating_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                /// Performs addition that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingAdd: Sized + Add<Self, Output = Self> {
                    /// Saturating addition. Computes `self + other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_add(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingAdd, saturating_add, u8);
                saturating_impl!(SaturatingAdd, saturating_add, u16);
                saturating_impl!(SaturatingAdd, saturating_add, u32);
                saturating_impl!(SaturatingAdd, saturating_add, u64);
                saturating_impl!(SaturatingAdd, saturating_add, usize);
                saturating_impl!(SaturatingAdd, saturating_add, u128);

                saturating_impl!(SaturatingAdd, saturating_add, i8);
                saturating_impl!(SaturatingAdd, saturating_add, i16);
                saturating_impl!(SaturatingAdd, saturating_add, i32);
                saturating_impl!(SaturatingAdd, saturating_add, i64);
                saturating_impl!(SaturatingAdd, saturating_add, isize);
                saturating_impl!(SaturatingAdd, saturating_add, i128);

                /// Performs subtraction that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingSub: Sized + Sub<Self, Output = Self> {
                    /// Saturating subtraction. Computes `self - other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_sub(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingSub, saturating_sub, u8);
                saturating_impl!(SaturatingSub, saturating_sub, u16);
                saturating_impl!(SaturatingSub, saturating_sub, u32);
                saturating_impl!(SaturatingSub, saturating_sub, u64);
                saturating_impl!(SaturatingSub, saturating_sub, usize);
                saturating_impl!(SaturatingSub, saturating_sub, u128);

                saturating_impl!(SaturatingSub, saturating_sub, i8);
                saturating_impl!(SaturatingSub, saturating_sub, i16);
                saturating_impl!(SaturatingSub, saturating_sub, i32);
                saturating_impl!(SaturatingSub, saturating_sub, i64);
                saturating_impl!(SaturatingSub, saturating_sub, isize);
                saturating_impl!(SaturatingSub, saturating_sub, i128);

                /// Performs multiplication that saturates at the numeric bounds instead of overflowing.
                pub trait SaturatingMul: Sized + Mul<Self, Output = Self> {
                    /// Saturating multiplication. Computes `self * other`, saturating at the relevant high or low boundary of
                    /// the type.
                    fn saturating_mul(&self, v: &Self) -> Self;
                }

                saturating_impl!(SaturatingMul, saturating_mul, u8);
                saturating_impl!(SaturatingMul, saturating_mul, u16);
                saturating_impl!(SaturatingMul, saturating_mul, u32);
                saturating_impl!(SaturatingMul, saturating_mul, u64);
                saturating_impl!(SaturatingMul, saturating_mul, usize);
                saturating_impl!(SaturatingMul, saturating_mul, u128);

                saturating_impl!(SaturatingMul, saturating_mul, i8);
                saturating_impl!(SaturatingMul, saturating_mul, i16);
                saturating_impl!(SaturatingMul, saturating_mul, i32);
                saturating_impl!(SaturatingMul, saturating_mul, i64);
                saturating_impl!(SaturatingMul, saturating_mul, isize);
                saturating_impl!(SaturatingMul, saturating_mul, i128);
            }
            
            pub mod wrapping
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use ::num::Wrapping;
                    use ::ops::{Add, Mul, Neg, Shl, Shr, Sub};
                */
                macro_rules! wrapping_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, v: &Self) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                    ($trait_name:ident, $method:ident, $t:ty, $rhs:ty) => {
                        impl $trait_name<$rhs> for $t {
                            #[inline]
                            fn $method(&self, v: &$rhs) -> Self {
                                <$t>::$method(*self, *v)
                            }
                        }
                    };
                }

                /// Performs addition that wraps around on overflow.
                pub trait WrappingAdd: Sized + Add<Self, Output = Self> {
                    /// Wrapping (modular) addition. Computes `self + other`, wrapping around at the boundary of
                    /// the type.
                    fn wrapping_add(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingAdd, wrapping_add, u8);
                wrapping_impl!(WrappingAdd, wrapping_add, u16);
                wrapping_impl!(WrappingAdd, wrapping_add, u32);
                wrapping_impl!(WrappingAdd, wrapping_add, u64);
                wrapping_impl!(WrappingAdd, wrapping_add, usize);
                wrapping_impl!(WrappingAdd, wrapping_add, u128);

                wrapping_impl!(WrappingAdd, wrapping_add, i8);
                wrapping_impl!(WrappingAdd, wrapping_add, i16);
                wrapping_impl!(WrappingAdd, wrapping_add, i32);
                wrapping_impl!(WrappingAdd, wrapping_add, i64);
                wrapping_impl!(WrappingAdd, wrapping_add, isize);
                wrapping_impl!(WrappingAdd, wrapping_add, i128);

                /// Performs subtraction that wraps around on overflow.
                pub trait WrappingSub: Sized + Sub<Self, Output = Self> {
                    /// Wrapping (modular) subtraction. Computes `self - other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_sub(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingSub, wrapping_sub, u8);
                wrapping_impl!(WrappingSub, wrapping_sub, u16);
                wrapping_impl!(WrappingSub, wrapping_sub, u32);
                wrapping_impl!(WrappingSub, wrapping_sub, u64);
                wrapping_impl!(WrappingSub, wrapping_sub, usize);
                wrapping_impl!(WrappingSub, wrapping_sub, u128);

                wrapping_impl!(WrappingSub, wrapping_sub, i8);
                wrapping_impl!(WrappingSub, wrapping_sub, i16);
                wrapping_impl!(WrappingSub, wrapping_sub, i32);
                wrapping_impl!(WrappingSub, wrapping_sub, i64);
                wrapping_impl!(WrappingSub, wrapping_sub, isize);
                wrapping_impl!(WrappingSub, wrapping_sub, i128);

                /// Performs multiplication that wraps around on overflow.
                pub trait WrappingMul: Sized + Mul<Self, Output = Self> {
                    /// Wrapping (modular) multiplication. Computes `self * other`, wrapping around at the boundary
                    /// of the type.
                    fn wrapping_mul(&self, v: &Self) -> Self;
                }

                wrapping_impl!(WrappingMul, wrapping_mul, u8);
                wrapping_impl!(WrappingMul, wrapping_mul, u16);
                wrapping_impl!(WrappingMul, wrapping_mul, u32);
                wrapping_impl!(WrappingMul, wrapping_mul, u64);
                wrapping_impl!(WrappingMul, wrapping_mul, usize);
                wrapping_impl!(WrappingMul, wrapping_mul, u128);

                wrapping_impl!(WrappingMul, wrapping_mul, i8);
                wrapping_impl!(WrappingMul, wrapping_mul, i16);
                wrapping_impl!(WrappingMul, wrapping_mul, i32);
                wrapping_impl!(WrappingMul, wrapping_mul, i64);
                wrapping_impl!(WrappingMul, wrapping_mul, isize);
                wrapping_impl!(WrappingMul, wrapping_mul, i128);

                macro_rules! wrapping_unary_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self) -> $t {
                                <$t>::$method(*self)
                            }
                        }
                    };
                }

                /// Performs a negation that does not panic.
                pub trait WrappingNeg: Sized {
                    /// Wrapping (modular) negation. Computes `-self`,
                    /// wrapping around at the boundary of the type.
                    ///
                    /// Since unsigned types do not have negative equivalents
                    /// all applications of this function will wrap (except for `-0`).
                    /// For values smaller than the corresponding signed type's maximum
                    /// the result is the same as casting the corresponding signed value.
                    /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where
                    /// `MAX` is the corresponding signed type's maximum.
                    ///
                    /// ```
                    /// use num_traits::WrappingNeg;
                    ///
                    /// assert_eq!(100i8.wrapping_neg(), -100);
                    /// assert_eq!((-100i8).wrapping_neg(), 100);
                    /// assert_eq!((-128i8).wrapping_neg(), -128);
                    /// ```
                    fn wrapping_neg(&self) -> Self;
                }

                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u8);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u16);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u32);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u64);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, usize);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, u128);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i8);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i16);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i32);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i64);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, isize);
                wrapping_unary_impl!(WrappingNeg, wrapping_neg, i128);

                macro_rules! wrapping_shift_impl {
                    ($trait_name:ident, $method:ident, $t:ty) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method(&self, rhs: u32) -> $t {
                                <$t>::$method(*self, rhs)
                            }
                        }
                    };
                }

                /// Performs a left shift that does not panic.
                pub trait WrappingShl: Sized + Shl<usize, Output = Self> {
                    /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    ///
                    /// ```
                    /// use num_traits::WrappingShl;
                    ///
                    /// let x: u16 = 0x0001;
                    ///
                    /// assert_eq!(WrappingShl::wrapping_shl(&x, 0),  0x0001);
                    /// assert_eq!(WrappingShl::wrapping_shl(&x, 1),  0x0002);
                    /// assert_eq!(WrappingShl::wrapping_shl(&x, 15), 0x8000);
                    /// assert_eq!(WrappingShl::wrapping_shl(&x, 16), 0x0001);
                    /// ```
                    fn wrapping_shl(&self, rhs: u32) -> Self;
                }

                wrapping_shift_impl!(WrappingShl, wrapping_shl, u8);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u16);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u32);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u64);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, usize);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, u128);

                wrapping_shift_impl!(WrappingShl, wrapping_shl, i8);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i16);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i32);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i64);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, isize);
                wrapping_shift_impl!(WrappingShl, wrapping_shl, i128);

                /// Performs a right shift that does not panic.
                pub trait WrappingShr: Sized + Shr<usize, Output = Self> {
                    /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,
                    /// where `mask` removes any high order bits of `rhs` that would
                    /// cause the shift to exceed the bitwidth of the type.
                    ///
                    /// ```
                    /// use num_traits::WrappingShr;
                    ///
                    /// let x: u16 = 0x8000;
                    ///
                    /// assert_eq!(WrappingShr::wrapping_shr(&x, 0),  0x8000);
                    /// assert_eq!(WrappingShr::wrapping_shr(&x, 1),  0x4000);
                    /// assert_eq!(WrappingShr::wrapping_shr(&x, 15), 0x0001);
                    /// assert_eq!(WrappingShr::wrapping_shr(&x, 16), 0x8000);
                    /// ```
                    fn wrapping_shr(&self, rhs: u32) -> Self;
                }

                wrapping_shift_impl!(WrappingShr, wrapping_shr, u8);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u16);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u32);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u64);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, usize);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, u128);

                wrapping_shift_impl!(WrappingShr, wrapping_shr, i8);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i16);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i32);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i64);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, isize);
                wrapping_shift_impl!(WrappingShr, wrapping_shr, i128);

               
                impl<T: WrappingAdd> WrappingAdd for Wrapping<T> where
                    Wrapping<T>: Add<Output = Wrapping<T>>,
                {
                    fn wrapping_add(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_add(&v.0))
                    }
                }
                impl<T: WrappingSub> WrappingSub for Wrapping<T> where
                    Wrapping<T>: Sub<Output = Wrapping<T>>,
                {
                    fn wrapping_sub(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_sub(&v.0))
                    }
                }
                impl<T: WrappingMul> WrappingMul for Wrapping<T> where
                    Wrapping<T>: Mul<Output = Wrapping<T>>,
                {
                    fn wrapping_mul(&self, v: &Self) -> Self {
                        Wrapping(self.0.wrapping_mul(&v.0))
                    }
                }
                impl<T: WrappingNeg> WrappingNeg for Wrapping<T> where
                    Wrapping<T>: Neg<Output = Wrapping<T>>,
                {
                    fn wrapping_neg(&self) -> Self {
                        Wrapping(self.0.wrapping_neg())
                    }
                }
                impl<T: WrappingShl> WrappingShl for Wrapping<T> where
                    Wrapping<T>: Shl<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shl(&self, rhs: u32) -> Self {
                        Wrapping(self.0.wrapping_shl(rhs))
                    }
                }
                impl<T: WrappingShr> WrappingShr for Wrapping<T> where
                    Wrapping<T>: Shr<usize, Output = Wrapping<T>>,
                {
                    fn wrapping_shr(&self, rhs: u32) -> Self {
                        Wrapping(self.0.wrapping_shr(rhs))
                    }
                }
            }
        } pub use self::ops::
        {
            bytes::{ FromBytes, ToBytes },
            checked::{ CheckedAdd, CheckedDiv, CheckedMul, CheckedNeg, CheckedRem, CheckedShl, CheckedShr, CheckedSub },
            euclid::{ CheckedEuclid, Euclid },
            inv::{ Inv },
            mul_add::{ MulAdd, MulAddAssign },
            saturating::{ Saturating, SaturatingAdd, SaturatingMul, SaturatingSub },
            wrapping::{ WrappingAdd, WrappingMul, WrappingNeg, WrappingShl, WrappingShr, WrappingSub },
        };

        pub mod pow
        {
            use ::
            {
                num::
                {
                    traits::{ CheckedMul, One, Float }, Wrapping
                },
                ops::{ Mul },
                *,
            };
            /*
            */
            /// Binary operator for raising a value to a power.
            pub trait Pow<RHS>
            {
                /// The result after applying the operator.
                type Output;

                /// Returns `self` to the power `rhs`.
                /// use num_traits::Pow;
                /// assert_eq!(Pow::pow(10u32, 2u32), 100);
                /// ```
                fn pow(self, rhs: RHS) -> Self::Output;
            }

            macro_rules! pow_impl {
                ($t:ty) =>
                {
                    pow_impl!($t, u8);
                    pow_impl!($t, usize);
                };
                ($t:ty, $rhs:ty) => {
                    pow_impl!($t, $rhs, usize, pow);
                };
                ($t:ty, $rhs:ty, $desired_rhs:ty, $method:expr) => {
                    impl Pow<$rhs> for $t {
                        type Output = $t;
                        #[inline]
                        fn pow(self, rhs: $rhs) -> $t {
                            ($method)(self, <$desired_rhs>::from(rhs))
                        }
                    }

                    impl<'a> Pow<&'a $rhs> for $t {
                        type Output = $t;
                        #[inline]
                        fn pow(self, rhs: &'a $rhs) -> $t {
                            ($method)(self, <$desired_rhs>::from(*rhs))
                        }
                    }

                    impl<'a> Pow<$rhs> for &'a $t {
                        type Output = $t;
                        #[inline]
                        fn pow(self, rhs: $rhs) -> $t {
                            ($method)(*self, <$desired_rhs>::from(rhs))
                        }
                    }

                    impl<'a, 'b> Pow<&'a $rhs> for &'b $t {
                        type Output = $t;
                        #[inline]
                        fn pow(self, rhs: &'a $rhs) -> $t {
                            ($method)(*self, <$desired_rhs>::from(*rhs))
                        }
                    }
                };
            }

            pow_impl!(u8, u8, u32, u8::pow);
            pow_impl!(u8, u16, u32, u8::pow);
            pow_impl!(u8, u32, u32, u8::pow);
            pow_impl!(u8, usize);
            pow_impl!(i8, u8, u32, i8::pow);
            pow_impl!(i8, u16, u32, i8::pow);
            pow_impl!(i8, u32, u32, i8::pow);
            pow_impl!(i8, usize);
            pow_impl!(u16, u8, u32, u16::pow);
            pow_impl!(u16, u16, u32, u16::pow);
            pow_impl!(u16, u32, u32, u16::pow);
            pow_impl!(u16, usize);
            pow_impl!(i16, u8, u32, i16::pow);
            pow_impl!(i16, u16, u32, i16::pow);
            pow_impl!(i16, u32, u32, i16::pow);
            pow_impl!(i16, usize);
            pow_impl!(u32, u8, u32, u32::pow);
            pow_impl!(u32, u16, u32, u32::pow);
            pow_impl!(u32, u32, u32, u32::pow);
            pow_impl!(u32, usize);
            pow_impl!(i32, u8, u32, i32::pow);
            pow_impl!(i32, u16, u32, i32::pow);
            pow_impl!(i32, u32, u32, i32::pow);
            pow_impl!(i32, usize);
            pow_impl!(u64, u8, u32, u64::pow);
            pow_impl!(u64, u16, u32, u64::pow);
            pow_impl!(u64, u32, u32, u64::pow);
            pow_impl!(u64, usize);
            pow_impl!(i64, u8, u32, i64::pow);
            pow_impl!(i64, u16, u32, i64::pow);
            pow_impl!(i64, u32, u32, i64::pow);
            pow_impl!(i64, usize);

            pow_impl!(u128, u8, u32, u128::pow);
            pow_impl!(u128, u16, u32, u128::pow);
            pow_impl!(u128, u32, u32, u128::pow);
            pow_impl!(u128, usize);

            pow_impl!(i128, u8, u32, i128::pow);
            pow_impl!(i128, u16, u32, i128::pow);
            pow_impl!(i128, u32, u32, i128::pow);
            pow_impl!(i128, usize);

            pow_impl!(usize, u8, u32, usize::pow);
            pow_impl!(usize, u16, u32, usize::pow);
            pow_impl!(usize, u32, u32, usize::pow);
            pow_impl!(usize, usize);
            pow_impl!(isize, u8, u32, isize::pow);
            pow_impl!(isize, u16, u32, isize::pow);
            pow_impl!(isize, u32, u32, isize::pow);
            pow_impl!(isize, usize);
            pow_impl!(Wrapping<u8>);
            pow_impl!(Wrapping<i8>);
            pow_impl!(Wrapping<u16>);
            pow_impl!(Wrapping<i16>);
            pow_impl!(Wrapping<u32>);
            pow_impl!(Wrapping<i32>);
            pow_impl!(Wrapping<u64>);
            pow_impl!(Wrapping<i64>);
            pow_impl!(Wrapping<u128>);
            pow_impl!(Wrapping<i128>);
            pow_impl!(Wrapping<usize>);
            pow_impl!(Wrapping<isize>);

            pow_impl!(f32, i8, i32, <f32 as Float>::powi);
            pow_impl!(f32, u8, i32, <f32 as Float>::powi);
            pow_impl!(f32, i16, i32, <f32 as Float>::powi);
            pow_impl!(f32, u16, i32, <f32 as Float>::powi);
            pow_impl!(f32, i32, i32, <f32 as Float>::powi);
            pow_impl!(f64, i8, i32, <f64 as Float>::powi);
            pow_impl!(f64, u8, i32, <f64 as Float>::powi);
            pow_impl!(f64, i16, i32, <f64 as Float>::powi);
            pow_impl!(f64, u16, i32, <f64 as Float>::powi);
            pow_impl!(f64, i32, i32, <f64 as Float>::powi);
            pow_impl!(f32, f32, f32, <f32 as Float>::powf);
            pow_impl!(f64, f32, f64, <f64 as Float>::powf);
            pow_impl!(f64, f64, f64, <f64 as Float>::powf);
            
            /// Raises a value to the power of exp, using exponentiation by squaring.
            /// assert_eq!(pow(6u8, 3), 216);
            /// assert_eq!(pow(0u8, 0), 1);
            /// ```
            #[inline]
            pub fn pow<T: Clone + One + Mul<T, Output = T>>(mut base: T, mut exp: usize) -> T {
                if exp == 0 {
                    return T::one();
                }

                while exp & 1 == 0 {
                    base = base.clone() * base;
                    exp >>= 1;
                }
                if exp == 1 {
                    return base;
                }

                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.clone() * base;
                    if exp & 1 == 1 {
                        acc = acc * base.clone();
                    }
                }
                acc
            }
            /// Raises a value to the power of exp, returning `None` if an overflow occurred.
            ///
            /// ```rust
            /// use num_traits::checked_pow;
            ///
            /// assert_eq!(checked_pow(2i8, 4), Some(16));
            /// assert_eq!(checked_pow(7i8, 8), None);
            /// assert_eq!(checked_pow(7u32, 8), Some(5_764_801));
            /// assert_eq!(checked_pow(0u32, 0), Some(1));
            /// ```
            #[inline]
            pub fn checked_pow<T: Clone + One + CheckedMul>(mut base: T, mut exp: usize) -> Option<T> {
                if exp == 0 {
                    return Some(T::one());
                }

                while exp & 1 == 0 {
                    base = base.checked_mul(&base)?;
                    exp >>= 1;
                }
                if exp == 1 {
                    return Some(base);
                }

                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.checked_mul(&base)?;
                    if exp & 1 == 1 {
                        acc = acc.checked_mul(&base)?;
                    }
                }
                Some(acc)
            }

        } pub use self::pow::{checked_pow, pow, Pow};

        pub mod real
        {
            use ::
            {
                num::traits::{Float, Num, NumCast},
                ops::{ Neg },
                *,
            };
            /*
            */
            /// A trait for real number types that do not necessarily have
            /// floating-point-specific characteristics such as NaN and infinity.
            pub trait Real: Num + Copy + NumCast + PartialOrd + Neg<Output = Self> {
                /// Returns the smallest finite value that this type can represent.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x: f64 = Real::min_value();
                ///
                /// assert_eq!(x, f64::MIN);
                /// ```
                fn min_value() -> Self;

                /// Returns the smallest positive, normalized value that this type can represent.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x: f64 = Real::min_positive_value();
                ///
                /// assert_eq!(x, f64::MIN_POSITIVE);
                /// ```
                fn min_positive_value() -> Self;

                /// Returns epsilon, a small positive value.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x: f64 = Real::epsilon();
                ///
                /// assert_eq!(x, f64::EPSILON);
                /// ```
                ///
                /// # Panics
                ///
                /// The default implementation will panic if `f32::EPSILON` cannot
                /// be cast to `Self`.
                fn epsilon() -> Self;

                /// Returns the largest finite value that this type can represent.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x: f64 = Real::max_value();
                /// assert_eq!(x, f64::MAX);
                /// ```
                fn max_value() -> Self;

                /// Returns the largest integer less than or equal to a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 3.99;
                /// let g = 3.0;
                ///
                /// assert_eq!(f.floor(), 3.0);
                /// assert_eq!(g.floor(), 3.0);
                /// ```
                fn floor(self) -> Self;

                /// Returns the smallest integer greater than or equal to a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 3.01;
                /// let g = 4.0;
                ///
                /// assert_eq!(f.ceil(), 4.0);
                /// assert_eq!(g.ceil(), 4.0);
                /// ```
                fn ceil(self) -> Self;

                /// Returns the nearest integer to a number. Round half-way cases away from
                /// `0.0`.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 3.3;
                /// let g = -3.3;
                ///
                /// assert_eq!(f.round(), 3.0);
                /// assert_eq!(g.round(), -3.0);
                /// ```
                fn round(self) -> Self;

                /// Return the integer part of a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 3.3;
                /// let g = -3.7;
                ///
                /// assert_eq!(f.trunc(), 3.0);
                /// assert_eq!(g.trunc(), -3.0);
                /// ```
                fn trunc(self) -> Self;

                /// Returns the fractional part of a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 3.5;
                /// let y = -3.5;
                /// let abs_difference_x = (x.fract() - 0.5).abs();
                /// let abs_difference_y = (y.fract() - (-0.5)).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                /// ```
                fn fract(self) -> Self;

                /// Computes the absolute value of `self`. Returns `Float::nan()` if the
                /// number is `Float::nan()`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x = 3.5;
                /// let y = -3.5;
                ///
                /// let abs_difference_x = (x.abs() - x).abs();
                /// let abs_difference_y = (y.abs() - (-y)).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                ///
                /// assert!(::num_traits::Float::is_nan(f64::NAN.abs()));
                /// ```
                fn abs(self) -> Self;

                /// Returns a number that represents the sign of `self`.
                ///
                /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`
                /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`
                /// - `Float::nan()` if the number is `Float::nan()`
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let f = 3.5;
                ///
                /// assert_eq!(f.signum(), 1.0);
                /// assert_eq!(f64::NEG_INFINITY.signum(), -1.0);
                ///
                /// assert!(f64::NAN.signum().is_nan());
                /// ```
                fn signum(self) -> Self;

                /// Returns `true` if `self` is positive, including `+0.0`,
                /// `Float::infinity()`, and with newer versions of Rust `f64::NAN`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let neg_nan: f64 = -f64::NAN;
                ///
                /// let f = 7.0;
                /// let g = -7.0;
                ///
                /// assert!(f.is_sign_positive());
                /// assert!(!g.is_sign_positive());
                /// assert!(!neg_nan.is_sign_positive());
                /// ```
                fn is_sign_positive(self) -> bool;

                /// Returns `true` if `self` is negative, including `-0.0`,
                /// `Float::neg_infinity()`, and with newer versions of Rust `-f64::NAN`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let nan: f64 = f64::NAN;
                ///
                /// let f = 7.0;
                /// let g = -7.0;
                ///
                /// assert!(!f.is_sign_negative());
                /// assert!(g.is_sign_negative());
                /// assert!(!nan.is_sign_negative());
                /// ```
                fn is_sign_negative(self) -> bool;

                /// Fused multiply-add. Computes `(self * a) + b` with only one rounding
                /// error, yielding a more accurate result than an unfused multiply-add.
                ///
                /// Using `mul_add` can be more performant than an unfused multiply-add if
                /// the target architecture has a dedicated `fma` CPU instruction.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let m = 10.0;
                /// let x = 4.0;
                /// let b = 60.0;
                ///
                ///
                /// let abs_difference = (m.mul_add(x, b) - (m*x + b)).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn mul_add(self, a: Self, b: Self) -> Self;

                /// Take the reciprocal (inverse) of a number, `1/x`.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.recip() - (1.0/x)).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn recip(self) -> Self;

                /// Raise a number to an integer power.
                /// use num_traits::real::Real;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.powi(2) - x*x).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn powi(self, n: i32) -> Self;

                /// Raise a number to a real number power.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 2.0;
                /// let abs_difference = (x.powf(2.0) - x*x).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn powf(self, n: Self) -> Self;

                /// Take the square root of a number.
                /// use num_traits::real::Real;
                ///
                /// let positive = 4.0;
                /// let negative = -4.0;
                ///
                /// let abs_difference = (positive.sqrt() - 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// assert!(::num_traits::Float::is_nan(negative.sqrt()));
                /// ```
                fn sqrt(self) -> Self;

                /// Returns `e^(self)`, (the exponential function).
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let one = 1.0;
                ///
                /// let e = one.exp();
                ///
                ///
                /// let abs_difference = (e.ln() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp(self) -> Self;

                /// Returns `2^(self)`.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 2.0;
                ///
                ///
                /// let abs_difference = (f.exp2() - 4.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp2(self) -> Self;

                /// Returns the natural logarithm of the number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let one = 1.0;
                ///
                /// let e = one.exp();
                ///
                ///
                /// let abs_difference = (e.ln() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn ln(self) -> Self;

                /// Returns the logarithm of the number with respect to an arbitrary base.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let ten = 10.0;
                /// let two = 2.0;
                ///
                ///
                /// let abs_difference_10 = (ten.log(10.0) - 1.0).abs();
                ///
                ///
                /// let abs_difference_2 = (two.log(2.0) - 1.0).abs();
                ///
                /// assert!(abs_difference_10 < 1e-10);
                /// assert!(abs_difference_2 < 1e-10);
                /// ```
                fn log(self, base: Self) -> Self;

                /// Returns the base 2 logarithm of the number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let two = 2.0;
                ///
                ///
                /// let abs_difference = (two.log2() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn log2(self) -> Self;

                /// Returns the base 10 logarithm of the number.
                ///
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let ten = 10.0;
                ///
                ///
                /// let abs_difference = (ten.log10() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn log10(self) -> Self;

                /// Converts radians to degrees.
                ///
                /// ```
                /// use ::f64::consts;
                ///
                /// let angle = consts::PI;
                ///
                /// let abs_difference = (angle.to_degrees() - 180.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn to_degrees(self) -> Self;

                /// Converts degrees to radians.
                ///
                /// ```
                /// use ::f64::consts;
                ///
                /// let angle = 180.0_f64;
                ///
                /// let abs_difference = (angle.to_radians() - consts::PI).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn to_radians(self) -> Self;

                /// Returns the maximum of the two numbers.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                ///
                /// assert_eq!(x.max(y), y);
                /// ```
                fn max(self, other: Self) -> Self;

                /// Returns the minimum of the two numbers.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 1.0;
                /// let y = 2.0;
                ///
                /// assert_eq!(x.min(y), x);
                /// ```
                fn min(self, other: Self) -> Self;

                /// The positive difference of two numbers.
                ///
                /// * If `self <= other`: `0:0`
                /// * Else: `self - other`
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 3.0;
                /// let y = -3.0;
                ///
                /// let abs_difference_x = (x.abs_sub(1.0) - 2.0).abs();
                /// let abs_difference_y = (y.abs_sub(1.0) - 0.0).abs();
                ///
                /// assert!(abs_difference_x < 1e-10);
                /// assert!(abs_difference_y < 1e-10);
                /// ```
                fn abs_sub(self, other: Self) -> Self;

                /// Take the cubic root of a number.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 8.0;
                ///
                ///
                /// let abs_difference = (x.cbrt() - 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn cbrt(self) -> Self;

                /// Calculate the length of the hypotenuse of a right-angle triangle given
                /// legs of length `x` and `y`.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 2.0;
                /// let y = 3.0;
                ///
                ///
                /// let abs_difference = (x.hypot(y) - (x.powi(2) + y.powi(2)).sqrt()).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn hypot(self, other: Self) -> Self;

                /// Computes the sine of a number (in radians).
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x = f64::consts::PI/2.0;
                ///
                /// let abs_difference = (x.sin() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn sin(self) -> Self;

                /// Computes the cosine of a number (in radians).
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x = 2.0*f64::consts::PI;
                ///
                /// let abs_difference = (x.cos() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn cos(self) -> Self;

                /// Computes the tangent of a number (in radians).
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x = f64::consts::PI/4.0;
                /// let abs_difference = (x.tan() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-14);
                /// ```
                fn tan(self) -> Self;

                /// Computes the arcsine of a number. Return value is in radians in
                /// the range [-pi/2, pi/2] or NaN if the number is outside the range
                /// [-1, 1].
                /// if the number is outside the range [-1, 1].
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let f = f64::consts::PI / 2.0;
                ///
                ///
                /// let abs_difference = (f.sin().asin() - f64::consts::PI / 2.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn asin(self) -> Self;

                /// Computes the arccosine of a number. Return value is in radians in
                /// the range [0, pi] or NaN if the number is outside the range
                /// [-1, 1].
                /// if the number is outside the range [-1, 1].
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let f = f64::consts::PI / 4.0;
                ///
                ///
                /// let abs_difference = (f.cos().acos() - f64::consts::PI / 4.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn acos(self) -> Self;

                /// Computes the arctangent of a number. Return value is in radians in the
                /// range [-pi/2, pi/2];
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let f = 1.0;
                ///
                ///
                /// let abs_difference = (f.tan().atan() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn atan(self) -> Self;

                /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).
                ///
                /// * `x = 0`, `y = 0`: `0`
                /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`
                /// * `y >= 0`: `arctan(y/x) + pi` -> `(pi/2, pi]`
                /// * `y < 0`: `arctan(y/x) - pi` -> `(-pi, -pi/2)`
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let pi = f64::consts::PI;
                ///
                ///
                /// let x1 = 3.0;
                /// let y1 = -3.0;
                ///
                ///
                /// let x2 = -3.0;
                /// let y2 = 3.0;
                ///
                /// let abs_difference_1 = (y1.atan2(x1) - (-pi/4.0)).abs();
                /// let abs_difference_2 = (y2.atan2(x2) - 3.0*pi/4.0).abs();
                ///
                /// assert!(abs_difference_1 < 1e-10);
                /// assert!(abs_difference_2 < 1e-10);
                /// ```
                fn atan2(self, other: Self) -> Self;

                /// Simultaneously computes the sine and cosine of the number, `x`. Returns
                /// `(sin(x), cos(x))`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x = f64::consts::PI/4.0;
                /// let f = x.sin_cos();
                ///
                /// let abs_difference_0 = (f.0 - x.sin()).abs();
                /// let abs_difference_1 = (f.1 - x.cos()).abs();
                ///
                /// assert!(abs_difference_0 < 1e-10);
                /// assert!(abs_difference_0 < 1e-10);
                /// ```
                fn sin_cos(self) -> (Self, Self);

                /// Returns `e^(self) - 1` in a way that is accurate even if the
                /// number is close to zero.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 7.0;
                ///
                ///
                /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn exp_m1(self) -> Self;

                /// Returns `ln(1+n)` (natural logarithm) more accurately than if
                /// the operations were performed separately.
                /// if `self-1 <= 0`.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let x = f64::consts::E - 1.0;
                ///
                ///
                /// let abs_difference = (x.ln_1p() - 1.0).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn ln_1p(self) -> Self;

                /// Hyperbolic sine function.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                ///
                /// let f = x.sinh();
                ///
                /// let g = (e*e - 1.0)/(2.0*e);
                /// let abs_difference = (f - g).abs();
                ///
                /// assert!(abs_difference < 1e-10);
                /// ```
                fn sinh(self) -> Self;

                /// Hyperbolic cosine function.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                /// let f = x.cosh();
                ///
                /// let g = (e*e + 1.0)/(2.0*e);
                /// let abs_difference = (f - g).abs();
                ///
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn cosh(self) -> Self;

                /// Hyperbolic tangent function.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let e = f64::consts::E;
                /// let x = 1.0;
                ///
                /// let f = x.tanh();
                ///
                /// let g = (1.0 - e.powi(-2))/(1.0 + e.powi(-2));
                /// let abs_difference = (f - g).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn tanh(self) -> Self;

                /// Inverse hyperbolic sine function.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 1.0;
                /// let f = x.sinh().asinh();
                ///
                /// let abs_difference = (f - x).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn asinh(self) -> Self;

                /// Inverse hyperbolic cosine function.
                ///
                /// ```
                /// use num_traits::real::Real;
                ///
                /// let x = 1.0;
                /// let f = x.cosh().acosh();
                ///
                /// let abs_difference = (f - x).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn acosh(self) -> Self;

                /// Inverse hyperbolic tangent function.
                ///
                /// ```
                /// use num_traits::real::Real;
                /// use ::f64;
                ///
                /// let e = f64::consts::E;
                /// let f = e.tanh().atanh();
                ///
                /// let abs_difference = (f - e).abs();
                ///
                /// assert!(abs_difference < 1.0e-10);
                /// ```
                fn atanh(self) -> Self;
            }

            impl<T: Float> Real for T {
                forward! {
                    Float::min_value() -> Self;
                    Float::min_positive_value() -> Self;
                    Float::epsilon() -> Self;
                    Float::max_value() -> Self;
                }
                forward! {
                    Float::floor(self) -> Self;
                    Float::ceil(self) -> Self;
                    Float::round(self) -> Self;
                    Float::trunc(self) -> Self;
                    Float::fract(self) -> Self;
                    Float::abs(self) -> Self;
                    Float::signum(self) -> Self;
                    Float::is_sign_positive(self) -> bool;
                    Float::is_sign_negative(self) -> bool;
                    Float::mul_add(self, a: Self, b: Self) -> Self;
                    Float::recip(self) -> Self;
                    Float::powi(self, n: i32) -> Self;
                    Float::powf(self, n: Self) -> Self;
                    Float::sqrt(self) -> Self;
                    Float::exp(self) -> Self;
                    Float::exp2(self) -> Self;
                    Float::ln(self) -> Self;
                    Float::log(self, base: Self) -> Self;
                    Float::log2(self) -> Self;
                    Float::log10(self) -> Self;
                    Float::to_degrees(self) -> Self;
                    Float::to_radians(self) -> Self;
                    Float::max(self, other: Self) -> Self;
                    Float::min(self, other: Self) -> Self;
                    Float::abs_sub(self, other: Self) -> Self;
                    Float::cbrt(self) -> Self;
                    Float::hypot(self, other: Self) -> Self;
                    Float::sin(self) -> Self;
                    Float::cos(self) -> Self;
                    Float::tan(self) -> Self;
                    Float::asin(self) -> Self;
                    Float::acos(self) -> Self;
                    Float::atan(self) -> Self;
                    Float::atan2(self, other: Self) -> Self;
                    Float::sin_cos(self) -> (Self, Self);
                    Float::exp_m1(self) -> Self;
                    Float::ln_1p(self) -> Self;
                    Float::sinh(self) -> Self;
                    Float::cosh(self) -> Self;
                    Float::tanh(self) -> Self;
                    Float::asinh(self) -> Self;
                    Float::acosh(self) -> Self;
                    Float::atanh(self) -> Self;
                }
            }

        }

        pub mod sign
        {
            use ::
            {
                num::
                {
                    traits::{ float::FloatCore, Num },
                },
                ops::{ Neg },
                *,
            };
            /*
            */
            /// Useful functions for signed numbers (i.e. numbers that can be negative).
            pub trait Signed: Sized + Num + Neg<Output = Self>
            {
                /// Computes the absolute value.
                fn abs(&self) -> Self;

                /// The positive difference of two numbers.
                ///
                /// Returns `zero` if the number is less than or equal to `other`, otherwise the difference
                /// between `self` and `other` is returned.
                fn abs_sub(&self, other: &Self) -> Self;

                /// Returns the sign of the number.
                /// * `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
                /// * `NaN` if the number is `NaN`
                ///
                /// For signed integers:
                ///
                /// * `0` if the number is zero
                /// * `1` if the number is positive
                /// * `-1` if the number is negative
                fn signum(&self) -> Self;

                /// Returns true if the number is positive and false if the number is zero or negative.
                fn is_positive(&self) -> bool;

                /// Returns true if the number is negative and false if the number is zero or positive.
                fn is_negative(&self) -> bool;
            }

            macro_rules! signed_impl {
                ($($t:ty)*) => ($(
                    impl Signed for $t {
                        #[inline]
                        fn abs(&self) -> $t {
                            if self.is_negative() { -*self } else { *self }
                        }

                        #[inline]
                        fn abs_sub(&self, other: &$t) -> $t {
                            if *self <= *other { 0 } else { *self - *other }
                        }

                        #[inline]
                        fn signum(&self) -> $t {
                            match *self {
                                n if n > 0 => 1,
                                0 => 0,
                                _ => -1,
                            }
                        }

                        #[inline]
                        fn is_positive(&self) -> bool { *self > 0 }

                        #[inline]
                        fn is_negative(&self) -> bool { *self < 0 }
                    }
                )*)
            }

            signed_impl!(isize i8 i16 i32 i64 i128);

            impl<T: Signed> Signed for Wrapping<T> where
                Wrapping<T>: Num + Neg<Output = Wrapping<T>>,
            {
                #[inline]
                fn abs(&self) -> Self {
                    Wrapping(self.0.abs())
                }

                #[inline]
                fn abs_sub(&self, other: &Self) -> Self {
                    Wrapping(self.0.abs_sub(&other.0))
                }

                #[inline]
                fn signum(&self) -> Self {
                    Wrapping(self.0.signum())
                }

                #[inline]
                fn is_positive(&self) -> bool {
                    self.0.is_positive()
                }

                #[inline]
                fn is_negative(&self) -> bool {
                    self.0.is_negative()
                }
            }

            macro_rules! signed_float_impl {
                ($t:ty) => {
                    impl Signed for $t {
                        /// Computes the absolute value. Returns `NAN` if the number is `NAN`.
                        #[inline]
                        fn abs(&self) -> $t {
                            Float::abs(*self)
                        }

                        /// The positive difference of two numbers. Returns `0.0` if the number is
                        /// less than or equal to `other`, otherwise the difference between`self`
                        /// and `other` is returned.
                        #[inline]
                        fn abs_sub(&self, other: &$t) -> $t {
                            if *self <= *other {
                                0.
                            } else {
                                *self - *other
                            }
                        }

                        /// # Returns
                        ///
                        /// - `1.0` if the number is positive, `+0.0` or `INFINITY`
                        /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`
                        /// - `NAN` if the number is NaN
                        #[inline]
                        fn signum(&self) -> $t {
                            Float::signum(*self)
                        }

                        /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`
                        #[inline]
                        fn is_positive(&self) -> bool {
                            Float::is_sign_positive(*self)
                        }

                        /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`
                        #[inline]
                        fn is_negative(&self) -> bool {
                            Float::is_sign_negative(*self)
                        }
                    }
                };
            }

            signed_float_impl!(f32);
            signed_float_impl!(f64);
            /// Computes the absolute value.
            #[inline( always )] pub fn abs<T: Signed>(value: T) -> T {
                value.abs()
            }
            /// The positive difference of two numbers.
            #[inline( always )] pub fn abs_sub<T: Signed>(x: T, y: T) -> T {
                x.abs_sub(&y)
            }
            /// Returns the sign of the number.
            #[inline( always )] pub fn signum<T: Signed>(value: T) -> T {
                value.signum()
            }
            /// A trait for values which cannot be negative
            pub trait Unsigned: Num {}

            macro_rules! empty_trait_impl
            {
                ($name:ident for $($t:ty)*) => ($(
                    impl $name for $t {}
                )*)
            }

            empty_trait_impl!(Unsigned for usize u8 u16 u32 u64 u128);

            impl<T: Unsigned> Unsigned for Wrapping<T> where Wrapping<T>: Num {}
        } pub use self::sign::{abs, abs_sub, signum, Signed, Unsigned};

        /// The base trait for numeric types, covering `0` and `1` values,
        /// comparisons, basic numeric operations, and string conversion.
        pub trait Num: PartialEq + Zero + One + NumOps
        {
            type FromStrRadixErr;

            /// Convert from a string and radix (typically `2..=36`).
            /// use num_traits::Num;
            ///
            /// let result = <i32 as Num>::from_str_radix("27", 10);
            /// assert_eq!(result, Ok(27));
            ///
            /// let result = <i32 as Num>::from_str_radix("foo", 10);
            /// assert!(result.is_err());
            /// ```
            ///
            /// # Supported radices
            ///
            /// The exact range of supported radices is at the discretion of each type implementation. For
            /// primitive integers, this is implemented by the inherent `from_str_radix` methods in the
            /// standard library, which **panic** if the radix is not in the range from 2 to 36. The
            /// implementation in this crate for primitive floats is similar.
            /// It's possible that a type might not even support the common radix 10, nor any, if string
            /// parsing doesn't make sense for that type.
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr>;
        }
        /// Generic trait for types implementing basic numeric operations
        ///
        /// This is automatically implemented for types which implement the operators.
        pub trait NumOps<Rhs = Self, Output = Self>:
            Add<Rhs, Output = Output>
            + Sub<Rhs, Output = Output>
            + Mul<Rhs, Output = Output>
            + Div<Rhs, Output = Output>
            + Rem<Rhs, Output = Output>
        {
        }

        impl<T, Rhs, Output> NumOps<Rhs, Output> for T where
            T: Add<Rhs, Output = Output>
                + Sub<Rhs, Output = Output>
                + Mul<Rhs, Output = Output>
                + Div<Rhs, Output = Output>
                + Rem<Rhs, Output = Output>
        {
        }
        /// The trait for `Num` types which also implement numeric operations taking
        /// the second operand by reference.
        pub trait NumRef: Num + for<'r> NumOps<&'r Self> {}
        impl<T> NumRef for T where T: Num + for<'r> NumOps<&'r T> {}
        /// The trait for `Num` references which implement numeric operations, taking the
        /// second operand either by value or by reference.
        pub trait RefNum<Base>: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        impl<T, Base> RefNum<Base> for T where T: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        /// Generic trait for types implementing numeric assignment operators (like `+=`).
        pub trait NumAssignOps<Rhs = Self>:
        AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }

        impl<T, Rhs> NumAssignOps<Rhs> for T where
            T: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }
        /// The trait for `Num` types which also implement assignment operators.
        pub trait NumAssign: Num + NumAssignOps {}
        impl<T> NumAssign for T where T: Num + NumAssignOps {}
        /// The trait for `NumAssign` types which also implement assignment operations
        /// taking the second operand by reference.
        pub trait NumAssignRef: NumAssign + for<'r> NumAssignOps<&'r Self> {}
        impl<T> NumAssignRef for T where T: NumAssign + for<'r> NumAssignOps<&'r T> {}

        macro_rules! int_trait_impl {
            ($name:ident for $($t:ty)*) => ($(
                impl $name for $t {
                    type FromStrRadixErr = ::num::ParseIntError;
                    #[inline]
                    fn from_str_radix(s: &str, radix: u32)
                                    -> Result<Self, ::num::ParseIntError>
                    {
                        <$t>::from_str_radix(s, radix)
                    }
                }
            )*)
        }
        int_trait_impl!(Num for usize u8 u16 u32 u64 u128);
        int_trait_impl!(Num for isize i8 i16 i32 i64 i128);

        impl<T: Num> Num for Wrapping<T> where
            Wrapping<T>: NumOps,
        {
            type FromStrRadixErr = T::FromStrRadixErr;
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> {
                T::from_str_radix(str, radix).map(Wrapping)
            }
        }

        #[cfg(has_num_saturating)]
        impl<T: Num> Num for ::num::Saturating<T> where
            ::num::Saturating<T>: NumOps,
        {
            type FromStrRadixErr = T::FromStrRadixErr;
            fn from_str_radix(str: &str, radix: u32) -> Result<Self, Self::FromStrRadixErr> {
                T::from_str_radix(str, radix).map(::num::Saturating)
            }
        }

        #[derive(Debug)]
        pub enum FloatErrorKind {
            Empty,
            Invalid,
        }
       
       
        #[derive(Debug)]
        pub struct ParseFloatError {
            pub kind: FloatErrorKind,
        }

        impl fmt::Display for ParseFloatError {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {let description = match self.kind {
                    FloatErrorKind::Empty => "cannot parse float from empty string",
                    FloatErrorKind::Invalid => "invalid float literal",
                };

                description.fmt(f)
            }
        }

        fn str_to_ascii_lower_eq_str(a: &str, b: &str) -> bool {
            a.len() == b.len()
                && a.bytes().zip(b.bytes()).all(|(a, b)| {
                    let a_to_ascii_lower = a | (((b'A' <= a && a <= b'Z') as u8) << 5);
                    a_to_ascii_lower == b
                })
        }

       
       
       
        macro_rules! float_trait_impl {
            ($name:ident for $($t:ident)*) => ($(
                impl $name for $t {
                    type FromStrRadixErr = ParseFloatError;

                    fn from_str_radix(src: &str, radix: u32)
                                    -> Result<Self, Self::FromStrRadixErr>
                    {
                        use self::FloatErrorKind::*;
                        use self::ParseFloatError as PFE;

                       
                        if radix == 10 {
                            return src.parse().map_err(|_| PFE {
                                kind: if src.is_empty() { Empty } else { Invalid },
                            });
                        }

                       
                        if str_to_ascii_lower_eq_str(src, "inf")
                            || str_to_ascii_lower_eq_str(src, "infinity")
                        {
                            return Ok(::$t::INFINITY);
                        } else if str_to_ascii_lower_eq_str(src, "-inf")
                            || str_to_ascii_lower_eq_str(src, "-infinity")
                        {
                            return Ok(::$t::NEG_INFINITY);
                        } else if str_to_ascii_lower_eq_str(src, "nan") {
                            return Ok(::$t::NAN);
                        } else if str_to_ascii_lower_eq_str(src, "-nan") {
                            return Ok(-::$t::NAN);
                        }

                        fn slice_shift_char(src: &str) -> Option<(char, &str)> {
                            let mut chars = src.chars();
                            Some((chars.next()?, chars.as_str()))
                        }

                        let (is_positive, src) =  match slice_shift_char(src) {
                            None             => return Err(PFE { kind: Empty }),
                            Some(('-', ""))  => return Err(PFE { kind: Empty }),
                            Some(('-', src)) => (false, src),
                            Some((_, _))     => (true,  src),
                        };

                       
                        let mut sig = if is_positive { 0.0 } else { -0.0 };
                       
                        let mut prev_sig = sig;
                        let mut cs = src.chars().enumerate();
                       
                        let mut exp_info = None::<(char, usize)>;

                       
                        for (i, c) in cs.by_ref() {
                            match c.to_digit(radix) {
                                Some(digit) => {
                                   
                                    sig *= radix as $t;

                                   
                                    if is_positive {
                                        sig += (digit as isize) as $t;
                                    } else {
                                        sig -= (digit as isize) as $t;
                                    }

                                   
                                   
                                    if prev_sig != 0.0 {
                                        if is_positive && sig <= prev_sig
                                            { return Ok(::$t::INFINITY); }
                                        if !is_positive && sig >= prev_sig
                                            { return Ok(::$t::NEG_INFINITY); }

                                       
                                        if is_positive && (prev_sig != (sig - digit as $t) / radix as $t)
                                            { return Ok(::$t::INFINITY); }
                                        if !is_positive && (prev_sig != (sig + digit as $t) / radix as $t)
                                            { return Ok(::$t::NEG_INFINITY); }
                                    }
                                    prev_sig = sig;
                                },
                                None => match c {
                                    'e' | 'E' | 'p' | 'P' => {
                                        exp_info = Some((c, i + 1));
                                        break; 
                                    },
                                    '.' => {
                                        break; 
                                    },
                                    _ => {
                                        return Err(PFE { kind: Invalid });
                                    },
                                },
                            }
                        }

                       
                       
                        if exp_info.is_none() {
                            let mut power = 1.0;
                            for (i, c) in cs.by_ref() {
                                match c.to_digit(radix) {
                                    Some(digit) => {
                                       
                                        power /= radix as $t;
                                       
                                        sig = if is_positive {
                                            sig + (digit as $t) * power
                                        } else {
                                            sig - (digit as $t) * power
                                        };
                                       
                                        if is_positive && sig < prev_sig
                                            { return Ok(::$t::INFINITY); }
                                        if !is_positive && sig > prev_sig
                                            { return Ok(::$t::NEG_INFINITY); }
                                        prev_sig = sig;
                                    },
                                    None => match c {
                                        'e' | 'E' | 'p' | 'P' => {
                                            exp_info = Some((c, i + 1));
                                            break;
                                        },
                                        _ => {
                                            return Err(PFE { kind: Invalid });
                                        },
                                    },
                                }
                            }
                        }

                       
                        let exp = match exp_info {
                            Some((c, offset)) => {
                                let base = match c {
                                    'E' | 'e' if radix == 10 => 10.0,
                                    'P' | 'p' if radix == 16 => 2.0,
                                    _ => return Err(PFE { kind: Invalid }),
                                };

                               
                                let src = &src[offset..];
                                let (is_positive, exp) = match slice_shift_char(src) {
                                    Some(('-', src)) => (false, src.parse::<usize>()),
                                    Some(('+', src)) => (true,  src.parse::<usize>()),
                                    Some((_, _))     => (true,  src.parse::<usize>()),
                                    None             => return Err(PFE { kind: Invalid }),
                                };

                                                    fn pow(base: $t, exp: usize) -> $t {
                                    Float::powi(base, exp as i32)
                                }
                               

                                match (is_positive, exp) {
                                    (true,  Ok(exp)) => pow(base, exp),
                                    (false, Ok(exp)) => 1.0 / pow(base, exp),
                                    (_, Err(_))      => return Err(PFE { kind: Invalid }),
                                }
                            },
                            None => 1.0,
                        };

                        Ok(sig * exp)
                    }
                }
            )*)
        }
        float_trait_impl!(Num for f32 f64);

        /// A value bounded by a minimum and a maximum
        #[inline] pub fn clamp<T: PartialOrd>(input: T, min: T, max: T) -> T {
            debug_assert!(min <= max, "min must be less than or equal to max");
            if input < min {
                min
            } else if input > max {
                max
            } else {
                input
            }
        }
        /// A value bounded by a minimum value
        #[inline]
        #[allow(clippy::eq_op)]
        pub fn clamp_min<T: PartialOrd>(input: T, min: T) -> T {
            debug_assert!(min == min, "min must not be NAN");
            if input < min {
                min
            } else {
                input
            }
        }
        /// A value bounded by a maximum value
        #[inline]
        #[allow(clippy::eq_op)]
        pub fn clamp_max<T: PartialOrd>(input: T, max: T) -> T {
            debug_assert!(max == max, "max must not be NAN");
            if input > max {
                max
            } else {
                input
            }
        }
    }
    /*
    */
    pub mod integers
    {
        //! Integer trait and functions.
        use ::
        {
            num::{ traits::{ Num, Signed, Zero } },
            ops::{ Add },
            *,
        };
        /*
        */
        pub mod average
        {
            /*!
            */
            use ::
            {
                num::integers::{ Integer },
                ops::{BitAnd, BitOr, BitXor, Shr},
                *,
            };
            /*
            */
            /// Provides methods to compute the average of two integers, without overflows.
            pub trait Average: Integer {
                /// Returns the ceiling value of the average of `self` and `other`.
                /// -- `⌈(self + other)/2⌉`
                ///
                /// # Examples
                ///
                /// ```
                /// use num_integer::Average;
                ///
                /// assert_eq!(( 3).average_ceil(&10),  7);
                /// assert_eq!((-2).average_ceil(&-5), -3);
                /// assert_eq!(( 4).average_ceil(& 4),  4);
                ///
                /// assert_eq!(u8::max_value().average_ceil(&2), 129);
                /// assert_eq!(i8::min_value().average_ceil(&-1), -64);
                /// assert_eq!(i8::min_value().average_ceil(&i8::max_value()), 0);
                /// ```
                ///
                fn average_ceil(&self, other: &Self) -> Self;

                /// Returns the floor value of the average of `self` and `other`.
                /// -- `⌊(self + other)/2⌋`
                ///
                /// # Examples
                ///
                /// ```
                /// use num_integer::Average;
                ///
                /// assert_eq!(( 3).average_floor(&10),  6);
                /// assert_eq!((-2).average_floor(&-5), -4);
                /// assert_eq!(( 4).average_floor(& 4),  4);
                ///
                /// assert_eq!(u8::max_value().average_floor(&2), 128);
                /// assert_eq!(i8::min_value().average_floor(&-1), -65);
                /// assert_eq!(i8::min_value().average_floor(&i8::max_value()), -1);
                /// ```
                ///
                fn average_floor(&self, other: &Self) -> Self;
            }

            impl<I> Average for I
            where
                I: Integer + Shr<usize, Output = I>,
                for<'a, 'b> &'a I:
                    BitAnd<&'b I, Output = I> + BitOr<&'b I, Output = I> + BitXor<&'b I, Output = I>,
            {
               
               

                /// Returns the floor value of the average of `self` and `other`.
                #[inline]
                fn average_floor(&self, other: &I) -> I {
                    (self & other) + ((self ^ other) >> 1)
                }

                /// Returns the ceil value of the average of `self` and `other`.
                #[inline]
                fn average_ceil(&self, other: &I) -> I {
                    (self | other) - ((self ^ other) >> 1)
                }
            }
            /// Returns the floor value of the average of `x` and `y` --
            /// see [Average::average_floor](trait.Average.html#tymethod.average_floor).
            #[inline]
            pub fn average_floor<T: Average>(x: T, y: T) -> T {
                x.average_floor(&y)
            }
            /// Returns the ceiling value of the average of `x` and `y` --
            /// see [Average::average_ceil](trait.Average.html#tymethod.average_ceil).
            #[inline]
            pub fn average_ceil<T: Average>(x: T, y: T) -> T {
                x.average_ceil(&y)
            }
        } pub use self::average::{average_ceil, average_floor, Average};

        pub mod roots
        {
            /*!
            */
            use ::
            {
                num::
                {
                    traits::{checked_pow, PrimInt},
                    integers::{ Integer },
                },
                *,
            };
            /*
            */
            /// Provides methods to compute an integer's square root, cube root,
            /// and arbitrary `n`th root.
            pub trait Roots: Integer {
                /// Returns the truncated principal `n`th root of an integer
                /// -- `if x >= 0 { ⌊ⁿ√x⌋ } else { ⌈ⁿ√x⌉ }`
                ///
                /// This is solving for `r` in `rⁿ = x`, rounding toward zero.
                /// If `x` is positive, the result will satisfy `rⁿ ≤ x < (r+1)ⁿ`.
                /// If `x` is negative and `n` is odd, then `(r-1)ⁿ < x ≤ rⁿ`.
                ///
                /// ```should_panic
                /// # use num_integer::Roots;
                /// println!("can't compute ⁰√x : {}", 123.nth_root(0));
                /// ```
                ///
                /// or if `n` is even and `self` is negative:
                ///
                /// ```should_panic
                /// # use num_integer::Roots;
                /// println!("no imaginary numbers... {}", (-1).nth_root(10));
                /// ```
                ///
                /// # Examples
                ///
                /// ```
                /// use num_integer::Roots;
                ///
                /// let x: i32 = 12345;
                /// assert_eq!(x.nth_root(1), x);
                /// assert_eq!(x.nth_root(2), x.sqrt());
                /// assert_eq!(x.nth_root(3), x.cbrt());
                /// assert_eq!(x.nth_root(4), 10);
                /// assert_eq!(x.nth_root(13), 2);
                /// assert_eq!(x.nth_root(14), 1);
                /// assert_eq!(x.nth_root(::u32::MAX), 1);
                ///
                /// assert_eq!(::i32::MAX.nth_root(30), 2);
                /// assert_eq!(::i32::MAX.nth_root(31), 1);
                /// assert_eq!(::i32::MIN.nth_root(31), -2);
                /// assert_eq!((::i32::MIN + 1).nth_root(31), -1);
                ///
                /// assert_eq!(::u32::MAX.nth_root(31), 2);
                /// assert_eq!(::u32::MAX.nth_root(32), 1);
                /// ```
                fn nth_root(&self, n: u32) -> Self;

                /// Returns the truncated principal square root of an integer -- `⌊√x⌋`
                ///
                /// This is solving for `r` in `r² = x`, rounding toward zero.
                /// The result will satisfy `r² ≤ x < (r+1)²`.
                ///
                /// ```should_panic
                /// # use num_integer::Roots;
                /// println!("no imaginary numbers... {}", (-1).sqrt());
                /// ```
                ///
                /// # Examples
                ///
                /// ```
                /// use num_integer::Roots;
                ///
                /// let x: i32 = 12345;
                /// assert_eq!((x * x).sqrt(), x);
                /// assert_eq!((x * x + 1).sqrt(), x);
                /// assert_eq!((x * x - 1).sqrt(), x - 1);
                /// ```
                #[inline]
                fn sqrt(&self) -> Self {
                    self.nth_root(2)
                }

                /// Returns the truncated principal cube root of an integer --
                /// `if x >= 0 { ⌊∛x⌋ } else { ⌈∛x⌉ }`
                ///
                /// This is solving for `r` in `r³ = x`, rounding toward zero.
                /// If `x` is positive, the result will satisfy `r³ ≤ x < (r+1)³`.
                /// If `x` is negative, then `(r-1)³ < x ≤ r³`.
                /// use num_integer::Roots;
                ///
                /// let x: i32 = 1234;
                /// assert_eq!((x * x * x).cbrt(), x);
                /// assert_eq!((x * x * x + 1).cbrt(), x);
                /// assert_eq!((x * x * x - 1).cbrt(), x - 1);
                ///
                /// assert_eq!((-(x * x * x)).cbrt(), -x);
                /// assert_eq!((-(x * x * x + 1)).cbrt(), -x);
                /// assert_eq!((-(x * x * x - 1)).cbrt(), -(x - 1));
                /// ```
                #[inline]
                fn cbrt(&self) -> Self {
                    self.nth_root(3)
                }
            }
            /// Returns the truncated principal square root of an integer --
            /// see [Roots::sqrt](trait.Roots.html#method.sqrt).
            #[inline]
            pub fn sqrt<T: Roots>(x: T) -> T {
                x.sqrt()
            }
            /// Returns the truncated principal cube root of an integer --
            /// see [Roots::cbrt](trait.Roots.html#method.cbrt).
            #[inline]
            pub fn cbrt<T: Roots>(x: T) -> T {
                x.cbrt()
            }
            /// Returns the truncated principal `n`th root of an integer --
            /// see [Roots::nth_root](trait.Roots.html#tymethod.nth_root).
            #[inline]
            pub fn nth_root<T: Roots>(x: T, n: u32) -> T {
                x.nth_root(n)
            }

            macro_rules! signed_roots {
                ($T:ty, $U:ty) => {
                    impl Roots for $T {
                        #[inline]
                        fn nth_root(&self, n: u32) -> Self {
                            if *self >= 0 {
                                (*self as $U).nth_root(n) as Self
                            } else {
                                assert!(n.is_odd(), "even roots of a negative are imaginary");
                                -((self.wrapping_neg() as $U).nth_root(n) as Self)
                            }
                        }

                        #[inline]
                        fn sqrt(&self) -> Self {
                            assert!(*self >= 0, "the square root of a negative is imaginary");
                            (*self as $U).sqrt() as Self
                        }

                        #[inline]
                        fn cbrt(&self) -> Self {
                            if *self >= 0 {
                                (*self as $U).cbrt() as Self
                            } else {
                                -((self.wrapping_neg() as $U).cbrt() as Self)
                            }
                        }
                    }
                };
            }

            signed_roots!(i8, u8);
            signed_roots!(i16, u16);
            signed_roots!(i32, u32);
            signed_roots!(i64, u64);
            signed_roots!(i128, u128);
            signed_roots!(isize, usize);

            #[inline]
            fn fixpoint<T, F>(mut x: T, f: F) -> T
            where
                T: Integer + Copy,
                F: Fn(T) -> T,
            {
                let mut xn = f(x);
                while x < xn {
                    x = xn;
                    xn = f(x);
                }
                while x > xn {
                    x = xn;
                    xn = f(x);
                }
                x
            }

            #[inline]
            fn bits<T>() -> u32 {
                8 * mem::size_of::<T>() as u32
            }

            #[inline]
            fn log2<T: PrimInt>(x: T) -> u32 {
                debug_assert!(x > T::zero());
                bits::<T>() - 1 - x.leading_zeros()
            }

            macro_rules! unsigned_roots {
                ($T:ident) => {
                    impl Roots for $T {
                        #[inline]
                        fn nth_root(&self, n: u32) -> Self {
                            fn go(a: $T, n: u32) -> $T {
                               
                                match n {
                                    0 => panic!("can't find a root of degree 0!"),
                                    1 => return a,
                                    2 => return a.sqrt(),
                                    3 => return a.cbrt(),
                                    _ => (),
                                }

                               
                                if bits::<$T>() <= n || a < (1 << n) {
                                    return (a > 0) as $T;
                                }

                                if bits::<$T>() > 64 {
                                   
                                    return if a <= ::u64::MAX as $T {
                                        (a as u64).nth_root(n) as $T
                                    } else {
                                        let lo = (a >> n).nth_root(n) << 1;
                                        let hi = lo + 1;
                                       
                                       
                                        if hi.next_power_of_two().trailing_zeros() * n >= bits::<$T>() {
                                            match checked_pow(hi, n as usize) {
                                                Some(x) if x <= a => hi,
                                                _ => lo,
                                            }
                                        } else {
                                            if hi.pow(n) <= a {
                                                hi
                                            } else {
                                                lo
                                            }
                                        }
                                    };
                                }
                                
                                #[inline] fn guess(x: $T, n: u32) -> $T {
                                   
                                    if bits::<$T>() <= 32 || x <= ::u32::MAX as $T {
                                        1 << ((log2(x) + n - 1) / n)
                                    } else {
                                        ((x as f64).ln() / f64::from(n)).exp() as $T
                                    }
                                }
                                
                                let n1 = n - 1;
                                let next = |x: $T| {
                                    let y = match checked_pow(x, n1 as usize) {
                                        Some(ax) => a / ax,
                                        None => 0,
                                    };
                                    (y + x * n1 as $T) / n as $T
                                };
                                fixpoint(guess(a, n), next)
                            }
                            go(*self, n)
                        }

                        #[inline]
                        fn sqrt(&self) -> Self {
                            fn go(a: $T) -> $T {
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= ::u64::MAX as $T {
                                        (a as u64).sqrt() as $T
                                    } else {
                                        let lo = (a >> 2u32).sqrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }

                                if a < 4 {
                                    return (a > 0) as $T;
                                }

                                                    #[inline]
                                fn guess(x: $T) -> $T {
                                    (x as f64).sqrt() as $T
                                }
                                
                                let next = |x: $T| (a / x + x) >> 1;
                                fixpoint(guess(a), next)
                            }
                            go(*self)
                        }

                        #[inline]
                        fn cbrt(&self) -> Self {
                            fn go(a: $T) -> $T {
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= ::u64::MAX as $T {
                                        (a as u64).cbrt() as $T
                                    } else {
                                        let lo = (a >> 3u32).cbrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }

                                if bits::<$T>() <= 32 {
                                   
                                    let mut x = a;
                                    let mut y2 = 0;
                                    let mut y = 0;
                                    let smax = bits::<$T>() / 3;
                                    for s in (0..smax + 1).rev() {
                                        let s = s * 3;
                                        y2 *= 4;
                                        y *= 2;
                                        let b = 3 * (y2 + y) + 1;
                                        if x >> s >= b {
                                            x -= b << s;
                                            y2 += 2 * y + 1;
                                            y += 1;
                                        }
                                    }
                                    return y;
                                }

                                if a < 8 {
                                    return (a > 0) as $T;
                                }
                                if a <= ::u32::MAX as $T {
                                    return (a as u32).cbrt() as $T;
                                }

                                                    #[inline]
                                fn guess(x: $T) -> $T {
                                    (x as f64).cbrt() as $T
                                }
                                
                                let next = |x: $T| (a / (x * x) + x * 2) / 3;
                                fixpoint(guess(a), next)
                            }
                            go(*self)
                        }
                    }
                };
            }

            unsigned_roots!(u8);
            unsigned_roots!(u16);
            unsigned_roots!(u32);
            unsigned_roots!(u64);
            unsigned_roots!(u128);
            unsigned_roots!(usize);
        } pub use self::roots::{cbrt, nth_root, sqrt, Roots};

        pub trait Integer: Sized + Num + PartialOrd + Ord + Eq 
        {
            /// Floored integer division.
            /// assert!((-8).div_floor(&-3) ==  2);
            ///
            /// assert!(( 1).div_floor(& 2) ==  0);
            /// assert!(( 1).div_floor(&-2) == -1);
            /// assert!((-1).div_floor(& 2) == -1);
            /// assert!((-1).div_floor(&-2) ==  0);
            /// ~~~
            fn div_floor(&self, other: &Self) -> Self;

            /// Floored integer modulo, satisfying:
            ///
            /// ~~~
            /// # use num_integer::Integer;
            /// # let n = 1; let d = 1;
            /// assert!(n.div_floor(&d) * d + n.mod_floor(&d) == n)
            /// ~~~
            ///
            /// # Examples
            ///
            /// ~~~
            /// # use num_integer::Integer;
            /// assert!(( 8).mod_floor(& 3) ==  2);
            /// assert!(( 8).mod_floor(&-3) == -1);
            /// assert!((-8).mod_floor(& 3) ==  1);
            /// assert!((-8).mod_floor(&-3) == -2);
            ///
            /// assert!(( 1).mod_floor(& 2) ==  1);
            /// assert!(( 1).mod_floor(&-2) == -1);
            /// assert!((-1).mod_floor(& 2) ==  1);
            /// assert!((-1).mod_floor(&-2) == -1);
            /// ~~~
            fn mod_floor(&self, other: &Self) -> Self;

            /// Ceiled integer division.
            /// assert_eq!((-8).div_ceil(&-3),  3);
            ///
            /// assert_eq!(( 1).div_ceil( &2), 1);
            /// assert_eq!(( 1).div_ceil(&-2), 0);
            /// assert_eq!((-1).div_ceil( &2), 0);
            /// assert_eq!((-1).div_ceil(&-2), 1);
            /// ~~~
            fn div_ceil(&self, other: &Self) -> Self {
                let (q, r) = self.div_mod_floor(other);
                if r.is_zero() {
                    q
                } else {
                    q + Self::one()
                }
            }
            /// Greatest Common Divisor (GCD).
            fn gcd(&self, other: &Self) -> Self;

            /// Lowest Common Multiple (LCM).
            /// ~~~
            fn lcm(&self, other: &Self) -> Self;

            /// Greatest Common Divisor (GCD) and
            /// Lowest Common Multiple (LCM) together.
            #[inline]
            fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                (self.gcd(other), self.lcm(other))
            }
            /// Greatest common divisor and Bézout coefficients.
            ///     let ExtendedGcd { gcd, x, y, .. } = a.extended_gcd(&b);
            ///     gcd == x * a + y * b
            /// }
            /// assert!(check(10isize, 4isize));
            /// assert!(check(8isize,  9isize));
            /// # }
            /// ~~~
            #[inline]
            fn extended_gcd(&self, other: &Self) -> ExtendedGcd<Self> where
                Self: Clone,
            {
                let mut s = (Self::zero(), Self::one());
                let mut t = (Self::one(), Self::zero());
                let mut r = (other.clone(), self.clone());

                while !r.0.is_zero() {
                    let q = r.1.clone() / r.0.clone();
                    let f = |mut r: (Self, Self)| {
                        mem::swap(&mut r.0, &mut r.1);
                        r.0 = r.0 - q.clone() * r.1.clone();
                        r
                    };
                    r = f(r);
                    s = f(s);
                    t = f(t);
                }

                if r.1 >= Self::zero() {
                    ExtendedGcd {
                        gcd: r.1,
                        x: s.1,
                        y: t.1,
                    }
                } else {
                    ExtendedGcd {
                        gcd: Self::zero() - r.1,
                        x: Self::zero() - s.1,
                        y: Self::zero() - t.1,
                    }
                }
            }
            /// Greatest common divisor, least common multiple, and Bézout coefficients.
            #[inline]
            fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self)
            where
                Self: Clone + Signed,
            {
                (self.extended_gcd(other), self.lcm(other))
            }
            /// Deprecated, use `is_multiple_of` instead.
            #[deprecated(note = "Please use is_multiple_of instead")]
            #[inline]
            fn divides(&self, other: &Self) -> bool {
                self.is_multiple_of(other)
            }
            /// Returns `true` if `self` is a multiple of `other`.
            fn is_multiple_of(&self, other: &Self) -> bool;

            /// Returns `true` if the number is even.
            fn is_even(&self) -> bool;

            /// Returns `true` if the number is odd.
            fn is_odd(&self) -> bool;

            /// Simultaneous truncated integer division and modulus.
            /// assert_eq!((-8).div_rem( &3), (-2, -2));
            /// assert_eq!((-8).div_rem(&-3), ( 2, -2));
            ///
            /// assert_eq!(( 1).div_rem( &2), ( 0,  1));
            /// assert_eq!(( 1).div_rem(&-2), ( 0,  1));
            /// assert_eq!((-1).div_rem( &2), ( 0, -1));
            /// assert_eq!((-1).div_rem(&-2), ( 0, -1));
            /// ~~~
            fn div_rem(&self, other: &Self) -> (Self, Self);
            /// Simultaneous floored integer division and modulus.
            /// assert_eq!((-8).div_mod_floor( &3), (-3,  1));
            /// assert_eq!((-8).div_mod_floor(&-3), ( 2, -2));
            ///
            /// assert_eq!(( 1).div_mod_floor( &2), ( 0,  1));
            /// assert_eq!(( 1).div_mod_floor(&-2), (-1, -1));
            /// assert_eq!((-1).div_mod_floor( &2), (-1,  1));
            /// assert_eq!((-1).div_mod_floor(&-2), ( 0, -1));
            /// ~~~
            fn div_mod_floor(&self, other: &Self) -> (Self, Self) {
                (self.div_floor(other), self.mod_floor(other))
            }
            /// Rounds up to nearest multiple of argument.
            ///
            /// ~~~
            /// # use num_integer::Integer;
            /// assert_eq!(( 16).next_multiple_of(& 8),  16);
            /// assert_eq!(( 23).next_multiple_of(& 8),  24);
            /// assert_eq!(( 16).next_multiple_of(&-8),  16);
            /// assert_eq!(( 23).next_multiple_of(&-8),  16);
            /// assert_eq!((-16).next_multiple_of(& 8), -16);
            /// assert_eq!((-23).next_multiple_of(& 8), -16);
            /// assert_eq!((-16).next_multiple_of(&-8), -16);
            /// assert_eq!((-23).next_multiple_of(&-8), -24);
            /// ~~~
            #[inline]
            fn next_multiple_of(&self, other: &Self) -> Self
            where
                Self: Clone,
            {
                let m = self.mod_floor(other);
                self.clone()
                    + if m.is_zero() {
                        Self::zero()
                    } else {
                        other.clone() - m
                    }
            }
            /// Rounds down to nearest multiple of argument.
            ///
            /// ~~~
            /// # use num_integer::Integer;
            /// assert_eq!(( 16).prev_multiple_of(& 8),  16);
            /// assert_eq!(( 23).prev_multiple_of(& 8),  16);
            /// assert_eq!(( 16).prev_multiple_of(&-8),  16);
            /// assert_eq!(( 23).prev_multiple_of(&-8),  24);
            /// assert_eq!((-16).prev_multiple_of(& 8), -16);
            /// assert_eq!((-23).prev_multiple_of(& 8), -24);
            /// assert_eq!((-16).prev_multiple_of(&-8), -16);
            /// assert_eq!((-23).prev_multiple_of(&-8), -16);
            /// ~~~
            #[inline]
            fn prev_multiple_of(&self, other: &Self) -> Self
            where
                Self: Clone,
            {
                self.clone() - self.mod_floor(other)
            }
            /// Decrements self by one.
            /// ~~~
            fn dec(&mut self)
            where
                Self: Clone,
            {
                *self = self.clone() - Self::one()
            }
            /// Increments self by one.
            /// ~~~
            fn inc(&mut self)
            where
                Self: Clone,
            {
                *self = self.clone() + Self::one()
            }
        }
        /// Greatest common divisor and Bézout coefficients.
        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
        pub struct ExtendedGcd<A> 
        {
            pub gcd: A,
            pub x: A,
            pub y: A,
        }
        /// Simultaneous integer division and modulus
        #[inline] pub fn div_rem<T: Integer>(x: T, y: T) -> (T, T) 
        {
            x.div_rem(&y)
        }
        /// Floored integer division
        #[inline] pub fn div_floor<T: Integer>(x: T, y: T) -> T 
        {
            x.div_floor(&y)
        }
        /// Floored integer modulus
        #[inline] pub fn mod_floor<T: Integer>(x: T, y: T) -> T 
        {
            x.mod_floor(&y)
        }
        /// Simultaneous floored integer division and modulus
        #[inline] pub fn div_mod_floor<T: Integer>(x: T, y: T) -> (T, T) 
        {
            x.div_mod_floor(&y)
        }
        /// Ceiled integer division
        #[inline] pub fn div_ceil<T: Integer>(x: T, y: T) -> T 
        {
            x.div_ceil(&y)
        }
        /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.
        #[inline(always)] pub fn gcd<T: Integer>(x: T, y: T) -> T 
        {
            x.gcd(&y)
        }
        /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
        #[inline(always)] pub fn lcm<T: Integer>(x: T, y: T) -> T 
        {
            x.lcm(&y)
        }
        /// Calculates the Greatest Common Divisor (GCD) and Lowest Common Multiple (LCM) of the number and `other`.
        #[inline(always)] pub fn gcd_lcm<T: Integer>(x: T, y: T) -> (T, T) 
        {
            x.gcd_lcm(&y)
        }

        macro_rules! impl_integer_for_isize 
        {
            ($T:ty, $test_mod:ident) => {
                impl Integer for $T {
                    /// Floored integer division
                    #[inline]
                    fn div_floor(&self, other: &Self) -> Self {
                       
                       
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            d - 1
                        } else {
                            d
                        }
                    }

                    /// Floored integer modulo
                    #[inline]
                    fn mod_floor(&self, other: &Self) -> Self {
                       
                       
                        let r = *self % *other;
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            r + *other
                        } else {
                            r
                        }
                    }

                    /// Calculates `div_floor` and `mod_floor` simultaneously
                    #[inline]
                    fn div_mod_floor(&self, other: &Self) -> (Self, Self) {
                       
                       
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other < 0) || (r < 0 && *other > 0) {
                            (d - 1, r + *other)
                        } else {
                            (d, r)
                        }
                    }

                    #[inline]
                    fn div_ceil(&self, other: &Self) -> Self {
                        let (d, r) = self.div_rem(other);
                        if (r > 0 && *other > 0) || (r < 0 && *other < 0) {
                            d + 1
                        } else {
                            d
                        }
                    }

                    /// Calculates the Greatest Common Divisor (GCD) of the number and
                    /// `other`. The result is always non-negative.
                    #[inline]
                    fn gcd(&self, other: &Self) -> Self {
                       
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return (m | n).abs();
                        }

                       
                        let shift = (m | n).trailing_zeros();

                       
                       
                       
                       

                       
                       
                       
                        if m == Self::min_value() || n == Self::min_value() {
                            return (1 << shift).abs();
                        }

                       
                        m = m.abs();
                        n = n.abs();

                       
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }

                    #[inline]
                    fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) {
                        let egcd = self.extended_gcd(other);
                       
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            (*self * (*other / egcd.gcd)).abs()
                        };
                        (egcd, lcm)
                    }

                    /// Calculates the Lowest Common Multiple (LCM) of the number and
                    /// `other`.
                    #[inline]
                    fn lcm(&self, other: &Self) -> Self {
                        self.gcd_lcm(other).1
                    }

                    /// Calculates the Greatest Common Divisor (GCD) and
                    /// Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline]
                    fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                        if self.is_zero() && other.is_zero() {
                            return (Self::zero(), Self::zero());
                        }
                        let gcd = self.gcd(other);
                       
                        let lcm = (*self * (*other / gcd)).abs();
                        (gcd, lcm)
                    }

                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline]
                    fn is_multiple_of(&self, other: &Self) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    /// Returns `true` if the number is divisible by `2`
                    #[inline]
                    fn is_even(&self) -> bool {
                        (*self) & 1 == 0
                    }

                    /// Returns `true` if the number is not divisible by `2`
                    #[inline]
                    fn is_odd(&self) -> bool {
                        !self.is_even()
                    }

                    /// Simultaneous truncated integer division and modulus.
                    #[inline]
                    fn div_rem(&self, other: &Self) -> (Self, Self) {
                        (*self / *other, *self % *other)
                    }

                    /// Rounds up to nearest multiple of argument.
                    #[inline]
                    fn next_multiple_of(&self, other: &Self) -> Self {
                       
                        if *other == -1 {
                            return *self;
                        }

                        let m = Integer::mod_floor(self, other);
                        *self + if m == 0 { 0 } else { other - m }
                    }

                    /// Rounds down to nearest multiple of argument.
                    #[inline]
                    fn prev_multiple_of(&self, other: &Self) -> Self {
                       
                        if *other == -1 {
                            return *self;
                        }

                        *self - Integer::mod_floor(self, other)
                    }
                }
            };
        }

        impl_integer_for_isize!(i8, test_integer_i8);
        impl_integer_for_isize!(i16, test_integer_i16);
        impl_integer_for_isize!(i32, test_integer_i32);
        impl_integer_for_isize!(i64, test_integer_i64);
        impl_integer_for_isize!(i128, test_integer_i128);
        impl_integer_for_isize!(isize, test_integer_isize);

        macro_rules! impl_integer_for_usize 
        {
            ($T:ty, $test_mod:ident) => {
                impl Integer for $T {
                    /// Unsigned integer division. Returns the same result as `div` (`/`).
                    #[inline]
                    fn div_floor(&self, other: &Self) -> Self {
                        *self / *other
                    }

                    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).
                    #[inline]
                    fn mod_floor(&self, other: &Self) -> Self {
                        *self % *other
                    }

                    #[inline]
                    fn div_ceil(&self, other: &Self) -> Self {
                        *self / *other + (0 != *self % *other) as Self
                    }

                    /// Calculates the Greatest Common Divisor (GCD) of the number and `other`
                    #[inline]
                    fn gcd(&self, other: &Self) -> Self {
                       
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return m | n;
                        }

                       
                        let shift = (m | n).trailing_zeros();

                       
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }

                    #[inline]
                    fn extended_gcd_lcm(&self, other: &Self) -> (ExtendedGcd<Self>, Self) {
                        let egcd = self.extended_gcd(other);
                       
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            *self * (*other / egcd.gcd)
                        };
                        (egcd, lcm)
                    }

                    /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline]
                    fn lcm(&self, other: &Self) -> Self {
                        self.gcd_lcm(other).1
                    }

                    /// Calculates the Greatest Common Divisor (GCD) and
                    /// Lowest Common Multiple (LCM) of the number and `other`.
                    #[inline]
                    fn gcd_lcm(&self, other: &Self) -> (Self, Self) {
                        if self.is_zero() && other.is_zero() {
                            return (Self::zero(), Self::zero());
                        }
                        let gcd = self.gcd(other);
                        let lcm = *self * (*other / gcd);
                        (gcd, lcm)
                    }

                    /// Returns `true` if the number is a multiple of `other`.
                    #[inline]
                    fn is_multiple_of(&self, other: &Self) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    /// Returns `true` if the number is divisible by `2`.
                    #[inline]
                    fn is_even(&self) -> bool {
                        *self % 2 == 0
                    }

                    /// Returns `true` if the number is not divisible by `2`.
                    #[inline]
                    fn is_odd(&self) -> bool {
                        !self.is_even()
                    }

                    /// Simultaneous truncated integer division and modulus.
                    #[inline]
                    fn div_rem(&self, other: &Self) -> (Self, Self) {
                        (*self / *other, *self % *other)
                    }
                }
            };
        }

        impl_integer_for_usize!(u8, test_integer_u8);
        impl_integer_for_usize!(u16, test_integer_u16);
        impl_integer_for_usize!(u32, test_integer_u32);
        impl_integer_for_usize!(u64, test_integer_u64);
        impl_integer_for_usize!(u128, test_integer_u128);
        impl_integer_for_usize!(usize, test_integer_usize);
        /// An iterator over binomial coefficients.
        pub struct IterBinomial<T> 
        {
            a: T,
            n: T,
            k: T,
        }

        impl<T> IterBinomial<T> where
            T: Integer,
        {
            /// For a given n, iterate over all binomial coefficients binomial(n, k), for k=0...n.
            /// be no overflow:
            ///
            /// type | n
            /// -----|---
            /// u8   | 10
            /// i8   |  9
            /// u16  | 18
            /// i16  | 17
            /// u32  | 34
            /// i32  | 33
            /// u64  | 67
            /// i64  | 66
            ///
            /// For larger n, `T` should be a bigint type.
            pub fn new(n: T) -> IterBinomial<T> {
                IterBinomial {
                    k: T::zero(),
                    a: T::one(),
                    n,
                }
            }
        }

        impl<T> Iterator for IterBinomial<T> where
        T: Integer + Clone,
        {
            type Item = T;

            fn next(&mut self) -> Option<T> {
                if self.k > self.n {
                    return None;
                }
                self.a = if !self.k.is_zero() {
                    multiply_and_divide(
                        self.a.clone(),
                        self.n.clone() - self.k.clone() + T::one(),
                        self.k.clone(),
                    )
                } else {
                    T::one()
                };
                self.k = self.k.clone() + T::one();
                Some(self.a.clone())
            }
        }
        /// Calculate r * a / b, avoiding overflows and fractions.
        fn multiply_and_divide<T: Integer + Clone>(r: T, a: T, b: T) -> T
        {
           
            let g = gcd(r.clone(), b.clone());
            r / g.clone() * (a / (b / g))
        }
        /// Calculate the binomial coefficient.
        pub fn binomial<T: Integer + Clone>(mut n: T, k: T) -> T
        {
           
            if k > n {
                return T::zero();
            }
            if k > n.clone() - k.clone() {
                return binomial(n.clone(), n - k);
            }
            let mut r = T::one();
            let mut d = T::one();
            loop {
                if d > k {
                    break;
                }
                r = multiply_and_divide(r, n.clone(), d.clone());
                n = n - T::one();
                d = d + T::one();
            }
            r
        }
        /// Calculate the multinomial coefficient.
        pub fn multinomial<T: Integer + Clone>(k: &[T]) -> T where
            for<'a> T: Add<&'a T, Output = T>,
        {
            let mut r = T::one();
            let mut p = T::zero();
            for i in k {
                p = p + i;
                r = r * binomial(p.clone(), i.clone());
            }
            r
        }
    }
    /*
    */
    pub mod big
    {
        //! Big Integer Types for Rust
        use ::
        {
            *,
        };
        /*
        */
        pub mod bigint
        {
            use ::
            {
                cmp::{ Ordering::{self, Equal} },
                default::{ Default },
                num::
                {
                    traits::{ ConstZero, Num, One, Pow, Signed, Zero },
                    integers::{Integer, Roots},
                    big::
                    {
                        big_digit::BigDigit,
                        biguint::to_str_radix_reversed,
                        biguint::{BigUint, IntDigits, U32Digits, U64Digits},
                    },
                },
                ops::{ Neg, Not },
                string::{ String },
                vec::{ Vec },
                *,
            };
            /*
            */
            use self::Sign::{Minus, NoSign, Plus};

            pub mod addition
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    iter::{ Sum },
                    num::
                    {
                        big::{ IsizePromotion, UsizePromotion },
                        traits::{ CheckedAdd },
                    },
                    ops::{ Add, AddAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{ Negative, Positive };
                use super::Sign::{ Minus, NoSign, Plus };
                use super::{ BigInt, UnsignedAbs };
                /*
                */
                macro_rules! bigint_add {
                    ($a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr) => {
                        match ($a.sign, $b.sign) {
                            (_, NoSign) => $a_owned,
                            (NoSign, _) => $b_owned,
                           
                            (Plus, Plus) | (Minus, Minus) => BigInt::from_biguint($a.sign, $a_data + $b_data),
                           
                            (Plus, Minus) | (Minus, Plus) => match $a.data.cmp(&$b.data) {
                                Less => BigInt::from_biguint($b.sign, $b_data - $a_data),
                                Greater => BigInt::from_biguint($a.sign, $a_data - $b_data),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }

                impl Add<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: &BigInt) -> BigInt {
                        bigint_add!(
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }

                impl Add<BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: BigInt) -> BigInt {
                        bigint_add!(self, self.clone(), &self.data, other, other, other.data)
                    }
                }

                impl Add<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: &BigInt) -> BigInt {
                        bigint_add!(self, self, self.data, other, other.clone(), &other.data)
                    }
                }

                impl Add<BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: BigInt) -> BigInt {
                        bigint_add!(self, self, self.data, other, other, other.data)
                    }
                }

                impl AddAssign<&BigInt> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: &BigInt) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }
                forward_val_assign!(impl AddAssign for BigInt, add_assign);

                promote_all_scalars!(impl Add for BigInt, add);
                promote_all_scalars_assign!(impl AddAssign for BigInt, add_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u32> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u64> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u128> for BigInt, add);

                impl Add<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: u32) -> BigInt {
                        match self.sign {
                            NoSign => From::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }

                impl AddAssign<u32> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: u32) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                impl Add<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: u64) -> BigInt {
                        match self.sign {
                            NoSign => From::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }

                impl AddAssign<u64> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: u64) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                impl Add<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: u128) -> BigInt {
                        match self.sign {
                            NoSign => BigInt::from(other),
                            Plus => BigInt::from(self.data + other),
                            Minus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Less => BigInt::from(other - self.data),
                                Greater => -BigInt::from(self.data - other),
                            },
                        }
                    }
                }
                impl AddAssign<u128> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: u128) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n + other;
                    }
                }

                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i32> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i64> for BigInt, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<i128> for BigInt, add);

                impl Add<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i32> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl Add<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i64> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl Add<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn add(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self + u,
                            Negative(u) => self - u,
                        }
                    }
                }
                impl AddAssign<i128> for BigInt {
                    #[inline]
                    fn add_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self += u,
                            Negative(u) => *self -= u,
                        }
                    }
                }

                impl CheckedAdd for BigInt {
                    #[inline]
                    fn checked_add(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.add(v))
                    }
                }

                impl_sum_iter_type!(BigInt);

            }

            pub mod division
            {
                use ::
                {
                    num::
                    {
                        big::{IsizePromotion, UsizePromotion},
                        integers::{ Integer },
                        traits::{ CheckedDiv, CheckedEuclid, Euclid, Signed, ToPrimitive, Zero },
                    },
                    ops::{ Div, DivAssign, Rem, RemAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{Negative, Positive};
                use super::Sign::NoSign;
                use super::{BigInt, UnsignedAbs};
                /*
                */
                forward_all_binop_to_ref_ref!(impl Div for BigInt, div);

                impl Div<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: &BigInt) -> BigInt {
                        let (q, _) = self.div_rem(other);
                        q
                    }
                }

                impl DivAssign<&BigInt> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: &BigInt) {
                        *self = &*self / other;
                    }
                }
                forward_val_assign!(impl DivAssign for BigInt, div_assign);

                promote_all_scalars!(impl Div for BigInt, div);
                promote_all_scalars_assign!(impl DivAssign for BigInt, div_assign);
                forward_all_scalar_binop_to_val_val!(impl Div<u32> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u64> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u128> for BigInt, div);

                impl Div<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u32> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: u32) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                impl Div<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u64> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: u64) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                impl Div<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data / other)
                    }
                }

                impl DivAssign<u128> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: u128) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Div<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        BigInt::from_biguint(other.sign, self / other.data)
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Div<i32> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<i64> for BigInt, div);
                forward_all_scalar_binop_to_val_val!(impl Div<i128> for BigInt, div);

                impl Div<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i32> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                impl Div<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i64> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                impl Div<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self / u,
                            Negative(u) => -self / u,
                        }
                    }
                }

                impl DivAssign<i128> for BigInt {
                    #[inline]
                    fn div_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self /= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }

                impl Div<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline]
                    fn div(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u / other,
                            Negative(u) => u / -other,
                        }
                    }
                }

                forward_all_binop_to_ref_ref!(impl Rem for BigInt, rem);

                impl Rem<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: &BigInt) -> BigInt {
                        if let Some(other) = other.to_u32() {
                            self % other
                        } else if let Some(other) = other.to_i32() {
                            self % other
                        } else {
                            let (_, r) = self.div_rem(other);
                            r
                        }
                    }
                }

                impl RemAssign<&BigInt> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: &BigInt) {
                        *self = &*self % other;
                    }
                }
                forward_val_assign!(impl RemAssign for BigInt, rem_assign);

                promote_all_scalars!(impl Rem for BigInt, rem);
                promote_all_scalars_assign!(impl RemAssign for BigInt, rem_assign);
                forward_all_scalar_binop_to_val_val!(impl Rem<u32> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u64> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u128> for BigInt, rem);

                impl Rem<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u32> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: u32) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                impl Rem<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u64> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: u64) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                impl Rem<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data % other)
                    }
                }

                impl RemAssign<u128> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: u128) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Rem<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        BigInt::from(self % other.data)
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Rem<i32> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<i64> for BigInt, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<i128> for BigInt, rem);

                impl Rem<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: i32) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i32> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: i32) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl Rem<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: i64) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i64> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: i64) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl Rem<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: i128) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }

                impl RemAssign<i128> for BigInt {
                    #[inline]
                    fn rem_assign(&mut self, other: i128) {
                        *self %= other.unsigned_abs();
                    }
                }

                impl Rem<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline]
                    fn rem(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u % other,
                            Negative(u) => -(u % other),
                        }
                    }
                }

                impl CheckedDiv for BigInt {
                    #[inline]
                    fn checked_div(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div(v))
                    }
                }

                impl CheckedEuclid for BigInt {
                    #[inline]
                    fn checked_div_euclid(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div_euclid(v))
                    }

                    #[inline]
                    fn checked_rem_euclid(&self, v: &BigInt) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.rem_euclid(v))
                    }

                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some(self.div_rem_euclid(v))
                    }
                }

                impl Euclid for BigInt {
                    #[inline]
                    fn div_euclid(&self, v: &BigInt) -> BigInt {
                        let (q, r) = self.div_rem(v);
                        if r.is_negative() {
                            if v.is_positive() {
                                q - 1
                            } else {
                                q + 1
                            }
                        } else {
                            q
                        }
                    }

                    #[inline]
                    fn rem_euclid(&self, v: &BigInt) -> BigInt {
                        let r = self % v;
                        if r.is_negative() {
                            if v.is_positive() {
                                r + v
                            } else {
                                r - v
                            }
                        } else {
                            r
                        }
                    }

                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                        let (q, r) = self.div_rem(v);
                        if r.is_negative() {
                            if v.is_positive() {
                                (q - 1, r + v)
                            } else {
                                (q + 1, r - v)
                            }
                        } else {
                            (q, r)
                        }
                    }
                }

            }
            
            pub mod multiplication
            {
                use ::
                {
                    iter::{ Product },
                    num::
                    {
                        big::{IsizePromotion, UsizePromotion},
                        traits::{CheckedMul, One, Zero},
                    },
                    ops::{ Mul, MulAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{Negative, Positive};
                use super::Sign::{self, Minus, NoSign, Plus};
                use super::{BigInt, UnsignedAbs};
                /*
                */
                impl Mul<Sign> for Sign {
                    type Output = Sign;

                    #[inline]
                    fn mul(self, other: Sign) -> Sign {
                        match (self, other) {
                            (NoSign, _) | (_, NoSign) => NoSign,
                            (Plus, Plus) | (Minus, Minus) => Plus,
                            (Plus, Minus) | (Minus, Plus) => Minus,
                        }
                    }
                }

                macro_rules! impl_mul {
                    ($(impl Mul<$Other:ty> for $Self:ty;)*) => {$(
                        impl Mul<$Other> for $Self {
                            type Output = BigInt;

                            #[inline]
                            fn mul(self, other: $Other) -> BigInt {
                               
                                let BigInt { data: x, .. } = self;
                                let BigInt { data: y, .. } = other;
                                BigInt::from_biguint(self.sign * other.sign, x * y)
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigInt> for BigInt;
                    impl Mul<BigInt> for &BigInt;
                    impl Mul<&BigInt> for BigInt;
                    impl Mul<&BigInt> for &BigInt;
                }

                macro_rules! impl_mul_assign {
                    ($(impl MulAssign<$Other:ty> for BigInt;)*) => {$(
                        impl MulAssign<$Other> for BigInt {
                            #[inline]
                            fn mul_assign(&mut self, other: $Other) {
                               
                                let BigInt { data: y, .. } = other;
                                self.data *= y;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                } else {
                                    self.sign = self.sign * other.sign;
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigInt> for BigInt;
                    impl MulAssign<&BigInt> for BigInt;
                }

                promote_all_scalars!(impl Mul for BigInt, mul);
                promote_all_scalars_assign!(impl MulAssign for BigInt, mul_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u32> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u64> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u128> for BigInt, mul);

                impl Mul<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: u32) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u32> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: u32) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Mul<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: u64) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u64> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: u64) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                impl Mul<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: u128) -> BigInt {
                        BigInt::from_biguint(self.sign, self.data * other)
                    }
                }

                impl MulAssign<u128> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: u128) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }

                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i32> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i64> for BigInt, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<i128> for BigInt, mul);

                impl Mul<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i32> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl Mul<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i64> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl Mul<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn mul(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self * u,
                            Negative(u) => -self * u,
                        }
                    }
                }

                impl MulAssign<i128> for BigInt {
                    #[inline]
                    fn mul_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self *= u,
                            Negative(u) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }

                impl CheckedMul for BigInt {
                    #[inline]
                    fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.mul(v))
                    }
                }

                impl_product_iter_type!(BigInt);

            }

            pub mod subtraction
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    num::{ traits::CheckedSub },
                    ops::{ Sub, SubAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{Negative, Positive};
                use super::Sign::{Minus, NoSign, Plus};
                use super::{BigInt, UnsignedAbs};
                /*
                */
                macro_rules! bigint_sub
                {
                    ($a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr) => {
                        match ($a.sign, $b.sign) {
                            (_, NoSign) => $a_owned,
                            (NoSign, _) => -$b_owned,
                           
                            (Plus, Minus) | (Minus, Plus) => BigInt::from_biguint($a.sign, $a_data + $b_data),
                           
                            (Plus, Plus) | (Minus, Minus) => match $a.data.cmp(&$b.data) {
                                Less => BigInt::from_biguint(-$a.sign, $b_data - $a_data),
                                Greater => BigInt::from_biguint($a.sign, $a_data - $b_data),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }

                impl Sub<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: &BigInt) -> BigInt {
                        bigint_sub!(
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }

                impl Sub<BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        bigint_sub!(self, self.clone(), &self.data, other, other, other.data)
                    }
                }

                impl Sub<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: &BigInt) -> BigInt {
                        bigint_sub!(self, self, self.data, other, other.clone(), &other.data)
                    }
                }

                impl Sub<BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        bigint_sub!(self, self, self.data, other, other, other.data)
                    }
                }

                impl SubAssign<&BigInt> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: &BigInt) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }
                forward_val_assign!(impl SubAssign for BigInt, sub_assign);

                promote_all_scalars!(impl Sub for BigInt, sub);
                promote_all_scalars_assign!(impl SubAssign for BigInt, sub_assign);
                forward_all_scalar_binop_to_val_val!(impl Sub<u32> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u64> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u128> for BigInt, sub);

                impl Sub<u32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: u32) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }
                impl SubAssign<u32> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: u32) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                impl Sub<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        -(other - self)
                    }
                }

                impl Sub<u64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: u64) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }

                impl SubAssign<u64> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: u64) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                impl Sub<u128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: u128) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from(other),
                            Minus => -BigInt::from(self.data + other),
                            Plus => match self.data.cmp(&From::from(other)) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from(self.data - other),
                                Less => -BigInt::from(other - self.data),
                            },
                        }
                    }
                }

                impl SubAssign<u128> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: u128) {
                        let n = mem::replace(self, Self::ZERO);
                        *self = n - other;
                    }
                }

                forward_all_scalar_binop_to_val_val!(impl Sub<i32> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<i64> for BigInt, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<i128> for BigInt, sub);

                impl Sub<i32> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: i32) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }
                impl SubAssign<i32> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: i32) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl Sub<i64> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: i64) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }
                impl SubAssign<i64> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: i64) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl Sub<i128> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: i128) -> BigInt {
                        match other.checked_uabs() {
                            Positive(u) => self - u,
                            Negative(u) => self + u,
                        }
                    }
                }

                impl SubAssign<i128> for BigInt {
                    #[inline]
                    fn sub_assign(&mut self, other: i128) {
                        match other.checked_uabs() {
                            Positive(u) => *self -= u,
                            Negative(u) => *self += u,
                        }
                    }
                }

                impl Sub<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline]
                    fn sub(self, other: BigInt) -> BigInt {
                        match self.checked_uabs() {
                            Positive(u) => u - other,
                            Negative(u) => -other - u,
                        }
                    }
                }

                impl CheckedSub for BigInt {
                    #[inline]
                    fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {
                        Some(self.sub(v))
                    }
                }

            }

            pub mod bits
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    num::traits::{ToPrimitive, Zero},
                    ops::{ BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign },
                    vec::{ Vec },
                    *,
                };
                use super::BigInt;
                use super::Sign::{Minus, NoSign, Plus};
                /*
                */
                #[inline] fn negate_carry(a: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
                    *acc += DoubleBigDigit::from(!a);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }
                
                fn bitand_pos_neg(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut carry_b = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai &= twos_b;
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                }

               
               
               
                fn bitand_neg_pos(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = twos_a & bi;
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => a.truncate(b.len()),
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().cloned());
                        }
                    }
                }

               
               
               
               
                fn bitand_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_and = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(twos_a & twos_b, &mut carry_and);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                *ai = negate_carry(twos_a, &mut carry_and);
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_and)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                    if carry_and != 0 {
                        a.push(1);
                    }
                }

                forward_val_val_binop!(impl BitAnd for BigInt, bitand);
                forward_ref_val_binop!(impl BitAnd for BigInt, bitand);

               
               
                impl BitAnd<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitand(self, other: &BigInt) -> BigInt {
                        match (self.sign, other.sign) {
                            (NoSign, _) | (_, NoSign) => BigInt::ZERO,
                            (Plus, Plus) => BigInt::from(&self.data & &other.data),
                            (Plus, Minus) => self.clone() & other,
                            (Minus, Plus) => other.clone() & self,
                            (Minus, Minus) => {
                               
                                if self.len() >= other.len() {
                                    self.clone() & other
                                } else {
                                    other.clone() & self
                                }
                            }
                        }
                    }
                }

                impl BitAnd<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitand(mut self, other: &BigInt) -> BigInt {
                        self &= other;
                        self
                    }
                }

                forward_val_assign!(impl BitAndAssign for BigInt, bitand_assign);

                impl BitAndAssign<&BigInt> for BigInt {
                    fn bitand_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (NoSign, _) => {}
                            (_, NoSign) => self.set_zero(),
                            (Plus, Plus) => {
                                self.data &= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            (Plus, Minus) => {
                                bitand_pos_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitand_neg_pos(self.digits_mut(), other.digits());
                                self.sign = Plus;
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitand_neg_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                        }
                    }
                }

               
               
               
                fn bitor_pos_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(*ai | twos_b, &mut carry_or);
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            a.truncate(b.len());
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_or)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                   
                    debug_assert!(carry_or == 0);
                }

               
               
               
                fn bitor_neg_pos(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = negate_carry(twos_a | bi, &mut carry_or);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    if a.len() > b.len() {
                        for ai in a[b.len()..].iter_mut() {
                            let twos_a = negate_carry(*ai, &mut carry_a);
                            *ai = negate_carry(twos_a, &mut carry_or);
                        }
                        debug_assert!(carry_a == 0);
                    }
                   
                    debug_assert!(carry_or == 0);
                }

               
               
               
                fn bitor_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(twos_a | twos_b, &mut carry_or);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    if a.len() > b.len() {
                        a.truncate(b.len());
                    }
                   
                    debug_assert!(carry_or == 0);
                }

                forward_val_val_binop!(impl BitOr for BigInt, bitor);
                forward_ref_val_binop!(impl BitOr for BigInt, bitor);

               
               
                impl BitOr<&BigInt> for &BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitor(self, other: &BigInt) -> BigInt {
                        match (self.sign, other.sign) {
                            (NoSign, _) => other.clone(),
                            (_, NoSign) => self.clone(),
                            (Plus, Plus) => BigInt::from(&self.data | &other.data),
                            (Plus, Minus) => other.clone() | self,
                            (Minus, Plus) => self.clone() | other,
                            (Minus, Minus) => {
                               
                                if self.len() <= other.len() {
                                    self.clone() | other
                                } else {
                                    other.clone() | self
                                }
                            }
                        }
                    }
                }

                impl BitOr<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitor(mut self, other: &BigInt) -> BigInt {
                        self |= other;
                        self
                    }
                }

                forward_val_assign!(impl BitOrAssign for BigInt, bitor_assign);

                impl BitOrAssign<&BigInt> for BigInt {
                    fn bitor_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (_, NoSign) => {}
                            (NoSign, _) => self.clone_from(other),
                            (Plus, Plus) => self.data |= &other.data,
                            (Plus, Minus) => {
                                bitor_pos_neg(self.digits_mut(), other.digits());
                                self.sign = Minus;
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitor_neg_pos(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitor_neg_neg(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                        }
                    }
                }

               
               
               
                fn bitxor_pos_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_b = 1;
                    let mut carry_xor = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = negate_carry(*ai ^ twos_b, &mut carry_xor);
                    }
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_b = !0;
                                *ai = negate_carry(*ai ^ twos_b, &mut carry_xor);
                            }
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_b = negate_carry(bi, &mut carry_b);
                                negate_carry(twos_b, &mut carry_xor)
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                    if carry_xor != 0 {
                        a.push(1);
                    }
                }

               
               
               
                fn bitxor_neg_pos(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_xor = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        *ai = negate_carry(twos_a ^ bi, &mut carry_xor);
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                *ai = negate_carry(twos_a, &mut carry_xor);
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_a = !0;
                                negate_carry(twos_a ^ bi, &mut carry_xor)
                            }));
                        }
                    }
                    if carry_xor != 0 {
                        a.push(1);
                    }
                }

               
               
               
                fn bitxor_neg_neg(a: &mut Vec<BigDigit>, b: &[BigDigit]) {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    for (ai, &bi) in a.iter_mut().zip(b.iter()) {
                        let twos_a = negate_carry(*ai, &mut carry_a);
                        let twos_b = negate_carry(bi, &mut carry_b);
                        *ai = twos_a ^ twos_b;
                    }
                    debug_assert!(a.len() > b.len() || carry_a == 0);
                    debug_assert!(b.len() > a.len() || carry_b == 0);
                    match Ord::cmp(&a.len(), &b.len()) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry(*ai, &mut carry_a);
                                let twos_b = !0;
                                *ai = twos_a ^ twos_b;
                            }
                            debug_assert!(carry_a == 0);
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend(extra.iter().map(|&bi| {
                                let twos_a = !0;
                                let twos_b = negate_carry(bi, &mut carry_b);
                                twos_a ^ twos_b
                            }));
                            debug_assert!(carry_b == 0);
                        }
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitXor for BigInt, bitxor);

                impl BitXor<&BigInt> for BigInt {
                    type Output = BigInt;

                    #[inline]
                    fn bitxor(mut self, other: &BigInt) -> BigInt {
                        self ^= other;
                        self
                    }
                }

                forward_val_assign!(impl BitXorAssign for BigInt, bitxor_assign);

                impl BitXorAssign<&BigInt> for BigInt {
                    fn bitxor_assign(&mut self, other: &BigInt) {
                        match (self.sign, other.sign) {
                            (_, NoSign) => {}
                            (NoSign, _) => self.clone_from(other),
                            (Plus, Plus) => {
                                self.data ^= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            (Plus, Minus) => {
                                bitxor_pos_neg(self.digits_mut(), other.digits());
                                self.sign = Minus;
                                self.normalize();
                            }
                            (Minus, Plus) => {
                                bitxor_neg_pos(self.digits_mut(), other.digits());
                                self.normalize();
                            }
                            (Minus, Minus) => {
                                bitxor_neg_neg(self.digits_mut(), other.digits());
                                self.sign = Plus;
                                self.normalize();
                            }
                        }
                    }
                }

                pub(super) fn set_negative_bit(x: &mut BigInt, bit: u64, value: bool) {
                    debug_assert_eq!(x.sign, Minus);
                    let data = &mut x.data;

                    let bits_per_digit = u64::from(big_digit::BITS);
                    if bit >= bits_per_digit * data.len() as u64 {
                        if !value {
                            data.set_bit(bit, true);
                        }
                    } else {
                       
                       
                       
                       
                       
                       
                        let trailing_zeros = data.trailing_zeros().unwrap();
                        if bit > trailing_zeros {
                            data.set_bit(bit, !value);
                        } else if bit == trailing_zeros && !value {
                           
                           
                           
                           
                           
                            let bit_index = (bit / bits_per_digit).to_usize().unwrap();
                            let bit_mask = (1 as BigDigit) << (bit % bits_per_digit);
                            let mut digit_iter = data.digits_mut().iter_mut().skip(bit_index);
                            let mut carry_in = 1;
                            let mut carry_out = 1;

                            let digit = digit_iter.next().unwrap();
                            let twos_in = negate_carry(*digit, &mut carry_in);
                            let twos_out = twos_in & !bit_mask;
                            *digit = negate_carry(twos_out, &mut carry_out);

                            for digit in digit_iter {
                                if carry_in == 0 && carry_out == 0 {
                                   
                                    break;
                                }
                                let twos = negate_carry(*digit, &mut carry_in);
                                *digit = negate_carry(twos, &mut carry_out);
                            }

                            if carry_out != 0 {
                               
                                debug_assert_eq!(carry_in, 0);
                                data.digits_mut().push(1);
                            }
                        } else if bit < trailing_zeros && value {
                           
                           
                           
                           
                           
                           
                            let index_lo = (bit / bits_per_digit).to_usize().unwrap();
                            let index_hi = (trailing_zeros / bits_per_digit).to_usize().unwrap();
                            let bit_mask_lo = big_digit::MAX << (bit % bits_per_digit);
                            let bit_mask_hi =
                                big_digit::MAX >> (bits_per_digit - 1 - (trailing_zeros % bits_per_digit));
                            let digits = data.digits_mut();

                            if index_lo == index_hi {
                                digits[index_lo] ^= bit_mask_lo & bit_mask_hi;
                            } else {
                                digits[index_lo] = bit_mask_lo;
                                for digit in &mut digits[index_lo + 1..index_hi] {
                                    *digit = big_digit::MAX;
                                }
                                digits[index_hi] ^= bit_mask_hi;
                            }
                        } else {
                           
                           
                           
                        }
                    }
                }

            }

            pub mod convert
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    convert::{ TryFrom },
                    num::
                    {
                        big::{ BigUint, ParseBigIntError, ToBigUint, TryFromBigIntError },
                        traits::{ FromPrimitive, Num, One, ToPrimitive, Zero },
                    },
                    str::{ self, FromStr },
                    vec::{ Vec },
                    *,
                };
                use super::Sign::{self, Minus, NoSign, Plus};
                use super::{BigInt, ToBigInt};
                /*
                */
                impl FromStr for BigInt {
                    type Err = ParseBigIntError;

                    #[inline]
                    fn from_str(s: &str) -> Result<BigInt, ParseBigIntError> {
                        BigInt::from_str_radix(s, 10)
                    }
                }

                impl Num for BigInt {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a [`BigInt`].
                    #[inline]
                    fn from_str_radix(mut s: &str, radix: u32) -> Result<BigInt, ParseBigIntError> {
                        let sign = if let Some(tail) = s.strip_prefix('-') {
                            if !tail.starts_with('+') {
                                s = tail
                            }
                            Minus
                        } else {
                            Plus
                        };
                        let bu = BigUint::from_str_radix(s, radix)?;
                        Ok(BigInt::from_biguint(sign, bu))
                    }
                }

                impl ToPrimitive for BigInt {
                    #[inline]
                    fn to_i64(&self) -> Option<i64> {
                        match self.sign {
                            Plus => self.data.to_i64(),
                            NoSign => Some(0),
                            Minus => {
                                let n = self.data.to_u64()?;
                                let m: u64 = 1 << 63;
                                match n.cmp(&m) {
                                    Less => Some(-(n as i64)),
                                    Equal => Some(i64::MIN),
                                    Greater => None,
                                }
                            }
                        }
                    }

                    #[inline]
                    fn to_i128(&self) -> Option<i128> {
                        match self.sign {
                            Plus => self.data.to_i128(),
                            NoSign => Some(0),
                            Minus => {
                                let n = self.data.to_u128()?;
                                let m: u128 = 1 << 127;
                                match n.cmp(&m) {
                                    Less => Some(-(n as i128)),
                                    Equal => Some(i128::MIN),
                                    Greater => None,
                                }
                            }
                        }
                    }

                    #[inline]
                    fn to_u64(&self) -> Option<u64> {
                        match self.sign {
                            Plus => self.data.to_u64(),
                            NoSign => Some(0),
                            Minus => None,
                        }
                    }

                    #[inline]
                    fn to_u128(&self) -> Option<u128> {
                        match self.sign {
                            Plus => self.data.to_u128(),
                            NoSign => Some(0),
                            Minus => None,
                        }
                    }

                    #[inline]
                    fn to_f32(&self) -> Option<f32> {
                        let n = self.data.to_f32()?;
                        Some(if self.sign == Minus { -n } else { n })
                    }

                    #[inline]
                    fn to_f64(&self) -> Option<f64> {
                        let n = self.data.to_f64()?;
                        Some(if self.sign == Minus { -n } else { n })
                    }
                }

                macro_rules! impl_try_from_bigint {
                    ($T:ty, $to_ty:path) => {
                        impl TryFrom<&BigInt> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: &BigInt) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }

                        impl TryFrom<BigInt> for $T {
                            type Error = TryFromBigIntError<BigInt>;

                            #[inline]
                            fn try_from(value: BigInt) -> Result<$T, TryFromBigIntError<BigInt>> {
                                <$T>::try_from(&value).map_err(|_| TryFromBigIntError::new(value))
                            }
                        }
                    };
                }

                impl_try_from_bigint!(u8, ToPrimitive::to_u8);
                impl_try_from_bigint!(u16, ToPrimitive::to_u16);
                impl_try_from_bigint!(u32, ToPrimitive::to_u32);
                impl_try_from_bigint!(u64, ToPrimitive::to_u64);
                impl_try_from_bigint!(usize, ToPrimitive::to_usize);
                impl_try_from_bigint!(u128, ToPrimitive::to_u128);

                impl_try_from_bigint!(i8, ToPrimitive::to_i8);
                impl_try_from_bigint!(i16, ToPrimitive::to_i16);
                impl_try_from_bigint!(i32, ToPrimitive::to_i32);
                impl_try_from_bigint!(i64, ToPrimitive::to_i64);
                impl_try_from_bigint!(isize, ToPrimitive::to_isize);
                impl_try_from_bigint!(i128, ToPrimitive::to_i128);

                impl FromPrimitive for BigInt {
                    #[inline]
                    fn from_i64(n: i64) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline]
                    fn from_i128(n: i128) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline]
                    fn from_u64(n: u64) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline]
                    fn from_u128(n: u128) -> Option<BigInt> {
                        Some(BigInt::from(n))
                    }

                    #[inline]
                    fn from_f64(n: f64) -> Option<BigInt> {
                        if n >= 0.0 {
                            BigUint::from_f64(n).map(BigInt::from)
                        } else {
                            let x = BigUint::from_f64(-n)?;
                            Some(-BigInt::from(x))
                        }
                    }
                }

                impl From<i64> for BigInt {
                    #[inline]
                    fn from(n: i64) -> Self {
                        if n >= 0 {
                            BigInt::from(n as u64)
                        } else {
                            let u = u64::MAX - (n as u64) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from(u),
                            }
                        }
                    }
                }

                impl From<i128> for BigInt {
                    #[inline]
                    fn from(n: i128) -> Self {
                        if n >= 0 {
                            BigInt::from(n as u128)
                        } else {
                            let u = u128::MAX - (n as u128) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from(u),
                            }
                        }
                    }
                }

                macro_rules! impl_bigint_from_int {
                    ($T:ty) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigInt::from(n as i64)
                            }
                        }
                    };
                }

                impl_bigint_from_int!(i8);
                impl_bigint_from_int!(i16);
                impl_bigint_from_int!(i32);
                impl_bigint_from_int!(isize);

                impl From<u64> for BigInt {
                    #[inline]
                    fn from(n: u64) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from(n),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }

                impl From<u128> for BigInt {
                    #[inline]
                    fn from(n: u128) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from(n),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }

                macro_rules! impl_bigint_from_uint {
                    ($T:ty) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigInt::from(n as u64)
                            }
                        }
                    };
                }

                impl_bigint_from_uint!(u8);
                impl_bigint_from_uint!(u16);
                impl_bigint_from_uint!(u32);
                impl_bigint_from_uint!(usize);

                impl From<BigUint> for BigInt {
                    #[inline]
                    fn from(n: BigUint) -> Self {
                        if n.is_zero() {
                            Self::ZERO
                        } else {
                            BigInt {
                                sign: Plus,
                                data: n,
                            }
                        }
                    }
                }

                impl ToBigInt for BigInt {
                    #[inline]
                    fn to_bigint(&self) -> Option<BigInt> {
                        Some(self.clone())
                    }
                }

                impl ToBigInt for BigUint {
                    #[inline]
                    fn to_bigint(&self) -> Option<BigInt> {
                        if self.is_zero() {
                            Some(BigInt::ZERO)
                        } else {
                            Some(BigInt {
                                sign: Plus,
                                data: self.clone(),
                            })
                        }
                    }
                }

                impl ToBigUint for BigInt {
                    #[inline]
                    fn to_biguint(&self) -> Option<BigUint> {
                        match self.sign() {
                            Plus => Some(self.data.clone()),
                            NoSign => Some(BigUint::ZERO),
                            Minus => None,
                        }
                    }
                }

                impl TryFrom<&BigInt> for BigUint {
                    type Error = TryFromBigIntError<()>;

                    #[inline]
                    fn try_from(value: &BigInt) -> Result<BigUint, TryFromBigIntError<()>> {
                        value
                            .to_biguint()
                            .ok_or_else(|| TryFromBigIntError::new(()))
                    }
                }

                impl TryFrom<BigInt> for BigUint {
                    type Error = TryFromBigIntError<BigInt>;

                    #[inline]
                    fn try_from(value: BigInt) -> Result<BigUint, TryFromBigIntError<BigInt>> {
                        if value.sign() == Sign::Minus {
                            Err(TryFromBigIntError::new(value))
                        } else {
                            Ok(value.data)
                        }
                    }
                }

                macro_rules! impl_to_bigint {
                    ($T:ty, $from_ty:path) => {
                        impl ToBigInt for $T {
                            #[inline]
                            fn to_bigint(&self) -> Option<BigInt> {
                                $from_ty(*self)
                            }
                        }
                    };
                }

                impl_to_bigint!(isize, FromPrimitive::from_isize);
                impl_to_bigint!(i8, FromPrimitive::from_i8);
                impl_to_bigint!(i16, FromPrimitive::from_i16);
                impl_to_bigint!(i32, FromPrimitive::from_i32);
                impl_to_bigint!(i64, FromPrimitive::from_i64);
                impl_to_bigint!(i128, FromPrimitive::from_i128);

                impl_to_bigint!(usize, FromPrimitive::from_usize);
                impl_to_bigint!(u8, FromPrimitive::from_u8);
                impl_to_bigint!(u16, FromPrimitive::from_u16);
                impl_to_bigint!(u32, FromPrimitive::from_u32);
                impl_to_bigint!(u64, FromPrimitive::from_u64);
                impl_to_bigint!(u128, FromPrimitive::from_u128);

                impl_to_bigint!(f32, FromPrimitive::from_f32);
                impl_to_bigint!(f64, FromPrimitive::from_f64);

                impl From<bool> for BigInt {
                    fn from(x: bool) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }

                #[inline]
                pub(super) fn from_signed_bytes_be(digits: &[u8]) -> BigInt {
                    let sign = match digits.first() {
                        Some(v) if *v > 0x7f => Sign::Minus,
                        Some(_) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                       
                        let mut digits = Vec::from(digits);
                        twos_complement_be(&mut digits);
                        BigInt::from_biguint(sign, BigUint::from_bytes_be(&digits))
                    } else {
                        BigInt::from_biguint(sign, BigUint::from_bytes_be(digits))
                    }
                }

                #[inline]
                pub(super) fn from_signed_bytes_le(digits: &[u8]) -> BigInt {
                    let sign = match digits.last() {
                        Some(v) if *v > 0x7f => Sign::Minus,
                        Some(_) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                       
                        let mut digits = Vec::from(digits);
                        twos_complement_le(&mut digits);
                        BigInt::from_biguint(sign, BigUint::from_bytes_le(&digits))
                    } else {
                        BigInt::from_biguint(sign, BigUint::from_bytes_le(digits))
                    }
                }

                #[inline]
                pub(super) fn to_signed_bytes_be(x: &BigInt) -> Vec<u8> {
                    let mut bytes = x.data.to_bytes_be();
                    let first_byte = bytes.first().cloned().unwrap_or(0);
                    if first_byte > 0x7f
                        && !(first_byte == 0x80 && bytes.iter().skip(1).all(Zero::is_zero) && x.sign == Sign::Minus)
                    {
                       
                        bytes.insert(0, 0);
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_be(&mut bytes);
                    }
                    bytes
                }

                #[inline]
                pub(super) fn to_signed_bytes_le(x: &BigInt) -> Vec<u8> {
                    let mut bytes = x.data.to_bytes_le();
                    let last_byte = bytes.last().cloned().unwrap_or(0);
                    if last_byte > 0x7f
                        && !(last_byte == 0x80
                            && bytes.iter().rev().skip(1).all(Zero::is_zero)
                            && x.sign == Sign::Minus)
                    {
                       
                        bytes.push(0);
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_le(&mut bytes);
                    }
                    bytes
                }

                /// Perform in-place two's complement of the given binary representation,
                /// in little-endian byte order.
                #[inline]
                fn twos_complement_le(digits: &mut [u8]) {
                    twos_complement(digits)
                }

                /// Perform in-place two's complement of the given binary representation
                /// in big-endian byte order.
                #[inline]
                fn twos_complement_be(digits: &mut [u8]) {
                    twos_complement(digits.iter_mut().rev())
                }

                /// Perform in-place two's complement of the given digit iterator
                /// starting from the least significant byte.
                #[inline]
                fn twos_complement<'a, I>(digits: I) where
                    I: IntoIterator<Item = &'a mut u8>,
                {
                    let mut carry = true;
                    for d in digits {
                        *d = !*d;
                        if carry {
                            *d = d.wrapping_add(1);
                            carry = d.is_zero();
                        }
                    }
                }

            }

            pub mod power
            {
                use ::
                {
                    num::
                    {
                        big::{ BigUint }, 
                        integers::Integer,
                        traits::{Pow, Signed, Zero},
                    },
                    *,
                };
                use super::BigInt;
                use super::Sign::{self, Minus, Plus};
                /*
                */
                /// Help function for pow
                ///
                /// Computes the effect of the exponent on the sign.
                #[inline]
                fn powsign<T: Integer>(sign: Sign, other: &T) -> Sign {
                    if other.is_zero() {
                        Plus
                    } else if sign != Minus || other.is_odd() {
                        sign
                    } else {
                        -sign
                    }
                }

                macro_rules! pow_impl {
                    ($T:ty) => {
                        impl Pow<$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: $T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, &rhs), self.data.pow(rhs))
                            }
                        }

                        impl Pow<&$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: &$T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, rhs), self.data.pow(rhs))
                            }
                        }

                        impl Pow<$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: $T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, &rhs), Pow::pow(&self.data, rhs))
                            }
                        }

                        impl Pow<&$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow(self, rhs: &$T) -> BigInt {
                                BigInt::from_biguint(powsign(self.sign, rhs), Pow::pow(&self.data, rhs))
                            }
                        }
                    };
                }

                pow_impl!(u8);
                pow_impl!(u16);
                pow_impl!(u32);
                pow_impl!(u64);
                pow_impl!(usize);
                pow_impl!(u128);
                pow_impl!(BigUint);

                pub(super) fn modpow(x: &BigInt, exponent: &BigInt, modulus: &BigInt) -> BigInt {
                    assert!(
                        !exponent.is_negative(),
                        "negative exponentiation is not supported!"
                    );
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    let result = x.data.modpow(&exponent.data, &modulus.data);
                    if result.is_zero() {
                        return BigInt::ZERO;
                    }

                   
                    let (sign, mag) = match (x.is_negative() && exponent.is_odd(), modulus.is_negative()) {
                        (false, false) => (Plus, result),
                        (true, false) => (Plus, &modulus.data - result),
                        (false, true) => (Minus, &modulus.data - result),
                        (true, true) => (Minus, result),
                    };
                    BigInt::from_biguint(sign, mag)
                }

            }

            pub mod shift
            {
                use ::
                {
                    *,
                };
                /*
                use super::BigInt;
                use super::Sign::NoSign;

                use ::ops::{Shl, ShlAssign, Shr, ShrAssign};
                use num_traits::{PrimInt, Signed, Zero};
                */
                macro_rules! impl_shift {
                    (@ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty) => {
                        impl $Shx<&$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigInt {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $Shx<&$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigInt {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigInt {
                            #[inline]
                            fn $shx_assign(&mut self, rhs: &$rhs) {
                                $ShxAssign::$shx_assign(self, *rhs);
                            }
                        }
                    };
                    ($($rhs:ty),+) => {$(
                        impl Shl<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigInt {
                                BigInt::from_biguint(self.sign, self.data << rhs)
                            }
                        }
                        impl Shl<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigInt {
                                BigInt::from_biguint(self.sign, &self.data << rhs)
                            }
                        }
                        impl ShlAssign<$rhs> for BigInt {
                            #[inline]
                            fn shl_assign(&mut self, rhs: $rhs) {
                                self.data <<= rhs
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }

                        impl Shr<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigInt {
                                let round_down = shr_round_down(&self, rhs);
                                let data = self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint(self.sign, data)
                            }
                        }
                        impl Shr<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigInt {
                                let round_down = shr_round_down(self, rhs);
                                let data = &self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint(self.sign, data)
                            }
                        }
                        impl ShrAssign<$rhs> for BigInt {
                            #[inline]
                            fn shr_assign(&mut self, rhs: $rhs) {
                                let round_down = shr_round_down(self, rhs);
                                self.data >>= rhs;
                                if round_down {
                                    self.data += 1u8;
                                } else if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }

                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }

               
               
                fn shr_round_down<T: PrimInt>(i: &BigInt, shift: T) -> bool {
                    if i.is_negative() {
                        let zeros = i.trailing_zeros().expect("negative values are non-zero");
                        shift > T::zero() && shift.to_u64().map(|shift| zeros < shift).unwrap_or(true)
                    } else {
                        false
                    }
                }

            }
            /// A `Sign` is a [`BigInt`]'s composing element.
            #[derive(PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash)]
            pub enum Sign {
                Minus,
                NoSign,
                Plus,
            }

            impl Neg for Sign {
                type Output = Sign;

                /// Negate `Sign` value.
                #[inline]
                fn neg(self) -> Sign {
                    match self {
                        Minus => Plus,
                        NoSign => NoSign,
                        Plus => Minus,
                    }
                }
            }
            /// A big signed integer type.
            pub struct BigInt {
                sign: Sign,
                data: BigUint,
            }
                       
            impl Clone for BigInt {
                #[inline]
                fn clone(&self) -> Self {
                    BigInt {
                        sign: self.sign,
                        data: self.data.clone(),
                    }
                }

                #[inline]
                fn clone_from(&mut self, other: &Self) {
                    self.sign = other.sign;
                    self.data.clone_from(&other.data);
                }
            }

            impl hash::Hash for BigInt {
                #[inline]
                fn hash<H: hash::Hasher>(&self, state: &mut H) {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    self.sign.hash(state);
                    if self.sign != NoSign {
                        self.data.hash(state);
                    }
                }
            }

            impl PartialEq for BigInt {
                #[inline]
                fn eq(&self, other: &BigInt) -> bool {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    debug_assert!((other.sign != NoSign) ^ other.data.is_zero());
                    self.sign == other.sign && (self.sign == NoSign || self.data == other.data)
                }
            }

            impl Eq for BigInt {}

            impl PartialOrd for BigInt {
                #[inline]
                fn partial_cmp(&self, other: &BigInt) -> Option<Ordering> {
                    Some(self.cmp(other))
                }
            }

            impl Ord for BigInt {
                #[inline]
                fn cmp(&self, other: &BigInt) -> Ordering {
                    debug_assert!((self.sign != NoSign) ^ self.data.is_zero());
                    debug_assert!((other.sign != NoSign) ^ other.data.is_zero());
                    let scmp = self.sign.cmp(&other.sign);
                    if scmp != Equal {
                        return scmp;
                    }

                    match self.sign {
                        NoSign => Equal,
                        Plus => self.data.cmp(&other.data),
                        Minus => other.data.cmp(&self.data),
                    }
                }
            }

            impl Default for BigInt {
                #[inline]
                fn default() -> BigInt {
                    Self::ZERO
                }
            }

            impl fmt::Debug for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {    fmt::Display::fmt(self, f)
                }
            }

            impl fmt::Display for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {    f.pad_integral(!self.is_negative(), "", &self.data.to_str_radix(10))
                }
            }

            impl fmt::Binary for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {    f.pad_integral(!self.is_negative(), "0b", &self.data.to_str_radix(2))
                }
            }

            impl fmt::Octal for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {    f.pad_integral(!self.is_negative(), "0o", &self.data.to_str_radix(8))
                }
            }

            impl fmt::LowerHex for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {    f.pad_integral(!self.is_negative(), "0x", &self.data.to_str_radix(16))
                }
            }

            impl fmt::UpperHex for BigInt {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {    let mut s = self.data.to_str_radix(16);
                    s.make_ascii_uppercase();
                    f.pad_integral(!self.is_negative(), "0x", &s)
                }
            }
            
            impl Not for BigInt {
                type Output = BigInt;

                fn not(mut self) -> BigInt {
                    match self.sign {
                        NoSign | Plus => {
                            self.data += 1u32;
                            self.sign = Minus;
                        }
                        Minus => {
                            self.data -= 1u32;
                            self.sign = if self.data.is_zero() { NoSign } else { Plus };
                        }
                    }
                    self
                }
            }

            impl Not for &BigInt {
                type Output = BigInt;

                fn not(self) -> BigInt {
                    match self.sign {
                        NoSign => -BigInt::one(),
                        Plus => -BigInt::from(&self.data + 1u32),
                        Minus => BigInt::from(&self.data - 1u32),
                    }
                }
            }

            impl Zero for BigInt {
                #[inline]
                fn zero() -> BigInt {
                    Self::ZERO
                }

                #[inline]
                fn set_zero(&mut self) {
                    self.data.set_zero();
                    self.sign = NoSign;
                }

                #[inline]
                fn is_zero(&self) -> bool {
                    self.sign == NoSign
                }
            }

            impl ConstZero for BigInt {
               
                const ZERO: Self = Self::ZERO;
            }

            impl One for BigInt {
                #[inline]
                fn one() -> BigInt {
                    BigInt {
                        sign: Plus,
                        data: BigUint::one(),
                    }
                }

                #[inline]
                fn set_one(&mut self) {
                    self.data.set_one();
                    self.sign = Plus;
                }

                #[inline]
                fn is_one(&self) -> bool {
                    self.sign == Plus && self.data.is_one()
                }
            }

            impl Signed for BigInt {
                #[inline]
                fn abs(&self) -> BigInt {
                    match self.sign {
                        Plus | NoSign => self.clone(),
                        Minus => BigInt::from(self.data.clone()),
                    }
                }

                #[inline]
                fn abs_sub(&self, other: &BigInt) -> BigInt {
                    if *self <= *other {
                        Self::ZERO
                    } else {
                        self - other
                    }
                }

                #[inline]
                fn signum(&self) -> BigInt {
                    match self.sign {
                        Plus => BigInt::one(),
                        Minus => -BigInt::one(),
                        NoSign => Self::ZERO,
                    }
                }

                #[inline]
                fn is_positive(&self) -> bool {
                    self.sign == Plus
                }

                #[inline]
                fn is_negative(&self) -> bool {
                    self.sign == Minus
                }
            }

            trait UnsignedAbs {
                type Unsigned;

                fn checked_uabs(self) -> CheckedUnsignedAbs<Self::Unsigned>;
            }

            enum CheckedUnsignedAbs<T> {
                Positive(T),
                Negative(T),
            }
            use self::CheckedUnsignedAbs::{Negative, Positive};

            macro_rules! impl_unsigned_abs {
                ($Signed:ty, $Unsigned:ty) => {
                    impl UnsignedAbs for $Signed {
                        type Unsigned = $Unsigned;

                        #[inline]
                        fn checked_uabs(self) -> CheckedUnsignedAbs<Self::Unsigned> {
                            if self >= 0 {
                                Positive(self as $Unsigned)
                            } else {
                                Negative(self.wrapping_neg() as $Unsigned)
                            }
                        }
                    }
                };
            }
            impl_unsigned_abs!(i8, u8);
            impl_unsigned_abs!(i16, u16);
            impl_unsigned_abs!(i32, u32);
            impl_unsigned_abs!(i64, u64);
            impl_unsigned_abs!(i128, u128);
            impl_unsigned_abs!(isize, usize);

            impl Neg for BigInt {
                type Output = BigInt;

                #[inline]
                fn neg(mut self) -> BigInt {
                    self.sign = -self.sign;
                    self
                }
            }

            impl Neg for &BigInt {
                type Output = BigInt;

                #[inline]
                fn neg(self) -> BigInt {
                    -self.clone()
                }
            }

            impl Integer for BigInt {
                #[inline]
                fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {
                   
                    let (d_ui, r_ui) = self.data.div_rem(&other.data);
                    let d = BigInt::from_biguint(self.sign, d_ui);
                    let r = BigInt::from_biguint(self.sign, r_ui);
                    if other.is_negative() {
                        (-d, r)
                    } else {
                        (d, r)
                    }
                }

                #[inline]
                fn div_floor(&self, other: &BigInt) -> BigInt {
                    let (d_ui, m) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => d,
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                -d
                            } else {
                                -d - 1u32
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                #[inline]
                fn mod_floor(&self, other: &BigInt) -> BigInt {
                   
                    let m_ui = self.data.mod_floor(&other.data);
                    let m = BigInt::from_biguint(other.sign, m_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => m,
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                m
                            } else {
                                other - m
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {
                   
                    let (d_ui, m_ui) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    let m = BigInt::from_biguint(other.sign, m_ui);
                    match (self.sign, other.sign) {
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => (d, m),
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => {
                            if m.is_zero() {
                                (-d, m)
                            } else {
                                (-d - 1u32, other - m)
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                #[inline]
                fn div_ceil(&self, other: &Self) -> Self {
                    let (d_ui, m) = self.data.div_mod_floor(&other.data);
                    let d = BigInt::from(d_ui);
                    match (self.sign, other.sign) {
                        (Plus, Minus) | (NoSign, Minus) | (Minus, Plus) => -d,
                        (Plus, Plus) | (NoSign, Plus) | (Minus, Minus) => {
                            if m.is_zero() {
                                d
                            } else {
                                d + 1u32
                            }
                        }
                        (_, NoSign) => unreachable!(),
                    }
                }

                /// Calculates the Greatest Common Divisor (GCD) of the number and `other`.
                ///
                /// The result is always positive.
                #[inline]
                fn gcd(&self, other: &BigInt) -> BigInt {
                    BigInt::from(self.data.gcd(&other.data))
                }

                /// Calculates the Lowest Common Multiple (LCM) of the number and `other`.
                #[inline]
                fn lcm(&self, other: &BigInt) -> BigInt {
                    BigInt::from(self.data.lcm(&other.data))
                }

                /// Calculates the Greatest Common Divisor (GCD) and
                /// Lowest Common Multiple (LCM) together.
                #[inline]
                fn gcd_lcm(&self, other: &BigInt) -> (BigInt, BigInt) {
                    let (gcd, lcm) = self.data.gcd_lcm(&other.data);
                    (BigInt::from(gcd), BigInt::from(lcm))
                }

                /// Greatest common divisor, least common multiple, and Bézout coefficients.
                #[inline]
                fn extended_gcd_lcm(&self, other: &BigInt) -> (num_integer::ExtendedGcd<BigInt>, BigInt) {
                    let egcd = self.extended_gcd(other);
                    let lcm = if egcd.gcd.is_zero() {
                        Self::ZERO
                    } else {
                        BigInt::from(&self.data / &egcd.gcd.data * &other.data)
                    };
                    (egcd, lcm)
                }

                /// Deprecated, use `is_multiple_of` instead.
                #[inline]
                fn divides(&self, other: &BigInt) -> bool {
                    self.is_multiple_of(other)
                }

                /// Returns `true` if the number is a multiple of `other`.
                #[inline]
                fn is_multiple_of(&self, other: &BigInt) -> bool {
                    self.data.is_multiple_of(&other.data)
                }

                /// Returns `true` if the number is divisible by `2`.
                #[inline]
                fn is_even(&self) -> bool {
                    self.data.is_even()
                }

                /// Returns `true` if the number is not divisible by `2`.
                #[inline]
                fn is_odd(&self) -> bool {
                    self.data.is_odd()
                }

                /// Rounds up to nearest multiple of argument.
                #[inline]
                fn next_multiple_of(&self, other: &Self) -> Self {
                    let m = self.mod_floor(other);
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + (other - m)
                    }
                }
                /// Rounds down to nearest multiple of argument.
                #[inline]
                fn prev_multiple_of(&self, other: &Self) -> Self {
                    self - self.mod_floor(other)
                }

                fn dec(&mut self) {
                    *self -= 1u32;
                }

                fn inc(&mut self) {
                    *self += 1u32;
                }
            }

            impl Roots for BigInt {
                fn nth_root(&self, n: u32) -> Self {
                    assert!(
                        !(self.is_negative() && n.is_even()),
                        "root of degree {} is imaginary",
                        n
                    );

                    BigInt::from_biguint(self.sign, self.data.nth_root(n))
                }

                fn sqrt(&self) -> Self {
                    assert!(!self.is_negative(), "square root is imaginary");

                    BigInt::from_biguint(self.sign, self.data.sqrt())
                }

                fn cbrt(&self) -> Self {
                    BigInt::from_biguint(self.sign, self.data.cbrt())
                }
            }

            impl IntDigits for BigInt {
                #[inline]
                fn digits(&self) -> &[BigDigit] {
                    self.data.digits()
                }
                #[inline]
                fn digits_mut(&mut self) -> &mut Vec<BigDigit> {
                    self.data.digits_mut()
                }
                #[inline]
                fn normalize(&mut self) {
                    self.data.normalize();
                    if self.data.is_zero() {
                        self.sign = NoSign;
                    }
                }
                #[inline]
                fn capacity(&self) -> usize {
                    self.data.capacity()
                }
                #[inline]
                fn len(&self) -> usize {
                    self.data.len()
                }
            }
            /// A generic trait for converting a value to a [`BigInt`]. This may return
            /// `None` when converting from `f32` or `f64`, and will always succeed
            /// when converting from any integer or unsigned primitive, or [`BigUint`].
            pub trait ToBigInt {
                /// Converts the value of `self` to a [`BigInt`].
                fn to_bigint(&self) -> Option<BigInt>;
            }

            impl BigInt {
                /// A constant `BigInt` with value 0, useful for static initialization.
                pub const ZERO: Self = BigInt {
                    sign: NoSign,
                    data: BigUint::ZERO,
                };

                /// Creates and initializes a [`BigInt`].
                ///
                /// The base 2<sup>32</sup> digits are ordered least significant digit first.
                #[inline]
                pub fn new(sign: Sign, digits: Vec<u32>) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::new(digits))
                }

                /// Creates and initializes a [`BigInt`].
                ///
                /// The base 2<sup>32</sup> digits are ordered least significant digit first.
                #[inline]
                pub fn from_biguint(mut sign: Sign, mut data: BigUint) -> BigInt {
                    if sign == NoSign {
                        data.assign_from_slice(&[]);
                    } else if data.is_zero() {
                        sign = NoSign;
                    }

                    BigInt { sign, data }
                }

                /// Creates and initializes a [`BigInt`].
                ///
                /// The base 2<sup>32</sup> digits are ordered least significant digit first.
                #[inline]
                pub fn from_slice(sign: Sign, slice: &[u32]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_slice(slice))
                }

                /// Reinitializes a [`BigInt`].
                ///
                /// The base 2<sup>32</sup> digits are ordered least significant digit first.
                #[inline]
                pub fn assign_from_slice(&mut self, sign: Sign, slice: &[u32]) {
                    if sign == NoSign {
                        self.set_zero();
                    } else {
                        self.data.assign_from_slice(slice);
                        self.sign = if self.data.is_zero() { NoSign } else { sign };
                    }
                }

                /// Creates and initializes a [`BigInt`].
                ///
                /// ```
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from_bytes_be(Sign::Plus, b"A"),
                ///            BigInt::parse_bytes(b"65", 10).unwrap());
                /// assert_eq!(BigInt::from_bytes_be(Sign::Plus, b"AA"),
                ///            BigInt::parse_bytes(b"16705", 10).unwrap());
                /// assert_eq!(BigInt::from_bytes_be(Sign::Plus, b"AB"),
                ///            BigInt::parse_bytes(b"16706", 10).unwrap());
                /// assert_eq!(BigInt::from_bytes_be(Sign::Plus, b"Hello world!"),
                ///            BigInt::parse_bytes(b"22405534230753963835153736737", 10).unwrap());
                /// ```
                #[inline]
                pub fn from_bytes_be(sign: Sign, bytes: &[u8]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_bytes_be(bytes))
                }

                /// Creates and initializes a [`BigInt`].
                ///
                /// The bytes are in little-endian byte order.
                #[inline]
                pub fn from_bytes_le(sign: Sign, bytes: &[u8]) -> BigInt {
                    BigInt::from_biguint(sign, BigUint::from_bytes_le(bytes))
                }

                /// Creates and initializes a [`BigInt`] from an array of bytes in
                /// two's complement binary representation.
                ///
                /// The digits are in big-endian base 2<sup>8</sup>.
                #[inline]
                pub fn from_signed_bytes_be(digits: &[u8]) -> BigInt {
                    convert::from_signed_bytes_be(digits)
                }

                /// Creates and initializes a [`BigInt`] from an array of bytes in two's complement.
                ///
                /// The digits are in little-endian base 2<sup>8</sup>.
                #[inline]
                pub fn from_signed_bytes_le(digits: &[u8]) -> BigInt {
                    convert::from_signed_bytes_le(digits)
                }

                /// Creates and initializes a [`BigInt`].
                /// use num_bigint::{BigInt, ToBigInt};
                ///
                /// assert_eq!(BigInt::parse_bytes(b"1234", 10), ToBigInt::to_bigint(&1234));
                /// assert_eq!(BigInt::parse_bytes(b"ABCD", 16), ToBigInt::to_bigint(&0xABCD));
                /// assert_eq!(BigInt::parse_bytes(b"G", 16), None);
                /// ```
                #[inline]
                pub fn parse_bytes(buf: &[u8], radix: u32) -> Option<BigInt> {
                    let s = str::from_utf8(buf).ok()?;
                    BigInt::from_str_radix(s, radix).ok()
                }

                /// Creates and initializes a [`BigInt`]. Each `u8` of the input slice is
                /// interpreted as one digit of the number
                /// and must therefore be less than `radix`.
                ///
                /// The bytes are in big-endian byte order.
                /// `radix` must be in the range `2...256`.
                /// use num_bigint::{BigInt, Sign};
                ///
                /// let inbase190 = vec![15, 33, 125, 12, 14];
                /// let a = BigInt::from_radix_be(Sign::Minus, &inbase190, 190).unwrap();
                /// assert_eq!(a.to_radix_be(190), (Sign:: Minus, inbase190));
                /// ```
                pub fn from_radix_be(sign: Sign, buf: &[u8], radix: u32) -> Option<BigInt> {
                    let u = BigUint::from_radix_be(buf, radix)?;
                    Some(BigInt::from_biguint(sign, u))
                }

                /// Creates and initializes a [`BigInt`]. Each `u8` of the input slice is
                /// interpreted as one digit of the number
                /// and must therefore be less than `radix`.
                ///
                /// The bytes are in little-endian byte order.
                /// `radix` must be in the range `2...256`.
                /// use num_bigint::{BigInt, Sign};
                ///
                /// let inbase190 = vec![14, 12, 125, 33, 15];
                /// let a = BigInt::from_radix_be(Sign::Minus, &inbase190, 190).unwrap();
                /// assert_eq!(a.to_radix_be(190), (Sign::Minus, inbase190));
                /// ```
                pub fn from_radix_le(sign: Sign, buf: &[u8], radix: u32) -> Option<BigInt> {
                    let u = BigUint::from_radix_le(buf, radix)?;
                    Some(BigInt::from_biguint(sign, u))
                }

                /// Returns the sign and the byte representation of the [`BigInt`] in big-endian byte order.
                /// use num_bigint::{ToBigInt, Sign};
                ///
                /// let i = -1125.to_bigint().unwrap();
                /// assert_eq!(i.to_bytes_be(), (Sign::Minus, vec![4, 101]));
                /// ```
                #[inline]
                pub fn to_bytes_be(&self) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_bytes_be())
                }

                /// Returns the sign and the byte representation of the [`BigInt`] in little-endian byte order.
                /// use num_bigint::{ToBigInt, Sign};
                ///
                /// let i = -1125.to_bigint().unwrap();
                /// assert_eq!(i.to_bytes_le(), (Sign::Minus, vec![101, 4]));
                /// ```
                #[inline]
                pub fn to_bytes_le(&self) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_bytes_le())
                }

                /// Returns the sign and the `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(-1125).to_u32_digits(), (Sign::Minus, vec![1125]));
                /// assert_eq!(BigInt::from(4294967295u32).to_u32_digits(), (Sign::Plus, vec![4294967295]));
                /// assert_eq!(BigInt::from(4294967296u64).to_u32_digits(), (Sign::Plus, vec![0, 1]));
                /// assert_eq!(BigInt::from(-112500000000i64).to_u32_digits(), (Sign::Minus, vec![830850304, 26]));
                /// assert_eq!(BigInt::from(112500000000i64).to_u32_digits(), (Sign::Plus, vec![830850304, 26]));
                /// ```
                #[inline]
                pub fn to_u32_digits(&self) -> (Sign, Vec<u32>) {
                    (self.sign, self.data.to_u32_digits())
                }

                /// Returns the sign and the `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(-1125).to_u64_digits(), (Sign::Minus, vec![1125]));
                /// assert_eq!(BigInt::from(4294967295u32).to_u64_digits(), (Sign::Plus, vec![4294967295]));
                /// assert_eq!(BigInt::from(4294967296u64).to_u64_digits(), (Sign::Plus, vec![4294967296]));
                /// assert_eq!(BigInt::from(-112500000000i64).to_u64_digits(), (Sign::Minus, vec![112500000000]));
                /// assert_eq!(BigInt::from(112500000000i64).to_u64_digits(), (Sign::Plus, vec![112500000000]));
                /// assert_eq!(BigInt::from(1u128 << 64).to_u64_digits(), (Sign::Plus, vec![0, 1]));
                /// ```
                #[inline]
                pub fn to_u64_digits(&self) -> (Sign, Vec<u64>) {
                    (self.sign, self.data.to_u64_digits())
                }

                /// Returns an iterator of `u32` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                /// use num_bigint::BigInt;
                ///
                /// assert_eq!(BigInt::from(-1125).iter_u32_digits().collect::<Vec<u32>>(), vec![1125]);
                /// assert_eq!(BigInt::from(4294967295u32).iter_u32_digits().collect::<Vec<u32>>(), vec![4294967295]);
                /// assert_eq!(BigInt::from(4294967296u64).iter_u32_digits().collect::<Vec<u32>>(), vec![0, 1]);
                /// assert_eq!(BigInt::from(-112500000000i64).iter_u32_digits().collect::<Vec<u32>>(), vec![830850304, 26]);
                /// assert_eq!(BigInt::from(112500000000i64).iter_u32_digits().collect::<Vec<u32>>(), vec![830850304, 26]);
                /// ```
                #[inline]
                pub fn iter_u32_digits(&self) -> U32Digits<'_> {
                    self.data.iter_u32_digits()
                }

                /// Returns an iterator of `u64` digits representation of the [`BigInt`] ordered least
                /// significant digit first.
                /// use num_bigint::BigInt;
                ///
                /// assert_eq!(BigInt::from(-1125).iter_u64_digits().collect::<Vec<u64>>(), vec![1125u64]);
                /// assert_eq!(BigInt::from(4294967295u32).iter_u64_digits().collect::<Vec<u64>>(), vec![4294967295u64]);
                /// assert_eq!(BigInt::from(4294967296u64).iter_u64_digits().collect::<Vec<u64>>(), vec![4294967296u64]);
                /// assert_eq!(BigInt::from(-112500000000i64).iter_u64_digits().collect::<Vec<u64>>(), vec![112500000000u64]);
                /// assert_eq!(BigInt::from(112500000000i64).iter_u64_digits().collect::<Vec<u64>>(), vec![112500000000u64]);
                /// assert_eq!(BigInt::from(1u128 << 64).iter_u64_digits().collect::<Vec<u64>>(), vec![0, 1]);
                /// ```
                #[inline]
                pub fn iter_u64_digits(&self) -> U64Digits<'_> {
                    self.data.iter_u64_digits()
                }

                /// Returns the two's-complement byte representation of the [`BigInt`] in big-endian byte order.
                /// use num_bigint::ToBigInt;
                ///
                /// let i = -1125.to_bigint().unwrap();
                /// assert_eq!(i.to_signed_bytes_be(), vec![251, 155]);
                /// ```
                #[inline]
                pub fn to_signed_bytes_be(&self) -> Vec<u8> {
                    convert::to_signed_bytes_be(self)
                }

                /// Returns the two's-complement byte representation of the [`BigInt`] in little-endian byte order.
                /// use num_bigint::ToBigInt;
                ///
                /// let i = -1125.to_bigint().unwrap();
                /// assert_eq!(i.to_signed_bytes_le(), vec![155, 251]);
                /// ```
                #[inline]
                pub fn to_signed_bytes_le(&self) -> Vec<u8> {
                    convert::to_signed_bytes_le(self)
                }

                /// Returns the integer formatted as a string in the given radix.
                /// `radix` must be in the range `2...36`.
                /// use num_bigint::BigInt;
                ///
                /// let i = BigInt::parse_bytes(b"ff", 16).unwrap();
                /// assert_eq!(i.to_str_radix(16), "ff");
                /// ```
                #[inline]
                pub fn to_str_radix(&self, radix: u32) -> String {
                    let mut v = to_str_radix_reversed(&self.data, radix);

                    if self.is_negative() {
                        v.push(b'-');
                    }

                    v.reverse();
                    unsafe { String::from_utf8_unchecked(v) }
                }

                /// Returns the integer in the requested base in big-endian digit order.
                /// The output is not given in a human readable alphabet but as a zero
                /// based `u8` number.
                /// `radix` must be in the range `2...256`.
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(-0xFFFFi64).to_radix_be(159),
                ///            (Sign::Minus, vec![2, 94, 27]));
                ///
                /// ```
                #[inline]
                pub fn to_radix_be(&self, radix: u32) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_radix_be(radix))
                }

                /// Returns the integer in the requested base in little-endian digit order.
                /// The output is not given in a human readable alphabet but as a zero
                /// based `u8` number.
                /// `radix` must be in the range `2...256`.
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(-0xFFFFi64).to_radix_le(159),
                ///            (Sign::Minus, vec![27, 94, 2]));
                ///
                /// ```
                #[inline]
                pub fn to_radix_le(&self, radix: u32) -> (Sign, Vec<u8>) {
                    (self.sign, self.data.to_radix_le(radix))
                }

                /// Returns the sign of the [`BigInt`] as a [`Sign`].
                /// use num_bigint::{BigInt, Sign};
                ///
                /// assert_eq!(BigInt::from(1234).sign(), Sign::Plus);
                /// assert_eq!(BigInt::from(-4321).sign(), Sign::Minus);
                /// assert_eq!(BigInt::ZERO.sign(), Sign::NoSign);
                /// ```
                #[inline]
                pub fn sign(&self) -> Sign {
                    self.sign
                }

                /// Returns the magnitude of the [`BigInt`] as a [`BigUint`].
                /// use num_bigint::{BigInt, BigUint};
                /// use num_traits::Zero;
                ///
                /// assert_eq!(BigInt::from(1234).magnitude(), &BigUint::from(1234u32));
                /// assert_eq!(BigInt::from(-4321).magnitude(), &BigUint::from(4321u32));
                /// assert!(BigInt::ZERO.magnitude().is_zero());
                /// ```
                #[inline]
                pub fn magnitude(&self) -> &BigUint {
                    &self.data
                }

                /// Convert this [`BigInt`] into its [`Sign`] and [`BigUint`] magnitude,
                /// the reverse of [`BigInt::from_biguint()`].
                /// use num_bigint::{BigInt, BigUint, Sign};
                ///
                /// assert_eq!(BigInt::from(1234).into_parts(), (Sign::Plus, BigUint::from(1234u32)));
                /// assert_eq!(BigInt::from(-4321).into_parts(), (Sign::Minus, BigUint::from(4321u32)));
                /// assert_eq!(BigInt::ZERO.into_parts(), (Sign::NoSign, BigUint::ZERO));
                /// ```
                #[inline]
                pub fn into_parts(self) -> (Sign, BigUint) {
                    (self.sign, self.data)
                }

                /// Determines the fewest bits necessary to express the [`BigInt`],
                /// not including the sign.
                #[inline]
                pub fn bits(&self) -> u64 {
                    self.data.bits()
                }

                /// Converts this [`BigInt`] into a [`BigUint`], if it's not negative.
                #[inline]
                pub fn to_biguint(&self) -> Option<BigUint> {
                    match self.sign {
                        Plus => Some(self.data.clone()),
                        NoSign => Some(BigUint::ZERO),
                        Minus => None,
                    }
                }

                #[inline]
                pub fn checked_add(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self + v)
                }

                #[inline]
                pub fn checked_sub(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self - v)
                }

                #[inline]
                pub fn checked_mul(&self, v: &BigInt) -> Option<BigInt> {
                    Some(self * v)
                }

                #[inline]
                pub fn checked_div(&self, v: &BigInt) -> Option<BigInt> {
                    if v.is_zero() {
                        return None;
                    }
                    Some(self / v)
                }

                /// Returns `self ^ exponent`.
                pub fn pow(&self, exponent: u32) -> Self {
                    Pow::pow(self, exponent)
                }

                /// Returns `(self ^ exponent) mod modulus`
                ///
                /// Note that this rounds like `mod_floor`, not like the `%` operator,
                /// which makes a difference when given a negative `self` or `modulus`.
                /// The result will be in the interval `[0, modulus)` for `modulus > 0`,
                /// or in the interval `(modulus, 0]` for `modulus < 0`
                ///
                /// Panics if the exponent is negative or the modulus is zero.
                pub fn modpow(&self, exponent: &Self, modulus: &Self) -> Self {
                    power::modpow(self, exponent, modulus)
                }

                /// Returns the modular multiplicative inverse if it exists, otherwise `None`.
                ///
                /// This solves for `x` such that `self * x ≡ 1 (mod modulus)`.
                /// Note that this rounds like `mod_floor`, not like the `%` operator,
                /// which makes a difference when given a negative `self` or `modulus`.
                /// The solution will be in the interval `[0, modulus)` for `modulus > 0`,
                /// or in the interval `(modulus, 0]` for `modulus < 0`,
                /// and it exists if and only if `gcd(self, modulus) == 1`.
                ///
                /// ```
                /// use num_bigint::BigInt;
                /// use num_integer::Integer;
                /// use num_traits::{One, Zero};
                ///
                /// let m = BigInt::from(383);
                ///
                ///
                /// assert_eq!(BigInt::zero().modinv(&m), None);
                /// assert_eq!(BigInt::one().modinv(&m), Some(BigInt::one()));
                /// let neg1 = &m - 1u32;
                /// assert_eq!(neg1.modinv(&m), Some(neg1));
                ///
                ///
                /// let a = BigInt::from(271);
                /// let x = a.modinv(&m).unwrap();
                /// assert_eq!(x, BigInt::from(106));
                /// assert_eq!(x.modinv(&m).unwrap(), a);
                /// assert_eq!((&a * x).mod_floor(&m), BigInt::one());
                ///
                ///
                /// let b = -&a;
                /// let x = b.modinv(&m).unwrap();
                /// assert_eq!(x, BigInt::from(277));
                /// assert_eq!((&b * x).mod_floor(&m), BigInt::one());
                ///
                ///
                /// let n = -&m;
                /// let x = a.modinv(&n).unwrap();
                /// assert_eq!(x, BigInt::from(-277));
                /// assert_eq!((&a * x).mod_floor(&n), &n + 1);
                ///
                ///
                /// let x = b.modinv(&n).unwrap();
                /// assert_eq!(x, BigInt::from(-106));
                /// assert_eq!((&b * x).mod_floor(&n), &n + 1);
                /// ```
                pub fn modinv(&self, modulus: &Self) -> Option<Self> {
                    let result = self.data.modinv(&modulus.data)?;
                   
                    let (sign, mag) = match (self.is_negative(), modulus.is_negative()) {
                        (false, false) => (Plus, result),
                        (true, false) => (Plus, &modulus.data - result),
                        (false, true) => (Minus, &modulus.data - result),
                        (true, true) => (Minus, result),
                    };
                    Some(BigInt::from_biguint(sign, mag))
                }

                /// Returns the truncated principal square root of `self` --
                /// see [`num_integer::Roots::sqrt()`].
                pub fn sqrt(&self) -> Self {
                    Roots::sqrt(self)
                }

                /// Returns the truncated principal cube root of `self` --
                /// see [`num_integer::Roots::cbrt()`].
                pub fn cbrt(&self) -> Self {
                    Roots::cbrt(self)
                }

                /// Returns the truncated principal `n`th root of `self` --
                /// See [`num_integer::Roots::nth_root()`].
                pub fn nth_root(&self, n: u32) -> Self {
                    Roots::nth_root(self, n)
                }

                /// Returns the number of least-significant bits that are zero,
                /// or `None` if the entire number is zero.
                pub fn trailing_zeros(&self) -> Option<u64> {
                    self.data.trailing_zeros()
                }

                /// Returns whether the bit in position `bit` is set,
                /// using the two's complement for negative numbers
                pub fn bit(&self, bit: u64) -> bool {
                    if self.is_negative() {
                       
                       
                       
                       
                       
                        if bit >= u64::from(crate::big_digit::BITS) * self.len() as u64 {
                            true
                        } else {
                            let trailing_zeros = self.data.trailing_zeros().unwrap();
                            match Ord::cmp(&bit, &trailing_zeros) {
                                Ordering::Less => false,
                                Ordering::Equal => true,
                                Ordering::Greater => !self.data.bit(bit),
                            }
                        }
                    } else {
                        self.data.bit(bit)
                    }
                }

                /// Sets or clears the bit in the given position,
                /// using the two's complement for negative numbers
                ///
                /// Note that setting/clearing a bit (for positive/negative numbers,
                /// respectively) greater than the current bit length, a reallocation
                /// may be needed to store the new digits
                pub fn set_bit(&mut self, bit: u64, value: bool) {
                    match self.sign {
                        Sign::Plus => self.data.set_bit(bit, value),
                        Sign::Minus => bits::set_negative_bit(self, bit, value),
                        Sign::NoSign => {
                            if value {
                                self.data.set_bit(bit, true);
                                self.sign = Sign::Plus;
                            } else {
                               
                            }
                        }
                    }
                   
                    self.normalize();
                }
            }

            impl num_traits::FromBytes for BigInt {
                type Bytes = [u8];

                fn from_be_bytes(bytes: &Self::Bytes) -> Self {
                    Self::from_signed_bytes_be(bytes)
                }

                fn from_le_bytes(bytes: &Self::Bytes) -> Self {
                    Self::from_signed_bytes_le(bytes)
                }
            }

            impl num_traits::ToBytes for BigInt {
                type Bytes = Vec<u8>;

                fn to_be_bytes(&self) -> Self::Bytes {
                    self.to_signed_bytes_be()
                }

                fn to_le_bytes(&self) -> Self::Bytes {
                    self.to_signed_bytes_le()
                }
            }
        }

        pub mod bigrand
        {
            //! Randomization of big integers
            use ::
            {
                num::
                {
                    big::
                    {
                        BigInt, BigUint, Sign::*,
                        biguint::biguint_from_vec,
                    },
                    integers::Integer,
                    traits::{ ToPrimitive, Zero },
                },
                rand::
                {
                    distributions::uniform::{SampleBorrow, SampleUniform, UniformSampler},
                    prelude::*,
                },
                *,
            };
            /*
            */
            /// A trait for sampling random big integers.
            pub trait RandBigInt
            {
                /// Generate a random [`BigUint`] of the given bit size.
                fn gen_biguint(&mut self, bit_size: u64) -> BigUint;

                /// Generate a random [ BigInt`] of the given bit size.
                fn gen_bigint(&mut self, bit_size: u64) -> BigInt;

                /// Generate a random [`BigUint`] less than the given bound. Fails
                /// when the bound is zero.
                fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;

                /// Generate a random [`BigUint`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;

                /// Generate a random [`BigInt`] within the given range. The lower
                /// bound is inclusive; the upper bound is exclusive. Fails when
                /// the upper bound is not greater than the lower bound.
                fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;
            }

            fn gen_bits<R: Rng + ?Sized>(rng: &mut R, data: &mut [u32], rem: u64) {
               
                rng.fill(data);
                if rem > 0 {
                    let last = data.len() - 1;
                    data[last] >>= 32 - rem;
                }
            }

            impl<R: Rng + ?Sized> RandBigInt for R {
                cfg_digit!(
                    fn gen_biguint(&mut self, bit_size: u64) -> BigUint {
                        let (digits, rem) = bit_size.div_rem(&32);
                        let len = (digits + (rem > 0) as u64)
                            .to_usize()
                            .expect("capacity overflow");
                        let mut data = vec![0u32; len];
                        gen_bits(self, &mut data, rem);
                        biguint_from_vec(data)
                    }

                    fn gen_biguint(&mut self, bit_size: u64) -> BigUint {
                        use ::slice;

                        let (digits, rem) = bit_size.div_rem(&32);
                        let len = (digits + (rem > 0) as u64)
                            .to_usize()
                            .expect("capacity overflow");
                        let native_digits = Integer::div_ceil(&bit_size, &64);
                        let native_len = native_digits.to_usize().expect("capacity overflow");
                        let mut data = vec![0u64; native_len];
                        unsafe {
                           
                            let ptr = data.as_mut_ptr() as *mut u32;
                            debug_assert!(native_len * 2 >= len);
                            let data = slice::from_raw_parts_mut(ptr, len);
                            gen_bits(self, data, rem);
                        }
                        #[cfg(target_endian = "big")]
                        for digit in &mut data {
                           
                            *digit = (*digit << 32) | (*digit >> 32);
                        }
                        biguint_from_vec(data)
                    }
                );

                fn gen_bigint(&mut self, bit_size: u64) -> BigInt {
                    loop {
                       
                        let biguint = self.gen_biguint(bit_size);
                       
                        let sign = if biguint.is_zero() {
                           
                           
                           
                           
                            if self.gen() {
                                continue;
                            } else {
                                NoSign
                            }
                        } else if self.gen() {
                            Plus
                        } else {
                            Minus
                        };
                        return BigInt::from_biguint(sign, biguint);
                    }
                }

                fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint {
                    assert!(!bound.is_zero());
                    let bits = bound.bits();
                    loop {
                        let n = self.gen_biguint(bits);
                        if n < *bound {
                            return n;
                        }
                    }
                }

                fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint {
                    assert!(*lbound < *ubound);
                    if lbound.is_zero() {
                        self.gen_biguint_below(ubound)
                    } else {
                        lbound + self.gen_biguint_below(&(ubound - lbound))
                    }
                }

                fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt {
                    assert!(*lbound < *ubound);
                    if lbound.is_zero() {
                        BigInt::from(self.gen_biguint_below(ubound.magnitude()))
                    } else if ubound.is_zero() {
                        lbound + BigInt::from(self.gen_biguint_below(lbound.magnitude()))
                    } else {
                        let delta = ubound - lbound;
                        lbound + BigInt::from(self.gen_biguint_below(delta.magnitude()))
                    }
                }
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigUint`].
            #[derive(Clone, Debug)]
            pub struct UniformBigUint {
                base: BigUint,
                len: BigUint,
            }

            impl UniformSampler for UniformBigUint {
                type X = BigUint;

                #[inline]
                fn new<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low < high);
                    UniformBigUint {
                        len: high - low,
                        base: low.clone(),
                    }
                }

                #[inline]
                fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low <= high);
                    Self::new(low, high + 1u32)
                }

                #[inline]
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
                    &self.base + rng.gen_biguint_below(&self.len)
                }

                #[inline]
                fn sample_single<R: Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_biguint_range(low.borrow(), high.borrow())
                }
            }

            impl SampleUniform for BigUint {
                type Sampler = UniformBigUint;
            }
            /// The back-end implementing rand's [`UniformSampler`] for [`BigInt`].
            #[derive(Clone, Debug)]
            pub struct UniformBigInt {
                base: BigInt,
                len: BigUint,
            }

            impl UniformSampler for UniformBigInt {
                type X = BigInt;

                #[inline]
                fn new<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low < high);
                    UniformBigInt {
                        len: (high - low).into_parts().1,
                        base: low.clone(),
                    }
                }

                #[inline]
                fn new_inclusive<B1, B2>(low_b: B1, high_b: B2) -> Self
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!(low <= high);
                    Self::new(low, high + 1u32)
                }

                #[inline]
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
                    &self.base + BigInt::from(rng.gen_biguint_below(&self.len))
                }

                #[inline]
                fn sample_single<R: Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
                where
                    B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_bigint_range(low.borrow(), high.borrow())
                }
            }

            impl SampleUniform for BigInt {
                type Sampler = UniformBigInt;
            }
            /// A random distribution for [`BigUint`] and [`BigInt`] values of a particular bit size.
            #[derive(Clone, Copy, Debug)]
            pub struct RandomBits {
                bits: u64,
            }

            impl RandomBits {
                #[inline]
                pub fn new(bits: u64) -> RandomBits {
                    RandomBits { bits }
                }
            }

            impl Distribution<BigUint> for RandomBits {
                #[inline]
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> BigUint {
                    rng.gen_biguint(self.bits)
                }
            }

            impl Distribution<BigInt> for RandomBits {
                #[inline]
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> BigInt {
                    rng.gen_bigint(self.bits)
                }
            }

        }

        pub mod biguint
        {
            use ::
            {
                cmp::{ self, Ordering },
                default::{ Default },
                num::
                {
                    big::big_digit::{self, BigDigit},
                    integers::{Integer, Roots},
                    traits::{ConstZero, Num, One, Pow, ToPrimitive, Unsigned, Zero},
                },
                string::{ String },
                vec::{ Vec },
                *,
            };
            /*
            */
            pub use self::convert::to_str_radix_reversed;
            pub use self::iter::{U32Digits, U64Digits};
            pub mod addition
            {
                /*!
                */
                use ::
                {
                    iter::{ Sum },
                    num::
                    {
                        big::
                        {
                            big_digit::{self, BigDigit}, UsizePromotion
                        },
                        traits::CheckedAdd,
                    },
                    ops::{ Add, AddAssign },
                    *,
                };

                use super::{BigUint, IntDigits};
                /*
                */
                use ::arch::x86_64 as arch;
                
                cfg_64!(
                    #[inline]
                    fn adc(carry: u8, a: u64, b: u64, out: &mut u64) -> u8 {
                       
                       
                        unsafe { arch::_addcarry_u64(carry, a, b, out) }
                    }
                );
                /// Two argument addition of raw slices, `a += b`, returning the carry.
                ///
                /// This is used when the data `Vec` might need to resize to push a non-zero carry, so we perform
                /// the addition first hoping that it will fit.
                ///
                /// The caller _must_ ensure that `a` is at least as long as `b`.
                #[inline]
                pub(super) fn __add2(a: &mut [BigDigit], b: &[BigDigit]) -> BigDigit {
                    debug_assert!(a.len() >= b.len());

                    let mut carry = 0;
                    let (a_lo, a_hi) = a.split_at_mut(b.len());

                    for (a, b) in a_lo.iter_mut().zip(b) {
                        carry = adc(carry, *a, *b, a);
                    }

                    if carry != 0 {
                        for a in a_hi {
                            carry = adc(carry, *a, 0, a);
                            if carry == 0 {
                                break;
                            }
                        }
                    }

                    carry as BigDigit
                }

                /// Two argument addition of raw slices:
                /// a += b
                ///
                /// The caller _must_ ensure that a is big enough to store the result - typically this means
                /// resizing a to max(a.len(), b.len()) + 1, to fit a possible carry.
                pub(super) fn add2(a: &mut [BigDigit], b: &[BigDigit]) {
                    let carry = __add2(a, b);

                    debug_assert!(carry == 0);
                }

                forward_all_binop_to_val_ref_commutative!(impl Add for BigUint, add);
                forward_val_assign!(impl AddAssign for BigUint, add_assign);

                impl Add<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn add(mut self, other: &BigUint) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<&BigUint> for BigUint {
                    #[inline]
                    fn add_assign(&mut self, other: &BigUint) {
                        let self_len = self.data.len();
                        let carry = if self_len < other.data.len() {
                            let lo_carry = __add2(&mut self.data[..], &other.data[..self_len]);
                            self.data.extend_from_slice(&other.data[self_len..]);
                            __add2(&mut self.data[self_len..], &[lo_carry])
                        } else {
                            __add2(&mut self.data[..], &other.data[..])
                        };
                        if carry != 0 {
                            self.data.push(carry);
                        }
                    }
                }

                promote_unsigned_scalars!(impl Add for BigUint, add);
                promote_unsigned_scalars_assign!(impl AddAssign for BigUint, add_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u32> for BigUint, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u64> for BigUint, add);
                forward_all_scalar_binop_to_val_val_commutative!(impl Add<u128> for BigUint, add);

                impl Add<u32> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn add(mut self, other: u32) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u32> for BigUint {
                    #[inline]
                    fn add_assign(&mut self, other: u32) {
                        if other != 0 {
                            if self.data.is_empty() {
                                self.data.push(0);
                            }

                            let carry = __add2(&mut self.data, &[other as BigDigit]);
                            if carry != 0 {
                                self.data.push(carry);
                            }
                        }
                    }
                }

                impl Add<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn add(mut self, other: u64) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn add_assign(&mut self, other: u64) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[lo, hi]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }

                        #[inline]
                        fn add_assign(&mut self, other: u64) {
                            if other != 0 {
                                if self.data.is_empty() {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[other as BigDigit]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }
                    );
                }

                impl Add<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn add(mut self, other: u128) -> BigUint {
                        self += other;
                        self
                    }
                }

                impl AddAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn add_assign(&mut self, other: u128) {
                            if other <= u128::from(u64::MAX) {
                                *self += other as u64
                            } else {
                                let (a, b, c, d) = super::u32_from_u128(other);
                                let carry = if a > 0 {
                                    while self.data.len() < 4 {
                                        self.data.push(0);
                                    }
                                    __add2(&mut self.data, &[d, c, b, a])
                                } else {
                                    debug_assert!(b > 0);
                                    while self.data.len() < 3 {
                                        self.data.push(0);
                                    }
                                    __add2(&mut self.data, &[d, c, b])
                                };

                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }

                        #[inline]
                        fn add_assign(&mut self, other: u128) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push(0);
                                }

                                let carry = __add2(&mut self.data, &[lo, hi]);
                                if carry != 0 {
                                    self.data.push(carry);
                                }
                            }
                        }
                    );
                }

                impl CheckedAdd for BigUint {
                    #[inline]
                    fn checked_add(&self, v: &BigUint) -> Option<BigUint> {
                        Some(self.add(v))
                    }
                }

                impl_sum_iter_type!(BigUint);

            }

            pub mod division
            {
                /*!
                */
                use ::
                {
                    cmp::Ordering::{Equal, Greater, Less},
                    num::
                    {
                        big::
                        {
                            big_digit::{self, BigDigit, DoubleBigDigit}, UsizePromotion
                        },
                        integers::Integer,
                        traits::{CheckedDiv, CheckedEuclid, Euclid, One, ToPrimitive, Zero},
                    },
                    ops::{Div, DivAssign, Rem, RemAssign},
                    *,
                };
                
                use super::addition::__add2;
                use super::{cmp_slice, BigUint};
                /*
                */
                pub(super) const FAST_DIV_WIDE: bool = cfg!(any(target_arch = "x86", target_arch = "x86_64"));

                /// Divide a two digit numerator by a one digit divisor, returns quotient and remainder:
                ///
                /// Note: the caller must ensure that both the quotient and remainder will fit into a single digit.
                /// This is _not_ true for an arbitrary numerator/denominator.
                ///
                /// (This function also matches what the x86 divide instruction does).
                #[cfg(any(miri, not(any(target_arch = "x86", target_arch = "x86_64"))))]
                #[inline]
                fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
                    debug_assert!(hi < divisor);

                    let lhs = big_digit::to_doublebigdigit(hi, lo);
                    let rhs = DoubleBigDigit::from(divisor);
                    ((lhs / rhs) as BigDigit, (lhs % rhs) as BigDigit)
                }

                /// x86 and x86_64 can use a real `div` instruction.
                #[cfg(all(not(miri), any(target_arch = "x86", target_arch = "x86_64")))]
                #[inline]
                fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
                   
                   
                   
                    debug_assert!(hi < divisor);

                   
                   
                   
                   
                    unsafe {
                        let (div, rem);

                        cfg_digit!(
                            macro_rules! div {
                                () => {
                                    "div {0:e}"
                                };
                            }
                            macro_rules! div {
                                () => {
                                    "div {0:r}"
                                };
                            }
                        );

                        ::arch::asm!(
                            div!(),
                            in(reg) divisor,
                            inout("dx") hi => rem,
                            inout("ax") lo => div,
                            options(pure, nomem, nostack),
                        );

                        (div, rem)
                    }
                }

                /// For small divisors, we can divide without promoting to `DoubleBigDigit` by
                /// using half-size pieces of digit, like long-division.
                #[inline]
                fn div_half(rem: BigDigit, digit: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
                    use ::num::big::big_digit::{HALF, HALF_BITS};

                    debug_assert!(rem < divisor && divisor <= HALF);
                    let (hi, rem) = ((rem << HALF_BITS) | (digit >> HALF_BITS)).div_rem(&divisor);
                    let (lo, rem) = ((rem << HALF_BITS) | (digit & HALF)).div_rem(&divisor);
                    ((hi << HALF_BITS) | lo, rem)
                }

                #[inline]
                pub(super) fn div_rem_digit(mut a: BigUint, b: BigDigit) -> (BigUint, BigDigit) {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= big_digit::HALF {
                        for d in a.data.iter_mut().rev() {
                            let (q, r) = div_half(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    } else {
                        for d in a.data.iter_mut().rev() {
                            let (q, r) = div_wide(rem, *d, b);
                            *d = q;
                            rem = r;
                        }
                    }

                    (a.normalized(), rem)
                }

                #[inline]
                fn rem_digit(a: &BigUint, b: BigDigit) -> BigDigit {
                    if b == 0 {
                        panic!("attempt to divide by zero")
                    }

                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= big_digit::HALF {
                        for &digit in a.data.iter().rev() {
                            let (_, r) = div_half(rem, digit, b);
                            rem = r;
                        }
                    } else {
                        for &digit in a.data.iter().rev() {
                            let (_, r) = div_wide(rem, digit, b);
                            rem = r;
                        }
                    }

                    rem
                }

                /// Subtract a multiple.
                /// a -= b * c
                /// Returns a borrow (if a < b then borrow > 0).
                fn sub_mul_digit_same_len(a: &mut [BigDigit], b: &[BigDigit], c: BigDigit) -> BigDigit {
                    debug_assert!(a.len() == b.len());

                   
                   
                    let mut offset_carry = big_digit::MAX;

                    for (x, y) in a.iter_mut().zip(b) {
                       
                       
                       
                       
                        let offset_sum = big_digit::to_doublebigdigit(big_digit::MAX, *x)
                            - big_digit::MAX as DoubleBigDigit
                            + offset_carry as DoubleBigDigit
                            - *y as DoubleBigDigit * c as DoubleBigDigit;

                        let (new_offset_carry, new_x) = big_digit::from_doublebigdigit(offset_sum);
                        offset_carry = new_offset_carry;
                        *x = new_x;
                    }

                   
                    big_digit::MAX - offset_carry
                }

                fn div_rem(mut u: BigUint, mut d: BigUint) -> (BigUint, BigUint) {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u, BigUint::ZERO);
                        }
                        let (div, rem) = div_rem_digit(u, d.data[0]);
                       
                        d.data.clear();
                        d += rem;
                        return (div, d);
                    }

                   
                    match u.cmp(&d) {
                        Less => return (BigUint::ZERO, u),
                        Equal => {
                            u.set_one();
                            return (u, BigUint::ZERO);
                        }
                        Greater => {}
                    }

                   
                    //
                   
                   
                   
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                       
                        div_rem_core(u, &d.data)
                    } else {
                        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
                       
                        (q, r >> shift)
                    }
                }

                pub(super) fn div_rem_ref(u: &BigUint, d: &BigUint) -> (BigUint, BigUint) {
                    if d.is_zero() {
                        panic!("attempt to divide by zero")
                    }
                    if u.is_zero() {
                        return (BigUint::ZERO, BigUint::ZERO);
                    }

                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return (u.clone(), BigUint::ZERO);
                        }

                        let (div, rem) = div_rem_digit(u.clone(), d.data[0]);
                        return (div, rem.into());
                    }

                   
                    match u.cmp(d) {
                        Less => return (BigUint::ZERO, u.clone()),
                        Equal => return (One::one(), BigUint::ZERO),
                        Greater => {}
                    }

                   
                    //
                   
                   
                   
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                       
                        div_rem_core(u.clone(), &d.data)
                    } else {
                        let (q, r) = div_rem_core(u << shift, &(d << shift).data);
                       
                        (q, r >> shift)
                    }
                }

                /// An implementation of the base division algorithm.
                /// Knuth, TAOCP vol 2 section 4.3.1, algorithm D, with an improvement from exercises 19-21.
                fn div_rem_core(mut a: BigUint, b: &[BigDigit]) -> (BigUint, BigUint) {
                    debug_assert!(a.data.len() >= b.len() && b.len() > 1);
                    debug_assert!(b.last().unwrap().leading_zeros() == 0);

                   
                   
                    //
                   
                   
                    //
                   
                    //
                   
                   
                   
                   
                    //
                   
                   
                   

                   
                    let mut a0 = 0;

                   
                    let b0 = b[b.len() - 1];
                    let b1 = b[b.len() - 2];

                    let q_len = a.data.len() - b.len() + 1;
                    let mut q = BigUint {
                        data: vec![0; q_len],
                    };

                    for j in (0..q_len).rev() {
                        debug_assert!(a.data.len() == b.len() + j);

                        let a1 = *a.data.last().unwrap();
                        let a2 = a.data[a.data.len() - 2];

                       
                       
                        let (mut q0, mut r) = if a0 < b0 {
                            let (q0, r) = div_wide(a0, a1, b0);
                            (q0, r as DoubleBigDigit)
                        } else {
                            debug_assert!(a0 == b0);
                           
                           
                            (big_digit::MAX, a0 as DoubleBigDigit + a1 as DoubleBigDigit)
                        };

                       
                        //
                       
                       
                        //
                       
                       
                       
                        while r <= big_digit::MAX as DoubleBigDigit
                            && big_digit::to_doublebigdigit(r as BigDigit, a2)
                                < q0 as DoubleBigDigit * b1 as DoubleBigDigit
                        {
                            q0 -= 1;
                            r += b0 as DoubleBigDigit;
                        }

                       
                       

                        let mut borrow = sub_mul_digit_same_len(&mut a.data[j..], b, q0);
                        if borrow > a0 {
                           
                            q0 -= 1;
                            borrow -= __add2(&mut a.data[j..], b);
                        }
                       
                        debug_assert!(borrow == a0);

                        q.data[j] = q0;

                       
                        a0 = a.data.pop().unwrap();
                    }

                    a.data.push(a0);
                    a.normalize();

                    debug_assert_eq!(cmp_slice(&a.data, b), Less);

                    (q.normalized(), a)
                }

                forward_val_ref_binop!(impl Div for BigUint, div);
                forward_ref_val_binop!(impl Div for BigUint, div);
                forward_val_assign!(impl DivAssign for BigUint, div_assign);

                impl Div<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: BigUint) -> BigUint {
                        let (q, _) = div_rem(self, other);
                        q
                    }
                }

                impl Div<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: &BigUint) -> BigUint {
                        let (q, _) = self.div_rem(other);
                        q
                    }
                }
                impl DivAssign<&BigUint> for BigUint {
                    #[inline]
                    fn div_assign(&mut self, other: &BigUint) {
                        *self = &*self / other;
                    }
                }

                promote_unsigned_scalars!(impl Div for BigUint, div);
                promote_unsigned_scalars_assign!(impl DivAssign for BigUint, div_assign);
                forward_all_scalar_binop_to_val_val!(impl Div<u32> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u64> for BigUint, div);
                forward_all_scalar_binop_to_val_val!(impl Div<u128> for BigUint, div);

                impl Div<u32> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: u32) -> BigUint {
                        let (q, _) = div_rem_digit(self, other as BigDigit);
                        q
                    }
                }
                impl DivAssign<u32> for BigUint {
                    #[inline]
                    fn div_assign(&mut self, other: u32) {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u32 {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: BigUint) -> BigUint {
                        match other.data.len() {
                            0 => panic!("attempt to divide by zero"),
                            1 => From::from(self as BigDigit / other.data[0]),
                            _ => BigUint::ZERO,
                        }
                    }
                }

                impl Div<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: u64) -> BigUint {
                        let (q, _) = div_rem(self, From::from(other));
                        q
                    }
                }
                impl DivAssign<u64> for BigUint {
                    #[inline]
                    fn div_assign(&mut self, other: u64) {
                       
                        let temp = mem::replace(self, Self::ZERO);
                        *self = temp / other;
                    }
                }

                impl Div<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u64::from(other.data[0])),
                                2 => From::from(self / big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline]
                        fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0]),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                impl Div<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn div(self, other: u128) -> BigUint {
                        let (q, _) = div_rem(self, From::from(other));
                        q
                    }
                }

                impl DivAssign<u128> for BigUint {
                    #[inline]
                    fn div_assign(&mut self, other: u128) {
                        *self = &*self / other;
                    }
                }

                impl Div<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn div(self, other: BigUint) -> BigUint {
                            use super::u32_to_u128;
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / u128::from(other.data[0])),
                                2 => From::from(
                                    self / u128::from(big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                ),
                                3 => From::from(self / u32_to_u128(0, other.data[2], other.data[1], other.data[0])),
                                4 => From::from(
                                    self / u32_to_u128(other.data[3], other.data[2], other.data[1], other.data[0]),
                                ),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline]
                        fn div(self, other: BigUint) -> BigUint {
                            match other.data.len() {
                                0 => panic!("attempt to divide by zero"),
                                1 => From::from(self / other.data[0] as u128),
                                2 => From::from(self / big_digit::to_doublebigdigit(other.data[1], other.data[0])),
                                _ => BigUint::ZERO,
                            }
                        }
                    );
                }

                forward_val_ref_binop!(impl Rem for BigUint, rem);
                forward_ref_val_binop!(impl Rem for BigUint, rem);
                forward_val_assign!(impl RemAssign for BigUint, rem_assign);

                impl Rem<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: BigUint) -> BigUint {
                        if let Some(other) = other.to_u32() {
                            &self % other
                        } else {
                            let (_, r) = div_rem(self, other);
                            r
                        }
                    }
                }

                impl Rem<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: &BigUint) -> BigUint {
                        if let Some(other) = other.to_u32() {
                            self % other
                        } else {
                            let (_, r) = self.div_rem(other);
                            r
                        }
                    }
                }
                impl RemAssign<&BigUint> for BigUint {
                    #[inline]
                    fn rem_assign(&mut self, other: &BigUint) {
                        *self = &*self % other;
                    }
                }

                promote_unsigned_scalars!(impl Rem for BigUint, rem);
                promote_unsigned_scalars_assign!(impl RemAssign for BigUint, rem_assign);
                forward_all_scalar_binop_to_ref_val!(impl Rem<u32> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u64> for BigUint, rem);
                forward_all_scalar_binop_to_val_val!(impl Rem<u128> for BigUint, rem);

                impl Rem<u32> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: u32) -> BigUint {
                        rem_digit(self, other as BigDigit).into()
                    }
                }
                impl RemAssign<u32> for BigUint {
                    #[inline]
                    fn rem_assign(&mut self, other: u32) {
                        *self = &*self % other;
                    }
                }

                impl Rem<&BigUint> for u32 {
                    type Output = BigUint;

                    #[inline]
                    fn rem(mut self, other: &BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                macro_rules! impl_rem_assign_scalar {
                    ($scalar:ty, $to_scalar:ident) => {
                        forward_val_assign_scalar!(impl RemAssign for BigUint, $scalar, rem_assign);
                        impl RemAssign<&BigUint> for $scalar {
                            #[inline]
                            fn rem_assign(&mut self, other: &BigUint) {
                                *self = match other.$to_scalar() {
                                    None => *self,
                                    Some(0) => panic!("attempt to divide by zero"),
                                    Some(v) => *self % v
                                };
                            }
                        }
                    }
                }

               
                impl_rem_assign_scalar!(u128, to_u128);
                impl_rem_assign_scalar!(usize, to_usize);
                impl_rem_assign_scalar!(u64, to_u64);
                impl_rem_assign_scalar!(u32, to_u32);
                impl_rem_assign_scalar!(u16, to_u16);
                impl_rem_assign_scalar!(u8, to_u8);
                impl_rem_assign_scalar!(i128, to_i128);
                impl_rem_assign_scalar!(isize, to_isize);
                impl_rem_assign_scalar!(i64, to_i64);
                impl_rem_assign_scalar!(i32, to_i32);
                impl_rem_assign_scalar!(i16, to_i16);
                impl_rem_assign_scalar!(i8, to_i8);

                impl Rem<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: u64) -> BigUint {
                        let (_, r) = div_rem(self, From::from(other));
                        r
                    }
                }
                impl RemAssign<u64> for BigUint {
                    #[inline]
                    fn rem_assign(&mut self, other: u64) {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u64 {
                    type Output = BigUint;

                    #[inline]
                    fn rem(mut self, other: BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                impl Rem<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn rem(self, other: u128) -> BigUint {
                        let (_, r) = div_rem(self, From::from(other));
                        r
                    }
                }

                impl RemAssign<u128> for BigUint {
                    #[inline]
                    fn rem_assign(&mut self, other: u128) {
                        *self = &*self % other;
                    }
                }

                impl Rem<BigUint> for u128 {
                    type Output = BigUint;

                    #[inline]
                    fn rem(mut self, other: BigUint) -> BigUint {
                        self %= other;
                        From::from(self)
                    }
                }

                impl CheckedDiv for BigUint {
                    #[inline]
                    fn checked_div(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div(v))
                    }
                }

                impl CheckedEuclid for BigUint {
                    #[inline]
                    fn checked_div_euclid(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.div_euclid(v))
                    }

                    #[inline]
                    fn checked_rem_euclid(&self, v: &BigUint) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some(self.rem_euclid(v))
                    }

                    fn checked_div_rem_euclid(&self, v: &Self) -> Option<(Self, Self)> {
                        Some(self.div_rem_euclid(v))
                    }
                }

                impl Euclid for BigUint {
                    #[inline]
                    fn div_euclid(&self, v: &BigUint) -> BigUint {
                       
                        self / v
                    }

                    #[inline]
                    fn rem_euclid(&self, v: &BigUint) -> BigUint {
                       
                        self % v
                    }

                    fn div_rem_euclid(&self, v: &Self) -> (Self, Self) {
                       
                        self.div_rem(v)
                    }
                }

            }

            pub mod multiplication
            {
                /*!
                */
                use ::
                {
                    cmp::{ Ordering },
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            big_digit::{self, BigDigit, DoubleBigDigit},
                            Sign::{self, Minus, NoSign, Plus},
                            {BigInt, UsizePromotion},
                        },
                        traits::{ CheckedMul, FromPrimitive, One, Zero },
                    },
                    ops::{Mul, MulAssign},
                    *,
                };
                use super::addition::{__add2, add2};
                use super::subtraction::sub2;
                use super::{biguint_from_vec, cmp_slice, BigUint, IntDigits};
                /*
                */
                #[inline]
                pub(super) fn mac_with_carry(
                    a: BigDigit,
                    b: BigDigit,
                    c: BigDigit,
                    acc: &mut DoubleBigDigit,
                ) -> BigDigit {
                    *acc += DoubleBigDigit::from(a);
                    *acc += DoubleBigDigit::from(b) * DoubleBigDigit::from(c);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }

                #[inline]
                fn mul_with_carry(a: BigDigit, b: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
                    *acc += DoubleBigDigit::from(a) * DoubleBigDigit::from(b);
                    let lo = *acc as BigDigit;
                    *acc >>= big_digit::BITS;
                    lo
                }

                /// Three argument multiply accumulate:
                /// acc += b * c
                fn mac_digit(acc: &mut [BigDigit], b: &[BigDigit], c: BigDigit) {
                    if c == 0 {
                        return;
                    }

                    let mut carry = 0;
                    let (a_lo, a_hi) = acc.split_at_mut(b.len());

                    for (a, &b) in a_lo.iter_mut().zip(b) {
                        *a = mac_with_carry(*a, b, c, &mut carry);
                    }

                    let (carry_hi, carry_lo) = big_digit::from_doublebigdigit(carry);

                    let final_carry = if carry_hi == 0 {
                        __add2(a_hi, &[carry_lo])
                    } else {
                        __add2(a_hi, &[carry_hi, carry_lo])
                    };
                    assert_eq!(final_carry, 0, "carry overflow during multiplication!");
                }

                fn bigint_from_slice(slice: &[BigDigit]) -> BigInt {
                    BigInt::from(biguint_from_vec(slice.to_vec()))
                }

                /// Three argument multiply accumulate:
                /// acc += b * c
                #[allow(clippy::many_single_char_names)]
                fn mac3(mut acc: &mut [BigDigit], mut b: &[BigDigit], mut c: &[BigDigit]) {
                   
                    if let Some(&0) = b.first() {
                        if let Some(nz) = b.iter().position(|&d| d != 0) {
                            b = &b[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }
                    if let Some(&0) = c.first() {
                        if let Some(nz) = c.iter().position(|&d| d != 0) {
                            c = &c[nz..];
                            acc = &mut acc[nz..];
                        } else {
                            return;
                        }
                    }

                    let acc = acc;
                    let (x, y) = if b.len() < c.len() { (b, c) } else { (c, b) };

                   
                    //
                   
                   
                   
                   
                   
                   
                    //
                   
                   

                    if x.len() <= 32 {
                       
                        for (i, xi) in x.iter().enumerate() {
                            mac_digit(&mut acc[i..], y, *xi);
                        }
                    } else if x.len() * 2 <= y.len() {
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                       
                        //
                       
                        //
                       
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                       
                        let m2 = y.len() / 2;
                        let (low2, high2) = y.split_at(m2);

                       
                        mac3(acc, x, low2);
                        mac3(&mut acc[m2..], x, high2);
                    } else if x.len() <= 256 {
                       
                        //
                       
                       
                        //
                       
                       
                        //
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                       

                       
                       
                        let b = x.len() / 2;
                        let (x0, x1) = x.split_at(b);
                        let (y0, y1) = y.split_at(b);

                       
                       
                        let len = x1.len() + y1.len() + 1;
                        let mut p = BigUint { data: vec![0; len] };

                       
                        mac3(&mut p.data, x1, y1);

                       
                        p.normalize();

                        add2(&mut acc[b..], &p.data);
                        add2(&mut acc[b * 2..], &p.data);

                       
                        p.data.truncate(0);
                        p.data.resize(len, 0);

                       
                        mac3(&mut p.data, x0, y0);
                        p.normalize();

                        add2(acc, &p.data);
                        add2(&mut acc[b..], &p.data);

                       
                       
                        let (j0_sign, j0) = sub_sign(x1, x0);
                        let (j1_sign, j1) = sub_sign(y1, y0);

                        match j0_sign * j1_sign {
                            Plus => {
                                p.data.truncate(0);
                                p.data.resize(len, 0);

                                mac3(&mut p.data, &j0.data, &j1.data);
                                p.normalize();

                                sub2(&mut acc[b..], &p.data);
                            }
                            Minus => {
                                mac3(&mut acc[b..], &j0.data, &j1.data);
                            }
                            NoSign => (),
                        }
                    } else {
                       
                        //
                       
                       
                        //
                       
                       
                       
                        let i = y.len() / 3 + 1;

                        let x0_len = Ord::min(x.len(), i);
                        let x1_len = Ord::min(x.len() - x0_len, i);

                        let y0_len = i;
                        let y1_len = Ord::min(y.len() - y0_len, i);

                       
                       
                       
                        //
                       
                        let x0 = bigint_from_slice(&x[..x0_len]);
                        let x1 = bigint_from_slice(&x[x0_len..x0_len + x1_len]);
                        let x2 = bigint_from_slice(&x[x0_len + x1_len..]);

                       
                        let y0 = bigint_from_slice(&y[..y0_len]);
                        let y1 = bigint_from_slice(&y[y0_len..y0_len + y1_len]);
                        let y2 = bigint_from_slice(&y[y0_len + y1_len..]);

                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                       
                       

                       
                        let p = &x0 + &x2;

                       
                        let q = &y0 + &y2;

                       
                        let p2 = &p - &x1;

                       
                        let q2 = &q - &y1;

                       
                        let r0 = &x0 * &y0;

                       
                        let r4 = &x2 * &y2;

                       
                        let r1 = (p + x1) * (q + y1);

                       
                        let r2 = &p2 * &q2;

                       
                        let r3 = ((p2 + x2) * 2 - x0) * ((q2 + y2) * 2 - y0);

                       
                        //
                       
                       
                       
                       
                       
                        //
                       
                       
                        //
                       
                       
                       
                       
                       
                        //
                       
                       
                        let mut comp3: BigInt = (r3 - &r1) / 3u32;
                        let mut comp1: BigInt = (r1 - &r2) >> 1;
                        let mut comp2: BigInt = r2 - &r0;
                        comp3 = ((&comp2 - comp3) >> 1) + (&r4 << 1);
                        comp2 += &comp1 - &r4;
                        comp1 -= &comp3;

                       
                        //
                       
                        //
                       
                       
                       
                       
                       
                       
                       
                       
                        //
                       
                        for (j, result) in [&r0, &comp1, &comp2, &comp3, &r4].iter().enumerate().rev() {
                            match result.sign() {
                                Plus => add2(&mut acc[i * j..], result.digits()),
                                Minus => sub2(&mut acc[i * j..], result.digits()),
                                NoSign => {}
                            }
                        }
                    }
                }

                fn mul3(x: &[BigDigit], y: &[BigDigit]) -> BigUint {
                    let len = x.len() + y.len() + 1;
                    let mut prod = BigUint { data: vec![0; len] };

                    mac3(&mut prod.data, x, y);
                    prod.normalized()
                }

                fn scalar_mul(a: &mut BigUint, b: BigDigit) {
                    match b {
                        0 => a.set_zero(),
                        1 => {}
                        _ => {
                            if b.is_power_of_two() {
                                *a <<= b.trailing_zeros();
                            } else {
                                let mut carry = 0;
                                for a in a.data.iter_mut() {
                                    *a = mul_with_carry(*a, b, &mut carry);
                                }
                                if carry != 0 {
                                    a.data.push(carry as BigDigit);
                                }
                            }
                        }
                    }
                }

                fn sub_sign(mut a: &[BigDigit], mut b: &[BigDigit]) -> (Sign, BigUint) {
                   
                    if let Some(&0) = a.last() {
                        a = &a[..a.iter().rposition(|&x| x != 0).map_or(0, |i| i + 1)];
                    }
                    if let Some(&0) = b.last() {
                        b = &b[..b.iter().rposition(|&x| x != 0).map_or(0, |i| i + 1)];
                    }

                    match cmp_slice(a, b) {
                        Ordering::Greater => {
                            let mut a = a.to_vec();
                            sub2(&mut a, b);
                            (Plus, biguint_from_vec(a))
                        }
                        Ordering::Less => {
                            let mut b = b.to_vec();
                            sub2(&mut b, a);
                            (Minus, biguint_from_vec(b))
                        }
                        Ordering::Equal => (NoSign, BigUint::ZERO),
                    }
                }

                macro_rules! impl_mul {
                    ($(impl Mul<$Other:ty> for $Self:ty;)*) => {$(
                        impl Mul<$Other> for $Self {
                            type Output = BigUint;

                            #[inline]
                            fn mul(self, other: $Other) -> BigUint {
                                match (&*self.data, &*other.data) {
                                   
                                    (&[], _) | (_, &[]) => BigUint::ZERO,
                                   
                                    (_, &[digit]) => self * digit,
                                    (&[digit], _) => other * digit,
                                   
                                    (x, y) => mul3(x, y),
                                }
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigUint> for BigUint;
                    impl Mul<BigUint> for &BigUint;
                    impl Mul<&BigUint> for BigUint;
                    impl Mul<&BigUint> for &BigUint;
                }

                macro_rules! impl_mul_assign {
                    ($(impl MulAssign<$Other:ty> for BigUint;)*) => {$(
                        impl MulAssign<$Other> for BigUint {
                            #[inline]
                            fn mul_assign(&mut self, other: $Other) {
                                match (&*self.data, &*other.data) {
                                   
                                    (&[], _) => {},
                                    (_, &[]) => self.set_zero(),
                                   
                                    (_, &[digit]) => *self *= digit,
                                    (&[digit], _) => *self = other * digit,
                                   
                                    (x, y) => *self = mul3(x, y),
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigUint> for BigUint;
                    impl MulAssign<&BigUint> for BigUint;
                }

                promote_unsigned_scalars!(impl Mul for BigUint, mul);
                promote_unsigned_scalars_assign!(impl MulAssign for BigUint, mul_assign);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u32> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u64> for BigUint, mul);
                forward_all_scalar_binop_to_val_val_commutative!(impl Mul<u128> for BigUint, mul);

                impl Mul<u32> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn mul(mut self, other: u32) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u32> for BigUint {
                    #[inline]
                    fn mul_assign(&mut self, other: u32) {
                        scalar_mul(self, other as BigDigit);
                    }
                }

                impl Mul<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn mul(mut self, other: u64) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn mul_assign(&mut self, other: u64) {
                            if let Some(other) = BigDigit::from_u64(other) {
                                scalar_mul(self, other);
                            } else {
                                let (hi, lo) = big_digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }

                        #[inline]
                        fn mul_assign(&mut self, other: u64) {
                            scalar_mul(self, other);
                        }
                    );
                }

                impl Mul<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn mul(mut self, other: u128) -> BigUint {
                        self *= other;
                        self
                    }
                }

                impl MulAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn mul_assign(&mut self, other: u128) {
                            if let Some(other) = BigDigit::from_u128(other) {
                                scalar_mul(self, other);
                            } else {
                                *self = match super::u32_from_u128(other) {
                                    (0, 0, c, d) => mul3(&self.data, &[d, c]),
                                    (0, b, c, d) => mul3(&self.data, &[d, c, b]),
                                    (a, b, c, d) => mul3(&self.data, &[d, c, b, a]),
                                };
                            }
                        }

                        #[inline]
                        fn mul_assign(&mut self, other: u128) {
                            if let Some(other) = BigDigit::from_u128(other) {
                                scalar_mul(self, other);
                            } else {
                                let (hi, lo) = big_digit::from_doublebigdigit(other);
                                *self = mul3(&self.data, &[lo, hi]);
                            }
                        }
                    );
                }

                impl CheckedMul for BigUint {
                    #[inline]
                    fn checked_mul(&self, v: &BigUint) -> Option<BigUint> {
                        Some(self.mul(v))
                    }
                }

                impl_product_iter_type!(BigUint);
            }

            pub mod subtraction
            {
                /*!
                */
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    num::
                    {
                        big::
                        {
                            big_digit::{self, BigDigit}, UsizePromotion
                        },
                        traits::{ CheckedSub },
                    },
                    ops::{ Sub, SubAssign },
                    *,
                };
                
                use super::BigUint;
                /*
                */
                #[cfg(target_arch = "x86_64")]
                use ::arch::x86_64 as arch;

                #[cfg(target_arch = "x86")]
                use ::arch::x86 as arch;

                #[cfg(target_arch = "x86_64")]
                cfg_64!(
                    #[inline]
                    fn sbb(borrow: u8, a: u64, b: u64, out: &mut u64) -> u8 {
                       
                       
                        unsafe { arch::_subborrow_u64(borrow, a, b, out) }
                    }
                );

                #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
                cfg_32!(
                    #[inline]
                    fn sbb(borrow: u8, a: u32, b: u32, out: &mut u32) -> u8 {
                       
                       
                        unsafe { arch::_subborrow_u32(borrow, a, b, out) }
                    }
                );
                
                pub(super) fn sub2(a: &mut [BigDigit], b: &[BigDigit]) {
                    let mut borrow = 0;

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi) = a.split_at_mut(len);
                    let (b_lo, b_hi) = b.split_at(len);

                    for (a, b) in a_lo.iter_mut().zip(b_lo) {
                        borrow = sbb(borrow, *a, *b, a);
                    }

                    if borrow != 0 {
                        for a in a_hi {
                            borrow = sbb(borrow, *a, 0, a);
                            if borrow == 0 {
                                break;
                            }
                        }
                    }

                   
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }

               
                #[inline]
                fn __sub2rev(a: &[BigDigit], b: &mut [BigDigit]) -> u8 {
                    debug_assert!(b.len() == a.len());

                    let mut borrow = 0;

                    for (ai, bi) in a.iter().zip(b) {
                        borrow = sbb(borrow, *ai, *bi, bi);
                    }

                    borrow
                }

                fn sub2rev(a: &[BigDigit], b: &mut [BigDigit]) {
                    debug_assert!(b.len() >= a.len());

                    let len = Ord::min(a.len(), b.len());
                    let (a_lo, a_hi) = a.split_at(len);
                    let (b_lo, b_hi) = b.split_at_mut(len);

                    let borrow = __sub2rev(a_lo, b_lo);

                    assert!(a_hi.is_empty());

                   
                    assert!(
                        borrow == 0 && b_hi.iter().all(|x| *x == 0),
                        "Cannot subtract b from a because b is larger than a."
                    );
                }

                forward_val_val_binop!(impl Sub for BigUint, sub);
                forward_ref_ref_binop!(impl Sub for BigUint, sub);
                forward_val_assign!(impl SubAssign for BigUint, sub_assign);

                impl Sub<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn sub(mut self, other: &BigUint) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<&BigUint> for BigUint {
                    fn sub_assign(&mut self, other: &BigUint) {
                        sub2(&mut self.data[..], &other.data[..]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for &BigUint {
                    type Output = BigUint;

                    fn sub(self, mut other: BigUint) -> BigUint {
                        let other_len = other.data.len();
                        if other_len < self.data.len() {
                            let lo_borrow = __sub2rev(&self.data[..other_len], &mut other.data);
                            other.data.extend_from_slice(&self.data[other_len..]);
                            if lo_borrow != 0 {
                                sub2(&mut other.data[other_len..], &[1])
                            }
                        } else {
                            sub2rev(&self.data[..], &mut other.data[..]);
                        }
                        other.normalized()
                    }
                }

                promote_unsigned_scalars!(impl Sub for BigUint, sub);
                promote_unsigned_scalars_assign!(impl SubAssign for BigUint, sub_assign);
                forward_all_scalar_binop_to_val_val!(impl Sub<u32> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u64> for BigUint, sub);
                forward_all_scalar_binop_to_val_val!(impl Sub<u128> for BigUint, sub);

                impl Sub<u32> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn sub(mut self, other: u32) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u32> for BigUint {
                    fn sub_assign(&mut self, other: u32) {
                        sub2(&mut self.data[..], &[other as BigDigit]);
                        self.normalize();
                    }
                }

                impl Sub<BigUint> for u32 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.len() == 0 {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }

                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push(self as BigDigit);
                            } else {
                                sub2rev(&[self as BigDigit], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u64> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn sub(mut self, other: u64) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u64> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn sub_assign(&mut self, other: u64) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }

                        #[inline]
                        fn sub_assign(&mut self, other: u64) {
                            sub2(&mut self.data[..], &[other as BigDigit]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push(0);
                            }

                            let (hi, lo) = big_digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push(self);
                            } else {
                                sub2rev(&[self], &mut other.data[..]);
                            }
                            other.normalized()
                        }
                    );
                }

                impl Sub<u128> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn sub(mut self, other: u128) -> BigUint {
                        self -= other;
                        self
                    }
                }

                impl SubAssign<u128> for BigUint {
                    cfg_digit!(
                        #[inline]
                        fn sub_assign(&mut self, other: u128) {
                            let (a, b, c, d) = super::u32_from_u128(other);
                            sub2(&mut self.data[..], &[d, c, b, a]);
                            self.normalize();
                        }

                        #[inline]
                        fn sub_assign(&mut self, other: u128) {
                            let (hi, lo) = big_digit::from_doublebigdigit(other);
                            sub2(&mut self.data[..], &[lo, hi]);
                            self.normalize();
                        }
                    );
                }

                impl Sub<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!(
                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 4 {
                                other.data.push(0);
                            }

                            let (a, b, c, d) = super::u32_from_u128(self);
                            sub2rev(&[d, c, b, a], &mut other.data[..]);
                            other.normalized()
                        }

                        #[inline]
                        fn sub(self, mut other: BigUint) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push(0);
                            }

                            let (hi, lo) = big_digit::from_doublebigdigit(self);
                            sub2rev(&[lo, hi], &mut other.data[..]);
                            other.normalized()
                        }
                    );
                }

                impl CheckedSub for BigUint {
                    #[inline]
                    fn checked_sub(&self, v: &BigUint) -> Option<BigUint> {
                        match self.cmp(v) {
                            Less => None,
                            Equal => Some(Self::ZERO),
                            Greater => Some(self.sub(v)),
                        }
                    }
                }

            }

            pub mod bits
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use super::{BigUint, IntDigits};
                use ::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign};
                */
                forward_val_val_binop!(impl BitAnd for BigUint, bitand);
                forward_ref_val_binop!(impl BitAnd for BigUint, bitand);

               
               
                impl BitAnd<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn bitand(self, other: &BigUint) -> BigUint {
                       
                        if self.data.len() <= other.data.len() {
                            self.clone() & other
                        } else {
                            other.clone() & self
                        }
                    }
                }

                forward_val_assign!(impl BitAndAssign for BigUint, bitand_assign);

                impl BitAnd<&BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn bitand(mut self, other: &BigUint) -> BigUint {
                        self &= other;
                        self
                    }
                }
                impl BitAndAssign<&BigUint> for BigUint {
                    #[inline]
                    fn bitand_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai &= bi;
                        }
                        self.data.truncate(other.data.len());
                        self.normalize();
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitOr for BigUint, bitor);
                forward_val_assign!(impl BitOrAssign for BigUint, bitor_assign);

                impl BitOr<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn bitor(mut self, other: &BigUint) -> BigUint {
                        self |= other;
                        self
                    }
                }
                impl BitOrAssign<&BigUint> for BigUint {
                    #[inline]
                    fn bitor_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai |= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                    }
                }

                forward_all_binop_to_val_ref_commutative!(impl BitXor for BigUint, bitxor);
                forward_val_assign!(impl BitXorAssign for BigUint, bitxor_assign);

                impl BitXor<&BigUint> for BigUint {
                    type Output = BigUint;

                    fn bitxor(mut self, other: &BigUint) -> BigUint {
                        self ^= other;
                        self
                    }
                }
                impl BitXorAssign<&BigUint> for BigUint {
                    #[inline]
                    fn bitxor_assign(&mut self, other: &BigUint) {
                        for (ai, &bi) in self.data.iter_mut().zip(other.data.iter()) {
                            *ai ^= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend(extra.iter().cloned());
                        }
                        self.normalize();
                    }
                }

            }

            pub mod convert
            {
                /*!
                */
                use ::
                {
                    vec::{ Vec },
                    cmp::Ordering::{ Equal, Greater, Less },
                    convert::{ TryFrom },
                    num::
                    {
                        big::
                        {
                            big_digit::{self, BigDigit},
                            ParseBigIntError,
                            TryFromBigIntError,
                        },
                        integers::{ Integer, Roots },
                        traits::
                        {
                            float::FloatCore, FromPrimitive, Num, One, PrimInt, ToPrimitive, Zero,
                        },
                    },
                    str::{ FromStr },
                    *,
                };
                use super::{biguint_from_vec, BigUint, ToBigUint};
                use super::addition::add2;
                use super::division::{div_rem_digit, FAST_DIV_WIDE};
                use super::multiplication::mac_with_carry;
                /*
                */
                /// Find last set bit
                /// fls(0) == 0, fls(u32::MAX) == 32
                fn fls<T: PrimInt>(v: T) -> u8 {
                    mem::size_of::<T>() as u8 * 8 - v.leading_zeros() as u8
                }

                fn ilog2<T: PrimInt>(v: T) -> u8 {
                    fls(v) - 1
                }

                impl FromStr for BigUint {
                    type Err = ParseBigIntError;

                    #[inline]
                    fn from_str(s: &str) -> Result<BigUint, ParseBigIntError> {
                        BigUint::from_str_radix(s, 10)
                    }
                }
                
                pub(super) fn from_bitwise_digits_le(v: &[u8], bits: u8) -> BigUint {
                    debug_assert!(!v.is_empty() && bits <= 8 && big_digit::BITS % bits == 0);
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c) < (1 << bits)));

                    let digits_per_big_digit = big_digit::BITS / bits;

                    let data = v
                        .chunks(digits_per_big_digit.into())
                        .map(|chunk| {
                            chunk
                                .iter()
                                .rev()
                                .fold(0, |acc, &c| (acc << bits) | BigDigit::from(c))
                        })
                        .collect();

                    biguint_from_vec(data)
                }

               
               
                fn from_inexact_bitwise_digits_le(v: &[u8], bits: u8) -> BigUint {
                    debug_assert!(!v.is_empty() && bits <= 8 && big_digit::BITS % bits != 0);
                    debug_assert!(v.iter().all(|&c| BigDigit::from(c) < (1 << bits)));

                    let total_bits = (v.len() as u64).saturating_mul(bits.into());
                    let big_digits = Integer::div_ceil(&total_bits, &big_digit::BITS.into())
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut data = Vec::with_capacity(big_digits);

                    let mut d = 0;
                    let mut dbits = 0;

                   
                   
                    for &c in v {
                        d |= BigDigit::from(c) << dbits;
                        dbits += bits;

                        if dbits >= big_digit::BITS {
                            data.push(d);
                            dbits -= big_digit::BITS;
                           
                           
                            d = BigDigit::from(c) >> (bits - dbits);
                        }
                    }

                    if dbits > 0 {
                        debug_assert!(dbits < big_digit::BITS);
                        data.push(d as BigDigit);
                    }

                    biguint_from_vec(data)
                }

               
                fn from_radix_digits_be(v: &[u8], radix: u32) -> BigUint {
                    debug_assert!(!v.is_empty() && !radix.is_power_of_two());
                    debug_assert!(v.iter().all(|&c| u32::from(c) < radix));

                   
                            let big_digits = {
                        let radix_log2 = f64::from(radix).log2();
                        let bits = radix_log2 * v.len() as f64;
                        (bits / big_digit::BITS as f64).ceil()
                    };
                    
                    let mut data = Vec::with_capacity(big_digits.to_usize().unwrap_or(0));

                    let (base, power) = get_radix_base(radix);
                    let radix = radix as BigDigit;

                    let r = v.len() % power;
                    let i = if r == 0 { power } else { r };
                    let (head, tail) = v.split_at(i);

                    let first = head
                        .iter()
                        .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                    data.push(first);

                    debug_assert!(tail.len() % power == 0);
                    for chunk in tail.chunks(power) {
                        if data.last() != Some(&0) {
                            data.push(0);
                        }

                        let mut carry = 0;
                        for d in data.iter_mut() {
                            *d = mac_with_carry(0, *d, base, &mut carry);
                        }
                        debug_assert!(carry == 0);

                        let n = chunk
                            .iter()
                            .fold(0, |acc, &d| acc * radix + BigDigit::from(d));
                        add2(&mut data, &[n]);
                    }

                    biguint_from_vec(data)
                }

                pub(super) fn from_radix_be(buf: &[u8], radix: u32) -> Option<BigUint> {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                       
                        let bits = ilog2(radix);
                        let mut v = Vec::from(buf);
                        v.reverse();
                        if big_digit::BITS % bits == 0 {
                            from_bitwise_digits_le(&v, bits)
                        } else {
                            from_inexact_bitwise_digits_le(&v, bits)
                        }
                    } else {
                        from_radix_digits_be(buf, radix)
                    };

                    Some(res)
                }

                pub(super) fn from_radix_le(buf: &[u8], radix: u32) -> Option<BigUint> {
                    assert!(
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                    );

                    if buf.is_empty() {
                        return Some(BigUint::ZERO);
                    }

                    if radix != 256 && buf.iter().any(|&b| b >= radix as u8) {
                        return None;
                    }

                    let res = if radix.is_power_of_two() {
                       
                        let bits = ilog2(radix);
                        if big_digit::BITS % bits == 0 {
                            from_bitwise_digits_le(buf, bits)
                        } else {
                            from_inexact_bitwise_digits_le(buf, bits)
                        }
                    } else {
                        let mut v = Vec::from(buf);
                        v.reverse();
                        from_radix_digits_be(&v, radix)
                    };

                    Some(res)
                }

                impl Num for BigUint {
                    type FromStrRadixErr = ParseBigIntError;

                    /// Creates and initializes a `BigUint`.
                    fn from_str_radix(s: &str, radix: u32) -> Result<BigUint, ParseBigIntError> {
                        assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
                        let mut s = s;
                        if let Some(tail) = s.strip_prefix('+') {
                            if !tail.starts_with('+') {
                                s = tail
                            }
                        }

                        if s.is_empty() {
                            return Err(ParseBigIntError::empty());
                        }

                        if s.starts_with('_') {
                           
                            return Err(ParseBigIntError::invalid());
                        }

                       
                        let mut v = Vec::with_capacity(s.len());
                        for b in s.bytes() {
                            let d = match b {
                                b'0'..=b'9' => b - b'0',
                                b'a'..=b'z' => b - b'a' + 10,
                                b'A'..=b'Z' => b - b'A' + 10,
                                b'_' => continue,
                                _ => u8::MAX,
                            };
                            if d < radix as u8 {
                                v.push(d);
                            } else {
                                return Err(ParseBigIntError::invalid());
                            }
                        }

                        let res = if radix.is_power_of_two() {
                           
                            let bits = ilog2(radix);
                            v.reverse();
                            if big_digit::BITS % bits == 0 {
                                from_bitwise_digits_le(&v, bits)
                            } else {
                                from_inexact_bitwise_digits_le(&v, bits)
                            }
                        } else {
                            from_radix_digits_be(&v, radix)
                        };
                        Ok(res)
                    }
                }

                fn high_bits_to_u64(v: &BigUint) -> u64 {
                    match v.data.len() {
                        0 => 0,
                        1 => {
                           
                            #[allow(clippy::useless_conversion)]
                            let v0 = u64::from(v.data[0]);
                            v0
                        }
                        _ => {
                            let mut bits = v.bits();
                            let mut ret = 0u64;
                            let mut ret_bits = 0;

                            for d in v.data.iter().rev() {
                                let digit_bits = (bits - 1) % u64::from(big_digit::BITS) + 1;
                                let bits_want = Ord::min(64 - ret_bits, digit_bits);

                                if bits_want != 0 {
                                    if bits_want != 64 {
                                        ret <<= bits_want;
                                    }
                                   
                                    #[allow(clippy::useless_conversion)]
                                    let d0 = u64::from(*d) >> (digit_bits - bits_want);
                                    ret |= d0;
                                }

                               
                               
                               
                                //
                               

                                if digit_bits - bits_want != 0 {
                                   
                                    #[allow(clippy::useless_conversion)]
                                    let masked = u64::from(*d) << (64 - (digit_bits - bits_want) as u32);
                                    ret |= (masked != 0) as u64;
                                }

                                ret_bits += bits_want;
                                bits -= bits_want;
                            }

                            ret
                        }
                    }
                }

                impl ToPrimitive for BigUint {
                    #[inline]
                    fn to_i64(&self) -> Option<i64> {
                        self.to_u64().as_ref().and_then(u64::to_i64)
                    }

                    #[inline]
                    fn to_i128(&self) -> Option<i128> {
                        self.to_u128().as_ref().and_then(u128::to_i128)
                    }

                    #[allow(clippy::useless_conversion)]
                    #[inline]
                    fn to_u64(&self) -> Option<u64> {
                        let mut ret: u64 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 64 {
                                return None;
                            }

                           
                            ret += u64::from(*i) << bits;
                            bits += big_digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline]
                    fn to_u128(&self) -> Option<u128> {
                        let mut ret: u128 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 128 {
                                return None;
                            }

                            ret |= u128::from(*i) << bits;
                            bits += big_digit::BITS;
                        }

                        Some(ret)
                    }

                    #[inline]
                    fn to_f32(&self) -> Option<f32> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f32::MAX_EXP as u64 {
                            Some(f32::INFINITY)
                        } else {
                            Some((mantissa as f32) * 2.0f32.powi(exponent as i32))
                        }
                    }

                    #[inline]
                    fn to_f64(&self) -> Option<f64> {
                        let mantissa = high_bits_to_u64(self);
                        let exponent = self.bits() - u64::from(fls(mantissa));

                        if exponent > f64::MAX_EXP as u64 {
                            Some(f64::INFINITY)
                        } else {
                            Some((mantissa as f64) * 2.0f64.powi(exponent as i32))
                        }
                    }
                }

                macro_rules! impl_try_from_biguint {
                    ($T:ty, $to_ty:path) => {
                        impl TryFrom<&BigUint> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: &BigUint) -> Result<$T, TryFromBigIntError<()>> {
                                $to_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }

                        impl TryFrom<BigUint> for $T {
                            type Error = TryFromBigIntError<BigUint>;

                            #[inline]
                            fn try_from(value: BigUint) -> Result<$T, TryFromBigIntError<BigUint>> {
                                <$T>::try_from(&value).map_err(|_| TryFromBigIntError::new(value))
                            }
                        }
                    };
                }

                impl_try_from_biguint!(u8, ToPrimitive::to_u8);
                impl_try_from_biguint!(u16, ToPrimitive::to_u16);
                impl_try_from_biguint!(u32, ToPrimitive::to_u32);
                impl_try_from_biguint!(u64, ToPrimitive::to_u64);
                impl_try_from_biguint!(usize, ToPrimitive::to_usize);
                impl_try_from_biguint!(u128, ToPrimitive::to_u128);

                impl_try_from_biguint!(i8, ToPrimitive::to_i8);
                impl_try_from_biguint!(i16, ToPrimitive::to_i16);
                impl_try_from_biguint!(i32, ToPrimitive::to_i32);
                impl_try_from_biguint!(i64, ToPrimitive::to_i64);
                impl_try_from_biguint!(isize, ToPrimitive::to_isize);
                impl_try_from_biguint!(i128, ToPrimitive::to_i128);

                impl FromPrimitive for BigUint {
                    #[inline]
                    fn from_i64(n: i64) -> Option<BigUint> {
                        if n >= 0 {
                            Some(BigUint::from(n as u64))
                        } else {
                            None
                        }
                    }

                    #[inline]
                    fn from_i128(n: i128) -> Option<BigUint> {
                        if n >= 0 {
                            Some(BigUint::from(n as u128))
                        } else {
                            None
                        }
                    }

                    #[inline]
                    fn from_u64(n: u64) -> Option<BigUint> {
                        Some(BigUint::from(n))
                    }

                    #[inline]
                    fn from_u128(n: u128) -> Option<BigUint> {
                        Some(BigUint::from(n))
                    }

                    #[inline]
                    fn from_f64(mut n: f64) -> Option<BigUint> {
                       
                        if !n.is_finite() {
                            return None;
                        }

                       
                        n = n.trunc();

                       
                        if n.is_zero() {
                            return Some(Self::ZERO);
                        }

                        let (mantissa, exponent, sign) = Float::integer_decode(n);

                        if sign == -1 {
                            return None;
                        }

                        let mut ret = BigUint::from(mantissa);
                        match exponent.cmp(&0) {
                            Greater => ret <<= exponent as usize,
                            Equal => {}
                            Less => ret >>= (-exponent) as usize,
                        }
                        Some(ret)
                    }
                }

                impl From<u64> for BigUint {
                    #[inline]
                    fn from(mut n: u64) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                           
                            n = (n >> 1) >> (big_digit::BITS - 1);
                        }

                        ret
                    }
                }

                impl From<u128> for BigUint {
                    #[inline]
                    fn from(mut n: u128) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push(n as BigDigit);
                            n >>= big_digit::BITS;
                        }

                        ret
                    }
                }

                macro_rules! impl_biguint_from_uint {
                    ($T:ty) => {
                        impl From<$T> for BigUint {
                            #[inline]
                            fn from(n: $T) -> Self {
                                BigUint::from(n as u64)
                            }
                        }
                    };
                }

                impl_biguint_from_uint!(u8);
                impl_biguint_from_uint!(u16);
                impl_biguint_from_uint!(u32);
                impl_biguint_from_uint!(usize);

                macro_rules! impl_biguint_try_from_int {
                    ($T:ty, $from_ty:path) => {
                        impl TryFrom<$T> for BigUint {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from(value: $T) -> Result<BigUint, TryFromBigIntError<()>> {
                                $from_ty(value).ok_or(TryFromBigIntError::new(()))
                            }
                        }
                    };
                }

                impl_biguint_try_from_int!(i8, FromPrimitive::from_i8);
                impl_biguint_try_from_int!(i16, FromPrimitive::from_i16);
                impl_biguint_try_from_int!(i32, FromPrimitive::from_i32);
                impl_biguint_try_from_int!(i64, FromPrimitive::from_i64);
                impl_biguint_try_from_int!(isize, FromPrimitive::from_isize);
                impl_biguint_try_from_int!(i128, FromPrimitive::from_i128);

                impl ToBigUint for BigUint {
                    #[inline]
                    fn to_biguint(&self) -> Option<BigUint> {
                        Some(self.clone())
                    }
                }

                macro_rules! impl_to_biguint {
                    ($T:ty, $from_ty:path) => {
                        impl ToBigUint for $T {
                            #[inline]
                            fn to_biguint(&self) -> Option<BigUint> {
                                $from_ty(*self)
                            }
                        }
                    };
                }

                impl_to_biguint!(isize, FromPrimitive::from_isize);
                impl_to_biguint!(i8, FromPrimitive::from_i8);
                impl_to_biguint!(i16, FromPrimitive::from_i16);
                impl_to_biguint!(i32, FromPrimitive::from_i32);
                impl_to_biguint!(i64, FromPrimitive::from_i64);
                impl_to_biguint!(i128, FromPrimitive::from_i128);

                impl_to_biguint!(usize, FromPrimitive::from_usize);
                impl_to_biguint!(u8, FromPrimitive::from_u8);
                impl_to_biguint!(u16, FromPrimitive::from_u16);
                impl_to_biguint!(u32, FromPrimitive::from_u32);
                impl_to_biguint!(u64, FromPrimitive::from_u64);
                impl_to_biguint!(u128, FromPrimitive::from_u128);

                impl_to_biguint!(f32, FromPrimitive::from_f32);
                impl_to_biguint!(f64, FromPrimitive::from_f64);

                impl From<bool> for BigUint {
                    fn from(x: bool) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }

               
                pub(super) fn to_bitwise_digits_le(u: &BigUint, bits: u8) -> Vec<u8> {
                    debug_assert!(!u.is_zero() && bits <= 8 && big_digit::BITS % bits == 0);

                    let last_i = u.data.len() - 1;
                    let mask: BigDigit = (1 << bits) - 1;
                    let digits_per_big_digit = big_digit::BITS / bits;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    for mut r in u.data[..last_i].iter().cloned() {
                        for _ in 0..digits_per_big_digit {
                            res.push((r & mask) as u8);
                            r >>= bits;
                        }
                    }

                    let mut r = u.data[last_i];
                    while r != 0 {
                        res.push((r & mask) as u8);
                        r >>= bits;
                    }

                    res
                }

               
                fn to_inexact_bitwise_digits_le(u: &BigUint, bits: u8) -> Vec<u8> {
                    debug_assert!(!u.is_zero() && bits <= 8 && big_digit::BITS % bits != 0);

                    let mask: BigDigit = (1 << bits) - 1;
                    let digits = Integer::div_ceil(&u.bits(), &u64::from(bits))
                        .to_usize()
                        .unwrap_or(usize::MAX);
                    let mut res = Vec::with_capacity(digits);

                    let mut r = 0;
                    let mut rbits = 0;

                    for c in &u.data {
                        r |= *c << rbits;
                        rbits += big_digit::BITS;

                        while rbits >= bits {
                            res.push((r & mask) as u8);
                            r >>= bits;

                           
                            if rbits > big_digit::BITS {
                                r = *c >> (big_digit::BITS - (rbits - bits));
                            }

                            rbits -= bits;
                        }
                    }

                    if rbits != 0 {
                        res.push(r as u8);
                    }

                    while let Some(&0) = res.last() {
                        res.pop();
                    }

                    res
                }

               
                #[inline(always)]
                pub(super) fn to_radix_digits_le(u: &BigUint, radix: u32) -> Vec<u8> {
                    debug_assert!(!u.is_zero() && !radix.is_power_of_two());

                            let radix_digits = {
                        let radix_log2 = f64::from(radix).log2();
                        ((u.bits() as f64) / radix_log2).ceil()
                    };
                    
                    let mut res = Vec::with_capacity(radix_digits.to_usize().unwrap_or(0));

                    let mut digits = u.clone();

                   
                   
                    let (base, power) = if FAST_DIV_WIDE {
                        get_radix_base(radix)
                    } else {
                        get_half_radix_base(radix)
                    };
                    let radix = radix as BigDigit;

                   
                   
                   
                   
                    if digits.data.len() >= 64 {
                        let mut big_base = BigUint::from(base);
                        let mut big_power = 1usize;

                       
                        let target_len = digits.data.len().sqrt();
                        while big_base.data.len() < target_len {
                            big_base = &big_base * &big_base;
                            big_power *= 2;
                        }

                       
                        while digits > big_base {
                           
                            let (q, mut big_r) = digits.div_rem(&big_base);
                            digits = q;

                           
                            for _ in 0..big_power {
                                let (q, mut r) = div_rem_digit(big_r, base);
                                big_r = q;
                                for _ in 0..power {
                                    res.push((r % radix) as u8);
                                    r /= radix;
                                }
                            }
                        }
                    }

                    while digits.data.len() > 1 {
                        let (q, mut r) = div_rem_digit(digits, base);
                        for _ in 0..power {
                            res.push((r % radix) as u8);
                            r /= radix;
                        }
                        digits = q;
                    }

                    let mut r = digits.data[0];
                    while r != 0 {
                        res.push((r % radix) as u8);
                        r /= radix;
                    }

                    res
                }

                pub(super) fn to_radix_le(u: &BigUint, radix: u32) -> Vec<u8> {
                    if u.is_zero() {
                        vec![0]
                    } else if radix.is_power_of_two() {
                       
                        let bits = ilog2(radix);
                        if big_digit::BITS % bits == 0 {
                            to_bitwise_digits_le(u, bits)
                        } else {
                            to_inexact_bitwise_digits_le(u, bits)
                        }
                    } else if radix == 10 {
                       
                       
                        to_radix_digits_le(u, 10)
                    } else {
                        to_radix_digits_le(u, radix)
                    }
                }

                pub fn to_str_radix_reversed(u: &BigUint, radix: u32) -> Vec<u8> {
                    assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");

                    if u.is_zero() {
                        return vec![b'0'];
                    }

                    let mut res = to_radix_le(u, radix);

                   
                    for r in &mut res {
                        debug_assert!(u32::from(*r) < radix);
                        if *r < 10 {
                            *r += b'0';
                        } else {
                            *r += b'a' - 10;
                        }
                    }
                    res
                }

                /// Returns the greatest power of the radix for the `BigDigit` bit size
                #[inline]
                fn get_radix_base(radix: u32) -> (BigDigit, usize) {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(big_digit::MAX);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }

                /// Returns the greatest power of the radix for half the `BigDigit` bit size
                #[inline]
                fn get_half_radix_base(radix: u32) -> (BigDigit, usize) {
                    static BASES: [(BigDigit, usize); 257] = generate_radix_bases(big_digit::HALF);
                    debug_assert!(!radix.is_power_of_two());
                    debug_assert!((3..256).contains(&radix));
                    BASES[radix as usize]
                }

                /// Generate tables of the greatest power of each radix that is less that the given maximum. These
                /// are returned from `get_radix_base` to batch the multiplication/division of radix conversions on
                /// full `BigUint` values, operating on primitive integers as much as possible.
                ///
                /// e.g. BASES_16[3] = (59049, 10)
                ///      BASES_32[3] = (3486784401, 20)
                ///      BASES_64[3] = (12157665459056928801, 40)
                ///
                /// Powers of two are not included, just zeroed, as they're implemented with shifts.
                const fn generate_radix_bases(max: BigDigit) -> [(BigDigit, usize); 257] {
                    let mut bases = [(0, 0); 257];

                    let mut radix: BigDigit = 3;
                    while radix < 256 {
                        if !radix.is_power_of_two() {
                            let mut power = 1;
                            let mut base = radix;

                            while let Some(b) = base.checked_mul(radix) {
                                if b > max {
                                    break;
                                }
                                base = b;
                                power += 1;
                            }
                            bases[radix as usize] = (base, power)
                        }
                        radix += 1;
                    }

                    bases
                }

            }

            pub mod iter
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                    use ::iter::FusedIterator;
                */
                cfg_digit!(
                    /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U32Digits<'a> {
                        it: ::slice::Iter<'a, u32>,
                    }

                    /// An iterator of `u32` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U32Digits<'a> {
                        data: &'a [u64],
                        next_is_lo: bool,
                        last_hi_is_zero: bool,
                    }
                );

                cfg_digit!(
                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub(super) fn new(data: &'a [u32]) -> Self {
                                Self { it: data.iter() }
                            }
                        }

                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next(&mut self) -> Option<u32> {
                                self.it.next().cloned()
                            }

                            #[inline]
                            fn size_hint(&self) -> (usize, Option<usize>) {
                                self.it.size_hint()
                            }

                            #[inline]
                            fn nth(&mut self, n: usize) -> Option<u32> {
                                self.it.nth(n).cloned()
                            }

                            #[inline]
                            fn last(self) -> Option<u32> {
                                self.it.last().cloned()
                            }

                            #[inline]
                            fn count(self) -> usize {
                                self.it.count()
                            }
                        }

                        impl DoubleEndedIterator for U32Digits<'_> {
                            fn next_back(&mut self) -> Option<Self::Item> {
                                self.it.next_back().cloned()
                            }
                        }

                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len(&self) -> usize {
                                self.it.len()
                            }
                        }
                    };

                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub(super) fn new(data: &'a [u64]) -> Self {
                                let last_hi_is_zero = data
                                    .last()
                                    .map(|&last| {
                                        let last_hi = (last >> 32) as u32;
                                        last_hi == 0
                                    })
                                    .unwrap_or(false);
                                U32Digits {
                                    data,
                                    next_is_lo: true,
                                    last_hi_is_zero,
                                }
                            }
                        }

                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next(&mut self) -> Option<u32> {
                                match self.data.split_first() {
                                    Some((&first, data)) => {
                                        let next_is_lo = self.next_is_lo;
                                        self.next_is_lo = !next_is_lo;
                                        if next_is_lo {
                                            Some(first as u32)
                                        } else {
                                            self.data = data;
                                            if data.is_empty() && self.last_hi_is_zero {
                                                self.last_hi_is_zero = false;
                                                None
                                            } else {
                                                Some((first >> 32) as u32)
                                            }
                                        }
                                    }
                                    None => None,
                                }
                            }

                            #[inline]
                            fn size_hint(&self) -> (usize, Option<usize>) {
                                let len = self.len();
                                (len, Some(len))
                            }

                            #[inline]
                            fn last(self) -> Option<u32> {
                                self.data.last().map(|&last| {
                                    if self.last_hi_is_zero {
                                        last as u32
                                    } else {
                                        (last >> 32) as u32
                                    }
                                })
                            }

                            #[inline]
                            fn count(self) -> usize {
                                self.len()
                            }
                        }

                        impl DoubleEndedIterator for U32Digits<'_> {
                            fn next_back(&mut self) -> Option<Self::Item> {
                                match self.data.split_last() {
                                    Some((&last, data)) => {
                                        let last_is_lo = self.last_hi_is_zero;
                                        self.last_hi_is_zero = !last_is_lo;
                                        if last_is_lo {
                                            self.data = data;
                                            if data.is_empty() && !self.next_is_lo {
                                                self.next_is_lo = true;
                                                None
                                            } else {
                                                Some(last as u32)
                                            }
                                        } else {
                                            Some((last >> 32) as u32)
                                        }
                                    }
                                    None => None,
                                }
                            }
                        }

                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len(&self) -> usize {
                                self.data.len() * 2
                                    - usize::from(self.last_hi_is_zero)
                                    - usize::from(!self.next_is_lo)
                            }
                        }
                    };
                );

                impl FusedIterator for U32Digits<'_> {}

                cfg_digit!(
                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: ::slice::Chunks<'a, u32>,
                    }

                    /// An iterator of `u64` digits representation of a `BigUint` or `BigInt`,
                    /// ordered least significant digit first.
                    pub struct U64Digits<'a> {
                        it: ::slice::Iter<'a, u64>,
                    }
                );

                cfg_digit!(
                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub(super) fn new(data: &'a [u32]) -> Self {
                                U64Digits { it: data.chunks(2) }
                            }
                        }

                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next(&mut self) -> Option<u64> {
                                self.it.next().map(super::u32_chunk_to_u64)
                            }

                            #[inline]
                            fn size_hint(&self) -> (usize, Option<usize>) {
                                let len = self.len();
                                (len, Some(len))
                            }

                            #[inline]
                            fn last(self) -> Option<u64> {
                                self.it.last().map(super::u32_chunk_to_u64)
                            }

                            #[inline]
                            fn count(self) -> usize {
                                self.len()
                            }
                        }

                        impl DoubleEndedIterator for U64Digits<'_> {
                            fn next_back(&mut self) -> Option<Self::Item> {
                                self.it.next_back().map(super::u32_chunk_to_u64)
                            }
                        }
                    };

                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub(super) fn new(data: &'a [u64]) -> Self {
                                Self { it: data.iter() }
                            }
                        }

                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next(&mut self) -> Option<u64> {
                                self.it.next().cloned()
                            }

                            #[inline]
                            fn size_hint(&self) -> (usize, Option<usize>) {
                                self.it.size_hint()
                            }

                            #[inline]
                            fn nth(&mut self, n: usize) -> Option<u64> {
                                self.it.nth(n).cloned()
                            }

                            #[inline]
                            fn last(self) -> Option<u64> {
                                self.it.last().cloned()
                            }

                            #[inline]
                            fn count(self) -> usize {
                                self.it.count()
                            }
                        }

                        impl DoubleEndedIterator for U64Digits<'_> {
                            fn next_back(&mut self) -> Option<Self::Item> {
                                self.it.next_back().cloned()
                            }
                        }
                    };
                );

                impl ExactSizeIterator for U64Digits<'_> {
                    #[inline]
                    fn len(&self) -> usize {
                        self.it.len()
                    }
                }

                impl FusedIterator for U64Digits<'_> {}

            }

            pub mod monty
            {
                /*!
                */
                use ::
                {
                    vec::{ Vec },
                    ops::{ Shl },
                    num::
                    {
                        big::
                        {
                            big_digit::{self, BigDigit, DoubleBigDigit},
                            biguint::BigUint,
                        },
                        traits::One,
                    },
                    *,
                };
                /*
                */
                struct MontyReducer {
                    n0inv: BigDigit,
                }

               
               
                fn inv_mod_alt(b: BigDigit) -> BigDigit {
                    assert_ne!(b & 1, 0);

                    let mut k0 = BigDigit::wrapping_sub(2, b);
                    let mut t = b - 1;
                    let mut i = 1;
                    while i < big_digit::BITS {
                        t = t.wrapping_mul(t);
                        k0 = k0.wrapping_mul(t + 1);

                        i <<= 1;
                    }
                    debug_assert_eq!(k0.wrapping_mul(b), 1);
                    k0.wrapping_neg()
                }

                impl MontyReducer {
                    fn new(n: &BigUint) -> Self {
                        let n0inv = inv_mod_alt(n.data[0]);
                        MontyReducer { n0inv }
                    }
                }

                /// Computes z mod m = x * y * 2 ** (-n*_W) mod m
                /// assuming k = -1/m mod 2**_W
                /// See Gueron, "Efficient Software Implementations of Modular Exponentiation".
                /// <https://eprint.iacr.org/2011/239.pdf>
                /// In the terminology of that paper, this is an "Almost Montgomery Multiplication":
                /// x and y are required to satisfy 0 <= z < 2**(n*_W) and then the result
                /// z is guaranteed to satisfy 0 <= z < 2**(n*_W), but it may not be < m.
                #[allow(clippy::many_single_char_names)]
                fn montgomery(x: &BigUint, y: &BigUint, m: &BigUint, k: BigDigit, n: usize) -> BigUint {
                   
                   
                   
                   
                    assert!(
                        x.data.len() == n && y.data.len() == n && m.data.len() == n,
                        "{:?} {:?} {:?} {}",
                        x,
                        y,
                        m,
                        n
                    );

                    let mut z = BigUint::ZERO;
                    z.data.resize(n * 2, 0);

                    let mut c: BigDigit = 0;
                    for i in 0..n {
                        let c2 = add_mul_vvw(&mut z.data[i..n + i], &x.data, y.data[i]);
                        let t = z.data[i].wrapping_mul(k);
                        let c3 = add_mul_vvw(&mut z.data[i..n + i], &m.data, t);
                        let cx = c.wrapping_add(c2);
                        let cy = cx.wrapping_add(c3);
                        z.data[n + i] = cy;
                        if cx < c2 || cy < c3 {
                            c = 1;
                        } else {
                            c = 0;
                        }
                    }

                    if c == 0 {
                        z.data = z.data[n..].to_vec();
                    } else {
                        {
                            let (first, second) = z.data.split_at_mut(n);
                            sub_vv(first, second, &m.data);
                        }
                        z.data = z.data[..n].to_vec();
                    }

                    z
                }

                #[inline(always)]
                fn add_mul_vvw(z: &mut [BigDigit], x: &[BigDigit], y: BigDigit) -> BigDigit {
                    let mut c = 0;
                    for (zi, xi) in z.iter_mut().zip(x.iter()) {
                        let (z1, z0) = mul_add_www(*xi, y, *zi);
                        let (c_, zi_) = add_ww(z0, c, 0);
                        *zi = zi_;
                        c = c_ + z1;
                    }

                    c
                }

                /// The resulting carry c is either 0 or 1.
                #[inline(always)]
                fn sub_vv(z: &mut [BigDigit], x: &[BigDigit], y: &[BigDigit]) -> BigDigit {
                    let mut c = 0;
                    for (i, (xi, yi)) in x.iter().zip(y.iter()).enumerate().take(z.len()) {
                        let zi = xi.wrapping_sub(*yi).wrapping_sub(c);
                        z[i] = zi;
                       
                        c = ((yi & !xi) | ((yi | !xi) & zi)) >> (big_digit::BITS - 1)
                    }

                    c
                }

                /// z1<<_W + z0 = x+y+c, with c == 0 or 1
                #[inline(always)]
                fn add_ww(x: BigDigit, y: BigDigit, c: BigDigit) -> (BigDigit, BigDigit) {
                    let yc = y.wrapping_add(c);
                    let z0 = x.wrapping_add(yc);
                    let z1 = if z0 < x || yc < y { 1 } else { 0 };

                    (z1, z0)
                }

                /// z1 << _W + z0 = x * y + c
                #[inline(always)]
                fn mul_add_www(x: BigDigit, y: BigDigit, c: BigDigit) -> (BigDigit, BigDigit) {
                    let z = x as DoubleBigDigit * y as DoubleBigDigit + c as DoubleBigDigit;
                    ((z >> big_digit::BITS) as BigDigit, z as BigDigit)
                }

                /// Calculates x ** y mod m using a fixed, 4-bit window.
                #[allow(clippy::many_single_char_names)]
                pub(super) fn monty_modpow(x: &BigUint, y: &BigUint, m: &BigUint) -> BigUint {
                    assert!(m.data[0] & 1 == 1);
                    let mr = MontyReducer::new(m);
                    let num_words = m.data.len();

                    let mut x = x.clone();

                   
                   
                    if x.data.len() > num_words {
                        x %= m;
                       
                    }
                    if x.data.len() < num_words {
                        x.data.resize(num_words, 0);
                    }

                   
                    let mut rr = BigUint::one();
                    rr = (rr.shl(2 * num_words as u64 * u64::from(big_digit::BITS))) % m;
                    if rr.data.len() < num_words {
                        rr.data.resize(num_words, 0);
                    }
                   
                    let mut one = BigUint::one();
                    one.data.resize(num_words, 0);

                    let n = 4;
                   
                    let mut powers = Vec::with_capacity(1 << n);
                    powers.push(montgomery(&one, &rr, m, mr.n0inv, num_words));
                    powers.push(montgomery(&x, &rr, m, mr.n0inv, num_words));
                    for i in 2..1 << n {
                        let r = montgomery(&powers[i - 1], &powers[1], m, mr.n0inv, num_words);
                        powers.push(r);
                    }

                   
                    let mut z = powers[0].clone();
                    z.data.resize(num_words, 0);
                    let mut zz = BigUint::ZERO;
                    zz.data.resize(num_words, 0);

                   
                    for i in (0..y.data.len()).rev() {
                        let mut yi = y.data[i];
                        let mut j = 0;
                        while j < big_digit::BITS {
                            if i != y.data.len() - 1 || j != 0 {
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                                zz = montgomery(&z, &z, m, mr.n0inv, num_words);
                                z = montgomery(&zz, &zz, m, mr.n0inv, num_words);
                            }
                            zz = montgomery(
                                &z,
                                &powers[(yi >> (big_digit::BITS - n)) as usize],
                                m,
                                mr.n0inv,
                                num_words,
                            );
                            mem::swap(&mut z, &mut zz);
                            yi <<= n;
                            j += n;
                        }
                    }

                   
                    zz = montgomery(&z, &one, m, mr.n0inv, num_words);

                    zz.normalize();
                   
                   
                    if zz >= *m {
                       
                       
                       
                       
                       
                       
                       
                        zz -= m;
                        if zz >= *m {
                            zz %= m;
                        }
                    }

                    zz.normalize();
                    zz
                }

            }

            pub mod power
            {
                /*!
                */
                use ::
                {
                    num::
                    {
                        big::big_digit::{self, BigDigit},
                        integers::Integer,
                        traits::{One, Pow, ToPrimitive, Zero},
                    },
                    *,
                };
                use super::monty::monty_modpow;
                use super::BigUint;
                /*
                */
                impl Pow<&BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn pow(self, exp: &BigUint) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            Self::ZERO
                        } else if let Some(exp) = exp.to_u64() {
                            self.pow(exp)
                        } else if let Some(exp) = exp.to_u128() {
                            self.pow(exp)
                        } else {
                           
                           
                            panic!("memory overflow")
                        }
                    }
                }

                impl Pow<BigUint> for BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn pow(self, exp: BigUint) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                impl Pow<&BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn pow(self, exp: &BigUint) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            BigUint::ZERO
                        } else {
                            self.clone().pow(exp)
                        }
                    }
                }

                impl Pow<BigUint> for &BigUint {
                    type Output = BigUint;

                    #[inline]
                    fn pow(self, exp: BigUint) -> BigUint {
                        Pow::pow(self, &exp)
                    }
                }

                macro_rules! pow_impl {
                    ($T:ty) => {
                        impl Pow<$T> for BigUint {
                            type Output = BigUint;

                            fn pow(self, mut exp: $T) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                let mut base = self;

                                while exp & 1 == 0 {
                                    base = &base * &base;
                                    exp >>= 1;
                                }

                                if exp == 1 {
                                    return base;
                                }

                                let mut acc = base.clone();
                                while exp > 1 {
                                    exp >>= 1;
                                    base = &base * &base;
                                    if exp & 1 == 1 {
                                        acc *= &base;
                                    }
                                }
                                acc
                            }
                        }

                        impl Pow<&$T> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }

                        impl Pow<$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: $T) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                Pow::pow(self.clone(), exp)
                            }
                        }

                        impl Pow<&$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow(self, exp: &$T) -> BigUint {
                                Pow::pow(self, *exp)
                            }
                        }
                    };
                }

                pow_impl!(u8);
                pow_impl!(u16);
                pow_impl!(u32);
                pow_impl!(u64);
                pow_impl!(usize);
                pow_impl!(u128);

                pub(super) fn modpow(x: &BigUint, exponent: &BigUint, modulus: &BigUint) -> BigUint {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    if modulus.is_odd() {
                       
                        monty_modpow(x, exponent, modulus)
                    } else {
                       
                        plain_modpow(x, &exponent.data, modulus)
                    }
                }

                fn plain_modpow(base: &BigUint, exp_data: &[BigDigit], modulus: &BigUint) -> BigUint {
                    assert!(
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                    );

                    let i = match exp_data.iter().position(|&r| r != 0) {
                        None => return BigUint::one(),
                        Some(i) => i,
                    };

                    let mut base = base % modulus;
                    for _ in 0..i {
                        for _ in 0..big_digit::BITS {
                            base = &base * &base % modulus;
                        }
                    }

                    let mut r = exp_data[i];
                    let mut b = 0u8;
                    while r.is_even() {
                        base = &base * &base % modulus;
                        r >>= 1;
                        b += 1;
                    }

                    let mut exp_iter = exp_data[i + 1..].iter();
                    if exp_iter.len() == 0 && r.is_one() {
                        return base;
                    }

                    let mut acc = base.clone();
                    r >>= 1;
                    b += 1;

                    {
                        let mut unit = |exp_is_odd| {
                            base = &base * &base % modulus;
                            if exp_is_odd {
                                acc *= &base;
                                acc %= modulus;
                            }
                        };

                        if let Some(&last) = exp_iter.next_back() {
                           
                            for _ in b..big_digit::BITS {
                                unit(r.is_odd());
                                r >>= 1;
                            }

                           
                            for &r in exp_iter {
                                let mut r = r;
                                for _ in 0..big_digit::BITS {
                                    unit(r.is_odd());
                                    r >>= 1;
                                }
                            }
                            r = last;
                        }

                        debug_assert_ne!(r, 0);
                        while !r.is_zero() {
                            unit(r.is_odd());
                            r >>= 1;
                        }
                    }
                    acc
                }
            }

            pub mod shift
            {
                /*!
                */
                use ::
                {
                    borrow::{ Cow },
                    num::
                    {
                        big::{ big_digit },
                        traits::{PrimInt, Zero},
                    },
                    ops::{Shl, ShlAssign, Shr, ShrAssign},
                    vec::{ Vec },
                    *,
                };

                use super::{biguint_from_vec, BigUint};
                /*
                */
                #[inline]
                fn biguint_shl<T: PrimInt>(n: Cow<'_, BigUint>, shift: T) -> BigUint {
                    if shift < T::zero() {
                        panic!("attempt to shift left with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(big_digit::BITS).unwrap();
                    let digits = (shift / bits).to_usize().expect("capacity overflow");
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shl2(n, digits, shift)
                }

                fn biguint_shl2(n: Cow<'_, BigUint>, digits: usize, shift: u8) -> BigUint {
                    let mut data = match digits {
                        0 => n.into_owned().data,
                        _ => {
                            let len = digits.saturating_add(n.data.len() + 1);
                            let mut data = Vec::with_capacity(len);
                            data.resize(digits, 0);
                            data.extend(n.data.iter());
                            data
                        }
                    };

                    if shift > 0 {
                        let mut carry = 0;
                        let carry_shift = big_digit::BITS - shift;
                        for elem in data[digits..].iter_mut() {
                            let new_carry = *elem >> carry_shift;
                            *elem = (*elem << shift) | carry;
                            carry = new_carry;
                        }
                        if carry != 0 {
                            data.push(carry);
                        }
                    }

                    biguint_from_vec(data)
                }

                #[inline]
                fn biguint_shr<T: PrimInt>(n: Cow<'_, BigUint>, shift: T) -> BigUint {
                    if shift < T::zero() {
                        panic!("attempt to shift right with negative");
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from(big_digit::BITS).unwrap();
                    let digits = (shift / bits).to_usize().unwrap_or(usize::MAX);
                    let shift = (shift % bits).to_u8().unwrap();
                    biguint_shr2(n, digits, shift)
                }

                fn biguint_shr2(n: Cow<'_, BigUint>, digits: usize, shift: u8) -> BigUint {
                    if digits >= n.data.len() {
                        let mut n = n.into_owned();
                        n.set_zero();
                        return n;
                    }
                    let mut data = match n {
                        Cow::Borrowed(n) => n.data[digits..].to_vec(),
                        Cow::Owned(mut n) => {
                            n.data.drain(..digits);
                            n.data
                        }
                    };

                    if shift > 0 {
                        let mut borrow = 0;
                        let borrow_shift = big_digit::BITS - shift;
                        for elem in data.iter_mut().rev() {
                            let new_borrow = *elem << borrow_shift;
                            *elem = (*elem >> shift) | borrow;
                            borrow = new_borrow;
                        }
                    }

                    biguint_from_vec(data)
                }

                macro_rules! impl_shift {
                    (@ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty) => {
                        impl $Shx<&$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $Shx<&$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx(self, rhs: &$rhs) -> BigUint {
                                $Shx::$shx(self, *rhs)
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigUint {
                            #[inline]
                            fn $shx_assign(&mut self, rhs: &$rhs) {
                                $ShxAssign::$shx_assign(self, *rhs);
                            }
                        }
                    };
                    ($($rhs:ty),+) => {$(
                        impl Shl<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigUint {
                                biguint_shl(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shl<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl(self, rhs: $rhs) -> BigUint {
                                biguint_shl(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShlAssign<$rhs> for BigUint {
                            #[inline]
                            fn shl_assign(&mut self, rhs: $rhs) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n << rhs;
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }

                        impl Shr<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigUint {
                                biguint_shr(Cow::Owned(self), rhs)
                            }
                        }
                        impl Shr<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr(self, rhs: $rhs) -> BigUint {
                                biguint_shr(Cow::Borrowed(self), rhs)
                            }
                        }
                        impl ShrAssign<$rhs> for BigUint {
                            #[inline]
                            fn shr_assign(&mut self, rhs: $rhs) {
                                let n = mem::replace(self, Self::ZERO);
                                *self = n >> rhs;
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }

                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }

            }

        }

        #[cfg(target_pointer_width = "32")]
        type UsizePromotion = u32;
        #[cfg(target_pointer_width = "64")]
        type UsizePromotion = u64;

        #[cfg(target_pointer_width = "32")]
        type IsizePromotion = i32;
        #[cfg(target_pointer_width = "64")]
        type IsizePromotion = i64;

        #[derive(Debug, Clone, PartialEq, Eq)]
        pub struct ParseBigIntError {
            kind: BigIntErrorKind,
        }

        #[derive(Debug, Clone, PartialEq, Eq)]
        enum BigIntErrorKind {
            Empty,
            InvalidDigit,
        }

        impl ParseBigIntError {
            fn __description(&self) -> &str {
                use ::num::big::BigIntErrorKind::*;
                match self.kind {
                    Empty => "cannot parse integer from empty string",
                    InvalidDigit => "invalid digit found in string",
                }
            }

            fn empty() -> Self {
                ParseBigIntError {
                    kind: BigIntErrorKind::Empty,
                }
            }

            fn invalid() -> Self {
                ParseBigIntError {
                    kind: BigIntErrorKind::InvalidDigit,
                }
            }
        }

        impl fmt::Display for ParseBigIntError {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {self.__description().fmt(f)
            }
        }

        #[cfg(feature = "std")]
        #[cfg_attr(docsrs, doc(cfg(feature = "std")))]
        impl ::error::Error for ParseBigIntError {
            fn description(&self) -> &str {
                self.__description()
            }
        }
        /// The error type returned when a checked conversion regarding big integer fails.
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TryFromBigIntError<T> {
            original: T,
        }

        impl<T> TryFromBigIntError<T> {
            fn new(original: T) -> Self {
                TryFromBigIntError { original }
            }

            fn __description(&self) -> &str {
                "out of range conversion regarding big integer attempted"
            }
            /// Extract the original value, if available. The value will be available
            /// if the type before conversion was either [`BigInt`] or [`BigUint`].
            pub fn into_original(self) -> T {
                self.original
            }
        }

        #[cfg(feature = "std")]
        #[cfg_attr(docsrs, doc(cfg(feature = "std")))]
        impl<T> ::error::Error for TryFromBigIntError<T> where
            T: fmt::Debug,
        {
            fn description(&self) -> &str {
                self.__description()
            }
        }

        impl<T> fmt::Display for TryFromBigIntError<T> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {self.__description().fmt(f)
            }
        }

        pub use self::biguint::BigUint;
        pub use self::biguint::ToBigUint;
        pub use self::biguint::U32Digits;
        pub use self::biguint::U64Digits;

        pub use self::bigint::BigInt;
        pub use self::bigint::Sign;
        pub use self::bigint::ToBigInt;

        #[cfg(feature = "rand")]
        #[cfg_attr(docsrs, doc(cfg(feature = "rand")))]
        pub use self::bigrand::{RandBigInt, RandomBits, UniformBigInt, UniformBigUint};

        mod big_digit 
        {
           
            cfg_digit!
            (
                pub type BigDigit = u32;
                pub type BigDigit = u64;
            );

           
           
            cfg_digit!
            (
                pub type DoubleBigDigit = u64;
                pub type DoubleBigDigit = u128;
            );

            pub const BITS: u8 = BigDigit::BITS as u8;
            pub const HALF_BITS: u8 = BITS / 2;
            pub const HALF: BigDigit = (1 << HALF_BITS) - 1;
            pub const MAX: BigDigit = BigDigit::MAX;
            const LO_MASK: DoubleBigDigit = MAX as DoubleBigDigit;

            #[inline]
            fn get_hi(n: DoubleBigDigit) -> BigDigit 
            {
                (n >> BITS) as BigDigit
            }
            #[inline]
            fn get_lo(n: DoubleBigDigit) -> BigDigit 
            {
                (n & LO_MASK) as BigDigit
            }
            /// Split one [`DoubleBigDigit`] into two [`BigDigit`]s.
            #[inline]
            pub fn from_doublebigdigit(n: DoubleBigDigit) -> (BigDigit, BigDigit) {
                (get_hi(n), get_lo(n))
            }
            /// Join two [`BigDigit`]s into one [`DoubleBigDigit`].
            #[inline]
            pub fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit {
                DoubleBigDigit::from(lo) | (DoubleBigDigit::from(hi) << BITS)
            }
        }
    }
    /*
    */
    pub mod rational
    {

        //! Rational numbers
        use ::
        {
            error::{ Error },
            fmt::{ Binary, Display, Formatter, LowerExp, LowerHex, Octal, UpperExp, UpperHex },
            hash::{Hash, Hasher},
            num::
            {
                big::{ BigInt, BigUint, Sign, ToBigInt },
                integers::{ Integer },
                traits::
                {
                    Bounded, CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, ConstOne, ConstZero, FromPrimitive, Inv,
                    Num, NumCast, One, Pow, Signed, ToPrimitive, Unsigned, Zero,
                },
            },
            ops::{Add, Div, Mul, Neg, Rem, ShlAssign, Sub},
            str::{ FromStr },
            *,
        };
        /*
        */
        pub mod pow
        {
            use ::
            {
                num::
                {
                    integers::{ Integer },
                    rational::{ Ratio },
                    traits::{ One, Pow },
                },
                *,
            };
            /*
            */
            macro_rules! pow_unsigned_impl {
                (@ $exp:ty) => {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: $exp) -> Ratio<T> {
                        Ratio::new_raw(self.numer.pow(expon), self.denom.pow(expon))
                    }
                };
                ($exp:ty) => {
                    impl<T: Clone + Integer + Pow<$exp, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_unsigned_impl!(@ $exp);
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        pow_unsigned_impl!(@ $exp);
                    }
                    impl<'b, T: Clone + Integer + Pow<$exp, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                };
            }
            pow_unsigned_impl!(u8);
            pow_unsigned_impl!(u16);
            pow_unsigned_impl!(u32);
            pow_unsigned_impl!(u64);
            pow_unsigned_impl!(u128);
            pow_unsigned_impl!(usize);

            macro_rules! pow_signed_impl {
                (@ &'b BigInt, BigUint) => {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: &'b BigInt) -> Ratio<T> {
                        match expon.sign() {
                            Sign::NoSign => One::one(),
                            Sign::Minus => {
                                Pow::pow(self, expon.magnitude()).into_recip()
                            }
                            Sign::Plus => Pow::pow(self, expon.magnitude()),
                        }
                    }
                };
                (@ $exp:ty, $unsigned:ty) => {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: $exp) -> Ratio<T> {
                        match expon.cmp(&0) {
                            cmp::Ordering::Equal => One::one(),
                            cmp::Ordering::Less => {
                                let expon = expon.wrapping_abs() as $unsigned;
                                Pow::pow(self, expon).into_recip()
                            }
                            cmp::Ordering::Greater => Pow::pow(self, expon as $unsigned),
                        }
                    }
                };
                ($exp:ty, $unsigned:ty) => {
                    impl<T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<$exp> for Ratio<T> {
                        pow_signed_impl!(@ $exp, $unsigned);
                    }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        pow_signed_impl!(@ $exp, $unsigned);
                    }
                    impl<'b, T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline]
                        fn pow(self, expon: &'b $exp) -> Ratio<T> {
                            Pow::pow(self, *expon)
                        }
                    }
                };
            }
            pow_signed_impl!(i8, u8);
            pow_signed_impl!(i16, u16);
            pow_signed_impl!(i32, u32);
            pow_signed_impl!(i64, u64);
            pow_signed_impl!(i128, u128);
            pow_signed_impl!(isize, usize);

            #[cfg(feature = "num-bigint")]
            mod bigint {
                use super::*;
                use num_bigint::{BigInt, BigUint, Sign};

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigUint> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: BigUint) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigUint> for &'a Ratio<T> where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: BigUint) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigUint> for Ratio<T> {
                    pow_unsigned_impl!(@ &'b BigUint);
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigUint> for &'a Ratio<T> where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_unsigned_impl!(@ &'b BigUint);
                }

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigInt> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: BigInt) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'a, T: Clone + Integer> Pow<BigInt> for &'a Ratio<T> where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline]
                    fn pow(self, expon: BigInt) -> Ratio<T> {
                        Pow::pow(self, &expon)
                    }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigInt> for Ratio<T> {
                    pow_signed_impl!(@ &'b BigInt, BigUint);
                }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigInt> for &'a Ratio<T> where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_signed_impl!(@ &'b BigInt, BigUint);
                }
            }

        }
        /// Represents the ratio between two numbers.
        #[derive(Copy, Clone, Debug)]
        #[allow(missing_docs)]
        pub struct Ratio<T> {
            /// Numerator.
            numer: T,
            /// Denominator.
            denom: T,
        }
        /// Alias for a `Ratio` of machine-sized integers.
        #[deprecated(
            since = "0.4.0",
            note = "it's better to use a specific size, like `Rational32` or `Rational64`"
        )]
        pub type Rational = Ratio<isize>;
        /// Alias for a `Ratio` of 32-bit-sized integers.
        pub type Rational32 = Ratio<i32>;
        /// Alias for a `Ratio` of 64-bit-sized integers.
        pub type Rational64 = Ratio<i64>;
        /// Alias for arbitrary precision rationals.
        pub type BigRational = Ratio<BigInt>;
        /// These method are `const`.
        impl<T> Ratio<T>
        {
            /// Creates a `Ratio` without checking for `denom == 0` or reducing.
            #[inline]
            pub const fn new_raw(numer: T, denom: T) -> Ratio<T> {
                Ratio { numer, denom }
            }
            /// Deconstructs a `Ratio` into its numerator and denominator.
            #[inline]
            pub fn into_raw(self) -> (T, T) {
                (self.numer, self.denom)
            }
            /// Gets an immutable reference to the numerator.
            #[inline]
            pub const fn numer(&self) -> &T {
                &self.numer
            }
            /// Gets an immutable reference to the denominator.
            #[inline]
            pub const fn denom(&self) -> &T {
                &self.denom
            }
        }

        impl<T: Clone + Integer> Ratio<T>
        {
            /// Creates a new `Ratio`.
            #[inline]
            pub fn new(numer: T, denom: T) -> Ratio<T> {
                let mut ret = Ratio::new_raw(numer, denom);
                ret.reduce();
                ret
            }
            /// Creates a `Ratio` representing the integer `t`.
            #[inline]
            pub fn from_integer(t: T) -> Ratio<T> {
                Ratio::new_raw(t, One::one())
            }
            /// Converts to an integer, rounding towards zero.
            #[inline]
            pub fn to_integer(&self) -> T {
                self.trunc().numer
            }
            /// Returns true if the rational number is an integer (denominator is 1).
            #[inline]
            pub fn is_integer(&self) -> bool {
                self.denom.is_one()
            }
            /// Puts self into lowest terms, with `denom` > 0.
            fn reduce(&mut self) {
                if self.denom.is_zero() {
                    panic!("denominator == 0");
                }
                if self.numer.is_zero() {
                    self.denom.set_one();
                    return;
                }
                if self.numer == self.denom {
                    self.set_one();
                    return;
                }
                let g: T = self.numer.gcd(&self.denom);

               
               

                #[inline]
                fn replace_with<T: Zero>(x: &mut T, f: impl FnOnce(T) -> T) {
                    let y = ::mem::replace(x, T::zero());
                    *x = f(y);
                }

               
                replace_with(&mut self.numer, |x| x / g.clone());

               
                replace_with(&mut self.denom, |x| x / g);

               
                if self.denom < T::zero() {
                    replace_with(&mut self.numer, |x| T::zero() - x);
                    replace_with(&mut self.denom, |x| T::zero() - x);
                }
            }
            /// Returns a reduced copy of self.
            pub fn reduced(&self) -> Ratio<T> {
                let mut ret = self.clone();
                ret.reduce();
                ret
            }
            /// Returns the reciprocal.
            #[inline]
            pub fn recip(&self) -> Ratio<T> {
                self.clone().into_recip()
            }

            #[inline]
            fn into_recip(self) -> Ratio<T> {
                match self.numer.cmp(&T::zero()) {
                    cmp::Ordering::Equal => panic!("division by zero"),
                    cmp::Ordering::Greater => Ratio::new_raw(self.denom, self.numer),
                    cmp::Ordering::Less => Ratio::new_raw(T::zero() - self.denom, T::zero() - self.numer),
                }
            }
            /// Rounds towards minus infinity.
            #[inline]
            pub fn floor(&self) -> Ratio<T> {
                if *self < Zero::zero() {
                    let one: T = One::one();
                    Ratio::from_integer(
                        (self.numer.clone() - self.denom.clone() + one) / self.denom.clone(),
                    )
                } else {
                    Ratio::from_integer(self.numer.clone() / self.denom.clone())
                }
            }
            /// Rounds towards plus infinity.
            #[inline]
            pub fn ceil(&self) -> Ratio<T> {
                if *self < Zero::zero() {
                    Ratio::from_integer(self.numer.clone() / self.denom.clone())
                } else {
                    let one: T = One::one();
                    Ratio::from_integer(
                        (self.numer.clone() + self.denom.clone() - one) / self.denom.clone(),
                    )
                }
            }
            /// Rounds to the nearest integer. Rounds half-way cases away from zero.
            #[inline]
            pub fn round(&self) -> Ratio<T> {
                let zero: Ratio<T> = Zero::zero();
                let one: T = One::one();
                let two: T = one.clone() + one.clone();

               
                let mut fractional = self.fract();
                if fractional < zero {
                    fractional = zero - fractional
                };

               
               
               
                let half_or_larger = if fractional.denom.is_even() {
                    fractional.numer >= fractional.denom / two
                } else {
                    fractional.numer >= (fractional.denom / two) + one
                };

                if half_or_larger {
                    let one: Ratio<T> = One::one();
                    if *self >= Zero::zero() {
                        self.trunc() + one
                    } else {
                        self.trunc() - one
                    }
                } else {
                    self.trunc()
                }
            }
            /// Rounds towards zero.
            #[inline]
            pub fn trunc(&self) -> Ratio<T> {
                Ratio::from_integer(self.numer.clone() / self.denom.clone())
            }
            /// Returns the fractional part of a number, with division rounded towards zero.
            #[inline]
            pub fn fract(&self) -> Ratio<T> {
                Ratio::new_raw(self.numer.clone() % self.denom.clone(), self.denom.clone())
            }
            /// Raises the `Ratio` to the power of an exponent.
            #[inline]
            pub fn pow(&self, expon: i32) -> Ratio<T> where
                for<'a> &'a T: Pow<u32, Output = T>,
            {
                Pow::pow(self, expon)
            }
        }
        
        impl Ratio<BigInt>
        {
            /// Converts a float into a rational number.
            pub fn from_float<T: FloatCore>(f: T) -> Option<BigRational> {
                if !f.is_finite() {
                    return None;
                }
                let (mantissa, exponent, sign) = f.integer_decode();
                let bigint_sign = if sign == 1 { Sign::Plus } else { Sign::Minus };
                if exponent < 0 {
                    let one: BigInt = One::one();
                    let denom: BigInt = one << ((-exponent) as usize);
                    let numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();
                    Some(Ratio::new(BigInt::from_biguint(bigint_sign, numer), denom))
                } else {
                    let mut numer: BigUint = FromPrimitive::from_u64(mantissa).unwrap();
                    numer <<= exponent as usize;
                    Some(Ratio::from_integer(BigInt::from_biguint(
                        bigint_sign,
                        numer,
                    )))
                }
            }
        }

        impl<T: Clone + Integer> Default for Ratio<T>
        {
            /// Returns zero
            fn default() -> Self {
                Ratio::zero()
            }
        }
        
        impl<T> From<T> for Ratio<T> where
            T: Clone + Integer,
        {
            fn from(x: T) -> Ratio<T> {
                Ratio::from_integer(x)
            }
        }
        
        impl<T> From<(T, T)> for Ratio<T> where
            T: Clone + Integer,
        {
            fn from(pair: (T, T)) -> Ratio<T> {
                Ratio::new(pair.0, pair.1)
            }
        }
        
        impl<T: Clone + Integer> Ord for Ratio<T> 
        {
            #[inline]
            fn cmp(&self, other: &Self) -> cmp::Ordering {
               
                if self.denom == other.denom {
                    let ord = self.numer.cmp(&other.numer);
                    return if self.denom < T::zero() {
                        ord.reverse()
                    } else {
                        ord
                    };
                }

               
                if self.numer == other.numer {
                    if self.numer.is_zero() {
                        return cmp::Ordering::Equal;
                    }
                    let ord = self.denom.cmp(&other.denom);
                    return if self.numer < T::zero() {
                        ord
                    } else {
                        ord.reverse()
                    };
                }

               
               
               

               
                let (self_int, self_rem) = self.numer.div_mod_floor(&self.denom);
                let (other_int, other_rem) = other.numer.div_mod_floor(&other.denom);
                match self_int.cmp(&other_int) {
                    cmp::Ordering::Greater => cmp::Ordering::Greater,
                    cmp::Ordering::Less => cmp::Ordering::Less,
                    cmp::Ordering::Equal => {
                        match (self_rem.is_zero(), other_rem.is_zero()) {
                            (true, true) => cmp::Ordering::Equal,
                            (true, false) => cmp::Ordering::Less,
                            (false, true) => cmp::Ordering::Greater,
                            (false, false) => {
                               
                                let self_recip = Ratio::new_raw(self.denom.clone(), self_rem);
                                let other_recip = Ratio::new_raw(other.denom.clone(), other_rem);
                                self_recip.cmp(&other_recip).reverse()
                            }
                        }
                    }
                }
            }
        }

        impl<T: Clone + Integer> PartialOrd for Ratio<T>
        {
            #[inline]
            fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
                Some(self.cmp(other))
            }
        }

        impl<T: Clone + Integer> PartialEq for Ratio<T> 
        {
            #[inline]
            fn eq(&self, other: &Self) -> bool {
                self.cmp(other) == cmp::Ordering::Equal
            }
        }

        impl<T: Clone + Integer> Eq for Ratio<T> {}       
       
        impl<T: Clone + Integer + Hash> Hash for Ratio<T> 
        {
            fn hash<H: Hasher>(&self, state: &mut H) {
                recurse(&self.numer, &self.denom, state);

                fn recurse<T: Integer + Hash, H: Hasher>(numer: &T, denom: &T, state: &mut H) {
                    if !denom.is_zero() {
                        let (int, rem) = numer.div_mod_floor(denom);
                        int.hash(state);
                        recurse(denom, &rem, state);
                    } else {
                        denom.hash(state);
                    }
                }
            }
        }

        mod iter_sum_product
        {
            use ::
            {
                iter::{Product, Sum},
                num::
                {
                    integers::{ Integer },
                    rational::{ Ratio },
                    traits::{ One, Zero },
                },
                *,
            };

            impl<T: Integer + Clone> Sum for Ratio<T>
            {
                fn sum<I>(iter: I) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold(Self::zero(), |sum, num| sum + num)
                }
            }

            impl<'a, T: Integer + Clone> Sum<&'a Ratio<T>> for Ratio<T>
            {
                fn sum<I>(iter: I) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold(Self::zero(), |sum, num| sum + num)
                }
            }

            impl<T: Integer + Clone> Product for Ratio<T>
            {
                fn product<I>(iter: I) -> Self
                where
                    I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold(Self::one(), |prod, num| prod * num)
                }
            }

            impl<'a, T: Integer + Clone> Product<&'a Ratio<T>> for Ratio<T>
            {
                fn product<I>(iter: I) -> Self
                where
                    I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold(Self::one(), |prod, num| prod * num)
                }
            }
        }

        mod opassign
        {
            use ::
            {
                ops::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign},
                num::
                {
                    integers::Integer,
                    rational::{ Ratio },
                    traits::NumAssign,
                },
                *,
            };

            impl<T: Clone + Integer + NumAssign> AddAssign for Ratio<T>
            {
                fn add_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer += other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer + rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> DivAssign for Ratio<T>
            {
                fn div_assign(&mut self, other: Ratio<T>) {
                    let gcd_ac = self.numer.gcd(&other.numer);
                    let gcd_bd = self.denom.gcd(&other.denom);
                    self.numer /= gcd_ac.clone();
                    self.numer *= other.denom / gcd_bd.clone();
                    self.denom /= gcd_bd;
                    self.denom *= other.numer / gcd_ac;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> MulAssign for Ratio<T>
            {
                fn mul_assign(&mut self, other: Ratio<T>) {
                    let gcd_ad = self.numer.gcd(&other.denom);
                    let gcd_bc = self.denom.gcd(&other.numer);
                    self.numer /= gcd_ad.clone();
                    self.numer *= other.numer / gcd_bc.clone();
                    self.denom /= gcd_bc;
                    self.denom *= other.denom / gcd_ad;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> RemAssign for Ratio<T>
            {
                fn rem_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer %= other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer % rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> SubAssign for Ratio<T>
            {
                fn sub_assign(&mut self, other: Ratio<T>) {
                    if self.denom == other.denom {
                        self.numer -= other.numer
                    } else {
                        let lcm = self.denom.lcm(&other.denom);
                        let lhs_numer = self.numer.clone() * (lcm.clone() / self.denom.clone());
                        let rhs_numer = other.numer * (lcm.clone() / other.denom);
                        self.numer = lhs_numer - rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> AddAssign<T> for Ratio<T>
            {
                fn add_assign(&mut self, other: T) {
                    self.numer += self.denom.clone() * other;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> DivAssign<T> for Ratio<T>
            {
                fn div_assign(&mut self, other: T) {
                    let gcd = self.numer.gcd(&other);
                    self.numer /= gcd.clone();
                    self.denom *= other / gcd;
                    self.reduce();
                }
            }

            impl<T: Clone + Integer + NumAssign> MulAssign<T> for Ratio<T>
            {
                fn mul_assign(&mut self, other: T) {
                    let gcd = self.denom.gcd(&other);
                    self.denom /= gcd.clone();
                    self.numer *= other / gcd;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> RemAssign<T> for Ratio<T>
            {
                fn rem_assign(&mut self, other: T) {
                    self.numer %= self.denom.clone() * other;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> SubAssign<T> for Ratio<T>
            {
                fn sub_assign(&mut self, other: T) {
                    self.numer -= self.denom.clone() * other;
                    self.reduce();
                }
            }

            macro_rules! forward_op_assign {
                (impl $imp:ident, $method:ident) => {
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a Ratio<T>> for Ratio<T> {
                        #[inline]
                        fn $method(&mut self, other: &Ratio<T>) {
                            self.$method(other.clone())
                        }
                    }
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a T> for Ratio<T> {
                        #[inline]
                        fn $method(&mut self, other: &T) {
                            self.$method(other.clone())
                        }
                    }
                };
            }

            forward_op_assign!(impl AddAssign, add_assign);
            forward_op_assign!(impl DivAssign, div_assign);
            forward_op_assign!(impl MulAssign, mul_assign);
            forward_op_assign!(impl RemAssign, rem_assign);
            forward_op_assign!(impl SubAssign, sub_assign);
        }

        forward_all_binop!(impl Mul, mul);
       
        impl<T> Mul<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline]
            fn mul(self, rhs: Ratio<T>) -> Ratio<T> {
                let gcd_ad = self.numer.gcd(&rhs.denom);
                let gcd_bc = self.denom.gcd(&rhs.numer);
                Ratio::new(
                    self.numer / gcd_ad.clone() * (rhs.numer / gcd_bc.clone()),
                    self.denom / gcd_bc * (rhs.denom / gcd_ad),
                )
            }
        }
       
        impl<T> Mul<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline]
            fn mul(self, rhs: T) -> Ratio<T> {
                let gcd = self.denom.gcd(&rhs);
                Ratio::new(self.numer * (rhs / gcd.clone()), self.denom / gcd)
            }
        }

        forward_all_binop!(impl Div, div);
       
        impl<T> Div<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline]
            fn div(self, rhs: Ratio<T>) -> Ratio<T> {
                let gcd_ac = self.numer.gcd(&rhs.numer);
                let gcd_bd = self.denom.gcd(&rhs.denom);
                Ratio::new(
                    self.numer / gcd_ac.clone() * (rhs.denom / gcd_bd.clone()),
                    self.denom / gcd_bd * (rhs.numer / gcd_ac),
                )
            }
        }
       
        impl<T> Div<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline]
            fn div(self, rhs: T) -> Ratio<T> {
                let gcd = self.numer.gcd(&rhs);
                Ratio::new(self.numer / gcd.clone(), self.denom * (rhs / gcd))
            }
        }

        macro_rules! arith_impl
        {
            (impl $imp:ident, $method:ident) => {
                forward_all_binop!(impl $imp, $method);
               
                impl<T: Clone + Integer> $imp<Ratio<T>> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline]
                    fn $method(self, rhs: Ratio<T>) -> Ratio<T> {
                        if self.denom == rhs.denom {
                            return Ratio::new(self.numer.$method(rhs.numer), rhs.denom);
                        }
                        let lcm = self.denom.lcm(&rhs.denom);
                        let lhs_numer = self.numer * (lcm.clone() / self.denom);
                        let rhs_numer = rhs.numer * (lcm.clone() / rhs.denom);
                        Ratio::new(lhs_numer.$method(rhs_numer), lcm)
                    }
                }
               
                impl<T: Clone + Integer> $imp<T> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline]
                    fn $method(self, rhs: T) -> Ratio<T> {
                        Ratio::new(self.numer.$method(self.denom.clone() * rhs), self.denom)
                    }
                }
            };
        }

        arith_impl!(impl Add, add);
        arith_impl!(impl Sub, sub);
        arith_impl!(impl Rem, rem);
       
        impl<T> CheckedMul for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline]
            fn checked_mul(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                let gcd_ad = self.numer.gcd(&rhs.denom);
                let gcd_bc = self.denom.gcd(&rhs.numer);
                Some(Ratio::new(
                    (self.numer.clone() / gcd_ad.clone())
                        .checked_mul(&(rhs.numer.clone() / gcd_bc.clone()))?,
                    (self.denom.clone() / gcd_bc).checked_mul(&(rhs.denom.clone() / gcd_ad))?,
                ))
            }
        }

       
        impl<T> CheckedDiv for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline]
            fn checked_div(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                if rhs.is_zero() {
                    return None;
                }
                let (numer, denom) = if self.denom == rhs.denom {
                    (self.numer.clone(), rhs.numer.clone())
                } else if self.numer == rhs.numer {
                    (rhs.denom.clone(), self.denom.clone())
                } else {
                    let gcd_ac = self.numer.gcd(&rhs.numer);
                    let gcd_bd = self.denom.gcd(&rhs.denom);
                    (
                        (self.numer.clone() / gcd_ac.clone())
                            .checked_mul(&(rhs.denom.clone() / gcd_bd.clone()))?,
                        (self.denom.clone() / gcd_bd).checked_mul(&(rhs.numer.clone() / gcd_ac))?,
                    )
                };
               
                if denom.is_zero() {
                    None
                } else if numer.is_zero() {
                    Some(Self::zero())
                } else if numer == denom {
                    Some(Self::one())
                } else {
                    let g = numer.gcd(&denom);
                    let numer = numer / g.clone();
                    let denom = denom / g;
                    let raw = if denom < T::zero() {
                       
                       
                        let n1 = T::zero() - T::one();
                        Ratio::new_raw(numer.checked_mul(&n1)?, denom.checked_mul(&n1)?)
                    } else {
                        Ratio::new_raw(numer, denom)
                    };
                    Some(raw)
                }
            }
        }
        
        macro_rules! checked_arith_impl
        {
            (impl $imp:ident, $method:ident) => {
                impl<T: Clone + Integer + CheckedMul + $imp> $imp for Ratio<T> {
                    #[inline]
                    fn $method(&self, rhs: &Ratio<T>) -> Option<Ratio<T>> {
                        let gcd = self.denom.clone().gcd(&rhs.denom);
                        let lcm = (self.denom.clone() / gcd.clone()).checked_mul(&rhs.denom)?;
                        let lhs_numer = (lcm.clone() / self.denom.clone()).checked_mul(&self.numer)?;
                        let rhs_numer = (lcm.clone() / rhs.denom.clone()).checked_mul(&rhs.numer)?;
                        Some(Ratio::new(lhs_numer.$method(&rhs_numer)?, lcm))
                    }
                }
            };
        }
        
        checked_arith_impl!(impl CheckedAdd, checked_add);
        checked_arith_impl!(impl CheckedSub, checked_sub);

        impl<T> Neg for Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline]
            fn neg(self) -> Ratio<T> {
                Ratio::new_raw(-self.numer, self.denom)
            }
        }

        impl<'a, T> Neg for &'a Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline]
            fn neg(self) -> Ratio<T> {
                -self.clone()
            }
        }

        impl<T> Inv for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline]
            fn inv(self) -> Ratio<T> {
                self.recip()
            }
        }

        impl<'a, T> Inv for &'a Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline]
            fn inv(self) -> Ratio<T> {
                self.recip()
            }
        }
        
        impl<T: ConstZero + ConstOne> Ratio<T>
        {
            /// A constant `Ratio` 0/1.
            pub const ZERO: Self = Self::new_raw(T::ZERO, T::ONE);
        }

        impl<T: Clone + Integer + ConstZero + ConstOne> ConstZero for Ratio<T>
        {
            const ZERO: Self = Self::ZERO;
        }

        impl<T: Clone + Integer> Zero for Ratio<T> 
        {
            #[inline]
            fn zero() -> Ratio<T> {
                Ratio::new_raw(Zero::zero(), One::one())
            }

            #[inline]
            fn is_zero(&self) -> bool {
                self.numer.is_zero()
            }

            #[inline]
            fn set_zero(&mut self) {
                self.numer.set_zero();
                self.denom.set_one();
            }
        }

        impl<T: ConstOne> Ratio<T> 
        {
            /// A constant `Ratio` 1/1.
            pub const ONE: Self = Self::new_raw(T::ONE, T::ONE);
        }

        impl<T: Clone + Integer + ConstOne> ConstOne for Ratio<T> 
        {
            const ONE: Self = Self::ONE;
        }

        impl<T: Clone + Integer> One for Ratio<T>
        {
            #[inline]
            fn one() -> Ratio<T> {
                Ratio::new_raw(One::one(), One::one())
            }

            #[inline]
            fn is_one(&self) -> bool {
                self.numer == self.denom
            }

            #[inline]
            fn set_one(&mut self) {
                self.numer.set_one();
                self.denom.set_one();
            }
        }

        impl<T: Clone + Integer> Num for Ratio<T>
        {
            type FromStrRadixErr = ParseRatioError;

            /// Parses `numer/denom` where the numbers are in base `radix`.
            fn from_str_radix(s: &str, radix: u32) -> Result<Ratio<T>, ParseRatioError> {
                if s.splitn(2, '/').count() == 2 {
                    let mut parts = s.splitn(2, '/').map(|ss| {
                        T::from_str_radix(ss, radix).map_err(|_| ParseRatioError {
                            kind: RatioErrorKind::ParseError,
                        })
                    });
                    let numer: T = parts.next().unwrap()?;
                    let denom: T = parts.next().unwrap()?;
                    if denom.is_zero() {
                        Err(ParseRatioError {
                            kind: RatioErrorKind::ZeroDenominator,
                        })
                    } else {
                        Ok(Ratio::new(numer, denom))
                    }
                } else {
                    Err(ParseRatioError {
                        kind: RatioErrorKind::ParseError,
                    })
                }
            }
        }

        impl<T: Clone + Integer + Signed> Signed for Ratio<T>
        {
            #[inline]
            fn abs(&self) -> Ratio<T> {
                if self.is_negative() {
                    -self.clone()
                } else {
                    self.clone()
                }
            }

            #[inline]
            fn abs_sub(&self, other: &Ratio<T>) -> Ratio<T> {
                if *self <= *other {
                    Zero::zero()
                } else {
                    self - other
                }
            }

            #[inline]
            fn signum(&self) -> Ratio<T> {
                if self.is_positive() {
                    Self::one()
                } else if self.is_zero() {
                    Self::zero()
                } else {
                    -Self::one()
                }
            }

            #[inline]
            fn is_positive(&self) -> bool {
                (self.numer.is_positive() && self.denom.is_positive())
                    || (self.numer.is_negative() && self.denom.is_negative())
            }

            #[inline]
            fn is_negative(&self) -> bool {
                (self.numer.is_negative() && self.denom.is_positive())
                    || (self.numer.is_positive() && self.denom.is_negative())
            }
        }
        
        macro_rules! impl_formatting
        {
            ($fmt_trait:ident, $prefix:expr, $fmt_str:expr, $fmt_alt:expr) => {
                impl<T: $fmt_trait + Clone + Integer> $fmt_trait for Ratio<T> {
                            fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result
                {        let pre_pad = if self.denom.is_one() {
                            format!($fmt_str, self.numer)
                        } else {
                            if f.alternate() {
                                format!(concat!($fmt_str, "/", $fmt_alt), self.numer, self.denom)
                            } else {
                                format!(concat!($fmt_str, "/", $fmt_str), self.numer, self.denom)
                            }
                        };
                        if let Some(pre_pad) = pre_pad.strip_prefix("-") {
                            f.pad_integral(false, $prefix, pre_pad)
                        } else {
                            f.pad_integral(true, $prefix, &pre_pad)
                        }
                    }
                }
            };
        }

        impl_formatting!(Display, "", "{}", "{:#}");
        impl_formatting!(Octal, "0o", "{:o}", "{:#o}");
        impl_formatting!(Binary, "0b", "{:b}", "{:#b}");
        impl_formatting!(LowerHex, "0x", "{:x}", "{:#x}");
        impl_formatting!(UpperHex, "0x", "{:X}", "{:#X}");
        impl_formatting!(LowerExp, "", "{:e}", "{:#e}");
        impl_formatting!(UpperExp, "", "{:E}", "{:#E}");

        impl<T: FromStr + Clone + Integer> FromStr for Ratio<T>
        {
            type Err = ParseRatioError;

            /// Parses `numer/denom` or just `numer`.
            fn from_str(s: &str) -> Result<Ratio<T>, ParseRatioError> {
                let mut split = s.splitn(2, '/');

                let n = split.next().ok_or(ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;
                let num = FromStr::from_str(n).map_err(|_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;

                let d = split.next().unwrap_or("1");
                let den = FromStr::from_str(d).map_err(|_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                })?;

                if Zero::is_zero(&den) {
                    Err(ParseRatioError {
                        kind: RatioErrorKind::ZeroDenominator,
                    })
                } else {
                    Ok(Ratio::new(num, den))
                }
            }
        }

        impl<T> From<Ratio<T>> for (T, T)
        {
            fn from(val: Ratio<T>) -> Self {
                (val.numer, val.denom)
            }
        }
                
        #[derive(Copy, Clone, Debug, PartialEq)]
        pub struct ParseRatioError
        {
            kind: RatioErrorKind,
        }

        #[derive(Copy, Clone, Debug, PartialEq)]
        enum RatioErrorKind
        {
            ParseError,
            ZeroDenominator,
        }

        impl fmt::Display for ParseRatioError
        {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {self.kind.description().fmt(f)
            }
        }
        
        impl Error for ParseRatioError
        {
            #[allow(deprecated)]
            fn description(&self) -> &str {
                self.kind.description()
            }
        }

        impl RatioErrorKind
        {
            fn description(&self) -> &'static str {
                match *self {
                    RatioErrorKind::ParseError => "failed to parse integer",
                    RatioErrorKind::ZeroDenominator => "zero value denominator",
                }
            }
        }
        
        impl FromPrimitive for Ratio<BigInt>
        {
            fn from_i64(n: i64) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_i128(n: i128) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_u64(n: u64) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_u128(n: u128) -> Option<Self> {
                Some(Ratio::from_integer(n.into()))
            }

            fn from_f32(n: f32) -> Option<Self> {
                Ratio::from_float(n)
            }

            fn from_f64(n: f64) -> Option<Self> {
                Ratio::from_float(n)
            }
        }

        macro_rules! from_primitive_integer
        {
            ($typ:ty, $approx:ident) => {
                impl FromPrimitive for Ratio<$typ> {
                    fn from_i64(n: i64) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i64(n).map(Ratio::from_integer)
                    }

                    fn from_i128(n: i128) -> Option<Self> {
                        <$typ as FromPrimitive>::from_i128(n).map(Ratio::from_integer)
                    }

                    fn from_u64(n: u64) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u64(n).map(Ratio::from_integer)
                    }

                    fn from_u128(n: u128) -> Option<Self> {
                        <$typ as FromPrimitive>::from_u128(n).map(Ratio::from_integer)
                    }

                    fn from_f32(n: f32) -> Option<Self> {
                        $approx(n, 10e-20, 30)
                    }

                    fn from_f64(n: f64) -> Option<Self> {
                        $approx(n, 10e-20, 30)
                    }
                }
            };
        }

        from_primitive_integer!(i8, approximate_float);
        from_primitive_integer!(i16, approximate_float);
        from_primitive_integer!(i32, approximate_float);
        from_primitive_integer!(i64, approximate_float);
        from_primitive_integer!(i128, approximate_float);
        from_primitive_integer!(isize, approximate_float);

        from_primitive_integer!(u8, approximate_float_unsigned);
        from_primitive_integer!(u16, approximate_float_unsigned);
        from_primitive_integer!(u32, approximate_float_unsigned);
        from_primitive_integer!(u64, approximate_float_unsigned);
        from_primitive_integer!(u128, approximate_float_unsigned);
        from_primitive_integer!(usize, approximate_float_unsigned);

        impl<T: Integer + Signed + Bounded + NumCast + Clone> Ratio<T>
        {
            pub fn approximate_float<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>> {
               
               
               
                let epsilon = <F as NumCast>::from(10e-20).expect("Can't convert 10e-20");
                approximate_float(f, epsilon, 30)
            }
        }

        impl<T: Integer + Unsigned + Bounded + NumCast + Clone> Ratio<T>
        {
            pub fn approximate_float_unsigned<F: FloatCore + NumCast>(f: F) -> Option<Ratio<T>> {
               
               
               
                let epsilon = <F as NumCast>::from(10e-20).expect("Can't convert 10e-20");
                approximate_float_unsigned(f, epsilon, 30)
            }
        }

        fn approximate_float<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>> where
            T: Integer + Signed + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
            let negative = val.is_sign_negative();
            let abs_val = val.abs();

            let r = approximate_float_unsigned(abs_val, max_error, max_iterations)?;

           
            Some(if negative { r.neg() } else { r })
        }
        
        fn approximate_float_unsigned<T, F>(val: F, max_error: F, max_iterations: usize) -> Option<Ratio<T>> where
            T: Integer + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
           
           

            if val < F::zero() || val.is_nan() {
                return None;
            }

            let mut q = val;
            let mut n0 = T::zero();
            let mut d0 = T::one();
            let mut n1 = T::one();
            let mut d1 = T::zero();

            let t_max = T::max_value();
            let t_max_f = <F as NumCast>::from(t_max.clone())?;

           
            let epsilon = t_max_f.recip();

           
            if q > t_max_f {
                return None;
            }

            for _ in 0..max_iterations {
                let a = match <T as NumCast>::from(q) {
                    None => break,
                    Some(a) => a,
                };

                let a_f = match <F as NumCast>::from(a.clone()) {
                    None => break,
                    Some(a_f) => a_f,
                };
                let f = q - a_f;

               
                if !a.is_zero()
                    && (n1 > t_max.clone() / a.clone()
                        || d1 > t_max.clone() / a.clone()
                        || a.clone() * n1.clone() > t_max.clone() - n0.clone()
                        || a.clone() * d1.clone() > t_max.clone() - d0.clone())
                {
                    break;
                }

                let n = a.clone() * n1.clone() + n0.clone();
                let d = a.clone() * d1.clone() + d0.clone();

                n0 = n1;
                d0 = d1;
                n1 = n.clone();
                d1 = d.clone();

               
               
                let g = Integer::gcd(&n1, &d1);
                if !g.is_zero() {
                    n1 = n1 / g.clone();
                    d1 = d1 / g.clone();
                }

               
                let (n_f, d_f) = match (<F as NumCast>::from(n), <F as NumCast>::from(d)) {
                    (Some(n_f), Some(d_f)) => (n_f, d_f),
                    _ => break,
                };
                if (n_f / d_f - val).abs() < max_error {
                    break;
                }

               
                if f < epsilon {
                    break;
                }
                q = f.recip();
            }

           
            if d1.is_zero() {
                return None;
            }

            Some(Ratio::new(n1, d1))
        }
        
        impl<T: Clone + Integer + ToPrimitive + ToBigInt> ToPrimitive for Ratio<T>
        {
            fn to_i64(&self) -> Option<i64> {
                self.to_integer().to_i64()
            }

            fn to_i128(&self) -> Option<i128> {
                self.to_integer().to_i128()
            }

            fn to_u64(&self) -> Option<u64> {
                self.to_integer().to_u64()
            }

            fn to_u128(&self) -> Option<u128> {
                self.to_integer().to_u128()
            }

            fn to_f64(&self) -> Option<f64> {
                let float = match (self.numer.to_i64(), self.denom.to_i64()) {
                    (Some(numer), Some(denom)) => ratio_to_f64(
                        <i128 as From<_>>::from(numer),
                        <i128 as From<_>>::from(denom),
                    ),
                    _ => {
                        let numer: BigInt = self.numer.to_bigint()?;
                        let denom: BigInt = self.denom.to_bigint()?;
                        ratio_to_f64(numer, denom)
                    }
                };
                if float.is_nan() {
                    None
                } else {
                    Some(float)
                }
            }
        }

        trait Bits
        {
            fn bits(&self) -> u64;
        }
        
        impl Bits for BigInt
        {
            fn bits(&self) -> u64 {
                self.bits()
            }
        }

        impl Bits for i128
        {
            fn bits(&self) -> u64 {
                (128 - self.wrapping_abs().leading_zeros()).into()
            }
        }
        /// Converts a ratio of `T` to an f64.
        fn ratio_to_f64<T: Bits + Clone + Integer + Signed + ShlAssign<usize> + ToPrimitive>(
            numer: T,
            denom: T,
        ) -> f64 {
            use ::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, MIN_EXP, RADIX};

            assert_eq!(
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
            );

           
            const MAX_EXACT_INT: i64 = 1i64 << MANTISSA_DIGITS;
            const MIN_EXACT_INT: i64 = -MAX_EXACT_INT;

            let flo_sign = numer.signum().to_f64().unwrap() / denom.signum().to_f64().unwrap();
            if !flo_sign.is_normal() {
                return flo_sign;
            }

           
           
           
            if let (Some(n), Some(d)) = (numer.to_i64(), denom.to_i64()) {
                let exact = MIN_EXACT_INT..=MAX_EXACT_INT;
                if exact.contains(&n) && exact.contains(&d) {
                    return n.to_f64().unwrap() / d.to_f64().unwrap();
                }
            }

           
           
           
           
            let mut numer = numer.abs();
            let mut denom = denom.abs();
            let (is_diff_positive, absolute_diff) = match numer.bits().checked_sub(denom.bits()) {
                Some(diff) => (true, diff),
                None => (false, denom.bits() - numer.bits()),
            };

           
           
            if is_diff_positive && absolute_diff > MAX_EXP as u64 {
                return INFINITY * flo_sign;
            }
            if !is_diff_positive && absolute_diff > -MIN_EXP as u64 + MANTISSA_DIGITS as u64 + 1 {
                return 0.0 * flo_sign;
            }
            let diff = if is_diff_positive {
                absolute_diff.to_isize().unwrap()
            } else {
                -absolute_diff.to_isize().unwrap()
            };

           
           
            let shift: isize = diff.max(MIN_EXP as isize) - MANTISSA_DIGITS as isize - 2;
            if shift >= 0 {
                denom <<= shift as usize
            } else {
                numer <<= -shift as usize
            };

            let (quotient, remainder) = numer.div_rem(&denom);

           
            let mut quotient = quotient.to_u64().unwrap();
            let n_rounding_bits = {
                let quotient_bits = 64 - quotient.leading_zeros() as isize;
                let subnormal_bits = MIN_EXP as isize - shift;
                quotient_bits.max(subnormal_bits) - MANTISSA_DIGITS as isize
            } as usize;
            debug_assert!(n_rounding_bits == 2 || n_rounding_bits == 3);
            let rounding_bit_mask = (1u64 << n_rounding_bits) - 1;

           
           
            let ls_bit = quotient & (1u64 << n_rounding_bits) != 0;
            let ms_rounding_bit = quotient & (1u64 << (n_rounding_bits - 1)) != 0;
            let ls_rounding_bits = quotient & (rounding_bit_mask >> 1) != 0;
            if ms_rounding_bit && (ls_bit || ls_rounding_bits || !remainder.is_zero()) {
                quotient += 1u64 << n_rounding_bits;
            }
            quotient &= !rounding_bit_mask;

           
           
            let q_float = quotient as f64 * flo_sign;
            ldexp(q_float, shift as i32)
        }
        /// Multiply `x` by 2 to the power of `exp`. Returns an accurate result even if `2^exp` is not representable.
        fn ldexp(x: f64, exp: i32) -> f64
        {
            use ::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, RADIX};

            assert_eq!(
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
            );

            const EXPONENT_MASK: u64 = 0x7ff << 52;
            const MAX_UNSIGNED_EXPONENT: i32 = 0x7fe;
            const MIN_SUBNORMAL_POWER: i32 = MANTISSA_DIGITS as i32;

            if x.is_zero() || x.is_infinite() || x.is_nan() {
                return x;
            }

           
            if exp > 3 * MAX_EXP {
                return INFINITY * x.signum();
            } else if exp < -3 * MAX_EXP {
                return 0.0 * x.signum();
            }

           
            let (bits, curr_exp) = if !x.is_normal() {
               
               
                let normal_x = x * 2f64.powi(MIN_SUBNORMAL_POWER);
                let bits = normal_x.to_bits();
               
                (
                    bits,
                    ((bits & EXPONENT_MASK) >> 52) as i32 - MIN_SUBNORMAL_POWER,
                )
            } else {
                let bits = x.to_bits();
                let curr_exp = (bits & EXPONENT_MASK) >> 52;
               
                (bits, curr_exp as i32)
            };

           
           
            let new_exp = curr_exp + exp;

            if new_exp > MAX_UNSIGNED_EXPONENT {
                INFINITY * x.signum()
            } else if new_exp > 0 {
               
                let new_bits = (bits & !EXPONENT_MASK) | ((new_exp as u64) << 52);
                f64::from_bits(new_bits)
            } else if new_exp >= -(MANTISSA_DIGITS as i32) {
               
               
               
               
                let new_exp = new_exp + MIN_SUBNORMAL_POWER;
                debug_assert!(new_exp >= 0);
                let new_bits = (bits & !EXPONENT_MASK) | ((new_exp as u64) << 52);
                f64::from_bits(new_bits) * 2f64.powi(-MIN_SUBNORMAL_POWER)
            } else {
               
                return 0.0 * x.signum();
            }
        }
    }
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod ops
{
    pub use std::ops::{ * };
}

pub mod option
{
    pub use std::option::{ * };
}

pub mod panic
{
    pub use std::panic::{ * };
}

pub mod path
{
    pub use std::path::{ * };
}

pub mod primitive
{
    pub use std::primitive::{ * };
}

pub mod process
{
    pub use std::process::{ * };

    pub mod macros
    {
        use ::
        {
            cmp::{ Ordering },
            error::{ Error },
            fmt::{ self, Debug, Display },
            hash::{ Hash, Hasher },
            ops::{ Range, RangeBounds },
            path::{ PathBuf },
            *,
        };
        /*
            use ::process::macros::extra::DelimSpan;
            use ::process::macros::marker::{ProcMacroAutoTraits, MARKER};
            use ::cmp::Ordering;
            use ::fmt::{self, Debug, Display};
            use ::hash::{Hash, Hasher};
            use ::ops::Range;
            use ::ops::RangeBounds;
            use ::str::FromStr;
            use ::error::Error;
            use ::ffi::CStr;
            use ::path::PathBuf;
            pub use ::process::macros::location::LineColumn;
        */        
        pub mod detection
        {
            use ::
            {
                sync::
                {
                    atomic::{ AtomicUsize, Ordering },
                    Once
                },
                *,
            };
            /*
            */
            static WORKS: AtomicUsize = AtomicUsize::new(0);
            static INIT: Once = Once::new();

            pub fn inside_proc_macro() -> bool
            {
                match WORKS.load(Ordering::Relaxed)
                {
                    1 => return false,
                    2 => return true,
                    _ =>
                    {}
                }

                INIT.call_once(initialize);
                inside_proc_macro()
            }

            pub fn force_fallback() { WORKS.store(1, Ordering::Relaxed); }

            pub fn unforce_fallback() { initialize(); }
            
            #[allow(deprecated)]
            fn initialize()
            {
                use ::panic::{self, PanicInfo};

                type PanicHook = dyn Fn(&PanicInfo) + Sync + Send + 'static;

                let null_hook: Box<PanicHook> = Box::new(|_panic_info| { /* ignore */ });
                let sanity_check = &*null_hook as *const PanicHook;
                let original_hook = panic::take_hook();
                panic::set_hook(null_hook);

                let works = panic::catch_unwind(proc_macro::Span::call_site).is_ok();
                WORKS.store(works as usize + 1, Ordering::Relaxed);

                let hopefully_null_hook = panic::take_hook();
                panic::set_hook(original_hook);
                if sanity_check != &*hopefully_null_hook
                {
                    panic!("observed race condition in process::macros::inside_proc_macro");
                }
            }
        }

        pub mod extra
        {
            use ::
            {
                fmt::{ self, Debug },
                process::macros::
                {
                    fallback, imp, Span, 
                },
                marker::{ ProcMacroAutoTraits, MARKER },
                *,
            };
            /*
            */
            /// Invalidate any `process::macros::Span` that exist on the current thread.
            pub fn invalidate_current_thread_spans()
            {
                ::process::macros::imp::invalidate_current_thread_spans();
            }
            /// An object that holds a [`Group`]'s `span_open()` and `span_close()` together
            /// in a more compact representation than holding those 2 spans individually.
            #[derive(Copy, Clone)]
            pub struct DelimSpan 
            {
                inner: DelimSpanEnum,
                _marker: ProcMacroAutoTraits,
            }

            #[derive(Copy, Clone)]
            enum DelimSpanEnum 
            {
                    Compiler {
                    join: proc_macro::Span,
                    open: proc_macro::Span,
                    close: proc_macro::Span,
                },
                Fallback(fallback::Span),
            }

            impl DelimSpan
            {
                pub fn new(group: &imp::Group) -> Self
               
                {
                    let inner = match group
                    {
                        imp::Group::Compiler(group) => DelimSpanEnum::Compiler
                        {
                            join: group.span(),
                            open: group.span_open(),
                            close: group.span_close(),
                        },
                        imp::Group::Fallback(group) => DelimSpanEnum::Fallback(group.span()),
                    };

                    DelimSpan
                    {
                        inner,
                        _marker: marker::MARKER,
                    }
                }
                /// Returns a span covering the entire delimited group.
                pub fn join( &self ) -> Span
                {
                    match &self.inner
                    {
                        DelimSpanEnum::Compiler { join, .. } => Span::_new(imp::Span::Compiler(*join)),
                        DelimSpanEnum::Fallback(span) => Span::_new_fallback(*span),
                    }
                }
                /// Returns a span for the opening punctuation of the group only.
                pub fn open( &self ) -> Span
                {
                    match &self.inner
                    {
                        DelimSpanEnum::Compiler { open, .. } => Span::_new(imp::Span::Compiler(*open)),
                        DelimSpanEnum::Fallback(span) => Span::_new_fallback(span.first_byte()),
                    }
                }
                /// Returns a span for the closing punctuation of the group only.
                pub fn close( &self ) -> Span
                {
                    match &self.inner
                    {
                        DelimSpanEnum::Compiler { close, .. } => Span::_new(imp::Span::Compiler(*close)),
                        DelimSpanEnum::Fallback(span) => Span::_new_fallback(span.last_byte()),
                    }
                }
            }

            impl Debug for DelimSpan           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    Debug::fmt(&self.join(), f)
                }
            }
        }
        
        pub mod fallback
        {
            use ::
            {
                cell::{ RefCell },
                collections::{ BTreeMap },
                convert::{ TryFrom },
                cmp::{ Ordering },
                fmt::{ self, Debug, Display, Write },
                ffi::{ CStr },
                mem::{ ManuallyDrop },
                ops::{ Range, RangeBounds },
                path::{ PathBuf },
                process::macros::
                {
                    location::LineColumn,
                    parse::{self, Cursor},
                    rcvec::{RcVec, RcVecBuilder, RcVecIntoIter, RcVecMut},
                    imp, Delimiter, Spacing, TokenTree,
                },
                str::{ FromStr },
                *,
            };
            /*
            */
            macro_rules! suffixed_numbers
            {
                ($($name:ident => $kind:ident,)*) => 
                ($(
                    pub fn $name(n: $kind) -> Literal 
                    {
                        Literal::_new(format!(concat!("{}", stringify!($kind)), n))
                    }
                )*)
            }

            macro_rules! unsuffixed_numbers
            {
                ($($name:ident => $kind:ident,)*) => 
                ($(
                    pub fn $name(n: $kind) -> Literal { Literal::_new(n.to_string()) }
                )*)
            }
            /// Force use of proc-macro2's fallback for now, even if the compiler's implementation is available.
            pub fn force()
            {
                ::process::macros::detection::force_fallback();
            }
            /// Resume using the compiler's implementation of the proc macro API if it is available.
            pub fn unforce()
            {
                ::process::macros::detection::unforce_fallback();
            }

            #[derive(Clone)]
            pub struct TokenStream 
            {
                inner: RcVec<TokenTree>,
            }

            #[derive(Debug)]
            pub struct LexError 
            {
                pub span: Span,
            }

            impl LexError           
            {
                pub fn span( &self ) -> Span { self.span }
                pub fn call_site() -> Self
                {
                    LexError
                    {
                        span: Span::call_site(),
                    }
                }
            }

            impl TokenStream
            {
                pub fn new() -> Self
                {
                    TokenStream
                    {
                        inner: RcVecBuilder::new().build(),
                    }
                }

                pub fn from_str_checked(src: &str) -> Result<Self, LexError>
               
                {
                    let mut cursor = get_cursor(src);
                    const BYTE_ORDER_MARK: &str = "\u{feff}";
                    if cursor.starts_with(BYTE_ORDER_MARK) {
                        cursor = cursor.advance(BYTE_ORDER_MARK.len());
                    }

                    parse::token_stream(cursor)
                }
                
                pub fn from_str_unchecked(src: &str) -> Self {
                    Self::from_str_checked(src).unwrap()
                }

                pub fn is_empty( &self ) -> bool
                {
                    self.inner.len() == 0
                }

                fn take_inner( self ) -> RcVecBuilder<TokenTree>
                {
                    let nodrop = ManuallyDrop::new( self );
                    unsafe { ptr::read(&nodrop.inner) }.make_owned()
                }
            }

            fn push_token_from_proc_macro(mut vec: RcVecMut<TokenTree>, token: TokenTree)
            {
                match token
                {
                    TokenTree::Literal
                    (
                        ::process::macros::Literal
                        {
                            inner: ::process::macros::imp::Literal::Fallback(literal),
                            _marker: marker::ProcMacroAutoTraits(_),
                        }
                    ) if literal.repr.starts_with('-') =>
                    {
                        push_negative_literal(vec, literal);
                    }
                    _ => vec.push(token),
                }

                #[cold] fn push_negative_literal(mut vec: RcVecMut<TokenTree>, mut literal: Literal)
                {
                    literal.repr.remove(0);
                    let mut punct = ::process::macros::Punct::new('-', Spacing::Alone);
                    punct.set_span(::process::macros::Span::_new_fallback(literal.span));
                    vec.push(TokenTree::Punct(punct));
                    vec.push(TokenTree::Literal(::process::macros::Literal::_new_fallback(literal)));
                }
            }
            
            impl Drop for TokenStream           
            {
                fn drop( &mut self )
                {
                    let mut stack = Vec::new();
                    let mut current = match self.inner.get_mut() {
                        Some(inner) => inner.take().into_iter(),
                        None => return,
                    };
                    loop {
                        while let Some(token) = current.next() {
                            let group = match token {
                                TokenTree::Group(group) => group.inner,
                                _ => continue,
                            };
                                            let group = match group {
                                ::process::macros::imp::Group::Fallback(group) => group,
                                ::process::macros::imp::Group::Compiler(_) => continue,
                            };
                            let mut group = group;
                            if let Some(inner) = group.stream.inner.get_mut() {
                                stack.push(current);
                                current = inner.take().into_iter();
                            }
                        }
                        match stack.pop() {
                            Some(next) => current = next,
                            None => return,
                        }
                    }
                }
            }

            pub struct TokenStreamBuilder {
                inner: RcVecBuilder<TokenTree>,
            }

            impl TokenStreamBuilder
            {
                pub fn new() -> Self {
                    TokenStreamBuilder {
                        inner: RcVecBuilder::new(),
                    }
                }

                pub fn with_capacity(cap: usize) -> Self {
                    TokenStreamBuilder {
                        inner: RcVecBuilder::with_capacity(cap),
                    }
                }

                pub fn push_token_from_parser(&mut self, tt: TokenTree) {
                    self.inner.push(tt);
                }

                pub fn build( self ) -> TokenStream {
                    TokenStream {
                        inner: self.inner.build(),
                    }
                }
            }
            
            fn get_cursor(src: &str) -> Cursor<'_>
            {
                SOURCE_MAP.with(|sm|
               
                {
                    let mut sm = sm.borrow_mut();
                    let span = sm.add_file(src);
                    Cursor {
                        rest: src,
                        off: span.lo,
                    }
                })
            }

            impl Display for LexError
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {    f.write_str("cannot parse string into token stream")
                }
            }

            impl Display for TokenStream
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    let mut joint = false;
                    for (i, tt) in self.inner.iter().enumerate() {
                        if i != 0 && !joint {
                            write!(f, " ")?;
                        }
                        joint = false;
                        match tt {
                            TokenTree::Group(tt) => Display::fmt(tt, f),
                            TokenTree::Ident(tt) => Display::fmt(tt, f),
                            TokenTree::Punct(tt) =>
                    {
                                joint = tt.spacing() == Spacing::Joint;
                                Display::fmt(tt, f)
                            }
                            TokenTree::Literal(tt) => Display::fmt(tt, f),
                        }?;
                    }

                    Ok(())
                }
            }

            impl Debug for TokenStream
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {    f.write_str("TokenStream ")?;
                    f.debug_list().entries(self.clone()).finish()
                }
            }
            
            impl From<proc_macro::TokenStream> for TokenStream
            {
                fn from(inner: proc_macro::TokenStream) -> Self {
                    TokenStream::from_str_unchecked(&inner.to_string())
                }
            }
            
            impl From<TokenStream> for proc_macro::TokenStream
            {
                fn from(inner: TokenStream) -> Self {
                    proc_macro::TokenStream::from_str_unchecked(&inner.to_string())
                }
            }

            impl From<TokenTree> for TokenStream
            {
                fn from(tree: TokenTree) -> Self
                {
                    let mut stream = RcVecBuilder::new();
                    push_token_from_proc_macro(stream.as_mut(), tree);
                    TokenStream {
                        inner: stream.build(),
                    }
                }
            }

            impl iter::FromIterator<TokenTree> for TokenStream
            {
                fn from_iter<I: IntoIterator<Item = TokenTree>>(tokens: I) -> Self
                {
                    let mut stream = TokenStream::new();
                    stream.extend(tokens);
                    stream
                }
            }

            impl iter::FromIterator<TokenStream> for TokenStream
            {
                fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self
                {
                    let mut v = RcVecBuilder::new();

                    for stream in streams {
                        v.extend(stream.take_inner());
                    }

                    TokenStream { inner: v.build() }
                }
            }

            impl Extend<TokenTree> for TokenStream
            {
                fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, tokens: I)
                {
                    let mut vec = self.inner.make_mut();
                    tokens
                        .into_iter()
                        .for_each(|token| push_token_from_proc_macro(vec.as_mut(), token));
                }
            }

            impl Extend<TokenStream> for TokenStream
            {
                fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I) {
                    self.inner.make_mut().extend(streams.into_iter().flatten());
                }
            }

            pub type TokenTreeIter = RcVecIntoIter<TokenTree>;

            impl IntoIterator for TokenStream {
                type Item = TokenTree;
                type IntoIter = TokenTreeIter;
                fn into_iter( self ) -> TokenTreeIter {
                    self.take_inner().into_iter()
                }
            }

            thread_local! {
                static SOURCE_MAP: RefCell<SourceMap> = RefCell::new(SourceMap {
                   
                   
                    files: vec![FileInfo {
                        source_text: String::new(),
                        span: Span { lo: 0, hi: 0 },
                        lines: vec![0],
                        char_index_to_byte_offset: BTreeMap::new(),
                    }],
                });
            }

            pub fn invalidate_current_thread_spans() {
                #[cfg(not(fuzzing))]
                SOURCE_MAP.with(|sm| sm.borrow_mut().files.truncate(1));
            }

            struct FileInfo {
                source_text: String,
                span: Span,
                lines: Vec<usize>,
                char_index_to_byte_offset: BTreeMap<usize, usize>,
            }

            impl FileInfo
            {
                fn offset_line_column( &self, offset: usize) -> LineColumn {
                    assert!(self.span_within(Span {
                        lo: offset as u32,
                        hi: offset as u32,
                    }));
                    let offset = offset - self.span.lo as usize;
                    match self.lines.binary_search(&offset) {
                        Ok(found) => LineColumn {
                            line: found + 1,
                            column: 0,
                        },
                        Err(idx) => LineColumn {
                            line: idx,
                            column: offset - self.lines[idx - 1],
                        },
                    }
                }

                fn span_within( &self, span: Span) -> bool
        {
                    span.lo >= self.span.lo && span.hi <= self.span.hi
                }

                fn byte_range(&mut self, span: Span) -> Range<usize>
                {
                    let lo_char = (span.lo - self.span.lo) as usize;

                   
                   
                   
                    let (&last_char_index, &last_byte_offset) = self
                        .char_index_to_byte_offset
                        .range(..=lo_char)
                        .next_back()
                        .unwrap_or((&0, &0));

                    let lo_byte = if last_char_index == lo_char {
                        last_byte_offset
                    } else {
                        let total_byte_offset = match self.source_text[last_byte_offset..]
                            .char_indices()
                            .nth(lo_char - last_char_index)
                        {
                            Some((additional_offset, _ch)) => last_byte_offset + additional_offset,
                            None => self.source_text.len(),
                        };
                        self.char_index_to_byte_offset
                            .insert(lo_char, total_byte_offset);
                        total_byte_offset
                    };

                    let trunc_lo = &self.source_text[lo_byte..];
                    let char_len = (span.hi - span.lo) as usize;
                    lo_byte..match trunc_lo.char_indices().nth(char_len) {
                        Some((offset, _ch)) => lo_byte + offset,
                        None => self.source_text.len(),
                    }
                }

                fn source_text(&mut self, span: Span) -> String
                {
                    let byte_range = self.byte_range(span);
                    self.source_text[byte_range].to_owned()
                }
            }
            /// Computes the offsets of each line in the given source string and the total number of characters
            fn lines_offsets(s: &str) -> (usize, Vec<usize>)
            {
                let mut lines = vec![0];
                let mut total = 0;

                for ch in s.chars() {
                    total += 1;
                    if ch == '\n' {
                        lines.push(total);
                    }
                }

                (total, lines)
            }

            struct SourceMap {
                files: Vec<FileInfo>,
            }

            impl SourceMap
            {
                fn next_start_pos( &self ) -> u32 {

                   
                   
                    self.files.last().unwrap().span.hi + 1
                }

                fn add_file(&mut self, src: &str) -> Span
                {
                    let (len, lines) = lines_offsets(src);
                    let lo = self.next_start_pos();
                    let span = Span {
                        lo,
                        hi: lo + (len as u32),
                    };

                    self.files.push(FileInfo {
                        source_text: src.to_owned(),
                        span,
                        lines,
                       
                        char_index_to_byte_offset: BTreeMap::new(),
                    });

                    span
                }

                fn find( &self, span: Span) -> usize {
                    match self.files.binary_search_by(|file| {
                        if file.span.hi < span.lo {
                            Ordering::Less
                        } else if file.span.lo > span.hi {
                            Ordering::Greater
                        } else {
                            assert!(file.span_within(span));
                            Ordering::Equal
                        }
                    }) {
                        Ok(i) => i,
                        Err(_) => unreachable!("Invalid span with no related FileInfo!"),
                    }
                }

                fn filepath( &self, span: Span) -> String
                {
                    let i = self.find(span);
                    if i == 0 {
                        "<unspecified>".to_owned()
                    } else {
                        format!("<parsed string {}>", i)
                    }
                }

                fn fileinfo( &self, span: Span) -> &FileInfo
                {
                    let i = self.find(span);
                    &self.files[i]
                }

                fn fileinfo_mut(&mut self, span: Span) -> &mut FileInfo
                {
                    let i = self.find(span);
                    &mut self.files[i]
                }
            }

            #[derive(Clone, Copy, PartialEq, Eq)]
            pub struct Span {
                    pub lo: u32,
                    pub hi: u32,
            }

            impl Span 
            {
                pub fn call_site() -> Self {
                    Span { lo: 0, hi: 0 }
                }

                pub fn mixed_site() -> Self {
                    Span::call_site()
                }
                
                pub fn def_site() -> Self {
                    Span::call_site()
                }

                pub fn resolved_at( &self, _other: Span) -> Span {
                    *self
                }

                pub fn located_at( &self, other: Span) -> Span {
                    other
                }

                pub fn byte_range( &self ) -> Range<usize>
                    {
                    #[cfg(fuzzing)]
                    return 0..0;

                    #[cfg(not(fuzzing))]
                    {
                        if self.is_call_site() {
                            0..0
                        } else {
                            SOURCE_MAP.with(|sm| sm.borrow_mut().fileinfo_mut(*self).byte_range(*self))
                        }
                    }
                }

                pub fn start( &self ) -> LineColumn {
                    #[cfg(fuzzing)]
                    return LineColumn { line: 0, column: 0 };

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                        let fi = sm.fileinfo(*self);
                        fi.offset_line_column(self.lo as usize)
                    })
                }

                pub fn end( &self ) -> LineColumn {
                    #[cfg(fuzzing)]
                    return LineColumn { line: 0, column: 0 };

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                        let fi = sm.fileinfo(*self);
                        fi.offset_line_column(self.hi as usize)
                    })
                }

                pub fn file( &self ) -> String {
                    #[cfg(fuzzing)]
                    return "<unspecified>".to_owned();

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                        sm.filepath(*self)
                    })
                }

                pub fn local_file( &self ) -> Option<PathBuf>
                    {
                    None
                }

                pub fn join( &self, other: Span) -> Option<Span>
                    {
                    #[cfg(fuzzing)]
                    return {
                        let _ = other;
                        None
                    };

                    #[cfg(not(fuzzing))]
                    SOURCE_MAP.with(|sm| {
                        let sm = sm.borrow();
                       
                        if !sm.fileinfo(*self).span_within(other) {
                            return None;
                        }
                        Some(Span {
                            lo: cmp::min(self.lo, other.lo),
                            hi: cmp::max(self.hi, other.hi),
                        })
                    })
                }
                
                pub fn source_text( &self ) -> Option<String>
                    {
                    #[cfg(fuzzing)]
                    return None;

                    #[cfg(not(fuzzing))]
                    {
                        if self.is_call_site() {
                            None
                        } else {
                            Some(SOURCE_MAP.with(|sm| sm.borrow_mut().fileinfo_mut(*self).source_text(*self)))
                        }
                    }
                }
                
                pub fn first_byte( self ) -> Self {
                    Span {
                        lo: self.lo,
                        hi: cmp::min(self.lo.saturating_add(1), self.hi),
                    }
                }

                pub fn last_byte( self ) -> Self {
                    Span {
                        lo: cmp::max(self.hi.saturating_sub(1), self.lo),
                        hi: self.hi,
                    }
                }
                
                fn is_call_site( &self ) -> bool
        {
                    self.lo == 0 && self.hi == 0
                }
            }

            impl Debug for Span
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {            return write!(f, "bytes({}..{})", self.lo, self.hi);

                }
            }

            pub fn debug_span_field_if_nontrivial(debug: &mut fmt::DebugStruct, span: Span) {
                    {
                    if span.is_call_site() {
                        return;
                    }
                }

                if cfg!(span_locations) {
                    debug.field("span", &span);
                }
            }

            #[derive(Clone)]
            pub struct Group {
                delimiter: Delimiter,
                stream: TokenStream,
                span: Span,
            }

            impl Group
            {
                pub fn new(delimiter: Delimiter, stream: TokenStream) -> Self {
                    Group {
                        delimiter,
                        stream,
                        span: Span::call_site(),
                    }
                }

                pub fn delimiter( &self ) -> Delimiter {
                    self.delimiter
                }

                pub fn stream( &self ) -> TokenStream {
                    self.stream.clone()
                }

                pub fn span( &self ) -> Span {
                    self.span
                }

                pub fn span_open( &self ) -> Span {
                    self.span.first_byte()
                }

                pub fn span_close( &self ) -> Span {
                    self.span.last_byte()
                }

                pub fn set_span(&mut self, span: Span) {
                    self.span = span;
                }
            }

            impl Display for Group 
            {
               
               
               
               
               
               
               
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    let (open, close) = match self.delimiter {
                        Delimiter::Parenthesis => ("(", ")"),
                        Delimiter::Brace => ("{ ", "}"),
                        Delimiter::Bracket => ("[", "]"),
                        Delimiter::None => ("", ""),
                    };

                    f.write_str(open)?;
                    Display::fmt(&self.stream, f)?;
                    /*
                    if self.delimiter == Delimiter::Brace && !self.stream.inner.is_empty() {
                        f.write_str(" ")?;
                    } */
                    f.write_str(close)?;

                    Ok(())
                }
            }

            impl Debug for Group
            {
                fn fmt( &self, fmt: &mut fmt::Formatter) -> fmt::Result
                {
                    let mut debug = fmt.debug_struct("Group");
                    debug.field("delimiter", &self.delimiter);
                    debug.field("stream", &self.stream);
                    debug_span_field_if_nontrivial(&mut debug, self.span);
                    debug.finish()
                }
            }

            #[derive(Clone)]
            pub struct Ident 
            {
                sym: Box<str>,
                span: Span,
                raw: bool,
            }

            impl Ident 
            {
                #[track_caller]
                pub fn new_checked(string: &str, span: Span) -> Self {
                    validate_ident(string);
                    Ident::new_unchecked(string, span)
                }

                pub fn new_unchecked(string: &str, span: Span) -> Self {
                    Ident {
                        sym: Box::from(string),
                        span,
                        raw: false,
                    }
                }

                #[track_caller]
                pub fn new_raw_checked(string: &str, span: Span) -> Self {
                    validate_ident_raw(string);
                    Ident::new_raw_unchecked(string, span)
                }

                pub fn new_raw_unchecked(string: &str, span: Span) -> Self {
                    Ident {
                        sym: Box::from(string),
                        span,
                        raw: true,
                    }
                }

                pub fn span( &self ) -> Span {
                    self.span
                }

                pub fn set_span(&mut self, span: Span) {
                    self.span = span;
                }
            }

            #[track_caller] fn validate_ident(string: &str) {
                if string.is_empty() {
                    panic!("Ident is not allowed to be empty; use Option<Ident>");
                }

                if string.bytes().all(|digit| b'0' <= digit && digit <= b'9') {
                    panic!("Ident cannot be a number; use Literal instead");
                }

                fn ident_ok(string: &str) -> bool
                {
                    let mut chars = string.chars();
                    let first = chars.next().unwrap();
                    if !::is::ident_start(first) {
                        return false;
                    }
                    for ch in chars {
                        if !::is::ident_continue(ch) {
                            return false;
                        }
                    }
                    true
                }

                if !ident_ok(string) {
                    panic!("{:?} is not a valid Ident", string);
                }
            }

            #[track_caller] fn validate_ident_raw(string: &str) {
                validate_ident(string);

                match string {
                    "_" | "super" | "self" | "Self" | "crate" =>
                    {
                        panic!("`r#{}` cannot be a raw identifier", string);
                    }
                    _ =>
                    {}
                }
            }

            impl PartialEq for Ident
            {
                fn eq( &self, other: &Ident) -> bool
        {
                    self.sym == other.sym && self.raw == other.raw
                }
            }

            impl<T> PartialEq<T> for Ident where
            T: ?Sized + AsRef<str>
            {
                fn eq( &self, other: &T) -> bool
                {
                    let other = other.as_ref();
                    if self.raw {
                        other.starts_with("r#") && *self.sym == other[2..]
                    } else {
                        *self.sym == *other
                    }
                }
            }

            impl Display for Ident
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {    if self.raw {
                        f.write_str("r#")?;
                    }
                    Display::fmt(&self.sym, f)
                }
            }
            
            impl Debug for Ident
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
               
                {
                    let mut debug = f.debug_struct("Ident");
                    debug.field("sym", &format_args!("{}", self));
                    debug_span_field_if_nontrivial(&mut debug, self.span);
                    debug.finish()
                }
            }

            #[derive(Clone)]
            pub struct Literal {
                pub repr: String,
                span: Span,
            }

            impl Literal
            {
                pub fn _new(repr: String) -> Self {
                    Literal {
                        repr,
                        span: Span::call_site(),
                    }
                }

                pub fn from_str_checked(repr: &str) -> Result<Self, LexError>
                {
                    let mut cursor = get_cursor(repr);
                            let lo = cursor.off;

                    let negative = cursor.starts_with_char('-');
                    if negative {
                        cursor = cursor.advance(1);
                        if !cursor.starts_with_fn(|ch| ch.is_ascii_digit()) {
                            return Err(LexError::call_site());
                        }
                    }

                    if let Ok((rest, mut literal)) = parse::literal(cursor) {
                        if rest.is_empty() {
                            if negative {
                                literal.repr.insert(0, '-');
                            }
                            literal.span = Span {
                                                    lo,
                                                    hi: rest.off,
                            };
                            return Ok(literal);
                        }
                    }
                    Err(LexError::call_site())
                }

                pub unsafe fn from_str_unchecked(repr: &str) -> Self {
                    Literal::_new(repr.to_owned())
                }

                suffixed_numbers! {
                    u8_suffixed => u8,
                    u16_suffixed => u16,
                    u32_suffixed => u32,
                    u64_suffixed => u64,
                    u128_suffixed => u128,
                    usize_suffixed => usize,
                    i8_suffixed => i8,
                    i16_suffixed => i16,
                    i32_suffixed => i32,
                    i64_suffixed => i64,
                    i128_suffixed => i128,
                    isize_suffixed => isize,

                    f32_suffixed => f32,
                    f64_suffixed => f64,
                }

                unsuffixed_numbers! {
                    u8_unsuffixed => u8,
                    u16_unsuffixed => u16,
                    u32_unsuffixed => u32,
                    u64_unsuffixed => u64,
                    u128_unsuffixed => u128,
                    usize_unsuffixed => usize,
                    i8_unsuffixed => i8,
                    i16_unsuffixed => i16,
                    i32_unsuffixed => i32,
                    i64_unsuffixed => i64,
                    i128_unsuffixed => i128,
                    isize_unsuffixed => isize,
                }

                pub fn f32_unsuffixed(f: f32) -> Literal
                {
                    let mut s = f.to_string();
                    if !s.contains('.') {
                        s.push_str(".0");
                    }
                    Literal::_new(s)
                }

                pub fn f64_unsuffixed(f: f64) -> Literal
                {
                    let mut s = f.to_string();
                    if !s.contains('.') {
                        s.push_str(".0");
                    }
                    Literal::_new(s)
                }

                pub fn string(string: &str) -> Literal
                {
                    let mut repr = String::with_capacity(string.len() + 2);
                    repr.push('"');
                    escape_utf8(string, &mut repr);
                    repr.push('"');
                    Literal::_new(repr)
                }

                pub fn character(ch: char) -> Literal
                {
                    let mut repr = String::new();
                    repr.push('\'');
                    if ch == '"' {
                       
                        repr.push(ch);
                    } else {
                        repr.extend(ch.escape_debug());
                    }
                    repr.push('\'');
                    Literal::_new(repr)
                }

                pub fn byte_character(byte: u8) -> Literal
                {
                    let mut repr = "b'".to_string();
                    #[allow(clippy::match_overlapping_arm)]
                    match byte {
                        b'\0' => repr.push_str(r"\0"),
                        b'\t' => repr.push_str(r"\t"),
                        b'\n' => repr.push_str(r"\n"),
                        b'\r' => repr.push_str(r"\r"),
                        b'\'' => repr.push_str(r"\'"),
                        b'\\' => repr.push_str(r"\\"),
                        b'\x20'..=b'\x7E' => repr.push(byte as char),
                        _ =>
                    {
                            let _ = write!(repr, r"\x{:02X}", byte);
                        }
                    }
                    repr.push('\'');
                    Literal::_new(repr)
                }

                pub fn byte_string(bytes: &[u8]) -> Literal
                {
                    let mut repr = "b\"".to_string();
                    let mut bytes = bytes.iter();
                    while let Some(&b) = bytes.next() {
                        #[allow(clippy::match_overlapping_arm)]
                        match b {
                            b'\0' => repr.push_str(match bytes.as_slice().first() {
                               
                                Some(b'0'..=b'7') => r"\x00",
                                _ => r"\0",
                            }),
                            b'\t' => repr.push_str(r"\t"),
                            b'\n' => repr.push_str(r"\n"),
                            b'\r' => repr.push_str(r"\r"),
                            b'"' => repr.push_str("\\\""),
                            b'\\' => repr.push_str(r"\\"),
                            b'\x20'..=b'\x7E' => repr.push(b as char),
                            _ =>
                    {
                                let _ = write!(repr, r"\x{:02X}", b);
                            }
                        }
                    }
                    repr.push('"');
                    Literal::_new(repr)
                }

                pub fn c_string(string: &CStr) -> Literal
                {
                    let mut repr = "c\"".to_string();
                    let mut bytes = string.to_bytes();
                    while !bytes.is_empty() {
                        let (valid, invalid) = match str::from_utf8(bytes) {
                            Ok(all_valid) =>
                    {
                                bytes = b"";
                                (all_valid, bytes)
                            }
                            Err(utf8_error) =>
                    {
                                let (valid, rest) = bytes.split_at(utf8_error.valid_up_to());
                                let valid = str::from_utf8(valid).unwrap();
                                let invalid = utf8_error
                                    .error_len()
                                    .map_or(rest, |error_len| &rest[..error_len]);
                                bytes = &bytes[valid.len() + invalid.len()..];
                                (valid, invalid)
                            }
                        };
                        escape_utf8(valid, &mut repr);
                        for &byte in invalid {
                            let _ = write!(repr, r"\x{:02X}", byte);
                        }
                    }
                    repr.push('"');
                    Literal::_new(repr)
                }

                pub fn span( &self ) -> Span {
                    self.span
                }

                pub fn set_span(&mut self, span: Span) {
                    self.span = span;
                }

                pub fn subspan<R: RangeBounds<usize>>( &self, range: R) -> Option<Span> 
                {
                    use ::ops::Bound;

                    let lo = match range.start_bound() {
                        Bound::Included(start) =>
                    {
                            let start = u32::try_from(*start).ok()?;
                            self.span.lo.checked_add(start)?
                        }
                        Bound::Excluded(start) =>
                    {
                            let start = u32::try_from(*start).ok()?;
                            self.span.lo.checked_add(start)?.checked_add(1)?
                        }
                        Bound::Unbounded => self.span.lo,
                    };
                    let hi = match range.end_bound() {
                        Bound::Included(end) =>
                    {
                            let end = u32::try_from(*end).ok()?;
                            self.span.lo.checked_add(end)?.checked_add(1)?
                        }
                        Bound::Excluded(end) =>
                    {
                            let end = u32::try_from(*end).ok()?;
                            self.span.lo.checked_add(end)?
                        }
                        Bound::Unbounded => self.span.hi,
                    };
                    if lo <= hi && hi <= self.span.hi {
                        Some(Span { lo, hi })
                    } else {
                        None
                    }
                }
            }

            impl Display for Literal
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {    Display::fmt(&self.repr, f)
                }
            }

            impl Debug for Literal
            {
                fn fmt( &self, fmt: &mut fmt::Formatter) -> fmt::Result
                {
                    let mut debug = fmt.debug_struct("Literal");
                    debug.field("lit", &format_args!("{}", self.repr));
                    debug_span_field_if_nontrivial(&mut debug, self.span);
                    debug.finish()
                }
            }
            
            pub trait FromStr2: FromStr<Err = proc_macro::LexError>
            {
                    fn valid(src: &str) -> bool;

                    fn from_str_checked(src: &str) -> Result<Self, imp::LexError>
                    {
                   
                   
                   
                    if !Self::valid(src) {
                        return Err(imp::LexError::CompilerPanic);
                    }

                   
                    match panic::catch_unwind(|| Self::from_str(src)) {
                        Ok(Ok(ok)) => Ok(ok),
                        Ok(Err(lex)) => Err(imp::LexError::Compiler(lex)),
                        Err(_panic) => Err(imp::LexError::CompilerPanic),
                    }
                }

                fn from_str_unchecked(src: &str) -> Self {
                    Self::from_str(src).unwrap()
                }
            }
            
            impl FromStr2 for proc_macro::TokenStream
            {
                fn valid(src: &str) -> bool 
                {
                    TokenStream::from_str_checked(src).is_ok()
                }
            }
            
            impl FromStr2 for proc_macro::Literal
            {
                fn valid(src: &str) -> bool 
                {
                    Literal::from_str_checked(src).is_ok()
                }
            }

            fn escape_utf8(string: &str, repr: &mut String)
            {
                let mut chars = string.chars();
                while let Some(ch) = chars.next() {
                    if ch == '\0' {
                        repr.push_str(
                            if chars
                                .as_str()
                                .starts_with(|next| '0' <= next && next <= '7')
                            {
                               
                                r"\x00"
                            } else {
                                r"\0"
                            },
                        );
                    } else if ch == '\'' {
                       
                        repr.push(ch);
                    } else {
                        repr.extend(ch.escape_debug());
                    }
                }
            }
        }
           
        pub mod imp
        {
            use ::
            {
                ffi::{ CStr },
                fmt::{ self, Debug, Display },
                ops::{ Range, RangeBounds },
                path::{ PathBuf },
                process::
                {
                    macros::
                    {
                        detection::inside_proc_macro,
                        fallback::{self, FromStr2 as _},
                        location::LineColumn,
                        probe::{ proc_macro_span, proc_macro_span_file, proc_macro_span_location },
                        Delimiter, Punct, Spacing, TokenTree,                        
                    },
                },
                *,
            };
            /*
            */
            #[derive(Clone)]
            pub enum TokenStream 
            {
                Compiler(DeferredTokenStream),
                Fallback(fallback::TokenStream),
            }

            #[derive(Clone)]
            pub struct DeferredTokenStream 
            {
                stream: proc_macro::TokenStream,
                extra: Vec<proc_macro::TokenTree>,
            }

            pub enum LexError
            {
                Compiler(proc_macro::LexError),
                Fallback(fallback::LexError),
                CompilerPanic,
            }

            #[cold] fn mismatch(line: u32) -> !
            {
                let backtrace = ::backtrace::Backtrace::force_capture();
                panic!("compiler/fallback mismatch L{}\n\n{}", line, backtrace)
            }

            impl DeferredTokenStream           
            {
                fn new(stream: proc_macro::TokenStream) -> Self
                {
                    DeferredTokenStream
                    {
                        stream,
                        extra: Vec::new(),
                    }
                }

                fn is_empty( &self ) -> bool { self.stream.is_empty() && self.extra.is_empty() }

                fn evaluate_now( &mut self )
                {
                    if !self.extra.is_empty() { self.stream.extend(self.extra.drain(..)); }
                }

                fn into_token_stream(mut self) -> proc_macro::TokenStream
                {
                    self.evaluate_now();
                    self.stream
                }
            }

            impl TokenStream           
            {
                pub fn new() -> Self
                {
                    if inside_proc_macro() {
                        TokenStream::Compiler(DeferredTokenStream::new(proc_macro::TokenStream::new()))
                    } else {
                        TokenStream::Fallback(fallback::TokenStream::new())
                    }
                }

                pub fn from_str_checked(src: &str) -> Result<Self, LexError>
                    {
                    if inside_proc_macro() {
                        Ok(TokenStream::Compiler(DeferredTokenStream::new(
                            proc_macro::TokenStream::from_str_checked(src)?,
                        )))
                    } else {
                        Ok(TokenStream::Fallback(
                            fallback::TokenStream::from_str_checked(src)?,
                        ))
                    }
                }

                pub fn is_empty( &self ) -> bool
                {
                    match self {
                        TokenStream::Compiler(tts) => tts.is_empty(),
                        TokenStream::Fallback(tts) => tts.is_empty(),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::TokenStream
                {
                    match self {
                        TokenStream::Compiler(s) => s.into_token_stream(),
                        TokenStream::Fallback(_) => mismatch(line!()),
                    }
                }

                fn unwrap_stable( self ) -> fallback::TokenStream           
                {
                    match self {
                        TokenStream::Compiler(_) => mismatch(line!()),
                        TokenStream::Fallback(s) => s,
                    }
                }
            }

            impl Display for TokenStream                  
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        TokenStream::Compiler(tts) => Display::fmt(&tts.clone().into_token_stream(), f),
                        TokenStream::Fallback(tts) => Display::fmt(tts, f),
                    }
                }
            }

            impl From<proc_macro::TokenStream> for TokenStream           
            {
                fn from(inner: proc_macro::TokenStream) -> Self
                {
                    TokenStream::Compiler(DeferredTokenStream::new(inner))
                }
            }

            impl From<TokenStream> for proc_macro::TokenStream           
            {
                fn from(inner: TokenStream) -> Self
                {
                    match inner {
                        TokenStream::Compiler(inner) => inner.into_token_stream(),
                        TokenStream::Fallback(inner) =>
                    {
                            proc_macro::TokenStream::from_str_unchecked(&inner.to_string())
                        }
                    }
                }
            }

            impl From<fallback::TokenStream> for TokenStream           
            {
                fn from(inner: fallback::TokenStream) -> Self
                {
                    TokenStream::Fallback(inner)
                }
            }
            
            fn into_compiler_token(token: TokenTree) -> proc_macro::TokenTree
            {
                match token {
                    TokenTree::Group(tt) => proc_macro::TokenTree::Group(tt.inner.unwrap_nightly()),
                    TokenTree::Punct(tt) =>
                    {
                        let spacing = match tt.spacing() {
                            Spacing::Joint => proc_macro::Spacing::Joint,
                            Spacing::Alone => proc_macro::Spacing::Alone,
                        };
                        let mut punct = proc_macro::Punct::new(tt.as_char(), spacing);
                        punct.set_span(tt.span().inner.unwrap_nightly());
                        proc_macro::TokenTree::Punct(punct)
                    }
                    TokenTree::Ident(tt) => proc_macro::TokenTree::Ident(tt.inner.unwrap_nightly()),
                    TokenTree::Literal(tt) => proc_macro::TokenTree::Literal(tt.inner.unwrap_nightly()),
                }
            }

            impl From<TokenTree> for TokenStream           
            {
                fn from(token: TokenTree) -> Self
                {
                    if inside_proc_macro() {
                        TokenStream::Compiler(DeferredTokenStream::new(proc_macro::TokenStream::from(
                            into_compiler_token(token),
                        )))
                    } else {
                        TokenStream::Fallback(fallback::TokenStream::from(token))
                    }
                }
            }

            impl iter::FromIterator<TokenTree> for TokenStream           
            {
                fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self
                {
                    if inside_proc_macro() {
                        TokenStream::Compiler(DeferredTokenStream::new(
                            trees.into_iter().map(into_compiler_token).collect(),
                        ))
                    } else {
                        TokenStream::Fallback(trees.into_iter().collect())
                    }
                }
            }

            impl iter::FromIterator<TokenStream> for TokenStream
            {
                fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self
               
                {
                    let mut streams = streams.into_iter();
                    match streams.next() {
                        Some(TokenStream::Compiler(mut first)) =>
                    {
                            first.evaluate_now();
                            first.stream.extend(streams.map(|s| match s {
                                TokenStream::Compiler(s) => s.into_token_stream(),
                                TokenStream::Fallback(_) => mismatch(line!()),
                            }));
                            TokenStream::Compiler(first)
                        }
                        Some(TokenStream::Fallback(mut first)) =>
                    {
                            first.extend(streams.map(|s| match s {
                                TokenStream::Fallback(s) => s,
                                TokenStream::Compiler(_) => mismatch(line!()),
                            }));
                            TokenStream::Fallback(first)
                        }
                        None => TokenStream::new(),
                    }
                }
            }

            impl Extend<TokenTree> for TokenStream           
            {
                fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, stream: I)
                {
                    match self {
                        TokenStream::Compiler(tts) =>
                    {
                           
                            for token in stream {
                                tts.extra.push(into_compiler_token(token));
                            }
                        }
                        TokenStream::Fallback(tts) => tts.extend(stream),
                    }
                }
            }

            impl Extend<TokenStream> for TokenStream           
            {
                fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I)
                {
                    match self {
                        TokenStream::Compiler(tts) =>
                    {
                            tts.evaluate_now();
                            tts.stream
                                .extend(streams.into_iter().map(TokenStream::unwrap_nightly));
                        }
                        TokenStream::Fallback(tts) =>
                    {
                            tts.extend(streams.into_iter().map(TokenStream::unwrap_stable));
                        }
                    }
                }
            }

            impl Debug for TokenStream           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        TokenStream::Compiler(tts) => Debug::fmt(&tts.clone().into_token_stream(), f),
                        TokenStream::Fallback(tts) => Debug::fmt(tts, f),
                    }
                }
            }

            impl LexError
            {
                pub fn span( &self ) -> Span
                {
                    match self {
                        LexError::Compiler(_) | LexError::CompilerPanic => Span::call_site(),
                        LexError::Fallback(e) => Span::Fallback(e.span()),
                    }
                }
            }

            impl From<proc_macro::LexError> for LexError           
            {
                fn from(e: proc_macro::LexError) -> Self
                {
                    LexError::Compiler(e)
                }
            }

            impl From<fallback::LexError> for LexError           
            {
                fn from(e: fallback::LexError) -> Self
                {
                    LexError::Fallback(e)
                }
            }

            impl Debug for LexError           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        LexError::Compiler(e) => Debug::fmt(e, f),
                        LexError::Fallback(e) => Debug::fmt(e, f),
                        LexError::CompilerPanic =>
                    {
                            let fallback = fallback::LexError::call_site();
                            Debug::fmt(&fallback, f)
                        }
                    }
                }
            }

            impl Display for LexError           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        LexError::Compiler(e) => Display::fmt(e, f),
                        LexError::Fallback(e) => Display::fmt(e, f),
                        LexError::CompilerPanic =>
                    {
                            let fallback = fallback::LexError::call_site();
                            Display::fmt(&fallback, f)
                        }
                    }
                }
            }

            #[derive(Clone)]
            pub enum TokenTreeIter 
            {
                Compiler(proc_macro::token_stream::IntoIter),
                Fallback(fallback::TokenTreeIter),
            }

            impl IntoIterator for TokenStream
            {
                type Item = TokenTree;
                type IntoIter = TokenTreeIter;
                fn into_iter( self ) -> TokenTreeIter
                {
                    match self {
                        TokenStream::Compiler(tts) =>
                    {
                            TokenTreeIter::Compiler(tts.into_token_stream().into_iter())
                        }
                        TokenStream::Fallback(tts) => TokenTreeIter::Fallback(tts.into_iter()),
                    }
                }
            }

            impl Iterator for TokenTreeIter
            {
                type Item = TokenTree;
                fn next( &mut self ) -> Option<TokenTree>
                {
                    let token = match self {
                        TokenTreeIter::Compiler(iter) => iter.next()?,
                        TokenTreeIter::Fallback(iter) => return iter.next(),
                    };
                    Some(match token {
                        proc_macro::TokenTree::Group(tt) =>
                    {
                            TokenTree::Group(::process::macros::Group::_new(Group::Compiler(tt)))
                        }
                        proc_macro::TokenTree::Punct(tt) =>
                    {
                            let spacing = match tt.spacing() {
                                proc_macro::Spacing::Joint => Spacing::Joint,
                                proc_macro::Spacing::Alone => Spacing::Alone,
                            };
                            let mut o = Punct::new(tt.as_char(), spacing);
                            o.set_span(::process::macros::Span::_new(Span::Compiler(tt.span())));
                            TokenTree::Punct(o)
                        }
                        proc_macro::TokenTree::Ident(s) =>
                    {
                            TokenTree::Ident(::process::macros::Ident::_new(Ident::Compiler(s)))
                        }
                        proc_macro::TokenTree::Literal(l) =>
                    {
                            TokenTree::Literal(::process::macros::Literal::_new(Literal::Compiler(l)))
                        }
                    })
                }

                fn size_hint( &self ) -> (usize, Option<usize>)
                {
                    match self {
                        TokenTreeIter::Compiler(tts) => tts.size_hint(),
                        TokenTreeIter::Fallback(tts) => tts.size_hint(),
                    }
                }
            }

            #[derive(Copy, Clone)]
            pub enum Span
            {
                Compiler(proc_macro::Span),
                Fallback(fallback::Span),
            }

            impl Span           
            {
                pub fn call_site() -> Self
                {
                    if inside_proc_macro() {
                        Span::Compiler(proc_macro::Span::call_site())
                    } else {
                        Span::Fallback(fallback::Span::call_site())
                    }
                }

                pub fn mixed_site() -> Self
                {
                    if inside_proc_macro() {
                        Span::Compiler(proc_macro::Span::mixed_site())
                    } else {
                        Span::Fallback(fallback::Span::mixed_site())
                    }
                }
                
                pub fn def_site() -> Self
                {
                    Span::Fallback(fallback::Span::def_site())
                    /*
                    if inside_proc_macro() {
                        Span::Compiler(proc_macro::Span::def_site())
                    } else {
                        Span::Fallback(fallback::Span::def_site())
                    } */
                }

                pub fn resolved_at( &self, other: Span) -> Span 
                {
                    match (self, other) {
                        (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.resolved_at(b)),
                        (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.resolved_at(b)),
                        (Span::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Span::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                pub fn located_at( &self, other: Span) -> Span 
                {
                    match (self, other) {
                        (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(a.located_at(b)),
                        (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.located_at(b)),
                        (Span::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Span::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                pub fn unwrap( self ) -> proc_macro::Span
                {
                    match self {
                        Span::Compiler(s) => s,
                        Span::Fallback(_) => panic!("proc_macro::Span is only available in procedural macros"),
                    }
                }

                pub fn byte_range( &self ) -> Range<usize>
                {
                    match self {
                        #[cfg(proc_macro_span)]
                        Span::Compiler(s) => proc_macro_span::byte_range(s),
                        #[cfg(not(proc_macro_span))]
                        Span::Compiler(_) => 0..0,
                        Span::Fallback(s) => s.byte_range(),
                    }
                }

                pub fn start( &self ) -> LineColumn
                {
                    match self {
                        #[cfg(proc_macro_span_location)]
                        Span::Compiler(s) => LineColumn {
                            line: proc_macro_span_location::line(s),
                            column: proc_macro_span_location::column(s).saturating_sub(1),
                        },
                        #[cfg(not(proc_macro_span_location))]
                        Span::Compiler(_) => LineColumn { line: 0, column: 0 },
                        Span::Fallback(s) => s.start(),
                    }
                }

                pub fn end( &self ) -> LineColumn
                {
                    match self {
                        #[cfg(proc_macro_span_location)]
                        Span::Compiler(s) =>
                    {
                            let end = proc_macro_span_location::end(s);
                            LineColumn {
                                line: proc_macro_span_location::line(&end),
                                column: proc_macro_span_location::column(&end).saturating_sub(1),
                            }
                        }
                        #[cfg(not(proc_macro_span_location))]
                        Span::Compiler(_) => LineColumn { line: 0, column: 0 },
                        Span::Fallback(s) => s.end(),
                    }
                }

                pub fn file( &self ) -> String
                {
                    match self {
                        #[cfg(proc_macro_span_file)]
                        Span::Compiler(s) => proc_macro_span_file::file(s),
                        #[cfg(not(proc_macro_span_file))]
                        Span::Compiler(_) => "<token stream>".to_owned(),
                        Span::Fallback(s) => s.file(),
                    }
                }

                pub fn local_file( &self ) -> Option<PathBuf>
                {
                    match self {
                        #[cfg(proc_macro_span_file)]
                        Span::Compiler(s) => proc_macro_span_file::local_file(s),
                        #[cfg(not(proc_macro_span_file))]
                        Span::Compiler(_) => None,
                        Span::Fallback(s) => s.local_file(),
                    }
                }

                pub fn join( &self, other: Span) -> Option<Span> 
               
                {
                    let ret = match (self, other) {
                        #[cfg(proc_macro_span)]
                        (Span::Compiler(a), Span::Compiler(b)) => Span::Compiler(proc_macro_span::join(a, b)?),
                        (Span::Fallback(a), Span::Fallback(b)) => Span::Fallback(a.join(b)?),
                        _ => return None,
                    };
                    Some(ret)
                }
                
                pub fn eq( &self, other: &Span) -> bool 
                {
                    match (self, other)
                    {
                        //(Span::Compiler(a), Span::Compiler(b)) => a.eq(b),
                        (Span::Fallback(a), Span::Fallback(b)) => a.eq(b),
                        _ => false,
                    }
                }

                pub fn source_text( &self ) -> Option<String>
                {
                    match self {
                        #[cfg(not(no_source_text))]
                        Span::Compiler(s) => s.source_text(),
                        #[cfg(no_source_text)]
                        Span::Compiler(_) => None,
                        Span::Fallback(s) => s.source_text(),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Span
                {
                    match self {
                        Span::Compiler(s) => s,
                        Span::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<proc_macro::Span> for ::process::macros::Span           
            {
                fn from(proc_span: proc_macro::Span) -> Self
                {
                    ::process::macros::Span::_new(Span::Compiler(proc_span))
                }
            }

            impl From<fallback::Span> for Span           
            {
                fn from(inner: fallback::Span) -> Self
                {
                    Span::Fallback(inner)
                }
            }

            impl Debug for Span           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Span::Compiler(s) => Debug::fmt(s, f),
                        Span::Fallback(s) => Debug::fmt(s, f),
                    }
                }
            }

            pub fn debug_span_field_if_nontrivial(debug: &mut fmt::DebugStruct, span: Span)
            {
                match span {
                    Span::Compiler(s) =>
                    {
                        debug.field("span", &s);
                    }
                    Span::Fallback(s) => fallback::debug_span_field_if_nontrivial(debug, s),
                }
            }

            #[derive(Clone)]
            pub enum Group
            {
                Compiler(proc_macro::Group),
                Fallback(fallback::Group),
            }

            impl Group           
            {
                pub fn new(delimiter: Delimiter, stream: TokenStream) -> Self
                {
                    match stream {
                        TokenStream::Compiler(tts) =>
                    {
                            let delimiter = match delimiter {
                                Delimiter::Parenthesis => proc_macro::Delimiter::Parenthesis,
                                Delimiter::Bracket => proc_macro::Delimiter::Bracket,
                                Delimiter::Brace => proc_macro::Delimiter::Brace,
                                Delimiter::None => proc_macro::Delimiter::None,
                            };
                            Group::Compiler(proc_macro::Group::new(delimiter, tts.into_token_stream()))
                        }
                        TokenStream::Fallback(stream) =>
                    {
                            Group::Fallback(fallback::Group::new(delimiter, stream))
                        }
                    }
                }

                pub fn delimiter( &self ) -> Delimiter
                {
                    match self {
                        Group::Compiler(g) => match g.delimiter() {
                            proc_macro::Delimiter::Parenthesis => Delimiter::Parenthesis,
                            proc_macro::Delimiter::Bracket => Delimiter::Bracket,
                            proc_macro::Delimiter::Brace => Delimiter::Brace,
                            proc_macro::Delimiter::None => Delimiter::None,
                        },
                        Group::Fallback(g) => g.delimiter(),
                    }
                }

                pub fn stream( &self ) -> TokenStream
                {
                    match self {
                        Group::Compiler(g) => TokenStream::Compiler(DeferredTokenStream::new(g.stream())),
                        Group::Fallback(g) => TokenStream::Fallback(g.stream()),
                    }
                }

                pub fn span( &self ) -> Span
                {
                    match self {
                        Group::Compiler(g) => Span::Compiler(g.span()),
                        Group::Fallback(g) => Span::Fallback(g.span()),
                    }
                }

                pub fn span_open( &self ) -> Span
                {
                    match self {
                        Group::Compiler(g) => Span::Compiler(g.span_open()),
                        Group::Fallback(g) => Span::Fallback(g.span_open()),
                    }
                }

                pub fn span_close( &self ) -> Span
                {
                    match self {
                        Group::Compiler(g) => Span::Compiler(g.span_close()),
                        Group::Fallback(g) => Span::Fallback(g.span_close()),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match (self, span) {
                        (Group::Compiler(g), Span::Compiler(s)) => g.set_span(s),
                        (Group::Fallback(g), Span::Fallback(s)) => g.set_span(s),
                        (Group::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Group::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Group
                {
                    match self {
                        Group::Compiler(g) => g,
                        Group::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<fallback::Group> for Group           
            {
                fn from(g: fallback::Group) -> Self
                {
                    Group::Fallback(g)
                }
            }

            impl Display for Group           
            {
                fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Group::Compiler(group) => Display::fmt(group, formatter),
                        Group::Fallback(group) => Display::fmt(group, formatter),
                    }
                }
            }

            impl Debug for Group           
            {
                fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Group::Compiler(group) => Debug::fmt(group, formatter),
                        Group::Fallback(group) => Debug::fmt(group, formatter),
                    }
                }
            }

            #[derive(Clone)]
            pub enum Ident
            {
                Compiler(proc_macro::Ident),
                Fallback(fallback::Ident),
            }

            impl Ident 
            {
                #[track_caller]
                pub fn new_checked(string: &str, span: Span) -> Self
                {
                    match span {
                        Span::Compiler(s) => Ident::Compiler(proc_macro::Ident::new(string, s)),
                        Span::Fallback(s) => Ident::Fallback(fallback::Ident::new_checked(string, s)),
                    }
                }

                #[track_caller]
                pub fn new_raw_checked(string: &str, span: Span) -> Self
                {
                    match span {
                        Span::Compiler(s) => Ident::Compiler(proc_macro::Ident::new_raw(string, s)),
                        Span::Fallback(s) => Ident::Fallback(fallback::Ident::new_raw_checked(string, s)),
                    }
                }

                pub fn span( &self ) -> Span
                {
                    match self {
                        Ident::Compiler(t) => Span::Compiler(t.span()),
                        Ident::Fallback(t) => Span::Fallback(t.span()),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match (self, span) {
                        (Ident::Compiler(t), Span::Compiler(s)) => t.set_span(s),
                        (Ident::Fallback(t), Span::Fallback(s)) => t.set_span(s),
                        (Ident::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Ident::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Ident
                {
                    match self {
                        Ident::Compiler(s) => s,
                        Ident::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<fallback::Ident> for Ident           
            {
                fn from(inner: fallback::Ident) -> Self
                {
                    Ident::Fallback(inner)
                }
            }

            impl PartialEq for Ident           
            {
                fn eq( &self, other: &Ident) -> bool
        {
                    match (self, other) {
                        (Ident::Compiler(t), Ident::Compiler(o)) => t.to_string() == o.to_string(),
                        (Ident::Fallback(t), Ident::Fallback(o)) => t == o,
                        (Ident::Compiler(_), Ident::Fallback(_)) => mismatch(line!()),
                        (Ident::Fallback(_), Ident::Compiler(_)) => mismatch(line!()),
                    }
                }
            }

            impl<T> PartialEq<T> for Ident where
            T: ?Sized + AsRef<str>
            {
                fn eq( &self, other: &T) -> bool
                {
                    let other = other.as_ref();
                    match self {
                        Ident::Compiler(t) => t.to_string() == other,
                        Ident::Fallback(t) => t == other,
                    }
                }
            }

            impl Display for Ident           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Ident::Compiler(t) => Display::fmt(t, f),
                        Ident::Fallback(t) => Display::fmt(t, f),
                    }
                }
            }

            impl Debug for Ident           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Ident::Compiler(t) => Debug::fmt(t, f),
                        Ident::Fallback(t) => Debug::fmt(t, f),
                    }
                }
            }

            #[derive(Clone)]
            pub enum Literal 
            {
                Compiler(proc_macro::Literal),
                Fallback(fallback::Literal),
            }

            macro_rules! suffixed_numbers 
            {
                ($($name:ident => $kind:ident,)*) => ($(
                    pub fn $name(n: $kind) -> Literal {
                        if inside_proc_macro() {
                            Literal::Compiler(proc_macro::Literal::$name(n))
                        } else {
                            Literal::Fallback(fallback::Literal::$name(n))
                        }
                    }
                )*)
            }

            macro_rules! unsuffixed_integers 
            {
                ($($name:ident => $kind:ident,)*) => ($(
                    pub fn $name(n: $kind) -> Literal {
                        if inside_proc_macro() {
                            Literal::Compiler(proc_macro::Literal::$name(n))
                        } else {
                            Literal::Fallback(fallback::Literal::$name(n))
                        }
                    }
                )*)
            }

            impl Literal
            {
                pub fn from_str_checked(repr: &str) -> Result<Self, LexError>
                    {
                    if inside_proc_macro() {
                        let literal = proc_macro::Literal::from_str_checked(repr)?;
                        Ok(Literal::Compiler(literal))
                    } else {
                        let literal = fallback::Literal::from_str_checked(repr)?;
                        Ok(Literal::Fallback(literal))
                    }
                }

                pub unsafe fn from_str_unchecked(repr: &str) -> Self
                {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::from_str_unchecked(repr))
                    } else {
                        Literal::Fallback(unsafe { fallback::Literal::from_str_unchecked(repr) })
                    }
                }

                suffixed_numbers! {
                    u8_suffixed => u8,
                    u16_suffixed => u16,
                    u32_suffixed => u32,
                    u64_suffixed => u64,
                    u128_suffixed => u128,
                    usize_suffixed => usize,
                    i8_suffixed => i8,
                    i16_suffixed => i16,
                    i32_suffixed => i32,
                    i64_suffixed => i64,
                    i128_suffixed => i128,
                    isize_suffixed => isize,

                    f32_suffixed => f32,
                    f64_suffixed => f64,
                }

                unsuffixed_integers! {
                    u8_unsuffixed => u8,
                    u16_unsuffixed => u16,
                    u32_unsuffixed => u32,
                    u64_unsuffixed => u64,
                    u128_unsuffixed => u128,
                    usize_unsuffixed => usize,
                    i8_unsuffixed => i8,
                    i16_unsuffixed => i16,
                    i32_unsuffixed => i32,
                    i64_unsuffixed => i64,
                    i128_unsuffixed => i128,
                    isize_unsuffixed => isize,
                }

                pub fn f32_unsuffixed(f: f32) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::f32_unsuffixed(f))
                    } else {
                        Literal::Fallback(fallback::Literal::f32_unsuffixed(f))
                    }
                }

                pub fn f64_unsuffixed(f: f64) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::f64_unsuffixed(f))
                    } else {
                        Literal::Fallback(fallback::Literal::f64_unsuffixed(f))
                    }
                }

                pub fn string(string: &str) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::string(string))
                    } else {
                        Literal::Fallback(fallback::Literal::string(string))
                    }
                }

                pub fn character(ch: char) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::character(ch))
                    } else {
                        Literal::Fallback(fallback::Literal::character(ch))
                    }
                }

                pub fn byte_character(byte: u8) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler({
                            #[cfg(not(no_literal_byte_character))]
                            {
                                proc_macro::Literal::byte_character(byte)
                            }

                            #[cfg(no_literal_byte_character)]
                            {
                                let fallback = fallback::Literal::byte_character(byte);
                                proc_macro::Literal::from_str_unchecked(&fallback.repr)
                            }
                        })
                    } else {
                        Literal::Fallback(fallback::Literal::byte_character(byte))
                    }
                }

                pub fn byte_string(bytes: &[u8]) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler(proc_macro::Literal::byte_string(bytes))
                    } else {
                        Literal::Fallback(fallback::Literal::byte_string(bytes))
                    }
                }

                pub fn c_string(string: &CStr) -> Literal {
                    if inside_proc_macro() {
                        Literal::Compiler({
                            #[cfg(not(no_literal_c_string))]
                            {
                                proc_macro::Literal::c_string(string)
                            }

                            #[cfg(no_literal_c_string)]
                            {
                                let fallback = fallback::Literal::c_string(string);
                                proc_macro::Literal::from_str_unchecked(&fallback.repr)
                            }
                        })
                    } else {
                        Literal::Fallback(fallback::Literal::c_string(string))
                    }
                }

                pub fn span( &self ) -> Span
                {
                    match self {
                        Literal::Compiler(lit) => Span::Compiler(lit.span()),
                        Literal::Fallback(lit) => Span::Fallback(lit.span()),
                    }
                }

                pub fn set_span(&mut self, span: Span )
                {
                    match (self, span) {
                        (Literal::Compiler(lit), Span::Compiler(s)) => lit.set_span(s),
                        (Literal::Fallback(lit), Span::Fallback(s)) => lit.set_span(s),
                        (Literal::Compiler(_), Span::Fallback(_)) => mismatch(line!()),
                        (Literal::Fallback(_), Span::Compiler(_)) => mismatch(line!()),
                    }
                }

                pub fn subspan<R: RangeBounds<usize>>( &self, range: R) -> Option<Span>
                {
                    match self {
                        #[cfg(proc_macro_span)]
                        Literal::Compiler(lit) => proc_macro_span::subspan(lit, range).map(Span::Compiler),
                        #[cfg(not(proc_macro_span))]
                        Literal::Compiler(_lit) => None,
                        Literal::Fallback(lit) => lit.subspan(range).map(Span::Fallback),
                    }
                }

                fn unwrap_nightly( self ) -> proc_macro::Literal
                {
                    match self {
                        Literal::Compiler(s) => s,
                        Literal::Fallback(_) => mismatch(line!()),
                    }
                }
            }

            impl From<fallback::Literal> for Literal           
            {
                fn from(s: fallback::Literal) -> Self
                {
                    Literal::Fallback(s)
                }
            }

            impl Display for Literal           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Literal::Compiler(t) => Display::fmt(t, f),
                        Literal::Fallback(t) => Display::fmt(t, f),
                    }
                }
            }

            impl Debug for Literal           
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    match self {
                        Literal::Compiler(t) => Debug::fmt(t, f),
                        Literal::Fallback(t) => Debug::fmt(t, f),
                    }
                }
            }
            
            pub fn invalidate_current_thread_spans()
            {
                if inside_proc_macro()
                {
                    panic!
                    (
                        "process::macros::extra::invalidate_current_thread_spans is not available in procedural macros"
                    );
                }
                
                else
                {
                    ::process::macros::fallback::invalidate_current_thread_spans();
                }
            }
        }
        
        pub mod location
        {
            use ::
            {
                cmp::{ Ordering },
                *,
            };
            /*
            */
            /// A line-column pair representing the start or end of a `Span`.
            #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
            pub struct LineColumn 
            {
                /// The 1-indexed line in the source file on which the span starts or ends (inclusive).
                pub line: usize,
                /// The 0-indexed column (in UT8) in the source file on which the span starts or ends (inclusive).
                pub column: usize,
            }

            impl Ord for LineColumn
            {
                fn cmp( &self, other: &Self) -> Ordering
                {
                    self.line
                    .cmp(&other.line)
                    .then(self.column.cmp(&other.column))
                }
            }

            impl PartialOrd for LineColumn
            {
                fn partial_cmp( &self, other: &Self) -> Option<Ordering>
                {
                    Some(self.cmp(other))
                }
            }
        }
        /**
        A wrapper around the procedural macro API of the compiler's [`proc_macro`] crate.*/
        pub mod parse
        {
            use ::
            {
                process::
                {
                    macros::
                    {
                        fallback::
                        {
                            self, Group, Ident, LexError, Literal, Span, TokenStream, TokenStreamBuilder,
                        },
                        Delimiter, Punct, Spacing, TokenTree,
                    },
                },
                str::{ Bytes, CharIndices, Chars },
                *,
            };
            /*
            */
            /// Rustc's representation of a macro expansion error in expression position or type position.
            pub const ERROR: &str = "(/*ERROR*/)";

            pub type PResult<'a, O> = Result<(Cursor<'a>, O), Reject>;

            #[derive(Copy, Clone, Eq, PartialEq)]
            pub struct Cursor<'a> 
            {
                pub rest: &'a str,
                    pub off: u32,
            }

            impl<'a> Cursor<'a>
            {
                pub fn advance( &self, bytes: usize) -> Cursor<'a>
                {
                    let (_front, rest) = self.rest.split_at(bytes);
                    Cursor {
                        rest,
                                    off: self.off + _front.chars().count() as u32,
                    }
                }

                pub fn starts_with( &self, s: &str) -> bool
        {
                    self.rest.starts_with(s)
                }

                pub fn starts_with_char( &self, ch: char) -> bool
        {
                    self.rest.starts_with(ch)
                }

                pub fn starts_with_fn<Pattern>( &self, f: Pattern) -> bool
                where
                    Pattern: FnMut(char) -> bool,
                {
                    self.rest.starts_with(f)
                }

                pub fn is_empty( &self ) -> bool
        {
                    self.rest.is_empty()
                }

                fn len( &self ) -> usize {
                    self.rest.len()
                }

                fn as_bytes( &self ) -> &'a [u8] {
                    self.rest.as_bytes()
                }

                fn bytes( &self ) -> Bytes<'a>
                    {
                    self.rest.bytes()
                }

                fn chars( &self ) -> Chars<'a>
                    {
                    self.rest.chars()
                }

                fn char_indices( &self ) -> CharIndices<'a>
                    {
                    self.rest.char_indices()
                }

                fn parse( &self, tag: &str) -> Result<Cursor<'a>, Reject>
                    {
                    if self.starts_with(tag) {
                        Ok(self.advance(tag.len()))
                    } else {
                        Err(Reject)
                    }
                }
            }

            pub struct Reject;
            
            fn skip_whitespace(input: Cursor) -> Cursor
            {
                let mut s = input;

                while !s.is_empty()
               
                {
                    let byte = s.as_bytes()[0];
                    
                    if byte == b'/'
                    {
                        if s.starts_with("//")
                            && (!s.starts_with("///") || s.starts_with("////"))
                            && !s.starts_with("//!")
                        {
                            let (cursor, _) = take_until_newline_or_eof(s);
                            s = cursor;
                            continue;
                        } else if s.starts_with("/**/") {
                            s = s.advance(4);
                            continue;
                        } else if s.starts_with("/*")
                            && (!s.starts_with("/**") || s.starts_with("/***"))
                            && !s.starts_with("/*!")
                        {
                            match block_comment(s) {
                                Ok((rest, _)) =>
                    {
                                    s = rest;
                                    continue;
                                }
                                Err(Reject) => return s,
                            }
                        }
                    }
                    
                    match byte
                    {
                        b' ' | 0x09..=0x0d =>
                        {
                            s = s.advance(1);
                            continue;
                        }

                        b if b.is_ascii() =>
                    {}
                        _ =>
                        {
                            let ch = s.chars().next().unwrap();

                            if is::whitespace(ch)
                            {
                                s = s.advance(ch.len_utf8());
                                continue;
                            }
                        }
                    }
                    return s;
                }
                s
            }

            fn block_comment(input: Cursor<'_>) -> PResult<'_, &str>
            {
                if !input.starts_with("/*") {
                    return Err(Reject);
                }

                let mut depth = 0usize;
                let bytes = input.as_bytes();
                let mut i = 0usize;
                let upper = bytes.len() - 1;

                while i < upper {
                    if bytes[i] == b'/' && bytes[i + 1] == b'*' {
                        depth += 1;
                        i += 1;
                    } else if bytes[i] == b'*' && bytes[i + 1] == b'/' {
                        depth -= 1;
                        if depth == 0 {
                            return Ok((input.advance(i + 2), &input.rest[..i + 2]));
                        }
                        i += 1;
                    }
                    i += 1;
                }

                Err(Reject)
            }

            fn word_break(input: Cursor) -> Result<Cursor, Reject>
            {
                match input.chars().next() {
                    Some(ch) if is::ident_continue(ch) => Err(Reject),
                    Some(_) | None => Ok(input),
                }
            }

            pub fn token_stream(mut input: Cursor) -> Result<TokenStream, LexError>
            {
                let mut trees = TokenStreamBuilder::new();
                let mut stack = Vec::new();

                loop {
                    input = skip_whitespace(input);

                    if let Ok((rest, ())) = doc_comment(input, &mut trees) {
                        input = rest;
                        continue;
                    }

                            let lo = input.off;

                    let first = match input.bytes().next() {
                        Some(first) => first,
                        None => match stack.last() {
                            None => return Ok(trees.build()),
                                            Some((lo, _frame)) =>
                    {
                                return Err(LexError {
                                    span: Span { lo: *lo, hi: *lo },
                                })
                            }
                        },
                    };

                    if let Some(open_delimiter) = match first {
                        b'(' if !input.starts_with(ERROR) => Some(Delimiter::Parenthesis),
                        b'[' => Some(Delimiter::Bracket),
                        b'{' => Some(Delimiter::Brace),
                        _ => None,
                    } {
                        input = input.advance(1);
                        let frame = (open_delimiter, trees);
                                    let frame = (lo, frame);
                        stack.push(frame);
                        trees = TokenStreamBuilder::new();
                    } else if let Some(close_delimiter) = match first {
                        b')' => Some(Delimiter::Parenthesis),
                        b']' => Some(Delimiter::Bracket),
                        b'}' => Some(Delimiter::Brace),
                        _ => None,
                    } {
                        let frame = match stack.pop() {
                            Some(frame) => frame,
                            None => return Err(lex_error(input)),
                        };
                                    let (lo, frame) = frame;
                        let (open_delimiter, outer) = frame;
                        if open_delimiter != close_delimiter {
                            return Err(lex_error(input));
                        }
                        input = input.advance(1);
                        let mut g = Group::new(open_delimiter, trees.build());
                        g.set_span(Span {
                                            lo,
                                            hi: input.off,
                        });
                        trees = outer;
                        trees.push_token_from_parser(TokenTree::Group(::process::macros::Group::_new_fallback(g)));
                    } else {
                        let (rest, mut tt) = match leaf_token(input) {
                            Ok((rest, tt)) => (rest, tt),
                            Err(Reject) => return Err(lex_error(input)),
                        };
                        tt.set_span(::process::macros::Span::_new_fallback(Span {
                                            lo,
                                            hi: rest.off,
                        }));
                        trees.push_token_from_parser(tt);
                        input = rest;
                    }
                }
            }

            fn lex_error(cursor: Cursor) -> LexError
            {
                LexError
                {
                    span: Span
                    {
                        lo:cursor.off,
                        hi:cursor.off,
                    },
                }
            }

            fn leaf_token(input: Cursor) -> PResult<TokenTree>
            {
                if let Ok((input, l)) = literal(input) {
                   
                    Ok((input, TokenTree::Literal(::process::macros::Literal::_new_fallback(l))))
                } else if let Ok((input, p)) = punct(input) {
                    Ok((input, TokenTree::Punct(p)))
                } else if let Ok((input, i)) = ident(input) {
                    Ok((input, TokenTree::Ident(i)))
                } else if input.starts_with(ERROR)
                {
                    let rest = input.advance(ERROR.len());
                    let repr = ::process::macros::Literal::_new_fallback(Literal::_new(ERROR.to_owned()));
                    Ok((rest, TokenTree::Literal(repr)))
                } else {
                    Err(Reject)
                }
            }

            fn ident(input: Cursor) -> PResult<::process::macros::Ident>
            {
                if [
                    "r\"", "r#\"", "r##", "b\"", "b\'", "br\"", "br#", "c\"", "cr\"", "cr#",
                ]
                .iter()
                .any(|prefix| input.starts_with(prefix))
                {
                    Err(Reject)
                } else {
                    ident_any(input)
                }
            }

            fn ident_any(input: Cursor) -> PResult<::process::macros::Ident>
            {
                let raw = input.starts_with("r#");
                let rest = input.advance((raw as usize) << 1);

                let (rest, sym) = ident_not_raw(rest)?;

                if !raw
                {
                    let ident =
                        ::process::macros::Ident::_new_fallback(Ident::new_unchecked(sym, fallback::Span::call_site()));
                    return Ok((rest, ident));
                }

                match sym {
                    "_" | "super" | "self" | "Self" | "crate" => return Err(Reject),
                    _ =>
                    {}
                }

                let ident =
                    ::process::macros::Ident::_new_fallback(Ident::new_raw_unchecked(sym, fallback::Span::call_site()));
                Ok((rest, ident))
            }

            fn ident_not_raw(input: Cursor<'_>) -> PResult<'_, &str>
            {
                let mut chars = input.char_indices();

                match chars.next() {
                    Some((_, ch)) if is::ident_start(ch) =>
                    {}
                    _ => return Err(Reject),
                }

                let mut end = input.len();
                for (i, ch) in chars {
                    if !is::ident_continue(ch) {
                        end = i;
                        break;
                    }
                }

                Ok((input.advance(end), &input.rest[..end]))
            }

            pub fn literal(input: Cursor) -> PResult<Literal>
            {
                let rest = literal_nocapture(input)?;
                let end = input.len() - rest.len();
                Ok((rest, Literal::_new(input.rest[..end].to_string())))
            }

            fn literal_nocapture(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(ok) = string(input) {
                    Ok(ok)
                } else if let Ok(ok) = byte_string(input) {
                    Ok(ok)
                } else if let Ok(ok) = c_string(input) {
                    Ok(ok)
                } else if let Ok(ok) = byte(input) {
                    Ok(ok)
                } else if let Ok(ok) = character(input) {
                    Ok(ok)
                } else if let Ok(ok) = float(input) {
                    Ok(ok)
                } else if let Ok(ok) = int(input) {
                    Ok(ok)
                } else {
                    Err(Reject)
                }
            }

            fn literal_suffix(input: Cursor) -> Cursor
            {
                match ident_not_raw(input) {
                    Ok((input, _)) => input,
                    Err(Reject) => input,
                }
            }

            fn string(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(input) = input.parse("\"") {
                    cooked_string(input)
                } else if let Ok(input) = input.parse("r") {
                    raw_string(input)
                } else {
                    Err(Reject)
                }
            }

            fn cooked_string(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let mut chars = input.char_indices();

                while let Some((i, ch)) = chars.next( )
                {
                    match ch {
                        '"' =>
                    {
                            let input = input.advance(i + 1);
                            return Ok(literal_suffix(input));
                        }
                        '\r' => match chars.next() {
                            Some((_, '\n')) =>
                    {}
                            _ => break,
                        },
                        '\\' => match chars.next() {
                            Some((_, 'x')) =>
                    {
                                backslash_x_char(&mut chars)?;
                            }
                            Some((_, 'n' | 'r' | 't' | '\\' | '\'' | '"' | '0')) =>
                    {}
                            Some((_, 'u')) =>
                    {
                                backslash_u(&mut chars)?;
                            }
                            Some((newline, ch @ ('\n' | '\r'))) =>
                    {
                                input = input.advance(newline + 1);
                                trailing_backslash(&mut input, ch as u8)?;
                                chars = input.char_indices();
                            }
                            _ => break,
                        },
                        _ch =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn raw_string(input: Cursor) -> Result<Cursor, Reject>
            {
                let (input, delimiter) = delimiter_of_raw_string(input)?;
                let mut bytes = input.bytes().enumerate();
                while let Some((i, byte)) = bytes.next( )
                {
                    match byte {
                        b'"' if input.rest[i + 1..].starts_with(delimiter) =>
                    {
                            let rest = input.advance(i + 1 + delimiter.len());
                            return Ok(literal_suffix(rest));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        _ =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn byte_string(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(input) = input.parse("b\"") {
                    cooked_byte_string(input)
                } else if let Ok(input) = input.parse("br") {
                    raw_byte_string(input)
                } else {
                    Err(Reject)
                }
            }

            fn cooked_byte_string(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let mut bytes = input.bytes().enumerate();
                while let Some((offset, b)) = bytes.next( )
                {
                    match b {
                        b'"' =>
                    {
                            let input = input.advance(offset + 1);
                            return Ok(literal_suffix(input));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        b'\\' => match bytes.next() {
                            Some((_, b'x')) =>
                    {
                                backslash_x_byte(&mut bytes)?;
                            }
                            Some((_, b'n' | b'r' | b't' | b'\\' | b'0' | b'\'' | b'"')) =>
                    {}
                            Some((newline, b @ (b'\n' | b'\r'))) =>
                    {
                                input = input.advance(newline + 1);
                                trailing_backslash(&mut input, b)?;
                                bytes = input.bytes().enumerate();
                            }
                            _ => break,
                        },
                        b if b.is_ascii() =>
                    {}
                        _ => break,
                    }
                }
                Err(Reject)
            }

            fn delimiter_of_raw_string(input: Cursor<'_>) -> PResult<'_, &str>
            {
                for (i, byte) in input.bytes().enumerate( )
                {
                    match byte {
                        b'"' =>
                    {
                            if i > 255 {
                               
                                return Err(Reject);
                            }
                            return Ok((input.advance(i + 1), &input.rest[..i]));
                        }
                        b'#' =>
                    {}
                        _ => break,
                    }
                }
                Err(Reject)
            }

            fn raw_byte_string(input: Cursor) -> Result<Cursor, Reject>
            {
                let (input, delimiter) = delimiter_of_raw_string(input)?;
                let mut bytes = input.bytes().enumerate();
                while let Some((i, byte)) = bytes.next( )
                {
                    match byte {
                        b'"' if input.rest[i + 1..].starts_with(delimiter) =>
                    {
                            let rest = input.advance(i + 1 + delimiter.len());
                            return Ok(literal_suffix(rest));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        other =>
                    {
                            if !other.is_ascii() {
                                break;
                            }
                        }
                    }
                }
                Err(Reject)
            }

            fn c_string(input: Cursor) -> Result<Cursor, Reject>
            {
                if let Ok(input) = input.parse("c\"") {
                    cooked_c_string(input)
                } else if let Ok(input) = input.parse("cr") {
                    raw_c_string(input)
                } else {
                    Err(Reject)
                }
            }

            fn raw_c_string(input: Cursor) -> Result<Cursor, Reject>
            {
                let (input, delimiter) = delimiter_of_raw_string(input)?;
                let mut bytes = input.bytes().enumerate();
                while let Some((i, byte)) = bytes.next( )
                {
                    match byte {
                        b'"' if input.rest[i + 1..].starts_with(delimiter) =>
                    {
                            let rest = input.advance(i + 1 + delimiter.len());
                            return Ok(literal_suffix(rest));
                        }
                        b'\r' => match bytes.next() {
                            Some((_, b'\n')) =>
                    {}
                            _ => break,
                        },
                        b'\0' => break,
                        _ =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn cooked_c_string(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let mut chars = input.char_indices();

                while let Some((i, ch)) = chars.next( )
                {
                    match ch {
                        '"' =>
                    {
                            let input = input.advance(i + 1);
                            return Ok(literal_suffix(input));
                        }
                        '\r' => match chars.next() {
                            Some((_, '\n')) =>
                    {}
                            _ => break,
                        },
                        '\\' => match chars.next() {
                            Some((_, 'x')) =>
                    {
                                backslash_x_nonzero(&mut chars)?;
                            }
                            Some((_, 'n' | 'r' | 't' | '\\' | '\'' | '"')) =>
                    {}
                            Some((_, 'u')) =>
                    {
                                if backslash_u(&mut chars)? == '\0' {
                                    break;
                                }
                            }
                            Some((newline, ch @ ('\n' | '\r'))) =>
                    {
                                input = input.advance(newline + 1);
                                trailing_backslash(&mut input, ch as u8)?;
                                chars = input.char_indices();
                            }
                            _ => break,
                        },
                        '\0' => break,
                        _ch =>
                    {}
                    }
                }
                Err(Reject)
            }

            fn byte(input: Cursor) -> Result<Cursor, Reject>
            {
                let input = input.parse("b'")?;
                let mut bytes = input.bytes().enumerate();
                let ok = match bytes.next().map(|(_, b)| b) {
                    Some(b'\\') => match bytes.next().map(|(_, b)| b) {
                        Some(b'x') => backslash_x_byte(&mut bytes).is_ok(),
                        Some(b'n' | b'r' | b't' | b'\\' | b'0' | b'\'' | b'"') => true,
                        _ => false,
                    },
                    b => b.is_some(),
                };
                if !ok {
                    return Err(Reject);
                }
                let (offset, _) = bytes.next().ok_or(Reject)?;
                if !input.chars().as_str().is_char_boundary(offset) {
                    return Err(Reject);
                }
                let input = input.advance(offset).parse("'")?;
                Ok(literal_suffix(input))
            }

            fn character(input: Cursor) -> Result<Cursor, Reject>
            {
                let input = input.parse("'")?;
                let mut chars = input.char_indices();
                let ok = match chars.next().map(|(_, ch)| ch) {
                    Some('\\') => match chars.next().map(|(_, ch)| ch) {
                        Some('x') => backslash_x_char(&mut chars).is_ok(),
                        Some('u') => backslash_u(&mut chars).is_ok(),
                        Some('n' | 'r' | 't' | '\\' | '0' | '\'' | '"') => true,
                        _ => false,
                    },
                    ch => ch.is_some(),
                };
                if !ok {
                    return Err(Reject);
                }
                let (idx, _) = chars.next().ok_or(Reject)?;
                let input = input.advance(idx).parse("'")?;
                Ok(literal_suffix(input))
            }
            
            fn backslash_x_char<I>(chars: &mut I) -> Result<(), Reject> where
            I: Iterator<Item = (usize, char)>,
            {
                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='7' => ch,
                        _ => return Err(Reject),
                    },
                    None => todo!(),
                };

                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='9' | 'a'..='f' | 'A'..='F' => ch,
                        _ => return Err(Reject),
                    },
                    None => todo!(),
                };

                Ok(())
            } 

            fn backslash_x_byte<I>(chars: &mut I) -> Result<(), Reject> where
            I: Iterator<Item = (usize, u8)>,
            {
                /*
                ($chars:ident @ $pat:pat) =>
                {
                    match $chars.next()
                    {
                        Some((_, ch)) => match ch
                        {
                            $pat => ch,
                            _ => return Err(Reject),
                        },
                        None => return Err(Reject),
                    }
                };
                */
                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };

                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        b'0'..=b'9' | b'a'..=b'f' | b'A'..=b'F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };

                Ok(())
            }

            fn backslash_x_nonzero<I>(chars: &mut I) -> Result<(), Reject> where
            I: Iterator<Item = (usize, char)>,
            {
                let first = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='9' | 'a'..='f' | 'A'..='F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };
                
                let second = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '0'..='9' | 'a'..='f' | 'A'..='F' => ch,
                        _ => return Err(Reject),
                    },
                    None => return Err(Reject),
                };
                
                if first == '0' && second == '0' {
                    Err(Reject)
                } else {
                    Ok(())
                }
            }

            fn backslash_u<I>(chars: &mut I) -> Result<char, Reject> where
            I: Iterator<Item = (usize, char)>,
            {
                let _ = match chars.next()
                {
                    Some((_, ch)) => match ch
                    {
                        '{' => ch,
                        _ => return Err(Reject),
                    },
                    None => todo!(),
                };

                let mut value = 0;
                let mut len = 0;
                for (_, ch) in chars
                {
                    let digit = match ch {
                        '0'..='9' => ch as u8 - b'0',
                        'a'..='f' => 10 + ch as u8 - b'a',
                        'A'..='F' => 10 + ch as u8 - b'A',
                        '_' if len > 0 => continue,
                        '}' if len > 0 => return char::from_u32(value).ok_or(Reject),
                        _ => break,
                    };
                    if len == 6 {
                        break;
                    }
                    value *= 0x10;
                    value += u32::from(digit);
                    len += 1;
                }
                Err(Reject)
            }

            fn trailing_backslash(input: &mut Cursor, mut last: u8) -> Result<(), Reject>
            {
                let mut whitespace = input.bytes().enumerate();
                loop {
                    if last == b'\r' && whitespace.next().map_or(true, |(_, b)| b != b'\n') {
                        return Err(Reject);
                    }
                    match whitespace.next() {
                        Some((_, b @ (b' ' | b'\t' | b'\n' | b'\r'))) =>
                    {
                            last = b;
                        }
                        Some((offset, _)) =>
                    {
                            *input = input.advance(offset);
                            return Ok(());
                        }
                        None => return Err(Reject),
                    }
                }
            }

            fn float(input: Cursor) -> Result<Cursor, Reject>
            {
                let mut rest = float_digits(input)?;
                if let Some(ch) = rest.chars().next() {
                    if is::ident_start(ch) {
                        rest = ident_not_raw(rest)?.0;
                    }
                }
                word_break(rest)
            }

            fn float_digits(input: Cursor) -> Result<Cursor, Reject>
            {
                let mut chars = input.chars().peekable();
                match chars.next() {
                    Some(ch) if '0' <= ch && ch <= '9' =>
                    {}
                    _ => return Err(Reject),
                }

                let mut len = 1;
                let mut has_dot = false;
                let mut has_exp = false;
                while let Some(&ch) = chars.peek( )
                {
                    match ch {
                        '0'..='9' | '_' =>
                    {
                            chars.next();
                            len += 1;
                        }
                        '.' =>
                    {
                            if has_dot {
                                break;
                            }
                            chars.next();
                            if chars
                                .peek()
                                .map_or(false, |&ch| ch == '.' || is::ident_start(ch))
                            {
                                return Err(Reject);
                            }
                            len += 1;
                            has_dot = true;
                        }
                        'e' | 'E' =>
                    {
                            chars.next();
                            len += 1;
                            has_exp = true;
                            break;
                        }
                        _ => break,
                    }
                }

                if !(has_dot || has_exp) {
                    return Err(Reject);
                }

                if has_exp
                {
                    let token_before_exp = if has_dot {
                        Ok(input.advance(len - 1))
                    } else {
                        Err(Reject)
                    };
                    let mut has_sign = false;
                    let mut has_exp_value = false;
                    while let Some(&ch) = chars.peek() {
                        match ch {
                            '+' | '-' =>
                    {
                                if has_exp_value {
                                    break;
                                }
                                if has_sign {
                                    return token_before_exp;
                                }
                                chars.next();
                                len += 1;
                                has_sign = true;
                            }
                            '0'..='9' =>
                    {
                                chars.next();
                                len += 1;
                                has_exp_value = true;
                            }
                            '_' =>
                    {
                                chars.next();
                                len += 1;
                            }
                            _ => break,
                        }
                    }
                    if !has_exp_value {
                        return token_before_exp;
                    }
                }

                Ok(input.advance(len))
            }

            fn int(input: Cursor) -> Result<Cursor, Reject>
            {
                let mut rest = digits(input)?;
                if let Some(ch) = rest.chars().next() {
                    if is::ident_start(ch) {
                        rest = ident_not_raw(rest)?.0;
                    }
                }
                word_break(rest)
            }

            fn digits(mut input: Cursor) -> Result<Cursor, Reject>
            {
                let base = if input.starts_with("0x") {
                    input = input.advance(2);
                    16
                } else if input.starts_with("0o") {
                    input = input.advance(2);
                    8
                } else if input.starts_with("0b") {
                    input = input.advance(2);
                    2
                } else {
                    10
                };

                let mut len = 0;
                let mut empty = true;
                for b in input.bytes( )
                {
                    match b {
                        b'0'..=b'9' =>
                    {
                            let digit = (b - b'0') as u64;
                            if digit >= base {
                                return Err(Reject);
                            }
                        }
                        b'a'..=b'f' =>
                    {
                            let digit = 10 + (b - b'a') as u64;
                            if digit >= base {
                                break;
                            }
                        }
                        b'A'..=b'F' =>
                    {
                            let digit = 10 + (b - b'A') as u64;
                            if digit >= base {
                                break;
                            }
                        }
                        b'_' =>
                    {
                            if empty && base == 10 {
                                return Err(Reject);
                            }
                            len += 1;
                            continue;
                        }
                        _ => break,
                    }
                    len += 1;
                    empty = false;
                }
                if empty {
                    Err(Reject)
                } else {
                    Ok(input.advance(len))
                }
            }

            fn punct(input: Cursor) -> PResult<Punct>
            {
                let (rest, ch) = punct_char(input)?;
                if ch == '\''
                {
                    let (after_lifetime, _ident) = ident_any(rest)?;
                    if after_lifetime.starts_with_char('\'')
                        || (after_lifetime.starts_with_char('#') && !rest.starts_with("r#"))
                    {
                        Err(Reject)
                    } else {
                        Ok((rest, Punct::new('\'', Spacing::Joint)))
                    }
                } else
                {
                    let kind = match punct_char(rest) {
                        Ok(_) => Spacing::Joint,
                        Err(Reject) => Spacing::Alone,
                    };
                    Ok((rest, Punct::new(ch, kind)))
                }
            }

            fn punct_char(input: Cursor) -> PResult<char>
            {
                if input.starts_with("//") || input.starts_with("/*") {
                   
                    return Err(Reject);
                }

                let mut chars = input.chars();
                let first = match chars.next() {
                    Some(ch) => ch,
                    None =>
                    {
                        return Err(Reject);
                    }
                };
                let recognized = "~!@#$%^&*-=+|;:,<.>/?'";
                if recognized.contains(first) {
                    Ok((input.advance(first.len_utf8()), first))
                } else {
                    Err(Reject)
                }
            }

            fn doc_comment<'a>(input: Cursor<'a>, trees: &mut TokenStreamBuilder) -> PResult<'a, ()>
            {
                let lo = input.off;
                let (rest, (comment, inner)) = doc_comment_contents(input)?;
                let fallback_span = Span {
                            lo,
                            hi: rest.off,
                };
                let span = ::process::macros::Span::_new_fallback(fallback_span);

                let mut scan_for_bare_cr = comment;
                while let Some(cr) = scan_for_bare_cr.find('\r')
                {
                    let rest = &scan_for_bare_cr[cr + 1..];
                    if !rest.starts_with('\n') {
                        return Err(Reject);
                    }
                    scan_for_bare_cr = rest;
                }

                let mut pound = Punct::new('#', Spacing::Alone);
                pound.set_span(span);
                trees.push_token_from_parser(TokenTree::Punct(pound));

                if inner
                {
                    let mut bang = Punct::new('!', Spacing::Alone);
                    bang.set_span(span);
                    trees.push_token_from_parser(TokenTree::Punct(bang));
                }

                let doc_ident = ::process::macros::Ident::_new_fallback(Ident::new_unchecked("doc", fallback_span));
                let mut equal = Punct::new('=', Spacing::Alone);
                equal.set_span(span);
                let mut literal = ::process::macros::Literal::_new_fallback(Literal::string(comment));
                literal.set_span(span);
                let mut bracketed = TokenStreamBuilder::with_capacity(3);
                bracketed.push_token_from_parser(TokenTree::Ident(doc_ident));
                bracketed.push_token_from_parser(TokenTree::Punct(equal));
                bracketed.push_token_from_parser(TokenTree::Literal(literal));
                let group = Group::new(Delimiter::Bracket, bracketed.build());
                let mut group = ::process::macros::Group::_new_fallback(group);
                group.set_span(span);
                trees.push_token_from_parser(TokenTree::Group(group));

                Ok((rest, ()))
            }

            fn doc_comment_contents(input: Cursor<'_>) -> PResult<'_, (&str, bool)>
            {
                if input.starts_with("//!")
                {
                    let input = input.advance(3);
                    let (input, s) = take_until_newline_or_eof(input);
                    Ok((input, (s, true)))
                } else if input.starts_with("/*!")
                {
                    let (input, s) = block_comment(input)?;
                    Ok((input, (&s[3..s.len() - 2], true)))
                } else if input.starts_with("///")
                {
                    let input = input.advance(3);
                    if input.starts_with_char('/') {
                        return Err(Reject);
                    }
                    let (input, s) = take_until_newline_or_eof(input);
                    Ok((input, (s, false)))
                } else if input.starts_with("/**") && !input.rest[3..].starts_with('*')
                {
                    let (input, s) = block_comment(input)?;
                    Ok((input, (&s[3..s.len() - 2], false)))
                } else {
                    Err(Reject)
                }
            }

            fn take_until_newline_or_eof(input: Cursor<'_>) -> (Cursor<'_>, &str) 
            {
                let chars = input.char_indices();

                for (i, ch) in chars {
                    if ch == '\n' {
                        return (input.advance(i), &input.rest[..i]);
                    } else if ch == '\r' && input.rest[i + 1..].starts_with('\n') {
                        return (input.advance(i + 1), &input.rest[..i]);
                    }
                }

                (input.advance(input.len()), input.rest)
            }
        }

        pub mod probe
        {
            use ::
            {
                *,
            };
            /*
            */
            pub mod proc_macro_span
            {
                use ::
                {
                    ops::{ Range, RangeBounds },
                    path::{ PathBuf },
                    proc_macro::{ Literal, Span },
                    *,
                };
                /*
                */
                pub fn byte_range(this: &Span) -> Range<usize>
                {
                    //this.byte_range()
                    Range { start: 0, end: 0 }
                }
                pub fn start(this: &Span) -> Span { this.start() }
                pub fn end(this: &Span) -> Span { this.end() }
                pub fn line(this: &Span) -> usize { this.line() }
                pub fn column(this: &Span) -> usize { this.column() }
                pub fn file(this: &Span) -> String { this.file() }
                pub fn local_file(this: &Span) -> Option<PathBuf>
                    { this.local_file() }
                pub fn join(this: &Span, other: Span) -> Option<Span> 
                {
                    //this.join(other)
                    None
                }
                pub fn subspan<R:RangeBounds<usize>>( this:&Literal, range:R ) -> Option<Span>
                {
                    //this.subspan( range )
                    None
                }
                /*
               
                #[cfg(procmacro2_build_probe)] */
                const _: Option<&str> = option_env!("RUSTC_BOOTSTRAP");
            }
            
            pub mod proc_macro_span_file
            {
                use ::
                {
                    path::PathBuf,
                    proc_macro::Span,
                    *,
                };
                /*
                */
                pub fn file(this: &Span) -> String {
                    this.file()
                }

                pub fn local_file(this: &Span) -> Option<PathBuf>
                    {
                    this.local_file()
                }
            }
            
            pub mod proc_macro_span_location
            {
                use ::
                {
                    proc_macro::Span,
                    *,
                };
                /*
                */
                pub fn start(this: &Span) -> Span { this.start() }
                pub fn end(this: &Span) -> Span { this.end() }
                pub fn line(this: &Span) -> usize { this.line() }
                pub fn column(this: &Span) -> usize { this.column() }
            }
            
        }

        pub mod rcvec
        {
            use ::
            {
                rc::{ Rc },
                panic::{ RefUnwindSafe },
                *,
            };
            /*
            use alloc::rc::Rc;
            use alloc::vec;
            use ::mem;
            use ::panic::RefUnwindSafe;
            use ::slice;
            */
            pub struct RcVec<T>
            {
                inner: rc::Rc<Vec<T>>,
            }

            pub struct RcVecBuilder<T>
            {
                inner: Vec<T>,
            }

            pub struct RcVecMut<'a, T>
            {
                inner: &'a mut Vec<T>,
            }

            #[derive(Clone)]
            pub struct RcVecIntoIter<T>
            {
                inner: vec::IntoIter<T>,
            }

            impl<T> RcVec<T>
            {
                pub fn is_empty( &self ) -> bool 
                {
                    self.inner.is_empty()
                }

                pub fn len( &self ) -> usize 
                {
                    self.inner.len()
                }

                pub fn iter( &self ) -> slice::Iter<'_, T>
                {
                    self.inner.iter()
                }

                pub fn make_mut( &mut self ) -> RcVecMut<'_, T> where
                T: Clone,
                {
                    RcVecMut {
                        inner: rc::Rc::make_mut(&mut self.inner),
                    }
                }

                pub fn get_mut( &mut self ) -> Option<RcVecMut<'_, T>>
               
                {
                    let inner = rc::Rc::get_mut(&mut self.inner)?;
                    Some(RcVecMut { inner })
                }

                pub fn make_owned(mut self) -> RcVecBuilder<T> where
                T: Clone,
               
                {
                    let vec = if let Some(owned) = rc::Rc::get_mut(&mut self.inner) {
                        mem::take(owned)
                    } else {
                        Vec::clone(&self.inner)
                    };
                    RcVecBuilder { inner: vec }
                }
            }

            impl<T> RcVecBuilder<T>
            {
                pub fn new() -> Self {
                    RcVecBuilder { inner: Vec::new() }
                }

                pub fn with_capacity(cap: usize) -> Self {
                    RcVecBuilder {
                        inner: Vec::with_capacity(cap),
                    }
                }

                pub fn push(&mut self, element: T) {
                    self.inner.push(element);
                }

                pub fn extend(&mut self, iter: impl IntoIterator<Item = T>) {
                    self.inner.extend(iter);
                }

                pub fn as_mut( &mut self ) -> RcVecMut<'_, T>
                {
                    RcVecMut {
                        inner: &mut self.inner,
                    }
                }

                pub fn build( self ) -> RcVec<T>
                    {
                    RcVec {
                        inner: rc::Rc::new(self.inner),
                    }
                }
            }

            impl<'a, T> RcVecMut<'a, T>
            {
                pub fn push(&mut self, element: T) {
                    self.inner.push(element);
                }

                pub fn extend(&mut self, iter: impl IntoIterator<Item = T>) {
                    self.inner.extend(iter);
                }

                pub fn as_mut( &mut self ) -> RcVecMut<'_, T> 
                {
                    RcVecMut { inner: self.inner }
                }

                pub fn take( self ) -> RcVecBuilder<T>
                {
                    let vec = mem::take(self.inner);
                    RcVecBuilder { inner: vec }
                }
            }

            impl<T> Clone for RcVec<T>           
            {
                fn clone( &self ) -> Self
                {
                    RcVec {
                        inner: rc::Rc::clone(&self.inner),
                    }
                }
            }

            impl<T> IntoIterator for RcVecBuilder<T>
            {
                type Item = T;
                type IntoIter = RcVecIntoIter<T>;
                fn into_iter( self ) -> Self::IntoIter
                {
                    RcVecIntoIter
                    {
                        inner: self.inner.into_iter(),
                    }
                }
            }

            impl<T> Iterator for RcVecIntoIter<T>
            {
                type Item = T;
                fn next( &mut self ) -> Option<Self::Item>
                    { self.inner.next() }
                
                fn size_hint( &self ) -> (usize, Option<usize>) { self.inner.size_hint() }
            }

            impl<T> RefUnwindSafe for RcVec<T> where
            T:RefUnwindSafe
            {}
        }
        /// Public implementation details for the `TokenStream` type, such as iterators.
        pub mod token_stream 
        {
            use ::
            {
                fmt::{ self, Debug },
                marker::{ ProcMacroAutoTraits, MARKER },
                process::macros::
                {
                    imp, TokenStream, TokenTree
                },
                *,
            };
            /// An iterator over `TokenStream`'s `TokenTree`s.
            #[derive(Clone)]
            pub struct IntoIter
            {
                inner: imp::TokenTreeIter,
                _marker: ProcMacroAutoTraits,
            }

            impl Iterator for IntoIter
            {
                type Item = TokenTree;
                fn next( &mut self ) -> Option<TokenTree>
                {
                    self.inner.next()
                }

                fn size_hint( &self ) -> (usize, Option<usize>)
                {
                    self.inner.size_hint()
                }
            }

            impl Debug for IntoIter
            {
                fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    f.write_str("TokenStream ")?;
                    f.debug_list().entries(self.clone()).finish()
                }
            }

            impl IntoIterator for TokenStream
            {
                type Item = TokenTree;
                type IntoIter = IntoIter;
                fn into_iter( self ) -> IntoIter
                {
                    IntoIter {
                        inner: self.inner.into_iter(),
                        _marker: ::marker::MARKER,
                    }
                }
            }
        }
        /// An abstract stream of tokens, or more concretely a sequence of token trees
        #[derive(Clone)]
        pub struct TokenStream
        {
            inner: imp::TokenStream,
            _marker: ::marker::ProcMacroAutoTraits,
        }
        /// Error returned from `TokenStream::from_str`.
        pub struct LexError
        {
            inner: imp::LexError,
            _marker: ::marker::ProcMacroAutoTraits,
        }

        impl TokenStream       
        {
            fn _new(inner: imp::TokenStream) -> Self {
                TokenStream {
                    inner,
                    _marker: marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::TokenStream) -> Self {
                TokenStream {
                    inner: imp::TokenStream::from(inner),
                    _marker: marker::MARKER,
                }
            }
            /// Returns an empty `TokenStream` containing no token trees.
            pub fn new() -> Self {
                TokenStream::_new(imp::TokenStream::new())
            }
            /// Checks if this `TokenStream` is empty.
            pub fn is_empty( &self ) -> bool           
            {
                self.inner.is_empty()
            }
        }
        /// `TokenStream::default()` returns an empty stream, equivalent with `TokenStream::new()`.
        impl Default for TokenStream       
        {
            fn default() -> Self {
                TokenStream::new()
            }
        }
        /// Attempts to break the string into tokens and parse those tokens into a token stream.
        impl str::FromStr for TokenStream
        {
            type Err = LexError;
            fn from_str(src: &str) -> Result<TokenStream, LexError>
            {
                match imp::TokenStream::from_str_checked(src) {
                    Ok(tokens) => Ok(TokenStream::_new(tokens)),
                    Err(lex) => Err(LexError {
                        inner: lex,
                        _marker: marker::MARKER,
                    }),
                }
            }
        }
        
        impl From<proc_macro::TokenStream> for TokenStream       
        {
            fn from(inner: proc_macro::TokenStream) -> Self {
                TokenStream::_new(imp::TokenStream::from(inner))
            }
        }
        
        impl From<TokenStream> for proc_macro::TokenStream       
        {
            fn from(inner: TokenStream) -> Self {
                proc_macro::TokenStream::from(inner.inner)
            }
        }

        impl From<TokenTree> for TokenStream       
        {
            fn from(token: TokenTree) -> Self {
                TokenStream::_new(imp::TokenStream::from(token))
            }
        }

        impl Extend<TokenTree> for TokenStream       
        {
            fn extend<I: IntoIterator<Item = TokenTree>>(&mut self, streams: I)
            {
                self.inner.extend(streams);
            }
        }

        impl Extend<TokenStream> for TokenStream       
        {
            fn extend<I: IntoIterator<Item = TokenStream>>(&mut self, streams: I)
            {
                self.inner
                    .extend(streams.into_iter().map(|stream| stream.inner));
            }
        }
        /// Collects a number of token trees into a single stream.
        impl iter::FromIterator<TokenTree> for TokenStream       
        {
            fn from_iter<I: IntoIterator<Item = TokenTree>>(streams: I) -> Self {
                TokenStream::_new(streams.into_iter().collect())
            }
        }
        impl iter::FromIterator<TokenStream> for TokenStream       
        {
            fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {
                TokenStream::_new(streams.into_iter().map(|i| i.inner).collect())
            }
        }
        /// Prints the token stream as a string that is supposed to be losslessly
        /// convertible back into the same token stream (modulo spans), except for
        /// possibly `TokenTree::Group`s with `Delimiter::None` delimiters and negative
        /// numeric literals.
        impl Display for TokenStream       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Display::fmt(&self.inner, f)
            }
        }
        /// Prints token in a form convenient for debugging.
        impl Debug for TokenStream       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Debug::fmt(&self.inner, f)
            }
        }

        impl LexError 
        {
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
        }

        impl Debug for LexError
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Debug::fmt(&self.inner, f)
            }
        }

        impl Display for LexError
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Display::fmt(&self.inner, f)
            }
        }

        impl Error for LexError {}
        /// A region of source code, along with macro expansion information.
        #[derive(Copy, Clone)]
        pub struct Span
        {
            inner: imp::Span,
            _marker: marker::ProcMacroAutoTraits,
        }

        impl Span
        {
            fn _new(inner: imp::Span) -> Self {
                Span {
                    inner,
                    _marker: marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::Span) -> Self 
            {
                Span {
                    inner: imp::Span::from(inner),
                    _marker: marker::MARKER,
                }
            }
            /// The span of the invocation of the current procedural macro
            pub fn call_site() -> Self 
            {
                Span::_new(imp::Span::call_site())
            }
            /// The span located at the invocation of the procedural macro,
            /// but with local variables, labels, and `$crate` resolved at the definition site of the macro.
            pub fn mixed_site() -> Self 
            {
                Span::_new(imp::Span::mixed_site())
            }
            /// A span that resolves at the macro definition site.
            pub fn def_site() -> Self 
            {
                Span::_new(imp::Span::def_site())
            }
            /// Creates a new span with the same line/column information as `self` but
            /// that resolves symbols as though it were at `other`.
            pub fn resolved_at( &self, other: Span) -> Span 
            {
                Span::_new(self.inner.resolved_at(other.inner))
            }
            /// Creates a new span with the same name resolution behavior as `self` but
            /// with the line/column information of `other`.
            pub fn located_at( &self, other: Span) -> Span 
            {
                Span::_new(self.inner.located_at(other.inner))
            }
            /// Convert `process::macros::Span` to `proc_macro::Span`
            pub fn unwrap( self ) -> proc_macro::Span 
           
            {
                self.inner.unwrap()
            }
           
            pub fn unstable( self ) -> proc_macro::Span
           
            {
                self.unwrap()
            }
            /// Returns the span's byte position range in the source file
            pub fn byte_range( &self ) -> Range<usize>
           
            {
                self.inner.byte_range()
            }
            /// Get the starting line/column in the source file for this span
            pub fn start( &self ) -> location::LineColumn
           
            {
                self.inner.start()
            }
            /// Get the ending line/column in the source file for this span
            pub fn end( &self ) -> location::LineColumn
           
            {
                self.inner.end()
            }
            /// The path to the source file in which this span occurs, for display purposes
            pub fn file( &self ) -> String
           
            {
                self.inner.file()
            }
            /// The path to the source file in which this span occurs on disk.
            pub fn local_file( &self ) -> Option<PathBuf>
           
            {
                self.inner.local_file()
            }
            /// Create a new span encompassing `self` and `other`.
            pub fn join( &self, other: Span) -> Option<Span>
           
            {
                self.inner.join(other.inner).map(Span::_new)
            }
            /// Compares two spans to see if they're equal.
            pub fn eq( &self, other: &Span) -> bool
            {
                self.inner.eq(&other.inner)
            }
            /// Returns the source text behind a span.
            pub fn source_text( &self ) -> Option<String>
           
            {
                self.inner.source_text()
            }
        }
        /// Prints a span in a form convenient for debugging.
        impl Debug for Span
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Debug::fmt(&self.inner, f)
            }
        }
        /// A single token or a delimited sequence of token trees (e.g. `[1, (), ..]`).
        #[derive(Clone)]
        pub enum TokenTree 
        {
            /// A token stream surrounded by bracket delimiters.
            Group(Group),
            /// An identifier.
            Ident(Ident),
            /// A single punctuation character (`+`, `,`, `$`, etc.).
            Punct(Punct),
            /// A literal character (`'a'`), string (`"hello"`), number (`2.3`), etc.
            Literal(Literal),
        }

        impl TokenTree 
        {
            /// Returns the span of this tree, 
            /// delegating to the `span` method of the contained token or a delimited stream.
            pub fn span( &self ) -> Span {
                match self {
                    TokenTree::Group(t) => t.span(),
                    TokenTree::Ident(t) => t.span(),
                    TokenTree::Punct(t) => t.span(),
                    TokenTree::Literal(t) => t.span(),
                }
            }
            /// Configures the span for *only this token*
            pub fn set_span(&mut self, span: Span) {
                match self {
                    TokenTree::Group(t) => t.set_span(span),
                    TokenTree::Ident(t) => t.set_span(span),
                    TokenTree::Punct(t) => t.set_span(span),
                    TokenTree::Literal(t) => t.set_span(span),
                }
            }
        }

        impl From<Group> for TokenTree
        {
            fn from(g: Group) -> Self {
                TokenTree::Group(g)
            }
        }

        impl From<Ident> for TokenTree
        {
            fn from(g: Ident) -> Self {
                TokenTree::Ident(g)
            }
        }

        impl From<Punct> for TokenTree
        {
            fn from(g: Punct) -> Self {
                TokenTree::Punct(g)
            }
        }

        impl From<Literal> for TokenTree
        {
            fn from(g: Literal) -> Self {
                TokenTree::Literal(g)
            }
        }
        /**
            Prints the token tree as a string that is losslessly convertible back into the same tree (modulo spans),
            except for `TokenTree::Group`s with `Delimiter::None` delimiters and negative numeric literals. */
        impl Display for TokenTree       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {match self {
                    TokenTree::Group(t) => Display::fmt(t, f),
                    TokenTree::Ident(t) => Display::fmt(t, f),
                    TokenTree::Punct(t) => Display::fmt(t, f),
                    TokenTree::Literal(t) => Display::fmt(t, f),
                }
            }
        }
        /// Prints token tree in a form convenient for debugging.
        impl Debug for TokenTree
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
               
               
                match self {
                    TokenTree::Group(t) => Debug::fmt(t, f),
                    TokenTree::Ident(t) =>
                    {
                        let mut debug = f.debug_struct("Ident");
                        debug.field("sym", &format_args!("{}", t));
                        imp::debug_span_field_if_nontrivial(&mut debug, t.span().inner);
                        debug.finish()
                    }
                    TokenTree::Punct(t) => Debug::fmt(t, f),
                    TokenTree::Literal(t) => Debug::fmt(t, f),
                }
            }
        }
        /// A delimited token stream.
        #[derive(Clone)]
        pub struct Group {
            inner: imp::Group,
        }
        /// Describes how a sequence of token trees is delimited.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Delimiter 
        {
            /// `( ... )`
            Parenthesis,
            /// `{ ... }`
            Brace,
            /// `[ ... ]`
            Bracket,
            /// `∅ ... ∅
            /// Invisible delimiters may not survive roundtrip of a token stream through a string instead in this context.
            None,
        }

        impl Group
        {
            fn _new(inner: imp::Group) -> Self {
                Group { inner }
            }

            fn _new_fallback(inner: fallback::Group) -> Self {
                Group {
                    inner: imp::Group::from(inner),
                }
            }
            /// Creates a new `Group` with the given delimiter and token stream
            pub fn new(delimiter: Delimiter, stream: TokenStream) -> Self {
                Group {
                    inner: imp::Group::new(delimiter, stream.inner),
                }
            }
            /// Returns the punctuation used as the delimiter for this group: a set of
            /// parentheses, square brackets, or curly braces.
            pub fn delimiter( &self ) -> Delimiter
            {
                self.inner.delimiter()
            }
            /// Returns the `TokenStream` of tokens that are delimited in this `Group`
            pub fn stream( &self ) -> TokenStream {
                TokenStream::_new(self.inner.stream())
            }
            /// Returns the span for the delimiters of this token stream, spanning the entire `Group`
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
            /// Returns the span pointing to the opening delimiter of this group
            pub fn span_open( &self ) -> Span {
                Span::_new(self.inner.span_open())
            }
            /// Returns the span pointing to the closing delimiter of this group
            pub fn span_close( &self ) -> Span {
                Span::_new(self.inner.span_close())
            }
            /// Returns an object that holds this group's `span_open()` and `span_close()` together.
            pub fn delim_span( &self ) -> ::process::macros::extra::DelimSpan
            {
                ::process::macros::extra::DelimSpan::new(&self.inner)
            }
            /// Configures the span for this `Group`'s delimiters, but not its internal
            /// tokens
            pub fn set_span(&mut self, span: Span)
            {
                self.inner.set_span(span.inner);
            }
        }
        /// Prints the group as a string that should be losslessly convertible back
        /// into the same group (modulo spans), except for possibly `TokenTree::Group`s
        /// with `Delimiter::None` delimiters.
        impl Display for Group
        {
            fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result
                {Display::fmt(&self.inner, formatter)
            }
        }

        impl Debug for Group
        {
            fn fmt( &self, formatter: &mut fmt::Formatter) -> fmt::Result
                {Debug::fmt(&self.inner, formatter)
            }
        }
        /// A `Punct` is a single punctuation character like `+`, `-` or `#`.
        #[derive(Clone)]
        pub struct Punct 
        {
            ch: char,
            spacing: Spacing,
            span: Span,
        }
        /// Whether a `Punct` is followed immediately by another `Punct` or followed by another token or whitespace.
        #[derive(Copy, Clone, Debug, Eq, PartialEq)]
        pub enum Spacing 
        {
            /// E.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.
            Alone,
            /// E.g. `+` is `Joint` in `+=` or `'` is `Joint` in `'#`
            Joint,
        }

        impl Punct
        {
            /// Creates a new `Punct` from the given character and spacing
            /// which can be further configured with the `set_span` method below.
            pub fn new(ch: char, spacing: Spacing) -> Self {
                if let '!' | '#' | '$' | '%' | '&' | '\'' | '*' | '+' | ',' | '-' | '.' | '/' | ':' | ';'
                | '<' | '=' | '>' | '?' | '@' | '^' | '|' | '~' = ch
                {
                    Punct {
                        ch,
                        spacing,
                        span: Span::call_site(),
                    }
                } else {
                    panic!("unsupported proc macro punctuation character {:?}", ch);
                }
            }
            /// Returns the value of this punctuation character as `char`.
            pub fn as_char( &self ) -> char
            {
                self.ch
            }
            /// Returns the spacing of this punctuation character, indicating whether
            /// it's immediately followed by another `Punct` in the token stream, so
            /// they can potentially be combined into a multicharacter operator
            /// (`Joint`), or it's followed by some other token or whitespace (`Alone`)
            /// so the operator has certainly ended.
            pub fn spacing( &self ) -> Spacing
            {
                self.spacing
            }
            /// Returns the span for this punctuation character.
            pub fn span( &self ) -> Span
            {
                self.span
            }
            /// Configure the span for this punctuation character.
            pub fn set_span(&mut self, span: Span)
            {
                self.span = span;
            }
        }
        /// Prints the punctuation character as a string that is losslessly convertible back into the same character.
        impl Display for Punct
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Display::fmt(&self.ch, f)
            }
        }

        impl Debug for Punct       
        {
            fn fmt( &self, fmt: &mut fmt::Formatter) -> fmt::Result
            {
                let mut debug = fmt.debug_struct("Punct");
                debug.field("char", &self.ch);
                debug.field("spacing", &self.spacing);
                imp::debug_span_field_if_nontrivial(&mut debug, self.span.inner);
                debug.finish()
            }
        }
        /// A word of Rust code, which may be a keyword or legal variable name.
        #[derive(Clone)]
        pub struct Ident
        {
            inner: imp::Ident,
            _marker: marker::ProcMacroAutoTraits,
        }

        impl Ident       
        {
            fn _new(inner: imp::Ident) -> Self {
                Ident {
                    inner,
                    _marker: marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::Ident) -> Self {
                Ident {
                    inner: imp::Ident::from(inner),
                    _marker: marker::MARKER,
                }
            }
            /// Creates a new `Ident` with the given `string` as well as the specified `span`
            #[track_caller] pub fn new(string: &str, span: Span) -> Self {
                Ident::_new(imp::Ident::new_checked(string, span.inner))
            }
            /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).
            #[track_caller] pub fn new_raw(string: &str, span: Span) -> Self {
                Ident::_new(imp::Ident::new_raw_checked(string, span.inner))
            }
            /// Returns the span of this `Ident`.
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
            /// Configures the span of this `Ident`, possibly changing its hygiene context.
            pub fn set_span(&mut self, span: Span)
            {
                self.inner.set_span(span.inner);
            }
        }

        impl PartialEq for Ident       
        {
            fn eq( &self, other: &Ident) -> bool
            {
                self.inner == other.inner
            }
        }

        impl<T> PartialEq<T> for Ident where
        T: ?Sized + AsRef<str>       
        {
            fn eq( &self, other: &T) -> bool
            {
                self.inner == other
            }
        }

        impl Eq for Ident {}

        impl PartialOrd for Ident       
        {
            fn partial_cmp( &self, other: &Ident) -> Option<Ordering>
                    {
                Some(self.cmp(other))
            }
        }

        impl Ord for Ident 
       
        {
            fn cmp( &self, other: &Ident) -> Ordering
            {
                self.to_string().cmp(&other.to_string())
            }
        }

        impl Hash for Ident       
        {
            fn hash<H: Hasher>( &self, hasher: &mut H)
            {
                self.to_string().hash(hasher);
            }
        }
        /// Prints the identifier as a string that should be losslessly convertible back into the same identifier.
        impl Display for Ident        
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Display::fmt(&self.inner, f)
            }
        }

        impl Debug for Ident       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Debug::fmt(&self.inner, f)
            }
        }
        /// A literal string (`"hello"`), byte string (`b"hello"`), character (`'a'`),
        /// byte character (`b'a'`), an integer or floating point number with or without
        /// a suffix (`1`, `1u8`, `2.3`, `2.3f32`).
        #[derive(Clone)]
        pub struct Literal
        {
            inner: imp::Literal,
            _marker: marker::ProcMacroAutoTraits,
        }

        macro_rules! suffixed_int_literals
        {
            ($($name:ident => $kind:ident,)*) => 
            ($(
                /// Creates a new suffixed integer literal with the specified value.
                pub fn $name(n: $kind) -> Literal 
                {
                    Literal::_new(imp::Literal::$name(n))
                }
            )*);
        }

        macro_rules! unsuffixed_int_literals 
        {
            ($($name:ident => $kind:ident,)*) => ($(
                /// Creates a new unsuffixed integer literal with the specified value.
                pub fn $name(n: $kind) -> Literal {
                    Literal::_new(imp::Literal::$name(n))
                }
            )*)
        }

        impl Literal        
        {
            fn _new(inner: imp::Literal) -> Self 
            {
                Literal {
                    inner,
                    _marker: ::marker::MARKER,
                }
            }

            fn _new_fallback(inner: fallback::Literal) -> Self 
            {
                Literal {
                    inner: imp::Literal::from(inner),
                    _marker: ::marker::MARKER,
                }
            }

            suffixed_int_literals! 
            {
                u8_suffixed => u8,
                u16_suffixed => u16,
                u32_suffixed => u32,
                u64_suffixed => u64,
                u128_suffixed => u128,
                usize_suffixed => usize,
                i8_suffixed => i8,
                i16_suffixed => i16,
                i32_suffixed => i32,
                i64_suffixed => i64,
                i128_suffixed => i128,
                isize_suffixed => isize,
            }

            unsuffixed_int_literals! 
            {
                u8_unsuffixed => u8,
                u16_unsuffixed => u16,
                u32_unsuffixed => u32,
                u64_unsuffixed => u64,
                u128_unsuffixed => u128,
                usize_unsuffixed => usize,
                i8_unsuffixed => i8,
                i16_unsuffixed => i16,
                i32_unsuffixed => i32,
                i64_unsuffixed => i64,
                i128_unsuffixed => i128,
                isize_unsuffixed => isize,
            }
            /// Creates a new unsuffixed floating-point literal
            pub fn f64_unsuffixed(f: f64) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f64_unsuffixed(f))
            }
            /// Creates a new suffixed floating-point literal

            pub fn f64_suffixed(f: f64) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f64_suffixed(f))
            }
            /// Creates a new unsuffixed floating-point literal
            pub fn f32_unsuffixed(f: f32) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f32_unsuffixed(f))
            }
            /// Creates a new suffixed floating-point literal
            pub fn f32_suffixed(f: f32) -> Literal 
            {
                assert!(f.is_finite());
                Literal::_new(imp::Literal::f32_suffixed(f))
            }
            /// String literal.
            pub fn string(string: &str) -> Literal 
            {
                Literal::_new(imp::Literal::string(string))
            }
            /// Character literal.
            pub fn character(ch: char) -> Literal 
            {
                Literal::_new(imp::Literal::character(ch))
            }
            /// Byte character literal.
            pub fn byte_character(byte: u8) -> Literal 
            {
                Literal::_new(imp::Literal::byte_character(byte))
            }
            /// Byte string literal.
            pub fn byte_string(bytes: &[u8]) -> Literal 
            {
                Literal::_new(imp::Literal::byte_string(bytes))
            }
            /// C string literal.
            pub fn c_string( string:&::ffi::CStr ) -> Literal 
            {
                Literal::_new(imp::Literal::c_string(string))
            }
            /// Returns the span encompassing this literal.
            pub fn span( &self ) -> Span {
                Span::_new(self.inner.span())
            }
            /// Configures the span associated for this literal.
            pub fn set_span(&mut self, span: Span)
            {
                self.inner.set_span(span.inner);
            }
            /// Returns a `Span` that is a subset of `self.span()` containing only
            /// the source bytes in range `range`.
            pub fn subspan<R: RangeBounds<usize>>( &self, range: R) -> Option<Span> 
           
            {
                self.inner.subspan(range).map(Span::_new)
            }

            pub unsafe fn from_str_unchecked(repr: &str) -> Self 
            {
                Literal::_new(unsafe { imp::Literal::from_str_unchecked(repr) })
            }
        }

        impl ::str::FromStr for Literal 
        {
            type Err = LexError;
            fn from_str(repr: &str) -> Result<Self, LexError>
            {
                match imp::Literal::from_str_checked(repr) {
                    Ok(lit) => Ok(Literal::_new(lit)),
                    Err(lex) => Err(LexError {
                        inner: lex,
                        _marker: ::marker::MARKER,
                    }),
                }
            }
        }

        impl Debug for Literal       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Debug::fmt(&self.inner, f)
            }
        }

        impl Display for Literal       
        {
            fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result
                {Display::fmt(&self.inner, f)
            }
        }
    }
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod quote
{
    /*!
    Provides the [`quote!`] macro for turning Rust syntax tree data structures into tokens of source code. */
    use ::
    {
        *,
    };
    /*
    */
    pub mod ext
    {
        use ::
        {
            process::macros::{ TokenStream, TokenTree },
            quote::{ ToTokens },
            *,
        };
        /*
        */
        /// TokenStream extension trait with methods for appending tokens.
        pub trait TokenStreamExt: private::Sealed
        {
            /// For use by `ToTokens` implementations.
            fn append<U>(&mut self, token: U) where U: Into<TokenTree>;
            /// For use by `ToTokens` implementations.
            fn append_all<I>(&mut self, iter: I) where
            I: IntoIterator,
            I::Item: ToTokens;
            /// For use by `ToTokens` implementations.
            fn append_separated<I, U>(&mut self, iter: I, op: U) where
            I: IntoIterator,
            I::Item: ToTokens,
            U: ToTokens;
            /// For use by `ToTokens` implementations.
            fn append_terminated<I, U>(&mut self, iter: I, term: U) where
            I: IntoIterator,
            I::Item: ToTokens,
            U: ToTokens;
        }

        impl TokenStreamExt for TokenStream
        {
            fn append<U>(&mut self, token: U) where
                U: Into<TokenTree>,
           
            {
                self.extend(iter::once(token.into()));
            }

            fn append_all<I>(&mut self, iter: I) where
                I: IntoIterator,
                I::Item: ToTokens,
            {
                for token in iter {
                    token.to_tokens(self);
                }
            }

            fn append_separated<I, U>(&mut self, iter: I, op: U) where
                I: IntoIterator,
                I::Item: ToTokens,
                U: ToTokens,
            {
                for (i, token) in iter.into_iter().enumerate() {
                    if i > 0 {
                        op.to_tokens(self);
                    }
                    token.to_tokens(self);
                }
            }

            fn append_terminated<I, U>(&mut self, iter: I, term: U) where
                I: IntoIterator,
                I::Item: ToTokens,
                U: ToTokens,
            {
                for token in iter {
                    token.to_tokens(self);
                    term.to_tokens(self);
                }
            }
        }

        mod private 
        {
            use ::process::macros::TokenStream;

            pub trait Sealed {}

            impl Sealed for TokenStream {}
        }
    } pub use self::ext::TokenStreamExt;
    
    pub mod ident_fragment
    {
        use ::
        {
            borrow::{ Cow },
            process::macros::{ Ident, Span },
            *,
        };
        /*
        */
        /// Specialized formatting trait used by `format_ident!`.
        pub trait IdentFragment
        {
            /// Format this value as an identifier fragment.
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result;
            /// Span associated with this `IdentFragment`.
            fn span(&self) -> Option<Span> {
                None
            }
        }

        impl<T: IdentFragment + ?Sized> IdentFragment for &T 
        {
            fn span(&self) -> Option<Span> {
                <T as IdentFragment>::span(*self)
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {IdentFragment::fmt(*self, f)
            }
        }

        impl<T: IdentFragment + ?Sized> IdentFragment for &mut T 
        {
            fn span(&self) -> Option<Span> {
                <T as IdentFragment>::span(*self)
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {IdentFragment::fmt(*self, f)
            }
        }

        impl IdentFragment for Ident 
        {
            fn span(&self) -> Option<Span> {
                Some(self.span())
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {let id = self.to_string();
                if let Some(id) = id.strip_prefix("r#") {
                    fmt::Display::fmt(id, f)
                } else {
                    fmt::Display::fmt(&id[..], f)
                }
            }
        }

        impl<T> IdentFragment for Cow<'_, T> where
        T: IdentFragment + ToOwned + ?Sized,
        {
            fn span(&self) -> Option<Span> {
                T::span(self)
            }

            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {T::fmt(self, f)
            }
        }
        
        macro_rules! ident_fragment_display
        {
            ($($T:ty),*) => {
                $(
                    impl IdentFragment for $T {
                        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {            fmt::Display::fmt(self, f)
                        }
                    }
                )*
            };
        }

        ident_fragment_display!(bool, str, String, char);
        ident_fragment_display!(u8, u16, u32, u64, u128, usize);
    } pub use self::ident_fragment::IdentFragment;
    
    pub mod to_tokens
    {
        use ::
        {
            borrow::{ Cow },
            process::macros::{ Group, Ident, Literal, Punct, Span, TokenStream, TokenTree },
            quote::{ TokenStreamExt },
            rc::{ Rc },
            *,
        };
        /*
        */
        /// Types that can be interpolated inside a `quote!` invocation.
        pub trait ToTokens {
            /// Write `self` to the given `TokenStream`.
            fn to_tokens(&self, tokens: &mut TokenStream);
            /// Convert `self` directly into a `TokenStream` object.
            fn to_token_stream(&self) -> TokenStream
            {
                let mut tokens = TokenStream::new();
                self.to_tokens(&mut tokens);
                tokens
            }
            /// Convert `self` directly into a `TokenStream` object.
            fn into_token_stream(self) -> TokenStream where
            Self: Sized,
           
            {
                self.to_token_stream()
            }
        }

        impl<'a, T: ?Sized + ToTokens> ToTokens for &'a T {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<'a, T: ?Sized + ToTokens> ToTokens for &'a mut T {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<'a, T: ?Sized + ToOwned + ToTokens> ToTokens for Cow<'a, T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<T: ?Sized + ToTokens> ToTokens for Box<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<T: ?Sized + ToTokens> ToTokens for Rc<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                (**self).to_tokens(tokens);
            }
        }

        impl<T: ToTokens> ToTokens for Option<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                if let Some(ref t) = *self {
                    t.to_tokens(tokens);
                }
            }
        }

        impl ToTokens for str 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(Literal::string(self));
            }
        }

        impl ToTokens for String 
        {
            fn to_tokens(&self, tokens: &mut TokenStream)
            {
                self.as_str().to_tokens(tokens);
            }
        }

        macro_rules! primitive 
        {
            ($($t:ident => $name:ident)*) => {
                $(
                    impl ToTokens for $t {
                        fn to_tokens(&self, tokens: &mut TokenStream) {
                            tokens.append(Literal::$name(*self));
                        }
                    }
                )*
            };
        }

        primitive! 
        {
            i8 => i8_suffixed
            i16 => i16_suffixed
            i32 => i32_suffixed
            i64 => i64_suffixed
            i128 => i128_suffixed
            isize => isize_suffixed

            u8 => u8_suffixed
            u16 => u16_suffixed
            u32 => u32_suffixed
            u64 => u64_suffixed
            u128 => u128_suffixed
            usize => usize_suffixed

            f32 => f32_suffixed
            f64 => f64_suffixed
        }

        impl ToTokens for char 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(Literal::character(*self));
            }
        }

        impl ToTokens for bool 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                let word = if *self { "true" } else { "false" };
                tokens.append(Ident::new(word, Span::call_site()));
            }
        }

        impl ToTokens for Group 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for Ident 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for Punct 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for Literal 
        {
            fn to_tokens(&self, tokens: &mut TokenStream) {
                tokens.append(self.clone());
            }
        }

        impl ToTokens for TokenTree 
        {
            fn to_tokens(&self, dst: &mut TokenStream) {
                dst.append(self.clone());
            }
        }

        impl ToTokens for TokenStream 
        {
            fn to_tokens(&self, dst: &mut TokenStream) {
                dst.extend(iter::once(self.clone()));
            }

            fn into_token_stream(self) -> TokenStream { self }
        }
    } pub use self::to_tokens::ToTokens;
    
    pub mod __private
    {
        use ::
        {
            ops::{ BitOr },
            process::macros::{ Group, Ident, Punct, Spacing, TokenTree },
            quote::{ IdentFragment, ToTokens, TokenStreamExt },
            *,
        }; use self::get_span::{GetSpan, GetSpanBase, GetSpanInner};
        /*
        */
        pub type Delimiter = process::macros::Delimiter;
        pub type Span = process::macros::Span;
        pub type TokenStream = process::macros::TokenStream;
        
        macro_rules! push_punct
        {
            ($name:ident $spanned:ident $char1:tt) => {
                    pub fn $name(tokens: &mut TokenStream)
                {
                    tokens.append(Punct::new($char1, Spacing::Alone));
                }
                    pub fn $spanned(tokens: &mut TokenStream, span: Span) {
                    let mut punct = Punct::new($char1, Spacing::Alone);
                    punct.set_span(span);
                    tokens.append(punct);
                }
            };
            ($name:ident $spanned:ident $char1:tt $char2:tt) => {
                    pub fn $name(tokens: &mut TokenStream)
                {
                    tokens.append(Punct::new($char1, Spacing::Joint));
                    tokens.append(Punct::new($char2, Spacing::Alone));
                }
                    pub fn $spanned(tokens: &mut TokenStream, span: Span) {
                    let mut punct = Punct::new($char1, Spacing::Joint);
                    punct.set_span(span);
                    tokens.append(punct);
                    let mut punct = Punct::new($char2, Spacing::Alone);
                    punct.set_span(span);
                    tokens.append(punct);
                }
            };
            ($name:ident $spanned:ident $char1:tt $char2:tt $char3:tt) => {
                    pub fn $name(tokens: &mut TokenStream)
                {
                    tokens.append(Punct::new($char1, Spacing::Joint));
                    tokens.append(Punct::new($char2, Spacing::Joint));
                    tokens.append(Punct::new($char3, Spacing::Alone));
                }
                    pub fn $spanned(tokens: &mut TokenStream, span: Span) {
                    let mut punct = Punct::new($char1, Spacing::Joint);
                    punct.set_span(span);
                    tokens.append(punct);
                    let mut punct = Punct::new($char2, Spacing::Joint);
                    punct.set_span(span);
                    tokens.append(punct);
                    let mut punct = Punct::new($char3, Spacing::Alone);
                    punct.set_span(span);
                    tokens.append(punct);
                }
            };
        }

        pub struct HasIterator;
        pub struct ThereIsNoIteratorInRepetition;

        impl BitOr<ThereIsNoIteratorInRepetition> for ThereIsNoIteratorInRepetition {
            type Output = ThereIsNoIteratorInRepetition;
            fn bitor(self, _rhs: ThereIsNoIteratorInRepetition) -> ThereIsNoIteratorInRepetition {
                ThereIsNoIteratorInRepetition
            }
        }

        impl BitOr<ThereIsNoIteratorInRepetition> for HasIterator {
            type Output = HasIterator;
            fn bitor(self, _rhs: ThereIsNoIteratorInRepetition) -> HasIterator {
                HasIterator
            }
        }

        impl BitOr<HasIterator> for ThereIsNoIteratorInRepetition {
            type Output = HasIterator;
            fn bitor(self, _rhs: HasIterator) -> HasIterator {
                HasIterator
            }
        }

        impl BitOr<HasIterator> for HasIterator {
            type Output = HasIterator;
            fn bitor(self, _rhs: HasIterator) -> HasIterator {
                HasIterator
            }
        }
        /// Extension traits used by the implementation of `quote!`.
        pub mod ext
        {
            use ::
            {
                collections::btree_set::{ self, BTreeSet },
                quote::{ ToTokens },
                *,
            };
            /**/
            use super::RepInterp;
            use super::{HasIterator as HasIter, ThereIsNoIteratorInRepetition as DoesNotHaveIter};
            /// Extension trait providing the `quote_into_iter` method on iterators.
            pub trait RepIteratorExt: Iterator + Sized {
                fn quote_into_iter(self) -> (Self, HasIter) {
                    (self, HasIter)
                }
            }

            impl<T: Iterator> RepIteratorExt for T {}
            /// Extension trait providing the `quote_into_iter` method for non-iterable types.
            pub trait RepToTokensExt {
                /// Pretend to be an iterator for the purposes of `quote_into_iter`.
                /// This allows repeated calls to `quote_into_iter` to continue
                /// correctly returning DoesNotHaveIter.
                fn next(&self) -> Option<&Self> {
                    Some(self)
                }

                fn quote_into_iter(&self) -> (&Self, DoesNotHaveIter) {
                    (self, DoesNotHaveIter)
                }
            }

            impl<T: ToTokens + ?Sized> RepToTokensExt for T {}
            /// Extension trait providing the `quote_into_iter` method for types that can be referenced as an iterator.
            pub trait RepAsIteratorExt<'q>
            {
                type Iter: Iterator;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter);
            }

            impl<'q, 'a, T: RepAsIteratorExt<'q> + ?Sized> RepAsIteratorExt<'q> for &'a T
            {
                type Iter = T::Iter;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    <T as RepAsIteratorExt>::quote_into_iter(*self)
                }
            }

            impl<'q, 'a, T: RepAsIteratorExt<'q> + ?Sized> RepAsIteratorExt<'q> for &'a mut T {
                type Iter = T::Iter;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    <T as RepAsIteratorExt>::quote_into_iter(*self)
                }
            }

            impl<'q, T: 'q> RepAsIteratorExt<'q> for [T] {
                type Iter = slice::Iter<'q, T>;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    (self.iter(), HasIter)
                }
            }

            impl<'q, T: 'q> RepAsIteratorExt<'q> for Vec<T>
            {
                type Iter = slice::Iter<'q, T>;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    (self.iter(), HasIter)
                }
            }

            impl<'q, T: 'q> RepAsIteratorExt<'q> for BTreeSet<T>
            {
                type Iter = btree_set::Iter<'q, T>;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    (self.iter(), HasIter)
                }
            }

            impl<'q, T: RepAsIteratorExt<'q>> RepAsIteratorExt<'q> for RepInterp<T>
            {
                type Iter = T::Iter;
                fn quote_into_iter(&'q self) -> (Self::Iter, HasIter) {
                    self.0.quote_into_iter()
                }
            }
        }

        #[derive(Copy, Clone)]
        pub struct RepInterp<T>(pub T);

        impl<T> RepInterp<T>
        {
            pub fn next(self) -> Option<T>
            {
                Some(self.0)
            }
        }

        impl<T: Iterator> Iterator for RepInterp<T>
        {
            type Item = T::Item;
            fn next(&mut self) -> Option<Self::Item>
            {
                self.0.next()
            }
        }

        impl<T: ToTokens> ToTokens for RepInterp<T>
        {
            fn to_tokens(&self, tokens: &mut TokenStream)
            {
                self.0.to_tokens(tokens);
            }
        }
        
        #[inline] pub fn get_span<T>(span: T) -> GetSpan<T> 
        {
            GetSpan(GetSpanInner(GetSpanBase(span)))
        }

        mod get_span
        {
            use ::
            {
                ops::{ Deref },
                process::macros::
                {
                    extra::DelimSpan, Span
                },
                *,
            };
            /*
            */
            pub struct GetSpan<T>(pub GetSpanInner<T>);

            pub struct GetSpanInner<T>(pub GetSpanBase<T>);

            pub struct GetSpanBase<T>(pub T);

            impl GetSpan<Span> {
                #[inline]
                pub fn __into_span(self) -> Span {
                    ((self.0).0).0
                }
            }

            impl GetSpanInner<DelimSpan> {
                #[inline]
                pub fn __into_span(&self) -> Span {
                    (self.0).0.join()
                }
            }

            impl<T> GetSpanBase<T> {
                #[allow(clippy::unused_self)]
                pub fn __into_span(&self) -> T {
                    unreachable!()
                }
            }

            impl<T> Deref for GetSpan<T>
            {
                type Target = GetSpanInner<T>;

                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }

            impl<T> Deref for GetSpanInner<T>
            {
                type Target = GetSpanBase<T>;

                #[inline]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
        }

        pub fn push_group(tokens: &mut TokenStream, delimiter: Delimiter, inner: TokenStream) 
        {
            tokens.append(Group::new(delimiter, inner));
        }

        pub fn push_group_spanned
        (
            tokens: &mut TokenStream,
            span: Span,
            delimiter: Delimiter,
            inner: TokenStream,
        ) 
        {
            let mut g = Group::new(delimiter, inner);
            g.set_span(span);
            tokens.append(g);
        }

        pub fn parse(tokens: &mut TokenStream, s: &str)
        {
            let s: TokenStream = s.parse().expect("invalid token stream");
            tokens.extend(iter::once(s));
        }

        pub fn parse_spanned(tokens: &mut TokenStream, span: Span, s: &str)
        {
            let s: TokenStream = s.parse().expect("invalid token stream");
            tokens.extend(s.into_iter().map(|t| respan_token_tree(t, span)));
        }
        
        fn respan_token_tree(mut token: TokenTree, span: Span) -> TokenTree
        {
            match &mut token {
                TokenTree::Group(g) => {
                    let stream = g
                        .stream()
                        .into_iter()
                        .map(|token| respan_token_tree(token, span))
                        .collect();
                    *g = Group::new(g.delimiter(), stream);
                    g.set_span(span);
                }
                other => other.set_span(span),
            }
            token
        }

        pub fn push_ident(tokens: &mut TokenStream, s: &str)
        {
            let span = Span::call_site();
            push_ident_spanned(tokens, span, s);
        }

        pub fn push_ident_spanned(tokens: &mut TokenStream, span: Span, s: &str)
        {
            tokens.append(ident_maybe_raw(s, span));
        }

        pub fn push_lifetime(tokens: &mut TokenStream, lifetime: &str)
        {
            struct Lifetime<'a> {
                name: &'a str,
                state: u8,
            }

            impl<'a> Iterator for Lifetime<'a>
            {
                type Item = TokenTree;
                fn next(&mut self) -> Option<Self::Item> {
                    match self.state {
                        0 => {
                            self.state = 1;
                            Some(TokenTree::Punct(Punct::new('\'', Spacing::Joint)))
                        }
                        1 => {
                            self.state = 2;
                            Some(TokenTree::Ident(Ident::new(self.name, Span::call_site())))
                        }
                        _ => None,
                    }
                }
            }

            tokens.extend(Lifetime {
                name: &lifetime[1..],
                state: 0,
            });
        }

        pub fn push_lifetime_spanned(tokens: &mut TokenStream, span: Span, lifetime: &str)
        {
            struct Lifetime<'a> {
                name: &'a str,
                span: Span,
                state: u8,
            }

            impl<'a> Iterator for Lifetime<'a>
            {
                type Item = TokenTree;
                fn next(&mut self) -> Option<Self::Item> {
                    match self.state {
                        0 => {
                            self.state = 1;
                            let mut apostrophe = Punct::new('\'', Spacing::Joint);
                            apostrophe.set_span(self.span);
                            Some(TokenTree::Punct(apostrophe))
                        }
                        1 => {
                            self.state = 2;
                            Some(TokenTree::Ident(Ident::new(self.name, self.span)))
                        }
                        _ => None,
                    }
                }
            }

            tokens.extend(Lifetime {
                name: &lifetime[1..],
                span,
                state: 0,
            });
        }

        push_punct!(push_add push_add_spanned '+');
        push_punct!(push_add_eq push_add_eq_spanned '+' '=');
        push_punct!(push_and push_and_spanned '&');
        push_punct!(push_and_and push_and_and_spanned '&' '&');
        push_punct!(push_and_eq push_and_eq_spanned '&' '=');
        push_punct!(push_at push_at_spanned '@');
        push_punct!(push_bang push_bang_spanned '!');
        push_punct!(push_caret push_caret_spanned '^');
        push_punct!(push_caret_eq push_caret_eq_spanned '^' '=');
        push_punct!(push_colon push_colon_spanned ':');
        push_punct!(push_colon2 push_colon2_spanned ':' ':');
        push_punct!(push_comma push_comma_spanned ',');
        push_punct!(push_div push_div_spanned '/');
        push_punct!(push_div_eq push_div_eq_spanned '/' '=');
        push_punct!(push_dot push_dot_spanned '.');
        push_punct!(push_dot2 push_dot2_spanned '.' '.');
        push_punct!(push_dot3 push_dot3_spanned '.' '.' '.');
        push_punct!(push_dot_dot_eq push_dot_dot_eq_spanned '.' '.' '=');
        push_punct!(push_eq push_eq_spanned '=');
        push_punct!(push_eq_eq push_eq_eq_spanned '=' '=');
        push_punct!(push_ge push_ge_spanned '>' '=');
        push_punct!(push_gt push_gt_spanned '>');
        push_punct!(push_le push_le_spanned '<' '=');
        push_punct!(push_lt push_lt_spanned '<');
        push_punct!(push_mul_eq push_mul_eq_spanned '*' '=');
        push_punct!(push_ne push_ne_spanned '!' '=');
        push_punct!(push_or push_or_spanned '|');
        push_punct!(push_or_eq push_or_eq_spanned '|' '=');
        push_punct!(push_or_or push_or_or_spanned '|' '|');
        push_punct!(push_pound push_pound_spanned '#');
        push_punct!(push_question push_question_spanned '?');
        push_punct!(push_rarrow push_rarrow_spanned '-' '>');
        push_punct!(push_larrow push_larrow_spanned '<' '-');
        push_punct!(push_rem push_rem_spanned '%');
        push_punct!(push_rem_eq push_rem_eq_spanned '%' '=');
        push_punct!(push_fat_arrow push_fat_arrow_spanned '=' '>');
        push_punct!(push_semi push_semi_spanned ';');
        push_punct!(push_shl push_shl_spanned '<' '<');
        push_punct!(push_shl_eq push_shl_eq_spanned '<' '<' '=');
        push_punct!(push_shr push_shr_spanned '>' '>');
        push_punct!(push_shr_eq push_shr_eq_spanned '>' '>' '=');
        push_punct!(push_star push_star_spanned '*');
        push_punct!(push_sub push_sub_spanned '-');
        push_punct!(push_sub_eq push_sub_eq_spanned '-' '=');

        pub fn push_underscore(tokens: &mut TokenStream)
        {
            push_underscore_spanned(tokens, Span::call_site());
        }

        pub fn push_underscore_spanned(tokens: &mut TokenStream, span: Span)
        {
            tokens.append(Ident::new("_", span));
        }
       
        pub fn mk_ident(id: &str, span: Option<Span>) -> Ident
        {
            let span = span.unwrap_or_else(Span::call_site);
            ident_maybe_raw(id, span)
        }

        fn ident_maybe_raw(id: &str, span: Span) -> Ident       
        {
            if let Some(id) = id.strip_prefix("r#") {
                Ident::new_raw(id, span)
            } else {
                Ident::new(id, span)
            }
        }
        
        #[derive(Copy, Clone)]
        pub struct IdentFragmentAdapter<T: IdentFragment>(pub T);

        impl<T: IdentFragment> IdentFragmentAdapter<T>
        {
            pub fn span(&self) -> Option<Span> { self.0.span() }
        }

        impl<T: IdentFragment> fmt::Display for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { IdentFragment::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::Octal> fmt::Octal for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Octal::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::LowerHex> fmt::LowerHex for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::LowerHex::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::UpperHex> fmt::UpperHex for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::UpperHex::fmt(&self.0, f) }
        }

        impl<T: IdentFragment + fmt::Binary> fmt::Binary for IdentFragmentAdapter<T>
        {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { fmt::Binary::fmt(&self.0, f) }
        }
    }
    
    pub mod spanned
    {
        use ::
        {
            process::macros::{ extra::DelimSpan, Span, TokenStream },
            quote::ToTokens,
            *,
        };
        /*
        */
       
        pub trait Spanned: private::Sealed {
            fn __span(&self) -> Span;
        }

        impl Spanned for Span {
            fn __span(&self) -> Span {
                *self
            }
        }

        impl Spanned for DelimSpan {
            fn __span(&self) -> Span
            {
                self.join()
            }
        }

        impl<T: ?Sized + ToTokens> Spanned for T {
            fn __span(&self) -> Span {
                join_spans(self.into_token_stream())
            }
        }

        fn join_spans(tokens: TokenStream) -> Span
        {
            let mut iter = tokens.into_iter().map(|tt| tt.span());

            let first = match iter.next() {
                Some(span) => span,
                None => return Span::call_site(),
            };

            iter.fold(None, |_prev, next| Some(next))
                .and_then(|last| first.join(last))
                .unwrap_or(first)
        }

        mod private
        {
            use ::
            {
                process::macros::
                {
                    extra::DelimSpan, Span
                },
                quote::{ ToTokens },
                *,
            };
            /*
            */
            pub trait Sealed {}
            impl Sealed for Span {}
            impl Sealed for DelimSpan {}
            impl<T: ?Sized + ToTokens> Sealed for T {}
        }
    }
    
}

pub mod rand
{
    /*!
    Utilities for random number generation. */
    use ::
    {
        *,
    };
    /*
    #[cfg(all(feature = "std", feature = "std_rng"))]
    pub use crate::rngs::thread::thread_rng;
    pub use rng::{Fill, Rng};

    #[cfg(all(feature = "std", feature = "std_rng"))]
    use crate::distributions::{Distribution, Standard};
    */
    pub mod core
    {
        /*!
        Core random number generation traits */
        use ::
        {
            boxed::{ Box },
            convert::{ AsMut },
            default::{ Default },
            *,
        };
        /*
        */
        pub mod block
        {
            /*!
            The `BlockRngCore` trait and implementation helpers */
            use ::
            {
                convert::{ AsRef },
                rand::core::
                {
                    impls::{ fill_via_u32_chunks, fill_via_u64_chunks },
                    CryptoRng, Error, RngCore, SeedableRng,
                },
                *,
            };
            /*
            */
            /// Trait for RNGs which do not generate random numbers individually, but in blocks (typically `[u32; N]`).
            pub trait BlockRngCore
            {
                /// Results element type, e.g. `u32`.
                type Item;

                /// Results type. This is the 'block' an RNG implementing `BlockRngCore`
                /// generates, which will usually be an array like `[u32; 16]`.
                type Results: AsRef<[Self::Item]> + AsMut<[Self::Item]> + Default;

                /// Generate a new block of results.
                fn generate(&mut self, results: &mut Self::Results);
            }
            /// Wrapper type implementing [`RngCore`] for types implementing [`BlockRngCore`] with `u32` array buffer.
            #[derive(Clone)]
            pub struct BlockRng<R: BlockRngCore + ?Sized>
            {
                results: R::Results,
                index: usize,
                /// The *core* part of the RNG, implementing the `generate` function.
                pub core: R,
            }
          
            impl<R: BlockRngCore + fmt::Debug> fmt::Debug for BlockRng<R>
            {
                fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result
                {    fmt.debug_struct("BlockRng")
                        .field("core", &self.core)
                        .field("result_len", &self.results.as_ref().len())
                        .field("index", &self.index)
                        .finish()
                }
            }

            impl<R: BlockRngCore> BlockRng<R>
            {
                /// Create a new `BlockRng` from an existing RNG implementing
                /// `BlockRngCore`. Results will be generated on first use.
                #[inline]
                pub fn new(core: R) -> BlockRng<R> {
                    let results_empty = R::Results::default();
                    BlockRng {
                        core,
                        index: results_empty.as_ref().len(),
                        results: results_empty,
                    }
                }

                /// Get the index into the result buffer.
                ///
                /// If this is equal to or larger than the size of the result buffer then
                /// the buffer is "empty" and `generate()` must be called to produce new
                /// results.
                #[inline(always)]
                pub fn index(&self) -> usize {
                    self.index
                }

                /// Reset the number of available results.
                /// This will force a new set of results to be generated on next use.
                #[inline]
                pub fn reset(&mut self) {
                    self.index = self.results.as_ref().len();
                }

                /// Generate a new set of results immediately, setting the index to the
                /// given value.
                #[inline]
                pub fn generate_and_set(&mut self, index: usize) {
                    assert!(index < self.results.as_ref().len());
                    self.core.generate(&mut self.results);
                    self.index = index;
                }
            }

            impl<R: BlockRngCore<Item = u32>> RngCore for BlockRng<R> where
            <R as BlockRngCore>::Results: AsRef<[u32]> + AsMut<[u32]>,
            {
                #[inline]
                fn next_u32(&mut self) -> u32 {
                    if self.index >= self.results.as_ref().len() {
                        self.generate_and_set(0);
                    }

                    let value = self.results.as_ref()[self.index];
                    self.index += 1;
                    value
                }

                #[inline]
                fn next_u64(&mut self) -> u64 {
                    let read_u64 = |results: &[u32], index| {
                        let data = &results[index..=index + 1];
                        u64::from(data[1]) << 32 | u64::from(data[0])
                    };

                    let len = self.results.as_ref().len();

                    let index = self.index;
                    if index < len - 1 {
                        self.index += 2;
                       
                        read_u64(self.results.as_ref(), index)
                    } else if index >= len {
                        self.generate_and_set(2);
                        read_u64(self.results.as_ref(), 0)
                    } else {
                        let x = u64::from(self.results.as_ref()[len - 1]);
                        self.generate_and_set(1);
                        let y = u64::from(self.results.as_ref()[0]);
                        (y << 32) | x
                    }
                }

                #[inline]
                fn fill_bytes(&mut self, dest: &mut [u8]) {
                    let mut read_len = 0;
                    while read_len < dest.len() {
                        if self.index >= self.results.as_ref().len() {
                            self.generate_and_set(0);
                        }
                        let (consumed_u32, filled_u8) =
                            fill_via_u32_chunks(&self.results.as_ref()[self.index..], &mut dest[read_len..]);

                        self.index += consumed_u32;
                        read_len += filled_u8;
                    }
                }

                #[inline(always)]
                fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
                    self.fill_bytes(dest);
                    Ok(())
                }
            }

            impl<R: BlockRngCore + SeedableRng> SeedableRng for BlockRng<R> 
            {
                type Seed = R::Seed;

                #[inline(always)]
                fn from_seed(seed: Self::Seed) -> Self {
                    Self::new(R::from_seed(seed))
                }

                #[inline(always)]
                fn seed_from_u64(seed: u64) -> Self {
                    Self::new(R::seed_from_u64(seed))
                }

                #[inline(always)]
                fn from_rng<S: RngCore>(rng: S) -> Result<Self, Error> {
                    Ok(Self::new(R::from_rng(rng)?))
                }
            }
            /// A wrapper type implementing [`RngCore`] for some type implementing
            /// [`BlockRngCore`] with `u64` array buffer; i.e. this can be used to implement
            /// a full RNG from just a `generate` function.
            #[derive(Clone)]
            pub struct BlockRng64<R: BlockRngCore + ?Sized>
            {
                results: R::Results,
                index: usize,
                half_used: bool,
                /// The *core* part of the RNG, implementing the `generate` function.
                pub core: R,
            }
          
            impl<R: BlockRngCore + fmt::Debug> fmt::Debug for BlockRng64<R>
            {
                fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result
                {    fmt.debug_struct("BlockRng64")
                        .field("core", &self.core)
                        .field("result_len", &self.results.as_ref().len())
                        .field("index", &self.index)
                        .field("half_used", &self.half_used)
                        .finish()
                }
            }

            impl<R: BlockRngCore> BlockRng64<R> 
            {
                /// Create a new `BlockRng` from an existing RNG implementing
                /// `BlockRngCore`. Results will be generated on first use.
                #[inline]
                pub fn new(core: R) -> BlockRng64<R> {
                    let results_empty = R::Results::default();
                    BlockRng64 {
                        core,
                        index: results_empty.as_ref().len(),
                        half_used: false,
                        results: results_empty,
                    }
                }

                /// Get the index into the result buffer.
                ///
                /// If this is equal to or larger than the size of the result buffer then
                /// the buffer is "empty" and `generate()` must be called to produce new
                /// results.
                #[inline(always)]
                pub fn index(&self) -> usize {
                    self.index
                }

                /// Reset the number of available results.
                /// This will force a new set of results to be generated on next use.
                #[inline]
                pub fn reset(&mut self) {
                    self.index = self.results.as_ref().len();
                    self.half_used = false;
                }

                /// Generate a new set of results immediately, setting the index to the
                /// given value.
                #[inline]
                pub fn generate_and_set(&mut self, index: usize) {
                    assert!(index < self.results.as_ref().len());
                    self.core.generate(&mut self.results);
                    self.index = index;
                    self.half_used = false;
                }
            }

            impl<R: BlockRngCore<Item = u64>> RngCore for BlockRng64<R> where
            <R as BlockRngCore>::Results: AsRef<[u64]> + AsMut<[u64]>,
            {
                #[inline]
                fn next_u32(&mut self) -> u32 {
                    let mut index = self.index - self.half_used as usize;
                    if index >= self.results.as_ref().len() {
                        self.core.generate(&mut self.results);
                        self.index = 0;
                        index = 0;
                       
                        self.half_used = false;
                    }

                    let shift = 32 * (self.half_used as usize);

                    self.half_used = !self.half_used;
                    self.index += self.half_used as usize;

                    (self.results.as_ref()[index] >> shift) as u32
                }

                #[inline]
                fn next_u64(&mut self) -> u64 {
                    if self.index >= self.results.as_ref().len() {
                        self.core.generate(&mut self.results);
                        self.index = 0;
                    }

                    let value = self.results.as_ref()[self.index];
                    self.index += 1;
                    self.half_used = false;
                    value
                }

                #[inline]
                fn fill_bytes(&mut self, dest: &mut [u8]) {
                    let mut read_len = 0;
                    self.half_used = false;
                    while read_len < dest.len() {
                        if self.index as usize >= self.results.as_ref().len() {
                            self.core.generate(&mut self.results);
                            self.index = 0;
                        }

                        let (consumed_u64, filled_u8) = fill_via_u64_chunks(
                            &self.results.as_ref()[self.index as usize..],
                            &mut dest[read_len..],
                        );

                        self.index += consumed_u64;
                        read_len += filled_u8;
                    }
                }

                #[inline(always)]
                fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
                    self.fill_bytes(dest);
                    Ok(())
                }
            }

            impl<R: BlockRngCore + SeedableRng> SeedableRng for BlockRng64<R> 
            {
                type Seed = R::Seed;

                #[inline(always)]
                fn from_seed(seed: Self::Seed) -> Self {
                    Self::new(R::from_seed(seed))
                }

                #[inline(always)]
                fn seed_from_u64(seed: u64) -> Self {
                    Self::new(R::seed_from_u64(seed))
                }

                #[inline(always)]
                fn from_rng<S: RngCore>(rng: S) -> Result<Self, Error> {
                    Ok(Self::new(R::from_rng(rng)?))
                }
            }

            impl<R: BlockRngCore + CryptoRng> CryptoRng for BlockRng<R> {}
        }
        
        pub mod error
        {
            /*!
            Error types */
            use ::
            {
                boxed::{ Box },
                num::{ NonZeroU32 },
                *,
            };
            /*
            */
            /// Error type of random number generators
            pub struct Error 
            {
                inner: Box<dyn ::error::Error + Send + Sync + 'static>,
            }

            impl Error 
            {
                /// Codes at or above this point can be used by users to define their own
                /// custom errors.
                ///
                /// This has a fixed value of `(1 << 31) + (1 << 30) = 0xC000_0000`,
                /// therefore the number of values available for custom codes is `1 << 30`.
                ///
                /// This is identical to [`getrandom::Error::CUSTOM_START`](https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.CUSTOM_START).
                pub const CUSTOM_START: u32 = (1 << 31) + (1 << 30);
                /// Codes below this point represent OS Errors (i.e. positive i32 values).
                /// Codes at or above this point, but below [`Error::CUSTOM_START`] are
                /// reserved for use by the `rand` and `getrandom` crates.
                ///
                /// This is identical to [`getrandom::Error::INTERNAL_START`](https://docs.rs/getrandom/latest/getrandom/struct.Error.html#associatedconstant.INTERNAL_START).
                pub const INTERNAL_START: u32 = 1 << 31;

                /// Construct from any type supporting `::error::Error`
                ///
                /// Available only when configured with `std`.
                ///
                /// See also `From<NonZeroU32>`, which is available with and without `std`.
                #[cfg(feature = "std")]
                #[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
                #[inline]
                pub fn new<E>(err: E) -> Self
                where
                    E: Into<Box<dyn ::error::Error + Send + Sync + 'static>>,
                {
                    Error { inner: err.into() }
                }

                /// Reference the inner error (`std` only)
                ///
                /// When configured with `std`, this is a trivial operation and never
                /// panics. Without `std`, this method is simply unavailable.
                #[cfg(feature = "std")]
                #[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
                #[inline]
                pub fn inner(&self) -> &(dyn ::error::Error + Send + Sync + 'static) {
                    &*self.inner
                }

                /// Unwrap the inner error (`std` only)
                ///
                /// When configured with `std`, this is a trivial operation and never
                /// panics. Without `std`, this method is simply unavailable.
                #[cfg(feature = "std")]
                #[cfg_attr(doc_cfg, doc(cfg(feature = "std")))]
                #[inline]
                pub fn take_inner(self) -> Box<dyn ::error::Error + Send + Sync + 'static> {
                    self.inner
                }

                /// Extract the raw OS error code (if this error came from the OS)
                ///
                /// This method is identical to `::io::Error::raw_os_error()`, except
                /// that it works in `no_std` contexts. If this method returns `None`, the
                /// error value can still be formatted via the `Display` implementation.
                #[inline]
                pub fn raw_os_error(&self) -> Option<i32> {
                    #[cfg(feature = "std")]
                    {
                        if let Some(e) = self.inner.downcast_ref::<::io::Error>() {
                            return e.raw_os_error();
                        }
                    }
                    match self.code() {
                        Some(code) if u32::from(code) < Self::INTERNAL_START => Some(u32::from(code) as i32),
                        _ => None,
                    }
                }

                /// Retrieve the error code, if any.
                ///
                /// If this `Error` was constructed via `From<NonZeroU32>`, then this method
                /// will return this `NonZeroU32` code (for `no_std` this is always the
                /// case). Otherwise, this method will return `None`.
                #[inline] pub fn code(&self) -> Option<NonZeroU32>
                {
                    self.inner.downcast_ref::<ErrorCode>().map(|c| c.0)
                }
            }

            impl fmt::Debug for Error
            {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {
                    write!(f, "Error {{ inner: {:?} }}", self.inner)
                }
            }

            impl fmt::Display for Error
            {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {    #[cfg(feature = "std")]
                    {
                        write!(f, "{}", self.inner)
                    }
                    #[cfg(all(feature = "getrandom", not(feature = "std")))]
                    {
                        getrandom::Error::from(self.code).fmt(f)
                    }
                    #[cfg(not(feature = "getrandom"))]
                    {
                        write!(f, "error code {}", self.code)
                    }
                }
            }

            impl From<NonZeroU32> for Error
            {
                #[inline] fn from(code: NonZeroU32) -> Self
                {
                    Error
                    {
                        inner: Box::new(ErrorCode(code)),
                    }
                }
            }
            
            impl ::error::Error for Error
            {
                #[inline]
                fn source(&self) -> Option<&(dyn ::error::Error + 'static)> {
                    self.inner.source()
                }
            }
            
            impl From<Error> for ::io::Error 
            {
                #[inline]
                fn from(error: Error) -> Self {
                    if let Some(code) = error.raw_os_error() {
                        ::io::Error::from_raw_os_error(code)
                    } else {
                        ::io::Error::new(::io::ErrorKind::Other, error)
                    }
                }
            }
            
            #[derive(Debug, Copy, Clone)]
            struct ErrorCode(NonZeroU32);
            
            impl fmt::Display for ErrorCode 
            {
                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                {    write!(f, "error code {}", self.0)
                }
            }
            
            impl ::error::Error for ErrorCode {}
        } pub use self::error::Error;
        
        pub mod impls
        {
            /*!
            Helper functions for implementing `RngCore` functions. */
            use ::
            {
                rand::core::{ RngCore },
                *,
            };
            /*
            */
            /// Implement `next_u64` via `next_u32`, little-endian order.
            pub fn next_u64_via_u32<R: RngCore + ?Sized>(rng: &mut R) -> u64 {
               
                let x = u64::from(rng.next_u32());
                let y = u64::from(rng.next_u32());
                (y << 32) | x
            }
            /// Implement `fill_bytes` via `next_u64` and `next_u32`, little-endian order.
            pub fn fill_bytes_via_next<R: RngCore + ?Sized>(rng: &mut R, dest: &mut [u8]) 
            {
                let mut left = dest;
                while left.len() >= 8 {
                    let (l, r) = { left }.split_at_mut(8);
                    left = r;
                    let chunk: [u8; 8] = rng.next_u64().to_le_bytes();
                    l.copy_from_slice(&chunk);
                }
                let n = left.len();
                if n > 4 {
                    let chunk: [u8; 8] = rng.next_u64().to_le_bytes();
                    left.copy_from_slice(&chunk[..n]);
                } else if n > 0 {
                    let chunk: [u8; 4] = rng.next_u32().to_le_bytes();
                    left.copy_from_slice(&chunk[..n]);
                }
            }

            trait Observable: Copy 
            {
                type Bytes: AsRef<[u8]>;
                fn to_le_bytes(self) -> Self::Bytes;

               
                fn as_byte_slice(x: &[Self]) -> &[u8];
            }
            impl Observable for u32 
            {
                type Bytes = [u8; 4];
                fn to_le_bytes(self) -> Self::Bytes {
                    self.to_le_bytes()
                }
                fn as_byte_slice(x: &[Self]) -> &[u8] {
                    let ptr = x.as_ptr() as *const u8;
                    let len = x.len() * core::mem::size_of::<Self>();
                    unsafe { core::slice::from_raw_parts(ptr, len) }
                }
            }
            impl Observable for u64 
            {
                type Bytes = [u8; 8];
                fn to_le_bytes(self) -> Self::Bytes {
                    self.to_le_bytes()
                }
                fn as_byte_slice(x: &[Self]) -> &[u8] {
                    let ptr = x.as_ptr() as *const u8;
                    let len = x.len() * core::mem::size_of::<Self>();
                    unsafe { core::slice::from_raw_parts(ptr, len) }
                }
            }

            fn fill_via_chunks<T: Observable>(src: &[T], dest: &mut [u8]) -> (usize, usize) 
            {
                let size = core::mem::size_of::<T>();
                let byte_len = min(src.len() * size, dest.len());
                let num_chunks = (byte_len + size - 1) / size;

                if cfg!(target_endian = "little") {
                   
                    dest[..byte_len].copy_from_slice(&T::as_byte_slice(&src[..num_chunks])[..byte_len]);
                } else {
                   
                    let mut i = 0;
                    let mut iter = dest[..byte_len].chunks_exact_mut(size);
                    for chunk in &mut iter {
                        chunk.copy_from_slice(src[i].to_le_bytes().as_ref());
                        i += 1;
                    }
                    let chunk = iter.into_remainder();
                    if !chunk.is_empty() {
                        chunk.copy_from_slice(&src[i].to_le_bytes().as_ref()[..chunk.len()]);
                    }
                }

                (num_chunks, byte_len)
            }
            /// Implement `fill_bytes` by reading chunks from the output buffer of a block based RNG.
            pub fn fill_via_u32_chunks(src: &[u32], dest: &mut [u8]) -> (usize, usize) 
            {
                fill_via_chunks(src, dest)
            }
            /// Implement `fill_bytes` by reading chunks from the output buffer of a block based RNG.
            pub fn fill_via_u64_chunks(src: &[u64], dest: &mut [u8]) -> (usize, usize)
            {
                fill_via_chunks(src, dest)
            }
            /// Implement `next_u32` via `fill_bytes`, little-endian order.
            pub fn next_u32_via_fill<R: RngCore + ?Sized>(rng: &mut R) -> u32 
            {
                let mut buf = [0; 4];
                rng.fill_bytes(&mut buf);
                u32::from_le_bytes(buf)
            }
            /// Implement `next_u64` via `fill_bytes`, little-endian order.
            pub fn next_u64_via_fill<R: RngCore + ?Sized>(rng: &mut R) -> u64 
            {
                let mut buf = [0; 8];
                rng.fill_bytes(&mut buf);
                u64::from_le_bytes(buf)
            }
        }
        
        pub mod le
        {
            /*!
            Little-Endian utilities */
            use ::
            {
                *,
            };
            /*
            */
            /// Reads unsigned 32 bit integers from `src` into `dst`.
            #[inline]
            pub fn read_u32_into(src: &[u8], dst: &mut [u32]) {
                assert!(src.len() >= 4 * dst.len());
                for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(4)) {
                    *out = u32::from_le_bytes(chunk.try_into().unwrap());
                }
            }
            /// Reads unsigned 64 bit integers from `src` into `dst`.
            #[inline]
            pub fn read_u64_into(src: &[u8], dst: &mut [u64]) {
                assert!(src.len() >= 8 * dst.len());
                for (out, chunk) in dst.iter_mut().zip(src.chunks_exact(8)) {
                    *out = u64::from_le_bytes(chunk.try_into().unwrap());
                }
            }
        }
        
        /// The core of a random number generator.
        pub trait RngCore 
        {
            /// Return the next random `u32`.
            ///
            /// RNGs must implement at least one method from this trait directly. In
            /// the case this method is not implemented directly, it can be implemented
            /// using `self.next_u64() as u32` or via [`impls::next_u32_via_fill`].
            fn next_u32(&mut self) -> u32;

            /// Return the next random `u64`.
            ///
            /// RNGs must implement at least one method from this trait directly. In
            /// the case this method is not implemented directly, it can be implemented
            /// via [`impls::next_u64_via_u32`] or via [`impls::next_u64_via_fill`].
            fn next_u64(&mut self) -> u64;

            /// Fill `dest` with random data.
            ///
            /// RNGs must implement at least one method from this trait directly. In
            /// the case this method is not implemented directly, it can be implemented
            /// via [`impls::fill_bytes_via_next`] or
            /// via [`RngCore::try_fill_bytes`]; if this generator can
            /// fail the implementation must choose how best to handle errors here
            /// (e.g. panic with a descriptive message or log a warning and retry a few
            /// times).
            ///
            /// This method should guarantee that `dest` is entirely filled
            /// with new data, and may panic if this is impossible
            /// (e.g. reading past the end of a file that is being used as the
            /// source of randomness).
            fn fill_bytes(&mut self, dest: &mut [u8]);

            /// Fill `dest` entirely with random data.
            ///
            /// This is the only method which allows an RNG to report errors while
            /// generating random data thus making this the primary method implemented
            /// by external (true) RNGs (e.g. `OsRng`) which can fail. It may be used
            /// directly to generate keys and to seed (infallible) PRNGs.
            ///
            /// Other than error handling, this method is identical to [`RngCore::fill_bytes`];
            /// thus this may be implemented using `Ok(self.fill_bytes(dest))` or
            /// `fill_bytes` may be implemented with
            /// `self.try_fill_bytes(dest).unwrap()` or more specific error handling.
            fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error>;
        }
        /// Marker trait indicating that an [`RngCore`] or [`BlockRngCore`] implementation 
        /// is supposed to be cryptographically secure.
        pub trait CryptoRng {}
        /// An extension trait that is automatically implemented for any type
        /// implementing [`RngCore`] and [`CryptoRng`].
        pub trait CryptoRngCore: RngCore
        {
            /// Upcast to an [`RngCore`] trait object.
            fn as_rngcore(&mut self) -> &mut dyn RngCore;
        }

        impl<T: CryptoRng + RngCore> CryptoRngCore for T
        {
            fn as_rngcore(&mut self) -> &mut dyn RngCore {
                self
            }
        }
        /// A random number generator that can be explicitly seeded.
        pub trait SeedableRng: Sized
        {
            /// Seed type, which is restricted to types mutably-dereferenceable as `u8`
            /// arrays (we recommend `[u8; N]` for some `N`).
            ///
            /// It is recommended to seed PRNGs with a seed of at least circa 100 bits,
            /// which means an array of `[u8; 12]` or greater to avoid picking RNGs with
            /// partially overlapping periods.
            ///
            /// For cryptographic RNG's a seed of 256 bits is recommended, `[u8; 32]`.
            ///
            ///
            /// # Implementing `SeedableRng` for RNGs with large seeds
            ///
            /// Note that the required traits `core::default::Default` and
            /// `core::convert::AsMut<u8>` are not implemented for large arrays
            /// `[u8; N]` with `N` > 32. To be able to implement the traits required by
            /// `SeedableRng` for RNGs with such large seeds, the newtype pattern can be
            /// used:
            ///
            /// ```
            /// use rand_core::SeedableRng;
            ///
            /// const N: usize = 64;
            /// pub struct MyRngSeed(pub [u8; N]);
            /// pub struct MyRng(MyRngSeed);
            ///
            /// impl Default for MyRngSeed {
            ///     fn default() -> MyRngSeed {
            ///         MyRngSeed([0; N])
            ///     }
            /// }
            ///
            /// impl AsMut<[u8]> for MyRngSeed {
            ///     fn as_mut(&mut self) -> &mut [u8] {
            ///         &mut self.0
            ///     }
            /// }
            ///
            /// impl SeedableRng for MyRng {
            ///     type Seed = MyRngSeed;
            ///
            ///     fn from_seed(seed: MyRngSeed) -> MyRng {
            ///         MyRng(seed)
            ///     }
            /// }
            /// ```
            type Seed: Sized + Default + AsMut<[u8]>;

            /// Create a new PRNG using the given seed.
            ///
            /// PRNG implementations are allowed to assume that bits in the seed are
            /// well distributed. That means usually that the number of one and zero
            /// bits are roughly equal, and values like 0, 1 and (size - 1) are unlikely.
            /// Note that many non-cryptographic PRNGs will show poor quality output
            /// if this is not adhered to. If you wish to seed from simple numbers, use
            /// `seed_from_u64` instead.
            ///
            /// All PRNG implementations should be reproducible unless otherwise noted:
            /// given a fixed `seed`, the same sequence of output should be produced
            /// on all runs, library versions and architectures (e.g. check endianness).
            /// Any "value-breaking" changes to the generator should require bumping at
            /// least the minor version and documentation of the change.
            ///
            /// It is not required that this function yield the same state as a
            /// reference implementation of the PRNG given equivalent seed; if necessary
            /// another constructor replicating behaviour from a reference
            /// implementation can be added.
            ///
            /// PRNG implementations should make sure `from_seed` never panics. In the
            /// case that some special values (like an all zero seed) are not viable
            /// seeds it is preferable to map these to alternative constant value(s),
            /// for example `0xBAD5EEDu32` or `0x0DDB1A5E5BAD5EEDu64` ("odd biases? bad
            /// seed"). This is assuming only a small number of values must be rejected.
            fn from_seed(seed: Self::Seed) -> Self;

            /// Create a new PRNG using a `u64` seed.
            ///
            /// This is a convenience-wrapper around `from_seed` to allow construction
            /// of any `SeedableRng` from a simple `u64` value. It is designed such that
            /// low Hamming Weight numbers like 0 and 1 can be used and should still
            /// result in good, independent seeds to the PRNG which is returned.
            ///
            /// This **is not suitable for cryptography**, as should be clear given that
            /// the input size is only 64 bits.
            ///
            /// Implementations for PRNGs *may* provide their own implementations of
            /// this function, but the default implementation should be good enough for
            /// all purposes. *Changing* the implementation of this function should be
            /// considered a value-breaking change.
            fn seed_from_u64(mut state: u64) -> Self {
               
                fn pcg32(state: &mut u64) -> [u8; 4] {
                    const MUL: u64 = 6364136223846793005;
                    const INC: u64 = 11634580027462260723;

                   
                   
                    *state = state.wrapping_mul(MUL).wrapping_add(INC);
                    let state = *state;

                   
                    let xorshifted = (((state >> 18) ^ state) >> 27) as u32;
                    let rot = (state >> 59) as u32;
                    let x = xorshifted.rotate_right(rot);
                    x.to_le_bytes()
                }

                let mut seed = Self::Seed::default();
                let mut iter = seed.as_mut().chunks_exact_mut(4);
                for chunk in &mut iter {
                    chunk.copy_from_slice(&pcg32(&mut state));
                }
                let rem = iter.into_remainder();
                if !rem.is_empty() {
                    rem.copy_from_slice(&pcg32(&mut state)[..rem.len()]);
                }

                Self::from_seed(seed)
            }
            /// Create a new PRNG seeded from another `Rng`.
            ///
            /// This may be useful when needing to rapidly seed many PRNGs from a master
            /// PRNG, and to allow forking of PRNGs. It may be considered deterministic.
            ///
            /// The master PRNG should be at least as high quality as the child PRNGs.
            /// When seeding non-cryptographic child PRNGs, we recommend using a
            /// different algorithm for the master PRNG (ideally a CSPRNG) to avoid
            /// correlations between the child PRNGs. If this is not possible (e.g.
            /// forking using small non-crypto PRNGs) ensure that your PRNG has a good
            /// mixing function on the output or consider use of a hash function with
            /// `from_seed`.
            ///
            /// Note that seeding `XorShiftRng` from another `XorShiftRng` provides an
            /// extreme example of what can go wrong: the new PRNG will be a clone
            /// of the parent.
            ///
            /// PRNG implementations are allowed to assume that a good RNG is provided
            /// for seeding, and that it is cryptographically secure when appropriate.
            /// As of `rand` 0.7 / `rand_core` 0.5, implementations overriding this
            /// method should ensure the implementation satisfies reproducibility
            /// (in prior versions this was not required).
            ///
            /// [`rand`]: https://docs.rs/rand
            fn from_rng<R: RngCore>(mut rng: R) -> Result<Self, Error> {
                let mut seed = Self::Seed::default();
                rng.try_fill_bytes(seed.as_mut())?;
                Ok(Self::from_seed(seed))
            }
            /// Creates a new instance of the RNG seeded via [`getrandom`].
            ///
            /// This method is the recommended way to construct non-deterministic PRNGs
            /// since it is convenient and secure.
            ///
            /// In case the overhead of using [`getrandom`] to seed *many* PRNGs is an
            /// issue, one may prefer to seed from a local PRNG, e.g.
            /// `from_rng(thread_rng()).unwrap()`.
            ///
            /// # Panics
            ///
            /// If [`getrandom`] is unable to provide secure entropy this method will panic.
            ///
            /// [`getrandom`]: https://docs.rs/getrandom
            #[cfg(feature = "getrandom")]
            #[cfg_attr(doc_cfg, doc(cfg(feature = "getrandom")))]
            fn from_entropy() -> Self {
                let mut seed = Self::Seed::default();
                if let Err(err) = getrandom::getrandom(seed.as_mut()) {
                    panic!("from_entropy failed: {}", err);
                }
                Self::from_seed(seed)
            }
        }
        
        impl<'a, R: RngCore + ?Sized> RngCore for &'a mut R {
            #[inline(always)]
            fn next_u32(&mut self) -> u32 {
                (**self).next_u32()
            }

            #[inline(always)]
            fn next_u64(&mut self) -> u64 {
                (**self).next_u64()
            }

            #[inline(always)]
            fn fill_bytes(&mut self, dest: &mut [u8]) {
                (**self).fill_bytes(dest)
            }

            #[inline(always)]
            fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
                (**self).try_fill_bytes(dest)
            }
        }
        
        impl<R: RngCore + ?Sized> RngCore for Box<R>
        {
            #[inline(always)]
            fn next_u32(&mut self) -> u32 {
                (**self).next_u32()
            }

            #[inline(always)]
            fn next_u64(&mut self) -> u64 {
                (**self).next_u64()
            }

            #[inline(always)]
            fn fill_bytes(&mut self, dest: &mut [u8]) {
                (**self).fill_bytes(dest)
            }

            #[inline(always)]
            fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
                (**self).try_fill_bytes(dest)
            }
        }
        
        impl ::io::Read for dyn RngCore
        {
            fn read(&mut self, buf: &mut [u8]) -> Result<usize, ::io::Error> {
                self.try_fill_bytes(buf)?;
                Ok(buf.len())
            }
        }
        
        impl<'a, R: CryptoRng + ?Sized> CryptoRng for &'a mut R {}
        
        impl<R: CryptoRng + ?Sized> CryptoRng for Box<R> {}
    } pub use self::core::{CryptoRng, Error, RngCore, SeedableRng};

    pub mod distributions
    {
        /*!
        Generating random samples from probability distributions */
        use ::
        {
            rand::{ Rng },
            string::{ String },
            *,
        };
        /*
        */
        /// A generic random value distribution, implemented for many primitive types.
        #[derive(Clone, Copy, Debug)]
        pub struct Standard;
        /// Types (distributions) that can be used to create a random instance of `T`.
        pub trait Distribution<T> {
            /// Generate a random value of `T`, using `rng` as the source of randomness.
            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> T;

            /// Create an iterator that generates random values of `T`, using `rng` as
            /// the source of randomness.
            ///
            /// Note that this function takes `self` by value. This works since
            /// `Distribution<T>` is impl'd for `&D` where `D: Distribution<T>`,
            /// however borrowing is not automatic hence `distr.sample_iter(...)` may
            /// need to be replaced with `(&distr).sample_iter(...)` to borrow or
            /// `(&*distr).sample_iter(...)` to reborrow an existing reference.
            /// use rand::distributions::{Distribution, Alphanumeric, Uniform, Standard};
            ///
            /// let mut rng = thread_rng();
            ///
            ///
            /// let v: Vec<f32> = Standard.sample_iter(&mut rng).take(16).collect();
            ///
            ///
            /// let s: String = Alphanumeric
            ///     .sample_iter(&mut rng)
            ///     .take(7)
            ///     .map(char::from)
            ///     .collect();
            ///
            ///
            /// let die_range = Uniform::new_inclusive(1, 6);
            /// let mut roll_die = die_range.sample_iter(&mut rng);
            /// while roll_die.next().unwrap() != 6 {
            ///     println!("Not a 6; rolling again!");
            /// }
            /// ```
            fn sample_iter<R>(self, rng: R) -> DistIter<Self, R, T> where
                R: Rng,
                Self: Sized,
            {
                DistIter {
                    distr: self,
                    rng,
                    phantom: ::core::marker::PhantomData,
                }
            }
            /// Create a distribution of values of 'S' by mapping the output of `Self`
            /// through the closure `F`
            ///
            /// # Example
            ///
            /// ```
            /// use rand::thread_rng;
            /// use rand::distributions::{Distribution, Uniform};
            ///
            /// let mut rng = thread_rng();
            ///
            /// let die = Uniform::new_inclusive(1, 6);
            /// let even_number = die.map(|num| num % 2 == 0);
            /// while !even_number.sample(&mut rng) {
            ///     println!("Still odd; rolling again!");
            /// }
            /// ```
            fn map<F, S>(self, func: F) -> DistMap<Self, F, T, S> where
                F: Fn(T) -> S,
                Self: Sized,
            {
                DistMap {
                    distr: self,
                    func,
                    phantom: ::core::marker::PhantomData,
                }
            }
        }

        impl<'a, T, D: Distribution<T>> Distribution<T> for &'a D 
        {
            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> T {
                (*self).sample(rng)
            }
        }
        /// Iterator that generates random values of `T` with distribution `D`, using `R` as the source of randomness.
        #[derive(Debug)]
        pub struct DistIter<D, R, T> 
        {
            distr: D,
            rng: R,
            phantom: ::core::marker::PhantomData<T>,
        }

        impl<D, R, T> Iterator for DistIter<D, R, T> where
            D: Distribution<T>,
            R: Rng,
        {
            type Item = T;

            #[inline(always)]
            fn next(&mut self) -> Option<T> {
               
               
               
                Some(self.distr.sample(&mut self.rng))
            }

            fn size_hint(&self) -> (usize, Option<usize>) {
                (usize::max_value(), None)
            }
        }

        impl<D, R, T> iter::FusedIterator for DistIter<D, R, T> where
            D: Distribution<T>,
            R: Rng,
        {
        }
        /// Distribution of values of type `S` derived from `D` by mapping its output of type `T` through the closure `F`.
        #[derive(Debug)]
        pub struct DistMap<D, F, T, S>
        {
            distr: D,
            func: F,
            phantom: ::core::marker::PhantomData<fn(T) -> S>,
        }

        impl<D, F, T, S> Distribution<S> for DistMap<D, F, T, S> where
            D: Distribution<T>,
            F: Fn(T) -> S,
        {
            fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> S {
                (self.func)(self.distr.sample(rng))
            }
        }
        /// `String` sampler.
        pub trait DistString 
        {
            /// Append `len` random chars to `string`
            fn append_string<R: Rng + ?Sized>(&self, rng: &mut R, string: &mut String, len: usize);

            /// Generate a `String` of `len` random chars
            #[inline]
            fn sample_string<R: Rng + ?Sized>(&self, rng: &mut R, len: usize) -> String {
                let mut s = String::new();
                self.append_string(rng, &mut s, len);
                s
            }
        }
    } use self::distributions::{Distribution, Standard};

    pub mod rng
    {
        /*!
        [`Rng`] trait */
        use ::
        {
            num::{ Wrapping },
            rand::
            {
                core::{ Error, RngCore },
                distributions::{ self, Distribution, Standard },
            },
            *,
        };
        /*
        use crate::distributions::uniform::{SampleRange, SampleUniform};
        */
        /// Trait on [`RngCore`] for high-level generic methods for sampling values and other convenience methods.
        pub trait Rng: RngCore 
        {
            /// Return a random value supporting the [`Standard`] distribution.
            ///
            /// let mut rng = thread_rng();
            /// let x: u32 = rng.gen();
            /// println!("{}", x);
            /// println!("{:?}", rng.gen::<(f64, bool)>());
            /// ```
            ///
            /// # Arrays and tuples
            ///
            /// The `rng.gen()` method is able to generate arrays (up to 32 elements)
            /// and tuples (up to 12 elements), so long as all element types can be
            /// generated.
            /// When using `rustc` ≥ 1.51, enable the `min_const_gen` feature to support
            /// arrays larger than 32 elements.
            ///
            /// For arrays of integers, especially for those with small element types
            /// (< 64 bit), it will likely be faster to instead use [`Rng::fill`].
            ///
            /// ```
            /// use rand::{thread_rng, Rng};
            ///
            /// let mut rng = thread_rng();
            /// let tuple: (u8, i32, char) = rng.gen();
            ///
            /// let arr1: [f32; 32] = rng.gen();       
            /// let mut arr2 = [0u8; 128];
            /// rng.fill(&mut arr2);                   
            /// ```
            ///
            /// [`Standard`]: distributions::Standard
            #[inline]
            fn gen<T>(&mut self) -> T
            where Standard: Distribution<T> {
                Standard.sample(self)
            }
            /// Generate a random value in the given range.
            ///
            /// This function is optimised for the case that only a single sample is
            /// made from the given range. See also the [`Uniform`] distribution
            /// type which may be faster if sampling from the same range repeatedly.
            ///
            /// Only `gen_range(low..high)` and `gen_range(low..=high)` are supported.
            ///
            /// # Panics
            ///
            /// Panics if the range is empty.
            ///
            /// let mut rng = thread_rng();
            ///
            ///
            /// let n: u32 = rng.gen_range(0..10);
            /// println!("{}", n);
            /// let m: f64 = rng.gen_range(-40.0..1.3e5);
            /// println!("{}", m);
            ///
            ///
            /// let n: u32 = rng.gen_range(0..=10);
            /// println!("{}", n);
            /// ```
            ///
            /// [`Uniform`]: distributions::uniform::Uniform
            fn gen_range<T, R>(&mut self, range: R) -> T
            where
                T: SampleUniform,
                R: SampleRange<T>
            {
                assert!(!range.is_empty(), "cannot sample empty range");
                range.sample_single(self)
            }
            /// Sample a new value, using the given distribution.
            /// use rand::distributions::Uniform;
            ///
            /// let mut rng = thread_rng();
            /// let x = rng.sample(Uniform::new(10u32, 15));
            ///
            ///
            /// let y = rng.sample::<u16, _>(Uniform::new(10, 15));
            /// ```
            fn sample<T, D: Distribution<T>>(&mut self, distr: D) -> T {
                distr.sample(self)
            }
            /// Create an iterator that generates values using the given distribution.
            ///
            /// Note that this function takes its arguments by value. This works since
            /// `(&mut R): Rng where R: Rng` and
            /// `(&D): Distribution where D: Distribution`,
            /// however borrowing is not automatic hence `rng.sample_iter(...)` may
            /// need to be replaced with `(&mut rng).sample_iter(...)`.
            /// use rand::distributions::{Alphanumeric, Uniform, Standard};
            ///
            /// let mut rng = thread_rng();
            ///
            ///
            /// let v: Vec<f32> = (&mut rng).sample_iter(Standard).take(16).collect();
            ///
            ///
            /// let s: String = (&mut rng).sample_iter(Alphanumeric)
            ///     .take(7)
            ///     .map(char::from)
            ///     .collect();
            ///
            ///
            /// println!("{:?}", (&mut rng).sample_iter(Standard).take(5)
            ///                              .collect::<Vec<(f64, bool)>>());
            ///
            ///
            /// let die_range = Uniform::new_inclusive(1, 6);
            /// let mut roll_die = (&mut rng).sample_iter(die_range);
            /// while roll_die.next().unwrap() != 6 {
            ///     println!("Not a 6; rolling again!");
            /// }
            /// ```
            fn sample_iter<T, D>(self, distr: D) -> distributions::DistIter<D, Self, T> where
                D: Distribution<T>,
                Self: Sized,
            {
                distr.sample_iter(self)
            }
            /// Fill any type implementing [`Fill`] with random data
            ///
            /// The distribution is expected to be uniform with portable results, but
            /// this cannot be guaranteed for third-party implementations.
            ///
            /// This is identical to [`try_fill`] except that it panics on error.
            ///
            /// let mut arr = [0i8; 20];
            /// thread_rng().fill(&mut arr[..]);
            /// ```
            ///
            /// [`fill_bytes`]: RngCore::fill_bytes
            /// [`try_fill`]: Rng::try_fill
            fn fill<T: Fill + ?Sized>(&mut self, dest: &mut T) {
                dest.try_fill(self).unwrap_or_else(|_| panic!("Rng::fill failed"))
            }
            /// Fill any type implementing [`Fill`] with random data
            ///
            /// The distribution is expected to be uniform with portable results, but
            /// this cannot be guaranteed for third-party implementations.
            ///
            /// This is identical to [`fill`] except that it forwards errors.
            /// use rand::{thread_rng, Rng};
            ///
            /// # fn try_inner() -> Result<(), Error> {
            /// let mut arr = [0u64; 4];
            /// thread_rng().try_fill(&mut arr[..])?;
            /// # Ok(())
            /// # }
            ///
            /// # try_inner().unwrap()
            /// ```
            ///
            /// [`try_fill_bytes`]: RngCore::try_fill_bytes
            /// [`fill`]: Rng::fill
            fn try_fill<T: Fill + ?Sized>(&mut self, dest: &mut T) -> Result<(), Error> {
                dest.try_fill(self)
            }
            /// Return a bool with a probability `p` of being true.
            ///
            /// See also the [`Bernoulli`] distribution, which may be faster if
            /// sampling from the same probability repeatedly.
            ///
            /// let mut rng = thread_rng();
            /// println!("{}", rng.gen_bool(1.0 / 3.0));
            /// ```
            ///
            /// # Panics
            ///
            /// If `p < 0` or `p > 1`.
            ///
            /// [`Bernoulli`]: distributions::Bernoulli
            #[inline]
            fn gen_bool(&mut self, p: f64) -> bool {
                let d = distributions::Bernoulli::new(p).unwrap();
                self.sample(d)
            }
            /// Return a bool with a probability of `numerator/denominator` of being
            /// true. I.e. `gen_ratio(2, 3)` has chance of 2 in 3, or about 67%, of
            /// returning true. If `numerator == denominator`, then the returned value
            /// is guaranteed to be `true`. If `numerator == 0`, then the returned
            /// value is guaranteed to be `false`.
            ///
            /// See also the [`Bernoulli`] distribution, which may be faster if
            /// sampling from the same `numerator` and `denominator` repeatedly.
            ///
            /// # Panics
            ///
            /// If `denominator == 0` or `numerator > denominator`.
            ///
            /// let mut rng = thread_rng();
            /// println!("{}", rng.gen_ratio(2, 3));
            /// ```
            ///
            /// [`Bernoulli`]: distributions::Bernoulli
            #[inline]
            fn gen_ratio(&mut self, numerator: u32, denominator: u32) -> bool {
                let d = distributions::Bernoulli::from_ratio(numerator, denominator).unwrap();
                self.sample(d)
            }
        }

        impl<R: RngCore + ?Sized> Rng for R {}
        /// Types which may be filled with random data.
        pub trait Fill 
        {
            /// Fill self with random data
            fn try_fill<R: Rng + ?Sized>(&mut self, rng: &mut R) -> Result<(), Error>;
        }

        macro_rules! impl_fill_each 
        {
            () => {};
            ($t:ty) => {
                impl Fill for [$t] {
                    fn try_fill<R: Rng + ?Sized>(&mut self, rng: &mut R) -> Result<(), Error> {
                        for elt in self.iter_mut() {
                            *elt = rng.gen();
                        }
                        Ok(())
                    }
                }
            };
            ($t:ty, $($tt:ty,)*) => {
                impl_fill_each!($t);
                impl_fill_each!($($tt,)*);
            };
        }

        impl_fill_each!(bool, char, f32, f64,);

        impl Fill for [u8] 
        {
            fn try_fill<R: Rng + ?Sized>(&mut self, rng: &mut R) -> Result<(), Error> {
                rng.try_fill_bytes(self)
            }
        }

        macro_rules! impl_fill 
        {
            () => {};
            ($t:ty) => {
                impl Fill for [$t] {
                    #[inline(never)]
                    fn try_fill<R: Rng + ?Sized>(&mut self, rng: &mut R) -> Result<(), Error> {
                        if self.len() > 0 {
                            rng.try_fill_bytes(unsafe {
                                slice::from_raw_parts_mut(self.as_mut_ptr()
                                    as *mut u8,
                                    self.len() * mem::size_of::<$t>()
                                )
                            })?;
                            for x in self {
                                *x = x.to_le();
                            }
                        }
                        Ok(())
                    }
                }

                impl Fill for [Wrapping<$t>] {
                    #[inline(never)]
                    fn try_fill<R: Rng + ?Sized>(&mut self, rng: &mut R) -> Result<(), Error> {
                        if self.len() > 0 {
                            rng.try_fill_bytes(unsafe {
                                slice::from_raw_parts_mut(self.as_mut_ptr()
                                    as *mut u8,
                                    self.len() * mem::size_of::<$t>()
                                )
                            })?;
                            for x in self {
                            *x = Wrapping(x.0.to_le());
                            }
                        }
                        Ok(())
                    }
                }
            };
            ($t:ty, $($tt:ty,)*) => {
                impl_fill!($t);
               
               
                impl_fill!($($tt,)*);
            }
        }

        impl_fill!(u16, u32, u64, usize, u128,);
        impl_fill!(i8, i16, i32, i64, isize, i128,);
    } pub use self::rng::{Fill, Rng};

    pub mod rngs
    {
        /*!
        Random number generators and adapters */
        use ::
        {
            *,
        };

        pub use ::rand::core::OsRng;
        /*
        pub use rand_core::OsRng;
        */
        pub mod adapter
        {
            /*!
            Wrappers / adapters forming RNGs*/
            use ::
            {
                *,
            };
            /*
            */
            pub mod read
            {
                /*!
                A wrapper around any Read to treat it as an RNG. */
                use ::
                {
                    io::{ Read },
                    rand::
                    {
                        core::{ impls, Error, RngCore },
                    },
                    *,
                };
                /*
                */
                /// An RNG that reads random bytes straight from any type supporting [`::io::Read`], for example files.
                #[derive(Debug)]
                #[deprecated(since="0.8.4", note="removal due to lack of usage")]
                pub struct ReadRng<R> 
                {
                    reader: R,
                }

                impl<R: Read> ReadRng<R> 
                {
                    /// Create a new `ReadRng` from a `Read`.
                    pub fn new(r: R) -> ReadRng<R> {
                        ReadRng { reader: r }
                    }
                }

                impl<R: Read> RngCore for ReadRng<R> 
                {
                    fn next_u32(&mut self) -> u32 {
                        impls::next_u32_via_fill(self)
                    }

                    fn next_u64(&mut self) -> u64 {
                        impls::next_u64_via_fill(self)
                    }

                    fn fill_bytes(&mut self, dest: &mut [u8]) {
                        self.try_fill_bytes(dest).unwrap_or_else(|err| {
                            panic!(
                                "reading random bytes from Read implementation failed; error: {}",
                                err
                            )
                        });
                    }

                    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
                        if dest.is_empty() {
                            return Ok(());
                        }
                       
                        self.reader
                            .read_exact(dest)
                            .map_err(|e| Error::new(ReadError(e)))
                    }
                }

                /// `ReadRng` error type
                #[derive(Debug)]
                #[deprecated(since="0.8.4")]
                pub struct ReadError(::io::Error);

                impl fmt::Display for ReadError 
                {
                    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result
                    {
                        write!(f, "ReadError: {}", self.0)
                    }
                }

                impl ::error::Error for ReadError
                {
                    fn source(&self) -> Option<&(dyn ::error::Error + 'static)> 
                    {
                        Some(&self.0)
                    }
                }
            } pub use self::read::{ReadError, ReadRng};
            
            pub mod reseeding
            {
                /*!
                A wrapper around another PRNG that reseeds it after it generates a certain number of random bytes.*/
                use ::
                {
                    mem::{ size_of },
                    rand::
                    {
                        core::
                        {
                            block::{BlockRng, BlockRngCore},
                            CryptoRng, Error, RngCore, SeedableRng,
                        },
                    },
                    *,
                };
                /*
                */
                /// A wrapper around any PRNG that implements [`BlockRngCore`], that adds the ability to reseed it.
                #[derive(Debug)]
                pub struct ReseedingRng<R, Rsdr>(BlockRng<ReseedingCore<R, Rsdr>>) where
                R: BlockRngCore + SeedableRng,
                Rsdr: RngCore;

                impl<R, Rsdr> ReseedingRng<R, Rsdr> where
                R: BlockRngCore + SeedableRng,
                Rsdr: RngCore,
                {
                    /// Create a new `ReseedingRng` from an existing PRNG, combined with a RNG
                    /// to use as reseeder.
                    ///
                    /// `threshold` sets the number of generated bytes after which to reseed the
                    /// PRNG. Set it to zero to never reseed based on the number of generated
                    /// values.
                    pub fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
                        ReseedingRng(BlockRng::new(ReseedingCore::new(rng, threshold, reseeder)))
                    }

                    /// Reseed the internal PRNG.
                    pub fn reseed(&mut self) -> Result<(), Error> {
                        self.0.core.reseed()
                    }
                }

               
               
                impl<R, Rsdr: RngCore> RngCore for ReseedingRng<R, Rsdr> where
                R: BlockRngCore<Item = u32> + SeedableRng,
                <R as BlockRngCore>::Results: AsRef<[u32]> + AsMut<[u32]>,
                {
                    #[inline(always)]
                    fn next_u32(&mut self) -> u32 {
                        self.0.next_u32()
                    }

                    #[inline(always)]
                    fn next_u64(&mut self) -> u64 {
                        self.0.next_u64()
                    }

                    fn fill_bytes(&mut self, dest: &mut [u8]) {
                        self.0.fill_bytes(dest)
                    }

                    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
                        self.0.try_fill_bytes(dest)
                    }
                }

                impl<R, Rsdr> Clone for ReseedingRng<R, Rsdr> where
                R: BlockRngCore + SeedableRng + Clone,
                Rsdr: RngCore + Clone,
                {
                    fn clone(&self) -> ReseedingRng<R, Rsdr> {
                       
                       
                        ReseedingRng(BlockRng::new(self.0.core.clone()))
                    }
                }

                impl<R, Rsdr> CryptoRng for ReseedingRng<R, Rsdr> where
                R: BlockRngCore + SeedableRng + CryptoRng,
                Rsdr: RngCore + CryptoRng,
                {
                }

                #[derive(Debug)]
                struct ReseedingCore<R, Rsdr> 
                {
                    inner: R,
                    reseeder: Rsdr,
                    threshold: i64,
                    bytes_until_reseed: i64,
                    fork_counter: usize,
                }

                impl<R, Rsdr> BlockRngCore for ReseedingCore<R, Rsdr> where
                    R: BlockRngCore + SeedableRng,
                    Rsdr: RngCore,
                {
                    type Item = <R as BlockRngCore>::Item;
                    type Results = <R as BlockRngCore>::Results;

                    fn generate(&mut self, results: &mut Self::Results) {
                        let global_fork_counter = fork::get_fork_counter();
                        if self.bytes_until_reseed <= 0 || self.is_forked(global_fork_counter) {
                           
                           
                           
                            return self.reseed_and_generate(results, global_fork_counter);
                        }
                        let num_bytes = results.as_ref().len() * size_of::<Self::Item>();
                        self.bytes_until_reseed -= num_bytes as i64;
                        self.inner.generate(results);
                    }
                }

                impl<R, Rsdr> ReseedingCore<R, Rsdr> where
                    R: BlockRngCore + SeedableRng,
                    Rsdr: RngCore,
                {
                    /// Create a new `ReseedingCore`.
                    fn new(rng: R, threshold: u64, reseeder: Rsdr) -> Self {
                        use ::core::i64::MAX;
                        fork::register_fork_handler();

                       
                       
                       
                       
                        let threshold = if threshold == 0 {
                            MAX
                        } else if threshold <= MAX as u64 {
                            threshold as i64
                        } else {
                            MAX
                        };

                        ReseedingCore {
                            inner: rng,
                            reseeder,
                            threshold: threshold as i64,
                            bytes_until_reseed: threshold as i64,
                            fork_counter: 0,
                        }
                    }

                    /// Reseed the internal PRNG.
                    fn reseed(&mut self) -> Result<(), Error> {
                        R::from_rng(&mut self.reseeder).map(|result| {
                            self.bytes_until_reseed = self.threshold;
                            self.inner = result
                        })
                    }

                    fn is_forked(&self, global_fork_counter: usize) -> bool {
                       
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        (self.fork_counter.wrapping_sub(global_fork_counter) as isize) < 0
                    }

                    #[inline(never)]
                    fn reseed_and_generate
                    (
                        &mut self, results: &mut <Self as BlockRngCore>::Results, global_fork_counter: usize,
                    )
                    {
                        let num_bytes = results.as_ref().len() * size_of::<<R as BlockRngCore>::Item>();

                        if let Err(e) = self.reseed()
                        {
                            let _ = e;
                        }

                        self.fork_counter = global_fork_counter;

                        self.bytes_until_reseed = self.threshold - num_bytes as i64;
                        self.inner.generate(results);
                    }
                }

                impl<R, Rsdr> Clone for ReseedingCore<R, Rsdr> where
                    R: BlockRngCore + SeedableRng + Clone,
                    Rsdr: RngCore + Clone,
                {
                    fn clone(&self) -> ReseedingCore<R, Rsdr> {
                        ReseedingCore {
                            inner: self.inner.clone(),
                            reseeder: self.reseeder.clone(),
                            threshold: self.threshold,
                            bytes_until_reseed: 0,
                            fork_counter: self.fork_counter,
                        }
                    }
                }

                impl<R, Rsdr> CryptoRng for ReseedingCore<R, Rsdr> where
                    R: BlockRngCore + SeedableRng + CryptoRng,
                    Rsdr: RngCore + CryptoRng,
                {
                }
                
                mod fork
                {
                    use ::sync::atomic::{AtomicUsize, Ordering};
                    use ::sync::Once;
                    
                    static RESEEDING_RNG_FORK_COUNTER: AtomicUsize = AtomicUsize::new(0);

                    pub fn get_fork_counter() -> usize 
                    {
                        RESEEDING_RNG_FORK_COUNTER.load(Ordering::Relaxed)
                    }

                    extern "C" fn fork_handler() 
                    {
                       
                       
                        RESEEDING_RNG_FORK_COUNTER.fetch_add(1, Ordering::Relaxed);
                    }

                    pub fn register_fork_handler() 
                    {
                        static REGISTER: Once = Once::new();
                        REGISTER.call_once(|| {
                           
                            let ret = unsafe { libc::pthread_atfork(
                                Some(fork_handler),
                                Some(fork_handler),
                                Some(fork_handler),
                            ) };
                            if ret != 0 {
                                panic!("libc::pthread_atfork failed with code {}", ret);
                            }
                        });
                    }
                }
            } pub use self::reseeding::ReseedingRng;
        }
        
        pub mod std
        {
            /*!
            The standard RNG */
            use ::
            {
                rand::{ CryptoRng, Error, RngCore, SeedableRng },
                *,
            };
            /*
            pub use rand_chacha::ChaCha12Core as Core;
            use rand_chacha::ChaCha12Rng as Rng;
            */
            /// The standard RNG. The PRNG algorithm in `StdRng` is chosen to be efficient
            /// on the current platform, to be statistically strong and unpredictable
            /// (meaning a cryptographically secure PRNG).
            #[derive(Clone, Debug, PartialEq, Eq)]
            pub struct StdRng(Rng);

            impl RngCore for StdRng
            {
                #[inline(always)]
                fn next_u32(&mut self) -> u32 {
                    self.0.next_u32()
                }

                #[inline(always)]
                fn next_u64(&mut self) -> u64 {
                    self.0.next_u64()
                }

                #[inline(always)]
                fn fill_bytes(&mut self, dest: &mut [u8]) {
                    self.0.fill_bytes(dest);
                }

                #[inline(always)]
                fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
                    self.0.try_fill_bytes(dest)
                }
            }

            impl SeedableRng for StdRng
            {
                type Seed = <Rng as SeedableRng>::Seed;

                #[inline(always)]
                fn from_seed(seed: Self::Seed) -> Self {
                    StdRng(Rng::from_seed(seed))
                }

                #[inline(always)]
                fn from_rng<R: RngCore>(rng: R) -> Result<Self, Error> {
                    Rng::from_rng(rng).map(StdRng)
                }
            }

            impl CryptoRng for StdRng {}
        } pub use self::std::StdRng;
        
        pub mod thread
        {
            /*!
            Thread-local random number generator */
            use ::
            {
                cell::{ UnsafeCell },
                rand::
                {
                    rngs::adapter::ReseedingRng,
                    rngs::OsRng,
                    CryptoRng, Error, RngCore, SeedableRng,
                },
                rc::{ Rc },
                *,
            };

            use super::Core;
            /*
            */
            const THREAD_RNG_RESEED_THRESHOLD: u64 = 1024 * 64;
            /// A reference to the thread-local generator.
            #[derive(Clone, Debug)]
            pub struct ThreadRng
            {
               
                rng: Rc<UnsafeCell<ReseedingRng<Core, OsRng>>>,
            }

            thread_local!
            (
               
               
                static THREAD_RNG_KEY: Rc<UnsafeCell<ReseedingRng<Core, OsRng>>> = {
                    let r = Core::from_rng(OsRng).unwrap_or_else(|err|
                            panic!("could not initialize thread_rng: {}", err));
                    let rng = ReseedingRng::new(r,
                                                THREAD_RNG_RESEED_THRESHOLD,
                                                OsRng);
                    Rc::new(UnsafeCell::new(rng))
                }
            );

            /// Retrieve the lazily-initialized thread-local random number generator, seeded by the system.
            pub fn thread_rng() -> ThreadRng
            {
                let rng = THREAD_RNG_KEY.with(|t| t.clone());
                ThreadRng { rng }
            }

            impl Default for ThreadRng
            {
                fn default() -> ThreadRng {
                    crate::prelude::thread_rng()
                }
            }

            impl RngCore for ThreadRng
            {
                #[inline(always)]
                fn next_u32(&mut self) -> u32 {
                   
                   
                    let rng = unsafe { &mut *self.rng.get() };
                    rng.next_u32()
                }

                #[inline(always)]
                fn next_u64(&mut self) -> u64 {
                   
                   
                    let rng = unsafe { &mut *self.rng.get() };
                    rng.next_u64()
                }

                fn fill_bytes(&mut self, dest: &mut [u8]) {
                   
                   
                    let rng = unsafe { &mut *self.rng.get() };
                    rng.fill_bytes(dest)
                }

                fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {
                   
                   
                    let rng = unsafe { &mut *self.rng.get() };
                    rng.try_fill_bytes(dest)
                }
            }

            impl CryptoRng for ThreadRng {}
        } pub use self::thread::ThreadRng;
    } pub use self::rngs::thread::thread_rng;

    pub mod seq
    {
        /*!
        Sequence-related functionality */
        use ::
        {
            ops::{ Index },
            rand::{ distributions::WeightedError, Rng },
            vec::{ Vec },
            *,
        };
        /*
        use crate::distributions::uniform::{SampleBorrow, SampleUniform};
        */
        pub mod index
        {
            /*!
            */
            use ::
            {
                collections::{ BTreeSet, HashSet },
                rand::{ distributions::{ uniform::SampleUniform, Distribution, Uniform, WeightedError }, Rng },
                vec::{ self, Vec },
                *,
            };
            /*
            */
            /// A vector of indices.
            #[derive(Clone, Debug)]
            pub enum IndexVec
            {
                #[doc(hidden)]
                U32(Vec<u32>),
                #[doc(hidden)]
                USize(Vec<usize>),
            }

            impl IndexVec
            {
                /// Returns the number of indices
                #[inline]
                pub fn len(&self) -> usize {
                    match *self {
                        IndexVec::U32(ref v) => v.len(),
                        IndexVec::USize(ref v) => v.len(),
                    }
                }

                /// Returns `true` if the length is 0.
                #[inline]
                pub fn is_empty(&self) -> bool {
                    match *self {
                        IndexVec::U32(ref v) => v.is_empty(),
                        IndexVec::USize(ref v) => v.is_empty(),
                    }
                }

                /// Return the value at the given `index`.
                ///
                /// (Note: we cannot implement [`::ops::Index`] because of lifetime
                /// restrictions.)
                #[inline]
                pub fn index(&self, index: usize) -> usize {
                    match *self {
                        IndexVec::U32(ref v) => v[index] as usize,
                        IndexVec::USize(ref v) => v[index],
                    }
                }

                /// Return result as a `Vec<usize>`. Conversion may or may not be trivial.
                #[inline]
                pub fn into_vec(self) -> Vec<usize> {
                    match self {
                        IndexVec::U32(v) => v.into_iter().map(|i| i as usize).collect(),
                        IndexVec::USize(v) => v,
                    }
                }

                /// Iterate over the indices as a sequence of `usize` values
                #[inline]
                pub fn iter(&self) -> IndexVecIter<'_> {
                    match *self {
                        IndexVec::U32(ref v) => IndexVecIter::U32(v.iter()),
                        IndexVec::USize(ref v) => IndexVecIter::USize(v.iter()),
                    }
                }
            }

            impl IntoIterator for IndexVec
            {
                type Item = usize;
                type IntoIter = IndexVecIntoIter;

                /// Convert into an iterator over the indices as a sequence of `usize` values
                #[inline]
                fn into_iter(self) -> IndexVecIntoIter {
                    match self {
                        IndexVec::U32(v) => IndexVecIntoIter::U32(v.into_iter()),
                        IndexVec::USize(v) => IndexVecIntoIter::USize(v.into_iter()),
                    }
                }
            }

            impl PartialEq for IndexVec
            {
                fn eq(&self, other: &IndexVec) -> bool {
                    use self::IndexVec::*;
                    match (self, other) {
                        (&U32(ref v1), &U32(ref v2)) => v1 == v2,
                        (&USize(ref v1), &USize(ref v2)) => v1 == v2,
                        (&U32(ref v1), &USize(ref v2)) => {
                            (v1.len() == v2.len()) && (v1.iter().zip(v2.iter()).all(|(x, y)| *x as usize == *y))
                        }
                        (&USize(ref v1), &U32(ref v2)) => {
                            (v1.len() == v2.len()) && (v1.iter().zip(v2.iter()).all(|(x, y)| *x == *y as usize))
                        }
                    }
                }
            }

            impl From<Vec<u32>> for IndexVec
            {
                #[inline]
                fn from(v: Vec<u32>) -> Self {
                    IndexVec::U32(v)
                }
            }

            impl From<Vec<usize>> for IndexVec
            {
                #[inline]
                fn from(v: Vec<usize>) -> Self {
                    IndexVec::USize(v)
                }
            }
            /// Return type of `IndexVec::iter`.
            #[derive(Debug)]
            pub enum IndexVecIter<'a>
            {
                #[doc(hidden)]
                U32(slice::Iter<'a, u32>),
                #[doc(hidden)]
                USize(slice::Iter<'a, usize>),
            }

            impl<'a> Iterator for IndexVecIter<'a>
            {
                type Item = usize;

                #[inline]
                fn next(&mut self) -> Option<usize> {
                    use self::IndexVecIter::*;
                    match *self {
                        U32(ref mut iter) => iter.next().map(|i| *i as usize),
                        USize(ref mut iter) => iter.next().cloned(),
                    }
                }

                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    match *self {
                        IndexVecIter::U32(ref v) => v.size_hint(),
                        IndexVecIter::USize(ref v) => v.size_hint(),
                    }
                }
            }

            impl<'a> ExactSizeIterator for IndexVecIter<'a> {}
            /// Return type of `IndexVec::into_iter`.
            #[derive(Clone, Debug)]
            pub enum IndexVecIntoIter
            {
                #[doc(hidden)]
                U32(vec::IntoIter<u32>),
                #[doc(hidden)]
                USize(vec::IntoIter<usize>),
            }

            impl Iterator for IndexVecIntoIter
            {
                type Item = usize;

                #[inline]
                fn next(&mut self) -> Option<Self::Item> {
                    use self::IndexVecIntoIter::*;
                    match *self {
                        U32(ref mut v) => v.next().map(|i| i as usize),
                        USize(ref mut v) => v.next(),
                    }
                }

                #[inline]
                fn size_hint(&self) -> (usize, Option<usize>) {
                    use self::IndexVecIntoIter::*;
                    match *self {
                        U32(ref v) => v.size_hint(),
                        USize(ref v) => v.size_hint(),
                    }
                }
            }

            impl ExactSizeIterator for IndexVecIntoIter {}
            /// Randomly sample exactly `amount` distinct indices from `0..length`, and
            /// return them in random order (fully shuffled).
            pub fn sample<R>(rng: &mut R, length: usize, amount: usize) -> IndexVec where
            R: Rng + ?Sized
            {
                if amount > length {
                    panic!("`amount` of samples must be less than or equal to `length`");
                }
                if length > (::core::u32::MAX as usize) {
                   
                   
                    return sample_rejection(rng, length, amount);
                }
                let amount = amount as u32;
                let length = length as u32;

               
               
               

                if amount < 163 {
                    const C: [[f32; 2]; 2] = [[1.6, 8.0 / 45.0], [10.0, 70.0 / 9.0]];
                    let j = if length < 500_000 { 0 } else { 1 };
                    let amount_fp = amount as f32;
                    let m4 = C[0][j] * amount_fp;
                   
                    if amount > 11 && (length as f32) < (C[1][j] + m4) * amount_fp {
                        sample_inplace(rng, length, amount)
                    } else {
                        sample_floyd(rng, length, amount)
                    }
                } else {
                    const C: [f32; 2] = [270.0, 330.0 / 9.0];
                    let j = if length < 500_000 { 0 } else { 1 };
                    if (length as f32) < C[j] * (amount as f32) {
                        sample_inplace(rng, length, amount)
                    } else {
                        sample_rejection(rng, length, amount)
                    }
                }
            }
            /// Randomly sample exactly `amount` distinct indices from `0..length`, and
            /// return them in an arbitrary order (there is no guarantee of shuffling or
            /// ordering).
            pub fn sample_weighted<R, F, X>
            (
                rng: &mut R, length: usize, weight: F, amount: usize,
            ) -> Result<IndexVec, WeightedError> where
            R: Rng + ?Sized,
            F: Fn(usize) -> X,
            X: Into<f64>,
            {
                if length > (core::u32::MAX as usize) {
                    sample_efraimidis_spirakis(rng, length, weight, amount)
                } else {
                    assert!(amount <= core::u32::MAX as usize);
                    let amount = amount as u32;
                    let length = length as u32;
                    sample_efraimidis_spirakis(rng, length, weight, amount)
                }
            }
            /// Randomly sample exactly `amount` distinct indices from `0..length`, and 
            /// return them in an arbitrary order.
            fn sample_efraimidis_spirakis<R, F, X, N>
            (
                rng: &mut R, length: N, weight: F, amount: N,
            ) -> Result<IndexVec, WeightedError> where
            R: Rng + ?Sized,
            F: Fn(usize) -> X,
            X: Into<f64>,
            N: UInt,
            IndexVec: From<Vec<N>>,
            {
                if amount == N::zero() {
                    return Ok(IndexVec::U32(Vec::new()));
                }

                if amount > length {
                    panic!("`amount` of samples must be less than or equal to `length`");
                }

                struct Element<N> {
                    index: N,
                    key: f64,
                }
                impl<N> PartialOrd for Element<N> {
                    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
                        self.key.partial_cmp(&other.key)
                    }
                }
                impl<N> Ord for Element<N> {
                    fn cmp(&self, other: &Self) -> core::cmp::Ordering {
                       
                       
                        self.partial_cmp(other).unwrap()
                    }
                }
                impl<N> PartialEq for Element<N> {
                    fn eq(&self, other: &Self) -> bool {
                        self.key == other.key
                    }
                }
                impl<N> Eq for Element<N> {}

                #[cfg(feature = "nightly")]
                {
                    let mut candidates = Vec::with_capacity(length.as_usize());
                    let mut index = N::zero();
                    while index < length {
                        let weight = weight(index.as_usize()).into();
                        if !(weight >= 0.) {
                            return Err(WeightedError::InvalidWeight);
                        }

                        let key = rng.gen::<f64>().powf(1.0 / weight);
                        candidates.push(Element { index, key });

                        index += N::one();
                    }

                   
                   
                   
                   
                    let (_, mid, greater)
                        = candidates.select_nth_unstable(length.as_usize() - amount.as_usize());

                    let mut result: Vec<N> = Vec::with_capacity(amount.as_usize());
                    result.push(mid.index);
                    for element in greater {
                        result.push(element.index);
                    }
                    Ok(IndexVec::from(result))
                }

                #[cfg(not(feature = "nightly"))]
                {
                    use alloc::collections::BinaryHeap;

                   
                   
                    let mut candidates = BinaryHeap::with_capacity(length.as_usize());
                    let mut index = N::zero();
                    while index < length {
                        let weight = weight(index.as_usize()).into();
                        if !(weight >= 0.) {
                            return Err(WeightedError::InvalidWeight);
                        }

                        let key = rng.gen::<f64>().powf(1.0 / weight);
                        candidates.push(Element { index, key });

                        index += N::one();
                    }

                    let mut result: Vec<N> = Vec::with_capacity(amount.as_usize());
                    while result.len() < amount.as_usize() {
                        result.push(candidates.pop().unwrap().index);
                    }
                    Ok(IndexVec::from(result))
                }
            }
            /// Randomly sample exactly `amount` indices from `0..n`, using Floyd's combination algorithm.
            fn sample_floyd<R>(rng: &mut R, length: u32, amount: u32) -> IndexVec where
            R: Rng + ?Sized
            {
                let floyd_shuffle = amount < 50;

                debug_assert!(amount <= length);
                let mut indices = Vec::with_capacity(amount as usize);
                for j in length - amount..length {
                    let t = rng.gen_range(0..=j);
                    if floyd_shuffle {
                        if let Some(pos) = indices.iter().position(|&x| x == t) {
                            indices.insert(pos, j);
                            continue;
                        }
                    } else if indices.contains(&t) {
                        indices.push(j);
                        continue;
                    }
                    indices.push(t);
                }
                if !floyd_shuffle {
                   
                    for i in (1..amount).rev() {
                       
                        indices.swap(i as usize, rng.gen_range(0..=i) as usize);
                    }
                }
                IndexVec::from(indices)
            }
            /// Randomly sample exactly `amount` indices from `0..n`, using an inplace partial Fisher-Yates method.
            fn sample_inplace<R>(rng: &mut R, length: u32, amount: u32) -> IndexVec where
            R: Rng + ?Sized
            {
                debug_assert!(amount <= length);
                let mut indices: Vec<u32> = Vec::with_capacity(length as usize);
                indices.extend(0..length);
                for i in 0..amount {
                    let j: u32 = rng.gen_range(i..length);
                    indices.swap(i as usize, j as usize);
                }
                indices.truncate(amount as usize);
                debug_assert_eq!(indices.len(), amount as usize);
                IndexVec::from(indices)
            }

            trait UInt: Copy + PartialOrd + Ord + PartialEq + Eq + SampleUniform + ::hash::Hash + ::ops::AddAssign
            {
                fn zero() -> Self;
                fn one() -> Self;
                fn as_usize(self) -> usize;
            }

            impl UInt for u32
            {
                #[inline]
                fn zero() -> Self {
                    0
                }

                #[inline]
                fn one() -> Self {
                    1
                }

                #[inline]
                fn as_usize(self) -> usize {
                    self as usize
                }
            }

            impl UInt for usize
            {
                #[inline]
                fn zero() -> Self {
                    0
                }

                #[inline]
                fn one() -> Self {
                    1
                }

                #[inline]
                fn as_usize(self) -> usize {
                    self
                }
            }
            /// Randomly sample exactly `amount` indices from `0..length`, using rejection sampling.
            fn sample_rejection<X: UInt, R>(rng: &mut R, length: X, amount: X) -> IndexVec where
                R: Rng + ?Sized,
                IndexVec: From<Vec<X>>,
            {
                debug_assert!(amount < length);
                let mut cache = HashSet::with_capacity(amount.as_usize());
                let distr = Uniform::new(X::zero(), length);
                let mut indices = Vec::with_capacity(amount.as_usize());
                for _ in 0..amount.as_usize() {
                    let mut pos = distr.sample(rng);
                    while !cache.insert(pos) {
                        pos = distr.sample(rng);
                    }
                    indices.push(pos);
                }

                debug_assert_eq!(indices.len(), amount.as_usize());
                IndexVec::from(indices)
            }
        }
        /// Extension trait on slices, providing random mutation and sampling methods.
        pub trait SliceRandom
        {
            /// The element type.
            type Item;
            /// Returns a reference to one random element of the slice, or `None` if the slice is empty.
            fn choose<R>(&self, rng: &mut R) -> Option<&Self::Item> where R: Rng + ?Sized;
            /// Returns a mutable reference to one random element of the slice, or `None` if the slice is empty.
            fn choose_mut<R>(&mut self, rng: &mut R) -> Option<&mut Self::Item> where R: Rng + ?Sized;
            /// Chooses `amount` elements from the slice at random, without repetition, and in random order.
            fn choose_multiple<R>(&self, rng: &mut R, amount: usize) -> SliceChooseIter<Self, Self::Item> where
            R: Rng + ?Sized;
            /// Similar to [`choose`], but where the likelihood of each outcome may be specified.
            fn choose_weighted<R, F, B, X>
            (
                &self, rng: &mut R, weight: F,
            ) -> Result<&Self::Item, WeightedError> where
            R: Rng + ?Sized,
            F: Fn(&Self::Item) -> B,
            B: SampleBorrow<X>,
            X: SampleUniform
            + for<'a> ::ops::AddAssign<&'a X>
            + ::cmp::PartialOrd<X>
            + Clone
            + Default;
            /// Similar to [`choose_mut`], but where the likelihood of each outcome may be specified.
            fn choose_weighted_mut<R, F, B, X>
            (
                &mut self, rng: &mut R, weight: F,
            ) -> Result<&mut Self::Item, WeightedError> where
            R: Rng + ?Sized,
            F: Fn(&Self::Item) -> B,
            B: SampleBorrow<X>,
            X: SampleUniform
            + for<'a> ::ops::AddAssign<&'a X>
            + ::cmp::PartialOrd<X>
            + Clone
            + Default;
            /// Similar to [`choose_multiple`], but where the likelihood of each element's
            /// inclusion in the output may be specified.
            fn choose_multiple_weighted<R, F, X>
            (
                &self, rng: &mut R, amount: usize, weight: F,
            ) -> Result<SliceChooseIter<Self, Self::Item>, WeightedError> where
            R: Rng + ?Sized,
            F: Fn(&Self::Item) -> X,
            X: Into<f64>;
            /// Shuffle a mutable slice in place.
            fn shuffle<R>(&mut self, rng: &mut R) where R: Rng + ?Sized;
            /// Shuffle a slice in place, but exit early.
            fn partial_shuffle<R>( &mut self, rng: &mut R, amount: usize ) ->
            (&mut [Self::Item], &mut [Self::Item]) where R: Rng + ?Sized;
        }
        /// Extension trait on iterators, providing random sampling methods.
        pub trait IteratorRandom: Iterator + Sized
        {
            /// Choose one element at random from the iterator.
            fn choose<R>(mut self, rng: &mut R) -> Option<Self::Item> where R: Rng + ?Sized
            {
                let (mut lower, mut upper) = self.size_hint();
                let mut consumed = 0;
                let mut result = None;

               
               
               
                if upper == Some(lower) {
                    return if lower == 0 {
                        None
                    } else {
                        self.nth(gen_index(rng, lower))
                    };
                }

               
                loop {
                    if lower > 1 {
                        let ix = gen_index(rng, lower + consumed);
                        let skip = if ix < lower {
                            result = self.nth(ix);
                            lower - (ix + 1)
                        } else {
                            lower
                        };
                        if upper == Some(lower) {
                            return result;
                        }
                        consumed += lower;
                        if skip > 0 {
                            self.nth(skip - 1);
                        }
                    } else {
                        let elem = self.next();
                        if elem.is_none() {
                            return result;
                        }
                        consumed += 1;
                        if gen_index(rng, consumed) == 0 {
                            result = elem;
                        }
                    }

                    let hint = self.size_hint();
                    lower = hint.0;
                    upper = hint.1;
                }
            }
            /// Choose one element at random from the iterator.
            fn choose_stable<R>(mut self, rng: &mut R) -> Option<Self::Item> where R: Rng + ?Sized
            {
                let mut consumed = 0;
                let mut result = None;

                loop {
                   
                   
                   
                   
                    let mut next = 0;

                    let (lower, _) = self.size_hint();
                    if lower >= 2 {
                        let highest_selected = (0..lower)
                            .filter(|ix| gen_index(rng, consumed+ix+1) == 0)
                            .last();

                        consumed += lower;
                        next = lower;

                        if let Some(ix) = highest_selected {
                            result = self.nth(ix);
                            next -= ix + 1;
                            debug_assert!(result.is_some(), "iterator shorter than size_hint().0");
                        }
                    }

                    let elem = self.nth(next);
                    if elem.is_none() {
                        return result
                    }

                    if gen_index(rng, consumed+1) == 0 {
                        result = elem;
                    }
                    consumed += 1;
                }
            }
            /// Collects values at random from the iterator into a supplied buffer until that buffer is filled.
            fn choose_multiple_fill<R>(mut self, rng: &mut R, buf: &mut [Self::Item]) -> usize where
            R: Rng + ?Sized
            {
                let amount = buf.len();
                let mut len = 0;
                while len < amount {
                    if let Some(elem) = self.next() {
                        buf[len] = elem;
                        len += 1;
                    } else {
                       
                        return len;
                    }
                }

               
                for (i, elem) in self.enumerate() {
                    let k = gen_index(rng, i + 1 + amount);
                    if let Some(slot) = buf.get_mut(k) {
                        *slot = elem;
                    }
                }
                len
            }
            /// Collects `amount` values at random from the iterator into a vector.
            fn choose_multiple<R>(mut self, rng: &mut R, amount: usize) -> Vec<Self::Item> where R: Rng + ?Sized
            {
                let mut reservoir = Vec::with_capacity(amount);
                reservoir.extend(self.by_ref().take(amount));

               
                //
               
               
                if reservoir.len() == amount {
                    for (i, elem) in self.enumerate() {
                        let k = gen_index(rng, i + 1 + amount);
                        if let Some(slot) = reservoir.get_mut(k) {
                            *slot = elem;
                        }
                    }
                } else {
                   
                   
                    reservoir.shrink_to_fit();
                }
                reservoir
            }
        }
        
        impl<T> SliceRandom for [T]
        {
            type Item = T;

            fn choose<R>(&self, rng: &mut R) -> Option<&Self::Item> where R: Rng + ?Sized {
                if self.is_empty() {
                    None
                } else {
                    Some(&self[gen_index(rng, self.len())])
                }
            }

            fn choose_mut<R>(&mut self, rng: &mut R) -> Option<&mut Self::Item> where R: Rng + ?Sized {
                if self.is_empty() {
                    None
                } else {
                    let len = self.len();
                    Some(&mut self[gen_index(rng, len)])
                }
            }

            #[cfg(feature = "alloc")]
            fn choose_multiple<R>(&self, rng: &mut R, amount: usize) -> SliceChooseIter<Self, Self::Item> where R: Rng + ?Sized {
                let amount = ::core::cmp::min(amount, self.len());
                SliceChooseIter {
                    slice: self,
                    _phantom: Default::default(),
                    indices: index::sample(rng, self.len(), amount).into_iter(),
                }
            }

            #[cfg(feature = "alloc")]
            fn choose_weighted<R, F, B, X>(
                &self, rng: &mut R, weight: F,
            ) -> Result<&Self::Item, WeightedError> where
                R: Rng + ?Sized,
                F: Fn(&Self::Item) -> B,
                B: SampleBorrow<X>,
                X: SampleUniform
                    + for<'a> ::core::ops::AddAssign<&'a X>
                    + ::core::cmp::PartialOrd<X>
                    + Clone
                    + Default,
            {
                use crate::distributions::{Distribution, WeightedIndex};
                let distr = WeightedIndex::new(self.iter().map(weight))?;
                Ok(&self[distr.sample(rng)])
            }

            #[cfg(feature = "alloc")]
            fn choose_weighted_mut<R, F, B, X>(
                &mut self, rng: &mut R, weight: F,
            ) -> Result<&mut Self::Item, WeightedError> where
                R: Rng + ?Sized,
                F: Fn(&Self::Item) -> B,
                B: SampleBorrow<X>,
                X: SampleUniform
                    + for<'a> ::core::ops::AddAssign<&'a X>
                    + ::core::cmp::PartialOrd<X>
                    + Clone
                    + Default,
            {
                use crate::distributions::{Distribution, WeightedIndex};
                let distr = WeightedIndex::new(self.iter().map(weight))?;
                Ok(&mut self[distr.sample(rng)])
            }

            #[cfg(feature = "std")]
            fn choose_multiple_weighted<R, F, X>(
                &self, rng: &mut R, amount: usize, weight: F,
            ) -> Result<SliceChooseIter<Self, Self::Item>, WeightedError> where
                R: Rng + ?Sized,
                F: Fn(&Self::Item) -> X,
                X: Into<f64>,
            {
                let amount = ::core::cmp::min(amount, self.len());
                Ok(SliceChooseIter {
                    slice: self,
                    _phantom: Default::default(),
                    indices: index::sample_weighted(
                        rng,
                        self.len(),
                        |idx| weight(&self[idx]).into(),
                        amount,
                    )?
                    .into_iter(),
                })
            }

            fn shuffle<R>(&mut self, rng: &mut R)
            where R: Rng + ?Sized {
                for i in (1..self.len()).rev() {
                   
                    self.swap(i, gen_index(rng, i + 1));
                }
            }

            fn partial_shuffle<R>(
                &mut self, rng: &mut R, amount: usize,
            ) -> (&mut [Self::Item], &mut [Self::Item])
            where R: Rng + ?Sized {
               
               
               
               

                let len = self.len();
                let end = if amount >= len { 0 } else { len - amount };

                for i in (end..len).rev() {
                   
                    self.swap(i, gen_index(rng, i + 1));
                }
                let r = self.split_at_mut(end);
                (r.1, r.0)
            }
        }

        impl<I> IteratorRandom for I where I: Iterator + Sized {}
        /// An iterator over multiple slice elements.
        #[derive(Debug)]
        pub struct SliceChooseIter<'a, S: ?Sized + 'a, T: 'a>
        {
            slice: &'a S,
            _phantom: ::core::marker::PhantomData<T>,
            indices: index::IndexVecIntoIter,
        }
        
        impl<'a, S: Index<usize, Output = T> + ?Sized + 'a, T: 'a> Iterator for SliceChooseIter<'a, S, T>
        {
            type Item = &'a T;
            
            fn next(&mut self) -> Option<Self::Item>
            {
               
                self.indices.next().map(|i| &self.slice[i as usize])
            }

            fn size_hint(&self) -> (usize, Option<usize>)
            {
                (self.indices.len(), Some(self.indices.len()))
            }
        }
        
        impl<'a, S: Index<usize, Output = T> + ?Sized + 'a, T: 'a> ExactSizeIterator
            for SliceChooseIter<'a, S, T>
        {
            fn len(&self) -> usize
            {
                self.indices.len()
            }
        }
        
        #[inline] fn gen_index<R: Rng + ?Sized>(rng: &mut R, ubound: usize) -> usize
        {
            if ubound <= (::u32::MAX as usize)
            {
                rng.gen_range(0..ubound as u32) as usize
            }
            
            else
            {
                rng.gen_range(0..ubound)
            }
        }
    }
    /// Generates a random value using the thread-local random number generator.
    #[inline] pub fn random<T>() -> T where
    Standard: Distribution<T>
    { thread_rng().gen() }
}

pub mod rc
{
    pub use std::rc::{ * };
}

pub mod result
{
    pub use std::result::{ * };
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod str
{
    pub use std::str::{ * };
}

pub mod string
{
    pub use std::string::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };
}

pub mod thread
{
    pub use std::thread::{ * };
}

pub mod u8
{
    pub use std::u8::{ * };
}

pub mod u16
{
    pub use std::u16::{ * };
}

pub mod u32
{
    pub use std::u32::{ * };
}

pub mod u64
{
    pub use std::u64::{ * };
}

pub mod usize
{
    pub use std::usize::{ * };
}

pub mod u128
{
    pub use std::u128::{ * };
}

pub mod vec
{
    pub use std::vec::{ * };
}
// 28474 /////////////////////////////////////////////////////////////////////////////////////////////////////////////
