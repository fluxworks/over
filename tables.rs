//! Implementation of Unicode Standard Annex #31 for 
//! determining which `char` values are valid in programming language identifiers.
#![feature
( 
    
 )]

#![allow
( 
    bare_trait_objects,
    deprecated,
    mismatched_lifetime_syntaxes,
    non_camel_case_types,
    non_fmt_panics,
    non_snake_case,
    non_upper_case_globals,
    static_mut_refs,
    unpredictable_function_pointer_comparisons,
    unused_attributes,
    unused_imports,
    unused_macros,
    unused_variables,
 )]
/*
pub mod _
{
    pub use std::_::{ * };
}

pub mod __
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
}

pub mod error;
pub mod obj;
pub mod tup;
pub mod types;
pub mod value;
pub mod parse;

#[macro_use] extern crate bitflags;
#[macro_use] extern crate lazy_static;
#[macro_use] extern crate libc;
#[macro_use] extern crate rand;
#[macro_use] extern crate regex as re;
#[macro_use] extern crate smallvec;
#[macro_use] extern crate time as temporal;
#[macro_use] extern crate unicode_normalization;
#[macro_use] extern crate unicode_width;
*/

#[macro_use] pub mod macros
{   
    /*!
    */
    pub use std::
    {
        assert, assert_eq, assert_ne, cfg, column, compile_error, concat, dbg, debug_assert, debug_assert_eq, 
        debug_assert_ne, env, eprint, eprintln, file, format, format_args, include, include_bytes, include_str, 
        is_x86_feature_detected, line, matches, module_path, option_env, panic, print, println, stringify, 
        thread_local, todo, unimplemented, unreachable, vec, write, writeln
    };

    use ::
    {
        cell::{ Cell },
        mem::{ MaybeUninit },
        sync::{ Once, ONCE_INIT },
        *
    };

    #[macro_export] macro_rules! quote
    {
        () =>
        {
            ::__private::TokenStream::new()
        };
       
        ( $tt:tt ) => 
        {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt _s}
            _s
        }};
       
        
        ( # $var:ident ) => 
        {{
            let mut _s = ::__private::TokenStream::new();
            ::ToTokens::to_tokens( &$var, &mut _s );
            _s
        }};
        
        ( $tt1:tt $tt2:tt ) =>
        {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_token!{$tt1 _s}
            ::quote_token!{$tt2 _s}
            _s
        }};
       
        ( $( $tt:tt )* ) => {{
            let mut _s = ::__private::TokenStream::new();
            ::quote_each_token!{_s $( $tt )*}
            _s
        }};
    }

    #[macro_export] macro_rules! quote_spanned
    {
        ( $span:expr=> ) => {{
            let _: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::__private::TokenStream::new()
        }};
       
        ( $span:expr=> $tt:tt ) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::quote_token_spanned!{$tt _s _span}
            _s
        }};
       
        ( $span:expr=> # $var:ident ) => {{
            let mut _s = ::__private::TokenStream::new();
            let _: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::ToTokens::to_tokens( &$var, &mut _s );
            _s
        }};
        ( $span:expr=> $tt1:tt $tt2:tt ) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::quote_token_spanned!{$tt1 _s _span}
            ::quote_token_spanned!{$tt2 _s _span}
            _s
        }};
       
        ( $span:expr=> $( $tt:tt )* ) => {{
            let mut _s = ::__private::TokenStream::new();
            let _span: ::__private::Span = ::__private::get_span( $span ).__into_span();
            ::quote_each_token_spanned!{_s _span $( $tt )*}
            _s
        }};
    }
   
    #[macro_export] macro_rules! pounded_var_names
    {
        ( $call:ident! $extra:tt $( $tts:tt )* ) => {
            ::pounded_var_names_with_context!{$call! $extra
                ( @ $( $tts )* )
                ( $( $tts )* @ )
            }
        };
    }

    #[macro_export] macro_rules! pounded_var_names_with_context
    {
        ( $call:ident! $extra:tt ( $( $b1:tt )* ) ( $( $curr:tt )* ) ) => {
            $( 
                ::pounded_var_with_context!{$call! $extra $b1 $curr}
            )*
        };
    }

    #[macro_export] macro_rules! pounded_var_with_context
    {
        ( $call:ident! $extra:tt $b1:tt ( $( $inner:tt )* ) ) => { ::pounded_var_names!{$call! $extra $( $inner )*} };

        ( $call:ident! $extra:tt $b1:tt [ $( $inner:tt )* ] ) => { ::pounded_var_names!{$call! $extra $( $inner )*} };

        ( $call:ident! $extra:tt $b1:tt { $( $inner:tt )* } ) => { ::pounded_var_names!{$call! $extra $( $inner )*} };

        ( $call:ident!( $( $extra:tt )* ) # $var:ident ) => { ::$call!( $( $extra )* $var ); };

        ( $call:ident! $extra:tt $b1:tt $curr:tt ) => {};
    }

    #[macro_export] macro_rules! quote_bind_into_iter 
    {
        ( $has_iter:ident $var:ident ) => {
           
            #[allow( unused_mut )]
            let ( mut $var, i ) = $var.quote_into_iter();
            let $has_iter = $has_iter | i;
        };
    }

    #[macro_export] macro_rules! quote_bind_next_or_break 
    {
        ( $var:ident ) =>
        {
            let $var = match $var.next() {
                Some( _x ) => ::__private::RepInterp( _x ),
                None => break,
            };
        };
    }
    
    #[macro_export] macro_rules! quote_each_token 
    {
        ( $tokens:ident $( $tts:tt )* ) => {
            ::quote_tokens_with_context!{$tokens
                ( @ @ @ @ @ @ $( $tts )* )
                ( @ @ @ @ @ $( $tts )* @ )
                ( @ @ @ @ $( $tts )* @ @ )
                ( @ @ @ $( ( $tts ) )* @ @ @ )
                ( @ @ $( $tts )* @ @ @ @ )
                ( @ $( $tts )* @ @ @ @ @ )
                ( $( $tts )* @ @ @ @ @ @ )
            }
        };
    }

    #[macro_export] macro_rules! quote_each_token_spanned 
    {
        ( $tokens:ident $span:ident $( $tts:tt )* ) => {
            ::quote_tokens_with_context_spanned!{$tokens $span
                ( @ @ @ @ @ @ $( $tts )* )
                ( @ @ @ @ @ $( $tts )* @ )
                ( @ @ @ @ $( $tts )* @ @ )
                ( @ @ @ $( ( $tts ) )* @ @ @ )
                ( @ @ $( $tts )* @ @ @ @ )
                ( @ $( $tts )* @ @ @ @ @ )
                ( $( $tts )* @ @ @ @ @ @ )
            }
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context
    {
        ( $tokens:ident
            ( $( $b3:tt )* ) ( $( $b2:tt )* ) ( $( $b1:tt )* )
            ( $( $curr:tt )* )
            ( $( $a1:tt )* ) ( $( $a2:tt )* ) ( $( $a3:tt )* )
        ) => {
            $( 
                ::quote_token_with_context!{$tokens $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_tokens_with_context_spanned
    {
        ( $tokens:ident $span:ident
            ( $( $b3:tt )* ) ( $( $b2:tt )* ) ( $( $b1:tt )* )
            ( $( $curr:tt )* )
            ( $( $a1:tt )* ) ( $( $a2:tt )* ) ( $( $a3:tt )* )
        ) => {
            $( 
                ::quote_token_with_context_spanned!{$tokens $span $b3 $b2 $b1 $curr $a1 $a2 $a3}
            )*
        };
    }

    #[macro_export] macro_rules! quote_token_with_context
    {  
        ( $tokens:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt $b2:tt $b1:tt ( # ) ( $( $inner:tt )* ) * $a3:tt ) => 
        {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!( has_iter ) () $( $inner )*}
            let _: ::__private::HasIterator = has_iter;
            
            while true 
            {
                ::pounded_var_names!{quote_bind_next_or_break!() () $( $inner )*}
                ::quote_each_token!{$tokens $( $inner )*}
            }
        }};
       
        ( $tokens:ident $b3:tt $b2:tt # ( ( $( $inner:tt )* ) ) * $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt # ( $( $inner:tt )* ) ( * ) $a1:tt $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt $b2:tt $b1:tt ( # ) ( $( $inner:tt )* ) $sep:tt * ) => 
        {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!( has_iter ) () $( $inner )*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $( $inner )*}
                if _i > 0 {
                    ::quote_token!{$sep $tokens}
                }
                _i += 1;
                ::quote_each_token!{$tokens $( $inner )*}
            }
        }};
       
        ( $tokens:ident $b3:tt $b2:tt # ( ( $( $inner:tt )* ) ) $sep:tt * $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt # ( $( $inner:tt )* ) ( $sep:tt ) * $a2:tt $a3:tt ) => {};
       
       
        ( $tokens:ident # ( $( $inner:tt )* ) * ( * ) $a1:tt $a2:tt $a3:tt ) => { ::quote_token!{* $tokens} };
       
        ( $tokens:ident # ( $( $inner:tt )* ) $sep:tt ( * ) $a1:tt $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt $b2:tt $b1:tt ( # ) $var:ident $a2:tt $a3:tt ) => { ::ToTokens::to_tokens( &$var, &mut $tokens ); };
       
        ( $tokens:ident $b3:tt $b2:tt # ( $var:ident ) $a1:tt $a2:tt $a3:tt ) => {};
       
        ( $tokens:ident $b3:tt $b2:tt $b1:tt ( $curr:tt ) $a1:tt $a2:tt $a3:tt ) => { ::quote_token!{$curr $tokens} };
    }
    
    #[macro_export] macro_rules! quote_token_with_context_spanned 
    {
        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt @ $a1:tt $a2:tt $a3:tt ) => {};

        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ( # ) ( $( $inner:tt )* ) * $a3:tt ) => {{
            use ::__private::ext::*;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!( has_iter ) () $( $inner )*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $( $inner )*}
                ::quote_each_token_spanned!{$tokens $span $( $inner )*}
            }
        }};
        ( $tokens:ident $span:ident $b3:tt $b2:tt # ( ( $( $inner:tt )* ) ) * $a2:tt $a3:tt ) => {};
        ( $tokens:ident $span:ident $b3:tt # ( $( $inner:tt )* ) ( * ) $a1:tt $a2:tt $a3:tt ) => {};

        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ( # ) ( $( $inner:tt )* ) $sep:tt * ) => {{
            use ::__private::ext::*;
            let mut _i = 0usize;
            let has_iter = ::__private::ThereIsNoIteratorInRepetition;
            ::pounded_var_names!{quote_bind_into_iter!( has_iter ) () $( $inner )*}
            let _: ::__private::HasIterator = has_iter;
            while true {
                ::pounded_var_names!{quote_bind_next_or_break!() () $( $inner )*}
                if _i > 0 {
                    ::quote_token_spanned!{$sep $tokens $span}
                }
                _i += 1;
                ::quote_each_token_spanned!{$tokens $span $( $inner )*}
            }
        }};
        ( $tokens:ident $span:ident $b3:tt $b2:tt # ( ( $( $inner:tt )* ) ) $sep:tt * $a3:tt ) => {};
        ( $tokens:ident $span:ident $b3:tt # ( $( $inner:tt )* ) ( $sep:tt ) * $a2:tt $a3:tt ) => {};
        ( $tokens:ident $span:ident # ( $( $inner:tt )* ) * ( * ) $a1:tt $a2:tt $a3:tt ) => { ::quote_token_spanned!{* $tokens $span} };
        ( $tokens:ident $span:ident # ( $( $inner:tt )* ) $sep:tt ( * ) $a1:tt $a2:tt $a3:tt ) => {};

        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ( # ) $var:ident $a2:tt $a3:tt ) => { ::ToTokens::to_tokens( &$var, &mut $tokens ); };
        ( $tokens:ident $span:ident $b3:tt $b2:tt # ( $var:ident ) $a1:tt $a2:tt $a3:tt ) => {};

        ( $tokens:ident $span:ident $b3:tt $b2:tt $b1:tt ( $curr:tt ) $a1:tt $a2:tt $a3:tt ) => { ::quote_token_spanned!{$curr $tokens $span} };
    }
    
    #[macro_export] macro_rules! quote_token
    {
        ( $ident:ident $tokens:ident ) =>
        {
            ::__private::push_ident( &mut $tokens, stringify!( $ident ) );
        };

        ( :: $tokens:ident ) =>
        {
            ::__private::push_colon2( &mut $tokens );
        };

        ( ( $( $inner:tt )* ) $tokens:ident ) =>
        {
            ::__private::push_group
            ( 
                &mut $tokens,
                ::__private::Delimiter::Parenthesis,
                ::quote!( $( $inner )* ),
             );
        };

        ( [ $( $inner:tt )* ] $tokens:ident ) =>
        {
            ::__private::push_group
            ( 
                &mut $tokens,
                ::__private::Delimiter::Bracket,
                ::quote!( $( $inner )* ),
             );
        };

        ( { $( $inner:tt )* } $tokens:ident ) =>
        {
            ::__private::push_group
            ( 
                &mut $tokens,
                ::__private::Delimiter::Brace,
                ::quote!( $( $inner )* ),
             );
        };

        ( # $tokens:ident ) =>
        {
            ::__private::push_pound( &mut $tokens );
        };

        ( , $tokens:ident ) =>
        {
            ::__private::push_comma( &mut $tokens );
        };

        ( . $tokens:ident ) =>
        {
            ::__private::push_dot( &mut $tokens );
        };

        ( ; $tokens:ident ) =>
        {
            ::__private::push_semi( &mut $tokens );
        };

        ( : $tokens:ident ) =>
        {
            ::__private::push_colon( &mut $tokens );
        };

        ( + $tokens:ident ) =>
        {
            ::__private::push_add( &mut $tokens );
        };

        ( += $tokens:ident ) =>
        {
            ::__private::push_add_eq( &mut $tokens );
        };

        ( & $tokens:ident ) =>
        {
            ::__private::push_and( &mut $tokens );
        };

        ( && $tokens:ident ) =>
        {
            ::__private::push_and_and( &mut $tokens );
        };

        ( &= $tokens:ident ) =>
        {
            ::__private::push_and_eq( &mut $tokens );
        };

        ( @ $tokens:ident ) =>
        {
            ::__private::push_at( &mut $tokens );
        };

        ( ! $tokens:ident ) =>
        {
            ::__private::push_bang( &mut $tokens );
        };

        ( ^ $tokens:ident ) =>
        {
            ::__private::push_caret( &mut $tokens );
        };

        ( ^= $tokens:ident ) =>
        {
            ::__private::push_caret_eq( &mut $tokens );
        };

        ( / $tokens:ident ) =>
        {
            ::__private::push_div( &mut $tokens );
        };

        ( /= $tokens:ident ) =>
        {
            ::__private::push_div_eq( &mut $tokens );
        };

        ( .. $tokens:ident ) =>
        {
            ::__private::push_dot2( &mut $tokens );
        };

        ( ... $tokens:ident ) =>
        {
            ::__private::push_dot3( &mut $tokens );
        };

        ( ..= $tokens:ident ) =>
        {
            ::__private::push_dot_dot_eq( &mut $tokens );
        };

        ( = $tokens:ident ) =>
        {
            ::__private::push_eq( &mut $tokens );
        };

        ( == $tokens:ident ) =>
        {
            ::__private::push_eq_eq( &mut $tokens );
        };

        ( >= $tokens:ident ) =>
        {
            ::__private::push_ge( &mut $tokens );
        };

        ( > $tokens:ident ) =>
        {
            ::__private::push_gt( &mut $tokens );
        };

        ( <= $tokens:ident ) =>
        {
            ::__private::push_le( &mut $tokens );
        };

        ( < $tokens:ident ) =>
        {
            ::__private::push_lt( &mut $tokens );
        };

        ( *= $tokens:ident ) =>
        {
            ::__private::push_mul_eq( &mut $tokens );
        };

        ( != $tokens:ident ) =>
        {
            ::__private::push_ne( &mut $tokens );
        };

        ( | $tokens:ident ) =>
        {
            ::__private::push_or( &mut $tokens );
        };

        ( |= $tokens:ident ) =>
        {
            ::__private::push_or_eq( &mut $tokens );
        };

        ( || $tokens:ident ) =>
        {
            ::__private::push_or_or( &mut $tokens );
        };

        ( ? $tokens:ident ) =>
        {
            ::__private::push_question( &mut $tokens );
        };

        ( -> $tokens:ident ) =>
        {
            ::__private::push_rarrow( &mut $tokens );
        };

        ( <- $tokens:ident ) =>
        {
            ::__private::push_larrow( &mut $tokens );
        };

        ( % $tokens:ident ) =>
        {
            ::__private::push_rem( &mut $tokens );
        };

        ( %= $tokens:ident ) =>
        {
            ::__private::push_rem_eq( &mut $tokens );
        };

        ( => $tokens:ident ) =>
        {
            ::__private::push_fat_arrow( &mut $tokens );
        };

        ( << $tokens:ident ) =>
        {
            ::__private::push_shl( &mut $tokens );
        };

        ( <<= $tokens:ident ) =>
        {
            ::__private::push_shl_eq( &mut $tokens );
        };

        ( >> $tokens:ident ) =>
        {
            ::__private::push_shr( &mut $tokens );
        };

        ( >>= $tokens:ident ) =>
        {
            ::__private::push_shr_eq( &mut $tokens );
        };

        ( * $tokens:ident ) =>
        {
            ::__private::push_star( &mut $tokens );
        };

        ( - $tokens:ident ) =>
        {
            ::__private::push_sub( &mut $tokens );
        };

        ( -= $tokens:ident ) =>
        {
            ::__private::push_sub_eq( &mut $tokens );
        };

        ( $lifetime:lifetime $tokens:ident ) =>
        {
            ::__private::push_lifetime( &mut $tokens, stringify!( $lifetime ) );
        };

        ( _ $tokens:ident ) =>
        {
            ::__private::push_underscore( &mut $tokens );
        };

        ( $other:tt $tokens:ident ) =>
        {
            ::__private::parse( &mut $tokens, stringify!( $other ) );
        };
    }

    #[macro_export] macro_rules! quote_token_spanned
    {
        ( $ident:ident $tokens:ident $span:ident ) =>
        {
            ::__private::push_ident_spanned( &mut $tokens, $span, stringify!( $ident ) );
        };

        ( :: $tokens:ident $span:ident ) =>
        {
            ::__private::push_colon2_spanned( &mut $tokens, $span );
        };

        ( ( $( $inner:tt )* ) $tokens:ident $span:ident ) =>
        {
            ::__private::push_group_spanned            
            ( 
                &mut $tokens,
                $span,
                ::__private::Delimiter::Parenthesis,
                ::quote_spanned!( $span=> $( $inner )* ),
             );
        };

        ( [ $( $inner:tt )* ] $tokens:ident $span:ident ) =>
        {
            ::__private::push_group_spanned
            ( 
                &mut $tokens,
                $span,
                ::__private::Delimiter::Bracket,
                ::quote_spanned!( $span=> $( $inner )* ),
             );
        };

        ( { $( $inner:tt )* } $tokens:ident $span:ident ) =>
        {
            ::__private::push_group_spanned
            
            ( 
                &mut $tokens,
                $span,
                ::__private::Delimiter::Brace,
                ::quote_spanned!( $span=> $( $inner )* ),
             );
        };

        ( # $tokens:ident $span:ident ) =>
        {
            ::__private::push_pound_spanned( &mut $tokens, $span );
        };

        ( , $tokens:ident $span:ident ) =>
        {
            ::__private::push_comma_spanned( &mut $tokens, $span );
        };

        ( . $tokens:ident $span:ident ) =>
        {
            ::__private::push_dot_spanned( &mut $tokens, $span );
        };

        ( ; $tokens:ident $span:ident ) =>
        {
            ::__private::push_semi_spanned( &mut $tokens, $span );
        };

        ( : $tokens:ident $span:ident ) =>
        {
            ::__private::push_colon_spanned( &mut $tokens, $span );
        };

        ( + $tokens:ident $span:ident ) =>
        {
            ::__private::push_add_spanned( &mut $tokens, $span );
        };

        ( += $tokens:ident $span:ident ) =>
        {
            ::__private::push_add_eq_spanned( &mut $tokens, $span );
        };

        ( & $tokens:ident $span:ident ) =>
        {
            ::__private::push_and_spanned( &mut $tokens, $span );
        };

        ( && $tokens:ident $span:ident ) =>
        {
            ::__private::push_and_and_spanned( &mut $tokens, $span );
        };

        ( &= $tokens:ident $span:ident ) =>
        {
            ::__private::push_and_eq_spanned( &mut $tokens, $span );
        };

        ( @ $tokens:ident $span:ident ) =>
        {
            ::__private::push_at_spanned( &mut $tokens, $span );
        };

        ( ! $tokens:ident $span:ident ) =>
        {
            ::__private::push_bang_spanned( &mut $tokens, $span );
        };

        ( ^ $tokens:ident $span:ident ) =>
        {
            ::__private::push_caret_spanned( &mut $tokens, $span );
        };

        ( ^= $tokens:ident $span:ident ) =>
        {
            ::__private::push_caret_eq_spanned( &mut $tokens, $span );
        };

        ( / $tokens:ident $span:ident ) =>
        {
            ::__private::push_div_spanned( &mut $tokens, $span );
        };

        ( /= $tokens:ident $span:ident ) =>
        {
            ::__private::push_div_eq_spanned( &mut $tokens, $span );
        };

        ( .. $tokens:ident $span:ident ) =>
        {
            ::__private::push_dot2_spanned( &mut $tokens, $span );
        };

        ( ... $tokens:ident $span:ident ) =>
        {
            ::__private::push_dot3_spanned( &mut $tokens, $span );
        };

        ( ..= $tokens:ident $span:ident ) =>
        {
            ::__private::push_dot_dot_eq_spanned( &mut $tokens, $span );
        };

        ( = $tokens:ident $span:ident ) =>
        {
            ::__private::push_eq_spanned( &mut $tokens, $span );
        };

        ( == $tokens:ident $span:ident ) =>
        {
            ::__private::push_eq_eq_spanned( &mut $tokens, $span );
        };

        ( >= $tokens:ident $span:ident ) =>
        {
            ::__private::push_ge_spanned( &mut $tokens, $span );
        };

        ( > $tokens:ident $span:ident ) =>
        {
            ::__private::push_gt_spanned( &mut $tokens, $span );
        };

        ( <= $tokens:ident $span:ident ) =>
        {
            ::__private::push_le_spanned( &mut $tokens, $span );
        };

        ( < $tokens:ident $span:ident ) =>
        {
            ::__private::push_lt_spanned( &mut $tokens, $span );
        };

        ( *= $tokens:ident $span:ident ) =>
        {
            ::__private::push_mul_eq_spanned( &mut $tokens, $span );
        };

        ( != $tokens:ident $span:ident ) =>
        {
            ::__private::push_ne_spanned( &mut $tokens, $span );
        };

        ( | $tokens:ident $span:ident ) =>
        {
            ::__private::push_or_spanned( &mut $tokens, $span );
        };

        ( |= $tokens:ident $span:ident ) =>
        {
            ::__private::push_or_eq_spanned( &mut $tokens, $span );
        };

        ( || $tokens:ident $span:ident ) =>
        {
            ::__private::push_or_or_spanned( &mut $tokens, $span );
        };

        ( ? $tokens:ident $span:ident ) =>
        {
            ::__private::push_question_spanned( &mut $tokens, $span );
        };

        ( -> $tokens:ident $span:ident ) =>
        {
            ::__private::push_rarrow_spanned( &mut $tokens, $span );
        };

        ( <- $tokens:ident $span:ident ) =>
        {
            ::__private::push_larrow_spanned( &mut $tokens, $span );
        };

        ( % $tokens:ident $span:ident ) =>
        {
            ::__private::push_rem_spanned( &mut $tokens, $span );
        };

        ( %= $tokens:ident $span:ident ) =>
        {
            ::__private::push_rem_eq_spanned( &mut $tokens, $span );
        };

        ( => $tokens:ident $span:ident ) =>
        {
            ::__private::push_fat_arrow_spanned( &mut $tokens, $span );
        };

        ( << $tokens:ident $span:ident ) =>
        {
            ::__private::push_shl_spanned( &mut $tokens, $span );
        };

        ( <<= $tokens:ident $span:ident ) =>
        {
            ::__private::push_shl_eq_spanned( &mut $tokens, $span );
        };

        ( >> $tokens:ident $span:ident ) =>
        {
            ::__private::push_shr_spanned( &mut $tokens, $span );
        };

        ( >>= $tokens:ident $span:ident ) =>
        {
            ::__private::push_shr_eq_spanned( &mut $tokens, $span );
        };

        ( * $tokens:ident $span:ident ) =>
        {
            ::__private::push_star_spanned( &mut $tokens, $span );
        };

        ( - $tokens:ident $span:ident ) =>
        {
            ::__private::push_sub_spanned( &mut $tokens, $span );
        };

        ( -= $tokens:ident $span:ident ) =>
        {
            ::__private::push_sub_eq_spanned( &mut $tokens, $span );
        };

        ( $lifetime:lifetime $tokens:ident $span:ident ) =>
        {
            ::__private::push_lifetime_spanned( &mut $tokens, $span, stringify!( $lifetime ) );
        };

        ( _ $tokens:ident $span:ident ) =>
        {
            ::__private::push_underscore_spanned( &mut $tokens, $span );
        };

        ( $other:tt $tokens:ident $span:ident ) =>
        {
            ::__private::parse_spanned( &mut $tokens, $span, stringify!( $other ) );
        };
    }

    #[macro_export] macro_rules! format_ident
    {
        ( $fmt:expr ) => {
            format_ident_impl!( [
                ::quote::__private::Option::None,
                $fmt
            ] )
        };

        ( $fmt:expr, $( $rest:tt )* ) => {
            format_ident_impl!( [
                ::quote::__private::Option::None,
                $fmt
            ] $( $rest )* )
        };
    }

    #[macro_export] macro_rules! format_ident_impl
    {
       
        ( [$span:expr, $( $fmt:tt )*] ) => {
            ::quote::__private::mk_ident( 
                &::quote::__private::format!( $( $fmt )* ),
                $span,
            )
        };

       
        ( [$old:expr, $( $fmt:tt )*] span = $span:expr ) => { format_ident_impl!( [$old, $( $fmt )*] span = $span, ) };
        ( [$old:expr, $( $fmt:tt )*] span = $span:expr, $( $rest:tt )* ) => {
            format_ident_impl!( [
                ::quote::__private::Option::Some::<::quote::__private::Span>( $span ),
                $( $fmt )*
            ] $( $rest )* )
        };

       
        ( [$span:expr, $( $fmt:tt )*] $name:ident = $arg:expr ) => { format_ident_impl!( [$span, $( $fmt )*] $name = $arg, ) };
        ( [$span:expr, $( $fmt:tt )*] $name:ident = $arg:expr, $( $rest:tt )* ) => {
            match ::quote::__private::IdentFragmentAdapter( &$arg ) {
                arg => format_ident_impl!( [$span.or( arg.span() ), $( $fmt )*, $name = arg] $( $rest )* ),
            }
        };

       
        ( [$span:expr, $( $fmt:tt )*] $arg:expr ) => { format_ident_impl!( [$span, $( $fmt )*] $arg, ) };
        ( [$span:expr, $( $fmt:tt )*] $arg:expr, $( $rest:tt )* ) => {
            match ::quote::__private::IdentFragmentAdapter( &$arg ) {
                arg => format_ident_impl!( [$span.or( arg.span() ), $( $fmt )*, arg] $( $rest )* ),
            }
        };
    }

    #[macro_export] macro_rules! ast_struct 
    {
        ( 
            $( #[$attr:meta] )*
            $pub:ident $struct:ident $name:ident #full $body:tt
        ) =>
        {
            check_keyword_matches!( pub $pub );
            check_keyword_matches!( struct $struct );
            $( #[$attr] )* $pub $struct $name $body
        };

        ( 
            $( #[$attr:meta] )*
            $pub:ident $struct:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!( pub $pub );
            check_keyword_matches!( struct $struct );

            $( #[$attr] )* $pub $struct $name $body
        };
    }
    
    #[macro_export] macro_rules! ast_enum
    {
        ( 
            $( #[$enum_attr:meta] )*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!( pub $pub );
            check_keyword_matches!( enum $enum );

            $( #[$enum_attr] )* $pub $enum $name $body
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs
    {
        ( 
            $( #[$enum_attr:meta] )*
            $pub:ident $enum:ident $name:ident $body:tt
        ) => {
            check_keyword_matches!( pub $pub );
            check_keyword_matches!( enum $enum );

            $( #[$enum_attr] )* $pub $enum $name $body

            ast_enum_of_structs_impl!( $name $body );

                generate_to_tokens!( () tokens $name $body );
        };
    }

    #[macro_export] macro_rules! ast_enum_of_structs_impl
    {
        ( 
            $name:ident {
                $( 
                    $( #[cfg $cfg_attr:tt] )*
                    $( #[doc $( $doc_attr:tt )*] )*
                    $variant:ident $( ( $member:ident ) )*,
                )*
            }
        ) => {
            $( $( 
                ast_enum_from_struct!( $name::$variant, $member );
            )* )*
        };
    }

    #[macro_export] macro_rules! ast_enum_from_struct
    {
        ( $name:ident::Verbatim, $member:ident ) => {};

        ( $name:ident::$variant:ident, $member:ident ) =>
        {
            impl From<$member> for $name
            {
                fn from( e: $member ) -> $name {
                    $name::$variant( e )
                }
            }
        };
    }
    
    #[macro_export] macro_rules! generate_to_tokens
    {
        ( 
            ( $( $arms:tt )* ) $tokens:ident $name:ident {
                $( #[cfg $cfg_attr:tt] )*
                $( #[doc $( $doc_attr:tt )*] )*
                $variant:ident,
                $( $next:tt )*
            }
        ) => {
            generate_to_tokens!( 
                ( $( $arms )* $( #[cfg $cfg_attr] )* $name::$variant => {} )
                $tokens $name { $( $next )* }
             );
        };

        ( 
            ( $( $arms:tt )* ) $tokens:ident $name:ident {
                $( #[cfg $cfg_attr:tt] )*
                $( #[doc $( $doc_attr:tt )*] )*
                $variant:ident( $member:ident ),
                $( $next:tt )*
            }
        ) => {
            generate_to_tokens!( 
                ( $( $arms )* $( #[cfg $cfg_attr] )* $name::$variant( _e ) => _e.to_tokens( $tokens ), )
                $tokens $name { $( $next )* }
             );
        };

        ( ( $( $arms:tt )* ) $tokens:ident $name:ident {} ) => {
            impl ::quote::ToTokens for $name {
                fn to_tokens( &self, $tokens:&mut ::process::macros::TokenStream )
                {
                    match self {
                        $( $arms )*
                    }
                }
            }
        };
    }
    
    #[macro_export] macro_rules! pub_if_not_doc
    {
        ( $( #[$m:meta] )* $pub:ident $( $item:tt )* ) => {
            check_keyword_matches!( pub $pub );

            $( #[$m] )*
            $pub $( $item )*
        };
    }

    #[macro_export] macro_rules! check_keyword_matches 
    {
        ( enum enum ) => {};
        ( pub pub ) => {};
        ( struct struct ) => {};
    }

    #[macro_export] macro_rules! return_impl_trait
    {
        ( 
            $( #[$attr:meta] )*
            $vis:vis fn $name:ident $args:tt -> $impl_trait:ty [$concrete:ty] $body:block
        ) => {
            #[cfg( not( docsrs ) )]
            $( #[$attr] )*
            $vis fn $name $args -> $concrete $body

            #[cfg( docsrs )]
            $( #[$attr] )*
            $vis fn $name $args -> $impl_trait $body
        };
    }

    #[macro_export] macro_rules! parenthesized
    {
        ( $content:ident in $cursor:expr ) => {
            match ::syntax::__private::parse_parens( &$cursor ) {
                ::syntax::__private::Ok( parens ) => {
                    $content = parens.content;
                    parens.token
                }
                ::syntax::__private::Err( error ) => { return ::syntax::__private::Err( error ); }
            }
        };
    }

    #[macro_export] macro_rules! braced
    {
        ( $content:ident in $cursor:expr ) => 
        {
            match ::syntax::__private::parse_braces( &$cursor ) {
                ::syntax::__private::Ok( braces ) => {
                    $content = braces.content;
                    braces.token
                }
                ::syntax::__private::Err( error ) => { return ::syntax::__private::Err( error ); }
            }
        };
    }

    #[macro_export] macro_rules! bracketed
    {
        ( $content:ident in $cursor:expr ) =>
        {
            match ::syntax::__private::parse_brackets( &$cursor )
            {
                ::syntax::__private::Ok( brackets ) => {
                    $content = brackets.content;
                    brackets.token
                }
                ::syntax::__private::Err( error ) => { return ::syntax::__private::Err( error ); }
            }
        };
    }

    #[macro_export] macro_rules! parse_quote
    {
        ( $( $tt:tt )* ) =>
        {
            ::syntax::__private::parse_quote( ::syntax::__private::quote::quote!( $( $tt )* ) )
        };
    }

    #[macro_export] macro_rules! parse_quote_spanned
    {
        ( $span:expr=> $( $tt:tt )* ) =>
        {
            ::syntax::__private::parse_quote( ::syntax::__private::quote::quote_spanned!( $span=> $( $tt )* ) )
        };
    }
    
    #[macro_export] macro_rules! parse_macro_input
    {
        ( $tokenstream:ident as $ty:ty ) => {
            match ::syntax::parse::<$ty>( $tokenstream ) {
                ::syntax::__private::Ok( data ) => data,
                ::syntax::__private::Err( err ) => { return ::syntax::__private::TokenStream::from( err.to_compile_error() ); }
            }
        };
        ( $tokenstream:ident with $parser:path ) => {
            match ::syntax::parse::Parser::parse( $parser, $tokenstream ) {
                ::syntax::__private::Ok( data ) => data,
                ::syntax::__private::Err( err ) => { return ::syntax::__private::TokenStream::from( err.to_compile_error() ); }
            }
        };
        ( $tokenstream:ident ) => { ::syntax::parse_macro_input!( $tokenstream as _ ) };
    }

    #[macro_export] macro_rules! custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) =>
        {
            pub struct $ident {
                #[allow( dead_code )]
                pub spans: ::syntax::custom_punctuation_repr!( $( $tt )+ ),
            }
                #[allow( dead_code, non_snake_case )]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::custom_punctuation_repr!( $( $tt )+ )>>( 
                spans: __S,
            ) -> $ident {
                let _validate_len = 0 $( + ::syntax::custom_punctuation_len!( strict, $tt ) )*;
                $ident {
                    spans: ::syntax::__private::IntoSpans::into_spans( spans )
                }
            }
            const _: () = {
                impl ::syntax::__private::Default for $ident
                {
                    fn default() -> Self {
                        $ident( ::syntax::__private::Span::call_site() )
                    }
                }
                ::syntax::impl_parse_for_custom_punctuation!( $ident, $( $tt )+ );
                ::syntax::impl_to_tokens_for_custom_punctuation!( $ident, $( $tt )+ );
                ::syntax::impl_clone_for_custom_punctuation!( $ident, $( $tt )+ );
                ::syntax::impl_extra_traits_for_custom_punctuation!( $ident, $( $tt )+ );
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) => {
            impl ::syntax::__private::CustomToken for $ident {
                fn peek( cursor: ::syntax::buffer::Cursor ) -> ::syntax::__private::bool {
                    ::syntax::__private::peek_punct( cursor, ::syntax::stringify_punct!( $( $tt )+ ) )
                }
                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!( "`", ::syntax::stringify_punct!( $( $tt )+ ), "`" )
                }
            }
            
            impl ::syntax::parse::Parse for $ident
            {
                fn parse( input: ::syntax::parse::ParseStream ) -> ::syntax::parse::Result<$ident> {
                    let spans: ::syntax::custom_punctuation_repr!( $( $tt )+ ) =
                        ::syntax::__private::parse_punct( input, ::syntax::stringify_punct!( $( $tt )+ ) )?;
                    Ok( $ident( spans ) )
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens( &self, tokens:&mut ::syntax::__private::TokenStream2 ) {
                    ::syntax::__private::print_punct( ::syntax::stringify_punct!( $( $tt )+ ), &self.spans, tokens )
                }
            }
        };
    }
        
    #[macro_export] macro_rules! impl_clone_for_custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) => {
            impl ::syntax::__private::Copy for $ident {}
            #[allow( clippy::expl_impl_clone_on_copy )]
            impl ::syntax::__private::Clone for $ident {
                fn clone( &self ) -> Self { *self }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_punctuation
    {
        ( $ident:ident, $( $tt:tt )+ ) => {
            impl ::syntax::__private::Debug for $ident
            {
                fn fmt( &self, f:&mut ::syntax::__private::Formatter ) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str( f, ::syntax::__private::stringify!( $ident ) )
                }
            }
            
            impl ::syntax::__private::Eq for $ident {}
            
            impl ::syntax::__private::PartialEq for $ident {
                fn eq( &self, _other:&Self ) -> ::syntax::__private::bool {
                    true
                }
            }
            
            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>( &self, _state:&mut __H ) {}
            }
        };
    }
        
    #[macro_export] macro_rules! custom_punctuation_repr
    {
        ( $( $tt:tt )+ ) => { [::syntax::__private::Span; 0 $( + ::syntax::custom_punctuation_len!( lenient, $tt ) )+] };
    }
    
    #[macro_export] macro_rules! custom_punctuation_len
    {
        ( $mode:ident, & )     => { 1 };
        ( $mode:ident, && )    => { 2 };
        ( $mode:ident, &= )    => { 2 };
        ( $mode:ident, @ )     => { 1 };
        ( $mode:ident, ^ )     => { 1 };
        ( $mode:ident, ^= )    => { 2 };
        ( $mode:ident, : )     => { 1 };
        ( $mode:ident, , )     => { 1 };
        ( $mode:ident, $ )     => { 1 };
        ( $mode:ident, . )     => { 1 };
        ( $mode:ident, .. )    => { 2 };
        ( $mode:ident, ... )   => { 3 };
        ( $mode:ident, ..= )   => { 3 };
        ( $mode:ident, = )     => { 1 };
        ( $mode:ident, == )    => { 2 };
        ( $mode:ident, => )    => { 2 };
        ( $mode:ident, >= )    => { 2 };
        ( $mode:ident, > )     => { 1 };
        ( $mode:ident, <- )    => { 2 };
        ( $mode:ident, <= )    => { 2 };
        ( $mode:ident, < )     => { 1 };
        ( $mode:ident, - )     => { 1 };
        ( $mode:ident, -= )    => { 2 };
        ( $mode:ident, != )    => { 2 };
        ( $mode:ident, ! )     => { 1 };
        ( $mode:ident, | )     => { 1 };
        ( $mode:ident, |= )    => { 2 };
        ( $mode:ident, || )    => { 2 };
        ( $mode:ident, :: )    => { 2 };
        ( $mode:ident, % )     => { 1 };
        ( $mode:ident, %= )    => { 2 };
        ( $mode:ident, + )     => { 1 };
        ( $mode:ident, += )    => { 2 };
        ( $mode:ident, # )     => { 1 };
        ( $mode:ident, ? )     => { 1 };
        ( $mode:ident, -> )    => { 2 };
        ( $mode:ident, ; )     => { 1 };
        ( $mode:ident, << )    => { 2 };
        ( $mode:ident, <<= )   => { 3 };
        ( $mode:ident, >> )    => { 2 };
        ( $mode:ident, >>= )   => { 3 };
        ( $mode:ident, / )     => { 1 };
        ( $mode:ident, /= )    => { 2 };
        ( $mode:ident, * )     => { 1 };
        ( $mode:ident, *= )    => { 2 };
        ( $mode:ident, ~ )     => { 1 };
        ( lenient, $tt:tt )    => { 0 };
        ( strict, $tt:tt )     => {{ ::syntax::custom_punctuation_unexpected!( $tt ); 0 }};
    }
    
    #[macro_export] macro_rules! custom_punctuation_unexpected
    {
        () => {};
    }
    
    #[macro_export] macro_rules! stringify_punct
    {
        ( $( $tt:tt )+ ) => { ::syntax::__private::concat!( $( ::syntax::__private::stringify!( $tt ) ),+ ) };
    }

    #[macro_export] macro_rules! custom_keyword
    {
        ( $ident:ident ) => {
            #[allow( non_camel_case_types )]
            pub struct $ident {
                #[allow( dead_code )]
                pub span: ::syntax::__private::Span,
            }
                #[allow( dead_code, non_snake_case )]
            pub fn $ident<__S: ::syntax::__private::IntoSpans<::syntax::__private::Span>>( 
                span: __S,
            ) -> $ident {
                $ident {
                    span: ::syntax::__private::IntoSpans::into_spans( span ),
                }
            }
            const _: () = {
                impl ::syntax::__private::Default for $ident
                {
                    fn default() -> Self {
                        $ident {
                            span: ::syntax::__private::Span::call_site(),
                        }
                    }
                }
                ::syntax::impl_parse_for_custom_keyword!( $ident );
                ::syntax::impl_to_tokens_for_custom_keyword!( $ident );
                ::syntax::impl_clone_for_custom_keyword!( $ident );
                ::syntax::impl_extra_traits_for_custom_keyword!( $ident );
            };
        };
    }
    
    #[macro_export] macro_rules! impl_parse_for_custom_keyword
    {
        ( $ident:ident ) => {
           
            impl ::syntax::__private::CustomToken for $ident {
                fn peek( cursor: ::syntax::buffer::Cursor ) -> ::syntax::__private::bool {
                    if let ::syntax::__private::Some( ( ident, _rest ) ) = cursor.ident() {
                        ident == ::syntax::__private::stringify!( $ident )
                    } else {
                        false
                    }
                }
                fn display() -> &'static ::syntax::__private::str {
                    ::syntax::__private::concat!( "`", ::syntax::__private::stringify!( $ident ), "`" )
                }
            }
            
            impl ::syntax::parse::Parse for $ident
            {
                fn parse( input: ::syntax::parse::ParseStream ) -> ::syntax::parse::Result<$ident> {
                    input.step( |cursor| {
                        if let ::syntax::__private::Some( ( ident, rest ) ) = cursor.ident() {
                            if ident == ::syntax::__private::stringify!( $ident ) {
                                return ::syntax::__private::Ok( ( $ident { span: ident.span() }, rest ) );
                            }
                        }
                        ::syntax::__private::Err( cursor.error( ::syntax::__private::concat!( 
                            "expected `",
                            ::syntax::__private::stringify!( $ident ),
                            "`",
                        ) ) )
                    } )
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_to_tokens_for_custom_keyword
    {
        ( $ident:ident ) => {
            impl ::syntax::__private::ToTokens for $ident {
                fn to_tokens( &self, tokens:&mut ::syntax::__private::TokenStream2 ) {
                    let ident = ::syntax::Ident::new( ::syntax::__private::stringify!( $ident ), self.span );
                    ::syntax::__private::TokenStreamExt::append( tokens, ident );
                }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_clone_for_custom_keyword
    {
        ( $ident:ident ) => {
            impl ::syntax::__private::Copy for $ident {}
            #[allow( clippy::expl_impl_clone_on_copy )]
            impl ::syntax::__private::Clone for $ident {
                fn clone( &self ) -> Self { *self }
            }
        };
    }
    
    #[macro_export] macro_rules! impl_extra_traits_for_custom_keyword 
    {
        ( $ident:ident ) => {
            impl ::syntax::__private::Debug for $ident
            {
                fn fmt( &self, f:&mut ::syntax::__private::Formatter ) -> ::syntax::__private::FmtResult {
                    ::syntax::__private::Formatter::write_str( 
                        f,
                        ::syntax::__private::concat!( 
                            "Keyword [",
                            ::syntax::__private::stringify!( $ident ),
                            "]",
                        ),
                    )
                }
            }
            
            impl ::syntax::__private::Eq for $ident {}
            
            impl ::syntax::__private::PartialEq for $ident {
                fn eq( &self, _other:&Self ) -> ::syntax::__private::bool {
                    true
                }
            }
            
            impl ::syntax::__private::Hash for $ident {
                fn hash<__H: ::syntax::__private::Hasher>( &self, _state:&mut __H ) {}
            }
        };
    }

    #[macro_export] macro_rules! forward
    {
        ( $( Self :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )* )
            => {$( 
                #[inline] fn $method( self $( , $arg : $ty )* ) -> $ret {
                    Self::$method( self $( , $arg )* )
                }
            )*};
        ( $( $base:ident :: $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )* )
            => {$( 
                #[inline] fn $method( self $( , $arg : $ty )* ) -> $ret {
                    <Self as $base>::$method( self $( , $arg )* )
                }
            )*};
        ( $( $base:ident :: $method:ident ( $( $arg:ident : $ty:ty ),* ) -> $ret:ty ; )* )
            => {$( 
                #[inline] fn $method( $( $arg : $ty ),* ) -> $ret {
                    <Self as $base>::$method( $( $arg ),* )
                }
            )*};
        ( $( $imp:path as $method:ident ( self $( , $arg:ident : $ty:ty )* ) -> $ret:ty ; )* )
            => {$( 
                #[inline] fn $method( self $( , $arg : $ty )* ) -> $ret {
                    $imp( self $( , $arg )* )
                }
            )*};
    }

    #[macro_export] macro_rules! constant
    {
        ( $( $method:ident () -> $ret:expr ; )* )
            => {$( 
                #[inline] fn $method() -> Self {
                    $ret
                }
            )*};
    }
    
    #[macro_export] macro_rules! forward_ref_ref_binop
    {
        ( impl $imp:ident, $method:ident ) =>
        {
            impl<'a, 'b, T: Clone + Integer> $imp<&'b Ratio<T>> for &'a Ratio<T>
            {
                type Output = Ratio<T>;

                #[inline] fn $method( self, other:&'b Ratio<T> ) -> Ratio<T> { self.clone().$method( other.clone() ) }
            }
            
            impl<'a, 'b, T: Clone + Integer> $imp<&'b T> for &'a Ratio<T>
            {
                type Output = Ratio<T>;

                #[inline] fn $method( self, other:&'b T ) -> Ratio<T> { self.clone().$method( other.clone() ) }
            }
        };
    }

    #[macro_export] macro_rules! forward_ref_ref_binop_big
    {
        ( impl $imp:ident for $res:ty, $method:ident ) =>
        {
            impl $imp<&$res> for &$res
            {
                type Output = $res;
                #[inline] fn $method( self, other:&$res ) -> $res
                {
                    $imp::$method( self.clone(), other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_ref_val_binop
    {
        ( impl $imp:ident, $method:ident ) =>
        {
            impl<'a, T> $imp<Ratio<T>> for &'a Ratio<T> where
            T: Clone + Integer
            {
                type Output = Ratio<T>;
                #[inline] fn $method( self, other: Ratio<T> ) -> Ratio<T> { self.clone().$method( other ) }
            }
            
            impl<'a, T> $imp<T> for &'a Ratio<T> where
            T: Clone + Integer,
            {
                type Output = Ratio<T>;
                #[inline] fn $method( self, other: T ) -> Ratio<T> { self.clone().$method( other ) }
            }
        };
    }

    #[macro_export] macro_rules! forward_ref_val_binop_big
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                   
                    $imp::$method( self, &other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_val_ref_binop
    {
        ( impl $imp:ident, $method:ident ) => {
            impl<'a, T> $imp<&'a Ratio<T>> for Ratio<T> where
                T: Clone + Integer,
            {
                type Output = Ratio<T>;

                #[inline] fn $method( self, other:&Ratio<T> ) -> Ratio<T> { self.$method( other.clone() ) }
            }
            
            impl<'a, T> $imp<&'a T> for Ratio<T> where
                T: Clone + Integer,
            {
                type Output = Ratio<T>;

                #[inline] fn $method( self, other:&T ) -> Ratio<T> { self.$method( other.clone() ) }
            }
        };
    }

    
    #[macro_export] macro_rules! forward_val_ref_binop_big
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<&$res> for $res {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                   
                    $imp::$method( &self, other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_all_binop
    {
        ( impl $imp:ident, $method:ident ) =>
        {
            forward_ref_ref_binop!( impl $imp, $method );
            forward_ref_val_binop!( impl $imp, $method );
            forward_val_ref_binop!( impl $imp, $method );
        };
    }

    #[macro_export] macro_rules! cfg_32
    {
        ( $( $any:tt )+ ) => { #[cfg( not( target_pointer_width = "64" ) )] $( $any )+ }
    }

    #[macro_export] macro_rules! cfg_32_or_test 
    {
        ( $( $any:tt )+ ) => { #[cfg( any( not( target_pointer_width = "64" ), test ) )] $( $any )+ }
    }

    #[macro_export] macro_rules! cfg_64
    {
        ( $( $any:tt )+ ) => { #[cfg( target_pointer_width = "64" )] $( $any )+ }
    }

    #[macro_export] macro_rules! cfg_digit
    {
        ( $item32:item $item64:item ) => {
            cfg_32!( $item32 );
            cfg_64!( $item64 );
        };
    }

    #[macro_export] macro_rules! cfg_digit_expr
    {
        ( $expr32:expr, $expr64:expr ) => {
            cfg_32!( $expr32 );
            cfg_64!( $expr64 );
        };
    }

    #[macro_export] macro_rules! forward_val_val_binop
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for $res {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                   
                    $imp::$method( self, &other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_val_val_binop_commutative
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for $res {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                   
                    if self.capacity() >= other.capacity() {
                        $imp::$method( self, &other )
                    } else {
                        $imp::$method( other, &self )
                    }
                }
            }
        };
    }
    /*
     */

    #[macro_export] macro_rules! forward_ref_val_binop_commutative
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                   
                    $imp::$method( other, self )
                }
            }
        };
    }
    /*

     */

    #[macro_export] macro_rules! forward_ref_ref_binop_commutative
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<&$res> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                   
                    if self.len() >= other.len() {
                        $imp::$method( self.clone(), other )
                    } else {
                        $imp::$method( other.clone(), self )
                    }
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_val_assign
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            impl $imp<$res> for $res {
                #[inline] fn $method( &mut self, other: $res ) {
                    self.$method( &other );
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_val_assign_scalar
    {
        ( impl $imp:ident for $res:ty, $scalar:ty, $method:ident ) => {
            impl $imp<$res> for $scalar {
                #[inline] fn $method( &mut self, other: $res ) {
                    self.$method( &other );
                }
            }
        };
    }
    
    #[macro_export] macro_rules! forward_scalar_val_val_binop_commutative
    {
        ( impl $imp:ident < $scalar:ty > for $res:ty, $method:ident ) => {
            impl $imp<$res> for $scalar {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                    $imp::$method( other, self )
                }
            }
        };
    }
    
    #[macro_export] macro_rules! forward_scalar_val_val_binop_to_ref_val
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<$scalar> for $res {
                type Output = $res;

                #[inline] fn $method( self, other: $scalar ) -> $res {
                    $imp::$method( &self, other )
                }
            }
            
            impl $imp<$res> for $scalar {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                    $imp::$method( self, &other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_ref_ref_binop_to_ref_val
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<&$scalar> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other:&$scalar ) -> $res {
                    $imp::$method( self, *other )
                }
            }
            
            impl $imp<&$res> for &$scalar {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                    $imp::$method( *self, other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_val_ref_binop_to_ref_val 
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<&$scalar> for $res {
                type Output = $res;

                #[inline] fn $method( self, other:&$scalar ) -> $res {
                    $imp::$method( &self, *other )
                }
            }
            
            impl $imp<$res> for &$scalar {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                    $imp::$method( *self, &other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_val_ref_binop_to_val_val 
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<&$scalar> for $res {
                type Output = $res;

                #[inline] fn $method( self, other:&$scalar ) -> $res {
                    $imp::$method( self, *other )
                }
            }
            
            impl $imp<$res> for &$scalar {
                type Output = $res;

                #[inline] fn $method( self, other: $res ) -> $res {
                    $imp::$method( *self, other )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_ref_val_binop_to_val_val 
    {
        ( impl $imp:ident < $scalar:ty > for $res:ty, $method:ident ) => {
            impl $imp<$scalar> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other: $scalar ) -> $res {
                    $imp::$method( self.clone(), other )
                }
            }
            
            impl $imp<&$res> for $scalar {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                    $imp::$method( self, other.clone() )
                }
            }
        };
    }

    #[macro_export] macro_rules! forward_scalar_ref_ref_binop_to_val_val 
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            impl $imp<&$scalar> for &$res {
                type Output = $res;

                #[inline] fn $method( self, other:&$scalar ) -> $res {
                    $imp::$method( self.clone(), *other )
                }
            }
            
            impl $imp<&$res> for &$scalar {
                type Output = $res;

                #[inline] fn $method( self, other:&$res ) -> $res {
                    $imp::$method( *self, other.clone() )
                }
            }
        };
    }

    #[macro_export] macro_rules! promote_scalars 
    {
        ( impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),* ) => {
            $( 
                forward_all_scalar_binop_to_val_val!( impl $imp<$scalar> for $res, $method );

                impl $imp<$scalar> for $res {
                    type Output = $res;

                    #[allow( clippy::cast_lossless )]
                    #[inline] fn $method( self, other: $scalar ) -> $res {
                        $imp::$method( self, other as $promo )
                    }
                }
                impl $imp<$res> for $scalar {
                    type Output = $res;

                    #[allow( clippy::cast_lossless )]
                    #[inline] fn $method( self, other: $res ) -> $res {
                        $imp::$method( self as $promo, other )
                    }
                }
            )*
        }
    }

    #[macro_export] macro_rules! promote_scalars_assign 
    {
        ( impl $imp:ident<$promo:ty> for $res:ty, $method:ident, $( $scalar:ty ),* ) => {
            $( 
                impl $imp<$scalar> for $res {
                    #[allow( clippy::cast_lossless )]
                    #[inline] fn $method( &mut self, other: $scalar ) {
                        self.$method( other as $promo );
                    }
                }
            )*
        }
    }

    #[macro_export] macro_rules! promote_unsigned_scalars 
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_scalars!( impl $imp<u32> for $res, $method, u8, u16 );
            promote_scalars!( impl $imp<::num::big::UsizePromotion> for $res, $method, usize );
        }
    }

    #[macro_export] macro_rules! promote_unsigned_scalars_assign 
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_scalars_assign!( impl $imp<u32> for $res, $method, u8, u16 );
            promote_scalars_assign!( impl $imp<::num::big::UsizePromotion> for $res, $method, usize );
        }
    }

    #[macro_export] macro_rules! promote_signed_scalars 
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_scalars!( impl $imp<i32> for $res, $method, i8, i16 );
            promote_scalars!( impl $imp<::num::big::IsizePromotion> for $res, $method, isize );
        }
    }

    #[macro_export] macro_rules! promote_signed_scalars_assign 
    {
        ( impl $imp:ident for $res:ty, $method:ident ) =>
        {
            promote_scalars_assign!( impl $imp<i32> for $res, $method, i8, i16 );
            promote_scalars_assign!( impl $imp<::num::big::IsizePromotion> for $res, $method, isize );
        }
    }

    #[macro_export] macro_rules! forward_all_binop_to_ref_ref
    {
        ( impl $imp:ident for $res:ty, $method:ident ) =>
        {
            forward_val_val_binop!( impl $imp for $res, $method );
            forward_val_ref_binop_big!( impl $imp for $res, $method );
            forward_ref_val_binop_big!( impl $imp for $res, $method );
        };
    }
    
    #[macro_export] macro_rules! forward_all_binop_to_val_ref
    {
        ( impl $imp:ident for $res:ty, $method:ident ) =>
        {
            forward_val_val_binop!( impl $imp for $res, $method );
            forward_ref_val_binop!( impl $imp for $res, $method );
            forward_ref_ref_binop!( impl $imp for $res, $method );
        };
    }
    
    #[macro_export] macro_rules! forward_all_binop_to_val_ref_commutative
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            forward_val_val_binop_commutative!( impl $imp for $res, $method );
            forward_ref_val_binop_commutative!( impl $imp for $res, $method );
            forward_ref_ref_binop_commutative!( impl $imp for $res, $method );
        };
    }

    #[macro_export] macro_rules! forward_all_scalar_binop_to_ref_val
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            forward_scalar_val_val_binop_to_ref_val!( impl $imp<$scalar> for $res, $method );
            forward_scalar_val_ref_binop_to_ref_val!( impl $imp<$scalar> for $res, $method );
            forward_scalar_ref_ref_binop_to_ref_val!( impl $imp<$scalar> for $res, $method );
        }
    }

    #[macro_export] macro_rules! forward_all_scalar_binop_to_val_val
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            forward_scalar_val_ref_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
            forward_scalar_ref_val_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
            forward_scalar_ref_ref_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
        }
    }

    #[macro_export] macro_rules! forward_all_scalar_binop_to_val_val_commutative
    {
        ( impl $imp:ident<$scalar:ty> for $res:ty, $method:ident ) => {
            forward_scalar_val_val_binop_commutative!( impl $imp<$scalar> for $res, $method );
            forward_all_scalar_binop_to_val_val!( impl $imp<$scalar> for $res, $method );
        }
    }

    #[macro_export] macro_rules! promote_all_scalars
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_unsigned_scalars!( impl $imp for $res, $method );
            promote_signed_scalars!( impl $imp for $res, $method );
        }
    }

    #[macro_export] macro_rules! promote_all_scalars_assign
    {
        ( impl $imp:ident for $res:ty, $method:ident ) => {
            promote_unsigned_scalars_assign!( impl $imp for $res, $method );
            promote_signed_scalars_assign!( impl $imp for $res, $method );
        }
    }

    #[macro_export] macro_rules! impl_sum_iter_type
    {
        ( $res:ty ) => {
            impl<T> Sum<T> for $res
            where
                $res: Add<T, Output = $res>,
            {
                fn sum<I>( iter: I ) -> Self where I: Iterator<Item = T>,
                {
                    iter.fold( Self::ZERO, <$res>::add )
                }
            }
        };
    }

    #[macro_export] macro_rules! impl_product_iter_type
    {
        ( $res:ty ) => {
            impl<T> Product<T> for $res
            where
                $res: Mul<T, Output = $res>,
            {
                fn product<I>( iter: I ) -> Self where I: Iterator<Item = T>,
                {
                    iter.fold( One::one(), <$res>::mul )
                }
            }
        };
    }

    #[macro_export] macro_rules! map
    {
        { } => { ::collections::HashMap::new() };
        { $( $key:expr => $value:expr ),+ , } =>
        {
           
            map!{ $( $key => $value ),+ }
        };
        { $( $key:expr => $value:expr ),* } =>
        {
            {
                let mut _map = ::collections::HashMap::new();

                $( 
                    let _ = _map.insert( $key, $value );
                )*

                _map
            }
        }
    }

    #[macro_export] macro_rules! int 
    {
        ( $int:expr ) => {{
            use num_bigint::BigInt;

            let _b: BigInt = $int.into();
            _b
        }};
    }

    #[macro_export] macro_rules! frac 
    {
        ( $int1:expr, $int2:expr ) => {{
            ::num::rational::BigRational::new( $int1.into(), $int2.into() )
        }};
    }

    #[macro_export] macro_rules! arr 
    {
        [] => 
        {
            $crate::arrays::Arr::from_vec( vec![] ).unwrap()
        };

        [ $( $elem:expr ),+ , ] => 
        {
           
            try_arr![ $( $elem ),+ ].unwrap()
        };

        [ $( $elem:expr ),+ ] => 
        {
            try_arr![ $( $elem ),+ ].unwrap()
        };
    }

    #[macro_export] macro_rules! try_arr 
    {
        [ $( $elem:expr ),+ , ] => 
        {
           
            try_arr![ $( $elem ),+ ]
        };

        [ $( $elem:expr ),+ ] => 
        {{
                $crate::arrays::Arr::from_vec( vec![ $( $elem.into() ),+ ] )
        }};
    }

    #[macro_export] macro_rules! tup 
    {
        ( $( $elem:expr ),* , ) => { tup!( $( $elem ),* ) };
        ( $( $elem:expr ),* ) => {
            {
                $crate::tup::Tup::from_vec( vec![ $( $elem.into() ),+ ] )
            }
        };
    }

    #[macro_export] macro_rules! obj 
    {
        {} => { $crate::obj::Obj::from_map_unchecked( ::std::collections::HashMap::new() ) };
        { $( $field:expr => $inner:expr ),+ , } => { try_obj!{ $( $field => $inner ),+ }.unwrap() };
        { $( $field:expr => $inner:expr ),+ } => { try_obj!{ $( $field => $inner ),+ }.unwrap() };
    }

    #[macro_export] macro_rules! try_obj
    {
        { $( $field:expr => $inner:expr ),+ , } =>
        {
           
            try_obj!{ $( $field => $inner ),* };
        };
        
        { $( $field:expr => $inner:expr ),+ } =>
        {{
            use ::objects::Obj;
            let mut _map = ::collections::HashMap::new();
            let mut _parent:Option<::values::Value> = None;

            $( 
                if $field == "^" 
                {
                    _parent = Some( $inner.into() );
                } 
                
                else 
                {
                    _map.insert( $field.into(), $inner.into() );
                }
            )*

            match _parent 
            {
                Some( parent ) => match parent.get_obj() {
                    Ok( parent ) => Obj::from_map_with_parent( _map, parent ),
                    e @ Err( _ ) => e,
                }
                None => Obj::from_map( _map ),
            }
        }};
    }
    
    #[macro_export] macro_rules! forward_screen_buffer_methods
    {
        ( |$slf:ident| $field:expr ) =>
        {
            pub fn size( &self ) -> ::system::common::terminal::Size 
            {
                let $slf = self;
                $field.size()
            }

            pub fn cursor( &self ) -> ::system::common::terminal::Cursor 
            {
                let $slf = self;
                $field.cursor()
            }

            pub fn set_cursor( &self, pos: ::system::common::terminal::Cursor ) 
            {
                let $slf = self;
                $field.set_cursor( pos );
            }

            pub fn next_line( &self, column: usize ) 
            {
                let $slf = self;
                $field.next_line( column );
            }

            pub fn clear_screen( &self ) 
            {
                let $slf = self;
                $field.clear_screen();
            }

            pub fn clear_attributes( &self ) 
            {
                let $slf = self;
                $field.clear_attributes();
            }

            pub fn add_style( &self, style: ::system::common::terminal::Style ) 
            {
                let $slf = self;
                $field.add_style( style );
            }

            pub fn remove_style( &self, style: ::system::common::terminal::Style ) 
            {
                let $slf = self;
                $field.remove_style( style );
            }

            pub fn set_style( &self, style: ::system::common::terminal::Style ) 
            {
                let $slf = self;
                $field.set_style( style );
            }

            pub fn set_fg( &self, fg:Option<::system::common::terminal::Color> ) 
            {
                let $slf = self;
                $field.set_fg( fg );
            }

            pub fn set_bg( &self, bg:Option<::system::common::terminal::Color> ) 
            {
                let $slf = self;
                $field.set_bg( bg );
            }

            pub fn set_theme( &self, theme: ::system::common::terminal::Theme ) 
            {
                let $slf = self;
                $field.set_theme( theme )
            }

            pub fn write_char( &self, ch:char ) 
            {
                let $slf = self;
                let _ = $field.write_char( ch );
            }

            pub fn write_str( &self, s:&str ) 
            {
                let $slf = self;
                let _ = $field.write_str( s  );
            }

            pub fn write_at( &self, pos: ::system::common::terminal::Cursor, text:&str ) 
            {
                let $slf = self;
                let _ = $field.write_at( pos, text );
            }

            pub fn write_styled
            ( 
                &self,
                fg:Option<::system::common::terminal::Color>,
                bg:Option<::system::common::terminal::Color>,
                style: ::system::common::terminal::Style,
                text:&str
            )
            {
                let $slf = self;
                let _ = $field.write_styled( fg, bg, style, text );
            }

            pub fn write_styled_at( &self, pos: ::system::common::terminal::Cursor,
                    fg:Option<::system::common::terminal::Color>, bg:Option<::system::common::terminal::Color>,
                    style: ::system::common::terminal::Style, text:&str ) {
                let $slf = self;
                let _ = $field.write_styled_at( pos, fg, bg, style, text );
            }
        }
    }
    
    #[macro_export] macro_rules! forward_screen_buffer_mut_methods 
    {
        ( |$slf:ident| $field:expr ) => {
            pub fn size( &self ) -> ::system::common::terminal::Size {
                let $slf = self;
                $field.size()
            }

            pub fn cursor( &self ) -> ::system::common::terminal::Cursor {
                let $slf = self;
                $field.cursor()
            }

            pub fn set_cursor( &mut self, pos: ::system::common::terminal::Cursor ) {
                let $slf = self;
                $field.set_cursor( pos );
            }

            pub fn next_line( &mut self, column: usize ) {
                let $slf = self;
                $field.next_line( column );
            }

            pub fn clear_screen( &mut self ) {
                let $slf = self;
                $field.clear_screen();
            }

            pub fn clear_attributes( &mut self ) {
                let $slf = self;
                $field.clear_attributes();
            }

            pub fn add_style( &mut self, style: ::system::common::terminal::Style ) {
                let $slf = self;
                $field.add_style( style );
            }

            pub fn remove_style( &mut self, style: ::system::common::terminal::Style ) {
                let $slf = self;
                $field.remove_style( style );
            }

            pub fn set_style( &mut self, style: ::system::common::terminal::Style ) {
                let $slf = self;
                $field.set_style( style );
            }

            pub fn set_fg( &mut self, fg:Option<::system::common::terminal::Color> ) {
                let $slf = self;
                $field.set_fg( fg );
            }

            pub fn set_bg( &mut self, bg:Option<::system::common::terminal::Color> ) {
                let $slf = self;
                $field.set_bg( bg );
            }

            pub fn set_theme( &mut self, theme: ::system::common::terminal::Theme )
            {
                let $slf = self;
                $field.set_theme( theme );
            }

            pub fn write_char( &mut self, ch:char )
            {
                let $slf = self;
                let _ = $field.write_char( ch );
            }

            pub fn write_str( &mut self, s:&str ) 
            {
                let $slf = self;
                let _ = $field.write_str( s  );
            }

            pub fn write_at( &mut self, pos: ::system::common::terminal::Cursor, text:&str )
            {
                let $slf = self;
                let _ = $field.write_at( pos, text );
            }

            pub fn write_styled
            ( 
                &mut self,
                fg:Option<::system::common::terminal::Color>, 
                bg:Option<::system::common::terminal::Color>,
                style: ::system::common::terminal::Style,
                text:&str
            ) 
            {
                let $slf = self;
                let _ = $field.write_styled( fg, bg, style, text );
            }

            pub fn write_styled_at( &mut self, pos: ::system::common::terminal::Cursor,
                    fg:Option<::system::common::terminal::Color>, 
                    bg:Option<::system::common::terminal::Color>,
                    style: ::system::common::terminal::Style, text:&str ) {
                let $slf = self;
                let _ = $field.write_styled_at( pos, fg, bg, style, text );
            }
        }
    }
    
    #[macro_export] macro_rules! libc_bitflags
    {
        ( 
            $( #[$outer:meta] )*
            pub struct $BitFlags:ident: $T:ty {
                $( 
                    $( #[$inner:ident $( $args:tt )*] )*
                    $Flag:ident $( as $cast:ty )*;
                )+
            }
        ) =>
        {
            bitflags!
            {
                #[derive( Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
                #[repr( transparent )]
                $( #[$outer] )*
                pub struct $BitFlags: $T {
                    $( 
                        $( #[$inner $( $args )*] )*
                        const $Flag = $Flag $( as $cast )*;
                    )+
                }
            }
        };
    }

    #[macro_export] macro_rules! libc_enum
    {
        ( @make_enum
            name: $BitFlags:ident,
            {
                $v:vis
                attrs: [$( $attrs:tt )*],
                entries: [$( $entries:tt )*],
            }
        ) =>
        {
            $( $attrs )*
            #[derive( Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
            $v enum $BitFlags
            {
                $( $entries )*
            }
        };
        
        ( @make_enum
            name: $BitFlags:ident,
            {
                $v:vis
                attrs: [$( $attrs:tt )*],
                entries: [$( $entries:tt )*],
                from_type: $repr:path,
                try_froms: [$( $try_froms:tt )*]
            }
        ) =>
        {
            $( $attrs )*
            #[derive( Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
            $v enum $BitFlags
            {
                $( $entries )*
            }

            impl ::convert::TryFrom<$repr> for $BitFlags
            {
                type Error = ::system::api::Error;
                fn try_from( x: $repr ) -> ::system::api::Result<Self>
                {
                    match x
                    {
                        $( $try_froms )*
                        _ => Err( ::system::api::Error::EINVAL )
                    }
                }
            }
        };
        ( @accumulate_entries
            name: $BitFlags:ident,
            {
                $v:vis
                attrs: $attrs:tt,
            },
            $entries:tt,
            $try_froms:tt;
        ) => {
            libc_enum! {
                @make_enum
                name: $BitFlags,
                {
                    $v
                    attrs: $attrs,
                    entries: $entries,
                }
            }
        };
        ( @accumulate_entries
            name: $BitFlags:ident,
            {
                $v:vis
                attrs: $attrs:tt,
                from_type: $repr:path,
            },
            $entries:tt,
            $try_froms:tt;
        ) => {
            libc_enum! {
                @make_enum
                name: $BitFlags,
                {
                    $v
                    attrs: $attrs,
                    entries: $entries,
                    from_type: $repr,
                    try_froms: $try_froms
                }
            }
        };
        ( @accumulate_entries
            name: $BitFlags:ident,
            $prefix:tt,
            [$( $entries:tt )*],
            [$( $try_froms:tt )*];
            #[$attr:meta] $( $tail:tt )*
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                $prefix,
                [
                    $( $entries )*
                    #[$attr]
                ],
                [
                    $( $try_froms )*
                ];
                $( $tail )*
            }
        };
        ( @accumulate_entries
            name: $BitFlags:ident,
            $prefix:tt,
            [$( $entries:tt )*],
            [$( $try_froms:tt )*];
            $entry:ident
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                $prefix,
                [
                    $( $entries )*
                    $entry = $entry,
                ],
                [
                    $( $try_froms )*
                    $entry => Ok( $BitFlags::$entry ),
                ];
            }
        };
        ( @accumulate_entries
            name: $BitFlags:ident,
            $prefix:tt,
            [$( $entries:tt )*],
            [$( $try_froms:tt )*];
            $entry:ident,
            $( $tail:tt )*
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                $prefix,
                [
                    $( $entries )*
                    $entry = $entry,
                ],
                [
                    $( $try_froms )*
                    $entry => Ok( $BitFlags::$entry ),
                ];
                $( $tail )*
            }
        };
        ( @accumulate_entries
            name: $BitFlags:ident,
            $prefix:tt,
            [$( $entries:tt )*],
            [$( $try_froms:tt )*];
            $entry:ident as $ty:ty,
            $( $tail:tt )*
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                $prefix,
                [
                    $( $entries )*
                    $entry = $entry as $ty,
                ],
                [
                    $( $try_froms )*
                    $entry as $ty => Ok( $BitFlags::$entry ),
                ];
                $( $tail )*
            }
        };
        ( 
            $( #[$attr:meta] )*
            $v:vis enum $BitFlags:ident {
                $( $vals:tt )*
            }
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                {
                    $v
                    attrs: [$( #[$attr] )*],
                },
                [],
                [];
                $( $vals )*
            }
        };
        ( 
            $( #[$attr:meta] )*
            $v:vis enum $BitFlags:ident {
                $( $vals:tt )*
            }
            
            impl TryFrom<$repr:path>
        ) => {
            libc_enum! {
                @accumulate_entries
                name: $BitFlags,
                {
                    $v
                    attrs: [$( #[$attr] )*],
                    from_type: $repr,
                },
                [],
                [];
                $( $vals )*
            }
        };
    }

    #[macro_export] macro_rules! cfg_if
    {
        ( $( 
            if #[cfg( $( $meta:meta ),* )] { $( $it:item )* }
        ) else * else {
            $( $it2:item )*
        } ) =>
        {
            cfg_if!
            {
                @__items
                () ;
                $( ( ( $( $meta ),* ) ( $( $it )* ) ), )*
                ( () ( $( $it2 )* ) ),
            }
        };
        
        ( 
            if #[cfg( $( $i_met:meta ),* )] { $( $i_it:item )* }
            $( 
                else if #[cfg( $( $e_met:meta ),* )] { $( $e_it:item )* }
            )*
        ) =>
        {
            cfg_if!
            {
                @__items
                () ;
                ( ( $( $i_met ),* ) ( $( $i_it )* ) ),
                $( ( ( $( $e_met ),* ) ( $( $e_it )* ) ), )*
                ( () () ),
            }
        };
        
        ( @__items ( $( $not:meta, )* ) ; ) => {};
        ( @__items ( $( $not:meta, )* ) ; ( ( $( $m:meta ),* ) ( $( $it:item )* ) ), $( $rest:tt )* ) =>
        {
            cfg_if! { @__apply cfg( all( $( $m, )* not( any( $( $not ),* ) ) ) ), $( $it )* }            
            cfg_if! { @__items ( $( $not, )* $( $m, )* ) ; $( $rest )* }
        };
        
        ( @__apply $m:meta, $( $it:item )* ) => { $( #[$m] $it )* };
    }

    #[macro_export] macro_rules! println_stderr
    {
        ( $fmt:expr ) => 
        ( 
            use io::Write;
            match writeln!( &mut ::io::stderr(), $fmt )
            {
                Ok( _ ) => {}
                Err( e ) => println!( "write to stderr failed: {:?}", e )
            }
         );

        ( $fmt:expr, $( $arg:tt )* ) =>
        ( 
            match writeln!( &mut ::io::stderr(), $fmt, $( $arg )* )
            {
                Ok( _ ) => {}
                Err( e ) => println!( "write to stderr failed: {:?}", e )
            }
         );
    }

    #[macro_export] macro_rules! define_uuid_macro
    {
        {$(#[$doc:meta] )*} =>
        {
            #[macro_export] macro_rules! uuid
            {
                ( $uuid:expr ) => 
                {{
                    const OUTPUT: $crate::Uuid = match $crate::Uuid::try_parse( $uuid )
                    {
                        Ok(u ) => u,
                        Err(_ ) => panic!( "invalid UUID" ),
                    };

                    OUTPUT
                }};
            }
        }
    }

    define_uuid_macro!
    {

    }

    #[macro_export] macro_rules! unsafe_transmute_ref
    (
        ( $e:expr ) => { unsafe { ::mem::transmute::<&_, &_>( $e ) } }
    );

    #[macro_export] macro_rules! unsafe_transmute
    (
        ( $e:expr ) => { unsafe { ::mem::transmute::<_, _>( $e ) } }
    );

    #[allow(dead_code )]
    pub struct Lazy<T: Sync>( Cell<MaybeUninit<T>>, Once );

    impl<T: Sync> Lazy<T>
    {
        #[allow(deprecated )]
        pub const INIT: Self = Lazy( Cell::new(MaybeUninit::uninit() ), ONCE_INIT );

        #[inline( always )] pub fn get<F>( &'static self, f: F) -> &T where
        F:FnOnce() -> T
        {
            unsafe
            { 
                self.1.call_once(|| { self.0.set(MaybeUninit::new( f() ) ); });
                &*(*self.0.as_ptr() ).as_ptr()
            }
        }
    }

    unsafe impl<T: Sync> Sync for Lazy<T> {}

    #[macro_export] macro_rules! __lazy_static_create
    {
        ( $NAME:ident, $T:ty) => { static $NAME: ::macros::Lazy<$T> = ::macros::Lazy::INIT; };
    }

    #[macro_export( local_inner_macros )] macro_rules! __lazy_static_internal
    {
        ( $(#[$attr:meta])* ( $( $vis:tt )*) static ref $N:ident : $T:ty = $e:expr; $( $t:tt )*) =>
        {
            __lazy_static_internal!(@MAKE TY, $(#[$attr])*, ( $( $vis )*), $N);
            __lazy_static_internal!(@TAIL, $N : $T = $e );
            lazy_static!( $( $t )*);
        };
        
        (@TAIL, $N:ident : $T:ty = $e:expr ) =>
        {
            impl ::ops::Deref for $N
            {
                type Target = $T;
                fn deref( &self ) -> &$T
                {
                    #[inline( always )] fn __static_ref_initialize() -> $T { $e }

                    #[inline( always )] fn __stability() -> &'static $T
                    {
                        __lazy_static_create!(LAZY, $T );
                        LAZY.get(__static_ref_initialize )
                    }
                    __stability()
                }
            }

            impl ::macros::LazyStatic for $N
            {
                fn initialize(lazy: &Self) { let _ = &**lazy; }
            }
        };
        
        (@MAKE TY, $(#[$attr:meta])*, ( $( $vis:tt )*), $N:ident ) =>
        {
            $(#[$attr])*
            $( $vis )* struct $N {__private_field: ()}
            $( $vis )* static $N: $N = $N {__private_field: ()};
        };
        () => ()
    }

    #[macro_export(local_inner_macros )]
    macro_rules! lazy_static
    {
        ( $(#[$attr:meta])* static ref $N:ident : $T:ty = $e:expr; $( $t:tt )*) =>
        {
            __lazy_static_internal!( $(#[$attr])* () static ref $N : $T = $e; $( $t )*);
        };

        ( $(#[$attr:meta])* pub static ref $N:ident : $T:ty = $e:expr; $( $t:tt )*) =>
        {
            __lazy_static_internal!( $(#[$attr])* ( pub) static ref $N : $T = $e; $( $t )*);
        };

        ( $(#[$attr:meta])* pub ( $( $vis:tt )+) static ref $N:ident : $T:ty = $e:expr; $( $t:tt )*) =>
        {
            __lazy_static_internal!( $(#[$attr])* ( pub ( $( $vis )+ ) ) static ref $N : $T = $e; $( $t )*);
        };

        () => ()
    }

    pub trait LazyStatic
    {
        fn initialize(lazy: &Self);
    }

    pub fn initialize<T: LazyStatic>( lazy: &T )
    {
        LazyStatic::initialize(lazy);
    }
    
    #[macro_export] macro_rules! bitflags
    {
        (
            $(#[$outer:meta])*
            $vis:vis struct $BitFlags:ident: $T:ty
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }

            $( $t:tt )*
        ) =>
        {
            ::__declare_public_bitflags!
            {
                $(#[$outer])*
                $vis struct $BitFlags
            }
            
            ::__impl_public_bitflags_consts!
            {
                $BitFlags: $T
                {
                    $(
                        $(#[$inner $( $args )*])*
                        const $Flag = $value;
                    )*
                }
            }
            
            const _: () = 
            {
                ::__declare_internal_bitflags! { $vis struct InternalBitFlags: $T }

                ::__impl_internal_bitflags!
                {
                    InternalBitFlags: $T, $BitFlags 
                    {
                        $(
                            $(#[$inner $( $args )*])*
                            const $Flag = $value;
                        )*
                    }
                }

                ::__impl_public_bitflags_forward! { $BitFlags: $T, InternalBitFlags }

                ::__impl_public_bitflags_ops! { $BitFlags }

                ::__impl_public_bitflags_iter! { $BitFlags: $T, $BitFlags }
            };

            ::bitflags! { $( $t )* }
        };

        (
            $(#[$outer:meta])*
            impl $BitFlags:ident: $T:ty
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }

            $( $t:tt )*
        ) =>
        {
            ::__impl_public_bitflags_consts!
            {
                $BitFlags: $T
                {
                    $(
                        $(#[$inner $( $args )*])*
                        const $Flag = $value;
                    )*
                }
            }
            
            const _: () =
            {
                ::__impl_public_bitflags!
                {
                    $(#[$outer])*
                    $BitFlags: $T, $BitFlags
                    {
                        $(
                            $(#[$inner $( $args )*])*
                            const $Flag = $value;
                        )*
                    }
                }

                ::__impl_public_bitflags_ops! { $BitFlags }

                ::__impl_public_bitflags_iter! { $BitFlags: $T, $BitFlags }
            };

            ::bitflags! { $( $t )* }
        };

        () => {};
    }

    #[macro_export] macro_rules! __impl_bitflags
    {
        (
            params: $self:ident, $bits:ident, $name:ident, $other:ident, $value:ident;
            $(#[$outer:meta])*
            $PublicBitFlags:ident: $T:ty 
            {
                fn empty() $empty_body:block
                fn all() $all_body:block
                fn bits( &self ) $bits_body:block
                fn from_bits( bits ) $from_bits_body:block
                fn from_bits_truncate( bits ) $from_bits_truncate_body:block
                fn from_bits_retain( bits ) $from_bits_retain_body:block
                fn from_name(name) $from_name_body:block
                fn is_empty( &self ) $is_empty_body:block
                fn is_all( &self ) $is_all_body:block
                fn intersects(&self, other) $intersects_body:block
                fn contains(&self, other) $contains_body:block
                fn insert( &mut self, other) $insert_body:block
                fn remove( &mut self, other) $remove_body:block
                fn toggle( &mut self, other) $toggle_body:block
                fn set( &mut self, other, value) $set_body:block
                fn intersection(self, other) $intersection_body:block
                fn union(self, other) $union_body:block
                fn difference(self, other) $difference_body:block
                fn symmetric_difference(self, other) $symmetric_difference_body:block
                fn complement(self) $complement_body:block
            }
        ) => 
        {
            #[allow(dead_code, deprecated, unused_attributes )]
            $(#[$outer])*
            impl $PublicBitFlags 
            {

                #[inline] pub const fn empty() -> Self
                    $empty_body


                #[inline] pub const fn all() -> Self
                    $all_body


                ///

                #[inline] pub const fn bits(&$self) -> $T
                    $bits_body


                ///

                #[inline] pub const fn from_bits( $bits: $T ) -> ::option::Option<Self>
                    $from_bits_body


                #[inline] pub const fn from_bits_truncate( $bits: $T ) -> Self
                    $from_bits_truncate_body


                #[inline] pub const fn from_bits_retain( $bits: $T ) -> Self
                    $from_bits_retain_body


                #[inline] pub fn from_name( $name: &str) -> ::option::Option<Self>
                    $from_name_body


                #[inline] pub const fn is_empty(&$self) -> bool
                    $is_empty_body


                #[inline] pub const fn is_all(&$self) -> bool
                    $is_all_body


                #[inline] pub const fn intersects(&$self, $other: Self) -> bool
                    $intersects_body


                #[inline] pub const fn contains(&$self, $other: Self) -> bool
                    $contains_body


                #[inline] pub fn insert(&mut $self, $other: Self)
                    $insert_body
                #[inline] pub fn remove(&mut $self, $other: Self)
                    $remove_body


                #[inline] pub fn toggle(&mut $self, $other: Self)
                    $toggle_body


                #[inline] pub fn set(&mut $self, $other: Self, $value:bool )
                    $set_body


                #[inline]
                #[must_use]
                pub const fn intersection( $self, $other: Self) -> Self
                    $intersection_body


                #[inline]
                #[must_use]
                pub const fn union( $self, $other: Self) -> Self
                    $union_body
                #[inline]
                #[must_use]
                pub const fn difference( $self, $other: Self) -> Self
                    $difference_body


                #[inline]
                #[must_use]
                pub const fn symmetric_difference( $self, $other: Self) -> Self
                    $symmetric_difference_body


                #[inline]
                #[must_use]
                pub const fn complement( $self) -> Self
                    $complement_body
            }
        };
    }

    #[macro_export] macro_rules! bitflags_match 
    {
        ( $operation:expr, { $( $t:tt )* }) =>
        {
            (|| { ::__bitflags_match!( $operation, { $( $t )* }) })()
        };
    }

    #[macro_export] macro_rules! __bitflags_match
    {
        ( $operation:expr, { $pattern:expr => { $( $body:tt )* } , $( $t:tt )+ }) =>
        { ::__bitflags_match!( $operation, { $pattern => { $( $body)* } $( $t )+ }) };
        
        ( $operation:expr, { $pattern:expr => { $( $body:tt )* } $( $t:tt )+ }) => 
        {
            {
                if $operation == $pattern
                {
                    return
                    {
                        $( $body)*
                    }; 
                }

                ::__bitflags_match!( $operation, { $( $t )+ })
            }
        };
        
        ( $operation:expr, { $pattern:expr => $body:expr , $( $t:tt )+ }) =>
        {
            {
                if $operation == $pattern { return $body; }

                ::__bitflags_match!( $operation, { $( $t )+ })
            }
        };
        
        ( $operation:expr, { _ => $default:expr $(,)? }) => { $default }
    }

    #[macro_export] macro_rules! __bitflags_expr_safe_attrs 
    {
        (
            $(#[$inner:ident $( $args:tt )*])*
            { $e:expr }
        ) => 
        {
            ::__bitflags_expr_safe_attrs! 
            {
                expr: { $e },
                attrs: 
                {
                    unprocessed: [$(#[$inner $( $args )*])*],
                    processed: [],
                },
            }
        };
        
        (
            expr:{ $e:expr },
            attrs:
            {
                unprocessed:
                [
                    #[cfg $( $args:tt )*]
                    $( $attrs_rest:tt )*
                ],
                processed: [$( $expr:tt )*],
            },
        ) =>
        {
            ::__bitflags_expr_safe_attrs!
            {
                expr: { $e },
                attrs:
                {
                    unprocessed:
                    [
                        $( $attrs_rest )*
                    ],
                    processed:
                    [
                        $( $expr)*
                        #[cfg $( $args )*]
                    ],
                },
            }
        };
        
        (
            expr: { $e:expr },
            attrs:
            {
                unprocessed:
                [
                    #[$other:ident $( $args:tt )*]
                    $( $attrs_rest:tt )*
                ],
                processed: [$( $expr:tt )*],
            },
        ) =>
        {
            ::__bitflags_expr_safe_attrs! 
            {
                expr:{ $e },
                attrs:
                {
                    unprocessed:
                    [
                        $( $attrs_rest )*
                    ],
                    processed:
                    [
                        $( $expr)*
                    ],
                },
            }
        };
        
        (
            expr:{ $e:expr },
            attrs:
            {
                unprocessed: [],
                processed: [$(#[$expr:ident $( $exprargs:tt )*])*],
            },
        ) =>
        {
            $(#[$expr $( $exprargs )*])*
            { $e }
        }
    }

    #[macro_export] macro_rules! __bitflags_flag
    {
        (
            {
                name: _,
                named: { $( $named:tt )* },
                unnamed: { $( $unnamed:tt )* },
            }
        ) =>
        { $( $unnamed)* };

        (
            {
                name: $Flag:ident,
                named: { $( $named:tt )* },
                unnamed: { $( $unnamed:tt )* },
            }
        ) => { $( $named)* };
    }

    #[macro_export] macro_rules! __declare_public_bitflags
    {
        (
            $(#[$outer:meta])*
            $vis:vis struct $PublicBitFlags:ident
        ) => {
            $(#[$outer])*
            $vis struct $PublicBitFlags(<$PublicBitFlags as ::bits::flags::PublicFlags>::Internal);
        };
    }

    #[macro_export] macro_rules! __impl_public_bitflags_forward 
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident
        ) => 
        {
            __impl_bitflags! 
            {
                params: self, bits, name, other, value;
                $(#[$outer])*
                $PublicBitFlags: $T
               
                {
                    fn empty() { Self( $InternalBitFlags::empty()) }
                    fn all() { Self( $InternalBitFlags::all()) }
                    fn bits( &self ) { self.0.bits() }
                    fn from_bits( bits )
                    {
                        match $InternalBitFlags::from_bits( bits )
                        {
                            Some( bits ) => Some(Self( bits )),
                            None => None,
                        }
                    }
                    fn from_bits_truncate( bits ) { Self( $InternalBitFlags::from_bits_truncate( bits )) }
                    fn from_bits_retain( bits ) { Self( $InternalBitFlags::from_bits_retain( bits )) }
                    fn from_name(name)
                    {
                        match $InternalBitFlags::from_name(name)
                        {
                            Some( bits ) => Some(Self( bits )),
                            None =>None,
                        }
                    }
                    fn is_empty( &self ) { self.0.is_empty() }
                    fn is_all( &self ) { self.0.is_all() }
                    fn intersects(&self, other) { self.0.intersects(other.0) }
                    fn contains(&self, other) { self.0.contains(other.0) }
                    fn insert( &mut self, other) { self.0.insert(other.0) }
                    fn remove( &mut self, other) { self.0.remove(other.0) }
                    fn toggle( &mut self, other) { self.0.toggle(other.0) }
                    fn set( &mut self, other, value) { self.0.set(other.0, value) }
                    fn intersection(self, other) { Self( self.0.intersection(other.0)) }
                    fn union(self, other) { Self( self.0.union(other.0)) }
                    fn difference(self, other) { Self( self.0.difference(other.0)) }
                    fn symmetric_difference(self, other) { Self( self.0.symmetric_difference(other.0)) }
                    fn complement(self) { Self( self.0.complement()) }
                }
            }
        };
    }

    #[macro_export] macro_rules! __impl_public_bitflags 
    {
        (
            $(#[$outer:meta])*
            $BitFlags:ident: $T:ty, $PublicBitFlags:ident 
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }
        ) => 
        {
            __impl_bitflags! 
            {
                params: self, bits, name, other, value;
                $(#[$outer])*
                $BitFlags: $T 
               
                {
                    fn empty() { Self(<$T as ::bits::flags::Bits>::EMPTY) }
                    fn all() 
                    {
                        let mut truncated = <$T as ::bits::flags::Bits>::EMPTY;
                        let mut i = 0;

                        $(
                            __bitflags_expr_safe_attrs!
                            (
                                $(#[$inner $( $args )*])*
                                {{
                                    let flag = <$PublicBitFlags as ::bits::flags::Flags>::FLAGS[i].value().bits();
                                    truncated = truncated | flag;
                                    i += 1;
                                }}
                            );
                        )*

                        let _ = i;
                        Self( truncated)
                    }
                    fn bits( &self ) { self.0 }
                    fn from_bits( bits )
                    {
                        let truncated = Self::from_bits_truncate( bits ).0;
                        if truncated == bits { Some(Self( bits )) } else { None }
                    }
                    fn from_bits_truncate( bits ) { Self( bits & Self::all().0) }
                    fn from_bits_retain( bits ) { Self( bits ) }
                    fn from_name(name)
                    {
                        $(
                            __bitflags_flag!
                            ({
                                name: $Flag,
                                named: 
                                {
                                    __bitflags_expr_safe_attrs!
                                    (
                                        $(#[$inner $( $args )*])*
                                        {
                                            if name == stringify!( $Flag) 
                                            { return Some(Self( $PublicBitFlags::$Flag.bits())); }
                                        }
                                    );
                                },
                                unnamed: {},
                            });
                        )*

                        let _ = name;
                        None
                    }
                    fn is_empty( &self ) { self.0 == <$T as ::bits::flags::Bits>::EMPTY }
                    fn is_all( &self ) { Self::all().0 | self.0 == self.0 }
                    fn intersects(&self, other) { self.0 & other.0 != <$T as ::bits::flags::Bits>::EMPTY }
                    fn contains(&self, other) { self.0 & other.0 == other.0 }
                    fn insert( &mut self, other) { *self = Self( self.0).union( other ); }
                    fn remove( &mut self, other) { *self = Self( self.0).difference( other ); }
                    fn toggle( &mut self, other) { *self = Self( self.0).symmetric_difference( other ); }
                    fn set( &mut self, other, value)
                    {
                        if value { self.insert( other ); }
                        else { self.remove( other ); }
                    }
                    fn intersection(self, other) { Self( self.0 & other.0) }
                    fn union(self, other) { Self( self.0 | other.0) }
                    fn difference(self, other) { Self( self.0 & !other.0) }
                    fn symmetric_difference(self, other) { Self( self.0 ^ other.0) }
                    fn complement(self) { Self::from_bits_truncate(!self.0) }
                }
            }
        };
    }

    #[macro_export] macro_rules! __impl_public_bitflags_iter
    {
        (
            $(#[$outer:meta])*
            $BitFlags:ident: $T:ty, $PublicBitFlags:ident
        ) =>
        {
            $(#[$outer])*
            impl $BitFlags
            {

                #[inline] pub const fn iter( &self ) -> ::bits::flags::iter::Iter<$PublicBitFlags>
                {
                    ::bits::flags::iter::Iter::__private_const_new
                    (
                        <$PublicBitFlags as ::bits::flags::Flags>::FLAGS,
                        $PublicBitFlags::from_bits_retain( self.bits()),
                        $PublicBitFlags::from_bits_retain( self.bits()),
                    )
                }

                #[inline] pub const fn iter_names( &self ) -> ::bits::flags::iter::IterNames<$PublicBitFlags>
                {
                    ::bits::flags::iter::IterNames::__private_const_new
                    (
                        <$PublicBitFlags as ::bits::flags::Flags>::FLAGS,
                        $PublicBitFlags::from_bits_retain( self.bits()),
                        $PublicBitFlags::from_bits_retain( self.bits()),
                    )
                }
            }

            $(#[$outer:meta])*
            impl ::iter::IntoIterator for $BitFlags
            {
                type Item = $PublicBitFlags;
                type IntoIter = ::bits::flags::iter::Iter<$PublicBitFlags>;
                fn into_iter(self) -> Self::IntoIter { self.iter() }
            }
        };
    }

    #[macro_export] macro_rules! __impl_public_bitflags_ops
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident
        ) =>
        {
            $(#[$outer])*
            impl ::fmt::Binary for $PublicBitFlags
            {
                fn fmt
                (
                    &self,
                    f: &mut ::fmt::Formatter
                ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::Binary::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::fmt::Octal for $PublicBitFlags
            {
                fn fmt
                (
                    &self,
                    f: &mut ::fmt::Formatter
                ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::Octal::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::fmt::LowerHex for $PublicBitFlags
            {
                fn fmt
                (
                    &self,
                    f: &mut ::fmt::Formatter
                ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::LowerHex::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::fmt::UpperHex for $PublicBitFlags 
           
            {
                fn fmt( &self, f: &mut ::fmt::Formatter ) -> ::fmt::Result
                {
                    let inner = self.0;
                    ::fmt::UpperHex::fmt(&inner, f)
                }
            }

            $(#[$outer])*
            impl ::ops::BitOr for $PublicBitFlags
            {
                type Output = Self;

                #[inline] fn bitor(self, other: $PublicBitFlags ) -> Self { self.union( other ) }
            }

            $(#[$outer])*
            impl ::ops::BitOrAssign for $PublicBitFlags
            {

                #[inline] fn bitor_assign( &mut self, other: Self) { self.insert( other ); }
            }

            $(#[$outer])*
            impl ::ops::BitXor for $PublicBitFlags
            {
                type Output = Self;

                #[inline] fn bitxor(self, other: Self) -> Self { self.symmetric_difference( other ) }
            }

            $(#[$outer])*
            impl ::ops::BitXorAssign for $PublicBitFlags
            {

                #[inline] fn bitxor_assign( &mut self, other: Self) { self.toggle( other ); }
            }

            $(#[$outer])*
            impl ::ops::BitAnd for $PublicBitFlags
            {
                type Output = Self;

                #[inline] fn bitand(self, other: Self) -> Self { self.intersection( other ) }
            }

            $(#[$outer])*
            impl ::ops::BitAndAssign for $PublicBitFlags
            {

                #[inline] fn bitand_assign( &mut self, other: Self)
                { *self = Self::from_bits_retain( self.bits()).intersection( other ); }
            }

            $(#[$outer])*
            impl ::ops::Sub for $PublicBitFlags
            {
                type Output = Self;

                #[inline] fn sub(self, other: Self) -> Self { self.difference( other ) }
            }

            $(#[$outer])*
            impl ::ops::SubAssign for $PublicBitFlags
            {

                #[inline] fn sub_assign( &mut self, other: Self) { self.remove( other ); }
            }

            $(#[$outer])*
            impl ::ops::Not for $PublicBitFlags
            {
                type Output = Self;

                #[inline] fn not(self) -> Self { self.complement() }
            }

            $(#[$outer])*
            impl ::iter::Extend<$PublicBitFlags> for $PublicBitFlags 
            {
                fn extend<T: ::iter::IntoIterator<Item = Self>>
                (
                    &mut self,
                    iterator: T
                )
                {
                    for item in iterator
                    {
                        self.insert(item)
                    }
                }
            }

            $(#[$outer])*
            impl ::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags 
            {
                fn from_iter<T: ::iter::IntoIterator<Item = Self>>( iterator: T ) -> Self 
                {
                    use ::iter::Extend;

                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
        };
    }

    #[macro_export] macro_rules! __impl_public_bitflags_consts 
    {
        (
            $(#[$outer:meta])*
            $PublicBitFlags:ident: $T:ty 
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }
        ) => 
        {
            $(#[$outer])*
            impl $PublicBitFlags 
            {
                $(
                    __bitflags_flag!
                    ({
                        name: $Flag,
                        named: 
                        {
                            $(#[$inner $( $args )*])*
                            pub const $Flag: Self = Self::from_bits_retain( $value);
                        },
                        unnamed: {},
                    });
                )*
            }

            $(#[$outer])*
            impl ::bits::flags::Flags for $PublicBitFlags
            {
                const FLAGS:&'static [::bits::flags::Flag<$PublicBitFlags>] = 
                &[
                    $(
                        __bitflags_flag!
                        ({
                            name: $Flag,
                            named:
                            {
                                __bitflags_expr_safe_attrs!
                                (
                                    $(#[$inner $( $args )*])*
                                    {
                                        ::bits::flags::Flag::new( stringify!( $Flag), $PublicBitFlags::$Flag )
                                    }
                                )
                            },
                            unnamed:
                            {
                                ::bits::flags::__bitflags_expr_safe_attrs!
                                (
                                    $(#[$inner $( $args )*])*
                                    {
                                        ::bits::flags::Flag::new("", $PublicBitFlags::from_bits_retain( $value))
                                    }
                                )
                            },
                        }),
                    )*
                ];

                type Bits = $T;
                fn bits( &self ) -> $T { $PublicBitFlags::bits(self) }
                fn from_bits_retain( bits:$T ) -> $PublicBitFlags { $PublicBitFlags::from_bits_retain( bits ) }
            }
        };
    }

    #[macro_export] macro_rules! __declare_internal_bitflags
    {
        (
            $vis:vis struct $InternalBitFlags:ident: $T:ty
        ) =>
        {
            #[repr( transparent )] #[derive( Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash )]            
            $vis struct $InternalBitFlags( $T );
        };
    }

    #[macro_export] macro_rules! __impl_internal_bitflags
    {
        (
            $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident
            {
                $(
                    $(#[$inner:ident $( $args:tt )*])*
                    const $Flag:tt = $value:expr;
                )*
            }
        ) =>
        {
            impl ::bits::flags::PublicFlags for $PublicBitFlags
            {
                type Primitive = $T;
                type Internal = $InternalBitFlags;
            }

            impl ::default::Default for $InternalBitFlags
            {
                #[inline] fn default() -> Self { $InternalBitFlags::empty() }
            }

            impl ::fmt::Debug for $InternalBitFlags
           
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                {
                    if self.is_empty() { write!(f, "{:#x}", <$T as ::bits::flags::Bits>::EMPTY) }
                    else { ::fmt::Display::fmt(self, f) }
                }
            }

            impl ::fmt::Display for $InternalBitFlags
           
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                { ::bits::flags::parser::to_writer(&$PublicBitFlags(*self), f) }
            }

            impl ::str::FromStr for $InternalBitFlags
            {
                type Err = ::bits::flags::parser::ParseError;
                fn from_str(s: &str) -> ::result::Result<Self, Self::Err>
                { ::bits::flags::parser::from_str::<$PublicBitFlags>(s ).map(|flags| flags.0) }
            }

            impl ::convert::AsRef<$T> for $InternalBitFlags
            {
                fn as_ref( &self ) -> &$T { &self.0 }
            }

            impl ::convert::From<$T> for $InternalBitFlags
            {
                fn from( bits: $T ) -> Self { Self::from_bits_retain( bits ) }
            }
            
            __impl_public_bitflags!
            {
                $InternalBitFlags: $T, $PublicBitFlags
                {
                    $(
                        $(#[$inner $( $args )*])*
                        const $Flag = $value;
                    )*
                }
            }

            __impl_public_bitflags_ops! { $InternalBitFlags }

            __impl_public_bitflags_iter! { $InternalBitFlags: $T, $PublicBitFlags }

            impl $InternalBitFlags
            {

                #[inline] pub fn bits_mut(&mut self) -> &mut $T { &mut self.0 }
            }
        };
    }
}

pub mod arch
{
    pub use std::arch::{ * };
}

pub mod arrays
{
    /*!
    Arr | A container which can hold an arbitrary number of elements of a single type. */
    use ::
    {
        error::{ OverError },
        fmt::{ Format },
        result::{ OverResult },
        slice::{ Iter },
        sync::{ Arc },
        types::{ Type },
        values::{ Value },
        *,
    };
    /*
    */
    #[derive( Clone, Debug )]
    struct ArrInner 
    {
        vec: Vec<Value>,
        inner_t: Type,
    }

    #[derive( Clone, Debug )]
    pub struct Arr 
    {
        inner: Arc<ArrInner>,
    }

    impl Arr 
    {
        pub fn from_vec( vec: Vec<Value> ) -> OverResult<Arr> 
        {
            let mut tcur = Type::Any;
            let mut has_any = true;

            for value in &vec {
                let tnew = value.get_type();

                if has_any {
                    match Type::most_specific( &tcur, &tnew ) {
                        Some( ( t, any ) ) => {
                            tcur = t;
                            has_any = any;
                        }
                        None => return Err( OverError::ArrTypeMismatch( tcur, tnew ) ),
                    }
                } else if tcur != tnew {
                    return Err( OverError::ArrTypeMismatch( tcur, tnew ) );
                }
            }
            Ok( Arr {
                inner: Arc::new( ArrInner { vec, inner_t: tcur } ),
            } )
        }
        pub fn from_vec_unchecked( vec: Vec<Value>, inner_t: Type ) -> Arr 
        {
            Arr {
                inner: Arc::new( ArrInner { vec, inner_t } ),
            }
        }

        pub fn vec_ref( &self ) -> &Vec<Value> 
        {
            &self.inner.vec
        }

        pub fn with_each<F>( &self, mut f: F ) where
            F: FnMut( &Value ),
        {
            for value in &self.inner.vec {
                f( value )
            }
        }

        pub fn get( &self, index: usize ) -> OverResult<Value> 
        {
            if index >= self.inner.vec.len() {
                Err( OverError::ArrOutOfBounds( index ) )
            } else {
                Ok( self.inner.vec[index].clone() )
            }
        }

        pub fn inner_type( &self ) -> Type { self.inner.inner_t.clone() }

        pub fn len( &self ) -> usize { self.inner.vec.len() }

        pub fn is_empty( &self ) -> bool { self.inner.vec.is_empty() }

        pub fn ptr_eq( &self, other:&Self ) -> bool 
        {
            Arc::ptr_eq( &self.inner, &other.inner )
        }

        pub fn iter( &self ) -> Iter<Value> 
        {
            self.vec_ref().iter()
        }
    }

    impl Default for Arr 
    {
        fn default() -> Self {
            Self::from_vec_unchecked( vec![], Type::Any )
        }
    }

    impl fmt::Display for Arr 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            write!( f, "{}", self.format( true, INDENT_STEP ) )
        }
    }

    impl PartialEq for Arr 
    {
        fn eq( &self, other:&Self ) -> bool {
           
            if self.inner.inner_t != other.inner.inner_t {
                return false;
            }
            self.inner.vec == other.inner.vec
        }
    }
}

pub mod ascii
{
    pub use std::ascii::{ * };
    
    const T: bool = true;
    const F: bool = false;

    #[repr( C, align( 8 ) )]
    pub struct Align8<T>( pub T );
    #[repr( C, align( 64 ) )]
    pub struct Align64<T>( pub T );

    pub static ASCII_START: Align64<[bool; 128]> = Align64
    ( [
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T,
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ] );

    pub static ASCII_CONTINUE: Align64<[bool; 128]> = Align64
    ( [
        F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, 
        F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, T, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T, 
        T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F,
    ] );

    pub const CHUNK: usize = 64;

    pub static TRIE_START: Align8<[u8; 411]> = Align8
    ( [
        0x04, 0x0B, 0x0F, 0x13, 0x17, 0x1B, 0x1F, 0x23, 0x27, 0x2D, 0x31, 0x34, 0x38, 0x3C, 0x40, 0x02, 0x45, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x49, 0x00, 0x4D, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x51, 0x54, 0x58, 0x5C, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x60, 
        0x64, 0x66, 0x6A, 0x6E, 0x72, 0x28, 0x76, 0x78, 0x7C, 0x80, 0x84, 0x88, 0x8C, 0x90, 0x94, 0x98, 0x9C, 0xA0, 
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xA8, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x00, 
        0x05, 0xB2, 0xB6, 0xBA, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xD1, 0xD3, 0x00, 0x00, 0x00, 0xC9, 0xD9, 0xDD, 0xE1, 0xE5, 0xE9, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7,
    ] );

    pub static TRIE_CONTINUE: Align8<[u8; 1793]> = Align8
    ( [
        0x08, 0x0D, 0x11, 0x15, 0x19, 0x1D, 0x21, 0x25, 0x2A, 0x2F, 0x31, 0x36, 0x3A, 0x3E, 0x42, 0x02,0x47, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x4F, 0x00, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x51, 0x56, 0x5A, 0x5E, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x09, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x62, 
        0x64, 0x68,0x6C, 0x70, 0x74, 0x28, 0x76, 0x7A, 0x7E, 0x82, 0x86, 0x8A, 0x8E, 0x92, 0x96, 0x9A, 0x9E, 0xA2,
        0x05, 0x2B, 0xA4, 0x00, 0x00, 0x00, 0x00, 0xA6, 0x05, 0x05, 0xAB, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x32, 
        0x05, 0xAD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xB0, 0x00, 0x00, 0x00, 
        0x05, 0xB4, 0xB8, 0xBC, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 
        0x43, 0xC2, 0x00, 0x00, 0x00, 0x00, 0xC8, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xC3, 0xC6, 0xCE, 
        0xD1, 0xD5, 0x00, 0xD7, 0x00, 0xC9,0xDB, 0xDF, 0xE3, 0xE7, 0xEB, 0x00, 0x00, 0xED, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0xCC, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0xEF, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF1, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF3, 
        0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x52, 0x05, 0xF5, 0x00, 0x00, 
        0x00, 0x00, 0x05, 0xAF, 0x00, 0x00,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xA9, 0x05, 0x05, 
        0x05, 0x05, 0x05, 0x05,0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0xF7, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0xCF,
    ] );

    pub static LEAF: Align64<[u8; 7968]> = Align64
    ( [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xAA, 
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x5F, 0xDC, 0x1F, 0xCF, 0x0F, 0xFF, 0x1F, 
        0xDC, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x20, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xA0, 0x04, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 
        0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0xDF, 0xB8, 0x40, 0xD7, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0x03, 0x00, 0x1F, 0x50, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xB8, 0xC0, 0xD7, 0xFF, 0xFF,
        0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF,
        0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0x87, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFB, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x02, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xB6, 0x00, 0xFF, 0xFF, 0xFF, 0x87, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xC0, 0xFE, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2F, 0x00, 0x60, 0xC0, 0x00, 0x9C,
        0x00, 0x00, 0xFD, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x02, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x07, 0x30, 0x04,
        0x00, 0x00, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xEF, 0x9F, 0xFF, 0xFD, 0xFF, 0x9F,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x24,
        0xFF, 0xFF, 0x3F, 0x04, 0x10, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0x01, 0xFF, 0x03, 0x00, 0xFE, 0xFF,
        0xE1, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0x23, 0x00, 0x40, 0x00, 0xB0, 0x03, 0x00, 0x03, 0x10,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x07, 0xFF, 0xFF,
        0xFF, 0xFE, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0xFE, 0xFF,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0xF3, 0x9F, 0x79, 0x80, 0xB0, 0xCF, 0xFF, 0x03, 0x50,
        0xE0, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0x03, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x00, 0x1C, 0x00,
        0xE0, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x02,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x02, 0x00,
        0xE8, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEE, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0xD3, 0x87, 0x39, 0x02, 0x5E, 0xC0, 0xFF, 0x3F, 0x00,
        0xEE, 0xBF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0xBF, 0x3B, 0x01, 0x00, 0xCF, 0xFF, 0x00, 0xFE,
        0xEE, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xF3, 0x9F, 0x39, 0xE0, 0xB0, 0xCF, 0xFF, 0x02, 0x00,
        0xEC, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xFF, 0xC3, 0xC7, 0x3D, 0x81, 0x00, 0xC0, 0xFF, 0x00, 0x00,
        0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0x23, 0x00, 0x00, 0x00, 0x37, 0x03, 0x00, 0x00, 0x00,
        0xE1, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x23, 0x00, 0x00, 0x00, 0x70, 0x03, 0x00, 0x06, 0x00,
        0xF0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x27, 0x00, 0x40, 0x70, 0x80, 0x03, 0x00, 0x00, 0xFC,
        0xE0, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0xF3, 0xDF, 0x3D, 0x60, 0x37, 0xCF, 0xFF, 0x00, 0x00,
        0xEF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0xF3, 0xDF, 0x3D, 0x60, 0x70, 0xCF, 0xFF, 0x0E, 0x00,
        0xFF, 0xDF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x7D, 0xF0, 0x80, 0xCF, 0xFF, 0x00, 0xFC,
        0xEE, 0xFF, 0x7F, 0xFC, 0xFF, 0xFF, 0xFB, 0x2F, 0x7F, 0x84, 0x5F, 0xFF, 0xC0, 0xFF, 0x0C, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0x05, 0x20, 0x5F, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x7F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xD6, 0xF7, 0xFF, 0xFF, 0xAF, 0xFF, 0xFF, 0x3F, 0x5F, 0x7F, 0xFF, 0xF3, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x03, 0xFF, 0x03, 0xA0, 0xC2, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0xFE, 0xFF,
        0xDF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x80, 0x00, 0x00, 0x3F, 0x3C, 0x62, 0xC0, 0xE1, 0xFF,
        0x03, 0x40, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0x3D, 0x7F, 0x3D, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x3D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0xFE, 0x03, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F,
        0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x03, 0x80, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xDF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x80, 0x10, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9F, 0xFF, 0xFF,
        0xFE, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0xFF, 0x01,
        0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF, 0x1F, 0x00, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xDF, 0x0D, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F, 0x30, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0xB8, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x0F, 0xFF, 0x0F, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xE0, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x01, 0xC0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x9F,
        0xFF, 0x03, 0xFF, 0x03, 0x80, 0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x0F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03, 0x00, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0xFC, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDE, 0x6F, 0x04,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xE3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0x00, 0x00, 0xF7, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x27, 0x00, 0xF0, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x80,
        0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x1F, 0xE2, 0xFF, 0x01, 0x00,
        0x84, 0xFC, 0x2F, 0x3F, 0x50, 0xFD, 0xFF, 0xF3, 0xE0, 0x43, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x78, 0x0C, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xF8, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x80,
        0xFF, 0xFF, 0x7F, 0x00, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xE0, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0x3E, 0x1F, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0x7F, 0xE6, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0x00, 0x0C, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xBF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00,
        0x00, 0x00, 0x80, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xFE, 0xFF,
        0xBB, 0xF7, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x68,
        0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x80, 0x00, 0x00, 0xDF, 0xFF, 0x00, 0x7C,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x10, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xE8,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x80, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0xF7, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0xC4,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x62, 0x3E, 0x05, 0x00, 0x00, 0x38, 0xFF, 0x07, 0x1C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0x7F, 0xFC,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x38, 0xFF, 0xFF, 0x7C, 0x00,
        0x7E, 0x7E, 0x7E, 0x00, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF7, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x37, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xA0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0x00, 0xF8, 0xE0, 0xFF, 0xFD, 0x7F, 0x5F, 0xDB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xF0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0xFF, 0xFF, 0x07, 0xC0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x18, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x8A, 0xAA,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F,
        0x00, 0x00, 0xFF, 0x03, 0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07, 0xE0, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFC, 0xFC, 0xFC, 0x1C, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xEF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xB7, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0xFF, 0xF7,
        0xFF, 0xF7, 0xB7, 0xFF, 0xFB, 0xFF, 0xFB, 0x1B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00,
        0x3F, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x91, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x37, 0x00,
        0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x6F, 0xF0, 0xEF, 0xFE, 0xFF, 0xFF, 0x3F, 0x87, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x1F,
        0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF, 0xFF, 0x3F, 0x80, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xBE, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1B, 0x03, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC,
        0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF,
        0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x90, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x47, 0x00,
        0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x1E, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0x3F, 0x80,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x4F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xDE, 0xFF, 0x17, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0x0F, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00,
        0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0x23, 0x00, 0x00, 0x01, 0xE0, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xBD, 0xFF, 0xBF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x03,
        0xEF, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xED, 0xFB, 0x9F, 0x39, 0x81, 0xE0, 0xCF, 0x1F, 0x1F, 0x00,
        0xFF, 0x4B, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0xFF, 0xA5, 0xF7, 0x0F, 0x00, 0x06, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x80, 0x07, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xC3, 0x03, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBF, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0x01, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x11, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xE7, 0xFF, 0x0F, 0xFF, 0x03, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x0A, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x80,
        0x7F, 0xF2, 0x6F, 0xFF, 0xFF, 0xFF, 0xBF, 0xF9, 0x0F, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x1B, 0x00, 0x00, 0x00,
        0x01, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x04, 0x00, 0x00, 0x01, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x20, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x80, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xFF, 0x03,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x40, 0x00, 0x00, 0x00, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x03, 0x00, 0x01, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x01, 0x00, 0xFF, 0x03, 0x00, 0x00, 0xFC, 0xFF,
        0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFE, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xB4, 0xFF, 0x00, 0xFF, 0x03, 0xBF, 0xFD, 0xFF, 0xFF,
        0xFF, 0x7F, 0xFB, 0x01, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x07, 0x00,
        0xF4, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00,
        0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x07, 0x00, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x0F, 0x00, 0xFF, 0x03, 0xF8, 0xFF, 0xFF, 0xE0,
        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x7C, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0x80, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x7F, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x80,
        0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x6F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE3, 0x07, 0xF8,
        0xE7, 0x0F, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x1F,
        0xFF, 0x01, 0xFF, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0x7F, 0xE0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xDF, 0x64, 0xDE, 0xFF, 0xEB, 0xEF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xBF, 0xE7, 0xDF, 0xDF, 0xFF, 0xFF, 0xFF, 0x7B, 0x5F, 0xFC, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xFF, 0xFF, 0xFF, 0xF7,
        0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF,
        0xFF, 0xFD, 0xFF, 0xFF, 0xFF, 0xFD, 0xFF, 0xFF, 0xF7, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x20, 0x00,
        0x10, 0x00, 0x00, 0xF8, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x80, 0x3F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x7F, 0xFF, 0xFF, 0xF9, 0xDB, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00,
        0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0x3F, 0xFF, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x3F, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xB7, 0x3F, 0x1F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0x3F, 0xC0,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x6F, 0xFF, 0x7F,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xEF, 0xFF, 0xFF, 0xFF, 0x96, 0xFE, 0xF7, 0x0A, 0x84, 0xEA, 0x96, 0xAA, 0x96, 0xF7, 0xF7, 0x5E,
        0xFF, 0xFB, 0xFF, 0x0F, 0xEE, 0xFB, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ] );
}

pub mod backtrace
{
    pub use std::backtrace::{ * };
}

pub mod bits
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    pub mod flags
    {
        /*!
        Generate types for C-style flags with ergonomic APIs.*/
        use ::
        {
            *,
        };
        /*
        */
        pub mod iter
        {           
            /*!
            Yield the bits of a source flags value in a set of contained flags values. */
            use ::
            {
                *,
            };
            /*
            */
            use super::{ Flag, Flags };
            /**
            An iterator over flags values. */
            pub struct Iter<B: 'static> 
            {
                inner: IterNames<B>,
                done: bool,
            }

            impl<B: Flags> Iter<B> 
            {
                pub fn new(flags: &B) -> Self {
                    Iter {
                        inner: IterNames::new(flags ),
                        done: false,
                    }
                }
            }

            impl<B: 'static> Iter<B> 
            {
                // Used by the `bitflags` macro
                #[doc(hidden)]
                pub const fn __private_const_new(flags:&'static [Flag<B>], source: B, remaining: B) -> Self {
                    Iter {
                        inner: IterNames::__private_const_new(flags, source, remaining),
                        done: false,
                    }
                }
            }

            impl<B: Flags> Iterator for Iter<B> 
            {
                type Item = B;
                fn next(&mut self) -> Option<Self::Item> {
                    match self.inner.next() {
                        Some((_, flag)) => Some(flag),
                        None if !self.done => {
                            self.done = true;
                            
                            if !self.inner.remaining().is_empty() {
                                Some( b::from_bits_retain( self.inner.remaining.bits()))
                            } else {
                                None
                            }
                        }
                        None => None,
                    }
                }
            }
            /**
            An iterator over flags values.*/
            pub struct IterNames<B: 'static> {
                flags:&'static [Flag<B>],
                idx: usize,
                source: B,
                remaining: B,
            }

            impl<B: Flags> IterNames<B> {
                pub fn new(flags: &B) -> Self {
                    IterNames {
                        flags: B::FLAGS,
                        idx: 0,
                        remaining: B::from_bits_retain(flags.bits()),
                        source: B::from_bits_retain(flags.bits()),
                    }
                }
            }

            impl<B: 'static> IterNames<B> {
                // Used by the bitflags macro
                #[doc(hidden)]
                pub const fn __private_const_new(flags:&'static [Flag<B>], source: B, remaining: B) -> Self {
                    IterNames {
                        flags,
                        idx: 0,
                        remaining,
                        source,
                    }
                }

                pub fn remaining( &self ) -> &B { &self.remaining }
            }

            impl<B: Flags> Iterator for IterNames<B>
            {
                type Item = (&'static str, B);
                fn next(&mut self) -> Option<Self::Item> {
                    while let Some(flag) = self.flags.get( self.idx) {
                        // Short-circuit if our state is empty
                        if self.remaining.is_empty() {
                            return None;
                        }

                        self.idx += 1;
                        
                        if flag.name().is_empty() {
                            continue;
                        }

                        let bits = flag.value().bits();
                        
                        if self.source.contains( b::from_bits_retain( bits ))
                            && self.remaining.intersects( b::from_bits_retain( bits ))
                        {
                            self.remaining.remove( b::from_bits_retain( bits ));

                            return Some((flag.name(), B::from_bits_retain( bits )));
                        }
                    }

                    None
                }
            }

            /**
            An iterator over all defined named flags.

            This iterator will yield flags values for all defined named flags, regardless of
            whether they are contained in a particular flags value.
            */
            pub struct IterDefinedNames<B: 'static> {
                flags:&'static [Flag<B>],
                idx: usize,
            }

            impl<B: Flags> IterDefinedNames<B> {
                pub fn new() -> Self {
                    IterDefinedNames {
                        flags: B::FLAGS,
                        idx: 0,
                    }
                }
            }

            impl<B: Flags> Iterator for IterDefinedNames<B>
            {
                type Item = (&'static str, B);
                fn next(&mut self) -> Option<Self::Item>
                {
                    while let Some(flag) = self.flags.get( self.idx)
                    {
                        self.idx += 1;
                        if flag.is_named() { return Some((flag.name(), B::from_bits_retain(flag.value().bits()))); }
                    }

                    None
                }
            }
        } pub use self::iter::{ * };

        pub mod parser
        {
            /*!
            Parsing flags from text.*/
            use ::
            {
                fmt::{ self, Write },
                *,
            };

            use super::{ * };
            /*
            */
            /**
            Write a flags value as text.*/
            pub fn to_writer<B:Flags>( b:&B, mut w:impl Write ) -> Result<(), fmt::Error> where
            B::Bits: WriteHex
            {
                let mut first = true;
                let mut iter = b.iter_names();

                for (name, _) in &mut iter
                {
                    if !first { w.write_str(" | ")?; }

                    first = false;
                    w.write_str(name)?;
                }
                
                let remaining = iter.remaining().bits();
                
                if remaining != B::Bits::EMPTY
                {
                    if !first { w.write_str(" | ")?; }

                    w.write_str("0x")?;
                    remaining.write_hex( w )?;
                }

                fmt::Result::Ok( () )
            }
            /**
            Parse a flags value from text. */
            pub fn from_str<B: Flags>( t:&str ) -> Result<B, ParseError> where
            B::Bits: ParseHex
            {
                let mut parsed_flags = B::empty();
                
                if t.trim().is_empty() { return Ok(parsed_flags ); }

                for flag in t.split('|')
                {
                    let flag = flag.trim();
                    
                    if flag.is_empty() { return Err(ParseError::empty_flag()); }
                    
                    let parsed_flag = if let Some(flag) = flag.strip_prefix("0x")
                    {
                        let bits = <B::Bits>::parse_hex(flag).map_err( | _ | ParseError::invalid_hex_flag( flag ) )?;
                        B::from_bits_retain( bits )
                    }
                    
                    else { B::from_name(flag).ok_or_else(|| ParseError::invalid_named_flag(flag))? };

                    parsed_flags.insert(parsed_flag);
                }

                Ok(parsed_flags )
            }
            /**
            Write a flags value as text, ignoring any unknown bits. */
            pub fn to_writer_truncate<B: Flags>( f: &B, w:impl Write ) -> Result<(), fmt::Error> where
            B::Bits: WriteHex
            {
                to_writer( &B::from_bits_truncate( f.bits() ), w )
            }
            /**
            Parse a flags value from text. */
            pub fn from_str_truncate<B: Flags>( t:&str ) -> Result<B, ParseError> where
            B::Bits: ParseHex
            { Ok( B::from_bits_truncate( from_str::<B>( t )?.bits() ) ) }
            /**
            Write only the contained, defined, named flags in a flags value as text. */
            pub fn to_writer_strict<B: Flags>( f: &B, mut w: impl Write) -> Result<(), fmt::Error>
            {
                let mut first = true;
                let mut iter = f.iter_names();

                for (name, _) in &mut iter
                {
                    if !first { w.write_str(" | ")?; }

                    first = false;
                    w.write_str(name)?;
                }

                fmt::Result::Ok( () )
            }
            /**
            Parse a flags value from text.*/
            pub fn from_str_strict<B: Flags>( t:&str ) -> Result<B, ParseError>
            {
                let mut parsed_flags = B::empty();
                if t.trim().is_empty() { return Ok(parsed_flags ); }

                for flag in t.split('|')
                {
                    let flag = flag.trim();
                    if flag.is_empty() { return Err(ParseError::empty_flag()); }
                    
                    if flag.starts_with("0x") { return Err(ParseError::invalid_hex_flag("unsupported hex flag")); }

                    let parsed_flag = B::from_name(flag).ok_or_else(|| ParseError::invalid_named_flag(flag))?;

                    parsed_flags.insert(parsed_flag);
                }

                Ok( parsed_flags )
            }

            #[derive( Debug )]
            pub struct ParseError( ParseErrorKind );

            #[derive( Debug )]
            enum ParseErrorKind
            {
                EmptyFlag,
                InvalidNamedFlag
                {
                    got: String,
                },
                InvalidHexFlag
                {
                    got: String,
                },
            }

            impl ParseError
            
            {

                pub fn invalid_hex_flag(flag: impl fmt::Display) -> Self
                {
                    let _flag = flag;
                    let got = _flag.to_string();
                    ParseError(ParseErrorKind::InvalidHexFlag { got })
                }

                pub fn invalid_named_flag(flag: impl fmt::Display) -> Self 
                {
                    let _flag = flag;
                    let got = _flag.to_string();
                    ParseError(ParseErrorKind::InvalidNamedFlag { got })
                }

                pub const fn empty_flag() -> Self { ParseError(ParseErrorKind::EmptyFlag) }
            }

            impl fmt::Display for ParseError 
           
            {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result
                {
                    match &self.0 
                    {
                        ParseErrorKind::InvalidNamedFlag { got } => 
                        {
                            let _got = got;
                            write!(f, "unrecognized named flag")?;
                            write!(f, " `{}`", _got )?;
                        }

                        ParseErrorKind::InvalidHexFlag { got } => 
                        {
                            let _got = got;
                            write!(f, "invalid hex flag")?;
                            write!(f, " `{}`", _got )?;
                        }

                        ParseErrorKind::EmptyFlag => { write!(f, "encountered empty flag")?; }
                    }

                    Ok( () )
                }
            }
            
            impl ::error::Error for ParseError {}
        } pub use self::parser::{ * };
        
        pub mod traits
        {
            /*!
            */
            use ::
            {
                ops::{BitAnd, BitOr, BitXor, Not},
                *,
            };
            /**
            A defined flags value that may be named or unnamed.
            */
            #[derive( Debug )]
            pub struct Flag<B> 
            {
                name:&'static str,
                value: B,
            }

            impl<B> Flag<B> 
            {
                /**
                Define a flag. */
                pub const fn new(name:&'static str, value: B) -> Self { Flag { name, value } }
                /**
                Get the name of this flag. */
                pub const fn name( &self ) -> &'static str { self.name }
                /**
                Get the flags value of this flag.
                */
                pub const fn value( &self ) -> &B { &self.value }
                /**
                Whether the flag is named. */
                pub const fn is_named( &self ) -> bool { !self.name.is_empty() }
                /**
                Whether the flag is unnamed. */
                pub const fn is_unnamed( &self ) -> bool { self.name.is_empty() }
            }
            /**
            A set of defined flags using a bits type as storage.*/
            pub trait Flags: Sized + 'static 
            {

                const FLAGS:&'static [Flag<Self>];

                type Bits: Bits;
                fn empty() -> Self { Self::from_bits_retain(Self::Bits::EMPTY) }

                fn all() -> Self
                {
                    let mut truncated = Self::Bits::EMPTY;

                    for flag in Self::FLAGS.iter()
                    {
                        truncated = truncated | flag.value().bits();
                    }
                    
                    Self::from_bits_retain( truncated)
                }

                fn contains_unknown_bits( &self ) -> bool { Self::all().bits() & self.bits() != self.bits() }

                fn bits( &self ) -> Self::Bits;
                fn from_bits( bits: Self::Bits ) -> Option<Self> 
                {
                    let truncated = Self::from_bits_truncate( bits );

                    if truncated.bits() == bits { Some( truncated ) }
                    else { None }
                }

                fn from_bits_truncate( bits: Self::Bits ) -> Self { Self::from_bits_retain( bits & Self::all().bits()) }

                fn from_bits_retain( bits: Self::Bits ) -> Self;
                fn from_name(name: &str) -> Option<Self>
                {
                    if name.is_empty() { return None; }

                    for flag in Self::FLAGS 
                    {
                        if flag.name() == name { return Some(Self::from_bits_retain(flag.value().bits())); }
                    }

                    None
                }

                fn iter( &self ) -> super::iter::Iter<Self>
                {
                    super::iter::Iter::new(self)
                }

                fn iter_names( &self ) -> super::iter::IterNames<Self> { super::iter::IterNames::new(self) }

                fn iter_defined_names() -> super::iter::IterDefinedNames<Self> { super::iter::IterDefinedNames::new() }

                fn is_empty( &self ) -> bool { self.bits() == Self::Bits::EMPTY }

                fn is_all( &self ) -> bool  { Self::all().bits() | self.bits() == self.bits() }

                fn intersects(&self, other: Self) -> bool where
                Self: Sized
                { self.bits() & other.bits() != Self::Bits::EMPTY }

                fn contains(&self, other: Self) -> bool where
                Self: Sized
                { self.bits() & other.bits() == other.bits() }

                fn truncate(&mut self) where
                Self: Sized
                { *self = Self::from_bits_truncate( self.bits()); }

                fn insert( &mut self, other: Self) where
                Self: Sized
                { *self = Self::from_bits_retain( self.bits()).union( other ); }

                fn remove( &mut self, other: Self) where
                Self: Sized
                { *self = Self::from_bits_retain( self.bits()).difference( other ); }

                fn toggle( &mut self, other: Self) where
                Self: Sized
                { *self = Self::from_bits_retain( self.bits()).symmetric_difference( other ); }

                fn set( &mut self, other: Self, value:bool ) where
                Self: Sized
                {
                    if value { self.insert( other ); }
                    else { self.remove( other ); }
                }

                fn clear(&mut self) where
                Self: Sized
                { *self = Self::empty(); }

                #[must_use]
                fn intersection(self, other: Self) -> Self { Self::from_bits_retain( self.bits() & other.bits()) }

                #[must_use]
                fn union(self, other: Self) -> Self { Self::from_bits_retain( self.bits() | other.bits()) }

                #[must_use]
                fn difference(self, other: Self) -> Self { Self::from_bits_retain( self.bits() & !other.bits()) }

                #[must_use]
                fn symmetric_difference(self, other: Self) -> Self { Self::from_bits_retain( self.bits() ^ other.bits()) }

                #[must_use]
                fn complement(self) -> Self { Self::from_bits_truncate(!self.bits()) }
            }
            /**
            A bits type that can be used as storage for a flags type. */
            pub trait Bits:
            Clone
            + Copy
            + PartialEq
            + BitAnd<Output = Self>
            + BitOr<Output = Self>
            + BitXor<Output = Self>
            + Not<Output = Self>
            + Sized
            + 'static
            {

                const EMPTY: Self;

                const ALL: Self;
            }
            
            pub trait Primitive {}

            macro_rules! impl_bits 
            {
                ( $( $u:ty, $i:ty,)*) => 
                {
                    $(
                        impl Bits for $u 
                        {
                            const EMPTY: $u = 0;
                            const ALL: $u = <$u>::MAX;
                        }

                        impl Bits for $i 
                        {
                            const EMPTY: $i = 0;
                            const ALL: $i = <$u>::MAX as $i;
                        }

                        impl ParseHex for $u 
                        {
                            fn parse_hex(input: &str) -> Result<Self, ::bits::flags::ParseError> 
                            { <$u>::from_str_radix(input, 16).map_err(|_| ::bits::flags::ParseError::invalid_hex_flag(input )) }
                        }

                        impl ParseHex for $i
                        {
                            fn parse_hex(input: &str) -> Result<Self, ::bits::flags::ParseError> 
                            { <$i>::from_str_radix(input, 16).map_err(|_| ::bits::flags::ParseError::invalid_hex_flag(input )) }
                        }

                        impl WriteHex for $u
                        {
                            fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result { write!(writer, "{:x}", self) }
                        }

                        impl WriteHex for $i
                        {
                            fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result { write!(writer, "{:x}", self) }
                        }

                        impl Primitive for $i {}
                        impl Primitive for $u {}
                    )*
                }
            }

            impl_bits! 
            { 
                u8, u16, u32, u64, u128, usize,
                i8, i16, i32, i64, i128, isize,
            }

            pub trait PublicFlags 
            {

                type Primitive: Primitive;

                type Internal;
            }
            /**
            Encode a value as a hex string. */
            pub trait WriteHex
            {
                fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result;
            }
            /**
            Parse a value from a hex string. */
            pub trait ParseHex
            {
                fn parse_hex(input: &str) -> Result<Self, super::parser::ParseError>  where Self: Sized;
            }

            #[doc(hidden)]
            #[deprecated(note = "use the `Flags` trait instead")]
            pub trait BitFlags: ImplementedByBitFlagsMacro + Flags 
            {

                type Iter: Iterator<Item = Self>;

                type IterNames: Iterator<Item = (&'static str, Self)>;
            }

            #[allow(deprecated)]
            impl<B: Flags> BitFlags for B 
            {
                type Iter = ::bits::flags::iter::Iter<Self>;
                type IterNames = ::bits::flags::iter::IterNames<Self>;
            }

            impl<B: Flags> ImplementedByBitFlagsMacro for B {}

            #[doc(hidden)]
            pub trait ImplementedByBitFlagsMacro {}

            pub mod __private 
            {
                pub use super::{ImplementedByBitFlagsMacro, PublicFlags};
            }
        } pub use self::traits::{ * };
    }
}

pub mod borrow
{
    pub use std::borrow::{ * };
}

pub mod boxed
{
    pub use std::boxed::{ * };
}

pub mod cell
{
    pub use std::cell::{ * };
}

pub mod char
{
    /*!
    Character stream used for parsing. */
    pub use std::char::{ * };
    use ::
    {
        cell::{ RefCell },
        fs::{ File },
        io::{ self, Read },
        iter::{ Peekable },
        rc::{ Rc },
        str::{ Chars },
        *,
    };
    /*
    */
    #[allow( dead_code )]
    #[derive( Clone, Debug )]
    struct Inner 
    {
        file:Option<String>,
        contents: String,
        stream: Peekable<Chars<'static>>,
        line: usize,
        col: usize,
    }

    #[derive( Clone, Debug )]
    pub struct CharStream 
    {
        inner: Rc<RefCell<Inner>>,
    }

    impl CharStream 
    {
        pub fn from_file( path:&str ) -> io::Result<CharStream> 
        {
            let mut file = File::open( path )?;

            let len = file.metadata()?.len();
            let mut contents = String::with_capacity( len as usize );

            file.read_to_string( &mut contents )?;

            Self::from_string_impl( Some( String::from( path ) ), contents )
        }

        fn from_string_impl( file:Option<String>, contents: String ) -> io::Result<CharStream> 
        {
            let chars: Chars = unsafe { mem::transmute( contents.chars() ) };
            let stream = chars.peekable();
            Ok( CharStream 
            {
                inner: Rc::new( RefCell::new( Inner 
                {
                    file,
                    contents,
                    stream,
                    line: 1,
                    col: 1,
                } ) ),
            } )
        }

        pub fn from_string( contents: String ) -> io::Result<CharStream> 
        {
            Self::from_string_impl( None, contents )
        }

        pub fn peek( &self ) -> Option<char> 
        {
            let mut inner = self.inner.borrow_mut();
            let opt = inner.stream.peek();

            match opt {
                Some( ch ) => Some( *ch ),
                None => None,
            }
        }

        pub fn file( &self ) -> Option<String> 
        {
            let inner = self.inner.borrow();
            inner.file.clone()
        }

        pub fn line( &self ) -> usize 
        {
            let inner = self.inner.borrow();
            inner.line
        }

        pub fn col( &self ) -> usize 
        {
            let inner = self.inner.borrow();
            inner.col
        }

        fn set_line( &mut self, value: usize ) 
        {
            let mut inner = self.inner.borrow_mut();
            inner.line = value;
        }

        fn set_col( &mut self, value: usize ) 
        {
            let mut inner = self.inner.borrow_mut();
            inner.col = value;
        }
    }

    impl Iterator for CharStream 
    {
        type Item = char;

        fn next( &mut self ) -> Option<Self::Item>
        {
            let opt = {
                let mut inner = self.inner.borrow_mut();
                inner.stream.next()
            };

            match opt {
                Some( ch ) => {
                    if ch == '\n' {
                        let line = self.line();
                        self.set_line( line + 1 );
                        self.set_col( 1 );
                    } else {
                        let col = self.col();
                        self.set_col( col + 1 );
                    }
                    Some( ch )
                }
                None => None,
            }
        }
    }

    pub fn format( ch:char ) -> String 
    {
        match ch {
            '\n' => String::from( "\\n" ),
            ch => format!( "{}", ch ),
        }
    }

    // #[inline] pub fn char_width( ch:char ) -> Option<usize>
    #[inline] pub fn width( ch:char ) -> Option<usize>
    {
        use ::unicode::width::UnicodeWidthChar;
        ch.width()
    }

    #[inline] pub fn control( ch:char ) -> char { ( ( ch as u8 ) & 0x1f ) as char }

    #[inline] pub fn unctrl_upper( ch:char ) -> char { ( ( ch as u8 ) | 0x40 ) as char }

    #[inline] pub fn unctrl_lower( ch:char ) -> char { unctrl_upper( ch ).to_ascii_lowercase() }

    pub const EOF:char = '\x04';

    pub const ESCAPE:char = '\x1b';
    
    #[cfg( unix )]
    pub const DELETE:char = RUBOUT;

    #[cfg( windows )]
    pub const DELETE:char = '\x08';

    pub const RUBOUT:char = '\x7f';

    pub fn parse_char_name( name:&str ) -> Option<String>
    {
        let name_lc = name.to_lowercase();

        let is_ctrl = contains_any( &name_lc, &["c-","ctrl-","control-"] );
        let is_meta = contains_any( &name_lc, &["m-","meta-"] );

        let name = match name_lc.rfind( '-' ) {
            Some( pos ) => &name_lc[pos + 1..],
            None => &name_lc[..]
        };

        let ch = match name {
            "del" | "rubout"  => DELETE,
            "esc" | "escape"  => ESCAPE,
            "lfd" | "newline" => '\n',
            "ret" | "return"  => '\r',
            "spc" | "space"   => ' ',
            "tab"             => '\t',
            s if !s.is_empty() => s.chars().next().unwrap(),
            _ => return None
        };

        let ch = match ( is_ctrl, is_meta ) {
            ( true,  true )  => meta( ctrl( ch ) ),
            ( true,  false ) => ctrl( ch ).to_string(),
            ( false, true )  => meta( ch ),
            ( false, false ) => ch.to_string(),
        };

        Some( ch )
    }

    pub fn escape_sequence( s:&str ) -> String
    {
        let mut res = String::with_capacity( s.len() );

        for ch in s.chars()
        {
            match ch
            {
                ESCAPE => res.push_str( r"\e" ),
                RUBOUT => res.push_str( r"\C-?" ),
                '\\' => res.push_str( r"\\" ),
                '\'' => res.push_str( r"\'" ),
                '"' => res.push_str( r#"\""# ),
                ch if is_ctrl( ch ) => {
                    res.push_str( r"\C-" );
                    res.push( unctrl_lower( ch ) );
                }
                ch => res.push( ch )
            }
        }

        res
    }

    pub fn meta( ch:char ) -> String
    {
        let mut s = String::with_capacity( ch.len_utf8() + 1 );
        s.push( ESCAPE );
        s.push( ch );
        s
    }

    fn contains_any( s:&str, strs:&[&str] ) -> bool { strs.iter().any( |a| s.contains( a ) ) }

    pub fn is_printable( c:char ) -> bool { c == '\t' || c == '\n' || !( c == '\0' || is::control( c ) ) }

    const CTRL_BIT: u8 = 0x40;
    const CTRL_MASK: u8 = 0x1f;

    pub fn is_ctrl( c:char ) -> bool
    {
        const CTRL_MAX: u32 = 0x1f;
        c != '\0' && c as u32 <= CTRL_MAX
    }

    pub fn ctrl( c:char ) -> char { ( ( c as u8 ) & CTRL_MASK ) as char }

    pub fn unctrl( c:char ) -> char { ( ( c as u8 ) | CTRL_BIT ) as char }

    // pub fn repeat_char( ch:char, n: usize ) -> String
    pub fn repeat( ch:char, n: usize ) -> String
    {
        let mut buf = [0; 4];
        let s = ch.encode_utf8( &mut buf );
        s.repeat( n )
    }
    // pub fn backward_char( n: usize, s:&str, cur: usize ) -> usize
    pub fn backward( n: usize, s:&str, cur: usize ) -> usize
    {
        let mut chars = s[..cur].char_indices()
            .filter( |&( _, ch )| !is::combining_mark( ch ) );
        let mut res = cur;

        for _ in 0..n {
            match chars.next_back() {
                Some( ( idx, _ ) ) => res = idx,
                None => return 0
            }
        }

        res
    }
    // pub fn backward_search_char( n: usize, buf:&str, mut cur: usize, ch:char ) -> Option<usize>
    pub fn backward_search( n: usize, buf:&str, mut cur: usize, ch:char ) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n {
            match buf[..cur].rfind( ch ) {
                Some( p ) => {
                    cur = p;
                    pos = Some( cur );
                }
                None => break
            }
        }

        pos
    }
    // pub fn forward_char( n: usize, s:&str, cur: usize ) -> usize
    pub fn forward( n: usize, s:&str, cur: usize ) -> usize
    {
        let mut chars = s[cur..].char_indices()
            .filter( |&( _, ch )| !is::combining_mark( ch ) );

        for _ in 0..n {
            match chars.next() {
                Some( _ ) => (),
                None => return s.len()
            }
        }

        match chars.next() {
            Some( ( idx, _ ) ) => cur + idx,
            None => s.len()
        }
    }
    // pub fn forward_search_char( n: usize, buf:&str, mut cur: usize, ch:char ) -> Option<usize>
    pub fn forward_search( n: usize, buf:&str, mut cur: usize, ch:char ) -> Option<usize>
    {
        let mut pos = None;

        for _ in 0..n {
            let off = match buf[cur..].chars().next() {
                Some( ch ) => ch.len_utf8(),
                None => break
            };

            match buf[cur + off..].find( ch ) {
                Some( p ) => {
                    cur += off + p;
                    pos = Some( cur );
                }
                None => break
            }
        }

        pos
    }

    // pub fn first_char( buf:&[u8] ) -> io::Result<Option<char>>
    pub fn first( buf:&[u8] ) -> io::Result<Option<char>>
    {
        match str::from_utf8( buf ) 
        {
            Ok( s ) => Ok( s.chars().next() ),
            Err( e ) => 
            {
                if e.error_len().is_some()
                {
                    return Err
                    ( 
                        io::Error::new( io::ErrorKind::InvalidData, "invalid utf-8 input received" )
                     );
                }

                let valid = e.valid_up_to();

                let s = unsafe { str::from_utf8_unchecked( &buf[..valid] ) };
                Ok( s.chars().next() )
            }
        }
    }
}

pub mod clone
{
    pub use std::clone::{ * };
}

pub mod cmp
{
    pub use std::cmp::{ * };
}

pub mod collections
{
    pub use std::collections::{ * };
}

pub mod convert
{
    pub use std::convert::{ * };
}

pub mod default
{
    pub use std::default::{ * };
}

pub mod env
{
    /*!
    */
    pub use std::env::{ * };
    use ::
    {
        path::{ Path },
        *,
    };
    /*
    */
    //pub fn init_path_env()
    pub fn initialize_paths()
    {
        let mut paths:Vec<String> = vec![];
        for x in
        [
            "/usr/local/sbin",
            "/usr/local/bin",
            "/usr/sbin",
            "/usr/bin",
            "/sbin",
            "/bin",
        ]
        {
            if Path::new( x ).exists() { paths.push( x.to_string() ); }
        }

        if let Ok( env_path ) = var( "PATH" )
        {
            for x in env_path.split( ":" )
            {
                if !paths.contains( &x.to_string() ) { paths.push( x.to_string() ); }
            }
        }
        
        let paths = paths.join( ":" );
        set_var( "PATH", paths );
    }
}

pub mod error
{
    /*!
    Error Handling */
    pub use std::error::{ * };

    use ::
    {
        types::{ Type },
        *,
    };
    /*
    */

    #[derive( Debug, PartialEq, Eq )]
    pub enum OverError
    {
        ArrOutOfBounds( usize ),
        ArrTypeMismatch( Type, Type ),
        FieldNotFound( String ),
        InvalidFieldName( String ),
        NoParentFound,
        ParseError( String ),
        TupOutOfBounds( usize ),
        TupTypeMismatch( Type, Type, usize ),
        TypeMismatch( Type, Type ),
        IoError( String ),
    }

    impl fmt::Display for OverError 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            use self::OverError::*;

            match *self {
                ArrOutOfBounds( ref index ) => write!( f, "Arr index {} out of bounds", index ),
                ArrTypeMismatch( ref expected, ref found ) => write!( 
                    f,
                    "Arr inner types do not match: expected {}, found {}",
                    expected, found
                ),
                FieldNotFound( ref field ) => write!( f, "Field not found: \"{}\"", field ),
                InvalidFieldName( ref field ) => write!( f, "Invalid field name: \"{}\"", field ),
                NoParentFound => write!( f, "No parent found for this obj" ),
                TupOutOfBounds( ref index ) => write!( f, "Tup index {} out of bounds", index ),
                TupTypeMismatch( ref expected, ref found, ref index ) => write!( 
                    f,
                    "Tup inner types do not match at index {}: expected {}, found {}",
                    index, expected, found
                ),
                TypeMismatch( ref expected, ref found ) => { write!( f, "Type mismatch: expected {}, found {}", expected, found ) }
                ParseError( ref error ) | IoError( ref error ) => write!( f, "{}", error ),
            }
        }
    }

    impl Error for OverError
    {
        fn description( &self ) -> &str
        {
            use self::OverError::*;

            match *self 
            {
                ArrOutOfBounds( _ ) => "Arr index out of bounds",
                ArrTypeMismatch( _, _ ) => "Arr inner types do not match",
                FieldNotFound( _ ) => "Field not found",
                InvalidFieldName( _ ) => "Invalid field name",
                NoParentFound => "No parent found for this obj",
                TupOutOfBounds( _ ) => "Tup index out of bounds",
                TupTypeMismatch( _, _, _ ) => "Tup inner types do not match",
                TypeMismatch( _, _ ) => "Type mismatch",
                ParseError( ref error ) | IoError( ref error ) => error,
            }
        }
    }

    impl From<io::Error> for OverError
    {
        fn from( e: io::Error ) -> Self { OverError::IoError( format!( "{}", e ) ) }
    }

    impl From<ParseError> for OverError
    {
        fn from( e: ParseError ) -> Self
        {
            OverError::ParseError( format!( "{}", e ) )
        }
    }

    pub mod parse
    {
        /*!
        */
        use ::
        {
            char::{ format },
            error::{ Error, OverError },
            num::
            {
                big::{ BigInt, ParseBigIntError },
                ParseIntError
            },
            objects::{ Obj },
            parses::{ MAX_DEPTH, object_file, object_from_str },
            result::{ ParseResult },
            types::{ Type },
            *,
        };

        pub fn parse_err<T>( file:Option<String>, kind: ParseErrorKind ) -> ParseResult<T>
        {
            Err( ParseError { file, kind } )
        }

        #[derive( Debug )]
        pub enum ParseErrorKind
        {
            BinaryOperatorError( Type, Type, char, usize, usize ),
            CyclicInclude( String, usize, usize ),
            DuplicateField( String, usize, usize ),
            DuplicateGlobal( String, usize, usize ),
            ExpectedType( Type, Type, usize, usize ),
            GlobalNotFound( String, usize, usize ),
            InvalidIndex( BigInt, usize, usize ),
            InvalidClosingBracket( Option<char>, char, usize, usize ),
            InvalidDot( Type, usize, usize ),
            InvalidEscapeChar( char, usize, usize ),
            InvalidFieldChar( char, usize, usize ),
            InvalidFieldName( String, usize, usize ),
            InvalidIncludeChar( char, usize, usize ),
            InvalidIncludePath( String, usize, usize ),
            InvalidIncludeToken( Type, usize, usize ),
            InvalidNumeric( usize, usize ),
            InvalidValue( String, usize, usize ),
            InvalidValueChar( char, usize, usize ),
            MaxDepth( usize, usize ),
            UnaryOperatorError( Type, char, usize, usize ),
            UnexpectedEnd( usize ),
            VariableNotFound( String, usize, usize ),
            IoError( String ),
            OverError( String ),
            ParseIntError( String ),
        }

        #[derive( Debug )]
        pub struct ParseError 
        {

            pub file:Option<String>,
            pub kind: ParseErrorKind,
        }

        impl fmt::Display for ParseError 
        {
            fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
            {
                use self::ParseErrorKind::*;

                if let Some( ref file ) = ( *self ).file
                {
                    write!( f, "{}: ", file )?;
                }
                match ( *self ).kind
                {
                    BinaryOperatorError( ref expected, ref found, ref op, ref line, ref col ) => write!( 
                        f,
                        "Could not apply operator {} on types {} and {} at line {}, column {}",
                        op, expected, found, line, col,
                    ),
                    CyclicInclude( ref file, ref line, ref col ) => write!( 
                        f,
                        "Tried to cyclically include file \"{}\" at line {}, column {}",
                        file, line, col
                    ),
                    DuplicateField( ref field, ref line, ref col ) => write!( 
                        f,
                        "Duplicate field \"{}\" at line {}, column {}",
                        field, line, col
                    ),
                    DuplicateGlobal( ref field, ref line, ref col ) => write!( 
                        f,
                        "Duplicate global \"{}\" at line {}, column {}",
                        field, line, col
                    ),
                    ExpectedType( ref expected, ref found, ref line, ref col ) => write!( 
                        f,
                        "Expected {} at line {}, column {}; found {}",
                        expected, line, col, found
                    ),
                    GlobalNotFound( ref var, ref line, ref col ) => write!( 
                        f,
                        "Global \"{}\" at line {}, column {} could not be found",
                        var, line, col
                    ),
                    InvalidClosingBracket( ref expected, ref found, ref line, ref col ) => write!( 
                        f,
                        "Invalid closing bracket '{}' at line {}, column {}; expected {}",
                        found,
                        line,
                        col,
                        match *expected {
                            Some( ch ) => format!( "'{}'", ch ),
                            None => String::from( "none" ),
                        }
                    ),
                    InvalidDot( ref t, ref line, ref col ) => write!( 
                        f,
                        "Invalid use of dot notation on value of type {} at line {}, column {}; \
                        value must be an Obj, Arr, or Tup.",
                        t, line, col
                    ),
                    InvalidEscapeChar( ref ch, ref line, ref col ) => write!( 
                        f,
                        "Invalid escape character '\\{}' at line {}, column {}. \
                        If you meant to write a backslash, use '\\\\'",
                        format( *ch ),
                        line,
                        col
                    ),
                    InvalidFieldChar( ref ch, ref line, ref col ) => write!( 
                        f,
                        "Invalid character '{}' for field at line {}, column {}",
                        format( *ch ),
                        line,
                        col
                    ),
                    InvalidFieldName( ref field, ref line, ref col ) => write!( 
                        f,
                        "Invalid field name \"{}\" at line {}, column {}",
                        field, line, col
                    ),
                    InvalidIncludeChar( ref found, ref line, ref col ) => write!( 
                        f,
                        "Invalid include token character \'{}\' at line {}, column {}",
                        found, line, col
                    ),
                    InvalidIncludePath( ref path, ref line, ref col ) => write!( 
                        f,
                        "Invalid include path \"{}\" at line {}, column {}",
                        path, line, col
                    ),
                    InvalidIncludeToken( ref t, ref line, ref col ) => write!( 
                        f,
                        "Invalid value of type \"{}\" at line {}, column {}; \
                        must be either a Str value or one of the tokens \
                        \"Obj\", \"Arr\", \"Tup\", or \"Str\"",
                        t, line, col
                    ),
                    InvalidIndex( ref index, ref line, ref col ) => write!( 
                        f,
                        "Invalid index {} at line {}, column {}",
                        index, line, col
                    ),
                    InvalidNumeric( ref line, ref col ) => { write!( f, "Invalid numeric value at line {}, column {}", line, col ) }
                    InvalidValue( ref value, ref line, ref col ) => write!( 
                        f,
                        "Invalid value \"{}\" at line {}, column {}",
                        value, line, col
                    ),
                    InvalidValueChar( ref ch, ref line, ref col ) => write!( 
                        f,
                        "Invalid character '{}' for value at line {}, column {}",
                        format( *ch ),
                        line,
                        col
                    ),
                    MaxDepth( ref line, ref col ) => write!( 
                        f,
                        "Exceeded maximum recursion depth ( {} ) at line {}, column {}",
                        MAX_DEPTH, line, col
                    ),
                    UnaryOperatorError( ref found, ref op, ref line, ref col ) => write!( 
                        f,
                        "Could not apply operator {} on type {} at line {}, column {}",
                        op, found, line, col,
                    ),
                    UnexpectedEnd( ref line ) => write!( f, "Unexpected end at line {}", line, ),
                    VariableNotFound( ref var, ref line, ref col ) => write!( 
                        f,
                        "Variable \"{}\" at line {}, column {} could not be found",
                        var, line, col
                    ),
                    IoError( ref error ) | OverError( ref error ) | ParseIntError( ref error ) => { write!( f, "{}", error ) }
                }
            }
        }

        impl Error for ParseError 
        {
            fn description( &self ) -> &str {
                use self::ParseErrorKind::*;

                match ( *self ).kind {
                    BinaryOperatorError( _, _, _, _, _ ) | UnaryOperatorError( _, _, _, _ ) => { "Could not apply operator" }
                    CyclicInclude( _, _, _ ) => "Tried to cyclically include file",
                    DuplicateField( _, _, _ ) => "Duplicate field",
                    DuplicateGlobal( _, _, _ ) => "Duplicate global",
                    ExpectedType( _, _, _, _ ) => "Expected different type",
                    GlobalNotFound( _, _, _ ) => "Global could not be found",
                    InvalidClosingBracket( _, _, _, _ ) => "Invalid closing bracket",
                    InvalidDot( _, _, _ ) => "Invalid use of dot notation",
                    InvalidEscapeChar( _, _, _ ) => "Invalid escape character",
                    InvalidFieldChar( _, _, _ ) => "Invalid character for field",
                    InvalidFieldName( _, _, _ ) => "Invalid field name",
                    InvalidIncludeChar( _, _, _ ) => "Invalid include character",
                    InvalidIncludePath( _, _, _ ) => "Invalid include path",
                    InvalidIncludeToken( _, _, _ ) => "Invalid include token",
                    InvalidIndex( _, _, _ ) => "Invalid index",
                    InvalidNumeric( _, _ ) => "Invalid numeric value",
                    InvalidValue( _, _, _ ) => "Invalid value",
                    InvalidValueChar( _, _, _ ) => "Invalid character for value",
                    MaxDepth( _, _ ) => "Exceeded maximum depth for a container",
                    UnexpectedEnd( _ ) => "Unexpected end when reading value",
                    VariableNotFound( _, _, _ ) => "Variable could not be found",
                    IoError( ref error ) | OverError( ref error ) | ParseIntError( ref error ) => error,
                }
            }
        }

        impl ParseError 
        {

            pub fn from_over( e:&OverError, file:Option<String>, line: usize, col: usize ) -> Self {
                ParseError {
                    file,
                    kind: ParseErrorKind::OverError( format!( "{} at line {}, col {}", e, line, col ) ),
                }
            }
        }

        impl From<()> for ParseError 
        {
            fn from( e:() ) -> Self {
                ParseError {
                    file: None,
                    kind: ParseErrorKind::IoError( format!( "()" ) ),
                }
            }
        }


        impl From<io::Error> for ParseError 
        {
            fn from( e: io::Error ) -> Self {
                ParseError {
                    file: None,
                    kind: ParseErrorKind::IoError( format!( "{}", e ) ),
                }
            }
        }

        impl From<ParseIntError> for ParseError 
        {
            fn from( e: ParseIntError ) -> Self {
                ParseError {
                    file: None,
                    kind: ParseErrorKind::ParseIntError( format!( "{}", e ) ),
                }
            }
        }

        impl From<ParseBigIntError> for ParseError 
        {
            fn from( e: ParseBigIntError ) -> Self 
            {
                ParseError
                {
                    file: None,
                    kind: ParseErrorKind::ParseIntError( format!( "{}", e ) ),
                }
            }
        }
    } pub use self::parse::{ ParseError };

    pub mod no
    {
        /*!
        Cross-platform interface to the `errno` variable. */
        use ::
        {
            error::{ Error },
            *,
        };
        /*
        */
        pub mod sys
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub mod unix
            {
                /*!
                Implementation of `errno` functionality for Unix systems. */
                use ::
                {
                    error::no::{ Errno },
                    system::api::{ Result as Res, * },
                    *,
                };
                /*
                */
                fn from_utf8_lossy(input:&[u8] ) -> &str
                {
                    match str::from_utf8(input )
                    {
                        Ok(valid ) => valid,
                        Err(error ) => unsafe { str::from_utf8_unchecked( &input[..error.valid_up_to()]) },
                    }
                }

                pub fn with_description<F, T>(err: Errno, callback: F) -> T where
                F:FnOnce( ::result::Result<&str, Errno> ) -> T,
                {
                    let mut buf = [0u8; 1024];
                    let c_str = unsafe {
                        let rc = strerror_r(err.0, buf.as_mut_ptr() as *mut _, buf.len() as size_t );
                        if rc != 0
                        {
                            let fm_err = match rc < 0 {
                                true => errno(),
                                false => Errno( rc ),
                            };
                            if fm_err != Errno( ERANGE) {
                                return callback(Err( fm_err  ) );
                            }
                        }
                        let c_str_len = strlen( buf.as_ptr() as *const _ );
                        &buf[..c_str_len]
                    };
                    callback( Ok( from_utf8_lossy( c_str ) ) )
                }

                pub const STRERROR_NAME: &str = "strerror_r";

                pub fn errno() -> Errno {
                    unsafe { Errno(*errno_location() ) }
                }

                pub fn set_errno(Errno(errno): Errno) {
                    unsafe {
                        *errno_location() = errno;
                    }
                }

                extern "C" {
                    #[cfg_attr(
                        any(
                            target_os = "macos",
                            target_os = "ios",
                            target_os = "tvos",
                            target_os = "watchos",
                            target_os = "visionos",
                            target_os = "freebsd"
                        ),
                        link_name = "__error"
                    )]
                    #[cfg_attr(
                        any(
                            target_os = "openbsd",
                            target_os = "netbsd",
                            target_os = "android",
                            target_os = "espidf",
                            target_os = "vxworks",
                            target_os = "cygwin",
                            target_env = "newlib"
                        ),
                        link_name = "__errno"
                    )]
                    #[cfg_attr(
                        any( target_os = "solaris", target_os = "illumos" ),
                        link_name = "___errno"
                    )]
                    #[cfg_attr( target_os = "haiku", link_name = "_errnop" )]
                    #[cfg_attr(
                        any(
                            target_os = "linux",
                            target_os = "hurd",
                            target_os = "redox",
                            target_os = "dragonfly",
                            target_os = "emscripten",
                        ),
                        link_name = "__errno_location"
                    )]
                    #[cfg_attr( target_os = "aix", link_name = "_Errno" )]
                    #[cfg_attr( target_os = "nto", link_name = "__get_errno_ptr" )]
                    fn errno_location() -> *mut c_int;
                }
            }
            /*
            */
            pub mod windows
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
            }
            #[cfg( unix )] pub use self::unix::{ * };
            #[cfg( windows )] pub use self::windows::{ * };
        }

        #[derive( Copy, Clone, Eq, Ord, PartialEq, PartialOrd, Hash )]
        pub struct Errno( pub i32);

        impl fmt::Debug for Errno
        {
            fn fmt( &self, fmt: &mut fmt::Formatter ) -> fmt::Result
            {
                sys::with_description(*self, |desc|
                {
                    fmt.debug_struct( "Errno" )
                    .field( "code", &self.0)
                    .field( "description", &desc.ok() )
                    .finish()
                })
            }
        }

        impl fmt::Display for Errno
        {
            fn fmt( &self, fmt: &mut fmt::Formatter ) -> fmt::Result
            {
                sys::with_description(*self, |desc| match desc {
                    Ok(desc ) => fmt.write_str(desc ),
                    Err( fm_err ) => write!
                    (
                        fmt,
                        "OS error {} ({} returned error {})",
                        self.0,
                        sys::STRERROR_NAME,
                        fm_err.0
                    ),
                })
            }
        }

        impl From<Errno> for i32 {
            fn from(e: Errno) -> Self {
                e.0
            }
        }
        
        impl Error for Errno {
            // TODO: Remove when MSRV >= 1.27
            #[allow(deprecated )]
            fn description( &self ) -> &str { "system error" }
        }
        
        impl From<Errno> for io::Error {
            fn from(errno: Errno) -> Self {
                io::Error::from_raw_os_error(errno.0)
            }
        }

        pub fn errno() -> Errno {
            sys::errno()
        }

        pub fn set_errno(err: Errno) {
            sys::set_errno(err )
        }

    }

}

pub mod expand
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    
    // pub fn expand_home( text:&str ) -> String
    pub fn home( text:&str ) -> String
    {
        let mut s: String = text.to_string();
        let v = vec!
        [
            r"(?P<head> +)~(?P<tail> +)",
            r"(?P<head> +)~(?P<tail>/)",
            r"^(?P<head> *)~(?P<tail>/)",
            r"(?P<head> +)~(?P<tail> *$)",
        ];
        
        for item in &v
        {
            let re;

            if let Ok( x ) = Regex::new(item) { re = x; }
            else { return String::new(); }

            let home = get::user_home();
            let ss = s.clone();
            let to = format!( "$head{}$tail", home );
            let result = re.replace_all( ss.as_str(), to.as_str() );
            s = result.to_string();
        }

        s
    }
    // pub fn expand_glob( tokens: &mut types::Tokens )
    pub fn glob( tokens: &mut types::Tokens )
    {
        let mut idx: usize = 0;
        let mut buff = Vec::new();

        for ( sep, text ) in tokens.iter()
        {
            if !sep.is_empty() || !needs_globbing( text )
            {
                idx += 1;
                continue;
            }

            let mut result: Vec<String> = Vec::new();
            let item = text.as_str();

            if !item.contains('*') || item.trim().starts_with('\'') || item.trim().starts_with('"')
            { result.push(item.to_string() ); }

            else
            {
                let _basename = path::basename(item);
                let show_hidden = _basename.starts_with( ".*" );

                match ::path::glob( item )
                {
                    Ok( paths ) =>
                    {
                        let mut is_empty = true;
                        
                        for entry in paths
                        {
                            match entry
                            {
                                Ok( path ) =>
                                {
                                    let file_path = path.to_string_lossy();
                                    let _basename = path::basename( &file_path );

                                    if _basename == ".." || _basename == "." { continue; }

                                    if _basename.starts_with('.') && !show_hidden { continue; }

                                    result.push( file_path.to_string() );
                                    is_empty = false;
                                }

                                Err( e ) => { /*log!( "glob error: {:?}", e );*/ }
                            }
                        }

                        if is_empty { result.push(item.to_string() ); }
                    }

                    Err( e ) =>
                    {
                        println!( "glob error: {:?}", e );
                        result.push(item.to_string() );
                        return;
                    }
                }
            }

            buff.push((idx, result ) );
            idx += 1;
        }

        for (i, result ) in buff.iter().rev()
        {
            tokens.remove(*i);
            
            for (j, token ) in result.iter().enumerate()
            {
                let sep = if token.contains(' ') { "\"" } else { "" };
                tokens.insert(*i + j, ( sep.to_string(), token.clone() ) );
            }
        }
    }
}

pub mod get
{
    /*!
    use ::io::Write;
    Getter Setter Functionality */
    use ::
    {
        fs::{ File },
        path::{ Path, PathBuf },
        system::
        {
            api::{ c_char, size_t },
        },
        *,
    };
    /*
    */

    pub fn escaped_character( ch:char ) -> Option<char>
    {
        match ch
        {
            '\\' => Some( '\\' ),
            '"' => Some( '"' ),
            '\'' => Some( '\'' ),
            '$' => Some( '$' ),
            'n' => Some( '\n' ),
            'r' => Some( '\r' ),
            't' => Some( '\t' ),
            _ => None,
        }
    }
    // pub fn get_open_paren( ch:char ) -> Option<char>
    pub fn open_parenthesis( ch:char ) -> Option<char>
    {
        match ch
        {
            ')' => Some( '(' ),
            ']' => Some( '[' ),
            '}' => Some( '{' ),
            _ => None
        }
    }
    // pub fn get_current_dir() -> String
    pub fn current_directory() -> String
    {
        let mut current_dir = PathBuf::new();

        match env::current_dir() 
        {
            Ok( x ) => current_dir = x,
            Err( e ) =>
            {
                use ::io::Write;
                println_stderr!( "env current_dir() failed: {}", e );
            }
        }

        let mut str_current_dir = "";

        match current_dir.to_str() 
        {
            Some( x ) => str_current_dir = x,
            None =>
            {
                println_stderr!( "current_dir to str failed." );
            }
        }

        str_current_dir.to_string()
    }
    // pub fn get_user_name() -> String
    pub fn user_name() -> String
    {
        match env::var( "USER" )
        {
            Ok( x ) => { return x; }
            Err( e ) => { /* log!( ":: env USER error: {}", e ); */ }
        }

        let cmd_result = now::run( "whoami" );
        cmd_result.stdout.trim().to_string()
    }
    // pub fn get_user_home() -> String
    pub fn user_home() -> String
    {
        match env::var( "HOME" )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                use ::io::Write;
                println_stderr!( ":: env HOME error: {}", e );
                String::new()
            }
        }
    }
    // pub fn get_config_dir() -> String
    pub fn config_dir() -> String
    {
        if let Ok( x ) = env::var( "XDG_CONFIG_HOME" ) {
            format!( "{}/cicada", x)
        } else {
            let home = user_home();
            format!( "{}/.config/cicada", home )
        }
    }
    // pub fn get_user_completer_dir() -> String
    pub fn user_completer_dir() -> String
    {
        let dir_config = config_dir();
        format!( "{}/completers", dir_config)
    }
    // pub fn get_hostname() -> String
    pub fn hostname() -> String
    {
        let len = 255;
        let mut buf = Vec::<u8>::with_capacity(len );

        let ptr = buf.as_mut_slice().as_mut_ptr();

        let err = unsafe { hostname( ptr as *mut c_char, len as size_t ) } as i32;

        match err
        {
            0 =>
            {
                let real_len;
                let mut i = 0;
                
                loop
                {
                    let byte = unsafe { *((( ptr as u64) + (i as u64 ) ) as *const u8) };
                    if byte == 0 {
                        real_len = i;
                        break;
                    }

                    i += 1;
                }
                
                unsafe { buf.set_len( real_len ) }
                String::from_utf8_lossy( buf.as_slice() ).into_owned()
            }
            _ => String::from( "unknown" ),
        }
    }
    // pub fn get_fd_from_file( file_name:&str ) -> i32
    pub fn fd_from_file( file_name:&str ) -> i32
    {
        let path = Path::new( file_name );
        let display = path.display();
        let file = match File::open( path ) {
            Err(why) => 
            {
                use ::io::Write;
                println_stderr!( ":: {}: {}", display, why);
                return -1;
            }
            Ok( file ) => file,
        };
        file.into_raw_fd()
    }
    // pub fn get_prompt_len( prompt:&str ) -> i32
    pub fn prompt_len( prompt:&str ) -> i32
    {
        let mut count = 0;
        let mut met_x01 = false;
        for c in prompt.chars() {
            if c == '\x01' {
                met_x01 = true;
                continue;
            } else if c == '\x02' {
                met_x01 = false;
                continue;
            }
            if !met_x01 {
                count += 1;
            }
        }
        count
    }
}

pub mod f32
{
    pub use std::f32::{ * };
}

pub mod f64
{
    pub use std::f64::{ * };
}

pub mod ffi
{
    pub use std::ffi::{ * };
}

pub mod fmt
{
    /*!
    Module containing functions for formatting output of objects. */
    pub use std::fmt::{ * };    
    use ::
    {
        arrays::{ Arr },
        num::
        {
            big::{ BigInt },
            rational::{ BigRational },
            traits::{ One },
        },
        objects::{ Obj },
        tuples::{ Tup },
        values::{ Value },
        *,
    };
    /*
    use crate::INDENT_STEP;
    */
   
    fn indent( amount: usize ) -> String 
    {
        " ".repeat( amount )
    }

    fn get_char_map( ch:char ) -> Option<&'static str> 
    {
        match ch
        {
            '\\' => Some( "\\\\" ),
            '\"' => Some( "\\\"" ),
            '\'' => Some( "\\\'" ),
            '$' => Some( "\\$" ),
            '\n' => Some( "\\n" ),
            '\r' => Some( "\\r" ),
            '\t' => Some( "\\t" ),
            _ => None,
        }
    }

    fn replace_all( s:&str ) -> String 
    {
        let mut string = String::with_capacity( s.len() );

        for ch in s.chars() 
        {
            if let Some( s ) = get_char_map( ch  ) { string.push_str( s  ); }            
            else { string.push( ch  ); }
        }

        string
    }

    pub trait Format 
    {
        fn format( &self, full: bool, indent_amt: usize ) -> String;
    }

    impl Format for BigRational 
    {
        fn format( &self, _full: bool, _indent_amt: usize ) -> String {
            let frac_fmt = format!( "{}", *self );

            if *self.denom() == BigInt::one() {
                format!( "{}.0", frac_fmt )
            } else {
                frac_fmt
            }
        }
    }

    impl Format for char 
    {
        fn format( &self, _full: bool, _indent_amt: usize ) -> String {
            if let Some( s ) = get_char_map( *self ) {
                format!( "\'{}\'", s )
            } else {
                format!( "\'{}\'", *self )
            }
        }
    }

    impl Format for String 
    {
        fn format( &self, _full: bool, _indent_amt: usize ) -> String {
            format!( "\"{}\"", replace_all( self ) )
        }
    }

    impl Format for Value 
    {
        fn format( &self, _full: bool, indent_amt: usize ) -> String
        {
            match *self
            {
                Value::Null => String::from( "null" ),
                Value::Bool( ref inner ) =>
                {
                    if *inner {
                        String::from( "true" )
                    } else {
                        String::from( "false" )
                    }
                }

                Value::Int( ref inner ) => format!( "{}", inner ),
                Value::Integer( ref inner ) => format!( "{}", inner ),
                Value::Frac( ref inner ) => inner.format( true, indent_amt ),
                Value::Char( ref inner ) => inner.format( true, indent_amt ),
                Value::Str( ref inner ) => inner.format( true, indent_amt ),
                Value::Strand( ref inner ) => inner.format( true, indent_amt ),
                Value::Arr( ref inner ) => inner.format( true, indent_amt ),
                Value::Tup( ref inner ) => inner.format( true, indent_amt ),
                Value::Obj( ref inner ) => inner.format( true, indent_amt ),
            }
        }
    }

    impl Format for Arr 
    {
        fn format( &self, full: bool, indent_amt: usize ) -> String 
        {
            match self.len() {
                0 => {
                    if full {
                        String::from( "[]" )
                    } else {
                        String::new()
                    }
                }
                1 => {
                    let f = self.get( 0 ).unwrap().format( true, indent_amt );
                    if full {
                        format!( "[{}]", f )
                    } else {
                        f
                    }
                }
                _ => {
                    let mut s = if full {
                        String::from( "[\n" )
                    } else {
                        String::new()
                    };

                    self.with_each( |value| {
                        s.push_str( &format!( 
                            "{}{}\n",
                            indent( indent_amt ),
                            value.format( true, indent_amt + INDENT_STEP )
                        ) )
                    } );

                    if full {
                        let actual_indent_amt = if indent_amt == 0 {
                            0
                        } else {
                            indent_amt - INDENT_STEP
                        };
                        s.push_str( &format!( "{}]", indent( actual_indent_amt ) ) );
                    }
                    s
                }
            }
        }
    }

    impl Format for Tup 
    {
        fn format( &self, full: bool, indent_amt: usize ) -> String 
        {
            match self.len() {
                0 => {
                    if full {
                        String::from( "()" )
                    } else {
                        String::new()
                    }
                }
                1 => {
                    let f = self.get( 0 ).unwrap().format( true, indent_amt );
                    if full {
                        format!( "( {} )", f )
                    } else {
                        f
                    }
                }
                _ => {
                    let mut s = if full {
                        String::from( "( \n" )
                    } else {
                        String::new()
                    };

                    self.with_each( |value| {
                        s.push_str( &format!( 
                            "{}{}\n",
                            indent( indent_amt ),
                            value.format( true, indent_amt + INDENT_STEP )
                        ) )
                    } );

                    if full {
                        s.push_str( &format!( "{} )", indent( indent_amt - INDENT_STEP ) ) );
                    }
                    s
                }
            }
        }
    }

    impl Format for Obj 
    {
        fn format( &self, full: bool, indent_amt: usize ) -> String {
            if self.is_empty() && !self.has_parent() {
                if full {
                    String::from( "{}" )
                } else {
                    String::new()
                }
            } else {
                let mut s = if full {
                    String::from( "{\n" )
                } else {
                    String::new()
                };

                if let Some( parent ) = self.get_parent() {
                    s.push_str( &format!( 
                        "{}^: {}\n",
                        indent( indent_amt ),
                        parent.format( true, indent_amt + INDENT_STEP )
                    ) );
                }
                self.with_each( |field, value| {
                    s.push_str( &format!( 
                        "{}{}: {}\n",
                        indent( indent_amt ),
                        field,
                        value.format( true, indent_amt + INDENT_STEP )
                    ) );
                } );

                if full {
                    s.push_str( &format!( "{}}}", indent( indent_amt - INDENT_STEP ) ) );
                }
                s
            }
        }
    }
}

pub mod fs
{
    pub use std::fs::{ * };
}

pub mod has
{
    /*!
    */
    use ::
    {
        system::api::
        {
            tcgetpgrp, getpgid
        },
        *,
    };
    /*
    */
    // fn proc_has_terminal() -> bool
    pub fn terminal() -> bool
    {
        unsafe
        {
            let tgid = tcgetpgrp( 0 );
            let pgid = getpgid( 0 );
            tgid == pgid
        }
    }
}

pub mod hash
{
    pub use std::hash::{ * };
}

pub mod highlights
{
    /*!
    */
    use ::
    {
        collections::{ HashSet },
        ops::{ Range },
        os::{ unix::fs::PermissionsExt },
        sync::{ Arc, Mutex },
        *,
    };
    /*
    use crate::parsers::parser_line;
    */

    pub const RESET_STYLE: &str = "\x1b[0m";
    pub const GREEN: &str = "\x1b[0;32m";

    lazy_static!
    {
        pub static ref AVAILABLE_COMMANDS: Mutex<HashSet<String>> = Mutex::new(HashSet::new() );
        pub static ref ALIASES: Mutex<HashSet<String>> = Mutex::new(HashSet::new() );
    }

    #[derive( Clone )]
    pub struct CicadaHighlighter;

    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum Style 
    {

        AnsiColor(String),
        Default,
    }

    pub trait Highlighter
    {

        fn highlight( &self, line:&str ) -> Vec<(Range<usize>, Style )>;
    }

    pub fn initialize()
    {
        let commands = scan_available_commands();
        if let Ok( mut cache ) = AVAILABLE_COMMANDS.lock() { *cache = commands; }
    }

    pub fn update( sh: &shell::Shell) 
    {
        if let Ok( mut aliases ) = ALIASES.lock()
        {
            aliases.clear();

            for alias_name in sh.aliases.keys()
            {
                aliases.insert( alias_name.clone() );
            }
        }
    }

    pub fn scan() -> HashSet<String> 
    {
        let mut commands = HashSet::new();

        if let Ok( path_var ) = env::var( "PATH" )
        {
            for dir_path in env::split_paths( &path_var )
            {
                if !dir_path.is_dir() { continue; }

                if let Ok(entries ) = fs::read_dir(dir_path ) 
                {
                    for entry in entries.filter_map(Result::ok) 
                    {
                        if let Ok( file_type ) = entry.file_type() 
                        {
                            if file_type.is_file() || file_type.is_symlink() 
                            {
                                if let Ok(metadata ) = entry.metadata() 
                                {
                                    if metadata.permissions().mode() & 0o111 != 0 
                                    {
                                        if let Some( name ) = entry.file_name().to_str()
                                        { commands.insert( name.to_string() ); }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        commands
    }

    fn find( line: &str, start_byte: usize, token: &(String, String) ) -> Option<Range<usize>> 
    {
        let ( sep, word ) = token;
        let mut search_area = &line[start_byte..];

        let token_start_byte = if let Some( non_ws_offset ) = search_area.find(|c:char| !c.is_whitespace() )
        {
            start_byte + search_area
            .char_indices()
            .nth( non_ws_offset )
            .map_or(0, |(idx, _ )| idx)
        }
        else { return None; };

        search_area = &line[token_start_byte..];
        let mut estimated_len = 0;
        let mut current_search_offset = 0;
        
        if !sep.is_empty() && search_area.starts_with( sep)
        {
            estimated_len += sep.len();
            current_search_offset += sep.len();
        }
        
        if search_area[current_search_offset..].starts_with(word )
        {
            estimated_len += word.len();
            current_search_offset += word.len();
            
            if !sep.is_empty() && search_area[current_search_offset..].starts_with( sep) { estimated_len += sep.len(); }

            Some( token_start_byte..( token_start_byte + estimated_len ) )
        }
        
        else if word.is_empty()
        && !sep.is_empty()
        && search_area.starts_with( sep)
        && search_area[sep.len()..].starts_with( sep)
        {
            estimated_len += sep.len() * 2;
            Some( token_start_byte..( token_start_byte + estimated_len ) )
        }

        else
        {
            if search_area.starts_with(word ) { Some( token_start_byte..( token_start_byte + word.len() ) ) }
            else { None }
        }
    }

    impl Highlighter for CicadaHighlighter 
    {
        fn highlight( &self, line:&str ) -> Vec<(Range<usize>, Style )> 
        {
            let mut styles = Vec::new();
            if line.is_empty() { return styles; }

            let line_info = parser_line::parse_line(line );
            
            if line_info.tokens.is_empty()
            {
                styles.push((0..line.len(), Style::Default ) );
                return styles;
            }

            let mut current_byte_idx = 0;
            let mut is_start_of_segment = true;

            for token in &line_info.tokens
            {
                match find_token_range_heuristic(line, current_byte_idx, token )
                {
                    Some( token_range ) =>
                    {
                        if token_range.start > current_byte_idx {
                            styles.push(( current_byte_idx..token_range.start, Style::Default ) );
                        }

                        let (_sep, word ) = token;
                        let mut current_token_style = Style::Default;

                        if is_start_of_segment && !word.is_empty() {
                            if is_command(word ) {
                                current_token_style = Style::AnsiColor(GREEN.to_string() );
                            }
                            is_start_of_segment = false;
                        }

                        styles.push(( token_range.clone(), current_token_style  ) );
                        
                        if ["|","&&","||",";"].contains( &word.as_str() ) {
                            is_start_of_segment = true;
                        }

                        current_byte_idx = token_range.end;
                    }

                    None => 
                    {
                        if current_byte_idx < line.len() 
                        { styles.push(( current_byte_idx..line.len(), Style::Default ) ); }

                        current_byte_idx = line.len();
                        break;
                    }
                }
            }
            
            if current_byte_idx < line.len() { styles.push(( current_byte_idx..line.len(), Style::Default ) ); }

            styles
        }
    }

    pub fn create() -> Arc<CicadaHighlighter> { Arc::new( CicadaHighlighter ) }
}

pub mod i8
{
    pub use std::i8::{ * };
}

pub mod i16
{
    pub use std::i16::{ * };
}

pub mod i32
{
    pub use std::i32::{ * };
}

pub mod i64
{
    pub use std::i64::{ * };
}

pub mod is
{
    /*!
    Identity Signature*/
    use ::
    {
        *,
    };
    /*
    */

    pub fn value_end_char( ch:char ) -> bool 
    {
        whitespace( ch ) || end_delimiter( ch ) || operator( ch )
    }

    pub fn whitespace( ch:char ) -> bool 
    {
        ch.is_whitespace() || ch == '#'
    }
   
    pub fn end_delimiter( ch:char ) -> bool 
    {
        match ch {
            ')' | ']' | '}' | '>' => true,
            _ => false,
        }
    }
   
    pub fn numeric_char( ch:char ) -> bool 
    {
        match ch {
            _ch if digit( _ch ) => true,
            '.' | ',' => true,
            _ => false,
        }
    }
   
    pub fn priority_operator( ch:char ) -> bool 
    {
        match ch {
            '*' | '/' | '%' => true,
            _ => false,
        }
    }
   
    pub fn operator( ch:char ) -> bool 
    {
        match ch {
            '+' | '-' | '*' | '/' | '%' => true,
            _ => false,
        }
    }

    //pub fn is_digit( ch:char ) -> bool {
    pub fn digit( ch:char ) -> bool 
    {
        match ch {
            '0'..='9' => true,
            _ => false,
        }
    }
   
    pub fn reserved( field:&str ) -> bool 
    {
        match field {
            "@" | "null" | "true" | "false" | "Obj" | "Str" | "Arr" | "Tup" => true,
            _ => false,
        }
    }

    /*
    pub fn is_xid_start( ... ) -> bool*/
    pub fn xid_start( ch:char ) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_START.0[ch as usize]; }
        let chunk = * ::ascii::TRIE_START.0.get( ch as usize / 8 / ::ascii::CHUNK ).unwrap_or( &0 );
        let offset = chunk as usize *  ::ascii::CHUNK / 2 + ch as usize / 8 %  ::ascii::CHUNK;
        unsafe {  ::ascii::LEAF.0.get_unchecked( offset ) }.wrapping_shr( ch as u32 % 8 ) & 1 != 0
    }

    /*
    pub fn is_xid_continue( ch:char ) -> bool */
    pub fn xid_continue( ch:char ) -> bool
    {
        if ch.is_ascii() { return ::ascii::ASCII_CONTINUE.0[ch as usize]; }
        let chunk = *::ascii::TRIE_CONTINUE.0.get( ch as usize / 8 / ::ascii::CHUNK ).unwrap_or( &0 );
        let offset = chunk as usize * ::ascii::CHUNK / 2 + ch as usize / 8 % ::ascii::CHUNK;
        unsafe { ::ascii::LEAF.0.get_unchecked( offset ) }.wrapping_shr( ch as u32 % 8 ) & 1 != 0
    }
    /*
    pub fn is_ident_start( c:char ) -> bool*/
    pub fn ident_start( c:char ) -> bool
    {
        c == '_' || xid_start( c )
    }
    /*
    pub fn is_ident_continue( c:char ) -> bool */
    pub fn ident_continue( c:char ) -> bool
    {
        xid_continue( c )
    }

    // #[inline] pub fn is_combining_mark( ch:char ) -> bool
    #[inline] pub fn combining_mark( ch:char ) -> bool
    {
        use unicode::normalization::char::is_combining_mark;
        is_combining_mark( ch )
    }

    // #[inline] pub fn is_ctrl( ch:char ) -> bool
    #[inline] pub fn control( ch:char ) -> bool
    {
        let ch = ch as u32;
        ch & ( 0x1f as u32 ) == ch
    }
    // pub fn is_visible( ch:char ) -> bool
    pub fn visible( ch:char ) -> bool
    {
        match ch
        {
            '\t' | '\r' | '\n' => true,
            _ => char::width( ch ).unwrap_or( 0 ) != 0
        }
    }    
    // fn is_xterm( name:&str ) -> bool
    pub fn xterm( name:&str ) -> bool
    {
        // Includes such terminal names as "xterm-256color"
        name == "xterm" || name.starts_with( "xterm-" )
    }
    // pub fn is_wide( ch:char ) -> bool
    pub fn wide( ch:char ) -> bool
    {
        char::width( ch ) == Some( 2 )
    }    
    // pub fn is_env(line:&str ) -> bool
    pub fn env(line:&str ) -> bool
    {
        regex::contains(line, r"^[a-zA-Z_][a-zA-Z0-9_]*=.*$" )
    }
    // pub fn is_signal_handler_enabled() -> bool
    pub fn signal_handler_enabled() -> bool
    {
        env::var( "CICADA_ENABLE_SIG_HANDLER" ).is_ok_and(|x| x == "1" )
    }
    // pub fn is_arithmetic(line:&str ) -> bool
    pub fn arithmetic(line:&str ) -> bool
    {
        if !regex::contains(line, r"[0-9]+" ) { return false; }
        if !regex::contains(line, r"\+|\-|\*|/|\^" ) { return false; }
        regex::contains(line, r"^[ 0-9\.\(\)\+\-\*/\^]+[\.0-9 \)]$" )
    }
    // pub fn is_builtin( s:&str ) -> bool
    pub fn builtin( s:&str ) -> bool
    {
        let builtins = 
        [
            "alias","bg","cd","cinfo","exec","exit","export","fg","history","jobs","read","source", 
            "ulimit","unalias","vox","minfd","set","unset","unpath",
        ];

        builtins.contains( &s )
    }
    // pub fn is_shell_altering_command(line:&str ) -> bool
    pub fn shell_altering_command(line:&str ) -> bool
    {
        let line = line.trim();
        if regex::contains( line, r"^[A-Za-z_][A-Za-z0-9_]*=.*$" ) { return true; }

        line.starts_with( "alias " )
        || line.starts_with( "export " )
        || line.starts_with( "unalias " )
        || line.starts_with( "unset " )
        || line.starts_with( "source " )
    }
    // pub fn is_login( args:&[String] ) -> bool
    pub fn login( args:&[String] ) -> bool
    {
        if !args.is_empty() && args[0].starts_with( "-" ) { return true; }

        if args.len() > 1 && ( args[1] == "--login" || args[1] == "-l" ) { return true; }

        if let Ok( term_program) = ::env::var( "TERM_PROGRAM" )
        {
            if term_program == "vscode" { return true; }
        }

        false
    }
    // pub fn is_script( args:&[String] ) -> bool 
    pub fn script( args:&[String] ) -> bool { args.len() > 1 && !args[1].starts_with( "-" ) }
    // pub fn is_command_string( args:&[String] ) -> bool
    pub fn command_string( args:&[String] ) -> bool { args.len() > 1 && args[1] == "-c" }
    // pub fn is_non_tty() -> bool 
    pub fn non_tty() -> bool { unsafe { ::system::api::isatty( 0 ) == 0 } }

    // pub fn is_command(word:&str ) -> bool
    pub fn command(word:&str ) -> bool
    {
        if builtin(word ) { return true; }

        if let Ok( aliases ) = ::highlights::ALIASES.lock()
        {
            if aliases.contains(word ) { return true; }
        }

        if let Ok( commands ) = ::highlights::AVAILABLE_COMMANDS.lock()
        {
            if commands.contains(word ) { return true; }
        }

        false
    }
    // pub fn is_prefix_char( c:char ) -> bool
    pub fn prefix_char( c:char ) -> bool { c == '[' || c == '{' }
    //pub fn is_suffix_char( c:char ) -> bool
    pub fn suffix_char( c:char ) -> bool { c == ']' || c == '}' }
    // pub fn is_prompt_item_char( c:char, token:&str ) -> bool
    pub fn prompt_item_char( c:char, token:&str ) -> bool
    {
        let s = c.to_string();
        if token.is_empty() { regex::contains( &s, r#"^[a-zA-Z_]$"#) }
        else { regex::contains( &s, r#"^[a-zA-Z0-9_]$"#) }
    }

    pub fn tty( fd:system::api::c_int ) -> bool
    {
        system::api::isatty( fd )
    }
    // pub fn is_meta_character(c: char) -> bool

    pub fn meta_character(c: char) -> bool
    {
        match c
        {
            '\\'|'.'|'+'|'*'|'?'|'('|')'|'|'|'['|']'|'{'|'}'|'^'|'$'|'#'|'&'|'-'|'~' => true,
            _ => false,
        }
    }
    // pub fn is_escapeable_character(c: char) -> bool

    pub fn escapeable_character(c: char) -> bool
    {
        if meta_character(c) { return true; }
        
        if !c.is_ascii() { return false; }

        match c
        {
            '0'..='9' | 'A'..='Z' | 'a'..='z' => false,
            '<' | '>' => false,
            _ => true,
        }
    }
    // pub fn is_word_character(c: char) -> bool

    pub fn word_character(c: char) -> bool
    {
        try_word_character(c).expect("unicode-perl feature must be enabled")
    }

    pub fn try_word_character( c: char ) -> Result<bool, UnicodeWordError> { unicode::is_word_character(c) }
    // pub fn is_word_byte(c: u8) -> bool

    pub fn word_byte(c: u8) -> bool
    {
        match c
        {
            b'_' | b'0'..=b'9' | b'a'..=b'z' | b'A'..=b'Z' => true,
            _ => false,
        }
    }
}

pub mod isize
{
    pub use std::isize::{ * };
}

pub mod i128
{
    pub use std::i128::{ * };
}

pub mod io
{
    pub use std::io::{ * };
}

pub mod iter
{
    pub use std::iter::{ * };
    
    pub fn drop_while<I, T, F>( iter:&mut I, mut f: F ) where
    I: Iterator<Item=T> + Clone, F: FnMut( T ) -> bool
    {
        loop {
            let mut clone = iter.clone();

            match clone.next() {
                None => break,
                Some( t ) => {
                    if f( t ) {
                        *iter = clone;
                    } else {
                        break;
                    }
                }
            }
        }
    }
}

pub mod marker
{
    pub use std::marker::{ * };
    use ::
    {
        rc::{ Rc },
        panic::{ RefUnwindSafe, UnwindSafe },
        *,
    };
    /*
    */
    pub const MARKER: ProcMacroAutoTraits = ProcMacroAutoTraits( PhantomData );

    #[derive( Copy, Clone, PartialEq, Eq )]
    pub struct ProcMacroAutoTraits( pub PhantomData<Rc<()>>  );
    impl UnwindSafe for ProcMacroAutoTraits {}
    impl RefUnwindSafe for ProcMacroAutoTraits {}
}

pub mod num
{
    pub use std::num::{ * };
    use ::
    {
        *,
    };
    /*
    */
    pub mod traits
    {
        //! Numeric traits for generic mathematics
        use ::
        {
            num::{ Wrapping },
            ops::{ Add, Div, Mul, Rem, Sub, AddAssign, DivAssign, MulAssign, RemAssign, SubAssign },
            *,
        };
        /*
        */
        pub mod bounds
        {
            use ::
            {
                num::
                {
                    NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize, NonZeroU128,
                    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize, Wrapping,
                },
                *,
            };
            /*
            */

            pub trait Bounded
            {
               

                fn min_value() -> Self;
                fn max_value() -> Self;
            }

            pub trait LowerBounded
            {
                fn min_value() -> Self;
            }
           
            impl<T: Bounded> LowerBounded for T
            {
                fn min_value() -> T {
                    Bounded::min_value()
                }
            }

            pub trait UpperBounded
            {
                fn max_value() -> Self;
            }
           
            impl<T: Bounded> UpperBounded for T
            {
                fn max_value() -> T {
                    Bounded::max_value()
                }
            }
            macro_rules! bounded_impl
            {
                ( $t:ty, $min:expr, $max:expr ) =>
                {
                    impl Bounded for $t {
                        #[inline] fn min_value() -> $t {
                            $min
                        }

                        #[inline] fn max_value() -> $t {
                            $max
                        }
                    }
                };
            }
            bounded_impl!( usize, usize::MIN, usize::MAX );
            bounded_impl!( u8, u8::MIN, u8::MAX );
            bounded_impl!( u16, u16::MIN, u16::MAX );
            bounded_impl!( u32, u32::MIN, u32::MAX );
            bounded_impl!( u64, u64::MIN, u64::MAX );
            bounded_impl!( u128, u128::MIN, u128::MAX );

            bounded_impl!( isize, isize::MIN, isize::MAX );
            bounded_impl!( i8, i8::MIN, i8::MAX );
            bounded_impl!( i16, i16::MIN, i16::MAX );
            bounded_impl!( i32, i32::MIN, i32::MAX );
            bounded_impl!( i64, i64::MIN, i64::MAX );
            bounded_impl!( i128, i128::MIN, i128::MAX );

            macro_rules! bounded_impl_nonzero_const 
            {
                ( $t:ty, $v:expr, $i:ident ) => {
                    const $i: $t = match <$t>::new( $v ) {
                        Some( nz ) => nz,
                        None => panic!( "bad nonzero bound!" ),
                    };
                };
            }
            macro_rules! bounded_impl_nonzero 
            {
                ( $t:ty, $min:expr, $max:expr ) => {
                    impl Bounded for $t {
                        #[inline] fn min_value() -> $t {
                           
                            bounded_impl_nonzero_const!( $t, $min, MIN );
                            MIN
                        }

                        #[inline] fn max_value() -> $t {
                           
                            bounded_impl_nonzero_const!( $t, $max, MAX );
                            MAX
                        }
                    }
                };
            }
            bounded_impl_nonzero!( NonZeroUsize, 1, usize::MAX );
            bounded_impl_nonzero!( NonZeroU8, 1, u8::MAX );
            bounded_impl_nonzero!( NonZeroU16, 1, u16::MAX );
            bounded_impl_nonzero!( NonZeroU32, 1, u32::MAX );
            bounded_impl_nonzero!( NonZeroU64, 1, u64::MAX );
            bounded_impl_nonzero!( NonZeroU128, 1, u128::MAX );

            bounded_impl_nonzero!( NonZeroIsize, isize::MIN, isize::MAX );
            bounded_impl_nonzero!( NonZeroI8, i8::MIN, i8::MAX );
            bounded_impl_nonzero!( NonZeroI16, i16::MIN, i16::MAX );
            bounded_impl_nonzero!( NonZeroI32, i32::MIN, i32::MAX );
            bounded_impl_nonzero!( NonZeroI64, i64::MIN, i64::MAX );
            bounded_impl_nonzero!( NonZeroI128, i128::MIN, i128::MAX );

            impl<T: Bounded> Bounded for Wrapping<T> 
            {
                fn min_value() -> Self {
                    Wrapping( T::min_value() )
                }
                fn max_value() -> Self {
                    Wrapping( T::max_value() )
                }
            }
            bounded_impl!( f32, f32::MIN, f32::MAX );

            macro_rules! for_each_tuple_ 
            {
                ( $m:ident !! ) => ( 
                    $m! { }
                 );
                ( $m:ident !! $h:ident, $( $t:ident, )* ) => ( 
                    $m! { $h $( $t )* }
                    for_each_tuple_! { $m !! $( $t, )* }
                 );
            }
            macro_rules! for_each_tuple 
            {
                ( $m:ident ) => { for_each_tuple_! { $m !! A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, } };
            }
            macro_rules! bounded_tuple 
            {
                ( $( $name:ident )* ) => ( 
                    impl<$( $name: Bounded, )*> Bounded for ( $( $name, )* ) {
                        #[inline] fn min_value() -> Self {
                            ( $( $name::min_value(), )* )
                        }

                        #[inline] fn max_value() -> Self {
                            ( $( $name::max_value(), )* )
                        }
                    }
                 );
            }
            for_each_tuple!( bounded_tuple );
            bounded_impl!( f64, f64::MIN, f64::MAX );
        } pub use self::bounds::Bounded;

        pub mod cast
        {
            use ::
            {
                mem::{ size_of },
                num::
                {
                    NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize, NonZeroU128,
                    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize, Wrapping,
                },
                *,
            };
            /*
            */

            pub trait ToPrimitive
            {

                #[inline] fn to_isize( &self ) -> Option<isize> { self.to_i64().as_ref().and_then( ToPrimitive::to_isize ) }

                #[inline] fn to_i8( &self ) -> Option<i8> { self.to_i64().as_ref().and_then( ToPrimitive::to_i8 ) }

                #[inline] fn to_i16( &self ) -> Option<i16> { self.to_i64().as_ref().and_then( ToPrimitive::to_i16 ) }

                #[inline] fn to_i32( &self ) -> Option<i32> { self.to_i64().as_ref().and_then( ToPrimitive::to_i32 ) }

                fn to_i64( &self ) -> Option<i64>;

                #[inline] fn to_i128( &self ) -> Option<i128> { self.to_i64().map( From::from ) }

                #[inline] fn to_usize( &self ) -> Option<usize> { self.to_u64().as_ref().and_then( ToPrimitive::to_usize ) }

                #[inline] fn to_u8( &self ) -> Option<u8> { self.to_u64().as_ref().and_then( ToPrimitive::to_u8 ) }

                #[inline] fn to_u16( &self ) -> Option<u16> { self.to_u64().as_ref().and_then( ToPrimitive::to_u16 ) }

                #[inline] fn to_u32( &self ) -> Option<u32> { self.to_u64().as_ref().and_then( ToPrimitive::to_u32 ) }

                fn to_u64( &self ) -> Option<u64>;

                #[inline] fn to_u128( &self ) -> Option<u128> { self.to_u64().map( From::from ) }

                #[inline] fn to_f32( &self ) -> Option<f32> { self.to_f64().as_ref().and_then( ToPrimitive::to_f32 ) }

                #[inline] fn to_f64( &self ) -> Option<f64> {
                    match self.to_i64() {
                        Some( i ) => i.to_f64(),
                        None => self.to_u64().as_ref().and_then( ToPrimitive::to_f64 ),
                    }
                }
            }
            macro_rules! impl_to_primitive_int_to_int 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT>
                    {
                        let min = $DstT::MIN as $SrcT;
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || ( min <= *self && *self <= max ) {
                            Some( *self as $DstT )
                        } else {
                            None
                        }
                    }
                )*}
            }
            macro_rules! impl_to_primitive_int_to_uint 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT>
                    {
                        let max = $DstT::MAX as $SrcT;
                        if 0 <= *self && ( size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max ) {
                            Some( *self as $DstT )
                        } else {
                            None
                        }
                    }
                )*}
            }
            macro_rules! impl_to_primitive_int 
            {
                ( $T:ident ) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_int_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }
                        impl_to_primitive_int_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline] fn to_f32( &self ) -> Option<f32> { Some( *self as f32 ) }

                        #[inline] fn to_f64( &self ) -> Option<f64> { Some( *self as f64 ) }
                    }
                };
            }
            impl_to_primitive_int!( isize );
            impl_to_primitive_int!( i8 );
            impl_to_primitive_int!( i16 );
            impl_to_primitive_int!( i32 );
            impl_to_primitive_int!( i64 );
            impl_to_primitive_int!( i128 );

            macro_rules! impl_to_primitive_uint_to_int 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT>
                    {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() < size_of::<$DstT>() || *self <= max {
                            Some( *self as $DstT )
                        } else {
                            None
                        }
                    }
                )*}
            }
            macro_rules! impl_to_primitive_uint_to_uint 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT>
                    {
                        let max = $DstT::MAX as $SrcT;
                        if size_of::<$SrcT>() <= size_of::<$DstT>() || *self <= max {
                            Some( *self as $DstT )
                        } else {
                            None
                        }
                    }
                )*}
            }
            macro_rules! impl_to_primitive_uint 
            {
                ( $T:ident ) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_uint_to_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }
                        impl_to_primitive_uint_to_uint! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }

                        #[inline] fn to_f32( &self ) -> Option<f32> { Some( *self as f32 ) }

                        #[inline] fn to_f64( &self ) -> Option<f64> { Some( *self as f64 ) }
                    }
                };
            }
            impl_to_primitive_uint!( usize );
            impl_to_primitive_uint!( u8 );
            impl_to_primitive_uint!( u16 );
            impl_to_primitive_uint!( u32 );
            impl_to_primitive_uint!( u64 );
            impl_to_primitive_uint!( u128 );

            macro_rules! impl_to_primitive_nonzero_to_method 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT> { self.get().$method() }
                )*}
            }
            macro_rules! impl_to_primitive_nonzero 
            {
                ( $T:ident ) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_nonzero_to_method! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;

                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;

                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }
            impl_to_primitive_nonzero!( NonZeroUsize );
            impl_to_primitive_nonzero!( NonZeroU8 );
            impl_to_primitive_nonzero!( NonZeroU16 );
            impl_to_primitive_nonzero!( NonZeroU32 );
            impl_to_primitive_nonzero!( NonZeroU64 );
            impl_to_primitive_nonzero!( NonZeroU128 );

            impl_to_primitive_nonzero!( NonZeroIsize );
            impl_to_primitive_nonzero!( NonZeroI8 );
            impl_to_primitive_nonzero!( NonZeroI16 );
            impl_to_primitive_nonzero!( NonZeroI32 );
            impl_to_primitive_nonzero!( NonZeroI64 );
            impl_to_primitive_nonzero!( NonZeroI128 );

            macro_rules! impl_to_primitive_float_to_float 
            {
                ( $SrcT:ident : $( fn $method:ident -> $DstT:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$DstT> { Some( *self as $DstT ) }
                )*}
            }
            macro_rules! float_to_int_unchecked 
            {
               
               
                ( $float:expr => $int:ty ) => { unsafe { $float.to_int_unchecked::<$int>() } };
            }
            macro_rules! impl_to_primitive_float_to_signed_int 
            {
                ( $f:ident : $( fn $method:ident -> $i:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$i> {
                       
                       
                        if size_of::<$f>() > size_of::<$i>() {
                           
                            const MIN_M1: $f = $i::MIN as $f - 1.0;
                            const MAX_P1: $f = $i::MAX as $f + 1.0;
                            if *self > MIN_M1 && *self < MAX_P1 {
                                return Some( float_to_int_unchecked!( *self => $i ) );
                            }
                        } else {
                           
                           
                            const MIN: $f = $i::MIN as $f;
                           
                           
                            const MAX_P1: $f = $i::MAX as $f;
                            if *self >= MIN && *self < MAX_P1 {
                                return Some( float_to_int_unchecked!( *self => $i ) );
                            }
                        }
                        None
                    }
                )*}
            }
            macro_rules! impl_to_primitive_float_to_unsigned_int 
            {
                ( $f:ident : $( fn $method:ident -> $u:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$u> {
                       
                       
                        if size_of::<$f>() > size_of::<$u>() {
                           
                            const MAX_P1: $f = $u::MAX as $f + 1.0;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some( float_to_int_unchecked!( *self => $u ) );
                            }
                        } else {
                           
                           
                           
                            const MAX_P1: $f = $u::MAX as $f;
                            if *self > -1.0 && *self < MAX_P1 {
                                return Some( float_to_int_unchecked!( *self => $u ) );
                            }
                        }
                        None
                    }
                )*}
            }
            macro_rules! impl_to_primitive_float 
            {
                ( $T:ident ) => {
                    impl ToPrimitive for $T {
                        impl_to_primitive_float_to_signed_int! { $T:
                            fn to_isize -> isize;
                            fn to_i8 -> i8;
                            fn to_i16 -> i16;
                            fn to_i32 -> i32;
                            fn to_i64 -> i64;
                            fn to_i128 -> i128;
                        }
                        impl_to_primitive_float_to_unsigned_int! { $T:
                            fn to_usize -> usize;
                            fn to_u8 -> u8;
                            fn to_u16 -> u16;
                            fn to_u32 -> u32;
                            fn to_u64 -> u64;
                            fn to_u128 -> u128;
                        }
                        impl_to_primitive_float_to_float! { $T:
                            fn to_f32 -> f32;
                            fn to_f64 -> f64;
                        }
                    }
                };
            }
            impl_to_primitive_float!( f32 );
            impl_to_primitive_float!( f64 );

            pub trait FromPrimitive: Sized
            {
                #[inline] fn from_isize( n: isize ) -> Option<Self> { n.to_i64().and_then( FromPrimitive::from_i64 )}
                
                #[inline] fn from_i8( n: i8 ) -> Option<Self> { FromPrimitive::from_i64( From::from( n ) )}
                
                #[inline] fn from_i16( n: i16 ) -> Option<Self> { FromPrimitive::from_i64( From::from( n ) )}
                
                #[inline] fn from_i32( n: i32 ) -> Option<Self> { FromPrimitive::from_i64( From::from( n ) ) }
                fn from_i64( n: i64 ) -> Option<Self>;
                #[inline] fn from_i128( n: i128 ) -> Option<Self> { n.to_i64().and_then( FromPrimitive::from_i64 )}
                
                #[inline] fn from_usize( n: usize ) -> Option<Self> { n.to_u64().and_then( FromPrimitive::from_u64 )}
                
                #[inline] fn from_u8( n: u8 ) -> Option<Self> { FromPrimitive::from_u64( From::from( n ) )}
                
                #[inline] fn from_u16( n: u16 ) -> Option<Self> { FromPrimitive::from_u64( From::from( n ) )}
                
                #[inline] fn from_u32( n: u32 ) -> Option<Self> { FromPrimitive::from_u64( From::from( n ) ) }
                fn from_u64( n: u64 ) -> Option<Self>;
                #[inline] fn from_u128( n: u128 ) -> Option<Self> { n.to_u64().and_then( FromPrimitive::from_u64 )}
                
                #[inline] fn from_f32( n: f32 ) -> Option<Self> { FromPrimitive::from_f64( From::from( n ) )}
                
                #[inline] fn from_f64( n: f64 ) -> Option<Self> {
                    match n.to_i64() {
                        Some( i ) => FromPrimitive::from_i64( i ),
                        None => n.to_u64().and_then( FromPrimitive::from_u64 ),
                    }
                }
            }
            macro_rules! impl_from_primitive
            {
                ( $T:ty, $to_ty:ident ) => {
                    impl FromPrimitive for $T {
                        #[inline] fn from_isize( n: isize ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_i8( n: i8 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_i16( n: i16 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_i32( n: i32 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_i64( n: i64 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_i128( n: i128 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_usize( n: usize ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_u8( n: u8 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_u16( n: u16 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_u32( n: u32 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_u64( n: u64 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_u128( n: u128 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_f32( n: f32 ) -> Option<$T> { n.$to_ty() }

                        #[inline] fn from_f64( n: f64 ) -> Option<$T> { n.$to_ty() }
                    }
                };
            }
            impl_from_primitive!( isize, to_isize );
            impl_from_primitive!( i8, to_i8 );
            impl_from_primitive!( i16, to_i16 );
            impl_from_primitive!( i32, to_i32 );
            impl_from_primitive!( i64, to_i64 );
            impl_from_primitive!( i128, to_i128 );
            impl_from_primitive!( usize, to_usize );
            impl_from_primitive!( u8, to_u8 );
            impl_from_primitive!( u16, to_u16 );
            impl_from_primitive!( u32, to_u32 );
            impl_from_primitive!( u64, to_u64 );
            impl_from_primitive!( u128, to_u128 );
            impl_from_primitive!( f32, to_f32 );
            impl_from_primitive!( f64, to_f64 );

            macro_rules! impl_from_primitive_nonzero
            {
                ( $T:ty, $to_ty:ident ) => {
                    impl FromPrimitive for $T {
                        #[inline] fn from_isize( n: isize ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_i8( n: i8 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_i16( n: i16 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_i32( n: i32 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_i64( n: i64 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_i128( n: i128 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_usize( n: usize ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_u8( n: u8 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_u16( n: u16 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_u32( n: u32 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_u64( n: u64 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_u128( n: u128 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_f32( n: f32 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }

                        #[inline] fn from_f64( n: f64 ) -> Option<$T> { n.$to_ty().and_then( Self::new ) }
                    }
                };
            }
            impl_from_primitive_nonzero!( NonZeroIsize, to_isize );
            impl_from_primitive_nonzero!( NonZeroI8, to_i8 );
            impl_from_primitive_nonzero!( NonZeroI16, to_i16 );
            impl_from_primitive_nonzero!( NonZeroI32, to_i32 );
            impl_from_primitive_nonzero!( NonZeroI64, to_i64 );
            impl_from_primitive_nonzero!( NonZeroI128, to_i128 );
            impl_from_primitive_nonzero!( NonZeroUsize, to_usize );
            impl_from_primitive_nonzero!( NonZeroU8, to_u8 );
            impl_from_primitive_nonzero!( NonZeroU16, to_u16 );
            impl_from_primitive_nonzero!( NonZeroU32, to_u32 );
            impl_from_primitive_nonzero!( NonZeroU64, to_u64 );
            impl_from_primitive_nonzero!( NonZeroU128, to_u128 );

            macro_rules! impl_to_primitive_wrapping 
            {
                ( $( fn $method:ident -> $i:ident ; )* ) => {$( 
                    #[inline] fn $method( &self ) -> Option<$i> { ( self.0 ).$method() }
                )*}
            }
            
            impl<T: ToPrimitive> ToPrimitive for Wrapping<T> 
            {
                impl_to_primitive_wrapping!
                {
                    fn to_isize -> isize;
                    fn to_i8 -> i8;
                    fn to_i16 -> i16;
                    fn to_i32 -> i32;
                    fn to_i64 -> i64;
                    fn to_i128 -> i128;

                    fn to_usize -> usize;
                    fn to_u8 -> u8;
                    fn to_u16 -> u16;
                    fn to_u32 -> u32;
                    fn to_u64 -> u64;
                    fn to_u128 -> u128;

                    fn to_f32 -> f32;
                    fn to_f64 -> f64;
                }
            }
            macro_rules! impl_from_primitive_wrapping 
            {
                ( $( fn $method:ident ( $i:ident  ); )* ) => {$( 
                    #[inline] fn $method( n: $i ) -> Option<Self> { T::$method( n ).map( Wrapping ) }
                )*}
            }
            
            impl<T: FromPrimitive> FromPrimitive for Wrapping<T> 
            {
                impl_from_primitive_wrapping!
                {
                    fn from_isize( isize );
                    fn from_i8( i8 );
                    fn from_i16( i16 );
                    fn from_i32( i32 );
                    fn from_i64( i64 );
                    fn from_i128( i128 );

                    fn from_usize( usize );
                    fn from_u8( u8 );
                    fn from_u16( u16 );
                    fn from_u32( u32 );
                    fn from_u64( u64 );
                    fn from_u128( u128 );

                    fn from_f32( f32 );
                    fn from_f64( f64 );
                }
            }

            #[inline] pub fn cast<T: NumCast, U: NumCast>( n: T ) -> Option<U>
            {
                NumCast::from( n )
            }

            pub trait NumCast: Sized + ToPrimitive
            {
                fn from<T: ToPrimitive>( n: T ) -> Option<Self>;
            }
            macro_rules! impl_num_cast
            {
                ( $T:ty, $conv:ident ) => {
                    impl NumCast for $T {
                        #[inline] fn from<N: ToPrimitive>( n: N ) -> Option<$T> { n.$conv() }
                    }
                };
            }
            impl_num_cast!( u8, to_u8 );
            impl_num_cast!( u16, to_u16 );
            impl_num_cast!( u32, to_u32 );
            impl_num_cast!( u64, to_u64 );
            impl_num_cast!( u128, to_u128 );
            impl_num_cast!( usize, to_usize );
            impl_num_cast!( i8, to_i8 );
            impl_num_cast!( i16, to_i16 );
            impl_num_cast!( i32, to_i32 );
            impl_num_cast!( i64, to_i64 );
            impl_num_cast!( i128, to_i128 );
            impl_num_cast!( isize, to_isize );
            impl_num_cast!( f32, to_f32 );
            impl_num_cast!( f64, to_f64 );

            macro_rules! impl_num_cast_nonzero {
                ( $T:ty, $conv:ident ) => {
                    impl NumCast for $T {
                        #[inline] fn from<N: ToPrimitive>( n: N ) -> Option<$T> { n.$conv().and_then( Self::new ) }
                    }
                };
            }
            impl_num_cast_nonzero!( NonZeroUsize, to_usize );
            impl_num_cast_nonzero!( NonZeroU8, to_u8 );
            impl_num_cast_nonzero!( NonZeroU16, to_u16 );
            impl_num_cast_nonzero!( NonZeroU32, to_u32 );
            impl_num_cast_nonzero!( NonZeroU64, to_u64 );
            impl_num_cast_nonzero!( NonZeroU128, to_u128 );

            impl_num_cast_nonzero!( NonZeroIsize, to_isize );
            impl_num_cast_nonzero!( NonZeroI8, to_i8 );
            impl_num_cast_nonzero!( NonZeroI16, to_i16 );
            impl_num_cast_nonzero!( NonZeroI32, to_i32 );
            impl_num_cast_nonzero!( NonZeroI64, to_i64 );
            impl_num_cast_nonzero!( NonZeroI128, to_i128 );

            impl<T: NumCast> NumCast for Wrapping<T>
            {
                fn from<U: ToPrimitive>( n: U ) -> Option<Self> { T::from( n ).map( Wrapping ) }
            }

            pub trait AsPrimitive<T>: 'static + Copy where
            T: 'static + Copy,
            {
                fn as_( self ) -> T;
            }
            macro_rules! impl_as_primitive
            {
                ( @ $T: ty =>  impl $U: ty ) => {
                    impl AsPrimitive<$U> for $T {
                        #[inline] fn as_( self ) -> $U { self as $U }
                    }
                };
                ( @ $T: ty => { $( $U: ty ),* } ) => {$( 
                    impl_as_primitive!( @ $T => impl $U );
                )*};
                ( $T: ty => { $( $U: ty ),* } ) => {
                    impl_as_primitive!( @ $T => { $( $U ),* } );
                    impl_as_primitive!( @ $T => { u8, u16, u32, u64, u128, usize } );
                    impl_as_primitive!( @ $T => { i8, i16, i32, i64, i128, isize } );
                };
            }
            impl_as_primitive!( u8 => { char, f32, f64 } );
            impl_as_primitive!( i8 => { f32, f64 } );
            impl_as_primitive!( u16 => { f32, f64 } );
            impl_as_primitive!( i16 => { f32, f64 } );
            impl_as_primitive!( u32 => { f32, f64 } );
            impl_as_primitive!( i32 => { f32, f64 } );
            impl_as_primitive!( u64 => { f32, f64 } );
            impl_as_primitive!( i64 => { f32, f64 } );
            impl_as_primitive!( u128 => { f32, f64 } );
            impl_as_primitive!( i128 => { f32, f64 } );
            impl_as_primitive!( usize => { f32, f64 } );
            impl_as_primitive!( isize => { f32, f64 } );
            impl_as_primitive!( f32 => { f32, f64 } );
            impl_as_primitive!( f64 => { f32, f64 } );
            impl_as_primitive!( char => { char } );
            impl_as_primitive!( bool => {} );

        } pub use self::cast::{cast, AsPrimitive, FromPrimitive, NumCast, ToPrimitive};

        pub mod float
        {
            use ::
            {
                cmp::{ Ordering },
                num::
                {
                    traits::{ Num, NumCast, ToPrimitive },
                    FpCategory
                },
                ops::{ Add, Div, Neg },
                *,
            };
            /*
            */

            pub trait FloatCore: Num + NumCast + Neg<Output = Self> + PartialOrd + Copy
            {
                fn infinity() -> Self;
                fn neg_infinity() -> Self;
                fn nan() -> Self;
                fn neg_zero() -> Self;
                fn min_value() -> Self;
                fn min_positive_value() -> Self;
                fn epsilon() -> Self;
                fn max_value() -> Self;

                #[inline] fn is_nan( self ) -> bool {
                    self != self
                }

                #[inline] fn is_infinite( self ) -> bool {
                    self == Self::infinity() || self == Self::neg_infinity()
                }

                #[inline] fn is_finite( self ) -> bool {
                    !( self.is_nan() || self.is_infinite() )
                }

                #[inline] fn is_normal( self ) -> bool {
                    self.classify() == FpCategory::Normal
                }

                #[inline] fn is_subnormal( self ) -> bool {
                    self.classify() == FpCategory::Subnormal
                }

                fn classify( self ) -> FpCategory;

                #[inline] fn floor( self ) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self < Self::zero() {
                        self - f - Self::one()
                    } else {
                        self - f
                    }
                }

                #[inline] fn ceil( self ) -> Self {
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        self - f + Self::one()
                    } else {
                        self - f
                    }
                }

                #[inline] fn round( self ) -> Self {
                    let one = Self::one();
                    let h = Self::from( 0.5 ).expect( "Unable to cast from 0.5" );
                    let f = self.fract();
                    if f.is_nan() || f.is_zero() {
                        self
                    } else if self > Self::zero() {
                        if f < h {
                            self - f
                        } else {
                            self - f + one
                        }
                    } else if -f < h {
                        self - f
                    } else {
                        self - f - one
                    }
                }

                #[inline] fn trunc( self ) -> Self {
                    let f = self.fract();
                    if f.is_nan() {
                        self
                    } else {
                        self - f
                    }
                }

                #[inline] fn fract( self ) -> Self {
                    if self.is_zero() {
                        Self::zero()
                    } else {
                        self % Self::one()
                    }
                }

                #[inline] fn abs( self ) -> Self {
                    if self.is_sign_positive() {
                        return self;
                    }
                    if self.is_sign_negative() {
                        return -self;
                    }
                    Self::nan()
                }

                #[inline] fn signum( self ) -> Self {
                    if self.is_nan() {
                        Self::nan()
                    } else if self.is_sign_negative() {
                        -Self::one()
                    } else {
                        Self::one()
                    }
                }

                #[inline] fn is_sign_positive( self ) -> bool {
                    !self.is_sign_negative()
                }

                #[inline] fn is_sign_negative( self ) -> bool {
                    let ( _, _, sign ) = self.integer_decode();
                    sign < 0
                }

                #[inline] fn min( self, other: Self ) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self < other {
                        self
                    } else {
                        other
                    }
                }

                #[inline] fn max( self, other: Self ) -> Self {
                    if self.is_nan() {
                        return other;
                    }
                    if other.is_nan() {
                        return self;
                    }
                    if self > other {
                        self
                    } else {
                        other
                    }
                }

                fn clamp( self, min: Self, max: Self ) -> Self {
                    ::num::traits::clamp( self, min, max )
                }

                #[inline] fn recip( self ) -> Self {
                    Self::one() / self
                }

                #[inline] fn powi( mut self, mut exp: i32 ) -> Self {
                    if exp < 0 {
                        exp = exp.wrapping_neg();
                        self = self.recip();
                    }
                   
                   
                   
                    super::pow( self, ( exp as u32 ).to_usize().unwrap() )
                }

                fn to_degrees( self ) -> Self;
                fn to_radians( self ) -> Self;
                fn integer_decode( self ) -> ( u64, i16, i8 );
            }
            
            impl FloatCore for f32
            {
                constant!
                {
                    infinity() -> f32::INFINITY;
                    neg_infinity() -> f32::NEG_INFINITY;
                    nan() -> f32::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f32::MIN;
                    min_positive_value() -> f32::MIN_POSITIVE;
                    epsilon() -> f32::EPSILON;
                    max_value() -> f32::MAX;
               }
                
                #[inline] fn integer_decode( self ) -> ( u64, i16, i8 )
                {
                    integer_decode_f32( self )
                }
                forward!
                {
                    Self::is_nan( self ) -> bool;
                    Self::is_infinite( self ) -> bool;
                    Self::is_finite( self ) -> bool;
                    Self::is_normal( self ) -> bool;
                    Self::is_subnormal( self ) -> bool;
                    Self::clamp( self, min: Self, max: Self ) -> Self;
                    Self::classify( self ) -> FpCategory;
                    Self::is_sign_positive( self ) -> bool;
                    Self::is_sign_negative( self ) -> bool;
                    Self::min( self, other: Self ) -> Self;
                    Self::max( self, other: Self ) -> Self;
                    Self::recip( self ) -> Self;
                    Self::to_degrees( self ) -> Self;
                    Self::to_radians( self ) -> Self;
                }
                
                forward!
                {
                    Self::floor( self ) -> Self;
                    Self::ceil( self ) -> Self;
                    Self::round( self ) -> Self;
                    Self::trunc( self ) -> Self;
                    Self::fract( self ) -> Self;
                    Self::abs( self ) -> Self;
                    Self::signum( self ) -> Self;
                    Self::powi( self, n: i32 ) -> Self;
                }
            }
            
            impl FloatCore for f64
            {
                constant!
                {
                    infinity() -> f64::INFINITY;
                    neg_infinity() -> f64::NEG_INFINITY;
                    nan() -> f64::NAN;
                    neg_zero() -> -0.0;
                    min_value() -> f64::MIN;
                    min_positive_value() -> f64::MIN_POSITIVE;
                    epsilon() -> f64::EPSILON;
                    max_value() -> f64::MAX;
               }
                
                #[inline] fn integer_decode( self ) -> ( u64, i16, i8 )
                {
                    integer_decode_f64( self )
                }
                forward!
                {
                    Self::is_nan( self ) -> bool;
                    Self::is_infinite( self ) -> bool;
                    Self::is_finite( self ) -> bool;
                    Self::is_normal( self ) -> bool;
                    Self::is_subnormal( self ) -> bool;
                    Self::clamp( self, min: Self, max: Self ) -> Self;
                    Self::classify( self ) -> FpCategory;
                    Self::is_sign_positive( self ) -> bool;
                    Self::is_sign_negative( self ) -> bool;
                    Self::min( self, other: Self ) -> Self;
                    Self::max( self, other: Self ) -> Self;
                    Self::recip( self ) -> Self;
                    Self::to_degrees( self ) -> Self;
                    Self::to_radians( self ) -> Self;
                }
                
                forward!
                {
                    Self::floor( self ) -> Self;
                    Self::ceil( self ) -> Self;
                    Self::round( self ) -> Self;
                    Self::trunc( self ) -> Self;
                    Self::fract( self ) -> Self;
                    Self::abs( self ) -> Self;
                    Self::signum( self ) -> Self;
                    Self::powi( self, n: i32 ) -> Self;
                }
            }

            pub trait Float: Num + Copy + NumCast + PartialOrd + Neg<Output = Self>
            {
                fn nan() -> Self;
                fn infinity() -> Self;
                fn neg_infinity() -> Self;
                fn neg_zero() -> Self;
                fn min_value() -> Self;
                fn min_positive_value() -> Self;
                fn epsilon() -> Self {
                    Self::from( f32::EPSILON ).expect( "Unable to cast from f32::EPSILON" )
                }

                fn max_value() -> Self;
                fn is_nan( self ) -> bool;
                fn is_infinite( self ) -> bool;
                fn is_finite( self ) -> bool;
                fn is_normal( self ) -> bool;

                #[inline] fn is_subnormal( self ) -> bool {
                    self.classify() == FpCategory::Subnormal
                }

                fn classify( self ) -> FpCategory;
                fn floor( self ) -> Self;
                fn ceil( self ) -> Self;
                fn round( self ) -> Self;
                fn trunc( self ) -> Self;
                fn fract( self ) -> Self;
                fn abs( self ) -> Self;
                fn signum( self ) -> Self;
                fn is_sign_positive( self ) -> bool;
                fn is_sign_negative( self ) -> bool;
                fn mul_add( self, a: Self, b: Self ) -> Self;
                fn recip( self ) -> Self;
                fn powi( self, n: i32 ) -> Self;
                fn powf( self, n: Self ) -> Self;
                fn sqrt( self ) -> Self;
                fn exp( self ) -> Self;
                fn exp2( self ) -> Self;
                fn ln( self ) -> Self;
                fn log( self, base: Self ) -> Self;
                fn log2( self ) -> Self;
                fn log10( self ) -> Self;

                #[inline] fn to_degrees( self ) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from( 90u8 ).unwrap();
                    self * ninety / halfpi
                }

                #[inline] fn to_radians( self ) -> Self {
                    let halfpi = Self::zero().acos();
                    let ninety = Self::from( 90u8 ).unwrap();
                    self * halfpi / ninety
                }

                fn max( self, other: Self ) -> Self;
                fn min( self, other: Self ) -> Self;
                fn clamp( self, min: Self, max: Self ) -> Self {
                    num::traits::clamp( self, min, max )
                }

                fn abs_sub( self, other: Self ) -> Self;
                fn cbrt( self ) -> Self;
                fn hypot( self, other: Self ) -> Self;
                fn sin( self ) -> Self;
                fn cos( self ) -> Self;
                fn tan( self ) -> Self;
                fn asin( self ) -> Self;
                fn acos( self ) -> Self;
                fn atan( self ) -> Self;
                fn atan2( self, other: Self ) -> Self;
                fn sin_cos( self ) -> ( Self, Self );
                fn exp_m1( self ) -> Self;
                fn ln_1p( self ) -> Self;
                fn sinh( self ) -> Self;
                fn cosh( self ) -> Self;
                fn tanh( self ) -> Self;
                fn asinh( self ) -> Self;
                fn acosh( self ) -> Self;
                fn atanh( self ) -> Self;
                fn integer_decode( self ) -> ( u64, i16, i8 );
                fn copysign( self, sign: Self ) -> Self {
                    if self.is_sign_negative() == sign.is_sign_negative() {
                        self
                    } else {
                        self.neg()
                    }
                }
            }
            macro_rules! float_impl_std
            {
                ( $T:ident $decode:ident ) => {
                    impl Float for $T {
                        constant! {
                            nan() -> $T::NAN;
                            infinity() -> $T::INFINITY;
                            neg_infinity() -> $T::NEG_INFINITY;
                            neg_zero() -> -0.0;
                            min_value() -> $T::MIN;
                            min_positive_value() -> $T::MIN_POSITIVE;
                            epsilon() -> $T::EPSILON;
                            max_value() -> $T::MAX;
                        }
                        #[inline]
                        #[allow( deprecated )]
                        fn abs_sub( self, other: Self ) -> Self {
                            <$T>::abs_sub( self, other )
                        }

                        #[inline] fn integer_decode( self ) -> ( u64, i16, i8 ) {
                            $decode( self )
                        }
                        forward! {
                            Self::is_nan( self ) -> bool;
                            Self::is_infinite( self ) -> bool;
                            Self::is_finite( self ) -> bool;
                            Self::is_normal( self ) -> bool;
                            Self::is_subnormal( self ) -> bool;
                            Self::classify( self ) -> FpCategory;
                            Self::clamp( self, min: Self, max: Self ) -> Self;
                            Self::floor( self ) -> Self;
                            Self::ceil( self ) -> Self;
                            Self::round( self ) -> Self;
                            Self::trunc( self ) -> Self;
                            Self::fract( self ) -> Self;
                            Self::abs( self ) -> Self;
                            Self::signum( self ) -> Self;
                            Self::is_sign_positive( self ) -> bool;
                            Self::is_sign_negative( self ) -> bool;
                            Self::mul_add( self, a: Self, b: Self ) -> Self;
                            Self::recip( self ) -> Self;
                            Self::powi( self, n: i32 ) -> Self;
                            Self::powf( self, n: Self ) -> Self;
                            Self::sqrt( self ) -> Self;
                            Self::exp( self ) -> Self;
                            Self::exp2( self ) -> Self;
                            Self::ln( self ) -> Self;
                            Self::log( self, base: Self ) -> Self;
                            Self::log2( self ) -> Self;
                            Self::log10( self ) -> Self;
                            Self::to_degrees( self ) -> Self;
                            Self::to_radians( self ) -> Self;
                            Self::max( self, other: Self ) -> Self;
                            Self::min( self, other: Self ) -> Self;
                            Self::cbrt( self ) -> Self;
                            Self::hypot( self, other: Self ) -> Self;
                            Self::sin( self ) -> Self;
                            Self::cos( self ) -> Self;
                            Self::tan( self ) -> Self;
                            Self::asin( self ) -> Self;
                            Self::acos( self ) -> Self;
                            Self::atan( self ) -> Self;
                            Self::atan2( self, other: Self ) -> Self;
                            Self::sin_cos( self ) -> ( Self, Self );
                            Self::exp_m1( self ) -> Self;
                            Self::ln_1p( self ) -> Self;
                            Self::sinh( self ) -> Self;
                            Self::cosh( self ) -> Self;
                            Self::tanh( self ) -> Self;
                            Self::asinh( self ) -> Self;
                            Self::acosh( self ) -> Self;
                            Self::atanh( self ) -> Self;
                            Self::copysign( self, sign: Self ) -> Self;
                        }
                    }
                };
            }
            
            fn integer_decode_f32( f: f32 ) -> ( u64, i16, i8 )
            {
                let bits: u32 = f.to_bits();
                let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };
                let mut exponent: i16 = (( bits >> 23 ) & 0xff ) as i16;
                let mantissa = if exponent == 0 {
                    ( bits & 0x7fffff ) << 1
                } else {
                    ( bits & 0x7fffff ) | 0x800000
                };
               
                exponent -= 127 + 23;
                ( mantissa as u64, exponent, sign )
            }
            
            fn integer_decode_f64( f: f64 ) -> ( u64, i16, i8 )
            {
                let bits: u64 = f.to_bits();
                let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };
                let mut exponent: i16 = (( bits >> 52 ) & 0x7ff ) as i16;
                let mantissa = if exponent == 0 {
                    ( bits & 0xfffffffffffff ) << 1
                } else {
                    ( bits & 0xfffffffffffff ) | 0x10000000000000
                };
               
                exponent -= 1023 + 52;
                ( mantissa, exponent, sign )
            }
            float_impl_std!( f32 integer_decode_f32 );
            float_impl_std!( f64 integer_decode_f64 );
            
            macro_rules! float_const_impl
            {
                ( $( #[$doc:meta] $constant:ident, )+ ) => ( 
                    #[allow( non_snake_case )]
                    pub trait FloatConst {
                        $( #[$doc] fn $constant() -> Self; )+
                        #[doc = "Return the full circle constant ``."]
                        #[inline] fn TAU() -> Self  where Self: Sized + Add<Self, Output = Self> { Self::PI() + Self::PI() }
                        #[doc = "Return `log10( 2.0 )`."]
                        #[inline] fn LOG10_2() -> Self  where Self: Sized + Div<Self, Output = Self> { Self::LN_2() / Self::LN_10() }
                        #[doc = "Return `log2( 10.0 )`."]
                        #[inline] fn LOG2_10() -> Self  where Self: Sized + Div<Self, Output = Self> { Self::LN_10() / Self::LN_2() }
                    }
                    float_const_impl! { @float f32, $( $constant, )+ }
                    float_const_impl! { @float f64, $( $constant, )+ }
                 );
                ( @float $T:ident, $( $constant:ident, )+ ) => ( 
                    impl FloatConst for $T {
                        constant! {
                            $( $constant() -> $T::consts::$constant; )+
                            TAU() -> 6.28318530717958647692528676655900577;
                            LOG10_2() -> 0.301029995663981195213738894724493027;
                            LOG2_10() -> 3.32192809488736234787031942948939018;
                        }
                    }
                 );
            }
            float_const_impl!
            {
                #[doc = "Return Eulers number."]
                E,
                #[doc = "Return `1.0 / `."]
                FRAC_1_PI,
                #[doc = "Return `1.0 / sqrt( 2.0 )`."]
                FRAC_1_SQRT_2,
                #[doc = "Return `2.0 / `."]
                FRAC_2_PI,
                #[doc = "Return `2.0 / sqrt(  )`."]
                FRAC_2_SQRT_PI,
                #[doc = "Return ` / 2.0`."]
                FRAC_PI_2,
                #[doc = "Return ` / 3.0`."]
                FRAC_PI_3,
                #[doc = "Return ` / 4.0`."]
                FRAC_PI_4,
                #[doc = "Return ` / 6.0`."]
                FRAC_PI_6,
                #[doc = "Return ` / 8.0`."]
                FRAC_PI_8,
                #[doc = "Return `ln( 10.0 )`."]
                LN_10,
                #[doc = "Return `ln( 2.0 )`."]
                LN_2,
                #[doc = "Return `log10( e )`."]
                LOG10_E,
                #[doc = "Return `log2( e )`."]
                LOG2_E,
                #[doc = "Return Archimedes constant ``."]
                PI,
                #[doc = "Return `sqrt( 2.0 )`."]
                SQRT_2,
            }

            pub trait TotalOrder
            {
                fn total_cmp( &self, other:&Self ) -> Ordering;
            }
            macro_rules! totalorder_impl
            {
                ( $T:ident, $I:ident, $U:ident, $bits:expr ) => {
                    impl TotalOrder for $T {
                        #[inline]
                        #[cfg( has_total_cmp )]
                        fn total_cmp( &self, other:&Self ) -> Ordering {
                           
                            Self::total_cmp( &self, other )
                        }
                        #[inline]
                        #[cfg( not( has_total_cmp ) )]
                        fn total_cmp( &self, other:&Self ) -> Ordering {
                           
                            let mut left = self.to_bits() as $I;
                            let mut right = other.to_bits() as $I;

                            left ^= (( ( left >> ( $bits - 1 ) ) as $U ) >> 1 ) as $I;
                            right ^= (( ( right >> ( $bits - 1 ) ) as $U ) >> 1 ) as $I;

                            left.cmp( &right )
                        }
                    }
                };
            }
            totalorder_impl!( f64, i64, u64, 64 );
            totalorder_impl!( f32, i32, u32, 32 );
        } pub use self::float::{ Float, FloatConst };

        pub mod identities
        {
            use ::
            {
                num::{ Saturating, Wrapping },
                ops::{ Add, Mul },
                *,
            };
            /*
            */

            pub trait Zero: Sized + Add<Self, Output = Self>
            {

               
                fn zero() -> Self;
                fn set_zero( &mut self ) { *self = Zero::zero(); }

                fn is_zero( &self ) -> bool;
            }

            pub trait ConstZero: Zero
            {

                const ZERO: Self;
            }
            macro_rules! zero_impl
            {
                ( $t:ty, $v:expr ) => {
                    impl Zero for $t {
                        #[inline] fn zero() -> $t {
                            $v
                        }

                        #[inline] fn is_zero( &self ) -> bool { *self == $v }
                    }
                    
                    impl ConstZero for $t {
                        const ZERO: Self = $v;
                    }
                };
            }
            zero_impl!( usize, 0 );
            zero_impl!( u8, 0 );
            zero_impl!( u16, 0 );
            zero_impl!( u32, 0 );
            zero_impl!( u64, 0 );
            zero_impl!( u128, 0 );

            zero_impl!( isize, 0 );
            zero_impl!( i8, 0 );
            zero_impl!( i16, 0 );
            zero_impl!( i32, 0 );
            zero_impl!( i64, 0 );
            zero_impl!( i128, 0 );

            zero_impl!( f32, 0.0 );
            zero_impl!( f64, 0.0 );

            impl<T: Zero> Zero for Wrapping<T> where
            Wrapping<T>: Add<Output = Wrapping<T>>
            {
                fn is_zero( &self ) -> bool { self.0.is_zero() }
                fn set_zero( &mut self ) { self.0.set_zero(); }
                fn zero() -> Self { Wrapping( T::zero() ) }
            }
            
            impl<T: ConstZero> ConstZero for Wrapping<T> where
            Wrapping<T>: Add<Output = Wrapping<T>>,
            {
                const ZERO: Self = Wrapping( T::ZERO );
            }
            
            impl<T: Zero> Zero for Saturating<T> where
            Saturating<T>: Add<Output = Saturating<T>>,
            {
                fn is_zero( &self ) -> bool { self.0.is_zero() }
                fn set_zero( &mut self ) { self.0.set_zero(); }
                fn zero() -> Self { Saturating( T::zero() ) }
            }
            
            impl<T: ConstZero> ConstZero for Saturating<T> where
            Saturating<T>: Add<Output = Saturating<T>>,
            {
                const ZERO: Self = Saturating( T::ZERO );
            }

            pub trait One: Sized + Mul<Self, Output = Self>
            {  
                fn one() -> Self;
                fn set_one( &mut self ) {
                    *self = One::one();
                }

                #[inline] fn is_one( &self ) -> bool where Self: PartialEq,
                {
                    *self == Self::one()
                }
            }

            pub trait ConstOne: One {

                const ONE: Self;
            }

            macro_rules! one_impl {
                ( $t:ty, $v:expr ) => {
                    impl One for $t {
                        #[inline] fn one() -> $t {
                            $v
                        }

                        #[inline] fn is_one( &self ) -> bool { *self == $v }
                    }
                    
                    impl ConstOne for $t {
                        const ONE: Self = $v;
                    }
                };
            }

            one_impl!( usize, 1 );
            one_impl!( u8, 1 );
            one_impl!( u16, 1 );
            one_impl!( u32, 1 );
            one_impl!( u64, 1 );
            one_impl!( u128, 1 );

            one_impl!( isize, 1 );
            one_impl!( i8, 1 );
            one_impl!( i16, 1 );
            one_impl!( i32, 1 );
            one_impl!( i64, 1 );
            one_impl!( i128, 1 );

            one_impl!( f32, 1.0 );
            one_impl!( f64, 1.0 );

            impl<T: One> One for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                fn set_one( &mut self ) {
                    self.0.set_one();
                }
                fn one() -> Self {
                    Wrapping( T::one() )
                }
            }
            
            impl<T: ConstOne> ConstOne for Wrapping<T> where
                Wrapping<T>: Mul<Output = Wrapping<T>>,
            {
                const ONE: Self = Wrapping( T::ONE );
            }
            #[cfg( has_num_saturating )]
            impl<T: One> One for Saturating<T> where
                Saturating<T>: Mul<Output = Saturating<T>>,
            {
                fn set_one( &mut self ) {
                    self.0.set_one();
                }
                fn one() -> Self {
                    Saturating( T::one() )
                }
            }
            #[cfg( has_num_saturating )]
            impl<T: ConstOne> ConstOne for Saturating<T> where
                Saturating<T>: Mul<Output = Saturating<T>>,
            {
                const ONE: Self = Saturating( T::ONE );
            }
           


            #[inline( always )] pub fn zero<T: Zero>() -> T {
                Zero::zero()
            }

            #[inline( always )] pub fn one<T: One>() -> T {
                One::one()
            }
        } pub use self::identities::{one, zero, ConstOne, ConstZero, One, Zero};

        pub mod int
        {
            use ::
            {
                num::
                {
                    traits::
                    {
                        bounds::Bounded,
                        ops::
                        {
                            checked::*,
                            saturating::Saturating,
                        },
                        Num, NumCast,
                    },
                },
                ops::{BitAnd, BitOr, BitXor, Not, Shl, Shr},
                *,
            };
            /*
            */

            pub trait PrimInt:
                Sized
                + Copy
                + Num
                + NumCast
                + Bounded
                + PartialOrd
                + Ord
                + Eq
                + Not<Output = Self>
                + BitAnd<Output = Self>
                + BitOr<Output = Self>
                + BitXor<Output = Self>
                + Shl<usize, Output = Self>
                + Shr<usize, Output = Self>
                + CheckedAdd<Output = Self>
                + CheckedSub<Output = Self>
                + CheckedMul<Output = Self>
                + CheckedDiv<Output = Self>
                + Saturating
            {
                fn count_ones( self ) -> u32;
                fn count_zeros( self ) -> u32;
                fn leading_ones( self ) -> u32 { ( !self ).leading_zeros() }
                fn leading_zeros( self ) -> u32;
                fn trailing_ones( self ) -> u32 { ( !self ).trailing_zeros() }
                fn trailing_zeros( self ) -> u32;
                fn rotate_left( self, n: u32 ) -> Self;
                fn rotate_right( self, n: u32 ) -> Self;
                fn signed_shl( self, n: u32 ) -> Self;
                fn signed_shr( self, n: u32 ) -> Self;
                fn unsigned_shl( self, n: u32 ) -> Self;
                fn unsigned_shr( self, n: u32 ) -> Self;
                fn swap_bytes( self ) -> Self;
                fn reverse_bits( self ) -> Self { reverse_bits_fallback( self ) }
                fn from_be( x: Self ) -> Self;
                fn from_le( x: Self ) -> Self;
                fn to_be( self ) -> Self;
                fn to_le( self ) -> Self;
                fn pow( self, exp: u32 ) -> Self;
            }
            
            fn one_per_byte<P: PrimInt>() -> P {
               
               
               
               
                let mut ret = P::one();
                let mut shift = 8;
                let mut b = ret.count_zeros() >> 3;
                while b != 0 {
                    ret = ( ret << shift ) | ret;
                    shift <<= 1;
                    b >>= 1;
                }
                ret
            }
            
            fn reverse_bits_fallback<P: PrimInt>( i: P ) -> P {
                let rep_01: P = one_per_byte();
                let rep_03 = ( rep_01 << 1 ) | rep_01;
                let rep_05 = ( rep_01 << 2 ) | rep_01;
                let rep_0f = ( rep_03 << 2 ) | rep_03;
                let rep_33 = ( rep_03 << 4 ) | rep_03;
                let rep_55 = ( rep_05 << 4 ) | rep_05;

               
               
                let mut ret = i.swap_bytes();
                ret = (( ret & rep_0f ) << 4 ) | ( ( ret >> 4 ) & rep_0f );
                ret = (( ret & rep_33 ) << 2 ) | ( ( ret >> 2 ) & rep_33 );
                ret = (( ret & rep_55 ) << 1 ) | ( ( ret >> 1 ) & rep_55 );
                ret
            }
            macro_rules! prim_int_impl {
                ( $T:ty, $S:ty, $U:ty ) => {
                    impl PrimInt for $T {
                        #[inline] fn count_ones( self ) -> u32 {
                            <$T>::count_ones( self )
                        }

                        #[inline] fn count_zeros( self ) -> u32 {
                            <$T>::count_zeros( self )
                        }

                        #[inline] fn leading_ones( self ) -> u32 {
                            <$T>::leading_ones( self )
                        }

                        #[inline] fn leading_zeros( self ) -> u32 {
                            <$T>::leading_zeros( self )
                        }

                        #[inline] fn trailing_ones( self ) -> u32 {
                            <$T>::trailing_ones( self )
                        }

                        #[inline] fn trailing_zeros( self ) -> u32 {
                            <$T>::trailing_zeros( self )
                        }

                        #[inline] fn rotate_left( self, n: u32 ) -> Self {
                            <$T>::rotate_left( self, n )
                        }

                        #[inline] fn rotate_right( self, n: u32 ) -> Self {
                            <$T>::rotate_right( self, n )
                        }

                        #[inline] fn signed_shl( self, n: u32 ) -> Self {
                            ( ( self as $S ) << n ) as $T
                        }

                        #[inline] fn signed_shr( self, n: u32 ) -> Self {
                            ( ( self as $S ) >> n ) as $T
                        }

                        #[inline] fn unsigned_shl( self, n: u32 ) -> Self {
                            ( ( self as $U ) << n ) as $T
                        }

                        #[inline] fn unsigned_shr( self, n: u32 ) -> Self {
                            ( ( self as $U ) >> n ) as $T
                        }

                        #[inline] fn swap_bytes( self ) -> Self {
                            <$T>::swap_bytes( self )
                        }

                        #[inline] fn reverse_bits( self ) -> Self {
                            <$T>::reverse_bits( self )
                        }

                        #[inline] fn from_be( x: Self ) -> Self {
                            <$T>::from_be( x )
                        }

                        #[inline] fn from_le( x: Self ) -> Self {
                            <$T>::from_le( x )
                        }

                        #[inline] fn to_be( self ) -> Self {
                            <$T>::to_be( self )
                        }

                        #[inline] fn to_le( self ) -> Self {
                            <$T>::to_le( self )
                        }

                        #[inline] fn pow( self, exp: u32 ) -> Self {
                            <$T>::pow( self, exp )
                        }
                    }
                };
            }
            
            prim_int_impl!( u8, i8, u8 );
            prim_int_impl!( u16, i16, u16 );
            prim_int_impl!( u32, i32, u32 );
            prim_int_impl!( u64, i64, u64 );
            prim_int_impl!( u128, i128, u128 );
            prim_int_impl!( usize, isize, usize );
            prim_int_impl!( i8, i8, u8 );
            prim_int_impl!( i16, i16, u16 );
            prim_int_impl!( i32, i32, u32 );
            prim_int_impl!( i64, i64, u64 );
            prim_int_impl!( i128, i128, u128 );
            prim_int_impl!( isize, isize, usize );
        } pub use self::int::PrimInt;

        pub mod ops
        {
            use ::
            {
                *,
            };
            /*
            */
            pub mod bytes
            {
                /*!
                */
                use ::
                {
                    borrow::{ Borrow, BorrowMut },
                    cmp::{ Eq, Ord, PartialEq, PartialOrd },
                    fmt::{ Debug },
                    hash::{ Hash },
                    *,
                };
                /*
                */
                pub trait NumBytes:
                    Debug
                    + AsRef<[u8]>
                    + AsMut<[u8]>
                    + PartialEq
                    + Eq
                    + PartialOrd
                    + Ord
                    + Hash
                    + Borrow<[u8]>
                    + BorrowMut<[u8]>
                {
                }
                impl<T> NumBytes for T where
                    T: Debug
                        + AsRef<[u8]>
                        + AsMut<[u8]>
                        + PartialEq
                        + Eq
                        + PartialOrd
                        + Ord
                        + Hash
                        + Borrow<[u8]>
                        + BorrowMut<[u8]>
                        + ?Sized
                {
                }

                pub trait ToBytes {
                    type Bytes: NumBytes;

                    fn to_be_bytes( &self ) -> Self::Bytes;

                    fn to_le_bytes( &self ) -> Self::Bytes;

                    fn to_ne_bytes( &self ) -> Self::Bytes {
                        #[cfg( target_endian = "big" )]
                        let bytes = self.to_be_bytes();
                        #[cfg( target_endian = "little" )]
                        let bytes = self.to_le_bytes();
                        bytes
                    }
                }

                pub trait FromBytes: Sized {
                    type Bytes: NumBytes + ?Sized;

                    fn from_be_bytes( bytes:&Self::Bytes ) -> Self;

                    fn from_le_bytes( bytes:&Self::Bytes ) -> Self;

                    fn from_ne_bytes( bytes:&Self::Bytes ) -> Self {
                        #[cfg( target_endian = "big" )]
                        let this = Self::from_be_bytes( bytes );
                        #[cfg( target_endian = "little" )]
                        let this = Self::from_le_bytes( bytes );
                        this
                    }
                }
                macro_rules! float_to_from_bytes_impl {
                    ( $T:ty, $L:expr ) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes( &self ) -> Self::Bytes { <$T>::to_be_bytes( *self ) }
                            #[inline]
                            fn to_le_bytes( &self ) -> Self::Bytes { <$T>::to_le_bytes( *self ) }
                            #[inline]
                            fn to_ne_bytes( &self ) -> Self::Bytes { <$T>::to_ne_bytes( *self ) }
                        }
                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_be_bytes( *bytes )
                            }
                            #[inline]
                            fn from_le_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_le_bytes( *bytes )
                            }
                            #[inline]
                            fn from_ne_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_ne_bytes( *bytes )
                            }
                        }
                    };
                }
                macro_rules! int_to_from_bytes_impl {
                    ( $T:ty, $L:expr ) => {
                        impl ToBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn to_be_bytes( &self ) -> Self::Bytes { <$T>::to_be_bytes( *self ) }
                            #[inline]
                            fn to_le_bytes( &self ) -> Self::Bytes { <$T>::to_le_bytes( *self ) }
                            #[inline]
                            fn to_ne_bytes( &self ) -> Self::Bytes { <$T>::to_ne_bytes( *self ) }
                        }
                        impl FromBytes for $T {
                            type Bytes = [u8; $L];

                            #[inline]
                            fn from_be_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_be_bytes( *bytes )
                            }
                            #[inline]
                            fn from_le_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_le_bytes( *bytes )
                            }
                            #[inline]
                            fn from_ne_bytes( bytes:&Self::Bytes ) -> Self {
                                <$T>::from_ne_bytes( *bytes )
                            }
                        }
                    };
                }
                int_to_from_bytes_impl!( u8, 1 );
                int_to_from_bytes_impl!( u16, 2 );
                int_to_from_bytes_impl!( u32, 4 );
                int_to_from_bytes_impl!( u64, 8 );
                int_to_from_bytes_impl!( u128, 16 );
                #[cfg( target_pointer_width = "64" )]
                int_to_from_bytes_impl!( usize, 8 );
                #[cfg( target_pointer_width = "32" )]
                int_to_from_bytes_impl!( usize, 4 );

                int_to_from_bytes_impl!( i8, 1 );
                int_to_from_bytes_impl!( i16, 2 );
                int_to_from_bytes_impl!( i32, 4 );
                int_to_from_bytes_impl!( i64, 8 );
                int_to_from_bytes_impl!( i128, 16 );
                #[cfg( target_pointer_width = "64" )]
                int_to_from_bytes_impl!( isize, 8 );
                #[cfg( target_pointer_width = "32" )]
                int_to_from_bytes_impl!( isize, 4 );

                float_to_from_bytes_impl!( f32, 4 );
                float_to_from_bytes_impl!( f64, 8 );
            }
            
            pub mod checked
            {
                /*!
                */
                use ::
                {
                    ops::{Add, Div, Mul, Rem, Shl, Shr, Sub},
                    *,
                };
                /*
                */

                pub trait CheckedAdd: Sized + Add<Self, Output = Self>
                {
                    fn checked_add( &self, v:&Self ) -> Option<Self>;
                }
                macro_rules! checked_impl {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, v:&$t ) -> Option<$t> { <$t>::$method( *self, *v ) }
                        }
                    };
                }
                checked_impl!( CheckedAdd, checked_add, u8 );
                checked_impl!( CheckedAdd, checked_add, u16 );
                checked_impl!( CheckedAdd, checked_add, u32 );
                checked_impl!( CheckedAdd, checked_add, u64 );
                checked_impl!( CheckedAdd, checked_add, usize );
                checked_impl!( CheckedAdd, checked_add, u128 );

                checked_impl!( CheckedAdd, checked_add, i8 );
                checked_impl!( CheckedAdd, checked_add, i16 );
                checked_impl!( CheckedAdd, checked_add, i32 );
                checked_impl!( CheckedAdd, checked_add, i64 );
                checked_impl!( CheckedAdd, checked_add, isize );
                checked_impl!( CheckedAdd, checked_add, i128 );

                pub trait CheckedSub: Sized + Sub<Self, Output = Self>
                {
                    fn checked_sub( &self, v:&Self ) -> Option<Self>;
                }
                checked_impl!( CheckedSub, checked_sub, u8 );
                checked_impl!( CheckedSub, checked_sub, u16 );
                checked_impl!( CheckedSub, checked_sub, u32 );
                checked_impl!( CheckedSub, checked_sub, u64 );
                checked_impl!( CheckedSub, checked_sub, usize );
                checked_impl!( CheckedSub, checked_sub, u128 );

                checked_impl!( CheckedSub, checked_sub, i8 );
                checked_impl!( CheckedSub, checked_sub, i16 );
                checked_impl!( CheckedSub, checked_sub, i32 );
                checked_impl!( CheckedSub, checked_sub, i64 );
                checked_impl!( CheckedSub, checked_sub, isize );
                checked_impl!( CheckedSub, checked_sub, i128 );

                pub trait CheckedMul: Sized + Mul<Self, Output = Self>
                {
                    fn checked_mul( &self, v:&Self ) -> Option<Self>;
                }
                checked_impl!( CheckedMul, checked_mul, u8 );
                checked_impl!( CheckedMul, checked_mul, u16 );
                checked_impl!( CheckedMul, checked_mul, u32 );
                checked_impl!( CheckedMul, checked_mul, u64 );
                checked_impl!( CheckedMul, checked_mul, usize );
                checked_impl!( CheckedMul, checked_mul, u128 );

                checked_impl!( CheckedMul, checked_mul, i8 );
                checked_impl!( CheckedMul, checked_mul, i16 );
                checked_impl!( CheckedMul, checked_mul, i32 );
                checked_impl!( CheckedMul, checked_mul, i64 );
                checked_impl!( CheckedMul, checked_mul, isize );
                checked_impl!( CheckedMul, checked_mul, i128 );
                pub trait CheckedDiv: Sized + Div<Self, Output = Self>
                {
                    fn checked_div( &self, v:&Self ) -> Option<Self>;
                }
                checked_impl!( CheckedDiv, checked_div, u8 );
                checked_impl!( CheckedDiv, checked_div, u16 );
                checked_impl!( CheckedDiv, checked_div, u32 );
                checked_impl!( CheckedDiv, checked_div, u64 );
                checked_impl!( CheckedDiv, checked_div, usize );
                checked_impl!( CheckedDiv, checked_div, u128 );

                checked_impl!( CheckedDiv, checked_div, i8 );
                checked_impl!( CheckedDiv, checked_div, i16 );
                checked_impl!( CheckedDiv, checked_div, i32 );
                checked_impl!( CheckedDiv, checked_div, i64 );
                checked_impl!( CheckedDiv, checked_div, isize );
                checked_impl!( CheckedDiv, checked_div, i128 );

                pub trait CheckedRem: Sized + Rem<Self, Output = Self> { fn checked_rem( &self, v:&Self ) -> Option<Self>; }
                checked_impl!( CheckedRem, checked_rem, u8 );
                checked_impl!( CheckedRem, checked_rem, u16 );
                checked_impl!( CheckedRem, checked_rem, u32 );
                checked_impl!( CheckedRem, checked_rem, u64 );
                checked_impl!( CheckedRem, checked_rem, usize );
                checked_impl!( CheckedRem, checked_rem, u128 );

                checked_impl!( CheckedRem, checked_rem, i8 );
                checked_impl!( CheckedRem, checked_rem, i16 );
                checked_impl!( CheckedRem, checked_rem, i32 );
                checked_impl!( CheckedRem, checked_rem, i64 );
                checked_impl!( CheckedRem, checked_rem, isize );
                checked_impl!( CheckedRem, checked_rem, i128 );

                macro_rules! checked_impl_unary {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self ) -> Option<$t> { <$t>::$method( *self ) }
                        }
                    };
                }

                pub trait CheckedNeg: Sized
                {
                    fn checked_neg( &self ) -> Option<Self>;
                }
                checked_impl_unary!( CheckedNeg, checked_neg, u8 );
                checked_impl_unary!( CheckedNeg, checked_neg, u16 );
                checked_impl_unary!( CheckedNeg, checked_neg, u32 );
                checked_impl_unary!( CheckedNeg, checked_neg, u64 );
                checked_impl_unary!( CheckedNeg, checked_neg, usize );
                checked_impl_unary!( CheckedNeg, checked_neg, u128 );

                checked_impl_unary!( CheckedNeg, checked_neg, i8 );
                checked_impl_unary!( CheckedNeg, checked_neg, i16 );
                checked_impl_unary!( CheckedNeg, checked_neg, i32 );
                checked_impl_unary!( CheckedNeg, checked_neg, i64 );
                checked_impl_unary!( CheckedNeg, checked_neg, isize );
                checked_impl_unary!( CheckedNeg, checked_neg, i128 );

                pub trait CheckedShl: Sized + Shl<u32, Output = Self>
                {
                    fn checked_shl( &self, rhs: u32 ) -> Option<Self>;
                }
                macro_rules! checked_shift_impl {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, rhs: u32 ) -> Option<$t> { <$t>::$method( *self, rhs ) }
                        }
                    };
                }
                checked_shift_impl!( CheckedShl, checked_shl, u8 );
                checked_shift_impl!( CheckedShl, checked_shl, u16 );
                checked_shift_impl!( CheckedShl, checked_shl, u32 );
                checked_shift_impl!( CheckedShl, checked_shl, u64 );
                checked_shift_impl!( CheckedShl, checked_shl, usize );
                checked_shift_impl!( CheckedShl, checked_shl, u128 );

                checked_shift_impl!( CheckedShl, checked_shl, i8 );
                checked_shift_impl!( CheckedShl, checked_shl, i16 );
                checked_shift_impl!( CheckedShl, checked_shl, i32 );
                checked_shift_impl!( CheckedShl, checked_shl, i64 );
                checked_shift_impl!( CheckedShl, checked_shl, isize );
                checked_shift_impl!( CheckedShl, checked_shl, i128 );

                pub trait CheckedShr: Sized + Shr<u32, Output = Self> { fn checked_shr( &self, rhs: u32 ) -> Option<Self>; }
                checked_shift_impl!( CheckedShr, checked_shr, u8 );
                checked_shift_impl!( CheckedShr, checked_shr, u16 );
                checked_shift_impl!( CheckedShr, checked_shr, u32 );
                checked_shift_impl!( CheckedShr, checked_shr, u64 );
                checked_shift_impl!( CheckedShr, checked_shr, usize );
                checked_shift_impl!( CheckedShr, checked_shr, u128 );

                checked_shift_impl!( CheckedShr, checked_shr, i8 );
                checked_shift_impl!( CheckedShr, checked_shr, i16 );
                checked_shift_impl!( CheckedShr, checked_shr, i32 );
                checked_shift_impl!( CheckedShr, checked_shr, i64 );
                checked_shift_impl!( CheckedShr, checked_shr, isize );
                checked_shift_impl!( CheckedShr, checked_shr, i128 );

            }
            
            pub mod euclid
            {
                /*!
                */
                use ::
                {
                    ops::{Div, Rem},
                    *,
                };
                /*
                */
                pub trait Euclid: Sized + Div<Self, Output = Self> + Rem<Self, Output = Self> {

                    fn div_euclid( &self, v:&Self ) -> Self;

                    fn rem_euclid( &self, v:&Self ) -> Self;

                    fn div_rem_euclid( &self, v:&Self ) -> ( Self, Self ) {
                        ( self.div_euclid( v ), self.rem_euclid( v ) )
                    }
                }
                macro_rules! euclid_forward_impl 
                {
                    ( $( $t:ty )* ) => {$( 
                        impl Euclid for $t {
                            #[inline]
                            fn div_euclid( &self, v:&$t ) -> Self {
                                <$t>::div_euclid( *self, *v )
                            }
                            #[inline]
                            fn rem_euclid( &self, v:&$t ) -> Self {
                                <$t>::rem_euclid( *self, *v )
                            }
                        }
                    )*}
                }
                euclid_forward_impl!( isize i8 i16 i32 i64 i128 );
                euclid_forward_impl!( usize u8 u16 u32 u64 u128 );
                euclid_forward_impl!( f32 f64 );

                pub trait CheckedEuclid: Euclid
                {

                    fn checked_div_euclid( &self, v:&Self ) -> Option<Self>;
                    fn checked_rem_euclid( &self, v:&Self ) -> Option<Self>;
                    fn checked_div_rem_euclid( &self, v:&Self ) -> Option<( Self, Self )> { Some( ( self.checked_div_euclid( v )?, self.checked_rem_euclid( v )? ) ) }
                }
                macro_rules! checked_euclid_forward_impl 
                {
                    ( $( $t:ty )* ) => {$( 
                        impl CheckedEuclid for $t {
                            #[inline]
                            fn checked_div_euclid( &self, v:&$t ) -> Option<Self> { <$t>::checked_div_euclid( *self, *v ) }
                            #[inline]
                            fn checked_rem_euclid( &self, v:&$t ) -> Option<Self> { <$t>::checked_rem_euclid( *self, *v ) }
                        }
                    )*}
                }
                checked_euclid_forward_impl!( isize i8 i16 i32 i64 i128 );
                checked_euclid_forward_impl!( usize u8 u16 u32 u64 u128 );
            }
            
            pub mod inv
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub trait Inv {

                    type Output;

                    fn inv( self ) -> Self::Output;
                }
                impl Inv for f32 {
                    type Output = f32;
                    #[inline] fn inv( self ) -> f32 {
                        1.0 / self
                    }
                }
                impl Inv for f64 {
                    type Output = f64;
                    #[inline] fn inv( self ) -> f64 {
                        1.0 / self
                    }
                }
                impl<'a> Inv for &'a f32 {
                    type Output = f32;
                    #[inline] fn inv( self ) -> f32 {
                        1.0 / *self
                    }
                }
                impl<'a> Inv for &'a f64 {
                    type Output = f64;
                    #[inline] fn inv( self ) -> f64 {
                        1.0 / *self
                    }
                }
            }
            
            pub mod mul_add
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                pub trait MulAdd<A = Self, B = Self> 
                {

                    type Output;

                    fn mul_add( self, a: A, b: B ) -> Self::Output;
                }

                pub trait MulAddAssign<A = Self, B = Self> 
                {

                    fn mul_add_assign( &mut self, a: A, b: B );
                }
                
                impl MulAdd<f32, f32> for f32                    
                {
                    type Output = Self;

                    #[inline] fn mul_add( self, a: Self, b: Self ) -> Self::Output {
                        <Self as ::num::traits::Float>::mul_add( self, a, b )
                    }
                }
                
                impl MulAdd<f64, f64> for f64
                {
                    type Output = Self;

                    #[inline] fn mul_add( self, a: Self, b: Self ) -> Self::Output {
                        <Self as ::num::traits::Float>::mul_add( self, a, b )
                    }
                }
                macro_rules! mul_add_impl 
                {
                    ( $trait_name:ident for $( $t:ty )* ) => {$( 
                        impl $trait_name for $t {
                            type Output = Self;

                            #[inline]
                            fn mul_add( self, a: Self, b: Self ) -> Self::Output {
                                ( self * a ) + b
                            }
                        }
                    )*}
                }
                mul_add_impl!( MulAdd for isize i8 i16 i32 i64 i128 );
                mul_add_impl!( MulAdd for usize u8 u16 u32 u64 u128 );
                
                impl MulAddAssign<f32, f32> for f32
                {
                    #[inline] fn mul_add_assign( &mut self, a: Self, b: Self ) {
                        *self = <Self as ::num::traits::Float>::mul_add( *self, a, b )
                    }
                }
                
                impl MulAddAssign<f64, f64> for f64
                {
                    #[inline] fn mul_add_assign( &mut self, a: Self, b: Self ) {
                        *self = <Self as ::num::traits::Float>::mul_add( *self, a, b )
                    }
                }
                macro_rules! mul_add_assign_impl
                {
                    ( $trait_name:ident for $( $t:ty )* ) => {$( 
                        impl $trait_name for $t {
                            #[inline]
                            fn mul_add_assign( &mut self, a: Self, b: Self ) {
                                *self = ( *self * a ) + b
                            }
                        }
                    )*}
                }
                mul_add_assign_impl!( MulAddAssign for isize i8 i16 i32 i64 i128 );
                mul_add_assign_impl!( MulAddAssign for usize u8 u16 u32 u64 u128 );
            }
            
            pub mod overflowing
            {
                /*!
                */
                use ::
                {
                    ops::{Add, Mul, Sub},
                    *,
                };
                /*
                */
                macro_rules! overflowing_impl {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, v:&Self ) -> ( Self, bool ) {
                                <$t>::$method( *self, *v )
                            }
                        }
                    };
                }

                pub trait OverflowingAdd: Sized + Add<Self, Output = Self>
                {
                    fn overflowing_add( &self, v:&Self ) -> ( Self, bool );
                }
                overflowing_impl!( OverflowingAdd, overflowing_add, u8 );
                overflowing_impl!( OverflowingAdd, overflowing_add, u16 );
                overflowing_impl!( OverflowingAdd, overflowing_add, u32 );
                overflowing_impl!( OverflowingAdd, overflowing_add, u64 );
                overflowing_impl!( OverflowingAdd, overflowing_add, usize );
                overflowing_impl!( OverflowingAdd, overflowing_add, u128 );

                overflowing_impl!( OverflowingAdd, overflowing_add, i8 );
                overflowing_impl!( OverflowingAdd, overflowing_add, i16 );
                overflowing_impl!( OverflowingAdd, overflowing_add, i32 );
                overflowing_impl!( OverflowingAdd, overflowing_add, i64 );
                overflowing_impl!( OverflowingAdd, overflowing_add, isize );
                overflowing_impl!( OverflowingAdd, overflowing_add, i128 );

                pub trait OverflowingSub: Sized + Sub<Self, Output = Self>
                {
                    fn overflowing_sub( &self, v:&Self ) -> ( Self, bool );
                }
                overflowing_impl!( OverflowingSub, overflowing_sub, u8 );
                overflowing_impl!( OverflowingSub, overflowing_sub, u16 );
                overflowing_impl!( OverflowingSub, overflowing_sub, u32 );
                overflowing_impl!( OverflowingSub, overflowing_sub, u64 );
                overflowing_impl!( OverflowingSub, overflowing_sub, usize );
                overflowing_impl!( OverflowingSub, overflowing_sub, u128 );

                overflowing_impl!( OverflowingSub, overflowing_sub, i8 );
                overflowing_impl!( OverflowingSub, overflowing_sub, i16 );
                overflowing_impl!( OverflowingSub, overflowing_sub, i32 );
                overflowing_impl!( OverflowingSub, overflowing_sub, i64 );
                overflowing_impl!( OverflowingSub, overflowing_sub, isize );
                overflowing_impl!( OverflowingSub, overflowing_sub, i128 );

                pub trait OverflowingMul: Sized + Mul<Self, Output = Self>
                {
                    fn overflowing_mul( &self, v:&Self ) -> ( Self, bool );
                }
                overflowing_impl!( OverflowingMul, overflowing_mul, u8 );
                overflowing_impl!( OverflowingMul, overflowing_mul, u16 );
                overflowing_impl!( OverflowingMul, overflowing_mul, u32 );
                overflowing_impl!( OverflowingMul, overflowing_mul, u64 );
                overflowing_impl!( OverflowingMul, overflowing_mul, usize );
                overflowing_impl!( OverflowingMul, overflowing_mul, u128 );

                overflowing_impl!( OverflowingMul, overflowing_mul, i8 );
                overflowing_impl!( OverflowingMul, overflowing_mul, i16 );
                overflowing_impl!( OverflowingMul, overflowing_mul, i32 );
                overflowing_impl!( OverflowingMul, overflowing_mul, i64 );
                overflowing_impl!( OverflowingMul, overflowing_mul, isize );
                overflowing_impl!( OverflowingMul, overflowing_mul, i128 );
            }
            
            pub mod saturating
            {
                /*!
                */
                use ::
                {
                    ops::{Add, Mul, Sub},
                    *,
                };
                /*
                */

                pub trait Saturating
               
                {
                    fn saturating_add( self, v: Self ) -> Self;
                    fn saturating_sub( self, v: Self ) -> Self;
                }
                macro_rules! deprecated_saturating_impl
                {
                    ( $trait_name:ident for $( $t:ty )* ) => {$( 
                        impl $trait_name for $t {
                            #[inline]
                            fn saturating_add( self, v: Self ) -> Self {
                                Self::saturating_add( self, v )
                            }
                            #[inline]
                            fn saturating_sub( self, v: Self ) -> Self {
                                Self::saturating_sub( self, v )
                            }
                        }
                    )*}
                }
                deprecated_saturating_impl!( Saturating for isize i8 i16 i32 i64 i128 );
                deprecated_saturating_impl!( Saturating for usize u8 u16 u32 u64 u128 );

                macro_rules! saturating_impl
                {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, v:&Self ) -> Self {
                                <$t>::$method( *self, *v )
                            }
                        }
                    };
                }

                pub trait SaturatingAdd: Sized + Add<Self, Output = Self>
                {
                    fn saturating_add( &self, v:&Self ) -> Self;
                }
                saturating_impl!( SaturatingAdd, saturating_add, u8 );
                saturating_impl!( SaturatingAdd, saturating_add, u16 );
                saturating_impl!( SaturatingAdd, saturating_add, u32 );
                saturating_impl!( SaturatingAdd, saturating_add, u64 );
                saturating_impl!( SaturatingAdd, saturating_add, usize );
                saturating_impl!( SaturatingAdd, saturating_add, u128 );

                saturating_impl!( SaturatingAdd, saturating_add, i8 );
                saturating_impl!( SaturatingAdd, saturating_add, i16 );
                saturating_impl!( SaturatingAdd, saturating_add, i32 );
                saturating_impl!( SaturatingAdd, saturating_add, i64 );
                saturating_impl!( SaturatingAdd, saturating_add, isize );
                saturating_impl!( SaturatingAdd, saturating_add, i128 );

                pub trait SaturatingSub: Sized + Sub<Self, Output = Self> 
               
                {
                    fn saturating_sub( &self, v:&Self ) -> Self;
                }
                saturating_impl!( SaturatingSub, saturating_sub, u8 );
                saturating_impl!( SaturatingSub, saturating_sub, u16 );
                saturating_impl!( SaturatingSub, saturating_sub, u32 );
                saturating_impl!( SaturatingSub, saturating_sub, u64 );
                saturating_impl!( SaturatingSub, saturating_sub, usize );
                saturating_impl!( SaturatingSub, saturating_sub, u128 );

                saturating_impl!( SaturatingSub, saturating_sub, i8 );
                saturating_impl!( SaturatingSub, saturating_sub, i16 );
                saturating_impl!( SaturatingSub, saturating_sub, i32 );
                saturating_impl!( SaturatingSub, saturating_sub, i64 );
                saturating_impl!( SaturatingSub, saturating_sub, isize );
                saturating_impl!( SaturatingSub, saturating_sub, i128 );

                pub trait SaturatingMul: Sized + Mul<Self, Output = Self> 
               
                {
                    fn saturating_mul( &self, v:&Self ) -> Self;
                }
                saturating_impl!( SaturatingMul, saturating_mul, u8 );
                saturating_impl!( SaturatingMul, saturating_mul, u16 );
                saturating_impl!( SaturatingMul, saturating_mul, u32 );
                saturating_impl!( SaturatingMul, saturating_mul, u64 );
                saturating_impl!( SaturatingMul, saturating_mul, usize );
                saturating_impl!( SaturatingMul, saturating_mul, u128 );

                saturating_impl!( SaturatingMul, saturating_mul, i8 );
                saturating_impl!( SaturatingMul, saturating_mul, i16 );
                saturating_impl!( SaturatingMul, saturating_mul, i32 );
                saturating_impl!( SaturatingMul, saturating_mul, i64 );
                saturating_impl!( SaturatingMul, saturating_mul, isize );
                saturating_impl!( SaturatingMul, saturating_mul, i128 );
            }
            
            pub mod wrapping
            {
                /*!
                */
                use ::
                {
                    num::{ Wrapping },
                    ops::{ Add, Mul, Neg, Shl, Shr, Sub },
                    *,
                };
                /*
                */
                macro_rules! wrapping_impl
                {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, v:&Self ) -> Self {
                                <$t>::$method( *self, *v )
                            }
                        }
                    };
                    ( $trait_name:ident, $method:ident, $t:ty, $rhs:ty ) => {
                        impl $trait_name<$rhs> for $t {
                            #[inline]
                            fn $method( &self, v:&$rhs ) -> Self {
                                <$t>::$method( *self, *v )
                            }
                        }
                    };
                }

                pub trait WrappingAdd: Sized + Add<Self, Output = Self>
                {
                    fn wrapping_add( &self, v:&Self ) -> Self;
                }
                wrapping_impl!( WrappingAdd, wrapping_add, u8 );
                wrapping_impl!( WrappingAdd, wrapping_add, u16 );
                wrapping_impl!( WrappingAdd, wrapping_add, u32 );
                wrapping_impl!( WrappingAdd, wrapping_add, u64 );
                wrapping_impl!( WrappingAdd, wrapping_add, usize );
                wrapping_impl!( WrappingAdd, wrapping_add, u128 );

                wrapping_impl!( WrappingAdd, wrapping_add, i8 );
                wrapping_impl!( WrappingAdd, wrapping_add, i16 );
                wrapping_impl!( WrappingAdd, wrapping_add, i32 );
                wrapping_impl!( WrappingAdd, wrapping_add, i64 );
                wrapping_impl!( WrappingAdd, wrapping_add, isize );
                wrapping_impl!( WrappingAdd, wrapping_add, i128 );

                pub trait WrappingSub: Sized + Sub<Self, Output = Self>
                {
                    fn wrapping_sub( &self, v:&Self ) -> Self;
                }
                wrapping_impl!( WrappingSub, wrapping_sub, u8 );
                wrapping_impl!( WrappingSub, wrapping_sub, u16 );
                wrapping_impl!( WrappingSub, wrapping_sub, u32 );
                wrapping_impl!( WrappingSub, wrapping_sub, u64 );
                wrapping_impl!( WrappingSub, wrapping_sub, usize );
                wrapping_impl!( WrappingSub, wrapping_sub, u128 );

                wrapping_impl!( WrappingSub, wrapping_sub, i8 );
                wrapping_impl!( WrappingSub, wrapping_sub, i16 );
                wrapping_impl!( WrappingSub, wrapping_sub, i32 );
                wrapping_impl!( WrappingSub, wrapping_sub, i64 );
                wrapping_impl!( WrappingSub, wrapping_sub, isize );
                wrapping_impl!( WrappingSub, wrapping_sub, i128 );

                pub trait WrappingMul: Sized + Mul<Self, Output = Self>
                {
                    fn wrapping_mul( &self, v:&Self ) -> Self;
                }
                wrapping_impl!( WrappingMul, wrapping_mul, u8 );
                wrapping_impl!( WrappingMul, wrapping_mul, u16 );
                wrapping_impl!( WrappingMul, wrapping_mul, u32 );
                wrapping_impl!( WrappingMul, wrapping_mul, u64 );
                wrapping_impl!( WrappingMul, wrapping_mul, usize );
                wrapping_impl!( WrappingMul, wrapping_mul, u128 );

                wrapping_impl!( WrappingMul, wrapping_mul, i8 );
                wrapping_impl!( WrappingMul, wrapping_mul, i16 );
                wrapping_impl!( WrappingMul, wrapping_mul, i32 );
                wrapping_impl!( WrappingMul, wrapping_mul, i64 );
                wrapping_impl!( WrappingMul, wrapping_mul, isize );
                wrapping_impl!( WrappingMul, wrapping_mul, i128 );

                macro_rules! wrapping_unary_impl 
                {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self ) -> $t { <$t>::$method( *self ) }
                        }
                    };
                }

                pub trait WrappingNeg: Sized 
               
                {
                    fn wrapping_neg( &self ) -> Self;
                }
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u8 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u16 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u32 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u64 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, usize );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, u128 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i8 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i16 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i32 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i64 );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, isize );
                wrapping_unary_impl!( WrappingNeg, wrapping_neg, i128 );

                macro_rules! wrapping_shift_impl 
                {
                    ( $trait_name:ident, $method:ident, $t:ty ) => {
                        impl $trait_name for $t {
                            #[inline]
                            fn $method( &self, rhs: u32 ) -> $t {
                                <$t>::$method( *self, rhs )
                            }
                        }
                    };
                }

                pub trait WrappingShl: Sized + Shl<usize, Output = Self> 
               
                {
                    fn wrapping_shl( &self, rhs: u32 ) -> Self;
                }
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u8 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u16 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u32 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u64 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, usize );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, u128 );

                wrapping_shift_impl!( WrappingShl, wrapping_shl, i8 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, i16 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, i32 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, i64 );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, isize );
                wrapping_shift_impl!( WrappingShl, wrapping_shl, i128 );

                pub trait WrappingShr: Sized + Shr<usize, Output = Self> 
               
                {
                    fn wrapping_shr( &self, rhs: u32 ) -> Self;
                }
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u8 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u16 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u32 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u64 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, usize );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, u128 );

                wrapping_shift_impl!( WrappingShr, wrapping_shr, i8 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, i16 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, i32 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, i64 );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, isize );
                wrapping_shift_impl!( WrappingShr, wrapping_shr, i128 );
               
                impl<T: WrappingAdd> WrappingAdd for Wrapping<T> where
                    Wrapping<T>: Add<Output = Wrapping<T>>,
               
                {
                    fn wrapping_add( &self, v:&Self ) -> Self {
                        Wrapping( self.0.wrapping_add( &v.0 ) )
                    }
                }
                
                impl<T: WrappingSub> WrappingSub for Wrapping<T> where
                    Wrapping<T>: Sub<Output = Wrapping<T>>,
               
                {
                    fn wrapping_sub( &self, v:&Self ) -> Self {
                        Wrapping( self.0.wrapping_sub( &v.0 ) )
                    }
                }
                impl<T: WrappingMul> WrappingMul for Wrapping<T> where
                    Wrapping<T>: Mul<Output = Wrapping<T>>,
               
                {
                    fn wrapping_mul( &self, v:&Self ) -> Self {
                        Wrapping( self.0.wrapping_mul( &v.0 ) )
                    }
                }
                impl<T: WrappingNeg> WrappingNeg for Wrapping<T> where
                    Wrapping<T>: Neg<Output = Wrapping<T>>,
               
                {
                    fn wrapping_neg( &self ) -> Self { Wrapping( self.0.wrapping_neg() ) }
                }
                impl<T: WrappingShl> WrappingShl for Wrapping<T> where
                    Wrapping<T>: Shl<usize, Output = Wrapping<T>>,
               
                {
                    fn wrapping_shl( &self, rhs: u32 ) -> Self {
                        Wrapping( self.0.wrapping_shl( rhs ) )
                    }
                }
                impl<T: WrappingShr> WrappingShr for Wrapping<T> where
                    Wrapping<T>: Shr<usize, Output = Wrapping<T>>,
               
                {
                    fn wrapping_shr( &self, rhs: u32 ) -> Self {
                        Wrapping( self.0.wrapping_shr( rhs ) )
                    }
                }
            }
        } pub use self::ops::
        {
            bytes::{ FromBytes, ToBytes },
            checked::{ CheckedAdd, CheckedDiv, CheckedMul, CheckedNeg, CheckedRem, CheckedShl, CheckedShr, CheckedSub },
            euclid::{ CheckedEuclid, Euclid },
            inv::{ Inv },
            mul_add::{ MulAdd, MulAddAssign },
            saturating::{ Saturating, SaturatingAdd, SaturatingMul, SaturatingSub },
            wrapping::{ WrappingAdd, WrappingMul, WrappingNeg, WrappingShl, WrappingShr, WrappingSub },
        };

        pub mod pow
        {
            use ::
            {
                num::
                {
                    traits::{ CheckedMul, One, Float }, Wrapping
                },
                ops::{ Mul },
                *,
            };
            /*
            */

            pub trait Pow<RHS>
            {

                type Output;
                fn pow( self, rhs: RHS ) -> Self::Output;
            }
            macro_rules! pow_impl {
                ( $t:ty ) =>
                {
                    pow_impl!( $t, u8 );
                    pow_impl!( $t, usize );
                };
                ( $t:ty, $rhs:ty ) => { pow_impl!( $t, $rhs, usize, pow ); };
                ( $t:ty, $rhs:ty, $desired_rhs:ty, $method:expr ) => {
                    impl Pow<$rhs> for $t {
                        type Output = $t;
                        #[inline] fn pow( self, rhs: $rhs ) -> $t {
                            ( $method )( self, <$desired_rhs>::from( rhs ) )
                        }
                    }
                    impl<'a> Pow<&'a $rhs> for $t {
                        type Output = $t;
                        #[inline] fn pow( self, rhs:&'a $rhs ) -> $t {
                            ( $method )( self, <$desired_rhs>::from( *rhs ) )
                        }
                    }
                    impl<'a> Pow<$rhs> for &'a $t {
                        type Output = $t;
                        #[inline] fn pow( self, rhs: $rhs ) -> $t {
                            ( $method )( *self, <$desired_rhs>::from( rhs ) )
                        }
                    }
                    impl<'a, 'b> Pow<&'a $rhs> for &'b $t {
                        type Output = $t;
                        #[inline] fn pow( self, rhs:&'a $rhs ) -> $t {
                            ( $method )( *self, <$desired_rhs>::from( *rhs ) )
                        }
                    }
                };
            }
            pow_impl!( u8, u8, u32, u8::pow );
            pow_impl!( u8, u16, u32, u8::pow );
            pow_impl!( u8, u32, u32, u8::pow );
            pow_impl!( u8, usize );
            pow_impl!( i8, u8, u32, i8::pow );
            pow_impl!( i8, u16, u32, i8::pow );
            pow_impl!( i8, u32, u32, i8::pow );
            pow_impl!( i8, usize );
            pow_impl!( u16, u8, u32, u16::pow );
            pow_impl!( u16, u16, u32, u16::pow );
            pow_impl!( u16, u32, u32, u16::pow );
            pow_impl!( u16, usize );
            pow_impl!( i16, u8, u32, i16::pow );
            pow_impl!( i16, u16, u32, i16::pow );
            pow_impl!( i16, u32, u32, i16::pow );
            pow_impl!( i16, usize );
            pow_impl!( u32, u8, u32, u32::pow );
            pow_impl!( u32, u16, u32, u32::pow );
            pow_impl!( u32, u32, u32, u32::pow );
            pow_impl!( u32, usize );
            pow_impl!( i32, u8, u32, i32::pow );
            pow_impl!( i32, u16, u32, i32::pow );
            pow_impl!( i32, u32, u32, i32::pow );
            pow_impl!( i32, usize );
            pow_impl!( u64, u8, u32, u64::pow );
            pow_impl!( u64, u16, u32, u64::pow );
            pow_impl!( u64, u32, u32, u64::pow );
            pow_impl!( u64, usize );
            pow_impl!( i64, u8, u32, i64::pow );
            pow_impl!( i64, u16, u32, i64::pow );
            pow_impl!( i64, u32, u32, i64::pow );
            pow_impl!( i64, usize );

            pow_impl!( u128, u8, u32, u128::pow );
            pow_impl!( u128, u16, u32, u128::pow );
            pow_impl!( u128, u32, u32, u128::pow );
            pow_impl!( u128, usize );

            pow_impl!( i128, u8, u32, i128::pow );
            pow_impl!( i128, u16, u32, i128::pow );
            pow_impl!( i128, u32, u32, i128::pow );
            pow_impl!( i128, usize );

            pow_impl!( usize, u8, u32, usize::pow );
            pow_impl!( usize, u16, u32, usize::pow );
            pow_impl!( usize, u32, u32, usize::pow );
            pow_impl!( usize, usize );
            pow_impl!( isize, u8, u32, isize::pow );
            pow_impl!( isize, u16, u32, isize::pow );
            pow_impl!( isize, u32, u32, isize::pow );
            pow_impl!( isize, usize );
            pow_impl!( Wrapping<u8> );
            pow_impl!( Wrapping<i8> );
            pow_impl!( Wrapping<u16> );
            pow_impl!( Wrapping<i16> );
            pow_impl!( Wrapping<u32> );
            pow_impl!( Wrapping<i32> );
            pow_impl!( Wrapping<u64> );
            pow_impl!( Wrapping<i64> );
            pow_impl!( Wrapping<u128> );
            pow_impl!( Wrapping<i128> );
            pow_impl!( Wrapping<usize> );
            pow_impl!( Wrapping<isize> );

            pow_impl!( f32, i8, i32, <f32 as Float>::powi );
            pow_impl!( f32, u8, i32, <f32 as Float>::powi );
            pow_impl!( f32, i16, i32, <f32 as Float>::powi );
            pow_impl!( f32, u16, i32, <f32 as Float>::powi );
            pow_impl!( f32, i32, i32, <f32 as Float>::powi );
            pow_impl!( f64, i8, i32, <f64 as Float>::powi );
            pow_impl!( f64, u8, i32, <f64 as Float>::powi );
            pow_impl!( f64, i16, i32, <f64 as Float>::powi );
            pow_impl!( f64, u16, i32, <f64 as Float>::powi );
            pow_impl!( f64, i32, i32, <f64 as Float>::powi );
            pow_impl!( f32, f32, f32, <f32 as Float>::powf );
            pow_impl!( f64, f32, f64, <f64 as Float>::powf );
            pow_impl!( f64, f64, f64, <f64 as Float>::powf );            

            #[inline] pub fn pow<T: Clone + One + Mul<T, Output = T>>( mut base: T, mut exp: usize ) -> T 
            {
                if exp == 0 {
                    return T::one();
                }
                while exp & 1 == 0 {
                    base = base.clone() * base;
                    exp >>= 1;
                }
                if exp == 1 {
                    return base;
                }
                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.clone() * base;
                    if exp & 1 == 1 {
                        acc = acc * base.clone();
                    }
                }
                acc
            }

            #[inline] pub fn checked_pow<T: Clone + One + CheckedMul>( mut base: T, mut exp: usize ) -> Option<T> 
            {
                if exp == 0 {
                    return Some( T::one() );
                }
                while exp & 1 == 0 {
                    base = base.checked_mul( &base )?;
                    exp >>= 1;
                }
                if exp == 1 {
                    return Some( base );
                }
                let mut acc = base.clone();
                while exp > 1 {
                    exp >>= 1;
                    base = base.checked_mul( &base )?;
                    if exp & 1 == 1 {
                        acc = acc.checked_mul( &base )?;
                    }
                }
                Some( acc )
            }

        } pub use self::pow::{checked_pow, pow, Pow};

        pub mod real
        {
            use ::
            {
                num::traits::{Float, Num, NumCast},
                ops::{ Neg },
                *,
            };
            /*
            */
            pub trait Real: Num + Copy + NumCast + PartialOrd + Neg<Output = Self>
            {
                fn min_value() -> Self;
                fn min_positive_value() -> Self;
                fn epsilon() -> Self;
                fn max_value() -> Self;
                fn floor( self ) -> Self;
                fn ceil( self ) -> Self;
                fn round( self ) -> Self;
                fn trunc( self ) -> Self;
                fn fract( self ) -> Self;
                fn abs( self ) -> Self;
                fn signum( self ) -> Self;
                fn is_sign_positive( self ) -> bool;
                fn is_sign_negative( self ) -> bool;
                fn mul_add( self, a: Self, b: Self ) -> Self;
                fn recip( self ) -> Self;
                fn powi( self, n: i32 ) -> Self;
                fn powf( self, n: Self ) -> Self;
                fn sqrt( self ) -> Self;
                fn exp( self ) -> Self;
                fn exp2( self ) -> Self;
                fn ln( self ) -> Self;
                fn log( self, base: Self ) -> Self;
                fn log2( self ) -> Self;
                fn log10( self ) -> Self;
                fn to_degrees( self ) -> Self;
                fn to_radians( self ) -> Self;
                fn max( self, other: Self ) -> Self;
                fn min( self, other: Self ) -> Self;
                fn abs_sub( self, other: Self ) -> Self;
                fn cbrt( self ) -> Self;
                fn hypot( self, other: Self ) -> Self;
                fn sin( self ) -> Self;
                fn cos( self ) -> Self;
                fn tan( self ) -> Self;
                fn asin( self ) -> Self;
                fn acos( self ) -> Self;
                fn atan( self ) -> Self;
                fn atan2( self, other: Self ) -> Self;
                fn sin_cos( self ) -> ( Self, Self );
                fn exp_m1( self ) -> Self;
                fn ln_1p( self ) -> Self;
                fn sinh( self ) -> Self;
                fn cosh( self ) -> Self;
                fn tanh( self ) -> Self;
                fn asinh( self ) -> Self;
                fn acosh( self ) -> Self;
                fn atanh( self ) -> Self;
            }
            
            impl<T: Float> Real for T
            {
                forward! {
                    Float::min_value() -> Self;
                    Float::min_positive_value() -> Self;
                    Float::epsilon() -> Self;
                    Float::max_value() -> Self;
                }
                forward! {
                    Float::floor( self ) -> Self;
                    Float::ceil( self ) -> Self;
                    Float::round( self ) -> Self;
                    Float::trunc( self ) -> Self;
                    Float::fract( self ) -> Self;
                    Float::abs( self ) -> Self;
                    Float::signum( self ) -> Self;
                    Float::is_sign_positive( self ) -> bool;
                    Float::is_sign_negative( self ) -> bool;
                    Float::mul_add( self, a: Self, b: Self ) -> Self;
                    Float::recip( self ) -> Self;
                    Float::powi( self, n: i32 ) -> Self;
                    Float::powf( self, n: Self ) -> Self;
                    Float::sqrt( self ) -> Self;
                    Float::exp( self ) -> Self;
                    Float::exp2( self ) -> Self;
                    Float::ln( self ) -> Self;
                    Float::log( self, base: Self ) -> Self;
                    Float::log2( self ) -> Self;
                    Float::log10( self ) -> Self;
                    Float::to_degrees( self ) -> Self;
                    Float::to_radians( self ) -> Self;
                    Float::max( self, other: Self ) -> Self;
                    Float::min( self, other: Self ) -> Self;
                    Float::abs_sub( self, other: Self ) -> Self;
                    Float::cbrt( self ) -> Self;
                    Float::hypot( self, other: Self ) -> Self;
                    Float::sin( self ) -> Self;
                    Float::cos( self ) -> Self;
                    Float::tan( self ) -> Self;
                    Float::asin( self ) -> Self;
                    Float::acos( self ) -> Self;
                    Float::atan( self ) -> Self;
                    Float::atan2( self, other: Self ) -> Self;
                    Float::sin_cos( self ) -> ( Self, Self );
                    Float::exp_m1( self ) -> Self;
                    Float::ln_1p( self ) -> Self;
                    Float::sinh( self ) -> Self;
                    Float::cosh( self ) -> Self;
                    Float::tanh( self ) -> Self;
                    Float::asinh( self ) -> Self;
                    Float::acosh( self ) -> Self;
                    Float::atanh( self ) -> Self;
                }
            }
        }

        pub mod sign
        {
            use ::
            {
                num::
                {
                    traits::{ float::{ Float, FloatCore }, Num }, Wrapping
                },
                ops::{ Neg },
                *,
            };
            /*
            */

            pub trait Signed: Sized + Num + Neg<Output = Self>
            {
                fn abs( &self ) -> Self;
                fn abs_sub( &self, other:&Self ) -> Self;
                fn signum( &self ) -> Self;
                fn is_positive( &self ) -> bool;
                fn is_negative( &self ) -> bool;
            }
            macro_rules! signed_impl {
                ( $( $t:ty )* ) => ( $( 
                    impl Signed for $t {
                        #[inline] fn abs( &self ) -> $t { if self.is_negative() { -*self } else { *self } }

                        #[inline] fn abs_sub( &self, other:&$t ) -> $t {
                            if *self <= *other { 0 } else { *self - *other }
                        }

                        #[inline] fn signum( &self ) -> $t {
                            match *self {
                                n if n > 0 => 1,
                                0 => 0,
                                _ => -1,
                            }
                        }

                        #[inline] fn is_positive( &self ) -> bool { *self > 0 }

                        #[inline] fn is_negative( &self ) -> bool { *self < 0 }
                    }
                )* )
            }
            signed_impl!( isize i8 i16 i32 i64 i128 );

            impl<T: Signed> Signed for Wrapping<T> where
                Wrapping<T>: Num + Neg<Output = Wrapping<T>>,
            {
                #[inline] fn abs( &self ) -> Self { Wrapping( self.0.abs() ) }
                
                #[inline] fn abs_sub( &self, other:&Self ) -> Self {
                    Wrapping( self.0.abs_sub( &other.0 ) )
               }
                
                #[inline] fn signum( &self ) -> Self { Wrapping( self.0.signum() ) }
                
                #[inline] fn is_positive( &self ) -> bool { self.0.is_positive() }
                
                #[inline] fn is_negative( &self ) -> bool { self.0.is_negative() }
            }
            macro_rules! signed_float_impl {
                ( $t:ty ) => {
                    impl Signed for $t {

                        #[inline] fn abs( &self ) -> $t { Float::abs( *self ) }

                        #[inline] fn abs_sub( &self, other:&$t ) -> $t {
                            if *self <= *other {
                                0.
                            } else {
                                *self - *other
                            }
                        }

                        ///
                        #[inline] fn signum( &self ) -> $t { Float::signum( *self ) }

                        #[inline] fn is_positive( &self ) -> bool { Float::is_sign_positive( *self ) }

                        #[inline] fn is_negative( &self ) -> bool { Float::is_sign_negative( *self ) }
                    }
                };
            }
            signed_float_impl!( f32 );
            signed_float_impl!( f64 );

            #[inline( always )] pub fn abs<T: Signed>( value: T ) -> T {
                value.abs()
            }

            #[inline( always )] pub fn abs_sub<T: Signed>( x: T, y: T ) -> T {
                x.abs_sub( &y )
            }

            #[inline( always )] pub fn signum<T: Signed>( value: T ) -> T {
                value.signum()
            }

            pub trait Unsigned: Num {}
            macro_rules! empty_trait_impl
            {
                ( $name:ident for $( $t:ty )* ) => ( $( 
                    impl $name for $t {}
                )* )
            }
            empty_trait_impl!( Unsigned for usize u8 u16 u32 u64 u128 );

            impl<T: Unsigned> Unsigned for Wrapping<T>  where Wrapping<T>: Num {}
        } pub use self::sign::{abs, abs_sub, signum, Signed, Unsigned};

        pub trait Num: PartialEq + Zero + One + NumOps
        {
            type FromStrRadixErr;
            fn from_str_radix( str:&str, radix: u32 ) -> Result<Self, Self::FromStrRadixErr>;
        }

        pub trait NumOps<Rhs = Self, Output = Self>:
        Add<Rhs, Output = Output>
        + Sub<Rhs, Output = Output>
        + Mul<Rhs, Output = Output>
        + Div<Rhs, Output = Output>
        + Rem<Rhs, Output = Output>
        {
        }

        impl<T, Rhs, Output> NumOps<Rhs, Output> for T where
        T: Add<Rhs, Output = Output>
        + Sub<Rhs, Output = Output>
        + Mul<Rhs, Output = Output>
        + Div<Rhs, Output = Output>
        + Rem<Rhs, Output = Output>
        {
        }

        pub trait NumRef: Num + for<'r> NumOps<&'r Self> {}
        impl<T> NumRef for T  where T: Num + for<'r> NumOps<&'r T> {}

        pub trait RefNum<Base>: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}
        impl<T, Base> RefNum<Base> for T  where T: NumOps<Base, Base> + for<'r> NumOps<&'r Base, Base> {}

        pub trait NumAssignOps<Rhs = Self>:
        AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }

        impl<T, Rhs> NumAssignOps<Rhs> for T where
        T: AddAssign<Rhs> + SubAssign<Rhs> + MulAssign<Rhs> + DivAssign<Rhs> + RemAssign<Rhs>
        {
        }

        pub trait NumAssign: Num + NumAssignOps {}
        impl<T> NumAssign for T  where T: Num + NumAssignOps {}

        pub trait NumAssignRef: NumAssign + for<'r> NumAssignOps<&'r Self> {}
        impl<T> NumAssignRef for T  where T: NumAssign + for<'r> NumAssignOps<&'r T> {}

        macro_rules! int_trait_impl
        {
            ( $name:ident for $( $t:ty )* ) => ( $( 
                impl $name for $t {
                    type FromStrRadixErr = ::num::ParseIntError;
                    #[inline] fn from_str_radix( s:&str, radix: u32 )
                                    -> Result<Self, ::num::ParseIntError>
                    {
                        <$t>::from_str_radix( s, radix )
                    }
                }
            )* )
        }

        int_trait_impl!( Num for usize u8 u16 u32 u64 u128 );
        int_trait_impl!( Num for isize i8 i16 i32 i64 i128 );

        impl<T: Num> Num for Wrapping<T> where
            Wrapping<T>: NumOps,
        {
            type FromStrRadixErr = T::FromStrRadixErr;
            fn from_str_radix( str:&str, radix: u32 ) -> Result<Self, Self::FromStrRadixErr> { T::from_str_radix( str, radix ).map( Wrapping ) }
        }
        
        #[derive( Debug )]
        pub enum FloatErrorKind
        {
            Empty,
            Invalid,
        }
        
        #[derive( Debug )]
        pub struct ParseFloatError
        {
            pub kind: FloatErrorKind,
        }

        impl fmt::Display for ParseFloatError
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {let description = match self.kind {
                    FloatErrorKind::Empty => "cannot parse float from empty string",
                    FloatErrorKind::Invalid => "invalid float literal",
                };

                description.fmt( f )
            }
        }

        fn str_to_ascii_lower_eq_str( a:&str, b:&str ) -> bool
        {
            a.len() == b.len()
                && a.bytes().zip( b.bytes() ).all( |( a, b )| {
                    let a_to_ascii_lower = a | ( ( ( b'A' <= a && a <= b'Z' ) as u8 ) << 5 );
                    a_to_ascii_lower == b
                } )
        }
        
        macro_rules! float_trait_impl
        {
            ( $name:ident for $( $t:ident )* ) => ( $( 
                impl $name for $t {
                    type FromStrRadixErr = ParseFloatError;

                    fn from_str_radix( src:&str, radix: u32 )
                                    -> Result<Self, Self::FromStrRadixErr>
                    {
                        use self::FloatErrorKind::*;
                        use self::ParseFloatError as PFE;

                       
                        if radix == 10 {
                            return src.parse().map_err( |_| PFE {
                                kind: if src.is_empty() { Empty } else { Invalid },
                            } );
                        }
                       
                        if str_to_ascii_lower_eq_str( src, "inf" )
                            || str_to_ascii_lower_eq_str( src, "infinity" )
                        {
                            return Ok( ::$t::INFINITY );
                        } else if str_to_ascii_lower_eq_str( src, "-inf" )
                            || str_to_ascii_lower_eq_str( src, "-infinity" )
                        {
                            return Ok( ::$t::NEG_INFINITY );
                        } else if str_to_ascii_lower_eq_str( src, "nan" ) {
                            return Ok( ::$t::NAN );
                        } else if str_to_ascii_lower_eq_str( src, "-nan" ) {
                            return Ok( -::$t::NAN );
                        }
                        fn slice_shift_char( src:&str ) -> Option<( char, &str )> {
                            let mut chars = src.chars();
                            Some( ( chars.next()?, chars.as_str() ) )
                        }
                        let ( is_positive, src ) =  match slice_shift_char( src ) {
                            None             => return Err( PFE { kind: Empty } ),
                            Some( ( '-', "" ) )  => return Err( PFE { kind: Empty } ),
                            Some( ( '-', src ) ) => ( false, src ),
                            Some( ( _, _ ) )     => ( true,  src ),
                        };

                       
                        let mut sig = if is_positive { 0.0 } else { -0.0 };
                       
                        let mut prev_sig = sig;
                        let mut cs = src.chars().enumerate();
                       
                        let mut exp_info = None::<( char, usize )>;

                       
                        for ( i, c ) in cs.by_ref() {
                            match c.to_digit( radix ) {
                                Some( digit ) => {
                                   
                                    sig *= radix as $t;

                                   
                                    if is_positive {
                                        sig += ( digit as isize ) as $t;
                                    } else {
                                        sig -= ( digit as isize ) as $t;
                                    }
                                   
                                   
                                    if prev_sig != 0.0 {
                                        if is_positive && sig <= prev_sig
                                            { return Ok( ::$t::INFINITY ); }
                                        if !is_positive && sig >= prev_sig
                                            { return Ok( ::$t::NEG_INFINITY ); }
                                       
                                        if is_positive && ( prev_sig != ( sig - digit as $t ) / radix as $t )
                                            { return Ok( ::$t::INFINITY ); }
                                        if !is_positive && ( prev_sig != ( sig + digit as $t ) / radix as $t )
                                            { return Ok( ::$t::NEG_INFINITY ); }
                                    }
                                    prev_sig = sig;
                                },
                                None => match c {
                                    'e' | 'E' | 'p' | 'P' => {
                                        exp_info = Some( ( c, i + 1 ) );
                                        break; 
                                    },
                                    '.' => { break;  },
                                    _ => { return Err( PFE { kind: Invalid } ); },
                                },
                            }
                        }
                       
                       
                        if exp_info.is_none() {
                            let mut power = 1.0;
                            for ( i, c ) in cs.by_ref() {
                                match c.to_digit( radix ) {
                                    Some( digit ) => {
                                       
                                        power /= radix as $t;
                                       
                                        sig = if is_positive {
                                            sig + ( digit as $t ) * power
                                        } else {
                                            sig - ( digit as $t ) * power
                                        };
                                       
                                        if is_positive && sig < prev_sig
                                            { return Ok( ::$t::INFINITY ); }
                                        if !is_positive && sig > prev_sig
                                            { return Ok( ::$t::NEG_INFINITY ); }
                                        prev_sig = sig;
                                    },
                                    None => match c {
                                        'e' | 'E' | 'p' | 'P' => {
                                            exp_info = Some( ( c, i + 1 ) );
                                            break;
                                        },
                                        _ => { return Err( PFE { kind: Invalid } ); },
                                    },
                                }
                            }
                        }
                       
                        let exp = match exp_info {
                            Some( ( c, offset ) ) => {
                                let base = match c {
                                    'E' | 'e' if radix == 10 => 10.0,
                                    'P' | 'p' if radix == 16 => 2.0,
                                    _ => return Err( PFE { kind: Invalid } ),
                                };

                               
                                let src = &src[offset..];
                                let ( is_positive, exp ) = match slice_shift_char( src ) {
                                    Some( ( '-', src ) ) => ( false, src.parse::<usize>() ),
                                    Some( ( '+', src ) ) => ( true,  src.parse::<usize>() ),
                                    Some( ( _, _ ) )     => ( true,  src.parse::<usize>() ),
                                    None             => return Err( PFE { kind: Invalid } ),
                                };

                                                    fn pow( base: $t, exp: usize ) -> $t {
                                    Float::powi( base, exp as i32 )
                                }
                               

                                match ( is_positive, exp ) {
                                    ( true,  Ok( exp ) ) => pow( base, exp ),
                                    ( false, Ok( exp ) ) => 1.0 / pow( base, exp ),
                                    ( _, Err( _ ) )      => return Err( PFE { kind: Invalid } ),
                                }
                            },
                            None => 1.0,
                        };

                        Ok( sig * exp )
                    }
                }
            )* )
        }
        
        float_trait_impl!( Num for f32 f64 );

        #[inline] pub fn clamp<T: PartialOrd>( input: T, min: T, max: T ) -> T
        {
            debug_assert!( min <= max, "min must be less than or equal to max" );
            if input < min {
                min
            } else if input > max {
                max
            } else {
                input
            }
        }

        #[inline] pub fn clamp_min<T: PartialOrd>( input: T, min: T ) -> T
        {
            debug_assert!( min == min, "min must not be NAN" );
            if input < min {
                min
            } else {
                input
            }
        }

        #[inline] pub fn clamp_max<T: PartialOrd>( input: T, max: T ) -> T
        {
            debug_assert!( max == max, "max must not be NAN" );
            if input > max {
                max
            } else {
                input
            }
        }
    }
    /*
    */
    pub mod integers
    {
        //! Integer trait and functions.
        use ::
        {
            num::{ traits::{ Num, Signed, Zero } },
            ops::{ Add },
            *,
        };
        /*
        */
        pub mod average
        {
            /*!
            */
            use ::
            {
                num::integers::{ Integer },
                ops::{BitAnd, BitOr, BitXor, Shr},
                *,
            };
            /*
            */

            pub trait Average: Integer {
                fn average_floor( &self, other:&Self ) -> Self;
                fn average_ceil( &self, other:&Self ) -> Self;
            }
            
            impl<I> Average for I where
            I: Integer + Shr<usize, Output = I>,
            for<'a, 'b> &'a I: BitAnd<&'b I, Output = I> 
            + BitOr<&'b I, Output = I> 
            + BitXor<&'b I, Output = I>,
            {

                #[inline] fn average_floor( &self, other:&I ) -> I {
                    ( self & other ) + ( ( self ^ other ) >> 1 )
                }

                #[inline] fn average_ceil( &self, other:&I ) -> I {
                    ( self | other ) - ( ( self ^ other ) >> 1 )
                }
            }
            #[inline] pub fn average_floor<T: Average>( x: T, y: T ) -> T {
                x.average_floor( &y )
            }
            #[inline] pub fn average_ceil<T: Average>( x: T, y: T ) -> T {
                x.average_ceil( &y )
            }
        } pub use self::average::{average_ceil, average_floor, Average};

        pub mod roots
        {
            /*!
            */
            use ::
            {
                num::
                {
                    traits::{checked_pow, PrimInt},
                    integers::{ Integer },
                },
                *,
            };
            /*
            */
            pub trait Roots: Integer {
                fn nth_root( &self, n: u32 ) -> Self;

                ///

                #[inline] fn sqrt( &self ) -> Self { self.nth_root( 2 ) }
                ///

                #[inline] fn cbrt( &self ) -> Self { self.nth_root( 3 ) }
            }
            #[inline] pub fn sqrt<T: Roots>( x: T ) -> T {
                x.sqrt()
            }
            #[inline] pub fn cbrt<T: Roots>( x: T ) -> T {
                x.cbrt()
            }
            #[inline] pub fn nth_root<T: Roots>( x: T, n: u32 ) -> T {
                x.nth_root( n )
            }
            macro_rules! signed_roots {
                ( $T:ty, $U:ty ) => {
                    impl Roots for $T {
                        #[inline] fn nth_root( &self, n: u32 ) -> Self {
                            if *self >= 0 {
                                ( *self as $U ).nth_root( n ) as Self
                            } else {
                                assert!( n.is_odd(), "even roots of a negative are imaginary" );
                                -( ( self.wrapping_neg() as $U ).nth_root( n ) as Self )
                            }
                        }

                        #[inline] fn sqrt( &self ) -> Self {
                            assert!( *self >= 0, "the square root of a negative is imaginary" );
                            ( *self as $U ).sqrt() as Self
                        }

                        #[inline] fn cbrt( &self ) -> Self {
                            if *self >= 0 {
                                ( *self as $U ).cbrt() as Self
                            } else {
                                -( ( self.wrapping_neg() as $U ).cbrt() as Self )
                            }
                        }
                    }
                };
            }
            signed_roots!( i8, u8 );
            signed_roots!( i16, u16 );
            signed_roots!( i32, u32 );
            signed_roots!( i64, u64 );
            signed_roots!( i128, u128 );
            signed_roots!( isize, usize );

            #[inline] fn fixpoint<T, F>( mut x: T, f: F ) -> T
            where
                T: Integer + Copy,
                F: Fn( T ) -> T,
            {
                let mut xn = f( x );
                while x < xn {
                    x = xn;
                    xn = f( x );
                }
                while x > xn {
                    x = xn;
                    xn = f( x );
                }
                x
            }
            #[inline] fn bits<T>() -> u32 {
                8 * mem::size_of::<T>() as u32
            }
            #[inline] fn log2<T: PrimInt>( x: T ) -> u32
            {
                debug_assert!( x > T::zero() );
                bits::<T>() - 1 - x.leading_zeros()
            }
            macro_rules! unsigned_roots {
                ( $T:ident ) => {
                    impl Roots for $T {
                        #[inline] fn nth_root( &self, n: u32 ) -> Self {
                            fn go( a: $T, n: u32 ) -> $T {
                               
                                match n {
                                    0 => panic!( "can't find a root of degree 0!" ),
                                    1 => return a,
                                    2 => return a.sqrt(),
                                    3 => return a.cbrt(),
                                    _ => (),
                                }
                               
                                if bits::<$T>() <= n || a < ( 1 << n ) {
                                    return ( a > 0 ) as $T;
                                }
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= ::u64::MAX as $T {
                                        ( a as u64 ).nth_root( n ) as $T
                                    } else {
                                        let lo = ( a >> n ).nth_root( n ) << 1;
                                        let hi = lo + 1;
                                       
                                       
                                        if hi.next_power_of_two().trailing_zeros() * n >= bits::<$T>() {
                                            match checked_pow( hi, n as usize ) {
                                                Some( x ) if x <= a => hi,
                                                _ => lo,
                                            }
                                        } else {
                                            if hi.pow( n ) <= a {
                                                hi
                                            } else {
                                                lo
                                            }
                                        }
                                    };
                                }
                                
                                #[inline] fn guess( x: $T, n: u32 ) -> $T {
                                   
                                    if bits::<$T>() <= 32 || x <= ::u32::MAX as $T {
                                        1 << ( ( log2( x ) + n - 1 ) / n )
                                    } else {
                                        ( ( x as f64 ).ln() / f64::from( n ) ).exp() as $T
                                    }
                                }
                                
                                let n1 = n - 1;
                                let next = |x: $T| {
                                    let y = match checked_pow( x, n1 as usize ) {
                                        Some( ax ) => a / ax,
                                        None => 0,
                                    };
                                    ( y + x * n1 as $T ) / n as $T
                                };
                                fixpoint( guess( a, n ), next )
                            }
                            go( *self, n )
                        }

                        #[inline] fn sqrt( &self ) -> Self {
                            fn go( a: $T ) -> $T {
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= ::u64::MAX as $T {
                                        ( a as u64 ).sqrt() as $T
                                    } else {
                                        let lo = ( a >> 2u32 ).sqrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }
                                if a < 4 {
                                    return ( a > 0 ) as $T;
                                }
                                                    #[inline]
                                fn guess( x: $T ) -> $T {
                                    ( x as f64 ).sqrt() as $T
                                }
                                
                                let next = |x: $T| ( a / x + x ) >> 1;
                                fixpoint( guess( a ), next )
                            }
                            go( *self )
                        }

                        #[inline] fn cbrt( &self ) -> Self {
                            fn go( a: $T ) -> $T {
                                if bits::<$T>() > 64 {
                                   
                                    return if a <= ::u64::MAX as $T {
                                        ( a as u64 ).cbrt() as $T
                                    } else {
                                        let lo = ( a >> 3u32 ).cbrt() << 1;
                                        let hi = lo + 1;
                                        if hi * hi * hi <= a {
                                            hi
                                        } else {
                                            lo
                                        }
                                    };
                                }
                                if bits::<$T>() <= 32 {
                                   
                                    let mut x = a;
                                    let mut y2 = 0;
                                    let mut y = 0;
                                    let smax = bits::<$T>() / 3;
                                    for s in ( 0..smax + 1 ).rev() {
                                        let s = s * 3;
                                        y2 *= 4;
                                        y *= 2;
                                        let b = 3 * ( y2 + y ) + 1;
                                        if x >> s >= b {
                                            x -= b << s;
                                            y2 += 2 * y + 1;
                                            y += 1;
                                        }
                                    }
                                    return y;
                                }
                                if a < 8 {
                                    return ( a > 0 ) as $T;
                                }
                                if a <= ::u32::MAX as $T {
                                    return ( a as u32 ).cbrt() as $T;
                                }
                                                    #[inline]
                                fn guess( x: $T ) -> $T {
                                    ( x as f64 ).cbrt() as $T
                                }
                                
                                let next = |x: $T| ( a / ( x * x ) + x * 2 ) / 3;
                                fixpoint( guess( a ), next )
                            }
                            go( *self )
                        }
                    }
                };
            }
            unsigned_roots!( u8 );
            unsigned_roots!( u16 );
            unsigned_roots!( u32 );
            unsigned_roots!( u64 );
            unsigned_roots!( u128 );
            unsigned_roots!( usize );
        } pub use self::roots::{cbrt, nth_root, sqrt, Roots};

        pub trait Integer: Sized + Num + PartialOrd + Ord + Eq 
        {

            fn div_floor( &self, other:&Self ) -> Self;
            fn mod_floor( &self, other:&Self ) -> Self;
            fn div_ceil( &self, other:&Self ) -> Self {
                let ( q, r ) = self.div_mod_floor( other );
                if r.is_zero() {
                    q
                } else {
                    q + Self::one()
                }
            }

            fn gcd( &self, other:&Self ) -> Self;
            fn lcm( &self, other:&Self ) -> Self;
            #[inline] fn gcd_lcm( &self, other:&Self ) -> ( Self, Self ) {
                ( self.gcd( other ), self.lcm( other ) )
            }

            #[inline] fn extended_gcd( &self, other:&Self ) -> ExtendedGcd<Self> where
                Self: Clone,
            {
                let mut s = ( Self::zero(), Self::one() );
                let mut t = ( Self::one(), Self::zero() );
                let mut r = ( other.clone(), self.clone() );

                while !r.0.is_zero() {
                    let q = r.1.clone() / r.0.clone();
                    let f = |mut r: ( Self, Self )| {
                        mem::swap( &mut r.0, &mut r.1 );
                        r.0 = r.0 - q.clone() * r.1.clone();
                        r
                    };
                    r = f( r );
                    s = f( s  );
                    t = f( t );
                }
                if r.1 >= Self::zero() {
                    ExtendedGcd {
                        gcd: r.1,
                        x: s.1,
                        y: t.1,
                    }
                } else {
                    ExtendedGcd {
                        gcd: Self::zero() - r.1,
                        x: Self::zero() - s.1,
                        y: Self::zero() - t.1,
                    }
                }
            }

            #[inline] fn extended_gcd_lcm( &self, other:&Self ) -> ( ExtendedGcd<Self>, Self )
            where
                Self: Clone + Signed,
            {
                ( self.extended_gcd( other ), self.lcm( other ) )
            }

            #[deprecated( note = "Please use is_multiple_of instead" )]
            #[inline] fn divides( &self, other:&Self ) -> bool {
                self.is_multiple_of( other )
            }

            fn is_multiple_of( &self, other:&Self ) -> bool;
            fn is_even( &self ) -> bool;
            fn is_odd( &self ) -> bool;
            fn div_rem( &self, other:&Self ) -> ( Self, Self );
            fn div_mod_floor( &self, other:&Self ) -> ( Self, Self ) {
                ( self.div_floor( other ), self.mod_floor( other ) )
            }

            #[inline] fn next_multiple_of( &self, other:&Self ) -> Self
            where
                Self: Clone,
            {
                let m = self.mod_floor( other );
                self.clone()
                    + if m.is_zero() {
                        Self::zero()
                    } else {
                        other.clone() - m
                    }
            }

            #[inline] fn prev_multiple_of( &self, other:&Self ) -> Self
            where
                Self: Clone,
            {
                self.clone() - self.mod_floor( other )
            }
            
            fn dec( &mut self )
            where
                Self: Clone,
            {
                *self = self.clone() - Self::one()
            }
            
            fn inc( &mut self )
            where
                Self: Clone,
            {
                *self = self.clone() + Self::one()
            }
        }

        #[derive( Debug, Clone, Copy, PartialEq, Eq )]
        pub struct ExtendedGcd<A> 
        {
            pub gcd: A,
            pub x: A,
            pub y: A,
        }

        #[inline] pub fn div_rem<T: Integer>( x: T, y: T ) -> ( T, T ) 
        {
            x.div_rem( &y )
        }

        #[inline] pub fn div_floor<T: Integer>( x: T, y: T ) -> T 
        {
            x.div_floor( &y )
        }

        #[inline] pub fn mod_floor<T: Integer>( x: T, y: T ) -> T 
        {
            x.mod_floor( &y )
        }

        #[inline] pub fn div_mod_floor<T: Integer>( x: T, y: T ) -> ( T, T ) 
        {
            x.div_mod_floor( &y )
        }

        #[inline] pub fn div_ceil<T: Integer>( x: T, y: T ) -> T 
        {
            x.div_ceil( &y )
        }

        #[inline( always )] pub fn gcd<T: Integer>( x: T, y: T ) -> T 
        {
            x.gcd( &y )
        }

        #[inline( always )] pub fn lcm<T: Integer>( x: T, y: T ) -> T 
        {
            x.lcm( &y )
        }

        #[inline( always )] pub fn gcd_lcm<T: Integer>( x: T, y: T ) -> ( T, T ) 
        {
            x.gcd_lcm( &y )
        }

        macro_rules! impl_integer_for_isize 
        {
            ( $T:ty, $test_mod:ident ) => {
                impl Integer for $T {

                    #[inline] fn div_floor( &self, other:&Self ) -> Self {
                       
                       
                        let ( d, r ) = self.div_rem( other );
                        if ( r > 0 && *other < 0 ) || ( r < 0 && *other > 0 ) {
                            d - 1
                        } else {
                            d
                        }
                    }

                    #[inline] fn mod_floor( &self, other:&Self ) -> Self {
                       
                       
                        let r = *self % *other;
                        if ( r > 0 && *other < 0 ) || ( r < 0 && *other > 0 ) {
                            r + *other
                        } else {
                            r
                        }
                    }

                    #[inline] fn div_mod_floor( &self, other:&Self ) -> ( Self, Self ) {
                       
                       
                        let ( d, r ) = self.div_rem( other );
                        if ( r > 0 && *other < 0 ) || ( r < 0 && *other > 0 ) {
                            ( d - 1, r + *other )
                        } else {
                            ( d, r )
                        }
                    }
                    #[inline] fn div_ceil( &self, other:&Self ) -> Self {
                        let ( d, r ) = self.div_rem( other );
                        if ( r > 0 && *other > 0 ) || ( r < 0 && *other < 0 ) {
                            d + 1
                        } else {
                            d
                        }
                    }
                    #[inline] fn gcd( &self, other:&Self ) -> Self {
                       
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return ( m | n ).abs();
                        }
                       
                        let shift = ( m | n ).trailing_zeros();

                       
                       
                       
                       

                       
                       
                       
                        if m == Self::min_value() || n == Self::min_value() {
                            return ( 1 << shift ).abs();
                        }
                       
                        m = m.abs();
                        n = n.abs();

                       
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }
                    #[inline] fn extended_gcd_lcm( &self, other:&Self ) -> ( ExtendedGcd<Self>, Self ) {
                        let egcd = self.extended_gcd( other );
                       
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            ( *self * ( *other / egcd.gcd ) ).abs()
                        };
                        ( egcd, lcm )
                    }
                    #[inline] fn lcm( &self, other:&Self ) -> Self {
                        self.gcd_lcm( other ).1
                    }
                    #[inline] fn gcd_lcm( &self, other:&Self ) -> ( Self, Self ) {
                        if self.is_zero() && other.is_zero() {
                            return ( Self::zero(), Self::zero() );
                        }
                        let gcd = self.gcd( other );
                       
                        let lcm = ( *self * ( *other / gcd ) ).abs();
                        ( gcd, lcm )
                    }

                    #[inline] fn is_multiple_of( &self, other:&Self ) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    #[inline] fn is_even( &self ) -> bool { ( *self ) & 1 == 0 }

                    #[inline] fn is_odd( &self ) -> bool { !self.is_even() }

                    #[inline] fn div_rem( &self, other:&Self ) -> ( Self, Self ) {
                        ( *self / *other, *self % *other )
                    }

                    #[inline] fn next_multiple_of( &self, other:&Self ) -> Self {
                       
                        if *other == -1 {
                            return *self;
                        }
                        let m = Integer::mod_floor( self, other );
                        *self + if m == 0 { 0 } else { other - m }
                    }

                    #[inline] fn prev_multiple_of( &self, other:&Self ) -> Self {
                       
                        if *other == -1 {
                            return *self;
                        }
                        *self - Integer::mod_floor( self, other )
                    }
                }
            };
        }

        impl_integer_for_isize!( i8, test_integer_i8 );
        impl_integer_for_isize!( i16, test_integer_i16 );
        impl_integer_for_isize!( i32, test_integer_i32 );
        impl_integer_for_isize!( i64, test_integer_i64 );
        impl_integer_for_isize!( i128, test_integer_i128 );
        impl_integer_for_isize!( isize, test_integer_isize );

        macro_rules! impl_integer_for_usize 
        {
            ( $T:ty, $test_mod:ident ) => {
                impl Integer for $T {

                    #[inline] fn div_floor( &self, other:&Self ) -> Self {
                        *self / *other
                    }

                    #[inline] fn mod_floor( &self, other:&Self ) -> Self {
                        *self % *other
                    }
                    #[inline] fn div_ceil( &self, other:&Self ) -> Self {
                        *self / *other + ( 0 != *self % *other ) as Self
                    }

                    #[inline] fn gcd( &self, other:&Self ) -> Self {
                       
                        let mut m = *self;
                        let mut n = *other;
                        if m == 0 || n == 0 {
                            return m | n;
                        }
                       
                        let shift = ( m | n ).trailing_zeros();

                       
                        m >>= m.trailing_zeros();
                        n >>= n.trailing_zeros();

                        while m != n {
                            if m > n {
                                m -= n;
                                m >>= m.trailing_zeros();
                            } else {
                                n -= m;
                                n >>= n.trailing_zeros();
                            }
                        }
                        m << shift
                    }
                    #[inline] fn extended_gcd_lcm( &self, other:&Self ) -> ( ExtendedGcd<Self>, Self ) {
                        let egcd = self.extended_gcd( other );
                       
                        let lcm = if egcd.gcd.is_zero() {
                            Self::zero()
                        } else {
                            *self * ( *other / egcd.gcd )
                        };
                        ( egcd, lcm )
                    }

                    #[inline] fn lcm( &self, other:&Self ) -> Self {
                        self.gcd_lcm( other ).1
                    }
                    #[inline] fn gcd_lcm( &self, other:&Self ) -> ( Self, Self ) {
                        if self.is_zero() && other.is_zero() {
                            return ( Self::zero(), Self::zero() );
                        }
                        let gcd = self.gcd( other );
                        let lcm = *self * ( *other / gcd );
                        ( gcd, lcm )
                    }

                    #[inline] fn is_multiple_of( &self, other:&Self ) -> bool {
                        if other.is_zero() {
                            return self.is_zero();
                        }
                        *self % *other == 0
                    }

                    #[inline] fn is_even( &self ) -> bool { *self % 2 == 0 }

                    #[inline] fn is_odd( &self ) -> bool { !self.is_even() }

                    #[inline] fn div_rem( &self, other:&Self ) -> ( Self, Self ) {
                        ( *self / *other, *self % *other )
                    }
                }
            };
        }

        impl_integer_for_usize!( u8, test_integer_u8 );
        impl_integer_for_usize!( u16, test_integer_u16 );
        impl_integer_for_usize!( u32, test_integer_u32 );
        impl_integer_for_usize!( u64, test_integer_u64 );
        impl_integer_for_usize!( u128, test_integer_u128 );
        impl_integer_for_usize!( usize, test_integer_usize );

        pub struct IterBinomial<T> 
        {
            a: T,
            n: T,
            k: T,
        }

        impl<T> IterBinomial<T> where
            T: Integer,
        {
            ///

            pub fn new( n: T ) -> IterBinomial<T> {
                IterBinomial {
                    k: T::zero(),
                    a: T::one(),
                    n,
                }
            }
        }

        impl<T> Iterator for IterBinomial<T> where
        T: Integer + Clone,
        {
            type Item = T;
            fn next( &mut self ) -> Option<T> {
                if self.k > self.n {
                    return None;
                }
                self.a = if !self.k.is_zero() {
                    multiply_and_divide( 
                        self.a.clone(),
                        self.n.clone() - self.k.clone() + T::one(),
                        self.k.clone(),
                    )
                } else {
                    T::one()
                };
                self.k = self.k.clone() + T::one();
                Some( self.a.clone() )
            }
        }

        fn multiply_and_divide<T: Integer + Clone>( r: T, a: T, b: T ) -> T
        {
           
            let g = gcd( r.clone(), b.clone() );
            r / g.clone() * ( a / ( b / g ) )
        }

        pub fn binomial<T: Integer + Clone>( mut n: T, k: T ) -> T
        {
           
            if k > n {
                return T::zero();
            }
            if k > n.clone() - k.clone() {
                return binomial( n.clone(), n - k );
            }
            let mut r = T::one();
            let mut d = T::one();
            loop {
                if d > k {
                    break;
                }
                r = multiply_and_divide( r, n.clone(), d.clone() );
                n = n - T::one();
                d = d + T::one();
            }
            r
        }

        pub fn multinomial<T: Integer + Clone>( k:&[T] ) -> T where
            for<'a> T: Add<&'a T, Output = T>,
        {
            let mut r = T::one();
            let mut p = T::zero();
            for i in k {
                p = p + i;
                r = r * binomial( p.clone(), i.clone() );
            }
            r
        }
    }
    /*
    */
    pub mod big
    {
        //! Big Integer Types for Rust
        use ::
        {
            *,
        };
        /*
        */
        pub mod int
        {
            use ::
            {
                cmp::{ Ordering::{self, Equal} },
                default::{ Default },
                num::
                {
                    traits::{ ConstZero, Num, One, Pow, Signed, Zero },
                    integers::{Integer, Roots},
                    big::
                    {
                        digit::BigDigit,
                        uint::{BigUint, IntDigits, to_str_radix_reversed, U32Digits, U64Digits},
                    },
                },
                ops::{ Neg, Not },
                string::{ String },
                vec::{ Vec },
                *,
            };
            /*
            */
            use self::Sign::{Minus, NoSign, Plus};

            pub mod addition
            {
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    iter::{ Sum },
                    num::
                    {
                        big::{ IsizePromotion, UsizePromotion },
                        traits::{ CheckedAdd },
                    },
                    ops::{ Add, AddAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{ Negative, Positive };
                use super::Sign::{ Minus, NoSign, Plus };
                use super::{ BigInt, UnsignedAbs };
                /*
                */
                macro_rules! bigint_add 
                {
                    ( $a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr ) => {
                        match ( $a.sign, $b.sign ) {
                            ( _, NoSign ) => $a_owned,
                            ( NoSign, _ ) => $b_owned,
                           
                            ( Plus, Plus ) | ( Minus, Minus ) => BigInt::from_biguint( $a.sign, $a_data + $b_data ),
                           
                            ( Plus, Minus ) | ( Minus, Plus ) => match $a.data.cmp( &$b.data ) {
                                Less => BigInt::from_biguint( $b.sign, $b_data - $a_data ),
                                Greater => BigInt::from_biguint( $a.sign, $a_data - $b_data ),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }
                impl Add<&BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other:&BigInt ) -> BigInt {
                        bigint_add!( 
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }
                impl Add<BigInt> for &BigInt 
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: BigInt ) -> BigInt {
                        bigint_add!( self, self.clone(), &self.data, other, other, other.data )
                    }
                }
                impl Add<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other:&BigInt ) -> BigInt {
                        bigint_add!( self, self, self.data, other, other.clone(), &other.data )
                    }
                }
                impl Add<BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: BigInt ) -> BigInt {
                        bigint_add!( self, self, self.data, other, other, other.data )
                    }
                }
                impl AddAssign<&BigInt> for BigInt 
                {
                    #[inline] fn add_assign( &mut self, other:&BigInt ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n + other;
                    }
                }
                forward_val_assign!( impl AddAssign for BigInt, add_assign );

                promote_all_scalars!( impl Add for BigInt, add );
                promote_all_scalars_assign!( impl AddAssign for BigInt, add_assign );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u32> for BigInt, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u64> for BigInt, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u128> for BigInt, add );

                impl Add<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: u32 ) -> BigInt {
                        match self.sign {
                            NoSign => From::from( other ),
                            Plus => BigInt::from( self.data + other ),
                            Minus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Less => BigInt::from( other - self.data ),
                                Greater => -BigInt::from( self.data - other ),
                            },
                        }
                    }
                }
                impl AddAssign<u32> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: u32 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n + other;
                    }
                }
                impl Add<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: u64 ) -> BigInt {
                        match self.sign {
                            NoSign => From::from( other ),
                            Plus => BigInt::from( self.data + other ),
                            Minus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Less => BigInt::from( other - self.data ),
                                Greater => -BigInt::from( self.data - other ),
                            },
                        }
                    }
                }
                impl AddAssign<u64> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: u64 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n + other;
                    }
                }
                impl Add<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: u128 ) -> BigInt {
                        match self.sign {
                            NoSign => BigInt::from( other ),
                            Plus => BigInt::from( self.data + other ),
                            Minus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Less => BigInt::from( other - self.data ),
                                Greater => -BigInt::from( self.data - other ),
                            },
                        }
                    }
                }
                impl AddAssign<u128> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: u128 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n + other;
                    }
                }
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<i32> for BigInt, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<i64> for BigInt, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<i128> for BigInt, add );

                impl Add<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: i32 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self + u,
                            Negative( u ) => self - u,
                        }
                    }
                }
                impl AddAssign<i32> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: i32 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self += u,
                            Negative( u ) => *self -= u,
                        }
                    }
                }
                impl Add<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: i64 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self + u,
                            Negative( u ) => self - u,
                        }
                    }
                }
                impl AddAssign<i64> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: i64 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self += u,
                            Negative( u ) => *self -= u,
                        }
                    }
                }
                impl Add<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn add( self, other: i128 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self + u,
                            Negative( u ) => self - u,
                        }
                    }
                }
                impl AddAssign<i128> for BigInt
                {
                    #[inline] fn add_assign( &mut self, other: i128 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self += u,
                            Negative( u ) => *self -= u,
                        }
                    }
                }
                impl CheckedAdd for BigInt
                {
                    #[inline] fn checked_add( &self, v:&BigInt ) -> Option<BigInt> { Some( self.add( v ) ) }
                }
                impl_sum_iter_type!( BigInt );
            }
            pub mod division
            {
                use ::
                {
                    num::
                    {
                        big::{IsizePromotion, UsizePromotion},
                        integers::{ Integer },
                        traits::{ CheckedDiv, CheckedEuclid, Euclid, Signed, ToPrimitive, Zero },
                    },
                    ops::{ Div, DivAssign, Rem, RemAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{Negative, Positive};
                use super::Sign::NoSign;
                use super::{BigInt, UnsignedAbs};
                /*
                */
                forward_all_binop_to_ref_ref!( impl Div for BigInt, div );

                impl Div<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other:&BigInt ) -> BigInt {
                        let ( q, _ ) = self.div_rem( other );
                        q
                    }
                }
                impl DivAssign<&BigInt> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other:&BigInt ) {
                        *self = &*self / other;
                    }
                }
                forward_val_assign!( impl DivAssign for BigInt, div_assign );

                promote_all_scalars!( impl Div for BigInt, div );
                promote_all_scalars_assign!( impl DivAssign for BigInt, div_assign );
                forward_all_scalar_binop_to_val_val!( impl Div<u32> for BigInt, div );
                forward_all_scalar_binop_to_val_val!( impl Div<u64> for BigInt, div );
                forward_all_scalar_binop_to_val_val!( impl Div<u128> for BigInt, div );

                impl Div<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: u32 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data / other )
                    }
                }
                impl DivAssign<u32> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: u32 ) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Div<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        BigInt::from_biguint( other.sign, self / other.data )
                    }
                }
                impl Div<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: u64 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data / other )
                    }
                }
                impl DivAssign<u64> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: u64 ) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Div<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        BigInt::from_biguint( other.sign, self / other.data )
                    }
                }
                impl Div<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: u128 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data / other )
                    }
                }
                impl DivAssign<u128> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: u128 ) {
                        self.data /= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Div<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        BigInt::from_biguint( other.sign, self / other.data )
                    }
                }
                forward_all_scalar_binop_to_val_val!( impl Div<i32> for BigInt, div );
                forward_all_scalar_binop_to_val_val!( impl Div<i64> for BigInt, div );
                forward_all_scalar_binop_to_val_val!( impl Div<i128> for BigInt, div );

                impl Div<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: i32 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self / u,
                            Negative( u ) => -self / u,
                        }
                    }
                }
                impl DivAssign<i32> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: i32 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self /= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }
                impl Div<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u / other,
                            Negative( u ) => u / -other,
                        }
                    }
                }
                impl Div<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: i64 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self / u,
                            Negative( u ) => -self / u,
                        }
                    }
                }
                impl DivAssign<i64> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: i64 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self /= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }
                impl Div<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u / other,
                            Negative( u ) => u / -other,
                        }
                    }
                }
                impl Div<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn div( self, other: i128 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self / u,
                            Negative( u ) => -self / u,
                        }
                    }
                }
                impl DivAssign<i128> for BigInt
                {
                    #[inline] fn div_assign( &mut self, other: i128 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self /= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                *self /= u;
                            }
                        }
                    }
                }
                impl Div<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline] fn div( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u / other,
                            Negative( u ) => u / -other,
                        }
                    }
                }
                forward_all_binop_to_ref_ref!( impl Rem for BigInt, rem );

                impl Rem<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other:&BigInt ) -> BigInt {
                        if let Some( other ) = other.to_u32() {
                            self % other
                        } else if let Some( other ) = other.to_i32() {
                            self % other
                        } else {
                            let ( _, r ) = self.div_rem( other );
                            r
                        }
                    }
                }
                impl RemAssign<&BigInt> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other:&BigInt ) {
                        *self = &*self % other;
                    }
                }
                forward_val_assign!( impl RemAssign for BigInt, rem_assign );

                promote_all_scalars!( impl Rem for BigInt, rem );
                promote_all_scalars_assign!( impl RemAssign for BigInt, rem_assign );
                forward_all_scalar_binop_to_val_val!( impl Rem<u32> for BigInt, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<u64> for BigInt, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<u128> for BigInt, rem );

                impl Rem<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: u32 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data % other )
                    }
                }
                impl RemAssign<u32> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: u32 ) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Rem<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        BigInt::from( self % other.data )
                    }
                }
                impl Rem<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: u64 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data % other )
                    }
                }
                impl RemAssign<u64> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: u64 ) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Rem<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        BigInt::from( self % other.data )
                    }
                }
                impl Rem<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: u128 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data % other )
                    }
                }
                impl RemAssign<u128> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: u128 ) {
                        self.data %= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Rem<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        BigInt::from( self % other.data )
                    }
                }
                forward_all_scalar_binop_to_val_val!( impl Rem<i32> for BigInt, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<i64> for BigInt, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<i128> for BigInt, rem );

                impl Rem<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: i32 ) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }
                impl RemAssign<i32> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: i32 ) {
                        *self %= other.unsigned_abs();
                    }
                }
                impl Rem<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u % other,
                            Negative( u ) => -( u % other ),
                        }
                    }
                }
                impl Rem<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: i64 ) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }
                impl RemAssign<i64> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: i64 ) {
                        *self %= other.unsigned_abs();
                    }
                }
                impl Rem<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u % other,
                            Negative( u ) => -( u % other ),
                        }
                    }
                }
                impl Rem<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: i128 ) -> BigInt {
                        self % other.unsigned_abs()
                    }
                }
                impl RemAssign<i128> for BigInt
                {
                    #[inline] fn rem_assign( &mut self, other: i128 ) {
                        *self %= other.unsigned_abs();
                    }
                }
                impl Rem<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline] fn rem( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u % other,
                            Negative( u ) => -( u % other ),
                        }
                    }
                }
                impl CheckedDiv for BigInt
                {
                    #[inline] fn checked_div( &self, v:&BigInt ) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.div( v ) )
                    }
                }
                impl CheckedEuclid for BigInt
                {
                    #[inline] fn checked_div_euclid( &self, v:&BigInt ) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.div_euclid( v ) )
                    }
                    #[inline] fn checked_rem_euclid( &self, v:&BigInt ) -> Option<BigInt> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.rem_euclid( v ) )
                    }
                    fn checked_div_rem_euclid( &self, v:&Self ) -> Option<( Self, Self )> { Some( self.div_rem_euclid( v ) ) }
                }
                impl Euclid for BigInt
                {
                    #[inline] fn div_euclid( &self, v:&BigInt ) -> BigInt {
                        let ( q, r ) = self.div_rem( v );
                        if r.is_negative() {
                            if v.is_positive() {
                                q - 1
                            } else {
                                q + 1
                            }
                        } else {
                            q
                        }
                    }
                    #[inline] fn rem_euclid( &self, v:&BigInt ) -> BigInt {
                        let r = self % v;
                        if r.is_negative() {
                            if v.is_positive() {
                                r + v
                            } else {
                                r - v
                            }
                        } else {
                            r
                        }
                    }
                    fn div_rem_euclid( &self, v:&Self ) -> ( Self, Self ) {
                        let ( q, r ) = self.div_rem( v );
                        if r.is_negative() {
                            if v.is_positive() {
                                ( q - 1, r + v )
                            } else {
                                ( q + 1, r - v )
                            }
                        } else {
                            ( q, r )
                        }
                    }
                }
            }
            
            pub mod multiplication
            {
                use ::
                {
                    iter::{ Product },
                    num::
                    {
                        big::{IsizePromotion, UsizePromotion},
                        traits::{CheckedMul, One, Zero},
                    },
                    ops::{ Mul, MulAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{Negative, Positive};
                use super::Sign::{self, Minus, NoSign, Plus};
                use super::{BigInt, UnsignedAbs};
                /*
                */
                impl Mul<Sign> for Sign {
                    type Output = Sign;

                    #[inline] fn mul( self, other: Sign ) -> Sign {
                        match ( self, other ) {
                            ( NoSign, _ ) | ( _, NoSign ) => NoSign,
                            ( Plus, Plus ) | ( Minus, Minus ) => Plus,
                            ( Plus, Minus ) | ( Minus, Plus ) => Minus,
                        }
                    }
                }
                macro_rules! impl_mul {
                    ( $( impl Mul<$Other:ty> for $Self:ty; )* ) => {$( 
                        impl Mul<$Other> for $Self {
                            type Output = BigInt;

                            #[inline]
                            fn mul( self, other: $Other ) -> BigInt {
                               
                                let BigInt { data: x, .. } = self;
                                let BigInt { data: y, .. } = other;
                                BigInt::from_biguint( self.sign * other.sign, x * y )
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigInt> for BigInt;
                    impl Mul<BigInt> for &BigInt;
                    impl Mul<&BigInt> for BigInt;
                    impl Mul<&BigInt> for &BigInt;
                }
                macro_rules! impl_mul_assign {
                    ( $( impl MulAssign<$Other:ty> for BigInt; )* ) => {$( 
                        impl MulAssign<$Other> for BigInt {
                            #[inline]
                            fn mul_assign( &mut self, other: $Other ) {
                               
                                let BigInt { data: y, .. } = other;
                                self.data *= y;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                } else {
                                    self.sign = self.sign * other.sign;
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigInt> for BigInt;
                    impl MulAssign<&BigInt> for BigInt;
                }
                promote_all_scalars!( impl Mul for BigInt, mul );
                promote_all_scalars_assign!( impl MulAssign for BigInt, mul_assign );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u32> for BigInt, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u64> for BigInt, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u128> for BigInt, mul );

                impl Mul<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: u32 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data * other )
                    }
                }
                impl MulAssign<u32> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: u32 ) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Mul<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: u64 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data * other )
                    }
                }
                impl MulAssign<u64> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: u64 ) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                impl Mul<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: u128 ) -> BigInt {
                        BigInt::from_biguint( self.sign, self.data * other )
                    }
                }
                impl MulAssign<u128> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: u128 ) {
                        self.data *= other;
                        if self.data.is_zero() {
                            self.sign = NoSign;
                        }
                    }
                }
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<i32> for BigInt, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<i64> for BigInt, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<i128> for BigInt, mul );

                impl Mul<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: i32 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self * u,
                            Negative( u ) => -self * u,
                        }
                    }
                }
                impl MulAssign<i32> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: i32 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self *= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }
                impl Mul<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: i64 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self * u,
                            Negative( u ) => -self * u,
                        }
                    }
                }
                impl MulAssign<i64> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: i64 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self *= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }
                impl Mul<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn mul( self, other: i128 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self * u,
                            Negative( u ) => -self * u,
                        }
                    }
                }
                impl MulAssign<i128> for BigInt
                {
                    #[inline] fn mul_assign( &mut self, other: i128 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self *= u,
                            Negative( u ) => {
                                self.sign = -self.sign;
                                self.data *= u;
                            }
                        }
                    }
                }
                impl CheckedMul for BigInt
                {
                    #[inline] fn checked_mul( &self, v:&BigInt ) -> Option<BigInt> { Some( self.mul( v ) ) }
                }
                impl_product_iter_type!( BigInt );

            }
            pub mod subtraction
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    num::{ traits::CheckedSub },
                    ops::{ Sub, SubAssign },
                    *,
                };
                use super::CheckedUnsignedAbs::{Negative, Positive};
                use super::Sign::{Minus, NoSign, Plus};
                use super::{BigInt, UnsignedAbs};
                /*
                */
                macro_rules! bigint_sub
                {
                    ( $a:expr, $a_owned:expr, $a_data:expr, $b:expr, $b_owned:expr, $b_data:expr ) => {
                        match ( $a.sign, $b.sign ) {
                            ( _, NoSign ) => $a_owned,
                            ( NoSign, _ ) => -$b_owned,
                           
                            ( Plus, Minus ) | ( Minus, Plus ) => BigInt::from_biguint( $a.sign, $a_data + $b_data ),
                           
                            ( Plus, Plus ) | ( Minus, Minus ) => match $a.data.cmp( &$b.data ) {
                                Less => BigInt::from_biguint( -$a.sign, $b_data - $a_data ),
                                Greater => BigInt::from_biguint( $a.sign, $a_data - $b_data ),
                                Equal => BigInt::ZERO,
                            },
                        }
                    };
                }
                impl Sub<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other:&BigInt ) -> BigInt {
                        bigint_sub!( 
                            self,
                            self.clone(),
                            &self.data,
                            other,
                            other.clone(),
                            &other.data
                        )
                    }
                }
                impl Sub<BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        bigint_sub!( self, self.clone(), &self.data, other, other, other.data )
                    }
                }
                impl Sub<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other:&BigInt ) -> BigInt {
                        bigint_sub!( self, self, self.data, other, other.clone(), &other.data )
                    }
                }
                impl Sub<BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        bigint_sub!( self, self, self.data, other, other, other.data )
                    }
                }
                impl SubAssign<&BigInt> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other:&BigInt ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n - other;
                    }
                }
                forward_val_assign!( impl SubAssign for BigInt, sub_assign );

                promote_all_scalars!( impl Sub for BigInt, sub );
                promote_all_scalars_assign!( impl SubAssign for BigInt, sub_assign );
                forward_all_scalar_binop_to_val_val!( impl Sub<u32> for BigInt, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<u64> for BigInt, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<u128> for BigInt, sub );

                impl Sub<u32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: u32 ) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from( other ),
                            Minus => -BigInt::from( self.data + other ),
                            Plus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from( self.data - other ),
                                Less => -BigInt::from( other - self.data ),
                            },
                        }
                    }
                }
                impl SubAssign<u32> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: u32 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n - other;
                    }
                }
                impl Sub<BigInt> for u32 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        -( other - self )
                    }
                }
                impl Sub<BigInt> for u64 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        -( other - self )
                    }
                }
                impl Sub<BigInt> for u128 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        -( other - self )
                    }
                }
                impl Sub<u64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: u64 ) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from( other ),
                            Minus => -BigInt::from( self.data + other ),
                            Plus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from( self.data - other ),
                                Less => -BigInt::from( other - self.data ),
                            },
                        }
                    }
                }
                impl SubAssign<u64> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: u64 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n - other;
                    }
                }
                impl Sub<u128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: u128 ) -> BigInt {
                        match self.sign {
                            NoSign => -BigInt::from( other ),
                            Minus => -BigInt::from( self.data + other ),
                            Plus => match self.data.cmp( &From::from( other ) ) {
                                Equal => Self::ZERO,
                                Greater => BigInt::from( self.data - other ),
                                Less => -BigInt::from( other - self.data ),
                            },
                        }
                    }
                }
                impl SubAssign<u128> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: u128 ) {
                        let n = mem::replace( self, Self::ZERO );
                        *self = n - other;
                    }
                }
                forward_all_scalar_binop_to_val_val!( impl Sub<i32> for BigInt, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<i64> for BigInt, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<i128> for BigInt, sub );

                impl Sub<i32> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: i32 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self - u,
                            Negative( u ) => self + u,
                        }
                    }
                }
                impl SubAssign<i32> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: i32 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self -= u,
                            Negative( u ) => *self += u,
                        }
                    }
                }
                impl Sub<BigInt> for i32 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u - other,
                            Negative( u ) => -other - u,
                        }
                    }
                }
                impl Sub<i64> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: i64 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self - u,
                            Negative( u ) => self + u,
                        }
                    }
                }
                impl SubAssign<i64> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: i64 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self -= u,
                            Negative( u ) => *self += u,
                        }
                    }
                }
                impl Sub<BigInt> for i64 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u - other,
                            Negative( u ) => -other - u,
                        }
                    }
                }
                impl Sub<i128> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: i128 ) -> BigInt {
                        match other.checked_uabs() {
                            Positive( u ) => self - u,
                            Negative( u ) => self + u,
                        }
                    }
                }
                impl SubAssign<i128> for BigInt
                {
                    #[inline] fn sub_assign( &mut self, other: i128 ) {
                        match other.checked_uabs() {
                            Positive( u ) => *self -= u,
                            Negative( u ) => *self += u,
                        }
                    }
                }
                impl Sub<BigInt> for i128 {
                    type Output = BigInt;

                    #[inline] fn sub( self, other: BigInt ) -> BigInt {
                        match self.checked_uabs() {
                            Positive( u ) => u - other,
                            Negative( u ) => -other - u,
                        }
                    }
                }
                impl CheckedSub for BigInt
                {
                    #[inline] fn checked_sub( &self, v:&BigInt ) -> Option<BigInt> { Some( self.sub( v ) ) }
                }
            }
            pub mod bits
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    num::
                    {
                        big::
                        {
                            uint::{ IntDigits },
                            digit::{ BigDigit, DoubleBigDigit },
                        },
                        traits::{ToPrimitive, Zero},
                    },
                    ops::{ BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign },
                    vec::{ Vec },
                    *,
                };
                use super::BigInt;
                use super::Sign::{Minus, NoSign, Plus};
                /*
                */
                #[inline] fn negate_carry( a: BigDigit, acc:&mut DoubleBigDigit ) -> BigDigit
                {
                    *acc += DoubleBigDigit::from( !a );
                    let lo = *acc as BigDigit;
                    *acc >>= ::num::big::digit::BITS;
                    lo
                }
                
                fn bitand_pos_neg( a:&mut [BigDigit], b:&[BigDigit] ) 
                {
                    let mut carry_b = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai &= twos_b;
                    }
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                }
                fn bitand_neg_pos( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        *ai = twos_a & bi;
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => a.truncate( b.len() ),
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().cloned() );
                        }
                    }
                }
                fn bitand_neg_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_and = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = negate_carry( twos_a & twos_b, &mut carry_and );
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry( *ai, &mut carry_a );
                                *ai = negate_carry( twos_a, &mut carry_and );
                            }
                            debug_assert!( carry_a == 0 );
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_b = negate_carry( bi, &mut carry_b );
                                negate_carry( twos_b, &mut carry_and )
                            } ) );
                            debug_assert!( carry_b == 0 );
                        }
                    }
                    if carry_and != 0 {
                        a.push( 1 );
                    }
                }
                forward_val_val_binop!( impl BitAnd for BigInt, bitand );
                forward_ref_val_binop_big!( impl BitAnd for BigInt, bitand );
                
                impl BitAnd<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitand( self, other:&BigInt ) -> BigInt {
                        match ( self.sign, other.sign ) {
                            ( NoSign, _ ) | ( _, NoSign ) => BigInt::ZERO,
                            ( Plus, Plus ) => BigInt::from( &self.data & &other.data ),
                            ( Plus, Minus ) => self.clone() & other,
                            ( Minus, Plus ) => other.clone() & self,
                            ( Minus, Minus ) => {
                               
                                if self.len() >= other.len() {
                                    self.clone() & other
                                } else {
                                    other.clone() & self
                                }
                            }
                        }
                    }
                }
                impl BitAnd<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitand( mut self, other:&BigInt ) -> BigInt {
                        self &= other;
                        self
                    }
                }
                forward_val_assign!( impl BitAndAssign for BigInt, bitand_assign );

                impl BitAndAssign<&BigInt> for BigInt
                {
                    fn bitand_assign( &mut self, other:&BigInt ) {
                        match ( self.sign, other.sign ) {
                            ( NoSign, _ ) => {}
                            ( _, NoSign ) => self.set_zero(),
                            ( Plus, Plus ) => {
                                self.data &= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            ( Plus, Minus ) => {
                                bitand_pos_neg( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                            ( Minus, Plus ) => {
                                bitand_neg_pos( self.digits_mut(), other.digits() );
                                self.sign = Plus;
                                self.normalize();
                            }
                            ( Minus, Minus ) => {
                                bitand_neg_neg( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                        }
                    }
                }
                fn bitor_pos_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = negate_carry( *ai | twos_b, &mut carry_or );
                    }
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => { a.truncate( b.len() ); }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_b = negate_carry( bi, &mut carry_b );
                                negate_carry( twos_b, &mut carry_or )
                            } ) );
                            debug_assert!( carry_b == 0 );
                        }
                    }
                   
                    debug_assert!( carry_or == 0 );
                }
                fn bitor_neg_pos( a:&mut [BigDigit], b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_or = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        *ai = negate_carry( twos_a | bi, &mut carry_or );
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    if a.len() > b.len() {
                        for ai in a[b.len()..].iter_mut() {
                            let twos_a = negate_carry( *ai, &mut carry_a );
                            *ai = negate_carry( twos_a, &mut carry_or );
                        }
                        debug_assert!( carry_a == 0 );
                    }
                   
                    debug_assert!( carry_or == 0 );
                }
                fn bitor_neg_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    let mut carry_or = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = negate_carry( twos_a | twos_b, &mut carry_or );
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    if a.len() > b.len() {
                        a.truncate( b.len() );
                    }
                   
                    debug_assert!( carry_or == 0 );
                }
                forward_val_val_binop!( impl BitOr for BigInt, bitor );
                forward_ref_val_binop_big!( impl BitOr for BigInt, bitor );               
               
                impl BitOr<&BigInt> for &BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitor( self, other:&BigInt ) -> BigInt {
                        match ( self.sign, other.sign ) {
                            ( NoSign, _ ) => other.clone(),
                            ( _, NoSign ) => self.clone(),
                            ( Plus, Plus ) => BigInt::from( &self.data | &other.data ),
                            ( Plus, Minus ) => other.clone() | self,
                            ( Minus, Plus ) => self.clone() | other,
                            ( Minus, Minus ) => {
                               
                                if self.len() <= other.len() {
                                    self.clone() | other
                                } else {
                                    other.clone() | self
                                }
                            }
                        }
                    }
                }
                impl BitOr<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitor( mut self, other:&BigInt ) -> BigInt {
                        self |= other;
                        self
                    }
                }
                forward_val_assign!( impl BitOrAssign for BigInt, bitor_assign );

                impl BitOrAssign<&BigInt> for BigInt
                {
                    fn bitor_assign( &mut self, other:&BigInt ) {
                        match ( self.sign, other.sign ) {
                            ( _, NoSign ) => {}
                            ( NoSign, _ ) => self.clone_from( other ),
                            ( Plus, Plus ) => self.data |= &other.data,
                            ( Plus, Minus ) => {
                                bitor_pos_neg( self.digits_mut(), other.digits() );
                                self.sign = Minus;
                                self.normalize();
                            }
                            ( Minus, Plus ) => {
                                bitor_neg_pos( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                            ( Minus, Minus ) => {
                                bitor_neg_neg( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                        }
                    }
                }
                fn bitxor_pos_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_b = 1;
                    let mut carry_xor = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = negate_carry( *ai ^ twos_b, &mut carry_xor );
                    }
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_b = !0;
                                *ai = negate_carry( *ai ^ twos_b, &mut carry_xor );
                            }
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_b = negate_carry( bi, &mut carry_b );
                                negate_carry( twos_b, &mut carry_xor )
                            } ) );
                            debug_assert!( carry_b == 0 );
                        }
                    }
                    if carry_xor != 0 {
                        a.push( 1 );
                    }
                }
                fn bitxor_neg_pos( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_xor = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        *ai = negate_carry( twos_a ^ bi, &mut carry_xor );
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry( *ai, &mut carry_a );
                                *ai = negate_carry( twos_a, &mut carry_xor );
                            }
                            debug_assert!( carry_a == 0 );
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_a = !0;
                                negate_carry( twos_a ^ bi, &mut carry_xor )
                            } ) );
                        }
                    }
                    if carry_xor != 0 {
                        a.push( 1 );
                    }
                }
                fn bitxor_neg_neg( a:&mut Vec<BigDigit>, b:&[BigDigit] ) 
                {
                    let mut carry_a = 1;
                    let mut carry_b = 1;
                    for ( ai, &bi ) in a.iter_mut().zip( b.iter() ) {
                        let twos_a = negate_carry( *ai, &mut carry_a );
                        let twos_b = negate_carry( bi, &mut carry_b );
                        *ai = twos_a ^ twos_b;
                    }
                    debug_assert!( a.len() > b.len() || carry_a == 0 );
                    debug_assert!( b.len() > a.len() || carry_b == 0 );
                    match Ord::cmp( &a.len(), &b.len() ) {
                        Greater => {
                            for ai in a[b.len()..].iter_mut() {
                                let twos_a = negate_carry( *ai, &mut carry_a );
                                let twos_b = !0;
                                *ai = twos_a ^ twos_b;
                            }
                            debug_assert!( carry_a == 0 );
                        }
                        Equal => {}
                        Less => {
                            let extra = &b[a.len()..];
                            a.extend( extra.iter().map( |&bi| {
                                let twos_a = !0;
                                let twos_b = negate_carry( bi, &mut carry_b );
                                twos_a ^ twos_b
                            } ) );
                            debug_assert!( carry_b == 0 );
                        }
                    }
                }
                forward_all_binop_to_val_ref_commutative!( impl BitXor for BigInt, bitxor );

                impl BitXor<&BigInt> for BigInt
                {
                    type Output = BigInt;

                    #[inline] fn bitxor( mut self, other:&BigInt ) -> BigInt {
                        self ^= other;
                        self
                    }
                }
                forward_val_assign!( impl BitXorAssign for BigInt, bitxor_assign );

                impl BitXorAssign<&BigInt> for BigInt
                {
                    fn bitxor_assign( &mut self, other:&BigInt ) {
                        match ( self.sign, other.sign ) {
                            ( _, NoSign ) => {}
                            ( NoSign, _ ) => self.clone_from( other ),
                            ( Plus, Plus ) => {
                                self.data ^= &other.data;
                                if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                            ( Plus, Minus ) => {
                                bitxor_pos_neg( self.digits_mut(), other.digits() );
                                self.sign = Minus;
                                self.normalize();
                            }
                            ( Minus, Plus ) => {
                                bitxor_neg_pos( self.digits_mut(), other.digits() );
                                self.normalize();
                            }
                            ( Minus, Minus ) => {
                                bitxor_neg_neg( self.digits_mut(), other.digits() );
                                self.sign = Plus;
                                self.normalize();
                            }
                        }
                    }
                }

                pub fn set_negative_bit( x:&mut BigInt, bit: u64, value: bool )
                {
                    debug_assert_eq!( x.sign, Minus );
                    let data = &mut x.data;

                    let bits_per_digit = u64::from( ::num::big::digit::BITS );
                    if bit >= bits_per_digit * data.len() as u64 {
                        if !value {
                            data.set_bit( bit, true );
                        }
                    } else {
                       
                       
                       
                       
                       
                       
                        let trailing_zeros = data.trailing_zeros().unwrap();
                        if bit > trailing_zeros {
                            data.set_bit( bit, !value );
                        } else if bit == trailing_zeros && !value {
                           
                           
                           
                           
                           
                            let bit_index = ( bit / bits_per_digit ).to_usize().unwrap();
                            let bit_mask = ( 1 as BigDigit ) << ( bit % bits_per_digit );
                            let mut digit_iter = data.digits_mut().iter_mut().skip( bit_index );
                            let mut carry_in = 1;
                            let mut carry_out = 1;

                            let digit = digit_iter.next().unwrap();
                            let twos_in = negate_carry( *digit, &mut carry_in );
                            let twos_out = twos_in & !bit_mask;
                            *digit = negate_carry( twos_out, &mut carry_out );

                            for digit in digit_iter {
                                if carry_in == 0 && carry_out == 0 {
                                   
                                    break;
                                }
                                let twos = negate_carry( *digit, &mut carry_in );
                                *digit = negate_carry( twos, &mut carry_out );
                            }
                            if carry_out != 0 {
                               
                                debug_assert_eq!( carry_in, 0 );
                                data.digits_mut().push( 1 );
                            }
                        } else if bit < trailing_zeros && value {
                           
                           
                           
                           
                           
                           
                            let index_lo = ( bit / bits_per_digit ).to_usize().unwrap();
                            let index_hi = ( trailing_zeros / bits_per_digit ).to_usize().unwrap();
                            let bit_mask_lo = ::num::big::digit::MAX << ( bit % bits_per_digit );
                            let bit_mask_hi =
                                ::num::big::digit::MAX >> ( bits_per_digit - 1 - ( trailing_zeros % bits_per_digit ) );
                            let digits = data.digits_mut();

                            if index_lo == index_hi {
                                digits[index_lo] ^= bit_mask_lo & bit_mask_hi;
                            } else {
                                digits[index_lo] = bit_mask_lo;
                                for digit in &mut digits[index_lo + 1..index_hi] {
                                    *digit = ::num::big::digit::MAX;
                                }
                                digits[index_hi] ^= bit_mask_hi;
                            }
                        } else {
                           
                           
                           
                        }
                    }
                }
            }
            pub mod convert
            {
                use ::
                {
                    cmp::{ Ordering::{ Equal, Greater, Less } },
                    convert::{ TryFrom },
                    num::
                    {
                        big::{ BigUint, ParseBigIntError, ToBigUint, TryFromBigIntError },
                        traits::{ FromPrimitive, Num, One, ToPrimitive, Zero },
                    },
                    str::{ self, FromStr },
                    vec::{ Vec },
                    *,
                };
                use super::Sign::{self, Minus, NoSign, Plus};
                use super::{BigInt, ToBigInt};
                /*
                */
                impl FromStr for BigInt
                {
                    type Err = ParseBigIntError;

                    #[inline] fn from_str( s:&str ) -> Result<BigInt, ParseBigIntError> { BigInt::from_str_radix( s, 10 ) }
                }
                impl Num for BigInt
                {
                    type FromStrRadixErr = ParseBigIntError;

                    #[inline] fn from_str_radix( mut s:&str, radix: u32 ) -> Result<BigInt, ParseBigIntError>
                    {
                        let sign = if let Some( tail ) = s.strip_prefix( '-' ) {
                            if !tail.starts_with( '+' ) {
                                s = tail
                            }
                            Minus
                        } else {
                            Plus
                        };
                        let bu = BigUint::from_str_radix( s, radix )?;
                        Ok( BigInt::from_biguint( sign, bu ) )
                    }
                }
                impl ToPrimitive for BigInt
                {
                    #[inline] fn to_i64( &self ) -> Option<i64> {
                        match self.sign {
                            Plus => self.data.to_i64(),
                            NoSign => Some( 0 ),
                            Minus => {
                                let n = self.data.to_u64()?;
                                let m: u64 = 1 << 63;
                                match n.cmp( &m ) {
                                    Less => Some( -( n as i64 ) ),
                                    Equal => Some( i64::MIN ),
                                    Greater => None,
                                }
                            }
                        }
                    }
                    #[inline] fn to_i128( &self ) -> Option<i128> {
                        match self.sign {
                            Plus => self.data.to_i128(),
                            NoSign => Some( 0 ),
                            Minus => {
                                let n = self.data.to_u128()?;
                                let m: u128 = 1 << 127;
                                match n.cmp( &m ) {
                                    Less => Some( -( n as i128 ) ),
                                    Equal => Some( i128::MIN ),
                                    Greater => None,
                                }
                            }
                        }
                    }
                    #[inline] fn to_u64( &self ) -> Option<u64> {
                        match self.sign {
                            Plus => self.data.to_u64(),
                            NoSign => Some( 0 ),
                            Minus => None,
                        }
                    }
                    #[inline] fn to_u128( &self ) -> Option<u128> {
                        match self.sign {
                            Plus => self.data.to_u128(),
                            NoSign => Some( 0 ),
                            Minus => None,
                        }
                    }
                    #[inline] fn to_f32( &self ) -> Option<f32>
                    {
                        let n = self.data.to_f32()?;
                        Some( if self.sign == Minus { -n } else { n } )
                    }
                    #[inline] fn to_f64( &self ) -> Option<f64>
                    {
                        let n = self.data.to_f64()?;
                        Some( if self.sign == Minus { -n } else { n } )
                    }
                }
                macro_rules! impl_try_from_bigint 
                {
                    ( $T:ty, $to_ty:path ) => {
                        impl TryFrom<&BigInt> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from( value:&BigInt ) -> Result<$T, TryFromBigIntError<()>> { $to_ty( value ).ok_or( TryFromBigIntError::new( () ) ) }
                        }
                        impl TryFrom<BigInt> for $T {
                            type Error = TryFromBigIntError<BigInt>;

                            #[inline]
                            fn try_from( value: BigInt ) -> Result<$T, TryFromBigIntError<BigInt>> { <$T>::try_from( &value ).map_err( |_| TryFromBigIntError::new( value ) ) }
                        }
                    };
                }
                impl_try_from_bigint!( u8, ToPrimitive::to_u8 );
                impl_try_from_bigint!( u16, ToPrimitive::to_u16 );
                impl_try_from_bigint!( u32, ToPrimitive::to_u32 );
                impl_try_from_bigint!( u64, ToPrimitive::to_u64 );
                impl_try_from_bigint!( usize, ToPrimitive::to_usize );
                impl_try_from_bigint!( u128, ToPrimitive::to_u128 );

                impl_try_from_bigint!( i8, ToPrimitive::to_i8 );
                impl_try_from_bigint!( i16, ToPrimitive::to_i16 );
                impl_try_from_bigint!( i32, ToPrimitive::to_i32 );
                impl_try_from_bigint!( i64, ToPrimitive::to_i64 );
                impl_try_from_bigint!( isize, ToPrimitive::to_isize );
                impl_try_from_bigint!( i128, ToPrimitive::to_i128 );

                impl FromPrimitive for BigInt
                {
                    #[inline] fn from_i64( n: i64 ) -> Option<BigInt> { Some( BigInt::from( n ) ) }
                    #[inline] fn from_i128( n: i128 ) -> Option<BigInt> { Some( BigInt::from( n ) ) }
                    #[inline] fn from_u64( n: u64 ) -> Option<BigInt> { Some( BigInt::from( n ) ) }
                    #[inline] fn from_u128( n: u128 ) -> Option<BigInt> { Some( BigInt::from( n ) ) }
                    #[inline] fn from_f64( n: f64 ) -> Option<BigInt> {
                        if n >= 0.0 {
                            BigUint::from_f64( n ).map( BigInt::from )
                        } else {
                            let x = BigUint::from_f64( -n )?;
                            Some( -BigInt::from( x ) )
                        }
                    }
                }
                impl From<i64> for BigInt
                {
                    #[inline] fn from( n: i64 ) -> Self {
                        if n >= 0 {
                            BigInt::from( n as u64 )
                        } else {
                            let u = u64::MAX - ( n as u64 ) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from( u ),
                            }
                        }
                    }
                }
                impl From<i128> for BigInt
                {
                    #[inline] fn from( n: i128 ) -> Self {
                        if n >= 0 {
                            BigInt::from( n as u128 )
                        } else {
                            let u = u128::MAX - ( n as u128 ) + 1;
                            BigInt {
                                sign: Minus,
                                data: BigUint::from( u ),
                            }
                        }
                    }
                }
                macro_rules! impl_bigint_from_int 
                {
                    ( $T:ty ) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from( n: $T ) -> Self {
                                BigInt::from( n as i64 )
                            }
                        }
                    };
                }
                impl_bigint_from_int!( i8 );
                impl_bigint_from_int!( i16 );
                impl_bigint_from_int!( i32 );
                impl_bigint_from_int!( isize );

                impl From<u64> for BigInt
                {
                    #[inline] fn from( n: u64 ) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from( n ),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }
                impl From<u128> for BigInt
                {
                    #[inline] fn from( n: u128 ) -> Self {
                        if n > 0 {
                            BigInt {
                                sign: Plus,
                                data: BigUint::from( n ),
                            }
                        } else {
                            Self::ZERO
                        }
                    }
                }
                macro_rules! impl_bigint_from_uint 
                {
                    ( $T:ty ) => {
                        impl From<$T> for BigInt {
                            #[inline]
                            fn from( n: $T ) -> Self {
                                BigInt::from( n as u64 )
                            }
                        }
                    };
                }
                impl_bigint_from_uint!( u8 );
                impl_bigint_from_uint!( u16 );
                impl_bigint_from_uint!( u32 );
                impl_bigint_from_uint!( usize );

                impl From<BigUint> for BigInt
                {
                    #[inline] fn from( n: BigUint ) -> Self {
                        if n.is_zero() {
                            Self::ZERO
                        } else {
                            BigInt {
                                sign: Plus,
                                data: n,
                            }
                        }
                    }
                }
                impl ToBigInt for BigInt
                {
                    #[inline] fn to_bigint( &self ) -> Option<BigInt> { Some( self.clone() ) }
                }
                impl ToBigInt for BigUint
                {
                    #[inline] fn to_bigint( &self ) -> Option<BigInt> {
                        if self.is_zero() {
                            Some( BigInt::ZERO )
                        } else {
                            Some( BigInt {
                                sign: Plus,
                                data: self.clone(),
                            } )
                        }
                    }
                }
                impl ToBigUint for BigInt
                {
                    #[inline] fn to_biguint( &self ) -> Option<BigUint> {
                        match self.sign() {
                            Plus => Some( self.data.clone() ),
                            NoSign => Some( BigUint::ZERO ),
                            Minus => None,
                        }
                    }
                }
                impl TryFrom<&BigInt> for BigUint
                {
                    type Error = TryFromBigIntError<()>;

                    #[inline] fn try_from( value:&BigInt ) -> Result<BigUint, TryFromBigIntError<()>> {
                        value
                            .to_biguint()
                            .ok_or_else( || TryFromBigIntError::new( () ) )
                    }
                }
                impl TryFrom<BigInt> for BigUint
                {
                    type Error = TryFromBigIntError<BigInt>;

                    #[inline] fn try_from( value: BigInt ) -> Result<BigUint, TryFromBigIntError<BigInt>> {
                        if value.sign() == Sign::Minus {
                            Err( TryFromBigIntError::new( value ) )
                        } else {
                            Ok( value.data )
                        }
                    }
                }
                macro_rules! impl_to_bigint
                {
                    ( $T:ty, $from_ty:path ) => {
                        impl ToBigInt for $T {
                            #[inline]
                            fn to_bigint( &self ) -> Option<BigInt> { $from_ty( *self ) }
                        }
                    };
                }
                impl_to_bigint!( isize, FromPrimitive::from_isize );
                impl_to_bigint!( i8, FromPrimitive::from_i8 );
                impl_to_bigint!( i16, FromPrimitive::from_i16 );
                impl_to_bigint!( i32, FromPrimitive::from_i32 );
                impl_to_bigint!( i64, FromPrimitive::from_i64 );
                impl_to_bigint!( i128, FromPrimitive::from_i128 );

                impl_to_bigint!( usize, FromPrimitive::from_usize );
                impl_to_bigint!( u8, FromPrimitive::from_u8 );
                impl_to_bigint!( u16, FromPrimitive::from_u16 );
                impl_to_bigint!( u32, FromPrimitive::from_u32 );
                impl_to_bigint!( u64, FromPrimitive::from_u64 );
                impl_to_bigint!( u128, FromPrimitive::from_u128 );

                impl_to_bigint!( f32, FromPrimitive::from_f32 );
                impl_to_bigint!( f64, FromPrimitive::from_f64 );

                impl From<bool> for BigInt 
                {
                    fn from( x: bool ) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
               }
                
                #[inline] pub fn from_signed_bytes_be( digits:&[u8] ) -> BigInt 
                {
                    let sign = match digits.first() {
                        Some( v ) if *v > 0x7f => Sign::Minus,
                        Some( _ ) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                       
                        let mut digits = Vec::from( digits );
                        twos_complement_be( &mut digits );
                        BigInt::from_biguint( sign, BigUint::from_bytes_be( &digits ) )
                    } else {
                        BigInt::from_biguint( sign, BigUint::from_bytes_be( digits ) )
                    }
               }
                
                #[inline] pub fn from_signed_bytes_le( digits:&[u8] ) -> BigInt 
                {
                    let sign = match digits.last() {
                        Some( v ) if *v > 0x7f => Sign::Minus,
                        Some( _ ) => Sign::Plus,
                        None => return BigInt::ZERO,
                    };

                    if sign == Sign::Minus {
                       
                        let mut digits = Vec::from( digits );
                        twos_complement_le( &mut digits );
                        BigInt::from_biguint( sign, BigUint::from_bytes_le( &digits ) )
                    } else {
                        BigInt::from_biguint( sign, BigUint::from_bytes_le( digits ) )
                    }
               }
                
                #[inline] pub fn to_signed_bytes_be( x:&BigInt ) -> Vec<u8> 
                {
                    let mut bytes = x.data.to_bytes_be();
                    let first_byte = bytes.first().cloned().unwrap_or( 0 );
                    if first_byte > 0x7f
                        && !( first_byte == 0x80 && bytes.iter().skip( 1 ).all( Zero::is_zero ) && x.sign == Sign::Minus )
                    {
                       
                        bytes.insert( 0, 0 );
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_be( &mut bytes );
                    }
                    bytes
               }
                
                #[inline] pub fn to_signed_bytes_le( x:&BigInt ) -> Vec<u8> 
                {
                    let mut bytes = x.data.to_bytes_le();
                    let last_byte = bytes.last().cloned().unwrap_or( 0 );
                    if last_byte > 0x7f
                        && !( last_byte == 0x80
                            && bytes.iter().rev().skip( 1 ).all( Zero::is_zero )
                            && x.sign == Sign::Minus )
                    {
                       
                        bytes.push( 0 );
                    }
                    if x.sign == Sign::Minus {
                        twos_complement_le( &mut bytes );
                    }
                    bytes
                }

                #[inline] fn twos_complement_le( digits:&mut [u8] )
                {
                    twos_complement( digits )
                }

                #[inline] fn twos_complement_be( digits:&mut [u8] )
                {
                    twos_complement( digits.iter_mut().rev() )
                }

                #[inline] fn twos_complement<'a, I>( digits: I ) where
                I: IntoIterator<Item = &'a mut u8>
                {
                    let mut carry = true;
                    for d in digits {
                        *d = !*d;
                        if carry {
                            *d = d.wrapping_add( 1 );
                            carry = d.is_zero();
                        }
                    }
                }
            }
            pub mod power
            {
                use ::
                {
                    num::
                    {
                        big::{ BigUint }, 
                        integers::Integer,
                        traits::{Pow, Signed, Zero},
                    },
                    *,
                };
                use super::BigInt;
                use super::Sign::{self, Minus, Plus};
                /*
                */

                ///

                #[inline] fn powsign<T: Integer>( sign: Sign, other:&T ) -> Sign {
                    if other.is_zero() {
                        Plus
                    } else if sign != Minus || other.is_odd() {
                        sign
                    } else {
                        -sign
                    }
                }
                macro_rules! pow_impl {
                    ( $T:ty ) => {
                        impl Pow<$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow( self, rhs: $T ) -> BigInt {
                                BigInt::from_biguint( powsign( self.sign, &rhs ), self.data.pow( rhs ) )
                            }
                        }
                        impl Pow<&$T> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow( self, rhs:&$T ) -> BigInt {
                                BigInt::from_biguint( powsign( self.sign, rhs ), self.data.pow( rhs ) )
                            }
                        }
                        impl Pow<$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow( self, rhs: $T ) -> BigInt {
                                BigInt::from_biguint( powsign( self.sign, &rhs ), Pow::pow( &self.data, rhs ) )
                            }
                        }
                        impl Pow<&$T> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn pow( self, rhs:&$T ) -> BigInt {
                                BigInt::from_biguint( powsign( self.sign, rhs ), Pow::pow( &self.data, rhs ) )
                            }
                        }
                    };
                }
                pow_impl!( u8 );
                pow_impl!( u16 );
                pow_impl!( u32 );
                pow_impl!( u64 );
                pow_impl!( usize );
                pow_impl!( u128 );
                pow_impl!( BigUint );

                pub( super ) fn modpow( x:&BigInt, exponent:&BigInt, modulus:&BigInt ) -> BigInt {
                    assert!( 
                        !exponent.is_negative(),
                        "negative exponentiation is not supported!"
                     );
                    assert!( 
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                     );

                    let result = x.data.modpow( &exponent.data, &modulus.data );
                    if result.is_zero() {
                        return BigInt::ZERO;
                    }
                   
                    let ( sign, mag ) = match ( x.is_negative() && exponent.is_odd(), modulus.is_negative() ) {
                        ( false, false ) => ( Plus, result ),
                        ( true, false ) => ( Plus, &modulus.data - result ),
                        ( false, true ) => ( Minus, &modulus.data - result ),
                        ( true, true ) => ( Minus, result ),
                    };
                    BigInt::from_biguint( sign, mag )
                }
            }
            pub mod shift
            {
                use ::
                {
                    num::traits::{ PrimInt, Signed, Zero },
                    ops::{ Shl, ShlAssign, Shr, ShrAssign },
                    *,
                };
                use super::BigInt;
                use super::Sign::NoSign;
                /*
                */
                macro_rules! impl_shift
                {
                    ( @ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty ) => {
                        impl $Shx<&$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx( self, rhs:&$rhs ) -> BigInt {
                                $Shx::$shx( self, *rhs )
                            }
                        }
                        impl $Shx<&$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn $shx( self, rhs:&$rhs ) -> BigInt {
                                $Shx::$shx( self, *rhs )
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigInt {
                            #[inline]
                            fn $shx_assign( &mut self, rhs:&$rhs ) {
                                $ShxAssign::$shx_assign( self, *rhs );
                            }
                        }
                    };
                    ( $( $rhs:ty ),+ ) => {$( 
                        impl Shl<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl( self, rhs: $rhs ) -> BigInt {
                                BigInt::from_biguint( self.sign, self.data << rhs )
                            }
                        }
                        impl Shl<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shl( self, rhs: $rhs ) -> BigInt {
                                BigInt::from_biguint( self.sign, &self.data << rhs )
                            }
                        }
                        impl ShlAssign<$rhs> for BigInt {
                            #[inline]
                            fn shl_assign( &mut self, rhs: $rhs ) {
                                self.data <<= rhs
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }
                        impl Shr<$rhs> for BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr( self, rhs: $rhs ) -> BigInt {
                                let round_down = shr_round_down( &self, rhs );
                                let data = self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint( self.sign, data )
                            }
                        }
                        impl Shr<$rhs> for &BigInt {
                            type Output = BigInt;

                            #[inline]
                            fn shr( self, rhs: $rhs ) -> BigInt {
                                let round_down = shr_round_down( self, rhs );
                                let data = &self.data >> rhs;
                                let data = if round_down { data + 1u8 } else { data };
                                BigInt::from_biguint( self.sign, data )
                            }
                        }
                        impl ShrAssign<$rhs> for BigInt {
                            #[inline]
                            fn shr_assign( &mut self, rhs: $rhs ) {
                                let round_down = shr_round_down( self, rhs );
                                self.data >>= rhs;
                                if round_down {
                                    self.data += 1u8;
                                } else if self.data.is_zero() {
                                    self.sign = NoSign;
                                }
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }
                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }
                
                fn shr_round_down<T: PrimInt>( i:&BigInt, shift: T ) -> bool
                {
                    if i.is_negative() {
                        let zeros = i.trailing_zeros().expect( "negative values are non-zero" );
                        shift > T::zero() && shift.to_u64().map( |shift| zeros < shift ).unwrap_or( true )
                    } else {
                        false
                    }
                }
            }

            #[derive( PartialEq, PartialOrd, Eq, Ord, Copy, Clone, Debug, Hash )]
            pub enum Sign 
            {
                Minus,
                NoSign,
                Plus,
            }
            
            impl Neg for Sign 
            {
                type Output = Sign;

                #[inline] fn neg( self ) -> Sign {
                    match self {
                        Minus => Plus,
                        NoSign => NoSign,
                        Plus => Minus,
                    }
                }
            }

            pub struct BigInt 
            {
                sign: Sign,
                data: BigUint,
            }
                       
            impl Clone for BigInt
            {
                #[inline] fn clone( &self ) -> Self {
                    BigInt {
                        sign: self.sign,
                        data: self.data.clone(),
                    }
               }
                
                #[inline] fn clone_from( &mut self, other:&Self ) {
                    self.sign = other.sign;
                    self.data.clone_from( &other.data );
                }
            }
            
            impl hash::Hash for BigInt
            {
                #[inline] fn hash<H: hash::Hasher>( &self, state:&mut H ) {
                    debug_assert!( ( self.sign != NoSign ) ^ self.data.is_zero() );
                    self.sign.hash( state  );
                    if self.sign != NoSign {
                        self.data.hash( state  );
                    }
                }
            }
            
            impl PartialEq for BigInt
            {
                #[inline] fn eq( &self, other:&BigInt ) -> bool {
                    debug_assert!( ( self.sign != NoSign ) ^ self.data.is_zero() );
                    debug_assert!( ( other.sign != NoSign ) ^ other.data.is_zero() );
                    self.sign == other.sign && ( self.sign == NoSign || self.data == other.data )
                }
            }
            
            impl Eq for BigInt {}
            
            impl PartialOrd for BigInt
            {
                #[inline] fn partial_cmp( &self, other:&BigInt ) -> Option<Ordering> { Some( self.cmp( other ) ) }
            }
            
            impl Ord for BigInt
            {
                #[inline] fn cmp( &self, other:&BigInt ) -> Ordering {
                    debug_assert!( ( self.sign != NoSign ) ^ self.data.is_zero() );
                    debug_assert!( ( other.sign != NoSign ) ^ other.data.is_zero() );
                    let scmp = self.sign.cmp( &other.sign );
                    if scmp != Equal {
                        return scmp;
                    }
                    match self.sign {
                        NoSign => Equal,
                        Plus => self.data.cmp( &other.data ),
                        Minus => other.data.cmp( &self.data ),
                    }
                }
            }
            
            impl Default for BigInt
            {
                #[inline] fn default() -> BigInt {
                    Self::ZERO
                }
            }
            
            impl fmt::Debug for BigInt
           
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    fmt::Display::fmt( self, f )
                }
            }
            
            impl fmt::Display for BigInt
           
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    f.pad_integral( !self.is_negative(), "", &self.data.to_str_radix( 10 ) )
                }
            }
            
            impl fmt::Binary for BigInt
           
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    f.pad_integral( !self.is_negative(), "0b", &self.data.to_str_radix( 2 ) )
                }
            }
            
            impl fmt::Octal for BigInt
           
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    f.pad_integral( !self.is_negative(), "0o", &self.data.to_str_radix( 8 ) )
                }
            }
            
            impl fmt::LowerHex for BigInt
           
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    f.pad_integral( !self.is_negative(), "0x", &self.data.to_str_radix( 16 ) )
                }
            }
            
            impl fmt::UpperHex for BigInt
           
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {    let mut s = self.data.to_str_radix( 16 );
                    s.make_ascii_uppercase();
                    f.pad_integral( !self.is_negative(), "0x", &s )
                }
            }
            
            impl Not for BigInt
            {
                type  Output = BigInt;
                fn not( mut self ) -> BigInt {
                    match self.sign {
                        NoSign | Plus => {
                            self.data += 1u32;
                            self.sign = Minus;
                        }
                        Minus => {
                            self.data -= 1u32;
                            self.sign = if self.data.is_zero() { NoSign } else { Plus };
                        }
                    }
                    self
                }
            }
            
            impl Not for &BigInt
            {
                type  Output = BigInt;
                fn not( self ) -> BigInt {
                    match self.sign {
                        NoSign => -BigInt::one(),
                        Plus => -BigInt::from( &self.data + 1u32 ),
                        Minus => BigInt::from( &self.data - 1u32 ),
                    }
                }
            }
            
            impl Zero for BigInt
            {
                #[inline] fn zero() -> BigInt {
                    Self::ZERO
               }
                
                #[inline] fn set_zero( &mut self ) {
                    self.data.set_zero();
                    self.sign = NoSign;
               }
                
                #[inline] fn is_zero( &self ) -> bool { self.sign == NoSign }
            }
            
            impl ConstZero for BigInt 
            {
               
                const ZERO: Self = Self::ZERO;
            }
            
            impl One for BigInt
            {
                #[inline] fn one() -> BigInt {
                    BigInt {
                        sign: Plus,
                        data: BigUint::one(),
                    }
               }
                
                #[inline] fn set_one( &mut self ) {
                    self.data.set_one();
                    self.sign = Plus;
               }
                
                #[inline] fn is_one( &self ) -> bool { self.sign == Plus && self.data.is_one() }
            }
            
            impl Signed for BigInt
            {
                #[inline] fn abs( &self ) -> BigInt {
                    match self.sign {
                        Plus | NoSign => self.clone(),
                        Minus => BigInt::from( self.data.clone() ),
                    }
               }
                
                #[inline] fn abs_sub( &self, other:&BigInt ) -> BigInt {
                    if *self <= *other {
                        Self::ZERO
                    } else {
                        self - other
                    }
               }
                
                #[inline] fn signum( &self ) -> BigInt {
                    match self.sign {
                        Plus => BigInt::one(),
                        Minus => -BigInt::one(),
                        NoSign => Self::ZERO,
                    }
               }
                
                #[inline] fn is_positive( &self ) -> bool { self.sign == Plus }
                
                #[inline] fn is_negative( &self ) -> bool { self.sign == Minus }
            }
            trait UnsignedAbs 
            {
                type Unsigned;
                fn checked_uabs( self ) -> CheckedUnsignedAbs<Self::Unsigned>;
            }
            enum CheckedUnsignedAbs<T> 
            {
                Positive( T ),
                Negative( T ),
            } use self::CheckedUnsignedAbs::{Negative, Positive};

            macro_rules! impl_unsigned_abs
            {
                ( $Signed:ty, $Unsigned:ty ) => {
                    impl UnsignedAbs for $Signed {
                        type Unsigned = $Unsigned;

                        #[inline] fn checked_uabs( self ) -> CheckedUnsignedAbs<Self::Unsigned> {
                            if self >= 0 {
                                Positive( self as $Unsigned )
                            } else {
                                Negative( self.wrapping_neg() as $Unsigned )
                            }
                        }
                    }
                };
            }
            impl_unsigned_abs!( i8, u8 );
            impl_unsigned_abs!( i16, u16 );
            impl_unsigned_abs!( i32, u32 );
            impl_unsigned_abs!( i64, u64 );
            impl_unsigned_abs!( i128, u128 );
            impl_unsigned_abs!( isize, usize );

            impl Neg for BigInt
            {
                type  Output = BigInt;

                #[inline] fn neg( mut self ) -> BigInt {
                    self.sign = -self.sign;
                    self
                }
            }
            
            impl Neg for &BigInt
            {
                type Output = BigInt;

                #[inline] fn neg( self ) -> BigInt 
                {
                    -self.clone()
                }
            }
            
            impl Integer for BigInt
            {
                #[inline] fn div_rem( &self, other:&BigInt ) -> ( BigInt, BigInt ) {
                   
                    let ( d_ui, r_ui ) = self.data.div_rem( &other.data );
                    let d = BigInt::from_biguint( self.sign, d_ui );
                    let r = BigInt::from_biguint( self.sign, r_ui );
                    if other.is_negative() {
                        ( -d, r )
                    } else {
                        ( d, r )
                    }
               }
                
                #[inline] fn div_floor( &self, other:&BigInt ) -> BigInt {
                    let ( d_ui, m ) = self.data.div_mod_floor( &other.data );
                    let d = BigInt::from( d_ui );
                    match ( self.sign, other.sign ) {
                        ( Plus, Plus ) | ( NoSign, Plus ) | ( Minus, Minus ) => d,
                        ( Plus, Minus ) | ( NoSign, Minus ) | ( Minus, Plus ) => {
                            if m.is_zero() {
                                -d
                            } else {
                                -d - 1u32
                            }
                        }
                        ( _, NoSign ) => unreachable!(),
                    }
               }
                
                #[inline] fn mod_floor( &self, other:&BigInt ) -> BigInt {
                   
                    let m_ui = self.data.mod_floor( &other.data );
                    let m = BigInt::from_biguint( other.sign, m_ui );
                    match ( self.sign, other.sign ) {
                        ( Plus, Plus ) | ( NoSign, Plus ) | ( Minus, Minus ) => m,
                        ( Plus, Minus ) | ( NoSign, Minus ) | ( Minus, Plus ) => {
                            if m.is_zero() {
                                m
                            } else {
                                other - m
                            }
                        }
                        ( _, NoSign ) => unreachable!(),
                    }
                }
                fn div_mod_floor( &self, other:&BigInt ) -> ( BigInt, BigInt ) {
                   
                    let ( d_ui, m_ui ) = self.data.div_mod_floor( &other.data );
                    let d = BigInt::from( d_ui );
                    let m = BigInt::from_biguint( other.sign, m_ui );
                    match ( self.sign, other.sign ) {
                        ( Plus, Plus ) | ( NoSign, Plus ) | ( Minus, Minus ) => ( d, m ),
                        ( Plus, Minus ) | ( NoSign, Minus ) | ( Minus, Plus ) => {
                            if m.is_zero() {
                                ( -d, m )
                            } else {
                                ( -d - 1u32, other - m )
                            }
                        }
                        ( _, NoSign ) => unreachable!(),
                    }
               }
                
                #[inline] fn div_ceil( &self, other:&Self ) -> Self {
                    let ( d_ui, m ) = self.data.div_mod_floor( &other.data );
                    let d = BigInt::from( d_ui );
                    match ( self.sign, other.sign ) {
                        ( Plus, Minus ) | ( NoSign, Minus ) | ( Minus, Plus ) => -d,
                        ( Plus, Plus ) | ( NoSign, Plus ) | ( Minus, Minus ) => {
                            if m.is_zero() {
                                d
                            } else {
                                d + 1u32
                            }
                        }
                        ( _, NoSign ) => unreachable!(),
                    }
                }

                #[inline] fn gcd( &self, other:&BigInt ) -> BigInt {
                    BigInt::from( self.data.gcd( &other.data ) )
                }

                #[inline] fn lcm( &self, other:&BigInt ) -> BigInt {
                    BigInt::from( self.data.lcm( &other.data ) )
               }
                
                #[inline] fn gcd_lcm( &self, other:&BigInt ) -> ( BigInt, BigInt ) {
                    let ( gcd, lcm ) = self.data.gcd_lcm( &other.data );
                    ( BigInt::from( gcd ), BigInt::from( lcm ) )
                }

                #[inline] fn extended_gcd_lcm( &self, other:&BigInt ) -> ( ::num::integers::ExtendedGcd<BigInt>, BigInt ) {
                    let egcd = self.extended_gcd( other );
                    let lcm = if egcd.gcd.is_zero() {
                        Self::ZERO
                    } else {
                        BigInt::from( &self.data / &egcd.gcd.data * &other.data )
                    };
                    ( egcd, lcm )
                }

                #[inline] fn divides( &self, other:&BigInt ) -> bool {
                    self.is_multiple_of( other )
                }

                #[inline] fn is_multiple_of( &self, other:&BigInt ) -> bool {
                    self.data.is_multiple_of( &other.data )
                }

                #[inline] fn is_even( &self ) -> bool { self.data.is_even() }

                #[inline] fn is_odd( &self ) -> bool { self.data.is_odd() }

                #[inline] fn next_multiple_of( &self, other:&Self ) -> Self {
                    let m = self.mod_floor( other );
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + ( other - m )
                    }
                }

                #[inline] fn prev_multiple_of( &self, other:&Self ) -> Self {
                    self - self.mod_floor( other )
                }
                fn dec( &mut self ) {
                    *self -= 1u32;
                }
                fn inc( &mut self ) {
                    *self += 1u32;
                }
            }
            
            impl Roots for BigInt
            {
                fn nth_root( &self, n: u32 ) -> Self
                {
                    assert!( 
                        !( self.is_negative() && n.is_even() ),
                        "root of degree {} is imaginary",
                        n
                     );

                    BigInt::from_biguint( self.sign, self.data.nth_root( n ) )
                }
                fn sqrt( &self ) -> Self
                {
                    assert!( !self.is_negative(), "square root is imaginary" );

                    BigInt::from_biguint( self.sign, self.data.sqrt() )
                }
                fn cbrt( &self ) -> Self
                {
                    BigInt::from_biguint( self.sign, self.data.cbrt() )
                }
            }
            
            impl IntDigits for BigInt
            {
                #[inline] fn digits( &self ) -> &[BigDigit] { self.data.digits()}
                
                #[inline] fn digits_mut( &mut self ) -> &mut Vec<BigDigit> { self.data.digits_mut()}
                
                #[inline] fn normalize( &mut self )
                {
                    self.data.normalize();
                    if self.data.is_zero() { self.sign = NoSign; }
               }
                
                #[inline] fn capacity( &self ) -> usize { self.data.capacity()}
                
                #[inline] fn len( &self ) -> usize { self.data.len() }
            }

            pub trait ToBigInt
            {
                fn to_bigint( &self ) -> Option<BigInt>;
            }
            
            impl BigInt
            {

                pub const ZERO: Self = BigInt {
                    sign: NoSign,
                    data: BigUint::ZERO,
                };

                #[inline] pub fn new( sign: Sign, digits: Vec<u32> ) -> BigInt {
                    BigInt::from_biguint( sign, BigUint::new( digits ) )
                }

                #[inline] pub fn from_biguint( mut sign: Sign, mut data: BigUint ) -> BigInt {
                    if sign == NoSign {
                        data.assign_from_slice( &[] );
                    } else if data.is_zero() {
                        sign = NoSign;
                    }
                    BigInt { sign, data }
                }

                #[inline] pub fn from_slice( sign: Sign, slice:&[u32] ) -> BigInt {
                    BigInt::from_biguint( sign, BigUint::from_slice( slice ) )
                }

                #[inline] pub fn assign_from_slice( &mut self, sign: Sign, slice:&[u32] ) {
                    if sign == NoSign {
                        self.set_zero();
                    } else {
                        self.data.assign_from_slice( slice );
                        self.sign = if self.data.is_zero() { NoSign } else { sign };
                    }
                }

                #[inline] pub fn from_bytes_be( sign: Sign, bytes:&[u8] ) -> BigInt {
                    BigInt::from_biguint( sign, BigUint::from_bytes_be( bytes ) )
                }

                #[inline] pub fn from_bytes_le( sign: Sign, bytes:&[u8] ) -> BigInt {
                    BigInt::from_biguint( sign, BigUint::from_bytes_le( bytes ) )
               }
                
                #[inline] pub fn from_signed_bytes_be( digits:&[u8] ) -> BigInt {
                    convert::from_signed_bytes_be( digits )
                }

                #[inline] pub fn from_signed_bytes_le( digits:&[u8] ) -> BigInt {
                    convert::from_signed_bytes_le( digits )
                }

                #[inline] pub fn parse_bytes( buf:&[u8], radix: u32 ) -> Option<BigInt> {
                    let s = str::from_utf8( buf ).ok()?;
                    BigInt::from_str_radix( s, radix ).ok()
                }

                pub fn from_radix_be( sign: Sign, buf:&[u8], radix: u32 ) -> Option<BigInt> {
                    let u = BigUint::from_radix_be( buf, radix )?;
                    Some( BigInt::from_biguint( sign, u ) )
                }

                pub fn from_radix_le( sign: Sign, buf:&[u8], radix: u32 ) -> Option<BigInt> {
                    let u = BigUint::from_radix_le( buf, radix )?;
                    Some( BigInt::from_biguint( sign, u ) )
                }

                #[inline] pub fn to_bytes_be( &self ) -> ( Sign, Vec<u8> ) { ( self.sign, self.data.to_bytes_be() ) }

                #[inline] pub fn to_bytes_le( &self ) -> ( Sign, Vec<u8> ) { ( self.sign, self.data.to_bytes_le() ) }
                
                #[inline] pub fn to_u32_digits( &self ) -> ( Sign, Vec<u32> ) { ( self.sign, self.data.to_u32_digits() ) }
                
                #[inline] pub fn to_u64_digits( &self ) -> ( Sign, Vec<u64> ) { ( self.sign, self.data.to_u64_digits() ) }
                
                #[inline] pub fn iter_u32_digits( &self ) -> U32Digits<'_> { self.data.iter_u32_digits()}
                
                #[inline] pub fn iter_u64_digits( &self ) -> U64Digits<'_> { self.data.iter_u64_digits() }

                #[inline] pub fn to_signed_bytes_be( &self ) -> Vec<u8> { convert::to_signed_bytes_be( self ) }

                #[inline] pub fn to_signed_bytes_le( &self ) -> Vec<u8> { convert::to_signed_bytes_le( self ) }

                #[inline] pub fn to_str_radix( &self, radix: u32 ) -> String {
                    let mut v = to_str_radix_reversed( &self.data, radix );

                    if self.is_negative() {
                        v.push( b'-' );
                    }
                    v.reverse();
                    unsafe { String::from_utf8_unchecked( v ) }
                }

                #[inline] pub fn to_radix_be( &self, radix: u32 ) -> ( Sign, Vec<u8> ) {
                    ( self.sign, self.data.to_radix_be( radix ) )
                }

                #[inline] pub fn to_radix_le( &self, radix: u32 ) -> ( Sign, Vec<u8> ) {
                    ( self.sign, self.data.to_radix_le( radix ) )
                }

                #[inline] pub fn sign( &self ) -> Sign { self.sign }

                #[inline] pub fn magnitude( &self ) -> &BigUint { &self.data }
                
                #[inline] pub fn into_parts( self ) -> ( Sign, BigUint ) {
                    ( self.sign, self.data )
               }
                
                #[inline] pub fn bits( &self ) -> u64 { self.data.bits() }

                #[inline] pub fn to_biguint( &self ) -> Option<BigUint> {
                    match self.sign {
                        Plus => Some( self.data.clone() ),
                        NoSign => Some( BigUint::ZERO ),
                        Minus => None,
                    }
               }
                
                #[inline] pub fn checked_add( &self, v:&BigInt ) -> Option<BigInt> { Some( self + v )}
                
                #[inline] pub fn checked_sub( &self, v:&BigInt ) -> Option<BigInt> { Some( self - v )}
                
                #[inline] pub fn checked_mul( &self, v:&BigInt ) -> Option<BigInt> { Some( self * v )}
                
                #[inline] pub fn checked_div( &self, v:&BigInt ) -> Option<BigInt> {
                    if v.is_zero() {
                        return None;
                    }
                    Some( self / v )
                }

                pub fn pow( &self, exponent: u32 ) -> Self {
                    Pow::pow( self, exponent )
                }

                pub fn modpow( &self, exponent:&Self, modulus:&Self ) -> Self {
                    power::modpow( self, exponent, modulus )
                }

                pub fn modinv( &self, modulus:&Self ) -> Option<Self> {
                    let result = self.data.modinv( &modulus.data )?;
                   
                    let ( sign, mag ) = match ( self.is_negative(), modulus.is_negative() ) {
                        ( false, false ) => ( Plus, result ),
                        ( true, false ) => ( Plus, &modulus.data - result ),
                        ( false, true ) => ( Minus, &modulus.data - result ),
                        ( true, true ) => ( Minus, result ),
                    };
                    Some( BigInt::from_biguint( sign, mag ) )
                }

                pub fn sqrt( &self ) -> Self { Roots::sqrt( self ) }

                pub fn cbrt( &self ) -> Self { Roots::cbrt( self ) }

                pub fn nth_root( &self, n: u32 ) -> Self {
                    Roots::nth_root( self, n )
                }

                pub fn trailing_zeros( &self ) -> Option<u64> { self.data.trailing_zeros() }

                pub fn bit( &self, bit: u64 ) -> bool
                {
                    if self.is_negative()
                    {
                        if bit >= u64::from( ::num::big::digit::BITS ) * self.len() as u64
                        {
                            true
                        }
                        
                        else
                        {
                            let trailing_zeros = self.data.trailing_zeros().unwrap();
                            match Ord::cmp( &bit, &trailing_zeros ) {
                                Ordering::Less => false,
                                Ordering::Equal => true,
                                Ordering::Greater => !self.data.bit( bit ),
                            }
                        }
                    }
                    
                    else
                    {
                        self.data.bit( bit )
                    }
                }

                pub fn set_bit( &mut self, bit: u64, value: bool )
                {
                    match self.sign {
                        Sign::Plus => self.data.set_bit( bit, value ),
                        Sign::Minus => bits::set_negative_bit( self, bit, value ),
                        Sign::NoSign => {
                            if value {
                                self.data.set_bit( bit, true );
                                self.sign = Sign::Plus;
                            } else {
                               
                            }
                        }
                    }
                   
                    self.normalize();
                }
            }
            
            impl ::num::traits::FromBytes for BigInt
            {
                type  Bytes = [u8];
                fn from_be_bytes( bytes:&Self::Bytes ) -> Self {
                    Self::from_signed_bytes_be( bytes )
                }
                fn from_le_bytes( bytes:&Self::Bytes ) -> Self {
                    Self::from_signed_bytes_le( bytes )
                }
            }
            
            impl ::num::traits::ToBytes for BigInt
            {
                type  Bytes = Vec<u8>;
                fn to_be_bytes( &self ) -> Self::Bytes { self.to_signed_bytes_be() }
                fn to_le_bytes( &self ) -> Self::Bytes { self.to_signed_bytes_le() }
            }
        }

        pub mod rand
        {
            //! Randomization of big integers
            use ::
            {
                num::
                {
                    big::{ uint::biguint_from_vec, BigInt, BigUint, Sign::* },
                    integers::{ Integer },
                    traits::{ ToPrimitive, Zero },
                },
                rand::
                {
                    Rng,
                    distributions::uniform::{SampleBorrow, SampleUniform, UniformSampler},
                    prelude::Distribution,
                },
                *,
            };
            /*
            */

            pub trait RandBigInt
            {
                fn gen_biguint( &mut self, bit_size: u64 ) -> BigUint;
                fn gen_bigint( &mut self, bit_size: u64 ) -> BigInt;
                fn gen_biguint_below( &mut self, bound:&BigUint ) -> BigUint;
                fn gen_biguint_range( &mut self, lbound:&BigUint, ubound:&BigUint ) -> BigUint;
                fn gen_bigint_range( &mut self, lbound:&BigInt, ubound:&BigInt ) -> BigInt;
            }
            
            fn gen_bits<R: Rng + ?Sized>( rng:&mut R, data:&mut [u32], rem: u64 ) 
            {
               
                rng.fill( data );
                if rem > 0 {
                    let last = data.len() - 1;
                    data[last] >>= 32 - rem;
                }
            }
            
            impl<R: Rng + ?Sized> RandBigInt for R 
            {
                cfg_digit!( 
                    fn gen_biguint( &mut self, bit_size: u64 ) -> BigUint {
                        let ( digits, rem ) = bit_size.div_rem( &32 );
                        let len = ( digits + ( rem > 0 ) as u64 )
                            .to_usize()
                            .expect( "capacity overflow" );
                        let mut data = vec![0u32; len];
                        gen_bits( self, &mut data, rem );
                        biguint_from_vec( data )
                    }
                    fn gen_biguint( &mut self, bit_size: u64 ) -> BigUint {
                        use ::slice;

                        let ( digits, rem ) = bit_size.div_rem( &32 );
                        let len = ( digits + ( rem > 0 ) as u64 )
                            .to_usize()
                            .expect( "capacity overflow" );
                        let native_digits = Integer::div_ceil( &bit_size, &64 );
                        let native_len = native_digits.to_usize().expect( "capacity overflow" );
                        let mut data = vec![0u64; native_len];
                        unsafe {
                           
                            let ptr = data.as_mut_ptr() as *mut u32;
                            debug_assert!( native_len * 2 >= len );
                            let data = slice::from_raw_parts_mut( ptr, len );
                            gen_bits( self, data, rem );
                        }
                        #[cfg( target_endian = "big" )]
                        for digit in &mut data {
                           
                            *digit = ( *digit << 32 ) | ( *digit >> 32 );
                        }
                        biguint_from_vec( data )
                    }
                 );
                fn gen_bigint( &mut self, bit_size: u64 ) -> BigInt {
                    loop {
                       
                        let biguint = self.gen_biguint( bit_size );
                       
                        let sign = if biguint.is_zero() {
                           
                           
                           
                           
                            if self.gen() {
                                continue;
                            } else {
                                NoSign
                            }
                        } else if self.gen() {
                            Plus
                        } else {
                            Minus
                        };
                        return BigInt::from_biguint( sign, biguint );
                    }
                }
                fn gen_biguint_below( &mut self, bound:&BigUint ) -> BigUint {
                    assert!( !bound.is_zero() );
                    let bits = bound.bits();
                    loop {
                        let n = self.gen_biguint( bits );
                        if n < *bound {
                            return n;
                        }
                    }
                }
                fn gen_biguint_range( &mut self, lbound:&BigUint, ubound:&BigUint ) -> BigUint {
                    assert!( *lbound < *ubound );
                    if lbound.is_zero() {
                        self.gen_biguint_below( ubound )
                    } else {
                        lbound + self.gen_biguint_below( &( ubound - lbound ) )
                    }
                }
                fn gen_bigint_range( &mut self, lbound:&BigInt, ubound:&BigInt ) -> BigInt {
                    assert!( *lbound < *ubound );
                    if lbound.is_zero() {
                        BigInt::from( self.gen_biguint_below( ubound.magnitude() ) )
                    } else if ubound.is_zero() {
                        lbound + BigInt::from( self.gen_biguint_below( lbound.magnitude() ) )
                    } else {
                        let delta = ubound - lbound;
                        lbound + BigInt::from( self.gen_biguint_below( delta.magnitude() ) )
                    }
                }
            }

            #[derive( Clone, Debug )]
            pub struct UniformBigUint 
            {
                base: BigUint,
                len: BigUint,
            }
            
            impl UniformSampler for UniformBigUint 
            {
                type X = BigUint;

                #[inline] fn new<B1, B2>( low_b: B1, high_b: B2 ) -> Self where B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!( low < high );
                    UniformBigUint {
                        len: high - low,
                        base: low.clone(),
                    }
               }
                
                #[inline] fn new_inclusive<B1, B2>( low_b: B1, high_b: B2 ) -> Self where B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!( low <= high );
                    Self::new( low, high + 1u32 )
               }
                
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng:&mut R ) -> Self::X {
                    &self.base + rng.gen_biguint_below( &self.len )
               }
                
                #[inline] fn sample_single<R: Rng + ?Sized, B1, B2>( low: B1, high: B2, rng:&mut R ) -> Self::X where B1: SampleBorrow<Self::X> + Sized,
                    B2: SampleBorrow<Self::X> + Sized,
                {
                    rng.gen_biguint_range( low.borrow(), high.borrow() )
                }
            }
            
            impl SampleUniform for BigUint 
            {
                type Sampler = UniformBigUint;
            }

            #[derive( Clone, Debug )]
            pub struct UniformBigInt 
            {
                base: BigInt,
                len: BigUint,
            }
            
            impl UniformSampler for UniformBigInt 
            {
                type X = BigInt;

                #[inline] fn new<B1, B2>( low_b: B1, high_b: B2 ) -> Self where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!( low < high );
                    UniformBigInt {
                        len: ( high - low ).into_parts().1,
                        base: low.clone(),
                    }
                }
                
                #[inline] fn new_inclusive<B1, B2>( low_b: B1, high_b: B2 ) -> Self where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized
                {
                    let low = low_b.borrow();
                    let high = high_b.borrow();
                    assert!( low <= high );
                    Self::new( low, high + 1u32 )
                }

                #[inline] fn sample<R: Rng + ?Sized>( &self, rng:&mut R ) -> Self::X 
                {
                    &self.base + BigInt::from( rng.gen_biguint_below( &self.len ) )
                }

                #[inline] fn sample_single<R: Rng + ?Sized, B1, B2>( low: B1, high: B2, rng:&mut R ) -> Self::X where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized
                {
                    rng.gen_bigint_range( low.borrow(), high.borrow() )
                }
            }
            
            impl SampleUniform for BigInt 
            {
                type Sampler = UniformBigInt;
            }

            #[derive( Clone, Copy, Debug )]
            pub struct RandomBits 
            {
                bits: u64,
            }
            
            impl RandomBits 
            {
                #[inline] pub fn new( bits: u64 ) -> RandomBits {
                    RandomBits { bits }
                }
            }
            
            impl Distribution<BigUint> for RandomBits 
            {
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng:&mut R ) -> BigUint {
                    rng.gen_biguint( self.bits )
                }
            }
            
            impl Distribution<BigInt> for RandomBits 
            {
                #[inline] fn sample<R: Rng + ?Sized>( &self, rng:&mut R ) -> BigInt {
                    rng.gen_bigint( self.bits )
                }
            }
        }

        pub mod uint
        {
            use ::
            {
                cmp::{ self, Ordering },
                default::{ Default },
                num::
                {
                    big::digit::{ self, BigDigit },
                    integers::{ Integer, Roots },
                    traits::{ ConstZero, Num, One, Pow, ToPrimitive, Unsigned, Zero },
                },
                string::{ String },
                vec::{ Vec },
                *,
            };
            /*
            */            
            pub mod addition
            {
                /*!
                */
                use ::
                {
                    iter::{ Sum },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit}, UsizePromotion
                        },
                        traits::CheckedAdd,
                    },
                    ops::{ Add, AddAssign },
                    *,
                };

                use super::{BigUint, IntDigits};
                /*
                */
                use ::arch::x86_64 as arch;
                
                cfg_64!( 
                    #[inline] fn adc( carry: u8, a: u64, b: u64, out:&mut u64 ) -> u8 {
                       
                       
                        unsafe { arch::_addcarry_u64( carry, a, b, out ) }
                    }
                 );

                #[inline] pub fn __add2( a:&mut [BigDigit], b:&[BigDigit] ) -> BigDigit {
                    debug_assert!( a.len() >= b.len() );

                    let mut carry = 0;
                    let ( a_lo, a_hi ) = a.split_at_mut( b.len() );

                    for ( a, b ) in a_lo.iter_mut().zip( b ) {
                        carry = adc( carry, *a, *b, a );
                    }
                    if carry != 0 {
                        for a in a_hi {
                            carry = adc( carry, *a, 0, a );
                            if carry == 0 {
                                break;
                            }
                        }
                    }
                    carry as BigDigit
                }
                ///
                pub( super ) fn add2( a:&mut [BigDigit], b:&[BigDigit] ) {
                    let carry = __add2( a, b );

                    debug_assert!( carry == 0 );
                }
                forward_all_binop_to_val_ref_commutative!( impl Add for BigUint, add );
                forward_val_assign!( impl AddAssign for BigUint, add_assign );

                impl Add<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    fn add( mut self, other:&BigUint ) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<&BigUint> for BigUint
                {
                    #[inline] fn add_assign( &mut self, other:&BigUint ) {
                        let self_len = self.data.len();
                        let carry = if self_len < other.data.len() {
                            let lo_carry = __add2( &mut self.data[..], &other.data[..self_len] );
                            self.data.extend_from_slice( &other.data[self_len..] );
                            __add2( &mut self.data[self_len..], &[lo_carry] )
                        } else {
                            __add2( &mut self.data[..], &other.data[..] )
                        };
                        if carry != 0 {
                            self.data.push( carry );
                        }
                    }
                }
                promote_unsigned_scalars!( impl Add for BigUint, add );
                promote_unsigned_scalars_assign!( impl AddAssign for BigUint, add_assign );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u32> for BigUint, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u64> for BigUint, add );
                forward_all_scalar_binop_to_val_val_commutative!( impl Add<u128> for BigUint, add );

                impl Add<u32> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn add( mut self, other: u32 ) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<u32> for BigUint
                {
                    #[inline] fn add_assign( &mut self, other: u32 ) {
                        if other != 0 {
                            if self.data.is_empty() {
                                self.data.push( 0 );
                            }
                            let carry = __add2( &mut self.data, &[other as BigDigit] );
                            if carry != 0 {
                                self.data.push( carry );
                            }
                        }
                    }
                }
                impl Add<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn add( mut self, other: u64 ) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<u64> for BigUint {
                    cfg_digit!( 
                        #[inline] fn add_assign( &mut self, other: u64 ) {
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push( 0 );
                                }
                                let carry = __add2( &mut self.data, &[lo, hi] );
                                if carry != 0 {
                                    self.data.push( carry );
                                }
                            }
                        }

                        #[inline] fn add_assign( &mut self, other: u64 ) {
                            if other != 0 {
                                if self.data.is_empty() {
                                    self.data.push( 0 );
                                }
                                let carry = __add2( &mut self.data, &[other as BigDigit] );
                                if carry != 0 {
                                    self.data.push( carry );
                                }
                            }
                        }
                     );
                }
                impl Add<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn add( mut self, other: u128 ) -> BigUint {
                        self += other;
                        self
                    }
                }
                impl AddAssign<u128> for BigUint {
                    cfg_digit!( 
                        #[inline] fn add_assign( &mut self, other: u128 ) {
                            if other <= u128::from( u64::MAX ) {
                                *self += other as u64
                            } else {
                                let ( a, b, c, d ) = super::u32_from_u128( other );
                                let carry = if a > 0 {
                                    while self.data.len() < 4 {
                                        self.data.push( 0 );
                                    }
                                    __add2( &mut self.data, &[d, c, b, a] )
                                } else {
                                    debug_assert!( b > 0 );
                                    while self.data.len() < 3 {
                                        self.data.push( 0 );
                                    }
                                    __add2( &mut self.data, &[d, c, b] )
                                };

                                if carry != 0 {
                                    self.data.push( carry );
                                }
                            }
                        }

                        #[inline] fn add_assign( &mut self, other: u128 ) {
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                            if hi == 0 {
                                *self += lo;
                            } else {
                                while self.data.len() < 2 {
                                    self.data.push( 0 );
                                }
                                let carry = __add2( &mut self.data, &[lo, hi] );
                                if carry != 0 {
                                    self.data.push( carry );
                                }
                            }
                        }
                     );
                }
                impl CheckedAdd for BigUint
                {
                    #[inline] fn checked_add( &self, v:&BigUint ) -> Option<BigUint> { Some( self.add( v ) ) }
                }
                impl_sum_iter_type!( BigUint );

            }
            pub mod division
            {
                /*!
                */
                use ::
                {
                    cmp::Ordering::{Equal, Greater, Less},
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit, DoubleBigDigit}, UsizePromotion
                        },
                        integers::Integer,
                        traits::{CheckedDiv, CheckedEuclid, Euclid, One, ToPrimitive, Zero},
                    },
                    ops::{Div, DivAssign, Rem, RemAssign},
                    *,
                };
                
                use super::addition::__add2;
                use super::{cmp_slice, BigUint};
                /*
                */
                pub const FAST_DIV_WIDE: bool = true;

                #[inline] fn div_wide( hi: BigDigit, lo: BigDigit, divisor: BigDigit ) -> ( BigDigit, BigDigit )
                {
                   
                   
                   
                    debug_assert!( hi < divisor );

                   
                   
                   
                   
                    unsafe {
                        let ( div, rem );

                        cfg_digit!( 
                            macro_rules! div {
                                () => { "div {0:e}" };
                            }
                            macro_rules! div {
                                () => { "div {0:r}" };
                            }
                         );

                        ::arch::asm!( 
                            div!(),
                            in( reg ) divisor,
                            inout( "dx" ) hi => rem,
                            inout( "ax" ) lo => div,
                            options( pure, nomem, nostack ),
                         );

                        ( div, rem )
                    }
               }
                
                #[inline] fn div_half( rem: BigDigit, digit: BigDigit, divisor: BigDigit ) -> ( BigDigit, BigDigit )
                {
                    use ::num::big::digit::{HALF, HALF_BITS};
                    debug_assert!( rem < divisor && divisor <= HALF );
                    let ( hi, rem ) = (( rem << HALF_BITS ) | ( digit >> HALF_BITS ) ).div_rem( &divisor );
                    let ( lo, rem ) = (( rem << HALF_BITS ) | ( digit & HALF ) ).div_rem( &divisor );
                    ( ( hi << HALF_BITS ) | lo, rem )
               }
                
                #[inline] pub fn div_rem_digit( mut a: BigUint, b: BigDigit ) -> ( BigUint, BigDigit )
                {
                    if b == 0 {
                        panic!( "attempt to divide by zero" )
                    }
                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= ::num::big::digit::HALF {
                        for d in a.data.iter_mut().rev() {
                            let ( q, r ) = div_half( rem, *d, b );
                            *d = q;
                            rem = r;
                        }
                    } else {
                        for d in a.data.iter_mut().rev() {
                            let ( q, r ) = div_wide( rem, *d, b );
                            *d = q;
                            rem = r;
                        }
                    }
                    ( a.normalized(), rem )
               }
                
                #[inline] fn rem_digit( a:&BigUint, b: BigDigit ) -> BigDigit
                {
                    if b == 0 {
                        panic!( "attempt to divide by zero" )
                    }
                    let mut rem = 0;

                    if !FAST_DIV_WIDE && b <= ::num::big::digit::HALF {
                        for &digit in a.data.iter().rev() {
                            let ( _, r ) = div_half( rem, digit, b );
                            rem = r;
                        }
                    } else {
                        for &digit in a.data.iter().rev() {
                            let ( _, r ) = div_wide( rem, digit, b );
                            rem = r;
                        }
                    }
                    rem
                }

                fn sub_mul_digit_same_len( a:&mut [BigDigit], b:&[BigDigit], c: BigDigit ) -> BigDigit
                {
                    debug_assert!( a.len() == b.len() );

                   
                   
                    let mut offset_carry = ::num::big::digit::MAX;

                    for ( x, y ) in a.iter_mut().zip( b ) {
                       
                       
                       
                       
                        let offset_sum = ::num::big::digit::to_doublebigdigit( ::num::big::digit::MAX, *x )
                            - ::num::big::digit::MAX as DoubleBigDigit
                            + offset_carry as DoubleBigDigit
                            - *y as DoubleBigDigit * c as DoubleBigDigit;

                        let ( new_offset_carry, new_x ) = ::num::big::digit::from_doublebigdigit( offset_sum );
                        offset_carry = new_offset_carry;
                        *x = new_x;
                    }
                   
                    ::num::big::digit::MAX - offset_carry
                }
                fn div_rem( mut u: BigUint, mut d: BigUint ) -> ( BigUint, BigUint )
                {
                    if d.is_zero() {
                        panic!( "attempt to divide by zero" )
                    }
                    if u.is_zero() {
                        return ( BigUint::ZERO, BigUint::ZERO );
                    }
                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return ( u, BigUint::ZERO );
                        }
                        let ( div, rem ) = div_rem_digit( u, d.data[0] );
                       
                        d.data.clear();
                        d += rem;
                        return ( div, d );
                    }
                   
                    match u.cmp( &d ) {
                        Less => return ( BigUint::ZERO, u ),
                        Equal => {
                            u.set_one();
                            return ( u, BigUint::ZERO );
                        }
                        Greater => {}
                    }
                   
                    //
                   
                   
                   
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                       
                        div_rem_core( u, &d.data )
                    } else {
                        let ( q, r ) = div_rem_core( u << shift, &( d << shift ).data );
                       
                        ( q, r >> shift )
                    }
                }
                pub( super ) fn div_rem_ref( u:&BigUint, d:&BigUint ) -> ( BigUint, BigUint )
                {
                    if d.is_zero() {
                        panic!( "attempt to divide by zero" )
                    }
                    if u.is_zero() {
                        return ( BigUint::ZERO, BigUint::ZERO );
                    }
                    if d.data.len() == 1 {
                        if d.data == [1] {
                            return ( u.clone(), BigUint::ZERO );
                        }
                        let ( div, rem ) = div_rem_digit( u.clone(), d.data[0] );
                        return ( div, rem.into() );
                    }
                   
                    match u.cmp( d ) {
                        Less => return ( BigUint::ZERO, u.clone() ),
                        Equal => return ( One::one(), BigUint::ZERO ),
                        Greater => {}
                    }
                   
                    //
                   
                   
                   
                    //
                    let shift = d.data.last().unwrap().leading_zeros() as usize;

                    if shift == 0 {
                       
                        div_rem_core( u.clone(), &d.data )
                    } else {
                        let ( q, r ) = div_rem_core( u << shift, &( d << shift ).data );
                       
                        ( q, r >> shift )
                    }
                }

                fn div_rem_core( mut a: BigUint, b:&[BigDigit] ) -> ( BigUint, BigUint )
                {
                    debug_assert!( a.data.len() >= b.len() && b.len() > 1 );
                    debug_assert!( b.last().unwrap().leading_zeros() == 0 );

                   
                   
                    //
                   
                   
                    //
                   
                    //
                   
                   
                   
                   
                    //
                   
                   
                   

                   
                    let mut a0 = 0;

                   
                    let b0 = b[b.len() - 1];
                    let b1 = b[b.len() - 2];

                    let q_len = a.data.len() - b.len() + 1;
                    let mut q = BigUint {
                        data: vec![0; q_len],
                    };

                    for j in ( 0..q_len ).rev() {
                        debug_assert!( a.data.len() == b.len() + j );

                        let a1 = *a.data.last().unwrap();
                        let a2 = a.data[a.data.len() - 2];

                       
                       
                        let ( mut q0, mut r ) = if a0 < b0 {
                            let ( q0, r ) = div_wide( a0, a1, b0 );
                            ( q0, r as DoubleBigDigit )
                        } else {
                            debug_assert!( a0 == b0 );
                           
                           
                            ( ::num::big::digit::MAX, a0 as DoubleBigDigit + a1 as DoubleBigDigit )
                        };

                       
                        //
                       
                       
                        //
                       
                       
                       
                        while r <= ::num::big::digit::MAX as DoubleBigDigit
                            && ::num::big::digit::to_doublebigdigit( r as BigDigit, a2 )
                                < q0 as DoubleBigDigit * b1 as DoubleBigDigit
                        {
                            q0 -= 1;
                            r += b0 as DoubleBigDigit;
                        }
                       
                       

                        let mut borrow = sub_mul_digit_same_len( &mut a.data[j..], b, q0 );
                        if borrow > a0 {
                           
                            q0 -= 1;
                            borrow -= __add2( &mut a.data[j..], b );
                        }
                       
                        debug_assert!( borrow == a0 );

                        q.data[j] = q0;

                       
                        a0 = a.data.pop().unwrap();
                    }
                    a.data.push( a0 );
                    a.normalize();

                    debug_assert_eq!( cmp_slice( &a.data, b ), Less );

                    ( q.normalized(), a )
                }
                forward_val_ref_binop_big!( impl Div for BigUint, div );
                forward_ref_val_binop_big!( impl Div for BigUint, div );
                forward_val_assign!( impl DivAssign for BigUint, div_assign );

                impl Div<BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other: BigUint ) -> BigUint {
                        let ( q, _ ) = div_rem( self, other );
                        q
                    }
                }
                impl Div<&BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other:&BigUint ) -> BigUint {
                        let ( q, _ ) = self.div_rem( other );
                        q
                    }
                }
                impl DivAssign<&BigUint> for BigUint
                {
                    #[inline] fn div_assign( &mut self, other:&BigUint ) {
                        *self = &*self / other;
                    }
                }
                promote_unsigned_scalars!( impl Div for BigUint, div );
                promote_unsigned_scalars_assign!( impl DivAssign for BigUint, div_assign );
                forward_all_scalar_binop_to_val_val!( impl Div<u32> for BigUint, div );
                forward_all_scalar_binop_to_val_val!( impl Div<u64> for BigUint, div );
                forward_all_scalar_binop_to_val_val!( impl Div<u128> for BigUint, div );

                impl Div<u32> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other: u32 ) -> BigUint {
                        let ( q, _ ) = div_rem_digit( self, other as BigDigit );
                        q
                    }
                }
                impl DivAssign<u32> for BigUint
                {
                    #[inline] fn div_assign( &mut self, other: u32 ) {
                        *self = &*self / other;
                    }
                }
                impl Div<BigUint> for u32 {
                    type Output = BigUint;

                    #[inline] fn div( self, other: BigUint ) -> BigUint {
                        match other.data.len() {
                            0 => panic!( "attempt to divide by zero" ),
                            1 => From::from( self as BigDigit / other.data[0] ),
                            _ => BigUint::ZERO,
                        }
                    }
                }
                impl Div<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other: u64 ) -> BigUint {
                        let ( q, _ ) = div_rem( self, From::from( other ) );
                        q
                    }
                }
                impl DivAssign<u64> for BigUint
                {
                    #[inline] fn div_assign( &mut self, other: u64 ) {
                       
                        let temp = mem::replace( self, Self::ZERO );
                        *self = temp / other;
                    }
                }
                impl Div<BigUint> for u64 {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline] fn div( self, other: BigUint ) -> BigUint {
                            match other.data.len() {
                                0 => panic!( "attempt to divide by zero" ),
                                1 => From::from( self / u64::from( other.data[0] ) ),
                                2 => From::from( self / ::num::big::digit::to_doublebigdigit( other.data[1], other.data[0] ) ),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline] fn div( self, other: BigUint ) -> BigUint {
                            match other.data.len() {
                                0 => panic!( "attempt to divide by zero" ),
                                1 => From::from( self / other.data[0] ),
                                _ => BigUint::ZERO,
                            }
                        }
                     );
                }
                impl Div<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn div( self, other: u128 ) -> BigUint {
                        let ( q, _ ) = div_rem( self, From::from( other ) );
                        q
                    }
                }
                impl DivAssign<u128> for BigUint
                {
                    #[inline] fn div_assign( &mut self, other: u128 ) {
                        *self = &*self / other;
                    }
                }
                impl Div<BigUint> for u128 {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline] fn div( self, other: BigUint ) -> BigUint {
                            use super::u32_to_u128;
                            match other.data.len() {
                                0 => panic!( "attempt to divide by zero" ),
                                1 => From::from( self / u128::from( other.data[0] ) ),
                                2 => From::from( 
                                    self / u128::from( ::num::big::digit::to_doublebigdigit( other.data[1], other.data[0] ) ),
                                ),
                                3 => From::from( self / u32_to_u128( 0, other.data[2], other.data[1], other.data[0] ) ),
                                4 => From::from( 
                                    self / u32_to_u128( other.data[3], other.data[2], other.data[1], other.data[0] ),
                                ),
                                _ => BigUint::ZERO,
                            }
                        }

                        #[inline] fn div( self, other: BigUint ) -> BigUint {
                            match other.data.len() {
                                0 => panic!( "attempt to divide by zero" ),
                                1 => From::from( self / other.data[0] as u128 ),
                                2 => From::from( self / ::num::big::digit::to_doublebigdigit( other.data[1], other.data[0] ) ),
                                _ => BigUint::ZERO,
                            }
                        }
                     );
                }
                forward_val_ref_binop_big!( impl Rem for BigUint, rem );
                forward_ref_val_binop_big!( impl Rem for BigUint, rem );
                forward_val_assign!( impl RemAssign for BigUint, rem_assign );

                impl Rem<BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other: BigUint ) -> BigUint {
                        if let Some( other ) = other.to_u32() {
                            &self % other
                        } else {
                            let ( _, r ) = div_rem( self, other );
                            r
                        }
                    }
                }
                impl Rem<&BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other:&BigUint ) -> BigUint {
                        if let Some( other ) = other.to_u32() {
                            self % other
                        } else {
                            let ( _, r ) = self.div_rem( other );
                            r
                        }
                    }
                }
                impl RemAssign<&BigUint> for BigUint
                {
                    #[inline] fn rem_assign( &mut self, other:&BigUint ) {
                        *self = &*self % other;
                    }
                }
                promote_unsigned_scalars!( impl Rem for BigUint, rem );
                promote_unsigned_scalars_assign!( impl RemAssign for BigUint, rem_assign );
                forward_all_scalar_binop_to_ref_val!( impl Rem<u32> for BigUint, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<u64> for BigUint, rem );
                forward_all_scalar_binop_to_val_val!( impl Rem<u128> for BigUint, rem );

                impl Rem<u32> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other: u32 ) -> BigUint {
                        rem_digit( self, other as BigDigit ).into()
                    }
                }
                impl RemAssign<u32> for BigUint
                {
                    #[inline] fn rem_assign( &mut self, other: u32 ) {
                        *self = &*self % other;
                    }
                }
                impl Rem<&BigUint> for u32 {
                    type Output = BigUint;

                    #[inline] fn rem( mut self, other:&BigUint ) -> BigUint {
                        self %= other;
                        From::from( self )
                    }
                }
                macro_rules! impl_rem_assign_scalar {
                    ( $scalar:ty, $to_scalar:ident ) => {
                        forward_val_assign_scalar!( impl RemAssign for BigUint, $scalar, rem_assign );
                        impl RemAssign<&BigUint> for $scalar {
                            #[inline]
                            fn rem_assign( &mut self, other:&BigUint ) {
                                *self = match other.$to_scalar() {
                                    None => *self,
                                    Some( 0 ) => panic!( "attempt to divide by zero" ),
                                    Some( v ) => *self % v
                                };
                            }
                        }
                    }
                }
               
                impl_rem_assign_scalar!( u128, to_u128 );
                impl_rem_assign_scalar!( usize, to_usize );
                impl_rem_assign_scalar!( u64, to_u64 );
                impl_rem_assign_scalar!( u32, to_u32 );
                impl_rem_assign_scalar!( u16, to_u16 );
                impl_rem_assign_scalar!( u8, to_u8 );
                impl_rem_assign_scalar!( i128, to_i128 );
                impl_rem_assign_scalar!( isize, to_isize );
                impl_rem_assign_scalar!( i64, to_i64 );
                impl_rem_assign_scalar!( i32, to_i32 );
                impl_rem_assign_scalar!( i16, to_i16 );
                impl_rem_assign_scalar!( i8, to_i8 );

                impl Rem<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other: u64 ) -> BigUint {
                        let ( _, r ) = div_rem( self, From::from( other ) );
                        r
                    }
                }
                impl RemAssign<u64> for BigUint
                {
                    #[inline] fn rem_assign( &mut self, other: u64 ) {
                        *self = &*self % other;
                    }
                }
                impl Rem<BigUint> for u64 {
                    type Output = BigUint;

                    #[inline] fn rem( mut self, other: BigUint ) -> BigUint {
                        self %= other;
                        From::from( self )
                    }
                }
                impl Rem<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn rem( self, other: u128 ) -> BigUint {
                        let ( _, r ) = div_rem( self, From::from( other ) );
                        r
                    }
                }
                impl RemAssign<u128> for BigUint
                {
                    #[inline] fn rem_assign( &mut self, other: u128 ) {
                        *self = &*self % other;
                    }
                }
                impl Rem<BigUint> for u128 {
                    type Output = BigUint;

                    #[inline] fn rem( mut self, other: BigUint ) -> BigUint {
                        self %= other;
                        From::from( self )
                    }
                }
                impl CheckedDiv for BigUint
                {
                    #[inline] fn checked_div( &self, v:&BigUint ) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.div( v ) )
                    }
                }
                impl CheckedEuclid for BigUint
                {
                    #[inline] fn checked_div_euclid( &self, v:&BigUint ) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.div_euclid( v ) )
                    }
                    #[inline] fn checked_rem_euclid( &self, v:&BigUint ) -> Option<BigUint> {
                        if v.is_zero() {
                            return None;
                        }
                        Some( self.rem_euclid( v ) )
                    }
                    fn checked_div_rem_euclid( &self, v:&Self ) -> Option<( Self, Self )> { Some( self.div_rem_euclid( v ) ) }
                }
                impl Euclid for BigUint
                {
                    #[inline] fn div_euclid( &self, v:&BigUint ) -> BigUint {
                       
                        self / v
                    }
                    #[inline] fn rem_euclid( &self, v:&BigUint ) -> BigUint {
                       
                        self % v
                    }
                    fn div_rem_euclid( &self, v:&Self ) -> ( Self, Self ) {
                       
                        self.div_rem( v )
                    }
                }
            }
            pub mod multiplication
            {
                /*!
                */
                use ::
                {
                    cmp::{ Ordering },
                    iter::{ Product },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit, DoubleBigDigit},
                            Sign::{self, Minus, NoSign, Plus},
                            {BigInt, UsizePromotion},
                        },
                        traits::{ CheckedMul, FromPrimitive, One, Zero },
                    },
                    ops::{Mul, MulAssign},
                    *,
                };
                use super::addition::{__add2, add2};
                use super::subtraction::sub2;
                use super::{biguint_from_vec, cmp_slice, BigUint, IntDigits};
                /*
                */
                #[inline] pub fn mac_with_carry( 
                    a: BigDigit,
                    b: BigDigit,
                    c: BigDigit,
                    acc:&mut DoubleBigDigit,
                ) -> BigDigit {
                    *acc += DoubleBigDigit::from( a );
                    *acc += DoubleBigDigit::from( b ) * DoubleBigDigit::from( c );
                    let lo = *acc as BigDigit;
                    *acc >>= ::num::big::digit::BITS;
                    lo
               }
                
                #[inline] fn mul_with_carry( a: BigDigit, b: BigDigit, acc:&mut DoubleBigDigit ) -> BigDigit {
                    *acc += DoubleBigDigit::from( a ) * DoubleBigDigit::from( b );
                    let lo = *acc as BigDigit;
                    *acc >>= ::num::big::digit::BITS;
                    lo
                }
                fn mac_digit( acc:&mut [BigDigit], b:&[BigDigit], c: BigDigit ) {
                    if c == 0 {
                        return;
                    }
                    let mut carry = 0;
                    let ( a_lo, a_hi ) = acc.split_at_mut( b.len() );

                    for ( a, &b ) in a_lo.iter_mut().zip( b ) {
                        *a = mac_with_carry( *a, b, c, &mut carry );
                    }
                    let ( carry_hi, carry_lo ) = ::num::big::digit::from_doublebigdigit( carry );

                    let final_carry = if carry_hi == 0 {
                        __add2( a_hi, &[carry_lo] )
                    } else {
                        __add2( a_hi, &[carry_hi, carry_lo] )
                    };
                    assert_eq!( final_carry, 0, "carry overflow during multiplication!" );
                }
                fn bigint_from_slice( slice:&[BigDigit] ) -> BigInt {
                    BigInt::from( biguint_from_vec( slice.to_vec() ) )
                }
                #[allow( clippy::many_single_char_names )]
                fn mac3( mut acc:&mut [BigDigit], mut b:&[BigDigit], mut c:&[BigDigit] ) {
                   
                    if let Some( &0 ) = b.first() {
                        if let Some( nz ) = b.iter().position( |&d| d != 0 ) {
                            b = &b[nz..];
                            acc = &mut acc[nz..];
                        } else { return; }
                    }
                    if let Some( &0 ) = c.first() {
                        if let Some( nz ) = c.iter().position( |&d| d != 0 ) {
                            c = &c[nz..];
                            acc = &mut acc[nz..];
                        } else { return; }
                    }
                    let acc = acc;
                    let ( x, y ) = if b.len() < c.len() { ( b, c ) } else { ( c, b ) };

                   
                    //
                   
                   
                   
                   
                   
                   
                    //
                   
                   

                    if x.len() <= 32 {
                       
                        for ( i, xi ) in x.iter().enumerate() {
                            mac_digit( &mut acc[i..], y, *xi );
                        }
                    } else if x.len() * 2 <= y.len() {
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                       
                        //
                       
                        //
                       
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                       
                        let m2 = y.len() / 2;
                        let ( low2, high2 ) = y.split_at( m2 );

                       
                        mac3( acc, x, low2 );
                        mac3( &mut acc[m2..], x, high2 );
                    } else if x.len() <= 256 {
                       
                        //
                       
                       
                        //
                       
                       
                        //
                       
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                       
                       
                        //
                       
                       

                       
                       
                        let b = x.len() / 2;
                        let ( x0, x1 ) = x.split_at( b );
                        let ( y0, y1 ) = y.split_at( b );

                       
                       
                        let len = x1.len() + y1.len() + 1;
                        let mut p = BigUint { data: vec![0; len] };

                       
                        mac3( &mut p.data, x1, y1 );

                       
                        p.normalize();

                        add2( &mut acc[b..], &p.data );
                        add2( &mut acc[b * 2..], &p.data );

                       
                        p.data.truncate( 0 );
                        p.data.resize( len, 0 );

                       
                        mac3( &mut p.data, x0, y0 );
                        p.normalize();

                        add2( acc, &p.data );
                        add2( &mut acc[b..], &p.data );

                       
                       
                        let ( j0_sign, j0 ) = sub_sign( x1, x0 );
                        let ( j1_sign, j1 ) = sub_sign( y1, y0 );

                        match j0_sign * j1_sign {
                            Plus => {
                                p.data.truncate( 0 );
                                p.data.resize( len, 0 );

                                mac3( &mut p.data, &j0.data, &j1.data );
                                p.normalize();

                                sub2( &mut acc[b..], &p.data );
                            }
                            Minus => { mac3( &mut acc[b..], &j0.data, &j1.data ); }
                            NoSign => (),
                        }
                    } else {
                       
                        //
                       
                       
                        //
                       
                       
                       
                        let i = y.len() / 3 + 1;

                        let x0_len = Ord::min( x.len(), i );
                        let x1_len = Ord::min( x.len() - x0_len, i );

                        let y0_len = i;
                        let y1_len = Ord::min( y.len() - y0_len, i );

                       
                       
                       
                        //
                       
                        let x0 = bigint_from_slice( &x[..x0_len] );
                        let x1 = bigint_from_slice( &x[x0_len..x0_len + x1_len] );
                        let x2 = bigint_from_slice( &x[x0_len + x1_len..] );

                       
                        let y0 = bigint_from_slice( &y[..y0_len] );
                        let y1 = bigint_from_slice( &y[y0_len..y0_len + y1_len] );
                        let y2 = bigint_from_slice( &y[y0_len + y1_len..] );

                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                       
                        //
                       
                       
                        //
                       
                        //
                       
                        //
                       
                       
                       
                       
                       

                       
                        let p = &x0 + &x2;

                       
                        let q = &y0 + &y2;

                       
                        let p2 = &p - &x1;

                       
                        let q2 = &q - &y1;

                       
                        let r0 = &x0 * &y0;

                       
                        let r4 = &x2 * &y2;

                       
                        let r1 = ( p + x1 ) * ( q + y1 );

                       
                        let r2 = &p2 * &q2;

                       
                        let r3 = (( p2 + x2 ) * 2 - x0 ) * ( ( q2 + y2 ) * 2 - y0 );

                       
                        //
                       
                       
                       
                       
                       
                        //
                       
                       
                        //
                       
                       
                       
                       
                       
                        //
                       
                       
                        let mut comp3: BigInt = ( r3 - &r1 ) / 3u32;
                        let mut comp1: BigInt = ( r1 - &r2 ) >> 1;
                        let mut comp2: BigInt = r2 - &r0;
                        comp3 = (( &comp2 - comp3 ) >> 1 ) + ( &r4 << 1 );
                        comp2 += &comp1 - &r4;
                        comp1 -= &comp3;

                       
                        //
                       
                        //
                       
                       
                       
                       
                       
                       
                       
                       
                        //
                       
                        for ( j, result ) in [&r0, &comp1, &comp2, &comp3, &r4].iter().enumerate().rev() {
                            match result.sign() {
                                Plus => add2( &mut acc[i * j..], result.digits() ),
                                Minus => sub2( &mut acc[i * j..], result.digits() ),
                                NoSign => {}
                            }
                        }
                    }
                }
                fn mul3( x:&[BigDigit], y:&[BigDigit] ) -> BigUint {
                    let len = x.len() + y.len() + 1;
                    let mut prod = BigUint { data: vec![0; len] };

                    mac3( &mut prod.data, x, y );
                    prod.normalized()
                }
                fn scalar_mul( a:&mut BigUint, b: BigDigit ) {
                    match b {
                        0 => a.set_zero(),
                        1 => {}
                        _ => {
                            if b.is_power_of_two() {
                                *a <<= b.trailing_zeros();
                            } else {
                                let mut carry = 0;
                                for a in a.data.iter_mut() {
                                    *a = mul_with_carry( *a, b, &mut carry );
                                }
                                if carry != 0 {
                                    a.data.push( carry as BigDigit );
                                }
                            }
                        }
                    }
                }
                fn sub_sign( mut a:&[BigDigit], mut b:&[BigDigit] ) -> ( Sign, BigUint ) {
                   
                    if let Some( &0 ) = a.last() {
                        a = &a[..a.iter().rposition( |&x| x != 0 ).map_or( 0, |i| i + 1 )];
                    }
                    if let Some( &0 ) = b.last() {
                        b = &b[..b.iter().rposition( |&x| x != 0 ).map_or( 0, |i| i + 1 )];
                    }
                    match cmp_slice( a, b ) {
                        Ordering::Greater => {
                            let mut a = a.to_vec();
                            sub2( &mut a, b );
                            ( Plus, biguint_from_vec( a ) )
                        }
                        Ordering::Less => {
                            let mut b = b.to_vec();
                            sub2( &mut b, a );
                            ( Minus, biguint_from_vec( b ) )
                        }
                        Ordering::Equal => ( NoSign, BigUint::ZERO ),
                    }
                }
                macro_rules! impl_mul {
                    ( $( impl Mul<$Other:ty> for $Self:ty; )* ) => {$( 
                        impl Mul<$Other> for $Self {
                            type Output = BigUint;

                            #[inline]
                            fn mul( self, other: $Other ) -> BigUint {
                                match ( &*self.data, &*other.data ) {
                                   
                                    ( &[], _ ) | ( _, &[] ) => BigUint::ZERO,
                                   
                                    ( _, &[digit] ) => self * digit,
                                    ( &[digit], _ ) => other * digit,
                                   
                                    ( x, y ) => mul3( x, y ),
                                }
                            }
                        }
                    )*}
                }
                impl_mul! {
                    impl Mul<BigUint> for BigUint;
                    impl Mul<BigUint> for &BigUint;
                    impl Mul<&BigUint> for BigUint;
                    impl Mul<&BigUint> for &BigUint;
                }
                macro_rules! impl_mul_assign {
                    ( $( impl MulAssign<$Other:ty> for BigUint; )* ) => {$( 
                        impl MulAssign<$Other> for BigUint {
                            #[inline]
                            fn mul_assign( &mut self, other: $Other ) {
                                match ( &*self.data, &*other.data ) {
                                   
                                    ( &[], _ ) => {},
                                    ( _, &[] ) => self.set_zero(),
                                   
                                    ( _, &[digit] ) => *self *= digit,
                                    ( &[digit], _ ) => *self = other * digit,
                                   
                                    ( x, y ) => *self = mul3( x, y ),
                                }
                            }
                        }
                    )*}
                }
                impl_mul_assign! {
                    impl MulAssign<BigUint> for BigUint;
                    impl MulAssign<&BigUint> for BigUint;
                }
                promote_unsigned_scalars!( impl Mul for BigUint, mul );
                promote_unsigned_scalars_assign!( impl MulAssign for BigUint, mul_assign );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u32> for BigUint, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u64> for BigUint, mul );
                forward_all_scalar_binop_to_val_val_commutative!( impl Mul<u128> for BigUint, mul );

                impl Mul<u32> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn mul( mut self, other: u32 ) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u32> for BigUint
                {
                    #[inline] fn mul_assign( &mut self, other: u32 ) {
                        scalar_mul( self, other as BigDigit );
                    }
                }
                impl Mul<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn mul( mut self, other: u64 ) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u64> for BigUint {
                    cfg_digit!( 
                        #[inline] fn mul_assign( &mut self, other: u64 ) {
                            if let Some( other ) = BigDigit::from_u64( other ) {
                                scalar_mul( self, other );
                            } else {
                                let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                                *self = mul3( &self.data, &[lo, hi] );
                            }
                        }

                        #[inline] fn mul_assign( &mut self, other: u64 ) {
                            scalar_mul( self, other );
                        }
                     );
                }
                impl Mul<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn mul( mut self, other: u128 ) -> BigUint {
                        self *= other;
                        self
                    }
                }
                impl MulAssign<u128> for BigUint {
                    cfg_digit!( 
                        #[inline] fn mul_assign( &mut self, other: u128 ) {
                            if let Some( other ) = BigDigit::from_u128( other ) {
                                scalar_mul( self, other );
                            } else {
                                *self = match super::u32_from_u128( other ) {
                                    ( 0, 0, c, d ) => mul3( &self.data, &[d, c] ),
                                    ( 0, b, c, d ) => mul3( &self.data, &[d, c, b] ),
                                    ( a, b, c, d ) => mul3( &self.data, &[d, c, b, a] ),
                                };
                            }
                        }

                        #[inline] fn mul_assign( &mut self, other: u128 ) {
                            if let Some( other ) = BigDigit::from_u128( other ) {
                                scalar_mul( self, other );
                            } else {
                                let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                                *self = mul3( &self.data, &[lo, hi] );
                            }
                        }
                     );
                }
                impl CheckedMul for BigUint
                {
                    #[inline] fn checked_mul( &self, v:&BigUint ) -> Option<BigUint> { Some( self.mul( v ) ) }
                }
                impl_product_iter_type!( BigUint );
            }
            pub mod subtraction
            {
                /*!
                */
                use ::
                {
                    cmp::Ordering::{ Equal, Greater, Less },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit}, UsizePromotion
                        },
                        traits::{ CheckedSub },
                    },
                    ops::{ Sub, SubAssign },
                    *,
                };
                
                use super::BigUint;
                /*
                */
                use ::arch::x86_64 as arch;
                
                cfg_64!( 
                    #[inline] fn sbb( borrow: u8, a: u64, b: u64, out:&mut u64 ) -> u8 {
                       
                       
                        unsafe { arch::_subborrow_u64( borrow, a, b, out ) }
                    }
                 );
                
                cfg_32!( 
                    #[inline] fn sbb( borrow: u8, a: u32, b: u32, out:&mut u32 ) -> u8 {
                       
                       
                        unsafe { arch::_subborrow_u32( borrow, a, b, out ) }
                    }
                 );
                
                pub( super ) fn sub2( a:&mut [BigDigit], b:&[BigDigit] ) {
                    let mut borrow = 0;

                    let len = Ord::min( a.len(), b.len() );
                    let ( a_lo, a_hi ) = a.split_at_mut( len );
                    let ( b_lo, b_hi ) = b.split_at( len );

                    for ( a, b ) in a_lo.iter_mut().zip( b_lo ) {
                        borrow = sbb( borrow, *a, *b, a );
                    }
                    if borrow != 0 {
                        for a in a_hi {
                            borrow = sbb( borrow, *a, 0, a );
                            if borrow == 0 {
                                break;
                            }
                        }
                    }
                   
                    assert!( 
                        borrow == 0 && b_hi.iter().all( |x| *x == 0 ),
                        "Cannot subtract b from a because b is larger than a."
                     );
                }
               
                #[inline] fn __sub2rev( a:&[BigDigit], b:&mut [BigDigit] ) -> u8 {
                    debug_assert!( b.len() == a.len() );

                    let mut borrow = 0;

                    for ( ai, bi ) in a.iter().zip( b ) {
                        borrow = sbb( borrow, *ai, *bi, bi );
                    }
                    borrow
                }
                fn sub2rev( a:&[BigDigit], b:&mut [BigDigit] ) {
                    debug_assert!( b.len() >= a.len() );

                    let len = Ord::min( a.len(), b.len() );
                    let ( a_lo, a_hi ) = a.split_at( len );
                    let ( b_lo, b_hi ) = b.split_at_mut( len );

                    let borrow = __sub2rev( a_lo, b_lo );

                    assert!( a_hi.is_empty() );

                   
                    assert!( 
                        borrow == 0 && b_hi.iter().all( |x| *x == 0 ),
                        "Cannot subtract b from a because b is larger than a."
                     );
                }
                forward_val_val_binop!( impl Sub for BigUint, sub );
                forward_ref_ref_binop_big!( impl Sub for BigUint, sub );
                forward_val_assign!( impl SubAssign for BigUint, sub_assign );

                impl Sub<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    fn sub( mut self, other:&BigUint ) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<&BigUint> for BigUint
                {
                    fn sub_assign( &mut self, other:&BigUint ) {
                        sub2( &mut self.data[..], &other.data[..] );
                        self.normalize();
                    }
                }
                impl Sub<BigUint> for &BigUint
                {
                    type Output = BigUint;

                    fn sub( self, mut other: BigUint ) -> BigUint {
                        let other_len = other.data.len();
                        if other_len < self.data.len() {
                            let lo_borrow = __sub2rev( &self.data[..other_len], &mut other.data );
                            other.data.extend_from_slice( &self.data[other_len..] );
                            if lo_borrow != 0 {
                                sub2( &mut other.data[other_len..], &[1] )
                            }
                        } else {
                            sub2rev( &self.data[..], &mut other.data[..] );
                        }
                        other.normalized()
                    }
                }
                promote_unsigned_scalars!( impl Sub for BigUint, sub );
                promote_unsigned_scalars_assign!( impl SubAssign for BigUint, sub_assign );
                forward_all_scalar_binop_to_val_val!( impl Sub<u32> for BigUint, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<u64> for BigUint, sub );
                forward_all_scalar_binop_to_val_val!( impl Sub<u128> for BigUint, sub );

                impl Sub<u32> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn sub( mut self, other: u32 ) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<u32> for BigUint 
                {
                    fn sub_assign( &mut self, other: u32 ) {
                        sub2( &mut self.data[..], &[other as BigDigit] );
                        self.normalize();
                    }
                }
                impl Sub<BigUint> for u32 
                {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline] fn sub( self, mut other: BigUint ) -> BigUint {
                            if other.data.len() == 0 {
                                other.data.push( self );
                            } else {
                                sub2rev( &[self], &mut other.data[..] );
                            }
                            other.normalized()
                        }

                        #[inline] fn sub( self, mut other: BigUint ) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push( self as BigDigit );
                            } else {
                                sub2rev( &[self as BigDigit], &mut other.data[..] );
                            }
                            other.normalized()
                        }
                     );
                }
                impl Sub<u64> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn sub( mut self, other: u64 ) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<u64> for BigUint 
                {
                    cfg_digit!( 
                        #[inline] fn sub_assign( &mut self, other: u64 ) {
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                            sub2( &mut self.data[..], &[lo, hi] );
                            self.normalize();
                        }

                        #[inline] fn sub_assign( &mut self, other: u64 ) {
                            sub2( &mut self.data[..], &[other as BigDigit] );
                            self.normalize();
                        }
                     );
                }
                impl Sub<BigUint> for u64 
                {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline] fn sub( self, mut other: BigUint ) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push( 0 );
                            }
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( self );
                            sub2rev( &[lo, hi], &mut other.data[..] );
                            other.normalized()
                        }

                        #[inline] fn sub( self, mut other: BigUint ) -> BigUint {
                            if other.data.is_empty() {
                                other.data.push( self );
                            } else {
                                sub2rev( &[self], &mut other.data[..] );
                            }
                            other.normalized()
                        }
                     );
                }
                impl Sub<u128> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn sub( mut self, other: u128 ) -> BigUint {
                        self -= other;
                        self
                    }
                }
                impl SubAssign<u128> for BigUint 
                {
                    cfg_digit!( 
                        #[inline] fn sub_assign( &mut self, other: u128 ) {
                            let ( a, b, c, d ) = super::u32_from_u128( other );
                            sub2( &mut self.data[..], &[d, c, b, a] );
                            self.normalize();
                        }

                        #[inline] fn sub_assign( &mut self, other: u128 ) {
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( other );
                            sub2( &mut self.data[..], &[lo, hi] );
                            self.normalize();
                        }
                     );
                }
                impl Sub<BigUint> for u128 
                {
                    type Output = BigUint;

                    cfg_digit!( 
                        #[inline] fn sub( self, mut other: BigUint ) -> BigUint {
                            while other.data.len() < 4 {
                                other.data.push( 0 );
                            }
                            let ( a, b, c, d ) = super::u32_from_u128( self );
                            sub2rev( &[d, c, b, a], &mut other.data[..] );
                            other.normalized()
                        }

                        #[inline] fn sub( self, mut other: BigUint ) -> BigUint {
                            while other.data.len() < 2 {
                                other.data.push( 0 );
                            }
                            let ( hi, lo ) = ::num::big::digit::from_doublebigdigit( self );
                            sub2rev( &[lo, hi], &mut other.data[..] );
                            other.normalized()
                        }
                     );
                }
                impl CheckedSub for BigUint
                {
                    #[inline] fn checked_sub( &self, v:&BigUint ) -> Option<BigUint> {
                        match self.cmp( v ) {
                            Less => None,
                            Equal => Some( Self::ZERO ),
                            Greater => Some( self.sub( v ) ),
                        }
                    }
                }
            }
            pub mod bits
            {
                /*!
                */
                use ::
                {
                    ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign},
                    *,
                };
                use super::{BigUint, IntDigits};
                /*
                */
                forward_val_val_binop!( impl BitAnd for BigUint, bitand );
                forward_ref_val_binop_big!( impl BitAnd for BigUint, bitand );
               
                impl BitAnd<&BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn bitand( self, other:&BigUint ) -> BigUint {
                       
                        if self.data.len() <= other.data.len() {
                            self.clone() & other
                        } else {
                            other.clone() & self
                        }
                    }
                }
                forward_val_assign!( impl BitAndAssign for BigUint, bitand_assign );

                impl BitAnd<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn bitand( mut self, other:&BigUint ) -> BigUint {
                        self &= other;
                        self
                    }
                }
                impl BitAndAssign<&BigUint> for BigUint
                {
                    #[inline] fn bitand_assign( &mut self, other:&BigUint ) {
                        for ( ai, &bi ) in self.data.iter_mut().zip( other.data.iter() ) {
                            *ai &= bi;
                        }
                        self.data.truncate( other.data.len() );
                        self.normalize();
                    }
                }
                forward_all_binop_to_val_ref_commutative!( impl BitOr for BigUint, bitor );
                forward_val_assign!( impl BitOrAssign for BigUint, bitor_assign );

                impl BitOr<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    fn bitor( mut self, other:&BigUint ) -> BigUint {
                        self |= other;
                        self
                    }
                }
                impl BitOrAssign<&BigUint> for BigUint
                {
                    #[inline] fn bitor_assign( &mut self, other:&BigUint ) {
                        for ( ai, &bi ) in self.data.iter_mut().zip( other.data.iter() ) {
                            *ai |= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend( extra.iter().cloned() );
                        }
                    }
                }
                forward_all_binop_to_val_ref_commutative!( impl BitXor for BigUint, bitxor );
                forward_val_assign!( impl BitXorAssign for BigUint, bitxor_assign );

                impl BitXor<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    fn bitxor( mut self, other:&BigUint ) -> BigUint {
                        self ^= other;
                        self
                    }
                }
                impl BitXorAssign<&BigUint> for BigUint
                {
                    #[inline] fn bitxor_assign( &mut self, other:&BigUint ) {
                        for ( ai, &bi ) in self.data.iter_mut().zip( other.data.iter() ) {
                            *ai ^= bi;
                        }
                        if other.data.len() > self.data.len() {
                            let extra = &other.data[self.data.len()..];
                            self.data.extend( extra.iter().cloned() );
                        }
                        self.normalize();
                    }
                }
            }
            pub mod convert
            {
                /*!
                */
                use ::
                {
                    vec::{ Vec },
                    cmp::Ordering::{ Equal, Greater, Less },
                    convert::{ TryFrom },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit},
                            ParseBigIntError, TryFromBigIntError,
                        },
                        integers::{ Integer, Roots },
                        traits::
                        {
                            float::{ Float, FloatCore }, FromPrimitive, Num, One, PrimInt, ToPrimitive, Zero,
                        },
                    },
                    str::{ FromStr },
                    *,
                };
                use super::{biguint_from_vec, BigUint, ToBigUint};
                use super::addition::add2;
                use super::division::{div_rem_digit, FAST_DIV_WIDE};
                use super::multiplication::mac_with_carry;
                /*
                */
                fn fls<T: PrimInt>( v: T ) -> u8 {
                    mem::size_of::<T>() as u8 * 8 - v.leading_zeros() as u8
                }
                fn ilog2<T: PrimInt>( v: T ) -> u8 {
                    fls( v ) - 1
                }
                impl FromStr for BigUint
                {
                    type Err = ParseBigIntError;

                    #[inline] fn from_str( s:&str ) -> Result<BigUint, ParseBigIntError> { BigUint::from_str_radix( s, 10 ) }
                }
                
                pub( super ) fn from_bitwise_digits_le( v:&[u8], bits: u8 ) -> BigUint {
                    debug_assert!( !v.is_empty() && bits <= 8 && ::num::big::digit::BITS % bits == 0 );
                    debug_assert!( v.iter().all( |&c| BigDigit::from( c ) < ( 1 << bits ) ) );

                    let digits_per_big_digit = ::num::big::digit::BITS / bits;

                    let data = v
                        .chunks( digits_per_big_digit.into() )
                        .map( |chunk| {
                            chunk
                                .iter()
                                .rev()
                                .fold( 0, |acc, &c| ( acc << bits ) | BigDigit::from( c ) )
                        } )
                        .collect();

                    biguint_from_vec( data )
                }
               
               
                fn from_inexact_bitwise_digits_le( v:&[u8], bits: u8 ) -> BigUint {
                    debug_assert!( !v.is_empty() && bits <= 8 && ::num::big::digit::BITS % bits != 0 );
                    debug_assert!( v.iter().all( |&c| BigDigit::from( c ) < ( 1 << bits ) ) );

                    let total_bits = ( v.len() as u64 ).saturating_mul( bits.into() );
                    let big_digits = Integer::div_ceil( &total_bits, &::num::big::digit::BITS.into() )
                        .to_usize()
                        .unwrap_or( usize::MAX );
                    let mut data = Vec::with_capacity( big_digits );

                    let mut d = 0;
                    let mut dbits = 0;

                   
                   
                    for &c in v {
                        d |= BigDigit::from( c ) << dbits;
                        dbits += bits;

                        if dbits >= ::num::big::digit::BITS {
                            data.push( d );
                            dbits -= ::num::big::digit::BITS;
                           
                           
                            d = BigDigit::from( c ) >> ( bits - dbits );
                        }
                    }
                    if dbits > 0 {
                        debug_assert!( dbits < ::num::big::digit::BITS );
                        data.push( d as BigDigit );
                    }
                    biguint_from_vec( data )
                }
               
                fn from_radix_digits_be( v:&[u8], radix: u32 ) -> BigUint {
                    debug_assert!( !v.is_empty() && !radix.is_power_of_two() );
                    debug_assert!( v.iter().all( |&c| u32::from( c ) < radix ) );

                   
                            let big_digits = {
                        let radix_log2 = f64::from( radix ).log2();
                        let bits = radix_log2 * v.len() as f64;
                        ( bits / ::num::big::digit::BITS as f64 ).ceil()
                    };
                    
                    let mut data = Vec::with_capacity( big_digits.to_usize().unwrap_or( 0 ) );

                    let ( base, power ) = get_radix_base( radix );
                    let radix = radix as BigDigit;

                    let r = v.len() % power;
                    let i = if r == 0 { power } else { r };
                    let ( head, tail ) = v.split_at( i );

                    let first = head
                        .iter()
                        .fold( 0, |acc, &d| acc * radix + BigDigit::from( d ) );
                    data.push( first );

                    debug_assert!( tail.len() % power == 0 );
                    for chunk in tail.chunks( power ) {
                        if data.last() != Some( &0 ) {
                            data.push( 0 );
                        }
                        let mut carry = 0;
                        for d in data.iter_mut() {
                            *d = mac_with_carry( 0, *d, base, &mut carry );
                        }
                        debug_assert!( carry == 0 );

                        let n = chunk
                            .iter()
                            .fold( 0, |acc, &d| acc * radix + BigDigit::from( d ) );
                        add2( &mut data, &[n] );
                    }
                    biguint_from_vec( data )
                }
                pub( super ) fn from_radix_be( buf:&[u8], radix: u32 ) -> Option<BigUint> {
                    assert!( 
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                     );

                    if buf.is_empty() {
                        return Some( BigUint::ZERO );
                    }
                    if radix != 256 && buf.iter().any( |&b| b >= radix as u8 ) {
                        return None;
                    }
                    let res = if radix.is_power_of_two() {
                       
                        let bits = ilog2( radix );
                        let mut v = Vec::from( buf );
                        v.reverse();
                        if ::num::big::digit::BITS % bits == 0 {
                            from_bitwise_digits_le( &v, bits )
                        } else {
                            from_inexact_bitwise_digits_le( &v, bits )
                        }
                    } else {
                        from_radix_digits_be( buf, radix )
                    };

                    Some( res )
                }
                pub( super ) fn from_radix_le( buf:&[u8], radix: u32 ) -> Option<BigUint> {
                    assert!( 
                        2 <= radix && radix <= 256,
                        "The radix must be within 2...256"
                     );

                    if buf.is_empty() {
                        return Some( BigUint::ZERO );
                    }
                    if radix != 256 && buf.iter().any( |&b| b >= radix as u8 ) {
                        return None;
                    }
                    let res = if radix.is_power_of_two() {
                       
                        let bits = ilog2( radix );
                        if ::num::big::digit::BITS % bits == 0 {
                            from_bitwise_digits_le( buf, bits )
                        } else {
                            from_inexact_bitwise_digits_le( buf, bits )
                        }
                    } else {
                        let mut v = Vec::from( buf );
                        v.reverse();
                        from_radix_digits_be( &v, radix )
                    };

                    Some( res )
                }
                impl Num for BigUint
                {
                    type FromStrRadixErr = ParseBigIntError;

                    fn from_str_radix( s:&str, radix: u32 ) -> Result<BigUint, ParseBigIntError> {
                        assert!( 2 <= radix && radix <= 36, "The radix must be within 2...36" );
                        let mut s = s;
                        if let Some( tail ) = s.strip_prefix( '+' ) {
                            if !tail.starts_with( '+' ) {
                                s = tail
                            }
                        }
                        if s.is_empty() {
                            return Err( ParseBigIntError::empty() );
                        }
                        if s.starts_with( '_' ) {
                           
                            return Err( ParseBigIntError::invalid() );
                        }
                       
                        let mut v = Vec::with_capacity( s.len() );
                        for b in s.bytes() {
                            let d = match b {
                                b'0'..=b'9' => b - b'0',
                                b'a'..=b'z' => b - b'a' + 10,
                                b'A'..=b'Z' => b - b'A' + 10,
                                b'_' => continue,
                                _ => u8::MAX,
                            };
                            if d < radix as u8 {
                                v.push( d );
                            } else {
                                return Err( ParseBigIntError::invalid() );
                            }
                        }
                        let res = if radix.is_power_of_two() {
                           
                            let bits = ilog2( radix );
                            v.reverse();
                            if ::num::big::digit::BITS % bits == 0 {
                                from_bitwise_digits_le( &v, bits )
                            } else {
                                from_inexact_bitwise_digits_le( &v, bits )
                            }
                        } else {
                            from_radix_digits_be( &v, radix )
                        };
                        Ok( res )
                    }
                }
                fn high_bits_to_u64( v:&BigUint ) -> u64 {
                    match v.data.len() {
                        0 => 0,
                        1 => {
                           
                            #[allow( clippy::useless_conversion )]
                            let v0 = u64::from( v.data[0] );
                            v0
                        }
                        _ => {
                            let mut bits = v.bits();
                            let mut ret = 0u64;
                            let mut ret_bits = 0;

                            for d in v.data.iter().rev() {
                                let digit_bits = ( bits - 1 ) % u64::from( ::num::big::digit::BITS ) + 1;
                                let bits_want = Ord::min( 64 - ret_bits, digit_bits );

                                if bits_want != 0 {
                                    if bits_want != 64 {
                                        ret <<= bits_want;
                                    }
                                   
                                    #[allow( clippy::useless_conversion )]
                                    let d0 = u64::from( *d ) >> ( digit_bits - bits_want );
                                    ret |= d0;
                                }
                               
                               
                               
                                //
                               

                                if digit_bits - bits_want != 0 {
                                   
                                    #[allow( clippy::useless_conversion )]
                                    let masked = u64::from( *d ) << ( 64 - ( digit_bits - bits_want ) as u32 );
                                    ret |= ( masked != 0 ) as u64;
                                }
                                ret_bits += bits_want;
                                bits -= bits_want;
                            }
                            ret
                        }
                    }
                }
                impl ToPrimitive for BigUint
                {
                    #[inline] fn to_i64( &self ) -> Option<i64> { self.to_u64().as_ref().and_then( u64::to_i64 ) }
                    #[inline] fn to_i128( &self ) -> Option<i128> { self.to_u128().as_ref().and_then( u128::to_i128 ) }
                    #[allow( clippy::useless_conversion )]
                    #[inline] fn to_u64( &self ) -> Option<u64>
                    {
                        let mut ret: u64 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 64 {
                                return None;
                            }
                           
                            ret += u64::from( *i ) << bits;
                            bits += ::num::big::digit::BITS;
                        }
                        Some( ret )
                    }
                    #[inline] fn to_u128( &self ) -> Option<u128>
                    {
                        let mut ret: u128 = 0;
                        let mut bits = 0;

                        for i in self.data.iter() {
                            if bits >= 128 {
                                return None;
                            }
                            ret |= u128::from( *i ) << bits;
                            bits += ::num::big::digit::BITS;
                        }
                        Some( ret )
                    }
                    #[inline] fn to_f32( &self ) -> Option<f32>
                    {
                        let mantissa = high_bits_to_u64( self );
                        let exponent = self.bits() - u64::from( fls( mantissa ) );

                        if exponent > f32::MAX_EXP as u64 {
                            Some( f32::INFINITY )
                        } else {
                            Some( ( mantissa as f32 ) * 2.0f32.powi( exponent as i32 ) )
                        }
                    }
                    #[inline] fn to_f64( &self ) -> Option<f64>
                    {
                        let mantissa = high_bits_to_u64( self );
                        let exponent = self.bits() - u64::from( fls( mantissa ) );

                        if exponent > f64::MAX_EXP as u64 {
                            Some( f64::INFINITY )
                        } else {
                            Some( ( mantissa as f64 ) * 2.0f64.powi( exponent as i32 ) )
                        }
                    }
                }
                macro_rules! impl_try_from_biguint {
                    ( $T:ty, $to_ty:path ) => {
                        impl TryFrom<&BigUint> for $T {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from( value:&BigUint ) -> Result<$T, TryFromBigIntError<()>> { $to_ty( value ).ok_or( TryFromBigIntError::new( () ) ) }
                        }
                        impl TryFrom<BigUint> for $T {
                            type Error = TryFromBigIntError<BigUint>;

                            #[inline]
                            fn try_from( value: BigUint ) -> Result<$T, TryFromBigIntError<BigUint>> { <$T>::try_from( &value ).map_err( |_| TryFromBigIntError::new( value ) ) }
                        }
                    };
                }
                impl_try_from_biguint!( u8, ToPrimitive::to_u8 );
                impl_try_from_biguint!( u16, ToPrimitive::to_u16 );
                impl_try_from_biguint!( u32, ToPrimitive::to_u32 );
                impl_try_from_biguint!( u64, ToPrimitive::to_u64 );
                impl_try_from_biguint!( usize, ToPrimitive::to_usize );
                impl_try_from_biguint!( u128, ToPrimitive::to_u128 );

                impl_try_from_biguint!( i8, ToPrimitive::to_i8 );
                impl_try_from_biguint!( i16, ToPrimitive::to_i16 );
                impl_try_from_biguint!( i32, ToPrimitive::to_i32 );
                impl_try_from_biguint!( i64, ToPrimitive::to_i64 );
                impl_try_from_biguint!( isize, ToPrimitive::to_isize );
                impl_try_from_biguint!( i128, ToPrimitive::to_i128 );

                impl FromPrimitive for BigUint
                {
                    #[inline] fn from_i64( n: i64 ) -> Option<BigUint> {
                        if n >= 0 {
                            Some( BigUint::from( n as u64 ) )
                        } else {
                            None
                        }
                    }
                    #[inline] fn from_i128( n: i128 ) -> Option<BigUint> {
                        if n >= 0 {
                            Some( BigUint::from( n as u128 ) )
                        } else {
                            None
                        }
                    }
                    #[inline] fn from_u64( n: u64 ) -> Option<BigUint> { Some( BigUint::from( n ) ) }
                    #[inline] fn from_u128( n: u128 ) -> Option<BigUint> { Some( BigUint::from( n ) ) }
                    #[inline] fn from_f64( mut n: f64 ) -> Option<BigUint> {
                       
                        if !n.is_finite() {
                            return None;
                        }
                       
                        n = n.trunc();

                       
                        if n.is_zero() {
                            return Some( Self::ZERO );
                        }
                        let ( mantissa, exponent, sign ) = Float::integer_decode( n  );

                        if sign == -1 {
                            return None;
                        }
                        let mut ret = BigUint::from( mantissa );
                        match exponent.cmp( &0 ) {
                            Greater => ret <<= exponent as usize,
                            Equal => {}
                            Less => ret >>= ( -exponent ) as usize,
                        }
                        Some( ret )
                    }
                }
                impl From<u64> for BigUint
                {
                    #[inline] fn from( mut n: u64 ) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push( n as BigDigit );
                           
                            n = ( n >> 1 ) >> ( ::num::big::digit::BITS - 1 );
                        }
                        ret
                    }
                }
                impl From<u128> for BigUint
                {
                    #[inline] fn from( mut n: u128 ) -> Self {
                        let mut ret: BigUint = Self::ZERO;

                        while n != 0 {
                            ret.data.push( n as BigDigit );
                            n >>= ::num::big::digit::BITS;
                        }
                        ret
                    }
                }
                macro_rules! impl_biguint_from_uint {
                    ( $T:ty ) => {
                        impl From<$T> for BigUint {
                            #[inline]
                            fn from( n: $T ) -> Self {
                                BigUint::from( n as u64 )
                            }
                        }
                    };
                }
                impl_biguint_from_uint!( u8 );
                impl_biguint_from_uint!( u16 );
                impl_biguint_from_uint!( u32 );
                impl_biguint_from_uint!( usize );

                macro_rules! impl_biguint_try_from_int {
                    ( $T:ty, $from_ty:path ) => {
                        impl TryFrom<$T> for BigUint {
                            type Error = TryFromBigIntError<()>;

                            #[inline]
                            fn try_from( value: $T ) -> Result<BigUint, TryFromBigIntError<()>> { $from_ty( value ).ok_or( TryFromBigIntError::new( () ) ) }
                        }
                    };
                }
                impl_biguint_try_from_int!( i8, FromPrimitive::from_i8 );
                impl_biguint_try_from_int!( i16, FromPrimitive::from_i16 );
                impl_biguint_try_from_int!( i32, FromPrimitive::from_i32 );
                impl_biguint_try_from_int!( i64, FromPrimitive::from_i64 );
                impl_biguint_try_from_int!( isize, FromPrimitive::from_isize );
                impl_biguint_try_from_int!( i128, FromPrimitive::from_i128 );

                impl ToBigUint for BigUint
                {
                    #[inline] fn to_biguint( &self ) -> Option<BigUint> { Some( self.clone() ) }
                }
                macro_rules! impl_to_biguint {
                    ( $T:ty, $from_ty:path ) => {
                        impl ToBigUint for $T {
                            #[inline]
                            fn to_biguint( &self ) -> Option<BigUint> { $from_ty( *self ) }
                        }
                    };
                }
                impl_to_biguint!( isize, FromPrimitive::from_isize );
                impl_to_biguint!( i8, FromPrimitive::from_i8 );
                impl_to_biguint!( i16, FromPrimitive::from_i16 );
                impl_to_biguint!( i32, FromPrimitive::from_i32 );
                impl_to_biguint!( i64, FromPrimitive::from_i64 );
                impl_to_biguint!( i128, FromPrimitive::from_i128 );

                impl_to_biguint!( usize, FromPrimitive::from_usize );
                impl_to_biguint!( u8, FromPrimitive::from_u8 );
                impl_to_biguint!( u16, FromPrimitive::from_u16 );
                impl_to_biguint!( u32, FromPrimitive::from_u32 );
                impl_to_biguint!( u64, FromPrimitive::from_u64 );
                impl_to_biguint!( u128, FromPrimitive::from_u128 );

                impl_to_biguint!( f32, FromPrimitive::from_f32 );
                impl_to_biguint!( f64, FromPrimitive::from_f64 );

                impl From<bool> for BigUint
                {
                    fn from( x: bool ) -> Self {
                        if x {
                            One::one()
                        } else {
                            Self::ZERO
                        }
                    }
                }
               
                pub( super ) fn to_bitwise_digits_le( u:&BigUint, bits: u8 ) -> Vec<u8> {
                    debug_assert!( !u.is_zero() && bits <= 8 && ::num::big::digit::BITS % bits == 0 );

                    let last_i = u.data.len() - 1;
                    let mask: BigDigit = ( 1 << bits ) - 1;
                    let digits_per_big_digit = ::num::big::digit::BITS / bits;
                    let digits = Integer::div_ceil( &u.bits(), &u64::from( bits ) )
                        .to_usize()
                        .unwrap_or( usize::MAX );
                    let mut res = Vec::with_capacity( digits );

                    for mut r in u.data[..last_i].iter().cloned() {
                        for _ in 0..digits_per_big_digit {
                            res.push( ( r & mask ) as u8 );
                            r >>= bits;
                        }
                    }
                    let mut r = u.data[last_i];
                    while r != 0 {
                        res.push( ( r & mask ) as u8 );
                        r >>= bits;
                    }
                    res
                }
               
                fn to_inexact_bitwise_digits_le( u:&BigUint, bits: u8 ) -> Vec<u8> {
                    debug_assert!( !u.is_zero() && bits <= 8 && ::num::big::digit::BITS % bits != 0 );

                    let mask: BigDigit = ( 1 << bits ) - 1;
                    let digits = Integer::div_ceil( &u.bits(), &u64::from( bits ) )
                        .to_usize()
                        .unwrap_or( usize::MAX );
                    let mut res = Vec::with_capacity( digits );

                    let mut r = 0;
                    let mut rbits = 0;

                    for c in &u.data {
                        r |= *c << rbits;
                        rbits += ::num::big::digit::BITS;

                        while rbits >= bits {
                            res.push( ( r & mask ) as u8 );
                            r >>= bits;

                           
                            if rbits > ::num::big::digit::BITS {
                                r = *c >> ( ::num::big::digit::BITS - ( rbits - bits ) );
                            }
                            rbits -= bits;
                        }
                    }
                    if rbits != 0 {
                        res.push( r as u8 );
                    }
                    while let Some( &0 ) = res.last() {
                        res.pop();
                    }
                    res
                }
               
                #[inline( always )]
                pub( super ) fn to_radix_digits_le( u:&BigUint, radix: u32 ) -> Vec<u8> {
                    debug_assert!( !u.is_zero() && !radix.is_power_of_two() );

                            let radix_digits = {
                        let radix_log2 = f64::from( radix ).log2();
                        ( ( u.bits() as f64 ) / radix_log2 ).ceil()
                    };
                    
                    let mut res = Vec::with_capacity( radix_digits.to_usize().unwrap_or( 0 ) );

                    let mut digits = u.clone();

                   
                   
                    let ( base, power ) = if FAST_DIV_WIDE {
                        get_radix_base( radix )
                    } else {
                        get_half_radix_base( radix )
                    };
                    let radix = radix as BigDigit;

                   
                   
                   
                   
                    if digits.data.len() >= 64 {
                        let mut big_base = BigUint::from( base );
                        let mut big_power = 1usize;

                       
                        let target_len = digits.data.len().sqrt();
                        while big_base.data.len() < target_len {
                            big_base = &big_base * &big_base;
                            big_power *= 2;
                        }
                       
                        while digits > big_base {
                           
                            let ( q, mut big_r ) = digits.div_rem( &big_base );
                            digits = q;

                           
                            for _ in 0..big_power {
                                let ( q, mut r ) = div_rem_digit( big_r, base );
                                big_r = q;
                                for _ in 0..power {
                                    res.push( ( r % radix ) as u8 );
                                    r /= radix;
                                }
                            }
                        }
                    }
                    while digits.data.len() > 1 {
                        let ( q, mut r ) = div_rem_digit( digits, base );
                        for _ in 0..power {
                            res.push( ( r % radix ) as u8 );
                            r /= radix;
                        }
                        digits = q;
                    }
                    let mut r = digits.data[0];
                    while r != 0 {
                        res.push( ( r % radix ) as u8 );
                        r /= radix;
                    }
                    res
                }
                pub( super ) fn to_radix_le( u:&BigUint, radix: u32 ) -> Vec<u8> {
                    if u.is_zero() {
                        vec![0]
                    } else if radix.is_power_of_two() {
                       
                        let bits = ilog2( radix );
                        if ::num::big::digit::BITS % bits == 0 {
                            to_bitwise_digits_le( u, bits )
                        } else {
                            to_inexact_bitwise_digits_le( u, bits )
                        }
                    } else if radix == 10 {
                       
                       
                        to_radix_digits_le( u, 10 )
                    } else {
                        to_radix_digits_le( u, radix )
                    }
                }

                pub fn to_str_radix_reversed( u:&BigUint, radix: u32 ) -> Vec<u8> {
                    assert!( 2 <= radix && radix <= 36, "The radix must be within 2...36" );

                    if u.is_zero() {
                        return vec![b'0'];
                    }
                    let mut res = to_radix_le( u, radix );

                   
                    for r in &mut res {
                        debug_assert!( u32::from( *r ) < radix );
                        if *r < 10 {
                            *r += b'0';
                        } else {
                            *r += b'a' - 10;
                        }
                    }
                    res
                }

                #[inline] fn get_radix_base( radix: u32 ) -> ( BigDigit, usize ) {
                    static BASES: [( BigDigit, usize ); 257] = generate_radix_bases( ::num::big::digit::MAX );
                    debug_assert!( !radix.is_power_of_two() );
                    debug_assert!( ( 3..256 ).contains( &radix ) );
                    BASES[radix as usize]
                }

                #[inline] fn get_half_radix_base( radix: u32 ) -> ( BigDigit, usize ) {
                    static BASES: [( BigDigit, usize ); 257] = generate_radix_bases( ::num::big::digit::HALF );
                    debug_assert!( !radix.is_power_of_two() );
                    debug_assert!( ( 3..256 ).contains( &radix ) );
                    BASES[radix as usize]
                }
                const fn generate_radix_bases( max: BigDigit ) -> [( BigDigit, usize ); 257] {
                    let mut bases = [( 0, 0 ); 257];

                    let mut radix: BigDigit = 3;
                    while radix < 256 {
                        if !radix.is_power_of_two() {
                            let mut power = 1;
                            let mut base = radix;

                            while let Some( b ) = base.checked_mul( radix ) {
                                if b > max {
                                    break;
                                }
                                base = b;
                                power += 1;
                            }
                            bases[radix as usize] = ( base, power )
                        }
                        radix += 1;
                    }
                    bases
                }
            } pub use self::convert::to_str_radix_reversed;

            pub mod iter
            {
                /*!
                */
                use ::
                {
                    iter::{ FusedIterator },
                    *,
                };
                /*
                    use ::iter::FusedIterator;
                */
                cfg_digit!
                (
                    pub struct U32Digits<'a> { it: ::slice::Iter<'a, u32>, }
                    
                    pub struct U32Digits<'a> {
                        data:&'a [u64],
                        next_is_lo: bool,
                        last_hi_is_zero: bool,
                    }
                 );

                cfg_digit!
                ( 
                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub( super ) fn new( data:&'a [u32] ) -> Self {
                                Self { it: data.iter() }
                            }
                        }
                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next( &mut self ) -> Option<u32> { self.it.next().cloned() }
                            #[inline]
                            fn size_hint( &self ) -> ( usize, Option<usize> ) { self.it.size_hint() }
                            #[inline]
                            fn nth( &mut self, n: usize ) -> Option<u32> { self.it.nth( n ).cloned() }
                            #[inline]
                            fn last( self ) -> Option<u32> { self.it.last().cloned() }
                            #[inline]
                            fn count( self ) -> usize {
                                self.it.count()
                            }
                        }
                        impl DoubleEndedIterator for U32Digits<'_> 
                        {
                            fn next_back( &mut self ) -> Option<Self::Item> { self.it.next_back().cloned() }
                        }

                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len( &self ) -> usize { self.it.len() }
                        }
                    };

                    const _: () = {
                        impl<'a> U32Digits<'a> {
                            #[inline]
                            pub( super ) fn new( data:&'a [u64] ) -> Self {
                                let last_hi_is_zero = data
                                    .last()
                                    .map( |&last| {
                                        let last_hi = ( last >> 32 ) as u32;
                                        last_hi == 0
                                    } )
                                    .unwrap_or( false );
                                U32Digits {
                                    data,
                                    next_is_lo: true,
                                    last_hi_is_zero,
                                }
                            }
                        }
                        impl Iterator for U32Digits<'_> {
                            type Item = u32;
                            #[inline]
                            fn next( &mut self ) -> Option<u32> {
                                match self.data.split_first() {
                                    Some( ( &first, data ) ) => {
                                        let next_is_lo = self.next_is_lo;
                                        self.next_is_lo = !next_is_lo;
                                        if next_is_lo {
                                            Some( first as u32 )
                                        } else {
                                            self.data = data;
                                            if data.is_empty() && self.last_hi_is_zero {
                                                self.last_hi_is_zero = false;
                                                None
                                            } else {
                                                Some( ( first >> 32 ) as u32 )
                                            }
                                        }
                                    }
                                    None => None,
                                }
                            }
                            #[inline]
                            fn size_hint( &self ) -> ( usize, Option<usize> ) {
                                let len = self.len();
                                ( len, Some( len ) )
                            }
                            #[inline]
                            fn last( self ) -> Option<u32> {
                                self.data.last().map( |&last| {
                                    if self.last_hi_is_zero {
                                        last as u32
                                    } else {
                                        ( last >> 32 ) as u32
                                    }
                                } )
                            }
                            #[inline]
                            fn count( self ) -> usize {
                                self.len()
                            }
                        }
                        impl DoubleEndedIterator for U32Digits<'_> {
                            fn next_back( &mut self ) -> Option<Self::Item> {
                                match self.data.split_last() {
                                    Some( ( &last, data ) ) => {
                                        let last_is_lo = self.last_hi_is_zero;
                                        self.last_hi_is_zero = !last_is_lo;
                                        if last_is_lo {
                                            self.data = data;
                                            if data.is_empty() && !self.next_is_lo {
                                                self.next_is_lo = true;
                                                None
                                            } else {
                                                Some( last as u32 )
                                            }
                                        } else {
                                            Some( ( last >> 32 ) as u32 )
                                        }
                                    }
                                    None => None,
                                }
                            }
                        }
                        impl ExactSizeIterator for U32Digits<'_> {
                            #[inline]
                            fn len( &self ) -> usize {
                                self.data.len() * 2
                                    - usize::from( self.last_hi_is_zero )
                                    - usize::from( !self.next_is_lo )
                            }
                        }
                    };
                 );

                impl FusedIterator for U32Digits<'_> {}
                cfg_digit!
                (
                    pub struct U64Digits<'a> { it: ::slice::Chunks<'a, u32>, }
                    
                    pub struct U64Digits<'a> { it: ::slice::Iter<'a, u64>, }
                 );

                cfg_digit!
                ( 
                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub( super ) fn new( data:&'a [u32] ) -> Self {
                                U64Digits { it: data.chunks( 2 ) }
                            }
                        }
                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next( &mut self ) -> Option<u64> { self.it.next().map( super::u32_chunk_to_u64 ) }
                            #[inline]
                            fn size_hint( &self ) -> ( usize, Option<usize> ) {
                                let len = self.len();
                                ( len, Some( len ) )
                            }
                            #[inline]
                            fn last( self ) -> Option<u64> { self.it.last().map( super::u32_chunk_to_u64 ) }
                            #[inline]
                            fn count( self ) -> usize {
                                self.len()
                            }
                        }

                        impl DoubleEndedIterator for U64Digits<'_> 
                        {
                            fn next_back( &mut self ) -> Option<Self::Item> { self.it.next_back().map( super::u32_chunk_to_u64 ) }
                        }
                    };

                    const _: () = {
                        impl<'a> U64Digits<'a> {
                            #[inline]
                            pub( super ) fn new( data:&'a [u64] ) -> Self {
                                Self { it: data.iter() }
                            }
                        }
                        impl Iterator for U64Digits<'_> {
                            type Item = u64;
                            #[inline]
                            fn next( &mut self ) -> Option<u64> { self.it.next().cloned() }
                            #[inline]
                            fn size_hint( &self ) -> ( usize, Option<usize> ) { self.it.size_hint() }
                            #[inline]
                            fn nth( &mut self, n: usize ) -> Option<u64> { self.it.nth( n ).cloned() }
                            #[inline]
                            fn last( self ) -> Option<u64> { self.it.last().cloned() }
                            #[inline]
                            fn count( self ) -> usize {
                                self.it.count()
                            }
                        }

                        impl DoubleEndedIterator for U64Digits<'_> 
                        {
                            fn next_back( &mut self ) -> Option<Self::Item> { self.it.next_back().cloned() }
                        }
                    };
                 );

                impl ExactSizeIterator for U64Digits<'_>
                {
                    #[inline] fn len( &self ) -> usize { self.it.len() }
                }
                impl FusedIterator for U64Digits<'_> {}
            }
            pub mod monty
            {
                /*!
                */
                use ::
                {
                    vec::{ Vec },
                    ops::{ Shl },
                    num::
                    {
                        big::
                        {
                            digit::{self, BigDigit, DoubleBigDigit},
                            uint::BigUint,
                        },
                        traits::One,
                    },
                    *,
                };
                /*
                */
                struct MontyReducer {
                    n0inv: BigDigit,
                }
               
               
                fn inv_mod_alt( b: BigDigit ) -> BigDigit {
                    assert_ne!( b & 1, 0 );

                    let mut k0 = BigDigit::wrapping_sub( 2, b );
                    let mut t = b - 1;
                    let mut i = 1;
                    while i < ::num::big::digit::BITS {
                        t = t.wrapping_mul( t );
                        k0 = k0.wrapping_mul( t + 1 );

                        i <<= 1;
                    }
                    debug_assert_eq!( k0.wrapping_mul( b ), 1 );
                    k0.wrapping_neg()
                }
                impl MontyReducer
                {
                    fn new( n:&BigUint ) -> Self {
                        let n0inv = inv_mod_alt( n.data[0] );
                        MontyReducer { n0inv }
                    }
                }
                #[allow( clippy::many_single_char_names )]
                fn montgomery( x:&BigUint, y:&BigUint, m:&BigUint, k: BigDigit, n: usize ) -> BigUint {
                   
                   
                   
                   
                    assert!( 
                        x.data.len() == n && y.data.len() == n && m.data.len() == n,
                        "{:?} {:?} {:?} {}",
                        x,
                        y,
                        m,
                        n
                     );

                    let mut z = BigUint::ZERO;
                    z.data.resize( n * 2, 0 );

                    let mut c: BigDigit = 0;
                    for i in 0..n {
                        let c2 = add_mul_vvw( &mut z.data[i..n + i], &x.data, y.data[i] );
                        let t = z.data[i].wrapping_mul( k );
                        let c3 = add_mul_vvw( &mut z.data[i..n + i], &m.data, t );
                        let cx = c.wrapping_add( c2 );
                        let cy = cx.wrapping_add( c3 );
                        z.data[n + i] = cy;
                        if cx < c2 || cy < c3 {
                            c = 1;
                        } else {
                            c = 0;
                        }
                    }
                    if c == 0 {
                        z.data = z.data[n..].to_vec();
                    } else {
                        {
                            let ( first, second ) = z.data.split_at_mut( n  );
                            sub_vv( first, second, &m.data );
                        }
                        z.data = z.data[..n].to_vec();
                    }
                    z
                }
                #[inline( always )] fn add_mul_vvw( z:&mut [BigDigit], x:&[BigDigit], y: BigDigit ) -> BigDigit {
                    let mut c = 0;
                    for ( zi, xi ) in z.iter_mut().zip( x.iter() ) {
                        let ( z1, z0 ) = mul_add_www( *xi, y, *zi );
                        let ( c_, zi_ ) = add_ww( z0, c, 0 );
                        *zi = zi_;
                        c = c_ + z1;
                    }
                    c
                }

                #[inline( always )] fn sub_vv( z:&mut [BigDigit], x:&[BigDigit], y:&[BigDigit] ) -> BigDigit {
                    let mut c = 0;
                    for ( i, ( xi, yi ) ) in x.iter().zip( y.iter() ).enumerate().take( z.len() ) {
                        let zi = xi.wrapping_sub( *yi ).wrapping_sub( c );
                        z[i] = zi;
                       
                        c = (( yi & !xi ) | ( ( yi | !xi ) & zi ) ) >> ( ::num::big::digit::BITS - 1 )
                    }
                    c
                }

                #[inline( always )] fn add_ww( x: BigDigit, y: BigDigit, c: BigDigit ) -> ( BigDigit, BigDigit ) {
                    let yc = y.wrapping_add( c );
                    let z0 = x.wrapping_add( yc );
                    let z1 = if z0 < x || yc < y { 1 } else { 0 };

                    ( z1, z0 )
                }

                #[inline( always )] fn mul_add_www( x: BigDigit, y: BigDigit, c: BigDigit ) -> ( BigDigit, BigDigit ) {
                    let z = x as DoubleBigDigit * y as DoubleBigDigit + c as DoubleBigDigit;
                    ( ( z >> ::num::big::digit::BITS ) as BigDigit, z as BigDigit )
                }

                #[allow( clippy::many_single_char_names )]
                pub( super ) fn monty_modpow( x:&BigUint, y:&BigUint, m:&BigUint ) -> BigUint {
                    assert!( m.data[0] & 1 == 1 );
                    let mr = MontyReducer::new( m );
                    let num_words = m.data.len();

                    let mut x = x.clone();

                   
                   
                    if x.data.len() > num_words {
                        x %= m;
                       
                    }
                    if x.data.len() < num_words {
                        x.data.resize( num_words, 0 );
                    }
                   
                    let mut rr = BigUint::one();
                    rr = ( rr.shl( 2 * num_words as u64 * u64::from( ::num::big::digit::BITS ) ) ) % m;
                    if rr.data.len() < num_words {
                        rr.data.resize( num_words, 0 );
                    }
                   
                    let mut one = BigUint::one();
                    one.data.resize( num_words, 0 );

                    let n = 4;
                   
                    let mut powers = Vec::with_capacity( 1 << n );
                    powers.push( montgomery( &one, &rr, m, mr.n0inv, num_words ) );
                    powers.push( montgomery( &x, &rr, m, mr.n0inv, num_words ) );
                    for i in 2..1 << n {
                        let r = montgomery( &powers[i - 1], &powers[1], m, mr.n0inv, num_words );
                        powers.push( r );
                    }
                   
                    let mut z = powers[0].clone();
                    z.data.resize( num_words, 0 );
                    let mut zz = BigUint::ZERO;
                    zz.data.resize( num_words, 0 );

                   
                    for i in ( 0..y.data.len() ).rev() {
                        let mut yi = y.data[i];
                        let mut j = 0;
                        while j < ::num::big::digit::BITS {
                            if i != y.data.len() - 1 || j != 0 {
                                zz = montgomery( &z, &z, m, mr.n0inv, num_words );
                                z = montgomery( &zz, &zz, m, mr.n0inv, num_words );
                                zz = montgomery( &z, &z, m, mr.n0inv, num_words );
                                z = montgomery( &zz, &zz, m, mr.n0inv, num_words );
                            }
                            zz = montgomery( 
                                &z,
                                &powers[( yi >> ( ::num::big::digit::BITS - n ) ) as usize],
                                m,
                                mr.n0inv,
                                num_words,
                             );
                            mem::swap( &mut z, &mut zz );
                            yi <<= n;
                            j += n;
                        }
                    }
                   
                    zz = montgomery( &z, &one, m, mr.n0inv, num_words );

                    zz.normalize();
                   
                   
                    if zz >= *m {
                       
                       
                       
                       
                       
                       
                       
                        zz -= m;
                        if zz >= *m {
                            zz %= m;
                        }
                    }
                    zz.normalize();
                    zz
                }
            } pub use self::iter::{U32Digits, U64Digits};

            pub mod power
            {
                /*!
                */
                use ::
                {
                    num::
                    {
                        big::digit::{self, BigDigit},
                        integers::Integer,
                        traits::{One, Pow, ToPrimitive, Zero},
                    },
                    *,
                };
                use super::monty::monty_modpow;
                use super::BigUint;
                /*
                */
                impl Pow<&BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow( self, exp:&BigUint ) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            Self::ZERO
                        } else if let Some( exp ) = exp.to_u64() {
                            self.pow( exp )
                        } else if let Some( exp ) = exp.to_u128() {
                            self.pow( exp )
                        } else {
                           
                           
                            panic!( "memory overflow" )
                        }
                    }
                }
                impl Pow<BigUint> for BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow( self, exp: BigUint ) -> BigUint {
                        Pow::pow( self, &exp )
                    }
                }
                impl Pow<&BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow( self, exp:&BigUint ) -> BigUint {
                        if self.is_one() || exp.is_zero() {
                            BigUint::one()
                        } else if self.is_zero() {
                            BigUint::ZERO
                        } else {
                            self.clone().pow( exp )
                        }
                    }
                }
                impl Pow<BigUint> for &BigUint
                {
                    type Output = BigUint;

                    #[inline] fn pow( self, exp: BigUint ) -> BigUint {
                        Pow::pow( self, &exp )
                    }
                }
                macro_rules! pow_impl 
                {
                    ( $T:ty ) => {
                        impl Pow<$T> for BigUint {
                            type Output = BigUint;

                            fn pow( self, mut exp: $T ) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                let mut base = self;

                                while exp & 1 == 0 {
                                    base = &base * &base;
                                    exp >>= 1;
                                }
                                if exp == 1 {
                                    return base;
                                }
                                let mut acc = base.clone();
                                while exp > 1 {
                                    exp >>= 1;
                                    base = &base * &base;
                                    if exp & 1 == 1 {
                                        acc *= &base;
                                    }
                                }
                                acc
                            }
                        }
                        impl Pow<&$T> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow( self, exp:&$T ) -> BigUint {
                                Pow::pow( self, *exp )
                            }
                        }
                        impl Pow<$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow( self, exp: $T ) -> BigUint {
                                if exp == 0 {
                                    return BigUint::one();
                                }
                                Pow::pow( self.clone(), exp )
                            }
                        }
                        impl Pow<&$T> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn pow( self, exp:&$T ) -> BigUint {
                                Pow::pow( self, *exp )
                            }
                        }
                    };
                }
                pow_impl!( u8 );
                pow_impl!( u16 );
                pow_impl!( u32 );
                pow_impl!( u64 );
                pow_impl!( usize );
                pow_impl!( u128 );

                pub fn modpow( x:&BigUint, exponent:&BigUint, modulus:&BigUint ) -> BigUint 
                {
                    assert!( 
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                     );

                    if modulus.is_odd() {
                       
                        monty_modpow( x, exponent, modulus )
                    } else {
                       
                        plain_modpow( x, &exponent.data, modulus )
                    }
                }

                pub fn plain_modpow( base:&BigUint, exp_data:&[BigDigit], modulus:&BigUint ) -> BigUint 
                {
                    assert!( 
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                     );

                    let i = match exp_data.iter().position( |&r| r != 0 ) {
                        None => return BigUint::one(),
                        Some( i ) => i,
                    };

                    let mut base = base % modulus;
                    for _ in 0..i {
                        for _ in 0..::num::big::digit::BITS {
                            base = &base * &base % modulus;
                        }
                    }
                    let mut r = exp_data[i];
                    let mut b = 0u8;
                    while r.is_even() {
                        base = &base * &base % modulus;
                        r >>= 1;
                        b += 1;
                    }
                    let mut exp_iter = exp_data[i + 1..].iter();
                    if exp_iter.len() == 0 && r.is_one() {
                        return base;
                    }
                    let mut acc = base.clone();
                    r >>= 1;
                    b += 1;

                    {
                        let mut unit = |exp_is_odd| {
                            base = &base * &base % modulus;
                            if exp_is_odd {
                                acc *= &base;
                                acc %= modulus;
                            }
                        };

                        if let Some( &last ) = exp_iter.next_back() {
                           
                            for _ in b..::num::big::digit::BITS {
                                unit( r.is_odd() );
                                r >>= 1;
                            }
                           
                            for &r in exp_iter {
                                let mut r = r;
                                for _ in 0..::num::big::digit::BITS {
                                    unit( r.is_odd() );
                                    r >>= 1;
                                }
                            }
                            r = last;
                        }
                        debug_assert_ne!( r, 0 );
                        while !r.is_zero() {
                            unit( r.is_odd() );
                            r >>= 1;
                        }
                    }
                    acc
                }
            }
            pub mod shift
            {
                /*!
                */
                use ::
                {
                    borrow::{ Cow },
                    num::
                    {
                        big::{ digit },
                        traits::{PrimInt, Zero},
                    },
                    ops::{Shl, ShlAssign, Shr, ShrAssign},
                    vec::{ Vec },
                    *,
                };

                use super::{biguint_from_vec, BigUint};
                /*
                */
                #[inline] fn biguint_shl<T: PrimInt>( n: Cow<'_, BigUint>, shift: T ) -> BigUint {
                    if shift < T::zero() {
                        panic!( "attempt to shift left with negative" );
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from( ::num::big::digit::BITS ).unwrap();
                    let digits = ( shift / bits ).to_usize().expect( "capacity overflow" );
                    let shift = ( shift % bits ).to_u8().unwrap();
                    biguint_shl2( n, digits, shift )
                }
                fn biguint_shl2( n: Cow<'_, BigUint>, digits: usize, shift: u8 ) -> BigUint {
                    let mut data = match digits {
                        0 => n.into_owned().data,
                        _ => {
                            let len = digits.saturating_add( n.data.len() + 1 );
                            let mut data = Vec::with_capacity( len );
                            data.resize( digits, 0 );
                            data.extend( n.data.iter() );
                            data
                        }
                    };

                    if shift > 0 {
                        let mut carry = 0;
                        let carry_shift = ::num::big::digit::BITS - shift;
                        for elem in data[digits..].iter_mut() {
                            let new_carry = *elem >> carry_shift;
                            *elem = ( *elem << shift ) | carry;
                            carry = new_carry;
                        }
                        if carry != 0 {
                            data.push( carry );
                        }
                    }
                    biguint_from_vec( data )
               }
                
                #[inline] fn biguint_shr<T: PrimInt>( n: Cow<'_, BigUint>, shift: T ) -> BigUint {
                    if shift < T::zero() {
                        panic!( "attempt to shift right with negative" );
                    }
                    if n.is_zero() {
                        return n.into_owned();
                    }
                    let bits = T::from( ::num::big::digit::BITS ).unwrap();
                    let digits = ( shift / bits ).to_usize().unwrap_or( usize::MAX );
                    let shift = ( shift % bits ).to_u8().unwrap();
                    biguint_shr2( n, digits, shift )
                }
                fn biguint_shr2( n: Cow<'_, BigUint>, digits: usize, shift: u8 ) -> BigUint {
                    if digits >= n.data.len() {
                        let mut n = n.into_owned();
                        n.set_zero();
                        return n;
                    }
                    let mut data = match n {
                        Cow::Borrowed( n ) => n.data[digits..].to_vec(),
                        Cow::Owned( mut n ) => {
                            n.data.drain( ..digits );
                            n.data
                        }
                    };

                    if shift > 0 {
                        let mut borrow = 0;
                        let borrow_shift = ::num::big::digit::BITS - shift;
                        for elem in data.iter_mut().rev() {
                            let new_borrow = *elem << borrow_shift;
                            *elem = ( *elem >> shift ) | borrow;
                            borrow = new_borrow;
                        }
                    }
                    biguint_from_vec( data )
                }
                macro_rules! impl_shift {
                    ( @ref $Shx:ident :: $shx:ident, $ShxAssign:ident :: $shx_assign:ident, $rhs:ty ) => {
                        impl $Shx<&$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx( self, rhs:&$rhs ) -> BigUint {
                                $Shx::$shx( self, *rhs )
                            }
                        }
                        impl $Shx<&$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn $shx( self, rhs:&$rhs ) -> BigUint {
                                $Shx::$shx( self, *rhs )
                            }
                        }
                        impl $ShxAssign<&$rhs> for BigUint {
                            #[inline]
                            fn $shx_assign( &mut self, rhs:&$rhs ) {
                                $ShxAssign::$shx_assign( self, *rhs );
                            }
                        }
                    };
                    ( $( $rhs:ty ),+ ) => {$( 
                        impl Shl<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl( self, rhs: $rhs ) -> BigUint {
                                biguint_shl( Cow::Owned( self ), rhs )
                            }
                        }
                        impl Shl<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shl( self, rhs: $rhs ) -> BigUint {
                                biguint_shl( Cow::Borrowed( self ), rhs )
                            }
                        }
                        impl ShlAssign<$rhs> for BigUint {
                            #[inline]
                            fn shl_assign( &mut self, rhs: $rhs ) {
                                let n = mem::replace( self, Self::ZERO );
                                *self = n << rhs;
                            }
                        }
                        impl_shift! { @ref Shl::shl, ShlAssign::shl_assign, $rhs }
                        impl Shr<$rhs> for BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr( self, rhs: $rhs ) -> BigUint {
                                biguint_shr( Cow::Owned( self ), rhs )
                            }
                        }
                        impl Shr<$rhs> for &BigUint {
                            type Output = BigUint;

                            #[inline]
                            fn shr( self, rhs: $rhs ) -> BigUint {
                                biguint_shr( Cow::Borrowed( self ), rhs )
                            }
                        }
                        impl ShrAssign<$rhs> for BigUint {
                            #[inline]
                            fn shr_assign( &mut self, rhs: $rhs ) {
                                let n = mem::replace( self, Self::ZERO );
                                *self = n >> rhs;
                            }
                        }
                        impl_shift! { @ref Shr::shr, ShrAssign::shr_assign, $rhs }
                    )*};
                }
                impl_shift! { u8, u16, u32, u64, u128, usize }
                impl_shift! { i8, i16, i32, i64, i128, isize }
            }

            pub struct BigUint
            {
                data: Vec<BigDigit>,
            }
            
            impl Clone for BigUint
            {
                #[inline] fn clone( &self ) -> Self {
                    BigUint {
                        data: self.data.clone(),
                    }
               }
                
                #[inline] fn clone_from( &mut self, other:&Self ) {
                    self.data.clone_from( &other.data );
                }
            }
            
            impl hash::Hash for BigUint
            {
                #[inline] fn hash<H: hash::Hasher>( &self, state:&mut H ) {
                    debug_assert!( self.data.last() != Some( &0 ) );
                    self.data.hash( state  );
                }
            }
            
            impl PartialEq for BigUint
            {
                #[inline] fn eq( &self, other:&BigUint ) -> bool {
                    debug_assert!( self.data.last() != Some( &0 ) );
                    debug_assert!( other.data.last() != Some( &0 ) );
                    self.data == other.data
                }
            }
            
            impl Eq for BigUint {}
            
            impl PartialOrd for BigUint
            {
                #[inline] fn partial_cmp( &self, other:&BigUint ) -> Option<Ordering> { Some( self.cmp( other ) ) }
            }
            
            impl Ord for BigUint
            {
                #[inline] fn cmp( &self, other:&BigUint ) -> Ordering {
                    cmp_slice( &self.data[..], &other.data[..] )
                }
            }
            #[inline] fn cmp_slice( a:&[BigDigit], b:&[BigDigit] ) -> Ordering
            {
                debug_assert!( a.last() != Some( &0 ) );
                debug_assert!( b.last() != Some( &0 ) );

                match Ord::cmp( &a.len(), &b.len() ) {
                    Ordering::Equal => Iterator::cmp( a.iter().rev(), b.iter().rev() ),
                    other => other,
                }
            }
            
            impl Default for BigUint
            {
                #[inline] fn default() -> BigUint {
                    Self::ZERO
                }
            }
            
            impl fmt::Debug for BigUint
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    fmt::Display::fmt( self, f )
                }
            }
            
            impl fmt::Display for BigUint
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    f.pad_integral( true, "", &self.to_str_radix( 10 ) )
                }
            }
            
            impl fmt::LowerHex for BigUint
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    f.pad_integral( true, "0x", &self.to_str_radix( 16 ) )
                }
            }
            
            impl fmt::UpperHex for BigUint
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    let mut s = self.to_str_radix( 16 );
                    s.make_ascii_uppercase();
                    f.pad_integral( true, "0x", &s )
                }
            }
            
            impl fmt::Binary for BigUint
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    f.pad_integral( true, "0b", &self.to_str_radix( 2 ) )
                }
            }
            
            impl fmt::Octal for BigUint
            {
                fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                    f.pad_integral( true, "0o", &self.to_str_radix( 8 ) )
                }
            }
            
            impl Zero for BigUint
            {
                #[inline] fn zero() -> BigUint {
                    Self::ZERO
               }
                
                #[inline] fn set_zero( &mut self ) {
                    self.data.clear();
               }
                
                #[inline] fn is_zero( &self ) -> bool { self.data.is_empty() }
            }
            
            impl ConstZero for BigUint {
               
                const ZERO: Self = Self::ZERO;
            }
            
            impl One for BigUint
            {
                #[inline] fn one() -> BigUint {
                    BigUint { data: vec![1] }
               }
                
                #[inline] fn set_one( &mut self ) {
                    self.data.clear();
                    self.data.push( 1 );
               }
                
                #[inline] fn is_one( &self ) -> bool { self.data[..] == [1] }
            }
            
            impl Unsigned for BigUint {}
            
            impl Integer for BigUint
            {
                #[inline] fn div_rem( &self, other:&BigUint ) -> ( BigUint, BigUint ) {
                    division::div_rem_ref( self, other )
               }
                
                #[inline] fn div_floor( &self, other:&BigUint ) -> BigUint {
                    let ( d, _ ) = division::div_rem_ref( self, other );
                    d
               }
                
                #[inline] fn mod_floor( &self, other:&BigUint ) -> BigUint {
                    let ( _, m ) = division::div_rem_ref( self, other );
                    m
               }
                
                #[inline] fn div_mod_floor( &self, other:&BigUint ) -> ( BigUint, BigUint ) {
                    division::div_rem_ref( self, other )
               }
                
                #[inline] fn div_ceil( &self, other:&BigUint ) -> BigUint {
                    let ( d, m ) = division::div_rem_ref( self, other );
                    if m.is_zero() {
                        d
                    } else {
                        d + 1u32
                    }
                }

                #[inline] fn gcd( &self, other:&Self ) -> Self
                {
                    #[inline] fn twos( x:&BigUint ) -> u64 {
                        x.trailing_zeros().unwrap_or( 0 )
                    }
                   
                    if self.is_zero() {
                        return other.clone();
                    }
                    if other.is_zero() {
                        return self.clone();
                    }
                    let mut m = self.clone();
                    let mut n = other.clone();

                   
                    let shift = cmp::min( twos( &n ), twos( &m ) );

                   
                   
                    n >>= twos( &n );

                    while !m.is_zero() {
                        m >>= twos( &m );
                        if n > m {
                            mem::swap( &mut n, &mut m )
                        }
                        m -= &n;
                    }
                    n << shift
                }

                #[inline] fn lcm( &self, other:&BigUint ) -> BigUint
                {
                    if self.is_zero() && other.is_zero() {
                        Self::ZERO
                    } else {
                        self / self.gcd( other ) * other
                    }
                }

                #[inline] fn gcd_lcm( &self, other:&Self ) -> ( Self, Self )
                {
                    let gcd = self.gcd( other );
                    let lcm = if gcd.is_zero() {
                        Self::ZERO
                    } else {
                        self / &gcd * other
                    };
                    ( gcd, lcm )
                }

                #[inline] fn divides( &self, other:&BigUint ) -> bool {
                    self.is_multiple_of( other )
                }

                #[inline] fn is_multiple_of( &self, other:&BigUint ) -> bool {
                    if other.is_zero() {
                        return self.is_zero();
                    }
                    ( self % other ).is_zero()
                }

                #[inline] fn is_even( &self ) -> bool
                {                   
                    match self.data.first() {
                        Some( x ) => x.is_even(),
                        None => true,
                    }
                }

                #[inline] fn is_odd( &self ) -> bool { !self.is_even() }

                #[inline] fn next_multiple_of( &self, other:&Self ) -> Self {
                    let m = self.mod_floor( other );
                    if m.is_zero() {
                        self.clone()
                    } else {
                        self + ( other - m )
                    }
                }

                #[inline] fn prev_multiple_of( &self, other:&Self ) -> Self {
                    self - self.mod_floor( other )
                }
                fn dec( &mut self ) {
                    *self -= 1u32;
                }
                fn inc( &mut self ) {
                    *self += 1u32;
                }
            }
            #[inline] fn fixpoint<F>( mut x: BigUint, max_bits: u64, f: F ) -> BigUint where
                F: Fn( &BigUint ) -> BigUint,
            {
                let mut xn = f( &x );

               
               
                while x < xn {
                   
                   
                   
                    x = if xn.bits() > max_bits {
                        BigUint::one() << max_bits
                    } else {
                        xn
                    };
                    xn = f( &x );
                }
               
                while x > xn {
                    x = xn;
                    xn = f( &x );
                }
                x
            }
            
            impl Roots for BigUint
            {  
                fn nth_root( &self, n: u32 ) -> Self {
                    assert!( n > 0, "root degree n must be at least 1" );

                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }
                    match n {
                       
                        1 => return self.clone(),
                        2 => return self.sqrt(),
                        3 => return self.cbrt(),
                        _ => (),
                    }
                   
                    let bits = self.bits();
                    let n64 = u64::from( n  );
                    if bits <= n64 {
                        return BigUint::one();
                    }
                   
                    if let Some( x ) = self.to_u64() {
                        return x.nth_root( n ).into();
                    }
                    let max_bits = bits / n64 + 1;

                    #[cfg( feature = "std" )]
                    let guess = match self.to_f64() {
                        Some( f ) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;

                           
                            BigUint::from_f64( ( f.ln() / f64::from( n ) ).exp() ).unwrap()
                        }
                        _ => {
                           
                           
                            let extra_bits = bits - ( f64::MAX_EXP as u64 - 1 );
                            let root_scale = Integer::div_ceil( &extra_bits, &n64 );
                            let scale = root_scale * n64;
                            if scale < bits && bits - scale > n64 {
                                ( self >> scale ).nth_root( n ) << root_scale
                            } else {
                                BigUint::one() << max_bits
                            }
                        }
                    };

                    #[cfg( not( feature = "std" ) )]
                    let guess = BigUint::one() << max_bits;

                    let n_min_1 = n - 1;
                    fixpoint( guess, max_bits, move |s| {
                        let q = self / s.pow( n_min_1 );
                        let t = n_min_1 * s + q;
                        t / n
                    } )
                }
               
               
                fn sqrt( &self ) -> Self {
                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }
                   
                    if let Some( x ) = self.to_u64() {
                        return x.sqrt().into();
                    }
                    let bits = self.bits();
                    let max_bits = bits / 2 + 1;

                    #[cfg( feature = "std" )]
                    let guess = match self.to_f64() {
                        Some( f ) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;

                           
                            BigUint::from_f64( f.sqrt() ).unwrap()
                        }
                        _ => {
                           
                           
                            let extra_bits = bits - ( f64::MAX_EXP as u64 - 1 );
                            let root_scale = ( extra_bits + 1 ) / 2;
                            let scale = root_scale * 2;
                            ( self >> scale ).sqrt() << root_scale
                        }
                    };

                    #[cfg( not( feature = "std" ) )]
                    let guess = BigUint::one() << max_bits;

                    fixpoint( guess, max_bits, move |s| {
                        let q = self / s;
                        let t = s + q;
                        t >> 1
                    } )
                }
                fn cbrt( &self ) -> Self {
                    if self.is_zero() || self.is_one() {
                        return self.clone();
                    }
                   
                    if let Some( x ) = self.to_u64() {
                        return x.cbrt().into();
                    }
                    let bits = self.bits();
                    let max_bits = bits / 3 + 1;

                    #[cfg( feature = "std" )]
                    let guess = match self.to_f64() {
                        Some( f ) if f.is_finite() => {
                            use ::num::traits::FromPrimitive;

                           
                            BigUint::from_f64( f.cbrt() ).unwrap()
                        }
                        _ => {
                           
                           
                            let extra_bits = bits - ( f64::MAX_EXP as u64 - 1 );
                            let root_scale = ( extra_bits + 2 ) / 3;
                            let scale = root_scale * 3;
                            ( self >> scale ).cbrt() << root_scale
                        }
                    };

                    #[cfg( not( feature = "std" ) )]
                    let guess = BigUint::one() << max_bits;

                    fixpoint( guess, max_bits, move |s| {
                        let q = self / ( s * s );
                        let t = ( s << 1 ) + q;
                        t / 3u32
                    } )
                }
            }

            pub trait ToBigUint
            {
                fn to_biguint( &self ) -> Option<BigUint>;
            }

            #[inline] pub fn biguint_from_vec( digits: Vec<BigDigit> ) -> BigUint
            {
                BigUint { data: digits }.normalized()
            }
            
            impl BigUint
            {

                pub const ZERO: Self = BigUint { data: Vec::new() };

                #[inline] pub fn new( digits: Vec<u32> ) -> BigUint
                {
                    let mut big = Self::ZERO;

                    cfg_digit_expr!( 
                        {
                            big.data = digits;
                            big.normalize();
                        },
                        big.assign_from_slice( &digits )
                     );

                    big
                }

                #[inline] pub fn from_slice( slice:&[u32] ) -> BigUint
                {
                    let mut big = Self::ZERO;
                    big.assign_from_slice( slice );
                    big
                }

                #[inline] pub fn assign_from_slice( &mut self, slice:&[u32] )
                {
                    self.data.clear();

                    cfg_digit_expr!( 
                        self.data.extend_from_slice( slice ),
                        self.data.extend( slice.chunks( 2 ).map( u32_chunk_to_u64 ) )
                     );

                    self.normalize();
                }

                #[inline] pub fn from_bytes_be( bytes:&[u8] ) -> BigUint
                {
                    if bytes.is_empty() {
                        Self::ZERO
                    } else {
                        let mut v = bytes.to_vec();
                        v.reverse();
                        BigUint::from_bytes_le( &v )
                    }
                }

                #[inline] pub fn from_bytes_le( bytes:&[u8] ) -> BigUint
                {
                    if bytes.is_empty() {
                        Self::ZERO
                    } else {
                        convert::from_bitwise_digits_le( bytes, 8 )
                    }
                }

                #[inline] pub fn parse_bytes( buf:&[u8], radix: u32 ) -> Option<BigUint>
                {
                    let s = str::from_utf8( buf ).ok()?;
                    BigUint::from_str_radix( s, radix ).ok()
                }

                pub fn from_radix_be( buf:&[u8], radix: u32 ) -> Option<BigUint>
                {
                    convert::from_radix_be( buf, radix )
                }

                pub fn from_radix_le( buf:&[u8], radix: u32 ) -> Option<BigUint>
                {
                    convert::from_radix_le( buf, radix )
                }

                #[inline] pub fn to_bytes_be( &self ) -> Vec<u8> {
                    let mut v = self.to_bytes_le();
                    v.reverse();
                    v
                }

                #[inline] pub fn to_bytes_le( &self ) -> Vec<u8> {
                    if self.is_zero() {
                        vec![0]
                    } else {
                        convert::to_bitwise_digits_le( self, 8 )
                    }
                }

                #[inline] pub fn to_u32_digits( &self ) -> Vec<u32> { self.iter_u32_digits().collect() }

                #[inline] pub fn to_u64_digits( &self ) -> Vec<u64> { self.iter_u64_digits().collect()}
                
                #[inline] pub fn iter_u32_digits( &self ) -> U32Digits<'_> { U32Digits::new( self.data.as_slice() )}
                
                #[inline] pub fn iter_u64_digits( &self ) -> U64Digits<'_> { U64Digits::new( self.data.as_slice() ) }

                #[inline] pub fn to_str_radix( &self, radix: u32 ) -> String {
                    let mut v = to_str_radix_reversed( self, radix );
                    v.reverse();
                    unsafe { String::from_utf8_unchecked( v ) }
                }

                #[inline] pub fn to_radix_be( &self, radix: u32 ) -> Vec<u8> {
                    let mut v = convert::to_radix_le( self, radix );
                    v.reverse();
                    v
                }

                #[inline] pub fn to_radix_le( &self, radix: u32 ) -> Vec<u8> { convert::to_radix_le( self, radix ) }

                #[inline] pub fn bits( &self ) -> u64 {
                    if self.is_zero() {
                        return 0;
                    }
                    let zeros: u64 = self.data.last().unwrap().leading_zeros().into();
                    self.data.len() as u64 * u64::from( ::num::big::digit::BITS ) - zeros
                }

                #[inline] fn normalize( &mut self ) {
                    if let Some( &0 ) = self.data.last() {
                        let len = self.data.iter().rposition( |&d| d != 0 ).map_or( 0, |i| i + 1 );
                        self.data.truncate( len );
                    }
                    if self.data.len() < self.data.capacity() / 4 {
                        self.data.shrink_to_fit();
                    }
                }

                #[inline] fn normalized( mut self ) -> BigUint {
                    self.normalize();
                    self
                }

                pub fn pow( &self, exponent: u32 ) -> Self {
                    Pow::pow( self, exponent )
                }

                pub fn modpow( &self, exponent:&Self, modulus:&Self ) -> Self {
                    power::modpow( self, exponent, modulus )
                }

                pub fn modinv( &self, modulus:&Self ) -> Option<Self> {
                   
                   
                   

                    assert!( 
                        !modulus.is_zero(),
                        "attempt to calculate with zero modulus!"
                     );
                    if modulus.is_one() {
                        return Some( Self::zero() );
                    }
                    let mut r0;
                    let mut r1 = self % modulus;
                    let mut t0;
                    let mut t1;

                   
                    if r1.is_zero() {
                        return None;
                    } else if r1.is_one() {
                        return Some( r1 );
                    } else {
                        let ( q, r2 ) = modulus.div_rem( &r1 );
                        if r2.is_zero() {
                            return None;
                        }
                        r0 = r1;
                        r1 = r2;
                        t0 = Self::one();
                        t1 = modulus - q;
                    }
                    while !r1.is_zero() {
                        let ( q, r2 ) = r0.div_rem( &r1 );
                        r0 = r1;
                        r1 = r2;

                       
                        let qt1 = q * &t1 % modulus;
                        let t2 = if t0 < qt1 {
                            t0 + ( modulus - qt1 )
                        } else {
                            t0 - qt1
                        };
                        t0 = t1;
                        t1 = t2;
                    }
                    if r0.is_one() {
                        Some( t0 )
                    } else {
                        None
                    }
                }

                pub fn sqrt( &self ) -> Self { Roots::sqrt( self ) }

                pub fn cbrt( &self ) -> Self { Roots::cbrt( self ) }

                pub fn nth_root( &self, n: u32 ) -> Self {
                    Roots::nth_root( self, n )
                }

                pub fn trailing_zeros( &self ) -> Option<u64> {
                    let i = self.data.iter().position( |&digit| digit != 0 )?;
                    let zeros: u64 = self.data[i].trailing_zeros().into();
                    Some( i as u64 * u64::from( ::num::big::digit::BITS ) + zeros )
                }

                pub fn trailing_ones( &self ) -> u64 {
                    if let Some( i ) = self.data.iter().position( |&digit| !digit != 0 ) {
                        let ones: u64 = self.data[i].trailing_ones().into();
                        i as u64 * u64::from( ::num::big::digit::BITS ) + ones
                    } else {
                        self.data.len() as u64 * u64::from( ::num::big::digit::BITS )
                    }
                }

                pub fn count_ones( &self ) -> u64 { self.data.iter().map( |&d| u64::from( d.count_ones() ) ).sum() }

                pub fn bit( &self, bit: u64 ) -> bool
                {
                    let bits_per_digit = u64::from( ::num::big::digit::BITS );
                    if let Some( digit_index ) = ( bit / bits_per_digit ).to_usize() {
                        if let Some( digit ) = self.data.get( digit_index ) {
                            let bit_mask = ( 1 as BigDigit ) << ( bit % bits_per_digit );
                            return ( digit & bit_mask ) != 0;
                        }
                    }
                    false
                }

                pub fn set_bit( &mut self, bit: u64, value: bool )
                {
                    let bits_per_digit = u64::from( ::num::big::digit::BITS );
                    let digit_index = ( bit / bits_per_digit ).to_usize().unwrap_or( usize::MAX );
                    let bit_mask = ( 1 as BigDigit ) << ( bit % bits_per_digit );
                    if value {
                        if digit_index >= self.data.len() {
                            let new_len = digit_index.saturating_add( 1 );
                            self.data.resize( new_len, 0 );
                        }
                        self.data[digit_index] |= bit_mask;
                    } else if digit_index < self.data.len() {
                        self.data[digit_index] &= !bit_mask;
                       
                        self.normalize();
                    }
                }
            }
            
            impl ::num::traits::FromBytes for BigUint {
                type Bytes = [u8];
                fn from_be_bytes( bytes:&Self::Bytes ) -> Self {
                    Self::from_bytes_be( bytes )
                }
                fn from_le_bytes( bytes:&Self::Bytes ) -> Self {
                    Self::from_bytes_le( bytes )
                }
            }
            
            impl ::num::traits::ToBytes for BigUint {
                type Bytes = Vec<u8>;
                fn to_be_bytes( &self ) -> Self::Bytes { self.to_bytes_be() }
                fn to_le_bytes( &self ) -> Self::Bytes { self.to_bytes_le() }
            }
            pub trait IntDigits {
                fn digits( &self ) -> &[BigDigit];
                fn digits_mut( &mut self ) -> &mut Vec<BigDigit>;
                fn normalize( &mut self );
                fn capacity( &self ) -> usize;
                fn len( &self ) -> usize;
            }
            
            impl IntDigits for BigUint
            {
                #[inline] fn digits( &self ) -> &[BigDigit] { &self.data }
                
                #[inline] fn digits_mut( &mut self ) -> &mut Vec<BigDigit> { &mut self.data}
                
                #[inline] fn normalize( &mut self ) {
                    self.normalize();
               }
                
                #[inline] fn capacity( &self ) -> usize { self.data.capacity() }
                
                #[inline] fn len( &self ) -> usize { self.data.len() }
            }

            #[inline] fn u32_chunk_to_u64( chunk:&[u32] ) -> u64 {
               
                let mut digit = chunk[0] as u64;
                if let Some( &hi ) = chunk.get( 1 ) {
                    digit |= ( hi as u64 ) << 32;
                }
                digit
            }
            cfg_32_or_test!( 

                #[inline] fn u32_to_u128( a: u32, b: u32, c: u32, d: u32 ) -> u128 {
                    u128::from( d ) | ( u128::from( c ) << 32 ) | ( u128::from( b ) << 64 ) | ( u128::from( a ) << 96 )
                }
             );

            cfg_32_or_test!( 

                #[inline] fn u32_from_u128( n: u128 ) -> ( u32, u32, u32, u32 ) {
                    ( 
                        ( n >> 96 ) as u32,
                        ( n >> 64 ) as u32,
                        ( n >> 32 ) as u32,
                        n as u32,
                    )
                }
             );
        }

        #[cfg( target_pointer_width = "32" )]
        type UsizePromotion = u32;
        #[cfg( target_pointer_width = "64" )]
        type UsizePromotion = u64;

        #[cfg( target_pointer_width = "32" )]
        type IsizePromotion = i32;
        #[cfg( target_pointer_width = "64" )]
        type IsizePromotion = i64;

        #[derive( Debug, Clone, PartialEq, Eq )]
        pub struct ParseBigIntError
        {
            kind: BigIntErrorKind,
        }

        #[derive( Debug, Clone, PartialEq, Eq )]
        enum BigIntErrorKind
        {
            Empty,
            InvalidDigit,
        }

        impl ParseBigIntError
        {
            fn __description( &self ) -> &str {
                use ::num::big::BigIntErrorKind::*;
                match self.kind {
                    Empty => "cannot parse integer from empty string",
                    InvalidDigit => "invalid digit found in string",
                }
            }
            
            fn empty() -> Self {
                ParseBigIntError {
                    kind: BigIntErrorKind::Empty,
                }
            }
            
            fn invalid() -> Self {
                ParseBigIntError {
                    kind: BigIntErrorKind::InvalidDigit,
                }
            }
        }

        impl fmt::Display for ParseBigIntError
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {self.__description().fmt( f )
            }
        }
        
        impl ::error::Error for ParseBigIntError
        {
            fn description( &self ) -> &str { self.__description() }
        }

        #[derive( Debug, Copy, Clone, PartialEq, Eq )]
        pub struct TryFromBigIntError<T>
        {
            original: T,
        }

        impl<T> TryFromBigIntError<T>
        {
            fn new( original: T ) -> Self {
                TryFromBigIntError { original }
            }
            
            fn __description( &self ) -> &str { "out of range conversion regarding big integer attempted" }
            pub fn into_original( self ) -> T {
                self.original
            }
        }
        
        impl<T> ::error::Error for TryFromBigIntError<T> where
        T: fmt::Debug,
        {
            fn description( &self ) -> &str { self.__description() }
        }

        impl<T> fmt::Display for TryFromBigIntError<T>
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { self.__description().fmt( f ) }
        }

        pub use self::uint::BigUint;
        pub use self::uint::ToBigUint;
        pub use self::uint::U32Digits;
        pub use self::uint::U64Digits;

        pub use self::int::BigInt;
        pub use self::int::Sign;
        pub use self::int::ToBigInt;
        
        pub use self::rand::{ RandBigInt, RandomBits, UniformBigInt, UniformBigUint };

        mod digit 
        {
           
            cfg_digit!
            ( 
                pub type BigDigit = u32;
                pub type BigDigit = u64;
             );
            
            cfg_digit!
            ( 
                pub type DoubleBigDigit = u64;
                pub type DoubleBigDigit = u128;
             );

            pub const BITS: u8 = BigDigit::BITS as u8;
            pub const HALF_BITS: u8 = BITS / 2;
            pub const HALF: BigDigit = ( 1 << HALF_BITS ) - 1;
            pub const MAX: BigDigit = BigDigit::MAX;
            const LO_MASK: DoubleBigDigit = MAX as DoubleBigDigit;

            #[inline] fn get_hi( n: DoubleBigDigit ) -> BigDigit 
            {
                ( n >> BITS ) as BigDigit
            }
            #[inline] fn get_lo( n: DoubleBigDigit ) -> BigDigit 
            {
                ( n & LO_MASK ) as BigDigit
            }

            #[inline] pub fn from_doublebigdigit( n: DoubleBigDigit ) -> ( BigDigit, BigDigit ) 
            {
                ( get_hi( n ), get_lo( n ) )
            }

            #[inline] pub fn to_doublebigdigit( hi: BigDigit, lo: BigDigit ) -> DoubleBigDigit 
            {
                DoubleBigDigit::from( lo ) | ( DoubleBigDigit::from( hi ) << BITS )
            }
        }
    }
    /*
    */
    pub mod rational
    {
        //! Rational numbers
        use ::
        {
            error::{ Error },
            fmt::{ Binary, Display, Formatter, LowerExp, LowerHex, Octal, UpperExp, UpperHex },
            hash::{Hash, Hasher},
            num::
            {
                big::{ BigInt, BigUint, Sign, ToBigInt },
                integers::{ Integer },
                traits::
                {
                    float::FloatCore,
                    Bounded, CheckedAdd, CheckedDiv, CheckedMul, CheckedSub, ConstOne, ConstZero, FromPrimitive, Inv,
                    Num, NumCast, One, Pow, Signed, ToPrimitive, Unsigned, Zero
                },
            },
            ops::{Add, Div, Mul, Neg, Rem, ShlAssign, Sub},
            str::{ FromStr },
            *,
        };
        /*
        */
        pub mod pow
        {
            use ::
            {
                num::
                {
                    integers::{ Integer },
                    rational::{ Ratio },
                    traits::{ One, Pow },
                },
                *,
            };
            /*
            */
            macro_rules! pow_unsigned_impl {
                ( @ $exp:ty ) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: $exp ) -> Ratio<T> { Ratio::new_raw( self.numer.pow( expon ), self.denom.pow( expon ) ) }
                };
                ( $exp:ty ) => {
                    impl<T: Clone + Integer + Pow<$exp, Output = T>> Pow<$exp> for Ratio<T> { pow_unsigned_impl!( @ $exp ); }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        pow_unsigned_impl!( @ $exp );
                    }
                    impl<'b, T: Clone + Integer + Pow<$exp, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline] fn pow( self, expon:&'b $exp ) -> Ratio<T> { Pow::pow( self, *expon ) }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$exp, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline] fn pow( self, expon:&'b $exp ) -> Ratio<T> { Pow::pow( self, *expon ) }
                    }
                };
            }
            pow_unsigned_impl!( u8 );
            pow_unsigned_impl!( u16 );
            pow_unsigned_impl!( u32 );
            pow_unsigned_impl!( u64 );
            pow_unsigned_impl!( u128 );
            pow_unsigned_impl!( usize );

            macro_rules! pow_signed_impl {
                ( @ &'b BigInt, BigUint ) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon:&'b BigInt ) -> Ratio<T> {
                        match expon.sign() {
                            Sign::NoSign => One::one(),
                            Sign::Minus => { Pow::pow( self, expon.magnitude() ).into_recip() }
                            Sign::Plus => Pow::pow( self, expon.magnitude() ),
                        }
                    }
                };
                ( @ $exp:ty, $unsigned:ty ) => {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: $exp ) -> Ratio<T> {
                        match expon.cmp( &0 ) {
                            cmp::Ordering::Equal => One::one(),
                            cmp::Ordering::Less => {
                                let expon = expon.wrapping_abs() as $unsigned;
                                Pow::pow( self, expon ).into_recip()
                            }
                            cmp::Ordering::Greater => Pow::pow( self, expon as $unsigned ),
                        }
                    }
                };
                ( $exp:ty, $unsigned:ty ) => {
                    impl<T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<$exp> for Ratio<T> { pow_signed_impl!( @ $exp, $unsigned ); }
                    impl<'a, T: Clone + Integer> Pow<$exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        pow_signed_impl!( @ $exp, $unsigned );
                    }
                    impl<'b, T: Clone + Integer + Pow<$unsigned, Output = T>> Pow<&'b $exp> for Ratio<T> {
                        type Output = Ratio<T>;
                        #[inline] fn pow( self, expon:&'b $exp ) -> Ratio<T> { Pow::pow( self, *expon ) }
                    }
                    impl<'a, 'b, T: Clone + Integer> Pow<&'b $exp> for &'a Ratio<T>
                    where
                        &'a T: Pow<$unsigned, Output = T>,
                    {
                        type Output = Ratio<T>;
                        #[inline] fn pow( self, expon:&'b $exp ) -> Ratio<T> { Pow::pow( self, *expon ) }
                    }
                };
            }
            pow_signed_impl!( i8, u8 );
            pow_signed_impl!( i16, u16 );
            pow_signed_impl!( i32, u32 );
            pow_signed_impl!( i64, u64 );
            pow_signed_impl!( i128, u128 );
            pow_signed_impl!( isize, usize );

            #[cfg( feature = "num-bigint" )]
            mod bigint {
                use super::*;
                use num_bigint::{BigInt, BigUint, Sign};

                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigUint> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigUint ) -> Ratio<T> { Pow::pow( self, &expon ) }
                }
                impl<'a, T: Clone + Integer> Pow<BigUint> for &'a Ratio<T> where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigUint ) -> Ratio<T> { Pow::pow( self, &expon ) }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigUint> for Ratio<T> { pow_unsigned_impl!( @ &'b BigUint ); }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigUint> for &'a Ratio<T> where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_unsigned_impl!( @ &'b BigUint );
                }
                impl<T: Clone + Integer + for<'b> Pow<&'b BigUint, Output = T>> Pow<BigInt> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigInt ) -> Ratio<T> { Pow::pow( self, &expon ) }
                }
                impl<'a, T: Clone + Integer> Pow<BigInt> for &'a Ratio<T> where
                    &'a T: for<'b> Pow<&'b BigUint, Output = T>,
                {
                    type Output = Ratio<T>;
                    #[inline] fn pow( self, expon: BigInt ) -> Ratio<T> { Pow::pow( self, &expon ) }
                }
                impl<'b, T: Clone + Integer + Pow<&'b BigUint, Output = T>> Pow<&'b BigInt> for Ratio<T> { pow_signed_impl!( @ &'b BigInt, BigUint ); }
                impl<'a, 'b, T: Clone + Integer> Pow<&'b BigInt> for &'a Ratio<T> where
                    &'a T: Pow<&'b BigUint, Output = T>,
                {
                    pow_signed_impl!( @ &'b BigInt, BigUint );
                }
            }

        }

        #[derive( Copy, Clone, Debug )]
        #[allow( missing_docs )]
        pub struct Ratio<T> {

            numer: T,
            denom: T,
        }

        #[deprecated( 
            since = "0.4.0",
            note = "it's better to use a specific size, like `Rational32` or `Rational64`"
        )]
        pub type Rational = Ratio<isize>;

        pub type Rational32 = Ratio<i32>;

        pub type Rational64 = Ratio<i64>;

        pub type BigRational = Ratio<BigInt>;

        impl<T> Ratio<T>
        {

            #[inline] pub const fn new_raw( numer: T, denom: T ) -> Ratio<T> { Ratio { numer, denom } }

            #[inline] pub fn into_raw( self ) -> ( T, T ) {
                ( self.numer, self.denom )
            }

            #[inline] pub const fn numer( &self ) -> &T { &self.numer }

            #[inline] pub const fn denom( &self ) -> &T { &self.denom }
        }

        impl<T: Clone + Integer> Ratio<T>
        {

            #[inline] pub fn new( numer: T, denom: T ) -> Ratio<T> {
                let mut ret = Ratio::new_raw( numer, denom );
                ret.reduce();
                ret
            }

            #[inline] pub fn from_integer( t: T ) -> Ratio<T> { Ratio::new_raw( t, One::one() ) }

            #[inline] pub fn to_integer( &self ) -> T { self.trunc().numer }

            #[inline] pub fn is_integer( &self ) -> bool { self.denom.is_one() }

            fn reduce( &mut self ) {
                if self.denom.is_zero() {
                    panic!( "denominator == 0" );
                }
                if self.numer.is_zero() {
                    self.denom.set_one();
                    return;
                }
                if self.numer == self.denom {
                    self.set_one();
                    return;
                }
                let g: T = self.numer.gcd( &self.denom );

               
               

                #[inline] fn replace_with<T: Zero>( x:&mut T, f: impl FnOnce( T ) -> T ) {
                    let y = ::mem::replace( x, T::zero() );
                    *x = f( y );
                }
               
                replace_with( &mut self.numer, |x| x / g.clone() );

               
                replace_with( &mut self.denom, |x| x / g );

               
                if self.denom < T::zero() {
                    replace_with( &mut self.numer, |x| T::zero() - x );
                    replace_with( &mut self.denom, |x| T::zero() - x );
                }
            }

            pub fn reduced( &self ) -> Ratio<T> {
                let mut ret = self.clone();
                ret.reduce();
                ret
            }

            #[inline] pub fn recip( &self ) -> Ratio<T> { self.clone().into_recip() }
            #[inline] fn into_recip( self ) -> Ratio<T> {
                match self.numer.cmp( &T::zero() ) {
                    cmp::Ordering::Equal => panic!( "division by zero" ),
                    cmp::Ordering::Greater => Ratio::new_raw( self.denom, self.numer ),
                    cmp::Ordering::Less => Ratio::new_raw( T::zero() - self.denom, T::zero() - self.numer ),
                }
            }

            #[inline] pub fn floor( &self ) -> Ratio<T> {
                if *self < Zero::zero() {
                    let one: T = One::one();
                    Ratio::from_integer( 
                        ( self.numer.clone() - self.denom.clone() + one ) / self.denom.clone(),
                    )
                } else {
                    Ratio::from_integer( self.numer.clone() / self.denom.clone() )
                }
            }

            #[inline] pub fn ceil( &self ) -> Ratio<T> {
                if *self < Zero::zero() {
                    Ratio::from_integer( self.numer.clone() / self.denom.clone() )
                } else {
                    let one: T = One::one();
                    Ratio::from_integer( 
                        ( self.numer.clone() + self.denom.clone() - one ) / self.denom.clone(),
                    )
                }
            }

            #[inline] pub fn round( &self ) -> Ratio<T> {
                let zero: Ratio<T> = Zero::zero();
                let one: T = One::one();
                let two: T = one.clone() + one.clone();

               
                let mut fractional = self.fract();
                if fractional < zero {
                    fractional = zero - fractional
                };

               
               
               
                let half_or_larger = if fractional.denom.is_even() {
                    fractional.numer >= fractional.denom / two
                } else {
                    fractional.numer >= ( fractional.denom / two ) + one
                };

                if half_or_larger {
                    let one: Ratio<T> = One::one();
                    if *self >= Zero::zero() {
                        self.trunc() + one
                    } else {
                        self.trunc() - one
                    }
                } else {
                    self.trunc()
                }
            }

            #[inline] pub fn trunc( &self ) -> Ratio<T> { Ratio::from_integer( self.numer.clone() / self.denom.clone() ) }

            #[inline] pub fn fract( &self ) -> Ratio<T> { Ratio::new_raw( self.numer.clone() % self.denom.clone(), self.denom.clone() ) }

            #[inline] pub fn pow( &self, expon: i32 ) -> Ratio<T> where
                for<'a> &'a T: Pow<u32, Output = T>,
            {
                Pow::pow( self, expon )
            }
        }
        
        impl Ratio<BigInt>
        {

            pub fn from_float<T: FloatCore>( f: T ) -> Option<BigRational> {
                if !f.is_finite() {
                    return None;
                }
                let ( mantissa, exponent, sign ) = f.integer_decode();
                let bigint_sign = if sign == 1 { Sign::Plus } else { Sign::Minus };
                if exponent < 0 {
                    let one: BigInt = One::one();
                    let denom: BigInt = one << ( ( -exponent ) as usize );
                    let numer: BigUint = FromPrimitive::from_u64( mantissa ).unwrap();
                    Some( Ratio::new( BigInt::from_biguint( bigint_sign, numer ), denom ) )
                } else {
                    let mut numer: BigUint = FromPrimitive::from_u64( mantissa ).unwrap();
                    numer <<= exponent as usize;
                    Some( Ratio::from_integer( BigInt::from_biguint( 
                        bigint_sign,
                        numer,
                    ) ) )
                }
            }
        }

        impl<T: Clone + Integer> Default for Ratio<T>
        {

            fn default() -> Self {
                Ratio::zero()
            }
        }
        
        impl<T> From<T> for Ratio<T> where
            T: Clone + Integer,
        {
            fn from( x: T ) -> Ratio<T> { Ratio::from_integer( x ) }
        }
        
        impl<T> From<( T, T )> for Ratio<T> where
            T: Clone + Integer,
        {
            fn from( pair: ( T, T ) ) -> Ratio<T> { Ratio::new( pair.0, pair.1 ) }
        }
        
        impl<T: Clone + Integer> Ord for Ratio<T> 
        {
            #[inline] fn cmp( &self, other:&Self ) -> cmp::Ordering {
               
                if self.denom == other.denom {
                    let ord = self.numer.cmp( &other.numer );
                    return if self.denom < T::zero() {
                        ord.reverse()
                    } else {
                        ord
                    };
                }
               
                if self.numer == other.numer {
                    if self.numer.is_zero() {
                        return cmp::Ordering::Equal;
                    }
                    let ord = self.denom.cmp( &other.denom );
                    return if self.numer < T::zero() {
                        ord
                    } else {
                        ord.reverse()
                    };
                }
               
               
               

               
                let ( self_int, self_rem ) = self.numer.div_mod_floor( &self.denom );
                let ( other_int, other_rem ) = other.numer.div_mod_floor( &other.denom );
                match self_int.cmp( &other_int ) {
                    cmp::Ordering::Greater => cmp::Ordering::Greater,
                    cmp::Ordering::Less => cmp::Ordering::Less,
                    cmp::Ordering::Equal => {
                        match ( self_rem.is_zero(), other_rem.is_zero() ) {
                            ( true, true ) => cmp::Ordering::Equal,
                            ( true, false ) => cmp::Ordering::Less,
                            ( false, true ) => cmp::Ordering::Greater,
                            ( false, false ) => {
                               
                                let self_recip = Ratio::new_raw( self.denom.clone(), self_rem );
                                let other_recip = Ratio::new_raw( other.denom.clone(), other_rem );
                                self_recip.cmp( &other_recip ).reverse()
                            }
                        }
                    }
                }
            }
        }

        impl<T: Clone + Integer> PartialOrd for Ratio<T>
        {
            #[inline] fn partial_cmp( &self, other:&Self ) -> Option<cmp::Ordering> { Some( self.cmp( other ) ) }
        }

        impl<T: Clone + Integer> PartialEq for Ratio<T> 
        {
            #[inline] fn eq( &self, other:&Self ) -> bool {
                self.cmp( other ) == cmp::Ordering::Equal
            }
        }

        impl<T: Clone + Integer> Eq for Ratio<T> {}       
       
        impl<T: Clone + Integer + Hash> Hash for Ratio<T> 
        {
            fn hash<H: Hasher>( &self, state:&mut H ) {
                recurse( &self.numer, &self.denom, state );
                fn recurse<T: Integer + Hash, H: Hasher>( numer:&T, denom:&T, state:&mut H ) {
                    if !denom.is_zero() {
                        let ( int, rem ) = numer.div_mod_floor( denom );
                        int.hash( state  );
                        recurse( denom, &rem, state );
                    } else {
                        denom.hash( state  );
                    }
                }
            }
        }

        mod iter_sum_product
        {
            use ::
            {
                iter::{Product, Sum},
                num::
                {
                    integers::{ Integer },
                    rational::{ Ratio },
                    traits::{ One, Zero },
                },
                *,
            };

            impl<T: Integer + Clone> Sum for Ratio<T>
            {
                fn sum<I>( iter: I ) -> Self where I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold( Self::zero(), |sum, num| sum + num )
                }
            }
            
            impl<'a, T: Integer + Clone> Sum<&'a Ratio<T>> for Ratio<T>
            {
                fn sum<I>( iter: I ) -> Self where I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold( Self::zero(), |sum, num| sum + num )
                }
            }
            
            impl<T: Integer + Clone> Product for Ratio<T>
            {
                fn product<I>( iter: I ) -> Self where I: Iterator<Item = Ratio<T>>,
                {
                    iter.fold( Self::one(), |prod, num| prod * num )
                }
            }
            
            impl<'a, T: Integer + Clone> Product<&'a Ratio<T>> for Ratio<T>
            {
                fn product<I>( iter: I ) -> Self where I: Iterator<Item = &'a Ratio<T>>,
                {
                    iter.fold( Self::one(), |prod, num| prod * num )
                }
            }
        }

        mod opassign
        {
            use ::
            {
                ops::{AddAssign, DivAssign, MulAssign, RemAssign, SubAssign},
                num::
                {
                    integers::Integer,
                    rational::{ Ratio },
                    traits::NumAssign,
                },
                *,
            };

            impl<T: Clone + Integer + NumAssign> AddAssign for Ratio<T>
            {
                fn add_assign( &mut self, other: Ratio<T> ) {
                    if self.denom == other.denom {
                        self.numer += other.numer
                    } else {
                        let lcm = self.denom.lcm( &other.denom );
                        let lhs_numer = self.numer.clone() * ( lcm.clone() / self.denom.clone() );
                        let rhs_numer = other.numer * ( lcm.clone() / other.denom );
                        self.numer = lhs_numer + rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> DivAssign for Ratio<T>
            {
                fn div_assign( &mut self, other: Ratio<T> ) {
                    let gcd_ac = self.numer.gcd( &other.numer );
                    let gcd_bd = self.denom.gcd( &other.denom );
                    self.numer /= gcd_ac.clone();
                    self.numer *= other.denom / gcd_bd.clone();
                    self.denom /= gcd_bd;
                    self.denom *= other.numer / gcd_ac;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> MulAssign for Ratio<T>
            {
                fn mul_assign( &mut self, other: Ratio<T> ) {
                    let gcd_ad = self.numer.gcd( &other.denom );
                    let gcd_bc = self.denom.gcd( &other.numer );
                    self.numer /= gcd_ad.clone();
                    self.numer *= other.numer / gcd_bc.clone();
                    self.denom /= gcd_bc;
                    self.denom *= other.denom / gcd_ad;
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> RemAssign for Ratio<T>
            {
                fn rem_assign( &mut self, other: Ratio<T> ) {
                    if self.denom == other.denom {
                        self.numer %= other.numer
                    } else {
                        let lcm = self.denom.lcm( &other.denom );
                        let lhs_numer = self.numer.clone() * ( lcm.clone() / self.denom.clone() );
                        let rhs_numer = other.numer * ( lcm.clone() / other.denom );
                        self.numer = lhs_numer % rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> SubAssign for Ratio<T>
            {
                fn sub_assign( &mut self, other: Ratio<T> ) {
                    if self.denom == other.denom {
                        self.numer -= other.numer
                    } else {
                        let lcm = self.denom.lcm( &other.denom );
                        let lhs_numer = self.numer.clone() * ( lcm.clone() / self.denom.clone() );
                        let rhs_numer = other.numer * ( lcm.clone() / other.denom );
                        self.numer = lhs_numer - rhs_numer;
                        self.denom = lcm;
                    }
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> AddAssign<T> for Ratio<T>
            {
                fn add_assign( &mut self, other: T ) {
                    self.numer += self.denom.clone() * other;
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> DivAssign<T> for Ratio<T>
            {
                fn div_assign( &mut self, other: T ) {
                    let gcd = self.numer.gcd( &other );
                    self.numer /= gcd.clone();
                    self.denom *= other / gcd;
                    self.reduce();
                }
            }
            
            impl<T: Clone + Integer + NumAssign> MulAssign<T> for Ratio<T>
            {
                fn mul_assign( &mut self, other: T ) {
                    let gcd = self.denom.gcd( &other );
                    self.denom /= gcd.clone();
                    self.numer *= other / gcd;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> RemAssign<T> for Ratio<T>
            {
                fn rem_assign( &mut self, other: T ) {
                    self.numer %= self.denom.clone() * other;
                    self.reduce();
                }
            }
           
            impl<T: Clone + Integer + NumAssign> SubAssign<T> for Ratio<T>
            {
                fn sub_assign( &mut self, other: T ) {
                    self.numer -= self.denom.clone() * other;
                    self.reduce();
                }
            }
            macro_rules! forward_op_assign {
                ( impl $imp:ident, $method:ident ) => {
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a Ratio<T>> for Ratio<T> {
                        #[inline] fn $method( &mut self, other:&Ratio<T> ) {
                            self.$method( other.clone() )
                        }
                    }
                    impl<'a, T: Clone + Integer + NumAssign> $imp<&'a T> for Ratio<T> {
                        #[inline] fn $method( &mut self, other:&T ) {
                            self.$method( other.clone() )
                        }
                    }
                };
            }
            forward_op_assign!( impl AddAssign, add_assign );
            forward_op_assign!( impl DivAssign, div_assign );
            forward_op_assign!( impl MulAssign, mul_assign );
            forward_op_assign!( impl RemAssign, rem_assign );
            forward_op_assign!( impl SubAssign, sub_assign );
        }

        forward_all_binop!( impl Mul, mul );
       
        impl<T> Mul<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline] fn mul( self, rhs: Ratio<T> ) -> Ratio<T> {
                let gcd_ad = self.numer.gcd( &rhs.denom );
                let gcd_bc = self.denom.gcd( &rhs.numer );
                Ratio::new( 
                    self.numer / gcd_ad.clone() * ( rhs.numer / gcd_bc.clone() ),
                    self.denom / gcd_bc * ( rhs.denom / gcd_ad ),
                )
            }
        }
       
        impl<T> Mul<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;
            #[inline] fn mul( self, rhs: T ) -> Ratio<T> {
                let gcd = self.denom.gcd( &rhs );
                Ratio::new( self.numer * ( rhs / gcd.clone() ), self.denom / gcd )
            }
        }

        forward_all_binop!( impl Div, div );
       
        impl<T> Div<Ratio<T>> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn div( self, rhs: Ratio<T> ) -> Ratio<T> {
                let gcd_ac = self.numer.gcd( &rhs.numer );
                let gcd_bd = self.denom.gcd( &rhs.denom );
                Ratio::new( 
                    self.numer / gcd_ac.clone() * ( rhs.denom / gcd_bd.clone() ),
                    self.denom / gcd_bd * ( rhs.numer / gcd_ac ),
                )
            }
        }
       
        impl<T> Div<T> for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn div( self, rhs: T ) -> Ratio<T> {
                let gcd = self.numer.gcd( &rhs );
                Ratio::new( self.numer / gcd.clone(), self.denom * ( rhs / gcd ) )
            }
        }

        macro_rules! arith_impl
        {
            ( impl $imp:ident, $method:ident ) => {
                forward_all_binop!( impl $imp, $method );
               
                impl<T: Clone + Integer> $imp<Ratio<T>> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, rhs: Ratio<T> ) -> Ratio<T> {
                        if self.denom == rhs.denom {
                            return Ratio::new( self.numer.$method( rhs.numer ), rhs.denom );
                        }
                        let lcm = self.denom.lcm( &rhs.denom );
                        let lhs_numer = self.numer * ( lcm.clone() / self.denom );
                        let rhs_numer = rhs.numer * ( lcm.clone() / rhs.denom );
                        Ratio::new( lhs_numer.$method( rhs_numer ), lcm )
                    }
                }
               
                impl<T: Clone + Integer> $imp<T> for Ratio<T> {
                    type Output = Ratio<T>;
                    #[inline] fn $method( self, rhs: T ) -> Ratio<T> { Ratio::new( self.numer.$method( self.denom.clone() * rhs ), self.denom ) }
                }
            };
        }

        arith_impl!( impl Add, add );
        arith_impl!( impl Sub, sub );
        arith_impl!( impl Rem, rem );
       
        impl<T> CheckedMul for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline] fn checked_mul( &self, rhs:&Ratio<T> ) -> Option<Ratio<T>> {
                let gcd_ad = self.numer.gcd( &rhs.denom );
                let gcd_bc = self.denom.gcd( &rhs.numer );
                Some( Ratio::new( 
                    ( self.numer.clone() / gcd_ad.clone() )
                        .checked_mul( &( rhs.numer.clone() / gcd_bc.clone() ) )?,
                    ( self.denom.clone() / gcd_bc ).checked_mul( &( rhs.denom.clone() / gcd_ad ) )?,
                ) )
            }
        }

       
        impl<T> CheckedDiv for Ratio<T> where
            T: Clone + Integer + CheckedMul,
        {
            #[inline] fn checked_div( &self, rhs:&Ratio<T> ) -> Option<Ratio<T>> {
                if rhs.is_zero() {
                    return None;
                }
                let ( numer, denom ) = if self.denom == rhs.denom {
                    ( self.numer.clone(), rhs.numer.clone() )
                } else if self.numer == rhs.numer {
                    ( rhs.denom.clone(), self.denom.clone() )
                } else {
                    let gcd_ac = self.numer.gcd( &rhs.numer );
                    let gcd_bd = self.denom.gcd( &rhs.denom );
                    ( 
                        ( self.numer.clone() / gcd_ac.clone() )
                            .checked_mul( &( rhs.denom.clone() / gcd_bd.clone() ) )?,
                        ( self.denom.clone() / gcd_bd ).checked_mul( &( rhs.numer.clone() / gcd_ac ) )?,
                    )
                };
               
                if denom.is_zero() {
                    None
                } else if numer.is_zero() {
                    Some( Self::zero() )
                } else if numer == denom {
                    Some( Self::one() )
                } else {
                    let g = numer.gcd( &denom );
                    let numer = numer / g.clone();
                    let denom = denom / g;
                    let raw = if denom < T::zero() {
                       
                       
                        let n1 = T::zero() - T::one();
                        Ratio::new_raw( numer.checked_mul( &n1 )?, denom.checked_mul( &n1 )? )
                    } else {
                        Ratio::new_raw( numer, denom )
                    };
                    Some( raw )
                }
            }
        }
        
        macro_rules! checked_arith_impl
        {
            ( impl $imp:ident, $method:ident ) => {
                impl<T: Clone + Integer + CheckedMul + $imp> $imp for Ratio<T> {
                    #[inline] fn $method( &self, rhs:&Ratio<T> ) -> Option<Ratio<T>>
                    {
                        let gcd = self.denom.clone().gcd( &rhs.denom );
                        let lcm = ( self.denom.clone() / gcd.clone() ).checked_mul( &rhs.denom )?;
                        let lhs_numer = ( lcm.clone() / self.denom.clone() ).checked_mul( &self.numer )?;
                        let rhs_numer = ( lcm.clone() / rhs.denom.clone() ).checked_mul( &rhs.numer )?;
                        Some( Ratio::new( lhs_numer.$method( &rhs_numer )?, lcm ) )
                    }
                }
            };
        }
        
        checked_arith_impl!( impl CheckedAdd, checked_add );
        checked_arith_impl!( impl CheckedSub, checked_sub );

        impl<T> Neg for Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline] fn neg( self ) -> Ratio<T> { Ratio::new_raw( -self.numer, self.denom ) }
        }

        impl<'a, T> Neg for &'a Ratio<T> where
            T: Clone + Integer + Neg<Output = T>,
        {
            type Output = Ratio<T>;

            #[inline] fn neg( self ) -> Ratio<T> { -self.clone() }
        }

        impl<T> Inv for Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn inv( self ) -> Ratio<T> { self.recip() }
        }

        impl<'a, T> Inv for &'a Ratio<T> where
            T: Clone + Integer,
        {
            type Output = Ratio<T>;

            #[inline] fn inv( self ) -> Ratio<T> { self.recip() }
        }
        
        impl<T: ConstZero + ConstOne> Ratio<T>
        {

            pub const ZERO: Self = Self::new_raw( T::ZERO, T::ONE );
        }

        impl<T: Clone + Integer + ConstZero + ConstOne> ConstZero for Ratio<T>
        {
            const ZERO: Self = Self::ZERO;
        }

        impl<T: Clone + Integer> Zero for Ratio<T> 
        {
            #[inline] fn zero() -> Ratio<T> { Ratio::new_raw( Zero::zero(), One::one() ) }
            #[inline] fn is_zero( &self ) -> bool { self.numer.is_zero() }
            #[inline] fn set_zero( &mut self ) {
                self.numer.set_zero();
                self.denom.set_one();
            }
        }

        impl<T: ConstOne> Ratio<T> 
        {

            pub const ONE: Self = Self::new_raw( T::ONE, T::ONE );
        }

        impl<T: Clone + Integer + ConstOne> ConstOne for Ratio<T> 
        {
            const ONE: Self = Self::ONE;
        }

        impl<T: Clone + Integer> One for Ratio<T>
        {
            #[inline] fn one() -> Ratio<T> { Ratio::new_raw( One::one(), One::one() ) }
            #[inline] fn is_one( &self ) -> bool { self.numer == self.denom }
            #[inline] fn set_one( &mut self ) {
                self.numer.set_one();
                self.denom.set_one();
            }
        }

        impl<T: Clone + Integer> Num for Ratio<T>
        {
            type FromStrRadixErr = ParseRatioError;
            fn from_str_radix( s:&str, radix: u32 ) -> Result<Ratio<T>, ParseRatioError> {
                if s.splitn( 2, '/' ).count() == 2 {
                    let mut parts = s.splitn( 2, '/' ).map( |ss| {
                        T::from_str_radix( ss, radix ).map_err( |_| ParseRatioError {
                            kind: RatioErrorKind::ParseError,
                        } )
                    } );
                    let numer: T = parts.next().unwrap()?;
                    let denom: T = parts.next().unwrap()?;
                    if denom.is_zero() {
                        Err( ParseRatioError {
                            kind: RatioErrorKind::ZeroDenominator,
                        } )
                    } else {
                        Ok( Ratio::new( numer, denom ) )
                    }
                } else {
                    Err( ParseRatioError {
                        kind: RatioErrorKind::ParseError,
                    } )
                }
            }
        }

        impl<T: Clone + Integer + Signed> Signed for Ratio<T>
        {
            #[inline] fn abs( &self ) -> Ratio<T> {
                if self.is_negative() {
                    -self.clone()
                } else {
                    self.clone()
                }
            }
            #[inline] fn abs_sub( &self, other:&Ratio<T> ) -> Ratio<T> {
                if *self <= *other {
                    Zero::zero()
                } else {
                    self - other
                }
            }
            #[inline] fn signum( &self ) -> Ratio<T> {
                if self.is_positive() {
                    Self::one()
                } else if self.is_zero() {
                    Self::zero()
                } else {
                    -Self::one()
                }
            }
            #[inline] fn is_positive( &self ) -> bool {
                ( self.numer.is_positive() && self.denom.is_positive() )
                    || ( self.numer.is_negative() && self.denom.is_negative() )
            }
            #[inline] fn is_negative( &self ) -> bool {
                ( self.numer.is_negative() && self.denom.is_positive() )
                    || ( self.numer.is_positive() && self.denom.is_negative() )
            }
        }
        
        macro_rules! impl_formatting
        {
            ( $fmt_trait:ident, $prefix:expr, $fmt_str:expr, $fmt_alt:expr ) => {
                impl<T: $fmt_trait + Clone + Integer> $fmt_trait for Ratio<T> {
                            fn fmt( &self, f:&mut Formatter<'_> ) -> fmt::Result
                {        let pre_pad = if self.denom.is_one() {
                            format!( $fmt_str, self.numer )
                        } else {
                            if f.alternate() {
                                format!( concat!( $fmt_str, "/", $fmt_alt ), self.numer, self.denom )
                            } else {
                                format!( concat!( $fmt_str, "/", $fmt_str ), self.numer, self.denom )
                            }
                        };
                        if let Some( pre_pad ) = pre_pad.strip_prefix( "-" ) {
                            f.pad_integral( false, $prefix, pre_pad )
                        } else {
                            f.pad_integral( true, $prefix, &pre_pad )
                        }
                    }
                }
            };
        }

        impl_formatting!( Display, "","{}","{:#}" );
        impl_formatting!( Octal, "0o","{:o}","{:#o}" );
        impl_formatting!( Binary, "0b","{:b}","{:#b}" );
        impl_formatting!( LowerHex, "0x","{:x}","{:#x}" );
        impl_formatting!( UpperHex, "0x","{:X}","{:#X}" );
        impl_formatting!( LowerExp, "","{:e}","{:#e}" );
        impl_formatting!( UpperExp, "","{:E}","{:#E}" );

        impl<T: FromStr + Clone + Integer> FromStr for Ratio<T>
        {
            type Err = ParseRatioError;
            fn from_str( s:&str ) -> Result<Ratio<T>, ParseRatioError> {
                let mut split = s.splitn( 2, '/' );

                let n = split.next().ok_or( ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                } )?;
                let num = FromStr::from_str( n ).map_err( |_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                } )?;

                let d = split.next().unwrap_or( "1" );
                let den = FromStr::from_str( d ).map_err( |_| ParseRatioError {
                    kind: RatioErrorKind::ParseError,
                } )?;

                if Zero::is_zero( &den ) {
                    Err( ParseRatioError {
                        kind: RatioErrorKind::ZeroDenominator,
                    } )
                } else {
                    Ok( Ratio::new( num, den ) )
                }
            }
        }

        impl<T> From<Ratio<T>> for ( T, T )
        {
            fn from( val: Ratio<T> ) -> Self {
                ( val.numer, val.denom )
            }
        }
                
        #[derive( Copy, Clone, Debug, PartialEq )]
        pub struct ParseRatioError
        {
            kind: RatioErrorKind,
        }

        #[derive( Copy, Clone, Debug, PartialEq )]
        enum RatioErrorKind
        {
            ParseError,
            ZeroDenominator,
        }

        impl fmt::Display for ParseRatioError
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
                {self.kind.description().fmt( f )
            }
        }
        
        impl Error for ParseRatioError
        {
            #[allow( deprecated )]
            fn description( &self ) -> &str { self.kind.description() }
        }

        impl RatioErrorKind
        {
            fn description( &self ) -> &'static str {
                match *self {
                    RatioErrorKind::ParseError => "failed to parse integer",
                    RatioErrorKind::ZeroDenominator => "zero value denominator",
                }
            }
        }
        
        impl FromPrimitive for Ratio<BigInt>
        {
            fn from_i64( n: i64 ) -> Option<Self> { Some( Ratio::from_integer( n.into() ) ) }
            
            fn from_i128( n: i128 ) -> Option<Self> { Some( Ratio::from_integer( n.into() ) ) }
            
            fn from_u64( n: u64 ) -> Option<Self> { Some( Ratio::from_integer( n.into() ) ) }
            
            fn from_u128( n: u128 ) -> Option<Self> { Some( Ratio::from_integer( n.into() ) ) }
            
            fn from_f32( n: f32 ) -> Option<Self> { Ratio::from_float( n ) }
            
            fn from_f64( n: f64 ) -> Option<Self> { Ratio::from_float( n ) }
        }

        macro_rules! from_primitive_integer
        {
            ( $typ:ty, $approx:ident ) => {
                impl FromPrimitive for Ratio<$typ>
                {
                    fn from_i64( n: i64 ) -> Option<Self> { <$typ as FromPrimitive>::from_i64( n ).map( Ratio::from_integer ) }
                    fn from_i128( n: i128 ) -> Option<Self> { <$typ as FromPrimitive>::from_i128( n ).map( Ratio::from_integer ) }
                    fn from_u64( n: u64 ) -> Option<Self> { <$typ as FromPrimitive>::from_u64( n ).map( Ratio::from_integer ) }
                    fn from_u128( n: u128 ) -> Option<Self> { <$typ as FromPrimitive>::from_u128( n ).map( Ratio::from_integer ) }
                    fn from_f32( n: f32 ) -> Option<Self> { $approx( n, 10e-20, 30 ) }
                    fn from_f64( n: f64 ) -> Option<Self> { $approx( n, 10e-20, 30 ) }
                }
            };
        }

        from_primitive_integer!( i8, approximate_float );
        from_primitive_integer!( i16, approximate_float );
        from_primitive_integer!( i32, approximate_float );
        from_primitive_integer!( i64, approximate_float );
        from_primitive_integer!( i128, approximate_float );
        from_primitive_integer!( isize, approximate_float );

        from_primitive_integer!( u8, approximate_float_unsigned );
        from_primitive_integer!( u16, approximate_float_unsigned );
        from_primitive_integer!( u32, approximate_float_unsigned );
        from_primitive_integer!( u64, approximate_float_unsigned );
        from_primitive_integer!( u128, approximate_float_unsigned );
        from_primitive_integer!( usize, approximate_float_unsigned );

        impl<T: Integer + Signed + Bounded + NumCast + Clone> Ratio<T>
        {
            pub fn approximate_float<F: FloatCore + NumCast>( f: F ) -> Option<Ratio<T>> {
               
               
               
                let epsilon = <F as NumCast>::from( 10e-20 ).expect( "Can't convert 10e-20" );
                approximate_float( f, epsilon, 30 )
            }
        }

        impl<T: Integer + Unsigned + Bounded + NumCast + Clone> Ratio<T>
        {
            pub fn approximate_float_unsigned<F: FloatCore + NumCast>( f: F ) -> Option<Ratio<T>> {
               
               
               
                let epsilon = <F as NumCast>::from( 10e-20 ).expect( "Can't convert 10e-20" );
                approximate_float_unsigned( f, epsilon, 30 )
            }
        }

        fn approximate_float<T, F>( val: F, max_error: F, max_iterations: usize ) -> Option<Ratio<T>> where
            T: Integer + Signed + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
            let negative = val.is_sign_negative();
            let abs_val = val.abs();

            let r = approximate_float_unsigned( abs_val, max_error, max_iterations )?;

           
            Some( if negative { r.neg() } else { r } )
        }
        
        fn approximate_float_unsigned<T, F>( val: F, max_error: F, max_iterations: usize ) -> Option<Ratio<T>> where
            T: Integer + Bounded + NumCast + Clone,
            F: FloatCore + NumCast,
        {
           
           

            if val < F::zero() || val.is_nan() {
                return None;
            }
            let mut q = val;
            let mut n0 = T::zero();
            let mut d0 = T::one();
            let mut n1 = T::one();
            let mut d1 = T::zero();

            let t_max = T::max_value();
            let t_max_f = <F as NumCast>::from( t_max.clone() )?;

           
            let epsilon = t_max_f.recip();

           
            if q > t_max_f {
                return None;
            }
            for _ in 0..max_iterations {
                let a = match <T as NumCast>::from( q ) {
                    None => break,
                    Some( a ) => a,
                };

                let a_f = match <F as NumCast>::from( a.clone() ) {
                    None => break,
                    Some( a_f ) => a_f,
                };
                let f = q - a_f;

               
                if !a.is_zero()
                    && ( n1 > t_max.clone() / a.clone()
                        || d1 > t_max.clone() / a.clone()
                        || a.clone() * n1.clone() > t_max.clone() - n0.clone()
                        || a.clone() * d1.clone() > t_max.clone() - d0.clone() )
                {
                    break;
                }
                let n = a.clone() * n1.clone() + n0.clone();
                let d = a.clone() * d1.clone() + d0.clone();

                n0 = n1;
                d0 = d1;
                n1 = n.clone();
                d1 = d.clone();

               
               
                let g = Integer::gcd( &n1, &d1 );
                if !g.is_zero() {
                    n1 = n1 / g.clone();
                    d1 = d1 / g.clone();
                }
               
                let ( n_f, d_f ) = match ( <F as NumCast>::from( n ), <F as NumCast>::from( d ) ) {
                    ( Some( n_f ), Some( d_f ) ) => ( n_f, d_f ),
                    _ => break,
                };
                if ( n_f / d_f - val ).abs() < max_error {
                    break;
                }
               
                if f < epsilon {
                    break;
                }
                q = f.recip();
            }
           
            if d1.is_zero() {
                return None;
            }
            Some( Ratio::new( n1, d1 ) )
        }
        
        impl<T: Clone + Integer + ToPrimitive + ToBigInt> ToPrimitive for Ratio<T>
        {
            fn to_i64( &self ) -> Option<i64> { self.to_integer().to_i64() }
            
            fn to_i128( &self ) -> Option<i128> { self.to_integer().to_i128() }
            
            fn to_u64( &self ) -> Option<u64> { self.to_integer().to_u64() }
            
            fn to_u128( &self ) -> Option<u128> { self.to_integer().to_u128() }
            
            fn to_f64( &self ) -> Option<f64> {
                let float = match ( self.numer.to_i64(), self.denom.to_i64() ) {
                    ( Some( numer ), Some( denom ) ) => ratio_to_f64( 
                        <i128 as From<_>>::from( numer ),
                        <i128 as From<_>>::from( denom ),
                    ),
                    _ =>
                    {
                        let numer: BigInt = self.numer.to_bigint()?;
                        let denom: BigInt = self.denom.to_bigint()?;
                        ratio_to_f64( numer, denom )
                    }
                };
                if float.is_nan() {
                    None
                } else {
                    Some( float )
                }
            }
        }

        trait Bits
        {
            fn bits( &self ) -> u64;
        }
        
        impl Bits for BigInt
        {
            fn bits( &self ) -> u64 { self.bits() }
        }

        impl Bits for i128
        {
            fn bits( &self ) -> u64 { ( 128 - self.wrapping_abs().leading_zeros() ).into() }
        }

        fn ratio_to_f64<T: Bits + Clone + Integer + Signed + ShlAssign<usize> + ToPrimitive>( 
            numer: T,
            denom: T,
        ) -> f64 {
            use ::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, MIN_EXP, RADIX};

            assert_eq!( 
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
             );

           
            const MAX_EXACT_INT: i64 = 1i64 << MANTISSA_DIGITS;
            const MIN_EXACT_INT: i64 = -MAX_EXACT_INT;

            let flo_sign = numer.signum().to_f64().unwrap() / denom.signum().to_f64().unwrap();
            if !flo_sign.is_normal() {
                return flo_sign;
            }
           
           
           
            if let ( Some( n ), Some( d ) ) = ( numer.to_i64(), denom.to_i64() ) {
                let exact = MIN_EXACT_INT..=MAX_EXACT_INT;
                if exact.contains( &n ) && exact.contains( &d ) {
                    return n.to_f64().unwrap() / d.to_f64().unwrap();
                }
            }
           
           
           
           
            let mut numer = numer.abs();
            let mut denom = denom.abs();
            let ( is_diff_positive, absolute_diff ) = match numer.bits().checked_sub( denom.bits() ) {
                Some( diff ) => ( true, diff ),
                None => ( false, denom.bits() - numer.bits() ),
            };

           
           
            if is_diff_positive && absolute_diff > MAX_EXP as u64 {
                return INFINITY * flo_sign;
            }
            if !is_diff_positive && absolute_diff > -MIN_EXP as u64 + MANTISSA_DIGITS as u64 + 1 {
                return 0.0 * flo_sign;
            }
            let diff = if is_diff_positive {
                absolute_diff.to_isize().unwrap()
            } else {
                -absolute_diff.to_isize().unwrap()
            };

           
           
            let shift: isize = diff.max( MIN_EXP as isize ) - MANTISSA_DIGITS as isize - 2;
            if shift >= 0 {
                denom <<= shift as usize
            } else {
                numer <<= -shift as usize
            };

            let ( quotient, remainder ) = numer.div_rem( &denom );

           
            let mut quotient = quotient.to_u64().unwrap();
            let n_rounding_bits = {
                let quotient_bits = 64 - quotient.leading_zeros() as isize;
                let subnormal_bits = MIN_EXP as isize - shift;
                quotient_bits.max( subnormal_bits ) - MANTISSA_DIGITS as isize
            } as usize;
            debug_assert!( n_rounding_bits == 2 || n_rounding_bits == 3 );
            let rounding_bit_mask = ( 1u64 << n_rounding_bits ) - 1;

           
           
            let ls_bit = quotient & ( 1u64 << n_rounding_bits ) != 0;
            let ms_rounding_bit = quotient & ( 1u64 << ( n_rounding_bits - 1 ) ) != 0;
            let ls_rounding_bits = quotient & ( rounding_bit_mask >> 1 ) != 0;
            if ms_rounding_bit && ( ls_bit || ls_rounding_bits || !remainder.is_zero() ) {
                quotient += 1u64 << n_rounding_bits;
            }
            quotient &= !rounding_bit_mask;

           
           
            let q_float = quotient as f64 * flo_sign;
            ldexp( q_float, shift as i32 )
        }

        fn ldexp( x: f64, exp: i32 ) -> f64
        {
            use ::f64::{INFINITY, MANTISSA_DIGITS, MAX_EXP, RADIX};

            assert_eq!( 
                RADIX, 2,
                "only floating point implementations with radix 2 are supported"
             );

            const EXPONENT_MASK: u64 = 0x7ff << 52;
            const MAX_UNSIGNED_EXPONENT: i32 = 0x7fe;
            const MIN_SUBNORMAL_POWER: i32 = MANTISSA_DIGITS as i32;

            if x.is_zero() || x.is_infinite() || x.is_nan() {
                return x;
            }
           
            if exp > 3 * MAX_EXP {
                return INFINITY * x.signum();
            } else if exp < -3 * MAX_EXP {
                return 0.0 * x.signum();
            }
           
            let ( bits, curr_exp ) = if !x.is_normal() {
               
               
                let normal_x = x * 2f64.powi( MIN_SUBNORMAL_POWER );
                let bits = normal_x.to_bits();
               
                ( 
                    bits,
                    ( ( bits & EXPONENT_MASK ) >> 52 ) as i32 - MIN_SUBNORMAL_POWER,
                )
            } else {
                let bits = x.to_bits();
                let curr_exp = ( bits & EXPONENT_MASK ) >> 52;
               
                ( bits, curr_exp as i32 )
            };

           
           
            let new_exp = curr_exp + exp;

            if new_exp > MAX_UNSIGNED_EXPONENT {
                INFINITY * x.signum()
            } else if new_exp > 0 {
               
                let new_bits = ( bits & !EXPONENT_MASK ) | ( ( new_exp as u64 ) << 52 );
                f64::from_bits( new_bits )
            } else if new_exp >= -( MANTISSA_DIGITS as i32 ) {
               
               
               
               
                let new_exp = new_exp + MIN_SUBNORMAL_POWER;
                debug_assert!( new_exp >= 0 );
                let new_bits = ( bits & !EXPONENT_MASK ) | ( ( new_exp as u64 ) << 52 );
                f64::from_bits( new_bits ) * 2f64.powi( -MIN_SUBNORMAL_POWER )
            } else {
               
                return 0.0 * x.signum();
            }
        }
        
        pub fn frac_from_whole_and_dec( whole: BigInt, decimal: BigInt, dec_len: usize ) -> BigRational
        {
            let denom = ::num::traits::pow( BigInt::from_u8( 10 ).unwrap(), dec_len );
            BigRational::new( whole, 1.into() ) + BigRational::new( decimal, denom )
        }
    }
}

pub mod map
{
    /*!
    Mapping Functionality*/
    use ::
    {
        sync::{ LockResult, PoisonError, TryLockError, TryLockResult },
        system::
        {
            common::
            {
                terminal::{ Terminal, TerminalReadGuard },
            },
        },
        *,
    };
    /*
    use crate::screen::{Screen, ScreenReadGuard};
    use crate::terminal::{Terminal, TerminalReadGuard};
    use crate::util::char_width;
    */
    pub fn map_lock_result<F, T, U>( res: LockResult<T>, f: F ) -> LockResult<U>  where 
    F:FnOnce( T ) -> U
    {
        match res 
        {
            Ok( t ) => Ok( f( t ) ),
            Err( e ) => Err( PoisonError::new( f( e.into_inner() ) ) ),
        }
    }

    pub fn map_try_lock_result<F, T, U>( res: TryLockResult<T>, f: F ) -> TryLockResult<U> where
    F: FnOnce( T ) -> U
    {
        match res
        {
            Ok( t ) => Ok( f( t ) ),
            Err( TryLockError::Poisoned( p ) ) => Err( TryLockError::Poisoned( PoisonError::new( f( p.into_inner() ) ) ) ),
            Err( TryLockError::WouldBlock ) => Err( TryLockError::WouldBlock ),
        }
    }

    pub fn map2_lock_result<F, T, U, R>( res: LockResult<T>, res2: LockResult<U>, f: F ) -> LockResult<R> where
    F: FnOnce( T, U ) -> R
    {
        match ( res, res2 )
        {
            ( Ok( a ), Ok( b ) ) => Ok( f( a, b ) ),
            ( Ok( a ), Err( b ) ) => Err( PoisonError::new( f( a, b.into_inner() ) ) ),
            ( Err( a ), Ok( b ) ) => Err( PoisonError::new( f( a.into_inner(), b ) ) ),
            ( Err( a ), Err( b ) ) => Err( PoisonError::new( f( a.into_inner(), b.into_inner() ) ) ),
        }
    }

    pub fn map2_try_lock_result<F,T,U,R>( res:TryLockResult<T>, res2:TryLockResult<U>, f:F ) -> TryLockResult<R> where
    F: FnOnce( T, U ) -> R
    {
        match ( res, res2 )
        {
            ( Ok( a ), Ok( b ) ) => Ok( f( a, b ) ),
            
            ( Err( TryLockError::WouldBlock ), _ ) => Err( TryLockError::WouldBlock ),
            
            ( _, Err( TryLockError::WouldBlock ) ) => Err( TryLockError::WouldBlock ),
            
            ( Ok( a ), Err( TryLockError::Poisoned( b ) ) ) => 
            Err( TryLockError::Poisoned( PoisonError::new( f( a, b.into_inner() ) ) ) ),
            
            ( Err( TryLockError::Poisoned( a ) ), Ok( b ) ) => 
            Err( TryLockError::Poisoned( PoisonError::new( f( a.into_inner(), b ) ) ) ),
            
            ( Err( TryLockError::Poisoned( a ) ), Err( TryLockError::Poisoned( b ) ) ) => 
            Err( TryLockError::Poisoned( PoisonError::new( f( a.into_inner(), b.into_inner() ) ) ) ),
        }
    }
}

pub mod mem
{
    pub use std::mem::{ * };
}

pub mod now
{
    /*!
    */
    use ::
    {
        collections::{ HashMap },
        io::{ self, Read, Write },
        shell::{ self, Shell },
        types::{ * },
        *,
    };
    /*
    */

    pub fn run_procs_for_non_tty( sh: &mut Shell)
    {
        let mut buffer = String::new();
        let stdin = io::stdin();
        let mut handle = stdin.lock();

        match handle.read_to_string( &mut buffer )
        {
            Ok(_ ) =>
            {
                /*log!( "run non tty command: {}", &buffer ); */
                run_command_line( sh, &buffer, false, false );
            }
            
            Err( e ) => { println!( ":: stdin.read_to_string() failed: {:?}", e ); }
        }
    }

    pub fn run_command_line( sh: &mut Shell, line: &str, tty: bool, capture: bool ) -> Vec<CommandResult>
    {
        let mut cr_list = Vec::new();
        let mut status = 0;
        let mut sep = String::new();

        for token in parsers::parser_line::line_to_cmds(line )
        {
            if token == ";" || token == "&&" || token == "||"
            {
                sep = token.clone();
                continue;
            }

            if sep == "&&" && status != 0 { break; }

            if sep == "||" && status == 0 { break; }

            let cmd = token.clone();
            let cr = run_proc( sh, &cmd, tty, capture );
            status = cr.status;
            sh.previous_status = status;
            cr_list.push( Cr );
        }

        cr_list
    }

    fn line_to_tokens( sh: &mut Shell, line: &str ) -> ( Tokens, HashMap<String, String> )
    {
        let linfo = parsers::parser_line::parse_line(line );
        let mut tokens = linfo.tokens;
        shell::do_expansion( sh, &mut tokens );
        let envs = drain_env_tokens( &mut tokens );
        ( tokens, envs )
    }

    fn set_shell_vars( sh: &mut Shell, envs: &HashMap<String, String>)
    {
        for ( name, value ) in envs.iter()
        {
            sh.set_env( name, value );
        }
    }

    fn run_proc( sh: &mut Shell, line: &str, tty: bool, capture:bool ) -> CommandResult
    {
        let log_cmd = !sh.cmd.starts_with(' ');
        match CommandLine::from_line(line, sh )
        {
            Ok( cl ) =>
            {
                if cl.is_empty()
                {
                    if !cl.envs.is_empty() { set_shell_vars( sh, &cl.envs ); }

                    return CommandResult::new();
                }

                let ( term_given, cr ) = run_pipeline( sh, &cl, tty, capture, log_cmd );
                
                if term_given
                {
                    unsafe
                    {
                        let gid = system::api::getpgid( 0 );
                        ::system::terminal::give_to( gid );
                    }
                }

                cr
            }

            Err( e ) =>
            {
                println_stderr!( ":: {}", e );
                CommandResult::from_status(0, 1)
            }
        }
    }

    fn run_with_shell( sh: &mut Shell, line:&str ) -> CommandResult
    {
        let ( tokens, envs ) = line_to_tokens( sh, line );

        if tokens.is_empty()
        {
            set_shell_vars( sh, &envs );
            return CommandResult::new();
        }

        match CommandLine::from_line(line, sh )
        {
            Ok( c ) =>
            {
                let ( term_given, cr ) = run_pipeline( sh, &c, false, true, false );
                if term_given
                {
                    unsafe
                    {
                        let gid = system::api::getpgid( 0 );
                        system::terminal::give_to( gid );
                    }
                }

                cr
            }

            Err( e ) =>
            {
                println_stderr!( ":: {}", e );
                CommandResult::from_status(0, 1)
            }
        }
    }

    pub fn run(line:&str ) -> CommandResult
    {
        let mut sh = Shell::new();
        run_with_shell( &mut sh, line )
    }

    fn try_run_builtin_in_subprocess
    (
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<i32>
    {
        if let Some( cr ) = try_run_builtin( sh, cl, idx_cmd, capture ) { return Some( cr.status ); }

        None
    }

    fn try_run_builtin
    (
        sh: &mut Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        capture: bool,
    ) -> Option<CommandResult>
    {
        let capture = capture && idx_cmd + 1 == cl.commands.len();

        if idx_cmd >= cl.commands.len()
        {
            println_stderr!( "unexpected error in try_run_builtin" );
            return None;
        }

        let cmd = &cl.commands[idx_cmd];
        let tokens = cmd.tokens.clone();
        let cname = tokens[0].1.clone();

        if cname == "alias"
        {
            let cr = ::api::run_alias( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "bg"
        {
            let cr = ::api::run_bg( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "cd"
        {
            let cr = ::api::run_cd( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "cinfo"
        {
            let cr = ::api::run_info( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "exec"
        {
            let cr = ::api::run_exec( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "exit"
        {
            let cr = ::api::run_exit( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "export"
        {
            let cr = ::api::run_export( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "fg"
        {
            let cr = ::api::run_fg( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "history"
        {
            let cr = ::api::run_history( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "jobs"
        {
            let cr = ::api::run_jobs( sh, cl, cmd, capture );
            return Some( cr );
        
        }
        
        else if cname == "minfd"
        {
            let cr = ::api::run_minfd( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "read"
        {
            let cr = ::api::run_read( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "set"
        {
            let cr = ::api::run_set( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "source"
        {
            let cr = ::api::run_source( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "ulimit"
        {
            let cr = ::api::run_ulimit( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "unalias"
        {
            let cr = ::api::run_unalias( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "unset"
        {
            let cr = ::api::run_unset( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "unpath"
        {
            let cr = ::api::run_unpath( sh, cl, cmd, capture );
            return Some( cr );
        }
        
        else if cname == "vox"
        {
            let cr = ::api::run_vox( sh, cl, cmd, capture );
            return Some( cr );
        }

        None
    }

    pub fn run_pipeline
    (
        sh: &mut shell::Shell,
        cl: &CommandLine,
        tty: bool,
        capture: bool,
        log_cmd: bool,
    ) -> ( bool, CommandResult )
    {
        let mut term_given = false;
        if cl.background && capture
        {
            println_stderr!( ":: cannot capture output of background cmd" );
            return ( term_given, CommandResult::error() );
        }
        /*
        if let Some( cr ) = try_run_calculator( &cl.line, capture ) {
            return ( term_given, cr );
        } */
        
        if let Some( cr ) = try_run_func( sh, cl, capture, log_cmd ) {
            return ( term_given, cr );
        }
        /*
        if log_cmd {
            log!( "run: {}", cl.line );
        } */

        let length = cl.commands.len();
        if length == 0 {
            println!( ":: invalid command: cmds with empty length" );
            return ( false, CommandResult::error() );
        }

        let mut pipes = Vec::new();
        let mut errored_pipes = false;
        for _ in 0..length - 1 {
            match pipe() {
                Ok( fds ) => pipes.push( fds ),
                Err( e ) => {
                    errored_pipes = true;
                    println_stderr!( ":: pipeline1: {}", e );
                    break;
                }
            }
        }

        if errored_pipes
        {
            for fds in pipes
            {
                ::process::close( fds.0);
                ::process::close( fds.1);
            }
            return ( false, CommandResult::error() );
        }

        if pipes.len() + 1 != length {
            println!( ":: invalid command: unmatched pipes count" );
            return ( false, CommandResult::error() );
        }

        let mut pgid: i32 = 0;
        let mut fg_pids: Vec<i32> = Vec::new();

        let isatty = if tty { unsafe { is::tty(1) == 1 } }
        else { false };

        let options = CommandOptions
        {
            isatty,
            capture_output: capture,
            background: cl.background,
            envs: cl.envs.clone(),
        };

        let mut fds_capture_stdout = None;
        let mut fds_capture_stderr = None;
        if capture
        {
            match ::process::pipe()
            {
                Ok( fds ) => fds_capture_stdout = Some( fds ),
                Err( e ) => {
                    println_stderr!( ":: pipeline2: {}", e );
                    return ( false, CommandResult::error() );
                }
            }

            match pipe()
            {
                Ok( fds ) => fds_capture_stderr = Some( fds ),
                Err( e ) =>
                {
                    if let Some( fds ) = fds_capture_stdout
                    {
                        process::close( fds.0);
                        process::close( fds.1);
                    }

                    println_stderr!( ":: pipeline3: {}", e );
                    return ( false, CommandResult::error() );
                }
            }
        }

        let mut cmd_result = CommandResult::new();
        for i in 0..length
        {
            let child_id: i32 = run_single_program(
                sh,
                cl,
                i,
                &options,
                &mut pgid,
                &mut term_given,
                &mut cmd_result,
                &pipes,
                &fds_capture_stdout,
                &fds_capture_stderr,
            );

            if child_id > 0 && !cl.background {
                fg_pids.push( Child_id );
            }
        }

        if cl.is_single_and_builtin() {
            return ( false, cmd_result );
        }

        if cl.background {
            if let Some(job) = sh.get_job_by_gid( pgid ) {
                println_stderr!( "[{}] {}", job.id, job.gid );
            }
        }

        if !fg_pids.is_empty()
        {
            let _cr = process::wait_fg_job( sh, pgid, &fg_pids );
            if !capture
            {
                cmd_result = _cr;
            }
        }
        
        ( term_given, cmd_result )
    }

    fn run_single_program
    (
        sh: &mut shell::Shell,
        cl: &CommandLine,
        idx_cmd: usize,
        options: &CommandOptions,
        pgid: &mut i32,
        term_given: &mut bool,
        cmd_result: &mut CommandResult,
        pipes:&[(RawFd, RawFd )],
        fds_capture_stdout: &Option<(RawFd, RawFd )>,
        fds_capture_stderr: &Option<(RawFd, RawFd )>,
    ) -> i32
    {
        let capture = options.capture_output;
        if cl.is_single_and_builtin()
        {
            if let Some( cr ) = try_run_builtin( sh, cl, idx_cmd, capture )
            {
                *cmd_result = cr;
                return unsafe { getpid() };
            }
            /*
            println_stderr!( ":: error when run singler builtin" );
            log!( "error when run singler builtin: {:?}", cl); */
            return 1;
        }

        let pipes_count = pipes.len();
        let mut fds_stdin = None;
        let cmd = cl.commands.get(idx_cmd ).unwrap();

        if cmd.has_here_string()
        {
            match pipe()
            {
                Ok( fds ) => fds_stdin = Some( fds ),
                Err( e ) =>
                {
                    println_stderr!( ":: pipeline4: {}", e );
                    return 1;
                }
            }
        }

        match process::fork()
        {
            Ok(ForkResult::Child ) =>
            {
                unsafe
                {
                    signal( SIGTSTP, SIG_DFL);
                    signal( SIGQUIT, SIG_DFL);
                }
                
                if idx_cmd > 0
                {
                    for i in 0..idx_cmd - 1
                    {
                        let fds = pipes[i];
                        process::close( fds.0);
                        process::close( fds.1);
                    }
                }
                
                for i in idx_cmd + 1..pipes_count
                {
                    let fds = pipes[i];
                    process::close( fds.0);
                    process::close( fds.1);
                }
                
                if idx_cmd < pipes_count
                {
                    if let Some( fds ) = fds_capture_stdout
                    {
                        process::close( fds.0);
                        process::close( fds.1);
                    }

                    if let Some( fds ) = fds_capture_stderr
                    {
                        process::close( fds.0);
                        process::close( fds.1);
                    }
                }

                if idx_cmd == 0 
                {
                    unsafe {
                        let pid = getpid();
                        setpgid(0, pid );
                    }
                }
                
                else
                {
                    unsafe { setpgid(0, *pgid ); }
                }
                
                if idx_cmd > 0
                {
                    let fds_prev = pipes[idx_cmd - 1];
                    process::dup2( fds_prev.0, 0);
                    process::close( fds_prev.0);
                    process::close( fds_prev.1);
                }

                if idx_cmd < pipes_count
                {
                    let fds = pipes[idx_cmd];
                    process::dup2( fds.1, 1);
                    process::close( fds.1);
                    process::close( fds.0);
                }

                if cmd.has_redirect_from()
                {
                    if let Some( redirect_from) = &cmd.redirect_from
                    {
                        let fd = getg::fd_from_file( &redirect_from.clone().1);
                        if fd == -1 {
                            process::exit(1);
                        }

                        process::dup2( fd, 0);
                        process::close( fd );
                    }
                }

                if cmd.has_here_string()
                {
                    if let Some( fds ) = fds_stdin
                    {
                        process::close( fds.1);
                        process::dup2( fds.0, 0);
                        process::close( fds.0);
                    }
                }

                let mut stdout_redirected = false;
                let mut stderr_redirected = false;
                
                for item in &cmd.redirects_to
                {
                    let from_ = &item.0;
                    let op_ = &item.1;
                    let to_ = &item.2;
                    if to_ == "&1" && from_ == "2"
                    {
                        if idx_cmd < pipes_count
                        {
                            process::dup2(1, 2);
                        }
                        
                        else if !options.capture_output
                        {
                            let fd = process::dup(1);
                            if fd == -1 {
                                println_stderr!( ":: dup error" );
                                process::exit(1);
                            }
                            process::dup2( fd, 2);
                        }

                        else { }
                    }
                    
                    else if to_ == "&2" && from_ == "1"
                    {
                        if idx_cmd < pipes_count || !options.capture_output {
                            let fd = process::dup(2);
                            if fd == -1 {
                                println_stderr!( ":: dup error" );
                                process::exit(1);
                            }
                            process::dup2( fd, 1);
                        }
                        
                        else { }
                    }
                    
                    else
                    {
                        let append = op_ == ">>";
                        match fs::create_raw_fd_from_file( to_, append )
                        {
                            Ok( fd ) =>
                            {
                                if fd == -1
                                {
                                    println_stderr!( ":: fork: fd error" );
                                    process::exit(1);
                                }

                                if from_ == "1"
                                {
                                    process::dup2( fd, 1);
                                    stdout_redirected = true;
                                }
                                
                                else
                                {
                                    process::dup2( fd, 2);
                                    stderr_redirected = true;
                                }
                            }

                            Err( e ) =>
                            {
                                println_stderr!( ":: fork: {}", e );
                                process::exit(1);
                            }
                        }
                    }
                }
                
                if idx_cmd == pipes_count && options.capture_output {
                    if !stdout_redirected {
                        if let Some( fds ) = fds_capture_stdout {
                            libs::close( fds.0);
                            libs::dup2( fds.1, 1);
                            libs::close( fds.1);
                        }
                    }
                    if !stderr_redirected {
                        if let Some( fds ) = fds_capture_stderr {
                            libs::close( fds.0);
                            libs::dup2( fds.1, 2);
                            libs::close( fds.1);
                        }
                    }
                }

                if cmd.is_builtin() {
                    if let Some( status ) = try_run_builtin_in_subprocess( sh, cl, idx_cmd, capture ) {
                        process::exit( status );
                    }
                }
                let mut c_envs: Vec<_> = env::vars()
                    .map(|(k, v)| {
                        CString::new( format!( "{}={}", k, v).as_str() ).expect( "CString error" )
                    })
                    .collect();
                for (key, value ) in cl.envs.iter() {
                    c_envs.push(
                        CString::new( format!( "{}={}", key, value ).as_str() ).expect( "CString error" ),
                    );
                }

                let program = &cmd.tokens[0].1;
                let path = if program.contains('/') {
                    program.clone()
                } else {
                    libs::path::find_file_in_path( program, true )
                };
                if path.is_empty() {
                    println_stderr!( ":: {}: command not found", program);
                    process::exit(127);
                }

                let c_program = CString::new( path.as_str() ).expect( "CString::new failed" );
                let c_args: Vec<_> = cmd
                    .tokens
                    .iter()
                    .map(|x| CString::new(x.1.as_str() ).expect( "CString error" ) )
                    .collect();

                let c_args: Vec<&CStr> = c_args.iter().map(|x| x.as_c_str() ).collect();
                let c_envs: Vec<&CStr> = c_envs.iter().map(|x| x.as_c_str() ).collect();
                match execve( &c_program, &c_args, &c_envs ) {
                    Ok(_ ) => {}
                    Err( e ) => match e {
                        nix::Error::ENOEXEC => { println_stderr!( ":: {}: exec format error (ENOEXEC)", program); }
                        nix::Error::ENOENT => { println_stderr!( ":: {}: file does not exist", program); }
                        nix::Error::EACCES => { println_stderr!( ":: {}: Permission denied", program); }
                        _ => { println_stderr!( ":: {}: {:?}", program, e ); }
                    },
                }

                process::exit(1);
            }
            Ok(ForkResult::Parent { child, .. }) => {
                let pid: i32 = child.into();
                if idx_cmd == 0 {
                    *pgid = pid;
                    unsafe {
                        if cfg!( target_os = "macos" ) {
                            loop {
                                let _pgid = libc::getpgid( pid );
                                if _pgid == pid {
                                    break;
                                }
                            }
                        }

                        if sh.has_terminal && options.isatty && !cl.background {
                            *term_given = shell::give_terminal_to( pid );
                        }
                    }
                }

                if options.isatty && !options.capture_output {
                    let _cmd = parsers::parser_line::tokens_to_line( &cmd.tokens );
                    sh.insert_job(*pgid, pid, &_cmd, "Running", cl.background );
                }

                if let Some( redirect_from) = &cmd.redirect_from {
                    if redirect_from.0 == "<<<" {
                        if let Some( fds ) = fds_stdin {
                            unsafe {
                                libs::close( fds.0);

                                let mut f = File::from_raw_fd( fds.1);
                                match f.write_all( redirect_from.1.clone().as_bytes() ) {
                                    Ok(_ ) => {}
                                    Err( e ) => println_stderr!( ":: write_all: {}", e ),
                                }
                                match f.write_all( b"\n" ) {
                                    Ok(_ ) => {}
                                    Err( e ) => println_stderr!( ":: write_all: {}", e ),
                                }
                            }
                        }
                    }
                }

                // (in parent ) close unused pipe ends
                if idx_cmd < pipes_count {
                    let fds = pipes[idx_cmd];
                    libs::close( fds.1);
                }
                if idx_cmd > 0 {
                    // close pipe end only after dupped in the child
                    let fds = pipes[idx_cmd - 1];
                    libs::close( fds.0);
                }

                if idx_cmd == pipes_count && options.capture_output {
                    let mut s_out = String::new();
                    let mut s_err = String::new();

                    unsafe {
                        if let Some( fds ) = fds_capture_stdout {
                            libs::close( fds.1);

                            let mut f = File::from_raw_fd( fds.0);
                            match f.read_to_string( &mut s_out ) {
                                Ok(_ ) => {}
                                Err( e ) => println_stderr!( ":: readstr: {}", e ),
                            }
                        }
                        if let Some( fds ) = fds_capture_stderr {
                            libs::close( fds.1);
                            let mut f_err = File::from_raw_fd( fds.0);
                            match f_err.read_to_string( &mut s_err ) {
                                Ok(_ ) => {}
                                Err( e ) => println_stderr!( ":: readstr: {}", e ),
                            }
                        }
                    }

                    *cmd_result = CommandResult {
                        gid: *pgid,
                        status: 0,
                        stdout: s_out.clone(),
                        stderr: s_err.clone(),
                    };
                }

                pid
            }

            Err(_ ) => {
                println_stderr!( "Fork failed" );
                *cmd_result = CommandResult::error();
                0
            }
        }
    }

    fn try_run_func
    (
        sh: &mut Shell,
        cl: &CommandLine,
        capture: bool,
        log_cmd: bool,
    ) -> Option<CommandResult>
    {
        if cl.is_empty() { return None; }

        let command = &cl.commands[0];

        if let Some( func_body) = sh.get_func( &command.tokens[0].1)
        {
            let mut args = vec!["cicada".to_string()];
            
            for token in &command.tokens
            {
                args.push( token.1.to_string() );
            }
            /*
            if log_cmd {
                log!( "run func: {:?}", &args );
            }*/

            let cr_list = scripts::run_lines( sh, &func_body, &args, capture );
            let mut stdout = String::new();
            let mut stderr = String::new();
            
            for cr in cr_list
            {
                stdout.push_str( cr.stdout.trim() );
                stdout.push(' ');
                stderr.push_str( cr.stderr.trim() );
                stderr.push(' ');
            }

            let mut cr = CommandResult::new();
            cr.stdout = stdout;
            cr.stderr = stderr;
            return Some( cr );
        }

        None
    }
}

pub mod objects
{
    /*!
    Object | A hashmap of keys to values,  where values can be any type, including other objects. */
    use ::
    {
        arrays::{ Arr },
        collections::{ hash_map::{Iter, Keys, Values}, HashMap },
        error::{ OverError },
        fmt::{ Format },
        num::
        {
            big::{ BigInt },
            rational::{ BigRational },
            traits::{ Zero },
        },
        result::{ OverResult },
        str::{ FromStr },
        sync::{ Arc, atomic::{ AtomicUsize, Ordering } },
        tuples::{ Tup },
        types::{ Type },
        values::{ Value },
        *,
    };
    /*
    */
    lazy_static! 
    {
        static ref CUR_ID: AtomicUsize = AtomicUsize::new( 0 );
    }

    fn get_id() -> usize 
    {
        CUR_ID.fetch_add( 1, Ordering::Relaxed )
    }

    #[derive( Clone, Debug )]
    struct ObjInner 
    {
        map: HashMap<String, Value>,
        parent:Option<Obj>,
        id: usize,
    }

    #[derive( Clone, Debug )]
    pub struct Obj 
    {
        inner: Arc<ObjInner>,
    }

    macro_rules! get_fn 
    {
        ( $doc:expr, $name:tt, $type:ty ) => {
            #[doc=$doc]
            pub fn $name( &self, field:&str ) -> OverResult<$type> {
                match self.get( field ) {
                    Some( value ) => {
                        match value.$name() {
                            Ok( result ) => Ok( result ),
                            e @ Err( _ ) => e,
                        }
                    }
                    None => Err( OverError::FieldNotFound( field.into() ) ),
                }
            }
        }
    }

    impl Obj 
    {
        pub fn read( &self, field:&str ) -> Result<Value, ()> 
        {
            match self.inner.map.get( field )
            {
                Some( value ) => Ok( value.clone() ),
                None => match self.inner.parent
                {
                    Some( ref parent ) => Ok( parent.get( field ).unwrap_or( Value::Null ) ),
                    None => Err( () ),
                },
            }
        }

        pub fn from_map( obj_map: HashMap<String, Value> ) -> OverResult<Obj> 
        {
            for field in obj_map.keys() {
                if !Self::is_valid_field( field ) {
                    return Err( OverError::InvalidFieldName( ( *field ).clone() ) );
                }
            }
            let id = get_id();

            Ok( Obj {
                inner: Arc::new( ObjInner {
                    map: obj_map,
                    parent: None,
                    id,
                } ),
            } )
        }

        pub fn from_map_with_parent( obj_map: HashMap<String, Value>, parent: Obj ) -> OverResult<Obj> 
        {
            for field in obj_map.keys() {
                if !Self::is_valid_field( field ) {
                    return Err( OverError::InvalidFieldName( field.clone() ) );
                }
            }
            let id = get_id();

            Ok( Obj {
                inner: Arc::new( ObjInner {
                    map: obj_map,
                    parent: Some( parent ),
                    id,
                } ),
            } )
        }

        pub fn from_map_unchecked( obj_map: HashMap<String, Value> ) -> Obj 
        {
            let id = get_id();

            Obj {
                inner: Arc::new( ObjInner {
                    map: obj_map,
                    parent: None,
                    id,
                } ),
            }
        }

        pub fn from_map_with_parent_unchecked( obj_map: HashMap<String, Value>, parent: Obj ) -> Obj 
        {
            let id = get_id();

            Obj {
                inner: Arc::new( ObjInner {
                    map: obj_map,
                    parent: Some( parent ),
                    id,
                } ),
            }
        }

        pub fn id( &self ) -> usize 
        {
            self.inner.id
        }

        pub fn map_ref( &self ) -> &HashMap<String, Value> 
        {
            &self.inner.map
        }

        pub fn from_file( path:&str ) -> OverResult<Obj> 
        {
            Ok( parses::load_from_file( path )? )
        }

        pub fn write_to_file( &self, path:&str ) -> OverResult<()>
        {
            str::write_file_from( path, &self.write_str() )?;
            Ok( () )
        }

        pub fn write_str( &self ) -> String 
        {
            self.format( false, 0 )
        }

        pub fn with_each<F>( &self, mut f: F ) where
        F: FnMut( &String, &Value ),
        {
            for ( field, value ) in &self.inner.map {
                f( field, value )
            }
        }

        pub fn len( &self ) -> usize 
        {
            self.inner.map.len()
        }

        pub fn is_empty( &self ) -> bool 
        {
            self.inner.map.is_empty()
        }

        pub fn ptr_eq( &self, other:&Self ) -> bool 
        {
            Arc::ptr_eq( &self.inner, &other.inner )
        }

        pub fn contains( &self, field:&str ) -> bool 
        {
            self.inner.map.contains_key( field )
        }

        pub fn get( &self, field:&str ) -> Option<Value> 
        {
            match self.inner.map.get( field ) {
                Some( value ) => Some( value.clone() ),
                None => match self.inner.parent {
                    Some( ref parent ) => parent.get( field ),
                    None => None,
                },
            }
        }

        pub fn get_with_source( &self, field:&str ) -> Option<( Value, Obj )> 
        {
            match self.inner.map.get( field ) {
                Some( value ) => Some( ( value.clone(), self.clone() ) ),
                None => match self.inner.parent {
                    Some( ref parent ) => parent.get_with_source( field ),
                    None => None,
                },
            }
        }

        get_fn!
        ( 
            "Returns the `bool` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Bool`.",
            get_bool,
            bool
         );

        get_fn!
        ( 
            "Returns the `BigInt` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Int`.",
            get_int,
            BigInt
         );

        get_fn!
        ( 
            "Returns the `BigRational` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Frac`.",
            get_frac,
            BigRational
         );

        get_fn!
        ( 
            "Returns the `char` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Char`.",
            get_char,
            char
         );

        get_fn!
        ( 
            "Returns the `String` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Str`.",
            get_str,
            String
         );

        get_fn!
        ( 
            "Returns the `Arr` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Arr`.",
            get_arr,
            Arr
         );

        get_fn!
        ( 
            "Returns the `Tup` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Tup`.",
            get_tup,
            Tup
         );

        get_fn!
        ( 
            "Returns the `Obj` found at `field`. \
            Returns an error if the field was not found \
            or if the `Value` at `field` is not `Obj`.",
            get_obj,
            Obj
         );

        pub fn has_parent( &self ) -> bool 
        {
            self.inner.parent.is_some()
        }

        pub fn get_parent( &self ) -> Option<Obj> 
        {
            match self.inner.parent {
                Some( ref parent ) => Some( parent.clone() ),
                None => None,
            }
        }

        pub fn is_valid_field( field:&str ) -> bool 
        {
            let mut first = true;

            for ch in field.chars() {
                if first {
                    if !Self::is_valid_field_char( ch, true ) {
                        return false;
                    }
                    first = false;
                } else if !Self::is_valid_field_char( ch, false ) {
                    return false;
                }
            }
            true
        }

        pub fn is_valid_field_char( ch:char, first: bool ) -> bool 
        {
            match ch 
            {
                ch if ch.is_alphabetic() => true,
                ch if is::digit( ch ) => !first,
                '_' => true,
                '^' => first,
                _ => false,
            }
        }

        pub fn keys( &self ) -> Keys<String, Value> 
        {
            self.map_ref().keys()
        }

        pub fn values( &self ) -> Values<String, Value> 
        {
            self.map_ref().values()
        }

        pub fn iter( &self ) -> Iter<String, Value> 
        {
            self.map_ref().iter()
        }
    }

    impl Default for Obj 
    {
        fn default() -> Self {
            Self::from_map_unchecked( map! {} )
        }
    }

    impl fmt::Display for Obj 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            write!( f, "{}", self.format( true, INDENT_STEP ) )
        }
    }

    impl FromStr for Obj 
    {
        type Err = OverError;

        fn from_str( s:&str ) -> Result<Self, Self::Err> 
        {
            Ok( parses::load_from_str( s )? )
        }
    }
    impl PartialEq for Obj 
    {
        fn eq( &self, other:&Self ) -> bool {
            let inner = &self.inner;
            let other_inner = &other.inner;

           
            if inner.parent.is_some() && other_inner.parent.is_some() {
                let parent = self.get_parent().unwrap();
                let other_parent = other.get_parent().unwrap();
                if parent != other_parent {
                    return false;
                }
            } else if !( inner.parent.is_none() && other_inner.parent.is_none() ) {
                return false;
            }
           
            inner.map == other_inner.map
        }
    }
}

pub mod ops
{
    pub use std::ops::{ * };


    pub trait RangeArgument<T>
    {

        fn start( &self ) -> Option<&T> { None }

        fn end( &self ) -> Option<&T> { None }
    }

    impl<T> RangeArgument<T> for Range<T>
    {
        fn start( &self ) -> Option<&T> { Some( &self.start ) }
        fn end( &self ) -> Option<&T> { Some( &self.end ) }
    }

    impl<T> RangeArgument<T> for RangeFrom<T>
    {
        fn start( &self ) -> Option<&T> { Some( &self.start ) }
    }

    impl<T> RangeArgument<T> for RangeTo<T>
    {
        fn end( &self ) -> Option<&T> { Some( &self.end ) }
    }

    impl<T> RangeArgument<T> for RangeFull {}
}

pub mod os
{
    pub use std::os::{ * };
}

pub mod option
{
    pub use std::option::{ * };
}

pub mod panic
{
    pub use std::panic::{ * };
}

pub mod parses
{
    /*!
    */
    use ::
    {
        arrays::{ self, Arr },
        char::{ CharStream },
        collections::{ HashMap, HashSet, VecDeque },
        error::{ parse::{ ParseErrorKind::{ * }, ParseError, parse_err } },
        num::
        {
            big::BigInt,
            rational::{ BigRational, frac_from_whole_and_dec },
            traits::{ ToPrimitive, Zero },
        },
        objects::{ Obj },
        ops::{ Deref },
        path::{ Path },
        result::{ ParseResult },
        tuples::{ Tup },
        types::{ Type },
        values::{ Value },
        *,
    };
    /*
    */
    type ObjMap = HashMap<String, Value>;
    type GlobalMap = HashMap<String, Value>;
    type IncludedMap = ( HashMap<String, Value>, HashSet<String> );

    lazy_static! 
    {
        static ref OBJ_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
        static ref STR_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
        static ref ARR_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
        static ref TUP_SENTINEL: Obj = Obj::from_map_unchecked( HashMap::new() );
    }
    pub const MAX_DEPTH: usize = 64;

    pub fn load_from_file( path:&str ) -> ParseResult<Obj>
    {
        object_file( path )
    }

    pub fn load_from_str( contents:&str ) -> ParseResult<Obj>
    {
        object_from_str( contents )
    }

   
    pub fn object_file( path:&str ) -> ParseResult<Obj>
    {
        let stream = CharStream::from_file( path )?;
        parse_obj_stream( stream, &mut ( HashMap::new(), HashSet::new() ) )
    }
   
    fn parse_obj_file_includes( path:&str, included:&mut IncludedMap ) -> ParseResult<Obj> {
        let stream = CharStream::from_file( path )?;
        parse_obj_stream( stream, included )
    }

   
    pub fn object_from_str( contents:&str ) -> ParseResult<Obj>
    {
        let contents = String::from( contents );
        let stream = CharStream::from_string( contents )?;
        parse_obj_stream( stream, &mut ( HashMap::new(), HashSet::new() ) )
    }

    #[inline] fn parse_obj_stream( mut stream: CharStream, mut included:&mut IncludedMap ) -> ParseResult<Obj> {
        let mut obj: ObjMap = HashMap::new();
       
        if !find_char( stream.clone() ) {
            return Ok( Obj::from_map_unchecked( obj ) );
        }

        let mut globals: GlobalMap = HashMap::new();
        let mut parent = None;

       
        while parse_field_value_pair( 
            &mut stream,
            &mut obj,
            &mut globals,
            &mut included,
            &mut parent,
            1,
            None,
        )? {}

        Ok( match parent {
            Some( parent ) => Obj::from_map_with_parent_unchecked( obj, parent ),
            None => Obj::from_map_unchecked( obj ),
        } )
    }
   
    fn parse_obj
    ( 
        mut stream:&mut CharStream,
        globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
    ) -> ParseResult<Value> 
    {
       
        if depth > MAX_DEPTH {
            return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) );
        }

       
        let ch = stream.next().unwrap();
        assert_eq!( ch, '{' );
       
        if !find_char( stream.clone() ) {
            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
        }

        let mut obj: ObjMap = HashMap::new();
        let mut parent = None;

       
        while parse_field_value_pair
        ( 
            &mut stream,
            &mut obj,
            globals,
            &mut included,
            &mut parent,
            depth,
            Some( '}' ),
        )? {}

        let obj = match parent 
        {
            Some( parent ) => Obj::from_map_with_parent_unchecked( obj, parent ),
            None => Obj::from_map_unchecked( obj ),
        };
        Ok( obj.into() )
    }

    #[inline] pub fn parse_field_value_pair
    ( 
        mut stream:&mut CharStream,
        obj:&mut ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        parent:&mut Option<Obj>,
        depth: usize,
        cur_brace:Option<char>,
    ) -> ParseResult<bool> 
    {
       
        let peek = stream.peek().unwrap();
        
        if peek == '}' && cur_brace.is_some() 
        {
            let _ = stream.next();
            return Ok( false );
        }
        
        else if is::end_delimiter( peek ) 
        {
            return parse_err( 
                stream.file(),
                InvalidClosingBracket( cur_brace, peek, stream.line(), stream.col() ),
             );
        }

       
        let ( field_line, field_col ) = ( stream.line(), stream.col() );

       
        let ( field, is_global, is_parent ) = parse_field( stream.clone(), field_line, field_col )?;

        if !is_global && !is_parent && obj.contains_key( &field ) {
            return parse_err( stream.file(), DuplicateField( field, field_line, field_col ) );
        } else if is_parent && parent.is_some() {
            return parse_err( 
                stream.file(),
                DuplicateField( "^".into(), field_line, field_col ),
             );
        }

       
        if !find_char( stream.clone() ) {
            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
        }

       
        let ( value_line, value_col ) = ( stream.line(), stream.col() );
        let value = parse_value( 
            &mut stream,
            obj,
            &mut globals,
            &mut included,
            value_line,
            value_col,
            depth,
            cur_brace,
            true,
        )?;
       
        if is_global {
            if globals.contains_key( &field ) {
                return parse_err( stream.file(), DuplicateGlobal( field, field_line, field_col ) );
            }
            globals.insert( field, value );
        } else if is_parent {
            let par = value
                .get_obj()
                .map_err( | e |ParseError::from_over( &e, stream.file(), value_line, value_col ) )?;
            *parent = Some( par );
        } else {
            obj.insert( field, value );
        }

       
        if !find_char( stream.clone() ) {
            match cur_brace {
                Some( _ ) => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
                None => return Ok( false ),
            }
        }

        Ok( true )
    }
   
    fn parse_arr_file( path:&str, mut included:&mut IncludedMap ) -> ParseResult<Arr> {
        let mut stream = CharStream::from_file( path )?;

        let obj: ObjMap = HashMap::new();
        let mut globals: GlobalMap = HashMap::new();

        let mut vec = Vec::new();
        let mut tcur = Type::Any;
        let mut has_any = true;

        loop {
           
            if !find_char( stream.clone() ) {
                break;
            }
           
            let ( value_line, value_col ) = ( stream.line(), stream.col() );
            let value = parse_value( 
                &mut stream,
                &obj,
                &mut globals,
                &mut included,
                value_line,
                value_col,
                1,
                None,
                true,
            )?;

            let tnew = value.get_type();

            if has_any {
                match Type::most_specific( &tcur, &tnew ) {
                    Some( ( t, any ) ) => {
                        tcur = t;
                        has_any = any;
                    }
                    None => {
                        return parse_err( 
                            stream.file(),
                            ExpectedType( tcur, tnew, value_line, value_col ),
                         );
                    }
                }
            } else if tcur != tnew {
                return parse_err( 
                    stream.file(),
                    ExpectedType( tcur, tnew, value_line, value_col ),
                 );
            }
            vec.push( value );
        }

        let arr = Arr::from_vec_unchecked( vec, tcur );

        Ok( arr )
    }
   
    fn parse_arr
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
    ) -> ParseResult<Value> 
    {
       
        if depth > MAX_DEPTH 
        {
            return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) );
        }

       
        let ch = stream.next().unwrap();
        assert_eq!( ch, '[' );

        let mut vec = Vec::new();
        let mut tcur = Type::Any;
        let mut has_any = true;

        loop 
        {
           
            if !find_char( stream.clone() ) 
            {
                return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
            }
            let peek = stream.peek().unwrap();
            if peek == ']' 
            {
                let _ = stream.next();
                break;
            } 
            
            else if is::end_delimiter( peek ) 
            {
                return parse_err( 
                    stream.file(),
                    InvalidClosingBracket( Some( ']' ), peek, stream.line(), stream.col() ),
                 );
            }
           
            let ( value_line, value_col ) = ( stream.line(), stream.col() );
            let value = parse_value( 
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                value_line,
                value_col,
                depth,
                Some( ']' ),
                true,
            )?;

            let tnew = value.get_type();

            if has_any {
                match Type::most_specific( &tcur, &tnew ) {
                    Some( ( t, any ) ) => {
                        tcur = t;
                        has_any = any;
                    }
                    None => {
                        return parse_err( 
                            stream.file(),
                            ExpectedType( tcur, tnew, value_line, value_col ),
                         );
                    }
                }
            } else if tcur != tnew {
                return parse_err( 
                    stream.file(),
                    ExpectedType( tcur, tnew, value_line, value_col ),
                 );
            }
            vec.push( value );
        }

        let arr = Arr::from_vec_unchecked( vec, tcur );

        Ok( arr.into() )
    }
   
    fn parse_tup_file( path:&str, mut included:&mut IncludedMap ) -> ParseResult<Tup> {
        let mut stream = CharStream::from_file( path )?;

        let mut vec: Vec<Value> = Vec::new();
        let obj: ObjMap = HashMap::new();
        let mut globals: GlobalMap = HashMap::new();

        loop {
           
            if !find_char( stream.clone() ) {
                break;
            }
           
            let ( value_line, value_col ) = ( stream.line(), stream.col() );
            let value = parse_value( 
                &mut stream,
                &obj,
                &mut globals,
                &mut included,
                value_line,
                value_col,
                1,
                None,
                true,
            )?;

            vec.push( value );
        }

        Ok( vec.into() )
    }
   
    fn parse_tup
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
    ) -> ParseResult<Value> 
    {        
        if depth > MAX_DEPTH 
        {
            return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) );
        }
        
        let ch = stream.next().unwrap();
        assert_eq!( ch, '(' );

        let mut vec = Vec::new();

        loop 
        {
            if !find_char( stream.clone() ) 
            {
                return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
            }
            let peek = stream.peek().unwrap();
            
            if peek == ')' 
            {
                let _ = stream.next();
                break;
            } 
            
            else if is::end_delimiter( peek )
            {
                return parse_err( 
                    stream.file(),
                    InvalidClosingBracket( Some( ')' ), peek, stream.line(), stream.col() ),
                 );
            }
           
            let ( value_line, value_col ) = ( stream.line(), stream.col() );
            let value = parse_value
            ( 
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                value_line,
                value_col,
                depth,
                Some( ')' ),
                true,
            )?;

            vec.push( value );
        }

        let tup = Tup::from_vec( vec );

        Ok( tup.into() )
    }
   
    fn parse_field
    ( 
        mut stream: CharStream,
        line: usize,
        col: usize,
    ) -> ParseResult<( String, bool, bool )> 
    {
        let mut field = String::new();
        let mut first = true;
        let mut is_global = false;

        let ch = stream.peek().unwrap();
        
        if ch == '@' {
            let ch = stream.next().unwrap();
            is_global = true;
            field.push( ch );
        }

        while let Some( ch ) = stream.next() 
        {
            match ch {
                ':' if !first => { break; }
                ch if Obj::is_valid_field_char( ch, first ) => field.push( ch ),
                ch => {
                    return parse_err( 
                        stream.file(),
                        InvalidFieldChar( ch, stream.line(), stream.col() - 1 ),
                     );
                }
            }
            first = false;
        }
       
        match field.as_str() 
        {
            _field_str if is::reserved( _field_str ) => 
            {
                parse_err( stream.file(), InvalidFieldName( field.clone(), line, col ) )
            }
            "^" => Ok( ( field.clone(), false, true ) ),
            bad if bad.starts_with( '^' ) => 
            {
                parse_err( stream.file(), InvalidFieldName( field.clone(), line, col ) )
            }
            _ => Ok( ( field.clone(), is_global, false ) ),
        }
    }
   
    fn parse_value
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        line: usize,
        col: usize,
        depth: usize,
        cur_brace:Option<char>,
        is_first: bool,
    ) -> ParseResult<Value> 
    {
       
        let res = match stream.peek().unwrap() 
        {
            '"' => parse_str( &mut stream )?,
            '\'' => parse_char( &mut stream )?,
            '{' => parse_obj( &mut stream, &mut globals, included, depth + 1 )?,
            '[' => parse_arr( &mut stream, obj, &mut globals, included, depth + 1 )?,
            '(' => parse_tup( &mut stream, obj, &mut globals, included, depth + 1 )?,
            '@' => parse_variable( 
                &mut stream,
                obj,
                globals,
                included,
                line,
                col,
                depth,
                cur_brace,
            )?,
            '<' => parse_include( &mut stream, obj, &mut globals, &mut included, depth + 1 )?,
            ch @ '+' | ch @ '-' => { parse_unary_op( &mut stream, obj, globals, included, depth, cur_brace, ch )? }
            ch if is::numeric_char( ch ) => parse_numeric( &mut stream, line, col )?,
            ch if Obj::is_valid_field_char( ch, true ) => parse_variable( 
                &mut stream,
                obj,
                globals,
                included,
                line,
                col,
                depth,
                cur_brace,
            )?,
            ch => { return parse_err( stream.file(), InvalidValueChar( ch, line, col ) ); }
        };
       
        if is_first 
        {
            let mut val_deque: VecDeque<( Value, usize, usize )> = VecDeque::new();
            let mut op_deque: VecDeque<char> = VecDeque::new();
            val_deque.push_back( ( res, line, col ) );

            loop 
            {
                match stream.peek()
                {
                    Some( ch ) if is::operator( ch ) => 
                    {
                        let _ = stream.next();
                        if stream.peek().is_none() {
                            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
                        }
                        let ( line2, col2 ) = ( stream.line(), stream.col() );

                       
                        let val2 = parse_value( 
                            &mut stream,
                            obj,
                            &mut globals,
                            &mut included,
                            line2,
                            col2,
                            depth,
                            cur_brace,
                            false,
                        )?;

                        if is::priority_operator( ch ) 
                        {
                            let ( val1, line1, col1 ) = val_deque.pop_back().unwrap();
                            let res = binary_op_on_values( stream, val1, val2, ch, line2, col2 )?;
                            val_deque.push_back( ( res, line1, col1 ) );
                        }
                        
                        else
                        {
                            val_deque.push_back( ( val2, line2, col2 ) );
                            op_deque.push_back( ch );
                        }
                    }
                    _ => break,
                }
            }
           
            check_value_end( stream, cur_brace )?;

            let ( mut val1, _, _ ) = val_deque.pop_front().unwrap();
            while !op_deque.is_empty() {
                let ( val2, line2, col2 ) = val_deque.pop_front().unwrap();
                val1 = binary_op_on_values( 
                    stream,
                    val1,
                    val2,
                    op_deque.pop_front().unwrap(),
                    line2,
                    col2,
                )?;
            }
            Ok( val1 )
        } 

        else 
        {
            Ok( res )
        }
    }

    fn parse_unary_op
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
        cur_brace:Option<char>,
        ch:char,
    ) -> ParseResult<Value> 
    {
        let _ = stream.next();
        let line = stream.line();
        let col = stream.col();

        let res = match stream.peek() {
            Some( _ ) => parse_value( 
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                line,
                col,
                depth + 1,
                cur_brace,
                false,
            )?,
            None => return parse_err( stream.file(), UnexpectedEnd( line ) ),
        };
        unary_op_on_value( stream, res, ch, line, col )
    }
   
    fn parse_numeric( stream:&mut CharStream, line: usize, col: usize ) -> ParseResult<Value> 
    {
        let mut s1 = String::new();
        let mut s2 = String::new();
        let mut dec = false;
        let mut under = false;

        while let Some( ch ) = stream.peek() {
            match ch {
                ch if is::value_end_char( ch ) => break,
                ch if is::digit( ch ) => {
                    if !dec {
                        s1.push( ch );
                    } else {
                        s2.push( ch );
                    }
                }
                '.' | ',' => {
                    if !dec {
                        dec = true;
                    } else {
                        return parse_err( 
                            stream.file(),
                            InvalidValueChar( ch, stream.line(), stream.col() ),
                         );
                    }
                }
                '_' => {
                    if !under {
                        under = true;
                    } else {
                        return parse_err( 
                            stream.file(),
                            InvalidValueChar( ch, stream.line(), stream.col() ),
                         );
                    }
                }
                _ => {
                    return parse_err( 
                        stream.file(),
                        InvalidValueChar( ch, stream.line(), stream.col() ),
                     );
                }
            }
            if ch != '_' {
                under = false;
            }
            let _ = stream.next();
        }

        if dec {
           
            if s1.is_empty() && s2.is_empty() {
                return parse_err( stream.file(), InvalidNumeric( line, col ) );
            }
            let whole: BigInt = if s1.is_empty() {
                0u8.into()
            } else {
                s1.parse()?
            };

           
            let s2 = s2.trim_end_matches( '0' );

            let ( decimal, dec_len ): ( BigInt, usize ) = if s2.is_empty() {
                ( 0u8.into(), 1 )
            } else {
                ( s2.parse()?, s2.len() )
            };

            let f = frac_from_whole_and_dec( whole, decimal, dec_len );
            Ok( f.into() )
        } else {
           
            if s1.is_empty() {
                return parse_err( stream.file(), InvalidNumeric( line, col ) );
            }
            let i: BigInt = s1.parse()?;
            Ok( i.into() )
        }
    }
   
    fn parse_variable
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        line: usize,
        col: usize,
        depth: usize,
        cur_brace:Option<char>,
    ) -> ParseResult<Value> 
    {
        let mut var = String::new();
        let mut is_global = false;
        let mut dot = false;
        let mut dot_global = false;

        let ch = stream.peek().unwrap();
        
        if ch == '@' {
            let ch = stream.next().unwrap();
            is_global = true;
            var.push( ch );
        }

        while let Some( ch ) = stream.peek() 
        {
            match ch 
            {
                '.' => {
                    let _ = stream.next();
                    match stream.peek() {
                        Some( '@' ) => dot_global = true,
                        Some( ch ) if Obj::is_valid_field_char( ch, true ) || is::numeric_char( ch ) => (),
                        Some( ch ) => {
                            return parse_err( 
                                stream.file(),
                                InvalidValueChar( ch, stream.line(), stream.col() ),
                             );
                        }
                        None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
                    }
                    dot = true;
                    break;
                }
                ch if is::value_end_char( ch ) => break,
                ch if Obj::is_valid_field_char( ch, false ) => {
                    let _ = stream.next();
                    var.push( ch );
                }
                ch => {
                    return parse_err( 
                        stream.file(),
                        InvalidValueChar( ch, stream.line(), stream.col() ),
                     );
                }
            }
        }

        let mut value = match var.as_str() 
        {
            "null" => Value::Null,
            "true" => Value::Bool( true ),
            "false" => Value::Bool( false ),
            "Obj" => Value::Obj( OBJ_SENTINEL.clone() ),
            "Str" => Value::Obj( STR_SENTINEL.clone() ),
            "Arr" => Value::Obj( ARR_SENTINEL.clone() ),
            "Tup" => Value::Obj( TUP_SENTINEL.clone() ),
            var @ "@" => return parse_err( stream.file(), InvalidValue( var.into(), line, col ) ),
            
            var if is_global => 
            {
               
                match globals.get( var ) {
                    Some( value ) => value.clone(),
                    None =>
                    {
                        let var = String::from( var );
                        return parse_err( stream.file(), GlobalNotFound( var, line, col ) );
                    }
                }
            }
            
            var => 
            {
               
                match obj.get( var ) {
                    Some( value ) => value.clone(),
                    None =>
                    {
                        let var = String::from( var );
                        return parse_err( stream.file(), VariableNotFound( var, line, col ) );
                    }
                }
            }
        };

        if dot 
        {
            value = match value 
            {
                Value::Arr( arr ) => {
                    let ( line, col ) = ( stream.line(), stream.col() );
                    let value = parse_value( 
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        line,
                        col,
                        depth + 1,
                        cur_brace,
                        false,
                    )?;

                    match value {
                        Value::Int( int ) => match int.to_usize() {
                            Some( index ) => arr
                                .get( index )
                                .map_err( | e |ParseError::from_over( &e, stream.file(), line, col ) )?,
                            None => return parse_err( stream.file(), InvalidIndex( int, line, col ) ),
                        },
                        _ => {
                            return parse_err( 
                                stream.file(),
                                ExpectedType( Type::Int, value.get_type(), line, col ),
                             );
                        }
                    }
                }
                Value::Tup( tup ) => {
                    let ( line, col ) = ( stream.line(), stream.col() );
                    let value = parse_value( 
                        &mut stream,
                        obj,
                        &mut globals,
                        &mut included,
                        line,
                        col,
                        depth + 1,
                        cur_brace,
                        false,
                    )?;

                    match value {
                        Value::Int( int ) => match int.to_usize() {
                            Some( index ) => tup
                                .get( index )
                                .map_err( | e |ParseError::from_over( &e, stream.file(), line, col ) )?,
                            None => return parse_err( stream.file(), InvalidIndex( int, line, col ) ),
                        },
                        _ => {
                            return parse_err( 
                                stream.file(),
                                ExpectedType( Type::Int, value.get_type(), line, col ),
                             );
                        }
                    }
                }
                Value::Obj( obj ) => {
                    let ( line, col ) = ( stream.line(), stream.col() );

                    if dot_global {
                        return parse_err( stream.file(), InvalidValueChar( '@', line, col ) );
                    }
                    parse_variable( 
                        &mut stream,
                        obj.map_ref(),
                        globals,
                        included,
                        line,
                        col,
                        depth + 1,
                        cur_brace,
                    )?
                }
                _ => return parse_err( stream.file(), InvalidDot( value.get_type(), line, col ) ),
            }
        }

        Ok( value )
    }
   
    fn parse_char( stream:&mut CharStream ) -> ParseResult<Value> 
    {
        let ch = stream.next().unwrap();
        assert_eq!( ch, '\'' );

        let ( escape, mut ch ) = match stream.next() 
        {
            Some( '\\' ) => ( true, '\0' ),
            Some( ch ) if ch == '\n' || ch == '\r' || ch == '\t' => {
                return parse_err( 
                    stream.file(),
                    InvalidValueChar( ch, stream.line(), stream.col() - 1 ),
                 );
            }
            Some( ch ) => ( false, ch ),
            None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
        };

        if escape 
        {
            ch = match stream.next() 
            {
                Some( ch ) => match get::escaped_character( ch )
                {
                    Some( ch ) => ch,
                    None => {
                        return parse_err( 
                            stream.file(),
                            InvalidEscapeChar( ch, stream.line(), stream.col() - 1 ),
                         );
                    }
                },
                None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
            }
        }

        match stream.next() 
        {
            Some( '\'' ) => (),
            Some( ch ) => {
                return parse_err( 
                    stream.file(),
                    InvalidValueChar( ch, stream.line(), stream.col() - 1 ),
                 );
            }
            None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
        }

        Ok( ch.into() )
    }

    fn parse_str_file( path:&str ) -> ParseResult<String> 
    {
       
        let s = str::read_from_file( path )?.replace( "\r\n","\n" );

        Ok( s )
    }
   
    fn parse_str( stream:&mut CharStream ) -> ParseResult<Value> 
    {
        let ch = stream.next().unwrap();
        assert_eq!( ch, '"' );

        let mut s = String::new();
        let mut escape = false;

        loop 
        {
            match stream.next() {
                Some( ch ) => {
                    if escape {
                        match get::escaped_character( ch ) {
                            Some( ch ) => s.push( ch ),
                            None => {
                                return parse_err( 
                                    stream.file(),
                                    InvalidEscapeChar( ch, stream.line(), stream.col() - 1 ),
                                 );
                            }
                        }
                        escape = false;
                    } else {
                        match ch {
                            '"' => break,
                            '\\' => escape = true,
                            _ => s.push( ch ),
                        }
                    }
                }
                None => return parse_err( stream.file(), UnexpectedEnd( stream.line() ) ),
            }
        }

       
        let s = s.replace( "\r\n","\n" );

        Ok( s.into() )
    }

    fn parse_include
    ( 
        mut stream:&mut CharStream,
        obj:&ObjMap,
        mut globals:&mut GlobalMap,
        mut included:&mut IncludedMap,
        depth: usize,
    ) -> ParseResult<Value> 
    {
        enum IncludeType {
            Obj,
            Str,
            Arr,
            Tup,
        }

       
        if depth > MAX_DEPTH {
            return parse_err( stream.file(), MaxDepth( stream.line(), stream.col() ) );
        }

        let ch = stream.next().unwrap();
        assert_eq!( ch, '<' );
       
        if !find_char( stream.clone() ) {
            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
        }

        let ( mut line, mut col ) = ( stream.line(), stream.col() );
        let mut value = parse_value( 
            &mut stream,
            obj,
            &mut globals,
            &mut included,
            line,
            col,
            depth,
            Some( '>' ),
            true,
        )?;

        let mut include_type = IncludeType::Obj;
        let mut parse_again = true;
        match value {
            Value::Obj( ref obj ) if obj.ptr_eq( &OBJ_SENTINEL ) => include_type = IncludeType::Obj,
            Value::Obj( ref obj ) if obj.ptr_eq( &STR_SENTINEL ) => include_type = IncludeType::Str,
            Value::Obj( ref obj ) if obj.ptr_eq( &ARR_SENTINEL ) => include_type = IncludeType::Arr,
            Value::Obj( ref obj ) if obj.ptr_eq( &TUP_SENTINEL ) => include_type = IncludeType::Tup,
            Value::Str( _ ) => parse_again = false,
            _ => {
                return parse_err( 
                    stream.file(),
                    InvalidIncludeToken( value.get_type(), line, col ),
                 );
            }
        }

        if parse_again {
           
            if !find_char( stream.clone() ) {
                return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
            }
            line = stream.line();
            col = stream.col();
            value = parse_value( 
                &mut stream,
                obj,
                &mut globals,
                &mut included,
                line,
                col,
                depth,
                Some( '>' ),
                true,
            )?;
        }

       
        if !find_char( stream.clone() ) {
            return parse_err( stream.file(), UnexpectedEnd( stream.line() ) );
        }

        match stream.next().unwrap() {
            '>' => (),
            ch => {
                return parse_err( 
                    stream.file(),
                    InvalidClosingBracket( Some( '>' ), ch, stream.line(), stream.col() - 1 ),
                 );
            }
        }

       
        let include_file = match value {
            Value::Str( s ) => s,
            _ => {
                return parse_err( 
                    stream.file(),
                    ExpectedType( Type::Str, value.get_type(), line, col ),
                 );
            }
        };

        let pathbuf = match stream.file().as_ref() {
            Some( file ) => Path::new( file )
                .parent()
                .unwrap()
                .join( Path::new( &include_file ) ),
            None => Path::new( &include_file ).to_path_buf(),
        };
        let path = pathbuf.as_path();
        
        if !path.is_file() {
            return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) );
        }

       
        let path_str = match path.to_str() {
            Some( path ) => path,
            None => return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ),
        };

       
        let path = match path.canonicalize() {
            Ok( path ) => path,
            Err( _ ) => return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ),
        };
        let full_path_str = match path.to_str() {
            Some( path ) => path,
            None => return parse_err( stream.file(), InvalidIncludePath( include_file, line, col ) ),
        };

       
        let storing = if let Some( file ) = stream.file() {
            let full_file = String::from( Path::new( &file ).canonicalize().unwrap().to_str().unwrap() );
            included.1.insert( full_file.clone() );
            Some( full_file )
        } else {
            None
        };
        
        if included.1.contains( full_path_str ) {
            return parse_err( stream.file(), CyclicInclude( include_file, line, col ) );
        }

       
        let value = if included.0.contains_key( full_path_str ) {
            let value = &included.0[full_path_str];
            value.clone()
        } else {
            let value: Value = match include_type {
                IncludeType::Obj => parse_obj_file_includes( path_str, included )?.into(),
                IncludeType::Str => parse_str_file( path_str )?.into(),
                IncludeType::Arr => parse_arr_file( path_str, included )?.into(),
                IncludeType::Tup => parse_tup_file( path_str, included )?.into(),
            };
           
            included.0.insert( full_path_str.into(), value.clone() );
            value
        };
       
        if let Some( file ) = storing {
            included.1.remove( &file );
        }

        Ok( value )
    }
   
    fn unary_op_on_value
    ( 
        stream:&CharStream,
        val: Value,
        op:char,
        line: usize,
        col: usize,
    ) -> ParseResult<Value> 
    {
        use crate::types::Type::*;

        let t = val.get_type();

        Ok( match op {
            '+' => match t {
                Int | Frac => val,
                _ => return parse_err( stream.file(), UnaryOperatorError( t, op, line, col ) ),
            },
            '-' => match t {
                Int => ( -val.get_int().unwrap() ).into(),
                Frac => ( -val.get_frac().unwrap() ).into(),
                _ => return parse_err( stream.file(), UnaryOperatorError( t, op, line, col ) ),
            },
            _ => return parse_err( stream.file(), UnaryOperatorError( t, op, line, col ) ),
        } )
    }
   
    fn binary_op_on_values
    ( 
        stream:&CharStream,
        mut val1: Value,
        mut val2: Value,
        op:char,
        line: usize,
        col: usize,
    ) -> ParseResult<Value> 
    {
        use crate::types::Type::*;

        let ( mut type1, mut type2 ) = ( val1.get_type(), val2.get_type() );
       
        if type1 == Int && type2 == Frac {
            val1 = Value::Frac( BigRational::new( val1.get_int().unwrap(), 1.into() ) );
            type1 = Frac;
        } else if type1 == Frac && type2 == Int {
            val2 = Value::Frac( BigRational::new( val2.get_int().unwrap(), 1.into() ) );
            type2 = Frac;
        }

        Ok( match op {
            '+' => {
                match type1 {
                    Int if type2 == Int => ( val1.get_int().unwrap() + val2.get_int().unwrap() ).into(),
                    Frac if type2 == Frac => { ( val1.get_frac().unwrap() + val2.get_frac().unwrap() ).into() }
                    Char if type2 == Char =>
                    {
                        let mut s = String::with_capacity( 2 );
                        s.push( val1.get_char().unwrap() );
                        s.push( val2.get_char().unwrap() );
                        s.into()
                    }
                    Char if type2 == Str =>
                    {
                        let str2 = val2.get_str().unwrap();
                        let mut s = String::with_capacity( 1 + str2.len() );
                        s.push( val1.get_char().unwrap() );
                        s.push_str( &str2 );
                        s.into()
                    }
                    Str if type2 == Char =>
                    {
                        let str1 = val1.get_str().unwrap();
                        let mut s = String::with_capacity( str1.len() + 1 );
                        s.push_str( &str1 );
                        s.push( val2.get_char().unwrap() );
                        s.into()
                    }
                    Str if type2 == Str =>
                    {
                        let str1 = val1.get_str().unwrap();
                        let str2 = val2.get_str().unwrap();
                        let mut s = String::with_capacity( str1.len() + str2.len() );
                        s.push_str( &str1 );
                        s.push_str( &str2 );
                        s.into()
                    }
                    Arr( _ ) => {
                        match Type::most_specific( &type1, &type2 ) {
                            Some( ( t, _ ) ) => {
                                let ( arr1, arr2 ) = ( val1.get_arr().unwrap(), val2.get_arr().unwrap() );
                                let ( mut vec1, mut vec2 ) =
                                    ( arr1.vec_ref().clone(), arr2.vec_ref().clone() );

                                let mut vec = Vec::with_capacity( vec1.len() + vec2.len() );
                                vec.append( &mut vec1 );
                                vec.append( &mut vec2 );

                               
                                let arr = if let Arr( ref t ) = t {
                                   
                                    arrays::Arr::from_vec_unchecked( vec, t.deref().clone() )
                                } else {
                                    panic!( "Logic error" )
                                };

                                arr.into()
                            }
                            None => {
                                return parse_err( 
                                    stream.file(),
                                    BinaryOperatorError( type1, type2, op, line, col ),
                                 );
                            }
                        }
                    }
                    _ => {
                        return parse_err( 
                            stream.file(),
                            BinaryOperatorError( type1, type2, op, line, col ),
                         );
                    }
                }
            }
            '-' => match type1 {
                Int if type2 == Int => ( val1.get_int().unwrap() - val2.get_int().unwrap() ).into(),
                Frac if type2 == Frac => ( val1.get_frac().unwrap() - val2.get_frac().unwrap() ).into(),
                _ => {
                    return parse_err( 
                        stream.file(),
                        BinaryOperatorError( type1, type2, op, line, col ),
                     );
                }
            },
            '*' => match type1 {
                Int if type2 == Int => ( val1.get_int().unwrap() * val2.get_int().unwrap() ).into(),
                Frac if type2 == Frac => ( val1.get_frac().unwrap() * val2.get_frac().unwrap() ).into(),
                _ => {
                    return parse_err( 
                        stream.file(),
                        BinaryOperatorError( type1, type2, op, line, col ),
                     );
                }
            },
            '/' => match type1 {
                Int if type2 == Int => {
                    let ( int1, int2 ) = ( val1.get_int().unwrap(), val2.get_int().unwrap() );
                    if int2.is_zero() {
                        return parse_err( stream.file(), InvalidNumeric( line, col ) );
                    }
                    BigRational::new( int1, int2 ).into()
                }
                Frac if type2 == Frac => {
                    let ( frac1, frac2 ) = ( val1.get_frac().unwrap(), val2.get_frac().unwrap() );
                    if frac2.is_zero() {
                        return parse_err( stream.file(), InvalidNumeric( line, col ) );
                    }
                    ( frac1 / frac2 ).into()
                }
                _ => {
                    return parse_err( 
                        stream.file(),
                        BinaryOperatorError( type1, type2, op, line, col ),
                     );
                }
            },
            '%' => match type1 {
                Int if type2 == Int => {
                    let int2 = val2.get_int().unwrap();
                    if int2.is_zero() {
                        return parse_err( stream.file(), InvalidNumeric( line, col ) );
                    }
                    ( val1.get_int().unwrap() % int2 ).into()
                }
                _ => {
                    return parse_err( 
                        stream.file(),
                        BinaryOperatorError( type1, type2, op, line, col ),
                     );
                }
            },
            _ => {
                return parse_err( 
                    stream.file(),
                    BinaryOperatorError( type1, type2, op, line, col ),
                 );
            }
        } )
    }
   
    fn find_char( mut stream: CharStream ) -> bool 
    {
        while let Some( ch ) = stream.peek() {
            match ch {
                '#' => {
                   
                    loop {
                        let ch = stream.next();
                        if ch.is_none() {
                            return false;
                        }
                        if ch.unwrap() == '\n' {
                            break;
                        }
                    }
                }
                ch if ch.is_whitespace() => { let _ = stream.next(); }
                _ => return true,
            }
        }

        false
    }
   
    fn check_value_end( stream:&CharStream, cur_brace:Option<char> ) -> ParseResult<()> 
    {
        match stream.peek()
        {
            Some( ch ) => match ch
            {
                ch if is::value_end_char( ch ) =>
                {
                    if is::end_delimiter( ch ) && Some( ch ) != cur_brace
                    {
                        parse_err
                        ( 
                            stream.file(),
                            InvalidClosingBracket( cur_brace, ch, stream.line(), stream.col() ),
                        )
                    }
                    
                    else
                    {
                        Ok( () )
                    }
                }
                ch => parse_err
                ( 
                    stream.file(),
                    InvalidValueChar( ch, stream.line(), stream.col() ),
                ),
            },
            None => Ok( () ),
        }
    }
}

pub mod path
{
    pub use std::path::{ * };
    use ::
    {
        borrow::{ Cow },
        cmp::{ self, Ordering },
        error::{ Error },
        fs::{ self, DirEntry, read_dir },
        io::{ self, ErrorKind, Write },
        ops::{ Deref },
        os::unix::fs::PermissionsExt,
        regex::{ Regex },
        str::{ FromStr },
        *,
    };
    
    pub const ERROR_WILDCARDS: &str = "wildcards are either regular `*` or recursive `**`";
    pub const ERROR_RECURSIVE_WILDCARDS: &str = "recursive wildcards must form a single path component";
    pub const ERROR_INVALID_RANGE: &str = "invalid range pattern";
    /*
    */
    pub fn basename( path:&str ) -> Cow<'_, str>
    {
        let mut pieces = path.rsplit('/');
        
        match pieces.next()
        {
            Some( p) => p.into(),
            None => path.into(),
        }
    }
    // pub fn find_file_in_path( filename: &str, exec:bool ) -> String
    pub fn find_file( filename: &str, exec:bool ) -> String
    {
        let env_path = match env::var( "PATH" )
        {
            Ok( x ) => x,
            Err( e ) => {
                println_stderr!( ":: error with env PATH: {:?}", e );
                return String::new();
            }
        };
        let vec_path = env::split_paths( &env_path );
        for p in vec_path {
            match read_dir( &p) {
                Ok(list ) => {
                    for entry in list.flatten() {
                        if let Ok( name ) = entry.file_name().into_string() {
                            if name != filename {
                                continue;
                            }

                            if exec {
                                let _mode = match entry.metadata() {
                                    Ok( x ) => x,
                                    Err( e ) => {
                                        println_stderr!( ":: metadata error: {:?}", e );
                                        continue;
                                    }
                                };
                                let mode = _mode.permissions().mode();
                                if mode & 0o111 == 0 {
                                    // not binary
                                    continue;
                                }
                            }

                            return entry.path().to_string_lossy().to_string();
                        }
                    }
                }
                Err( e ) => {
                    if e.kind() == ErrorKind::NotFound {
                        continue;
                    }
                    log!( ":: fs read_dir error: {}: {}", p.display(), e );
                }
            }
        }
        String::new()
    }

    pub fn current_dir() -> String
    {
        let _current_dir = match env::current_dir()
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                // log!( ":: PROMPT: env current_dir error: {}", e );
                return String::new();
            }
        };

        let current_dir = match _current_dir.to_str()
        {
            Some( x ) => x,
            None =>
            {
                // log!( ":: PROMPT: to_str error" );
                return String::new();
            }
        };

        current_dir.to_string()
    }
    
    #[derive( Debug )]
    pub struct Paths
    {
        dir_patterns: Vec<Pattern>,
        require_dir: bool,
        options: MatchOptions,
        todo: Vec<Result<( PathWrapper, usize ), GlobError>>,
        scope:Option<PathWrapper>,
    }

    pub fn glob( pattern:&str ) -> Result<Paths, PatternError> { glob_with( pattern, MatchOptions::new() ) }

    pub fn glob_with( pattern:&str, options:MatchOptions ) -> Result<Paths, PatternError>
    {
        #[cfg( windows )]
        fn check_windows_verbatim( p:&Path ) -> bool
        {
            match p.components().next()
            {
                Some( Component::Prefix( ref p ) ) =>
                {
                    p.kind().is_verbatim() && if let std::path::Prefix::VerbatimDisk(_ ) = p.kind() { false }
                    else { true }
                }
                _ => false,
            }
        }

        #[cfg( not( windows  ) )]
        fn check_windows_verbatim( _:&Path ) -> bool { false }

        #[cfg( windows )]
        fn to_scope( p:&Path ) -> PathBuf { p.to_path_buf() }

        #[cfg( not( windows  ) )]
        fn to_scope( p:&Path ) -> PathBuf { p.to_path_buf() }
        
        let _ = Pattern::new( pattern )?;

        let mut components = Path::new( pattern ).components().peekable();

        loop
        {
            match components.peek()
            {
                Some( &Component::Prefix(..) ) | Some( &Component::RootDir ) => { components.next(); }
                _ => break,
            }
        }

        let rest = components.map( |s| s.as_os_str() ).collect::<PathBuf>();
        let normalized_pattern = Path::new( pattern ).iter().collect::<PathBuf>();
        let root_len = normalized_pattern.to_str().unwrap().len() - rest.to_str().unwrap().len();

        let root = if root_len > 0 { Some( Path::new( &pattern[..root_len] ) ) }
        else { None };

        if root_len > 0 && check_windows_verbatim( root.unwrap() )
        {
            return Ok
            (
                Paths
                {
                    dir_patterns: Vec::new(),
                    require_dir: false,
                    options,
                    todo: Vec::new(),
                    scope: None,
                }
            );
        }

        let scope = root.map_or_else( || PathBuf::from( "." ), to_scope );
        let scope = PathWrapper::from_path( scope );

        let mut dir_patterns = Vec::new();
        let components = pattern[cmp::min( root_len, pattern.len() )..].split_terminator( is_separator );

        for component in components
        {
            dir_patterns.push( Pattern::new( component )? );
        }

        if root_len == pattern.len()
        {
            dir_patterns.push
            (
                Pattern
                {
                    original: "".to_string(),
                    tokens: Vec::new(),
                    is_recursive: false,
                    has_metachars: false,
                }
            );
        }

        let last_is_separator = pattern.chars().next_back().map( is_separator );
        let require_dir = last_is_separator == Some( true );
        let todo = Vec::new();

        Ok
        (
            Paths
            {
                dir_patterns,
                require_dir,
                options,
                todo,
                scope: Some( scope ),
            }
        )
    }

    #[derive( Debug )]
    pub struct GlobError
    {
        path:PathBuf,
        error:io::Error,
    }

    impl GlobError
    {
        pub fn path( &self ) -> &Path { &self.path }

        pub fn error( &self ) -> &io::Error { &self.error }

        #[deprecated( note = "use `.into` instead" )]
        pub fn into_error( self ) -> io::Error { self.error }
    }

    impl From<GlobError> for io::Error
    {
        fn from( value:GlobError ) -> Self { value.error }
    }

    impl Error for GlobError
    {
        fn description( &self ) -> &str { self.error.description() }
        fn cause( &self ) -> Option<&Error> { Some( &self.error ) }
    }

    impl fmt::Display for GlobError
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            write!
            (
                f,
                "attempting to read `{}` resulted in an error: {}",
                self.path.display(),
                self.error
            )
        }
    }

    #[derive( Debug )]
    pub struct PathWrapper
    {
        path: PathBuf,
        is_directory: bool,
    }

    impl PathWrapper
    {
        fn from_dir_entry( path: PathBuf, e: DirEntry) -> Self
        {
            let is_directory = e
            .file_type()
            .ok()
            .and_then(|file_type|
            {
                if file_type.is_symlink() { None }                    
                else { Some( file_type.is_dir() ) }
            })
            .or_else(|| fs::metadata( &path ).map(|m| m.is_dir() ).ok() )
            .unwrap_or( false );

            Self { path, is_directory }
        }

        fn from_path( path: PathBuf) -> Self
        {
            let is_directory = fs::metadata( &path ).map(|m| m.is_dir() ).unwrap_or( false );
            Self { path, is_directory }
        }

        fn into_path( self ) -> PathBuf { self.path }
    }

    impl Deref for PathWrapper 
    {
        type Target = Path;

        fn deref( &self ) -> &Self::Target { self.path.deref() }
    }

    impl AsRef<Path> for PathWrapper 
    {
        fn as_ref( &self ) -> &Path { self.path.as_ref() }
    }
    

    pub type GlobResult = Result<PathBuf, GlobError>;

    impl Iterator for Paths
    {
        type Item = GlobResult;

        fn next( &mut self) -> Option<GlobResult>
        {
            if let Some( scope ) = self.scope.take()
            {
                if !self.dir_patterns.is_empty()
                {
                    assert!( self.dir_patterns.len() < usize::MAX);
                    fill_todo( &mut self.todo, &self.dir_patterns, 0, &scope, self.options );
                }
            }

            loop
            {
                if self.dir_patterns.is_empty() || self.todo.is_empty() { return None; }

                let ( path, mut idx) = match self.todo.pop().unwrap()
                {
                    Ok( pair ) => pair,
                    Err( e ) => return Some(Err( e  ) ),
                };
                
                if idx == usize::MAX
                {
                    if self.require_dir && !path.is_directory { continue; }

                    return Some(Ok( path.into_path() ) );
                }

                if self.dir_patterns[idx].is_recursive
                {
                    let mut next = idx;
                    
                    while ( next + 1) < self.dir_patterns.len() && self.dir_patterns[next + 1].is_recursive 
                    { next += 1; }

                    if path.is_directory
                    {
                        fill_todo
                        (
                            &mut self.todo,
                            &self.dir_patterns,
                            next,
                            &path,
                            self.options,
                        );

                        if next == self.dir_patterns.len() - 1 { return Some(Ok( path.into_path() ) ); }
                        else { idx = next + 1; }
                    }
                    
                    else if next == self.dir_patterns.len() - 1 { continue; }
                    else { idx = next + 1; }
                }
                
                if self.dir_patterns[idx].matches_with
                (
                    {
                        match path.file_name().and_then(|s| s.to_str() )
                        {
                            None => continue,
                            Some( x ) => x,
                        }
                    },
                    self.options,
                )
                {
                    if idx == self.dir_patterns.len() - 1
                    {
                        if !self.require_dir || path.is_directory { return Some(Ok( path.into_path() ) ); }
                    }

                    else
                    {
                        fill_todo
                        (
                            &mut self.todo,
                            &self.dir_patterns,
                            idx + 1,
                            &path,
                            self.options,
                        );
                    }
                }
            }
        }
    }

    #[derive( Debug )]
    pub struct PatternError
    {

        pub pos: usize,
        pub msg:&'static str,
    }

    impl Error for PatternError
    {
        fn description( &self ) -> &str { self.msg }
    }

    impl fmt::Display for PatternError
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            write!
            (
                f,
                "Pattern syntax error near position {}: {}",
                self.pos, self.msg
            )
        }
    }

    #[derive( Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
    pub struct Pattern
    {
        original: String,
        tokens: Vec<PatternToken>,
        is_recursive: bool,
        has_metachars: bool,
    }

    impl fmt::Display for Pattern
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result { self.original.fmt( f) }
    }

    impl FromStr for Pattern
    {
        type Err = PatternError;
        fn from_str( s:&str ) -> Result<Self, PatternError> { Self::new( s ) }
    }

    #[derive( Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
    pub enum PatternToken
    {
        Char( char ),
        AnyChar,
        AnySequence,
        AnyRecursiveSequence,
        AnyWithin( Vec<CharSpecifier> ),
        AnyExcept( Vec<CharSpecifier> ),
    } pub use self::PatternToken::{ AnyChar, AnyExcept, AnyRecursiveSequence, AnySequence, AnyWithin, Char };

    #[derive( Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd )]
    pub enum CharSpecifier
    {
        SingleChar( char ),
        CharRange( char, char ),
    } pub use self::CharSpecifier::{CharRange, SingleChar};

    #[derive( Clone, Copy, PartialEq )]
    pub enum MatchResult
    {
        Match,
        SubPatternDoesntMatch,
        EntirePatternDoesntMatch,
    } pub use self::MatchResult::{ EntirePatternDoesntMatch, Match, SubPatternDoesntMatch };

    impl Pattern
    {
        pub fn new( pattern:&str ) -> Result<Self, PatternError>
        {
            let chars = pattern.chars().collect::<Vec<_>>();
            let mut tokens = Vec::new();
            let mut is_recursive = false;
            let mut has_metachars = false;
            let mut i = 0;

            while i < chars.len()
            {
                match chars[i]
                {
                    '?' =>
                    {
                        has_metachars = true;
                        tokens.push(AnyChar );
                        i += 1;
                    }

                    '*' =>
                    {
                        has_metachars = true;

                        let old = i;

                        while i < chars.len() && chars[i] == '*' { i += 1; }

                        let count = i - old;

                        match count.cmp( &2)
                        {
                            Ordering::Greater =>
                            {
                                return Err( PatternError
                                {
                                    pos: old + 2,
                                    msg: ERROR_WILDCARDS,
                                })
                            }

                            Ordering::Equal =>
                            {
                                let is_valid = if i == 2 || path::is_separator( Chars[i - count - 1])
                                {
                                    if i < chars.len() && path::is_separator( Chars[i])
                                    {
                                        i += 1;
                                        true
                                    }
                                    else if i == chars.len() { true }
                                    else
                                    {
                                        return Err( PatternError
                                        {
                                            pos: i,
                                            msg: ERROR_RECURSIVE_WILDCARDS,
                                        });
                                    }
                                }
                                
                                else
                                {
                                    return Err( PatternError
                                    {
                                        pos: old - 1,
                                        msg: ERROR_RECURSIVE_WILDCARDS,
                                    });
                                };

                                if is_valid
                                {
                                    let tokens_len = tokens.len();

                                    if !( tokens_len > 1 && tokens[tokens_len - 1] == AnyRecursiveSequence )
                                    {
                                        is_recursive = true;
                                        tokens.push(AnyRecursiveSequence );
                                    }
                                }
                            }

                            Ordering::Less => tokens.push(AnySequence ),
                        }
                    }

                    '[' =>
                    {
                        has_metachars = true;

                        if i + 4 <= chars.len() && chars[i + 1] == '!'
                        {
                            match chars[i + 3..].iter().position(|x| *x == ']') 
                            {
                                None => (),
                                Some(j) => {
                                    let chars = &chars[i + 2..i + 3 + j];
                                    let cs = parse_char_specifiers( Chars );
                                    tokens.push(AnyExcept( Cs  ) );
                                    i += j + 4;
                                    continue;
                                }
                            }
                        }
                        
                        else if i + 3 <= chars.len() && chars[i + 1] != '!'
                        {
                            match chars[i + 2..].iter().position(|x| *x == ']')
                            {
                                None => (),
                                Some(j) => {
                                    let cs = parse_char_specifiers( &chars[i + 1..i + 2 + j]);
                                    tokens.push(AnyWithin( Cs  ) );
                                    i += j + 3;
                                    continue;
                                }
                            }
                        }
                        
                        return Err( PatternError {
                            pos: i,
                            msg: ERROR_INVALID_RANGE,
                        });
                    }

                    c =>
                    {
                        tokens.push( Char( c  ) );
                        i += 1;
                    }
                }
            }

            Ok(Self
            {
                tokens,
                original: pattern.to_string(),
                is_recursive,
                has_metachars,
            })
        }

        pub fn escape( s:&str ) -> String
        {
            let mut escaped = String::new();
            for c in s.chars()
            {
                match c
                {
                    '?' | '*' | '[' | ']' => {
                        escaped.push('[');
                        escaped.push( c );
                        escaped.push(']');
                    }
                    c => { escaped.push( c ); }
                }
            }
            escaped
        }

        pub fn matches( &self, str:&str ) -> bool { self.matches_with( str, MatchOptions::new() ) }
        pub fn matches_path( &self, path:&Path ) -> bool { path.to_str().map_or( false, |s| self.matches( s ) ) }

        pub fn matches_with( &self, str: &str, options:MatchOptions ) -> bool
        { self.matches_from( true, str.chars(), 0, options ) == Match }

        pub fn matches_path_with( &self, path: &Path, options: MatchOptions ) -> bool
        {
            path.to_str().map_or( false, |s| self.matches_with( s, options ) )
        }

        pub fn as_str( &self ) -> &str { &self.original }

        fn matches_from
        (
            &self,
            mut follows_separator: bool,
            mut file: ::str::Chars,
            i: usize,
            options: MatchOptions,
        ) -> MatchResult
        {
            for ( ti, token ) in self.tokens[i..].iter().enumerate()
            {
                match *token
                {
                    AnySequence | AnyRecursiveSequence =>
                    {
                        debug_assert!(match *token
                        {
                            AnyRecursiveSequence => follows_separator,
                            _ => true,
                        });
                        
                        match self.matches_from( follows_separator, file.clone(), i + ti + 1, options )
                        {
                            SubPatternDoesntMatch => (),
                            m => return m,
                        };

                        while let Some( c ) = file.next()
                        {
                            if follows_separator && options.require_literal_leading_dot && c == '.'
                            { return SubPatternDoesntMatch; }

                            follows_separator = path::is_separator( c );
                            
                            match *token
                            {
                                AnyRecursiveSequence if !follows_separator => continue,
                                AnySequence if options.require_literal_separator && follows_separator =>
                                { return SubPatternDoesntMatch }
                                _ => (),
                            }

                            match self.matches_from
                            (
                                follows_separator,
                                file.clone(),
                                i + ti + 1,
                                options,
                            )
                            {
                                SubPatternDoesntMatch => (),
                                m => return m,
                            }
                        }
                    }
                    
                    _ =>
                    {
                        let c = match file.next()
                        {
                            Some( c ) => c,
                            None => return EntirePatternDoesntMatch,
                        };

                        let is_sep = path::is_separator( c );

                        if !match *token
                        {
                            AnyChar       |
                            AnyWithin(..) |
                            AnyExcept(..) if (options.require_literal_separator && is_sep) ||
                            ( follows_separator && options.require_literal_leading_dot && c == '.' ) => { false }
                            AnyChar => true,
                            AnyWithin( ref specifiers ) => in_char_specifiers( specifiers, c, options ),
                            AnyExcept( ref specifiers ) => !in_char_specifiers( specifiers, c, options ),
                            Char( c2 ) => chars_eq( c, c2, options.case_sensitive ),
                            AnySequence | AnyRecursiveSequence => unreachable!(),
                        }
                        { return SubPatternDoesntMatch; }

                        follows_separator = is_sep;
                    }
                }
            }
            
            if file.next().is_none() { Match }
            else { SubPatternDoesntMatch }
        }
    }
    
    fn fill_todo
    (
        todo: &mut Vec<Result<( PathWrapper, usize ), GlobError>>,
        patterns:&[Pattern],
        idx: usize,
        path: &PathWrapper,
        options: MatchOptions,
    )
    {
        let add = | todo:&mut Vec<_>, next_path: PathWrapper |
        {
            if idx + 1 == patterns.len() { todo.push( Ok( ( next_path, usize::MAX ) ) ); }
            else { fill_todo( todo, patterns, idx + 1, &next_path, options ); }
        };

        let pattern = &patterns[idx];
        let is_dir = path.is_directory;
        let curdir = path.as_ref() == Path::new( "." );

        match ( pattern.has_metachars, is_dir )
        {
            ( false, _ ) =>
            {
                debug_assert!
                (
                    pattern
                    .tokens
                    .iter()
                    .all( | tok | matches!( tok, PatternToken::Char( _ ) ) ),
                    "broken invariant: pattern has metachars but shouldn't"
                );
                
                let s = pattern.as_str();                
                let special = "." == s || ".." == s;
                let next_path = if curdir { PathBuf::from( s ) }
                
                else { path.join( s ) };
                
                let next_path = PathWrapper::from_path( next_path );
                
                if  ( special && is_dir ) ||
                    (!special && ( fs::metadata( &next_path ).is_ok() || fs::symlink_metadata( &next_path ).is_ok() ) )
                    { add( todo, next_path ); }
            }

            ( true, true ) => 
            {
                let dirs = fs::read_dir( path ).and_then(|d| 
                {
                    d.map(| e |
                    {
                        e.map(| e |
                        {
                            let path = if curdir { PathBuf::from( e.path().file_name().unwrap() ) }
                            
                            else { e.path() };

                            PathWrapper::from_dir_entry( path, e )
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()
                });

                match dirs
                {
                    Ok( mut children ) =>
                    {
                        if options.require_literal_leading_dot
                        {
                            children.retain(|x| !x.file_name().unwrap().to_str().unwrap().starts_with('.' ) );
                        }

                        children.sort_by(|p1, p2| p2.file_name().cmp( &p1.file_name() ) );
                        todo.extend( Children.into_iter().map(|x| Ok((x, idx ) )  ) );
                        
                        if !pattern.tokens.is_empty() && pattern.tokens[0] == Char('.')
                        {
                            for &special in &[".",".."]
                            {
                                if pattern.matches_with( special, options )
                                {
                                    add( todo, PathWrapper::from_path( path.join( special ) ) );
                                }
                            }
                        }
                    }

                    Err( e ) =>
                    {
                        todo.push
                        (
                            Err
                            (
                                GlobError
                                {
                                    path: path.to_path_buf(),
                                    error: e
                                }
                            )
                        );
                    }
                }
            }

            ( true, false ) => {}
        }
    }

    fn parse_char_specifiers( s:&[char] ) -> Vec<CharSpecifier>
    {
        let mut cs = Vec::new();
        let mut i = 0;

        while i < s.len()
        {
            if i + 3 <= s.len() && s[i + 1] == '-' {
                cs.push( CharRange( s[i], s[i + 2] ) );
                i += 3;
            } else {
                cs.push(SingleChar( s[i] ) );
                i += 1;
            }
        }

        cs
    }

    fn in_char_specifiers( specifiers:&[CharSpecifier], c:char, options:MatchOptions ) -> bool
    {
        for &specifier in specifiers.iter()
        {
            match specifier
            {
                SingleChar( sc ) =>
                {
                    if chars_eq( c, sc, options.case_sensitive ) { return true; }
                }
                
                CharRange( start, end ) =>
                {
                    if !options.case_sensitive && c.is_ascii() && start.is_ascii() && end.is_ascii()
                    {
                        let start = start.to_ascii_lowercase();
                        let end = end.to_ascii_lowercase();

                        let start_up = start.to_uppercase().next().unwrap();
                        let end_up = end.to_uppercase().next().unwrap();
                        
                        if start != start_up && end != end_up
                        {
                            let c = c.to_ascii_lowercase();
                            if c >= start && c <= end { return true; }
                        }
                    }

                    if c >= start && c <= end { return true; }
                }
            }
        }

        false
    }

    fn chars_eq( a:char, b:char, case_sensitive:bool ) -> bool 
    {
        if cfg!( windows ) && path::is_separator( a ) && path::is_separator( b ) { true }
        
        else if !case_sensitive && a.is_ascii() && b.is_ascii() { a.eq_ignore_ascii_case( &b ) }

        else { a == b }
    }

    #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
    pub struct MatchOptions
    {

        pub case_sensitive: bool,
        pub require_literal_separator: bool,
        pub require_literal_leading_dot: bool,
    }

    impl MatchOptions 
    {
        pub fn new() -> Self
        {
            Self
            {
                case_sensitive: true,
                require_literal_separator: false,
                require_literal_leading_dot: false,
            }
        }
    }
}

pub mod primitive
{
    pub use std::primitive::{ * };
}

pub mod process
{
    pub use std::process::{ * };

    use ::
    {
        error::no::{ Errno },
        os::fd::{ RawFd },
        system::
        {
            api::
            {
                Result, ForkResult, Pid, c_int
            },
        },
        *,
    };
    /*
    */

    #[inline] pub unsafe fn fork() -> Result<ForkResult>
    {
        use self::ForkResult::*;
        let res = unsafe { ::system::api::fork() };

        Errno::result( res ).map(|res| match res
        {
            0 => Child,
            res => Parent { child: Pid( res ) },
        })
    }
    
    pub fn pipe() -> Result<(RawFd, RawFd )>
    {
        let mut fds = mem::MaybeUninit::<[c_int; 2]>::uninit();
        let res = unsafe { system::api::pipe( fds.as_mut_ptr() as *mut c_int ) };
        Errno::result( res )?;
        unsafe { Ok(( fds.assume_init()[0], fds.assume_init()[1] ) ) }
    }
}

pub mod prompts
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    use crate::libs;
    use crate::shell;
    */
    pub mod main
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        use std::env;

        use crate::execute;
        use crate::libs;
        use crate::shell;

        const DEFAULT_PROMPT: &str = "${COLOR_STATUS}$USER${RESET}\
            @${COLOR_STATUS}$HOSTNAME${RESET}: \
            ${COLOR_STATUS}$CWD${RESET}$ ";
        use super::preset::apply_preset_item;
        use super::preset::apply_pyenv;
        */
        // pub fn get_prompt_string() -> String
        pub fn read_string() -> String
        {
            if let Ok( x ) = env::var( "PROMPT" ) { return x; }
            DEFAULT_PROMPT.to_string()
        }
        // pub fn apply_prompt_item( sh: &shell::Shell, result: &mut String, token:&str )
        pub fn apply_item( sh: &shell::Shell, result: &mut String, token:&str )
        {
            if let Some( x ) = sh.get_env( token )
            {
                result.push_str( &x);
                return;
            }

            apply_preset_item( sh, result, token );
        }

        pub fn apply_command( result: &mut String, token: &str, prefix: &str, suffix:&str )
        {
            let cr = now::run( token );
            let output = cr.stdout.trim();
            if !output.is_empty()
            {
                result.push_str( prefix);
                result.push_str(output );
                result.push_str( suffix);
            }
        }
        // pub fn render_prompt( sh: &shell::Shell, ps:&str ) -> String
        pub fn render( sh: &shell::Shell, ps:&str ) -> String
        {
            let mut prompt = String::new();
            apply_pyenv( &mut prompt );

            let mut met_dollar = false;
            let mut met_brace = false;
            let mut met_paren = false;
            let mut token = String::new();
            let mut prefix = String::new();
            let mut suffix = String::new();
            for c in ps.chars() {
                if met_dollar {
                    if c == '(' && !met_brace && !met_paren {
                        met_paren = true;
                        continue;
                    }
                    if c == ')' && met_paren {
                        apply_command( &mut prompt, &token, &prefix, &suffix);
                        token.clear();
                        prefix.clear();
                        suffix.clear();
                        met_dollar = false;
                        met_paren = false;
                        continue;
                    }
                    if c == '{' && !met_brace && !met_paren {
                        met_brace = true;
                        continue;
                    } else if c == '}' && met_brace {
                        apply_item( sh, &mut prompt, &token );
                        token.clear();
                        met_dollar = false;
                        met_brace = false;
                        continue;
                    } else if c == '$' {
                        if token.is_empty() {
                            // to make single $ as a plain $
                            prompt.push('$');
                            met_dollar = true;
                            continue;
                        } else {
                            apply_item( sh, &mut prompt, &token );
                            token.clear();
                            continue;
                        }
                    } else if met_paren {
                        if is::prefix_char( c ) {
                            prefix.push( c );
                        } else if is::suffix_char( c ) {
                            suffix.push( c );
                        } else {
                            token.push( c );
                        }
                        continue;
                    } else if is::prompt_item_char( c, &token ) {
                        token.push( c );
                        continue;
                    } else if token.is_empty() {
                        prompt.push('$');
                        prompt.push( c );
                        met_dollar = false;
                        continue;
                    }
                }

                if c == '$' {
                    met_dollar = true;
                    continue;
                }

                if !token.is_empty() {
                    apply_item( sh, &mut prompt, &token );
                    token.clear();
                }
                prompt.push( c );
                met_dollar = false;
            }

            if !token.is_empty() {
                apply_item( sh, &mut prompt, &token );
                met_dollar = false;
            }

            if met_dollar {
                // for cases like PROMPT='$$'
                prompt.push('$');
            }
            /*
            if prompt.trim().is_empty() {
                return format!( "cicada-{} >> ", env!( "CARGO_PKG_VERSION" ) );
            } */
            prompt
        }
    } pub use self::main::{ read_string, render };

    pub mod multilines
    {
        /*!
        */
        use ::
        {
            system::
            {
                function::{ Function },
                prompter::{ Prompter },
                terminal::{ Terminal },
            },
            *,
        };
        /*
        use std::io;
        use crate::parsers::parser_line;
        */
        pub struct EnterFunction;

        impl<T: Terminal> Function<T> for EnterFunction
        {
            fn execute( &self, prompter: &mut Prompter<T>, count: i32, _ch:char ) -> io::Result<()>
            {
                let buf = prompter.buffer();
                let linfo = parser_line::parse_line( buf);
                if linfo.is_complete {
                    prompter.accept_input()
                } else if count > 0 {
                    match prompter.insert( Count as usize, '\n') {
                        Ok(_ ) => {}
                        Err( e ) => { println!( "sub-prompt error: {}", e ); }
                    }
                    prompter.insert_str( ">> " )
                } else {
                    Ok(() )
                }
            }
        }
    } pub use self::multilines::{ EnterFunction };

    pub mod preset
    {
        /*!
        */
        use ::
        {
            fs::{ File },
            io::{ Read, Write },
            path::{ Path },
            *,
        };
        /*
        */
        fn apply_seq( prompt: &mut String) {
            prompt.push_str(libs::colored::SEQ);
        }

        fn apply_end_seq( prompt: &mut String) {
            prompt.push_str(libs::colored::END_SEQ);
        }

        fn apply_esc( prompt: &mut String) {
            prompt.push_str(libs::colored::ESC);
        }

        fn apply_underlined( prompt: &mut String) {
            prompt.push_str(libs::colored::UNDERLINED);
        }

        fn apply_user( prompt: &mut String) {
            let username = tools::get_user_name();
            prompt.push_str( &username );
        }

        fn apply_black( prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK);
        }

        fn apply_black_b( prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_B);
        }

        fn apply_black_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::BLACK_BG);
        }

        fn apply_blue( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE);
        }

        fn apply_blue_b( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_B);
        }

        fn apply_blue_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_BG);
        }

        fn apply_bold( prompt: &mut String) {
            prompt.push_str(libs::colored::BOLD);
        }

        fn apply_green( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN);
        }

        fn apply_green_b( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_B);
        }

        fn apply_green_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_BG);
        }

        fn apply_red( prompt: &mut String) {
            prompt.push_str(libs::colored::RED);
        }

        fn apply_red_b( prompt: &mut String) {
            prompt.push_str(libs::colored::RED_B);
        }

        fn apply_red_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::RED_BG);
        }

        fn apply_white( prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE);
        }

        fn apply_white_b( prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_B);
        }

        fn apply_white_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::WHITE_BG);
        }

        fn apply_hidden( prompt: &mut String) {
            prompt.push_str(libs::colored::HIDDEN);
        }

        fn apply_reset( prompt: &mut String) {
            prompt.push_str(libs::colored::RESEt );
        }

        fn apply_reverse( prompt: &mut String) {
            prompt.push_str(libs::colored::REVERSE);
        }

        fn apply_dim( prompt: &mut String) {
            prompt.push_str(libs::colored::DIM);
        }

        fn apply_blink( prompt: &mut String) {
            prompt.push_str(libs::colored::BLINK);
        }

        fn apply_reset_underlined( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_UNDERLINED);
        }

        fn apply_reset_dim( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_DIM);
        }

        fn apply_reset_reverse( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_REVERSE);
        }

        fn apply_reset_hidden( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_HIDDEN);
        }

        fn apply_reset_blink( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BLINK);
        }

        fn apply_reset_bold( prompt: &mut String) {
            prompt.push_str(libs::colored::RESET_BOLD);
        }

        fn apply_default( prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULt );
        }

        fn apply_default_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::DEFAULT_BG);
        }

        fn apply_cyan( prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN);
        }

        fn apply_cyan_l( prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L);
        }

        fn apply_cyan_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_BG);
        }

        fn apply_cyan_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::CYAN_L_BG);
        }

        fn apply_red_l( prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L);
        }

        fn apply_red_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::RED_L_BG);
        }

        fn apply_green_l( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L);
        }

        fn apply_green_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::GREEN_L_BG);
        }

        fn apply_gray_l( prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L);
        }

        fn apply_gray_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_L_BG);
        }

        fn apply_gray_d( prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D);
        }

        fn apply_gray_d_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::GRAY_D_BG);
        }

        fn apply_magenta( prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA);
        }

        fn apply_magenta_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_BG);
        }

        fn apply_magenta_l( prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L);
        }

        fn apply_magenta_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::MAGENTA_L_BG);
        }

        fn apply_yellow( prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW);
        }

        fn apply_yellow_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_BG);
        }

        fn apply_yellow_l( prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L);
        }

        fn apply_yellow_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::YELLOW_L_BG);
        }

        fn apply_blue_l( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L);
        }

        fn apply_blue_l_bg( prompt: &mut String) {
            prompt.push_str(libs::colored::BLUE_L_BG);
        }

        fn apply_color_status( sh: &shell::Shell, prompt: &mut String) {
            if sh.previous_status == 0 {
                prompt.push_str(libs::colored::GREEN_B);
            } else {
                prompt.push_str(libs::colored::RED_B);
            }
        }

        fn _find_git_root() -> String {
            let current_dir = libs::path::current_dir();
            let dir_git = format!( "{}/.git", current_dir );
            if Path::new( &dir_git ).exists() {
                return current_dir;
            }

            let mut _dir = current_dir.clone();
            while Path::new( &_dir ).parent().is_some() {
                match Path::new( &_dir ).parent() {
                    Some( p) => {
                        _dir = p.to_string_lossy().to_string();
                        let dir_git = format!( "{}/.git", _dir );
                        if Path::new( &dir_git ).exists() {
                            return _dir;
                        }
                    }
                    None => { break; }
                }
            }

            String::new()
        }

        fn apply_gitbr( prompt: &mut String) {
            let git_root = _find_git_root();
            if git_root.is_empty() {
                return;
            }

            let file_head = format!( "{}/.git/HEAD", git_root );
            if !Path::new( &file_head ).exists() {
                return;
            }

            let mut file;
            match File::open( &file_head ) {
                Ok( x ) => file = x,
                Err( e ) => {
                    println!( ":: .git/HEAD err: {:?}", e );
                    return;
                }
            }
            let mut text = String::new();
            match file.read_to_string( &mut text ) {
                Ok(_ ) => {}
                Err( e ) => {
                    println!( ":: read_to_string error: {:?}", e );
                    return;
                }
            }

            if let Some( branch ) = regex::find_first_group( r"^[a-z]+: ?[a-z]+/[a-z]+/(.+)$", text.trim() )
            {
                apply_blue_b( prompt );
                if let Ok( x ) = env::var( "CICADA_GITBR_PREFIX" ) {
                    prompt.push_str( &x);
                }

                let _len_default: i32 = 32;
                let mut len_max = if let Ok( x ) = env::var( "CICADA_GITBR_MAX_LEN" ) {
                    match x.parse::<i32>() {
                        Ok( n ) => n,
                        Err(_ ) => _len_default,
                    }
                } else {
                    _len_default
                };
                if len_max <= 0 {
                    len_max = _len_default;
                }

                if branch.len() as i32 <= len_max {
                    prompt.push_str( &branch );
                } else {
                    let len = branch.len() as i32;
                    let offset = (len - len_max + 2) as usize;
                    let branch_short = format!( "..{}", &branch[offset..]);
                    prompt.push_str( &branch_short );
                }
                if let Ok( x ) = env::var( "CICADA_GITBR_SUFFIX" ) {
                    prompt.push_str( &x);
                }
                apply_reset( prompt );
            }
        }

        pub fn apply_cwd( prompt: &mut String)
        {
            let _current_dir = match env::current_dir()
            {
                Ok( x ) => x,
                Err( e ) =>
                {
                    println_stderr!( ":: PROMPT: env current_dir error: {}", e );
                    return;
                }
            };

            let current_dir = match _current_dir.to_str()
            {
                Some( x ) => x,
                None =>
                {
                    println_stderr!( ":: PROMPT: to_str error" );
                    return;
                }
            };
            
            let _tokens: Vec<&str> = current_dir.split('/').collect();

            let last = match _tokens.last()
            {
                Some( x ) => x,
                None =>
                {
                    //log!( ":: PROMPT: token last error" );
                    return;
                }
            };

            let home = get::user_home();
            let pwd = if last.is_empty() { "/" }
            else if current_dir == home { "~" }

            else { last };

            prompt.push_str( pwd );
        }

        pub fn apply_hostname( prompt: &mut String)
        {
            let hostname = tools::get_hostname();
            prompt.push_str( &hostname );
        }

        pub fn apply_newline( prompt: &mut String) { prompt.push('\n'); }

        pub fn apply_pyenv( prompt: &mut String)
        {
            if let Ok( x ) = env::var( "VIRTUAL_ENV" )
            {
                if !x.is_empty()
                {
                    let _tokens: Vec<&str> = x.split('/').collect();
                    let env_name = match _tokens.last()
                    {
                        Some( x ) => x,
                        None =>
                        {
                            //log!( "prompt token last error" );
                            return;
                        }
                    };

                    apply_blue_b( prompt );
                    prompt.push('(');
                    prompt.push_str(env_name );
                    prompt.push(')');
                    apply_reset( prompt );
                }
            }
        }

        pub fn apply_preset_item( sh: &shell::Shell, prompt: &mut String, token:&str )
        {
            match token.to_ascii_lowercase().as_ref()
            {
                "black" => apply_black( prompt ),
                "black_b" => apply_black_b( prompt ),
                "black_bg" => apply_black_bg( prompt ),
                "blink" => apply_blink( prompt ),
                "blue" => apply_blue( prompt ),
                "blue_b" => apply_blue_b( prompt ),
                "blue_bg" => apply_blue_bg( prompt ),
                "blue_l" => apply_blue_l( prompt ),
                "blue_l_bg" => apply_blue_l_bg( prompt ),
                "bold" => apply_bold( prompt ),
                "color_status" => apply_color_status( sh, prompt ),
                "cwd" => apply_cwd( prompt ),
                "cyan" => apply_cyan( prompt ),
                "cyan_bg" => apply_cyan_bg( prompt ),
                "cyan_l" => apply_cyan_l( prompt ),
                "cyan_l_bg" => apply_cyan_l_bg( prompt ),
                "default" => apply_default( prompt ),
                "default_bg" => apply_default_bg( prompt ),
                "dim" => apply_dim( prompt ),
                "end_seq" => apply_end_seq( prompt ),
                "esc" => apply_esc( prompt ),
                "gitbr" => apply_gitbr( prompt ),
                "gray_d" => apply_gray_d( prompt ),
                "gray_d_bg" => apply_gray_d_bg( prompt ),
                "gray_l" => apply_gray_l( prompt ),
                "gray_l_bg" => apply_gray_l_bg( prompt ),
                "green" => apply_green( prompt ),
                "green_b" => apply_green_b( prompt ),
                "green_bg" => apply_green_bg( prompt ),
                "green_l" => apply_green_l( prompt ),
                "green_l_bg" => apply_green_l_bg( prompt ),
                "hidden" => apply_hidden( prompt ),
                "hostname" => apply_hostname( prompt ),
                "magenta" => apply_magenta( prompt ),
                "magenta_bg" => apply_magenta_bg( prompt ),
                "magenta_l" => apply_magenta_l( prompt ),
                "magenta_l_bg" => apply_magenta_l_bg( prompt ),
                "newline" => apply_newline( prompt ),
                "red" => apply_red( prompt ),
                "red_b" => apply_red_b( prompt ),
                "red_bg" => apply_red_bg( prompt ),
                "red_l" => apply_red_l( prompt ),
                "red_l_bg" => apply_red_l_bg( prompt ),
                "reset" => apply_reset( prompt ),
                "reset_blink" => apply_reset_blink( prompt ),
                "reset_bold" => apply_reset_bold( prompt ),
                "reset_dim" => apply_reset_dim( prompt ),
                "reset_hidden" => apply_reset_hidden( prompt ),
                "reset_reverse" => apply_reset_reverse( prompt ),
                "reset_underlined" => apply_reset_underlined( prompt ),
                "reverse" => apply_reverse( prompt ),
                "seq" => apply_seq( prompt ),
                "underlined" => apply_underlined( prompt ),
                "user" => apply_user( prompt ),
                "white" => apply_white( prompt ),
                "white_b" => apply_white_b( prompt ),
                "white_bg" => apply_white_bg( prompt ),
                "yellow" => apply_yellow( prompt ),
                "yellow_bg" => apply_yellow_bg( prompt ),
                "yellow_l" => apply_yellow_l( prompt ),
                "yellow_l_bg" => apply_yellow_l_bg( prompt ),
                _ => (),
            }
        }
    }
    // pub fn get_prompt( sh: &shell::Shell) -> String
    pub fn read( sh: &shell::Shell) -> String
    {
        let ps = read_string();
        let mut prompt = render( sh, &ps );
        if let Some((w, _h ) ) = libs::term_size::dimensions() {
            if get::prompt_len( &prompt ) > (w / 2) as i32
                && !regex::contains( &ps, r#"(?i)\$\{?newline.\}?"#)
            {
                prompt.push_str( "\n$ " );
            }
        } else {
            log!( "ERROR: Failed to get term size" );
        }
        prompt
    }
}

pub mod ptr
{
    pub use std::ptr::{ * };
}

pub mod rand
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */
    pub mod rngs
    {
        pub mod small
        {
            #[cfg(any(target_pointer_width = "32", target_pointer_width = "16"))]
            pub type Rng = super::xoshiro128plusplus::Xoshiro128PlusPlus;
            #[cfg(target_pointer_width = "64")]
            pub type Rng = super::xoshiro256plusplus::Xoshiro256PlusPlus;        
        } pub use self::small::{ * };
    } pub use self::rngs::{ * };
    
    pub mod distributions
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */
        pub mod uniform
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub trait SampleBorrow<Borrowed>
            {
                fn borrow(&self) -> &Borrowed;
            }

            pub trait SampleUniform: Sized
            {
                type Sampler: UniformSampler<X = Self>;
            }
            
            pub trait UniformSampler: Sized 
            {
                type X;
                fn new<B1, B2>(low: B1, high: B2) -> Result<Self, Error> where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized;
                
                fn new_inclusive<B1, B2>(low: B1, high: B2) -> Result<Self, Error> where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized;
                
                fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Self::X;

                fn sample_single<R: Rng + ?Sized, B1, B2>( low: B1, high: B2, rng: &mut R ) -> Result<Self::X, Error> where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized
                {
                    let uniform: Self = UniformSampler::new(low, high)?;
                    Ok(uniform.sample(rng))
                }
                
                fn sample_single_inclusive<R: Rng + ?Sized, B1, B2>
                (
                    low: B1,
                    high: B2,
                    rng: &mut R,
                ) -> Result<Self::X, Error> where
                B1: SampleBorrow<Self::X> + Sized,
                B2: SampleBorrow<Self::X> + Sized
                {
                    let uniform: Self = UniformSampler::new_inclusive(low, high)?;
                    Ok(uniform.sample(rng))
                }
            }
        }
    }
}

pub mod rc
{
    pub use std::rc::{ * };

    pub mod file
    {
        /*!
        */
        use ::
        {
            path::{ Path },
            *,
        };
        /*
        */
        pub fn read() -> String
        {
            let dir_config = tools::get_config_dir();
            let rc_file = format!( "{}/cicadarc", dir_config);
            if Path::new( &rc_file ).exists() {
                return rc_file;
            }

            // fail back to $HOME/.cicadarc
            let home = tools::get_user_home();
            let rc_file_home = format!( "{}/{}", home, ".cicadarc" );
            if Path::new( &rc_file_home ).exists() {
                return rc_file_home;
            }

            // use std path if both absent
            rc_file
        }
        // pub fn load_rc_files( sh: &mut shell::Shell)
        pub fn run( sh: &mut shell::Shell)
        {
            let rc_file = get_rc_file();
            if !Path::new( &rc_file ).exists() {
                return;
            }

            let args = vec!["source".to_string(), rc_file];
            scripting::run_script( sh, &args );
        }
    }
}

pub mod regex
{
    /*!
    Provides routines for searching strings for matches of a [regular expression] (aka "regex"). */
    pub use re::{ * };
    use ::
    {
        *,
    };
    /*
    */
    pub mod automata
    {
        /*!
        Exposes a variety of regex engines used by the `regex` crate.*/
        use ::
        {
            *,
        };
        /*
        #[cfg(any(test, feature = "std"))]
        extern crate std;

        #[cfg(feature = "alloc")]
        extern crate alloc;

        #[cfg(doctest)]
        doc_comment::doctest!("../README.md");

        #[doc(inline)]
        pub use crate::util::primitives::PatternID;
        pub use crate::util::search::*;

        #[macro_use]
        mod macros;
        
        pub mod nfa;
        pub mod util;
        
        pub mod __
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
        }
        */

        pub mod dfa
        {
            /*!
            A module for building and searching with deterministic finite automata (DFAs). */
            use ::
            {
                *,
            };
            /*
            */

            const DEAD:StateID = StateID::ZERO;
                
            pub mod dense
            {
                /*!
                Types and routines specific to dense DFAs. */
                use ::
                {
                    collections::{ BTreeMap, BTreeSet },
                    mem::{ size_of },
                    regex::
                    {
                        automata::
                        {
                            dfa::
                            {
                                accel::{ Accel, Accels }, 
                                automaton::{ fmt_state_indicator, Automaton, StartError },
                                minimize::{ Minimizer }, 
                                remapper::{ Remapper },
                                special::{ Special },
                                start::{ StartKind },
                                DEAD, determinize, sparse
                            },
                            nfa::thompson,
                        },
                    },
                    *,
                };
                /*
                use crate::{
                    util::{look::LookMatcher, search::MatchKind},
                    util::{
                        alphabet::{self, ByteClasses, ByteSet},
                        int::{Pointer, Usize},
                        prefilter::Prefilter,
                        primitives::{PatternID, StateID},
                        search::Anchored,
                        start::{self, Start, StartByteMap},
                        wire::{self, DeserializeError, Endian, SerializeError},
                    },
                };
                */

                const LABEL: &str = "rust-regex-automata-dfa-dense";

                const VERSION: u32 = 2;

                #[derive( Clone, Debug, Default )]
                pub struct Config
                {
                    accelerate:Option<bool>,
                    pre:Option<Option<Prefilter>>,
                    minimize:Option<bool>,
                    match_kind:Option<MatchKind>,
                    start_kind:Option<StartKind>,
                    starts_for_each_pattern:Option<bool>,
                    byte_classes:Option<bool>,
                    unicode_word_boundary:Option<bool>,
                    quitset:Option<ByteSet>,
                    specialize_start_states:Option<bool>,
                    dfa_size_limit:Option<Option<usize>>,
                    determinize_size_limit:Option<Option<usize>>,
                }
                
                impl Config 
                {
                    pub fn new() -> Config { Config::default() }

                    pub fn accelerate( mut self, yes:bool ) -> Config
                    {
                        self.accelerate = Some(yes);
                        self
                    }

                    pub fn prefilter( mut self, pre:Option<Prefilter>) -> Config
                    {
                        self.pre = Some(pre);
                        
                        if self.specialize_start_states.is_none()
                        {
                            self.specialize_start_states = Some( self.get_prefilter().is_some());
                        }

                        self
                    }

                    pub fn minimize( mut self, yes:bool ) -> Config
                    {
                        self.minimize = Some(yes);
                        self
                    }

                    pub fn match_kind( mut self, kind: MatchKind) -> Config
                    {
                        self.match_kind = Some(kind);
                        self
                    }

                    pub fn start_kind( mut self, kind: StartKind) -> Config
                    {
                        self.start_kind = Some(kind);
                        self
                    }

                    pub fn starts_for_each_pattern( mut self, yes:bool ) -> Config
                    {
                        self.starts_for_each_pattern = Some(yes);
                        self
                    }

                    pub fn byte_classes( mut self, yes:bool ) -> Config
                    {
                        self.byte_classes = Some(yes);
                        self
                    }

                    pub fn unicode_word_boundary( mut self, yes:bool ) -> Config
                    {
                        self.unicode_word_boundary = Some(yes);
                        self
                    }

                    pub fn quit( mut self, byte: u8, yes:bool ) -> Config
                    {
                        if self.get_unicode_word_boundary() && !byte.is_ascii() && !yes 
                        {
                            panic!( "cannot set non-ASCII byte to be non-quit when Unicode word boundaries are enabled" );
                        }

                        if self.quitset.is_none() { self.quitset = Some(ByteSet::empty()); }

                        if yes { self.quitset.as_mut().unwrap().add( byte ); }
                        
                        else { self.quitset.as_mut().unwrap().remove( byte ); }

                        self
                    }

                    pub fn specialize_start_states( mut self, yes:bool ) -> Config
                    {
                        self.specialize_start_states = Some(yes);
                        self
                    }

                    pub fn dfa_size_limit( mut self, bytes:Option<usize>) -> Config 
                    {
                        self.dfa_size_limit = Some(bytes);
                        self
                    }

                    pub fn determinize_size_limit( mut self, bytes:Option<usize>) -> Config 
                    {
                        self.determinize_size_limit = Some(bytes);
                        self
                    }

                    pub fn get_accelerate( &self ) -> bool { self.accelerate.unwrap_or(true) }

                    pub fn get_prefilter( &self ) -> Option<&Prefilter> { self.pre.as_ref().unwrap_or( &None ).as_ref() }

                    pub fn get_minimize( &self ) -> bool { self.minimize.unwrap_or( false ) }

                    pub fn get_match_kind( &self ) -> MatchKind { self.match_kind.unwrap_or(MatchKind::LeftmostFirst) }

                    pub fn get_starts( &self ) -> StartKind { self.start_kind.unwrap_or(StartKind::Both) }

                    pub fn get_starts_for_each_pattern( &self ) -> bool { self.starts_for_each_pattern.unwrap_or( false ) }

                    pub fn get_byte_classes( &self ) -> bool { self.byte_classes.unwrap_or(true) }

                    pub fn get_unicode_word_boundary( &self ) -> bool { self.unicode_word_boundary.unwrap_or( false ) }

                    pub fn get_quit(&self, byte: u8) -> bool { self.quitset.map_or(false, |q| q.contains( byte )) }

                    pub fn get_specialize_start_states( &self ) -> bool { self.specialize_start_states.unwrap_or( false ) }

                    pub fn get_dfa_size_limit( &self ) -> Option<usize> { self.dfa_size_limit.unwrap_or( None ) }

                    pub fn get_determinize_size_limit( &self ) -> Option<usize> { self.determinize_size_limit.unwrap_or( None ) }

                    pub fn overwrite(&self, o: Config) -> Config
                    {
                        Config
                        {
                            accelerate: o.accelerate.or( self.accelerate),
                            pre: o.pre.or_else(|| self.pre.clone()),
                            minimize: o.minimize.or( self.minimize),
                            match_kind: o.match_kind.or( self.match_kind),
                            start_kind: o.start_kind.or( self.start_kind),
                            starts_for_each_pattern: o
                                .starts_for_each_pattern
                                .or( self.starts_for_each_pattern),
                            byte_classes: o.byte_classes.or( self.byte_classes),
                            unicode_word_boundary: o
                                .unicode_word_boundary
                                .or( self.unicode_word_boundary),
                            quitset: o.quitset.or( self.quitset),
                            specialize_start_states: o
                                .specialize_start_states
                                .or( self.specialize_start_states),
                            dfa_size_limit: o.dfa_size_limit.or( self.dfa_size_limit),
                            determinize_size_limit: o
                                .determinize_size_limit
                                .or( self.determinize_size_limit),
                        }
                    }
                }

                #[derive( Clone, Debug )]
                pub struct Builder
                {
                    config: Config,
                    thompson: thompson::Compiler,
                }
                
                impl Builder
                {
                    pub fn new() -> Builder {
                        Builder {
                            config: Config::default(),
                                    thompson: thompson::Compiler::new(),
                        }
                    }

                    pub fn build(&self, pattern: &str) -> Result<OwnedDFA, BuildError> { self.build_many(&[pattern]) }

                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<OwnedDFA, BuildError>
                    {
                        let nfa = self
                            .thompson
                            .clone()
                            .configure(
                                thompson::Config::new()
                                    .which_captures(thompson::WhichCaptures::None),
                            )
                            .build_many(patterns)
                            .map_err(BuildError::nfa)?;
                        self.build_from_nfa(&nfa)
                    }

                    pub fn build_from_nfa(
                        &self,
                        nfa: &thompson::NFA,
                    ) -> Result<OwnedDFA, BuildError>
                    {
                        let mut quitset = self.config.quitset.unwrap_or(ByteSet::empty());
                        if self.config.get_unicode_word_boundary()
                            && nfa.look_set_any().contains_word_unicode()
                        {
                            for b in 0x80..=0xFF {
                                quitset.add(b);
                            }
                        }
                        let classes = if !self.config.get_byte_classes() {
                            ByteClasses::singletons()
                        } else {
                            let mut set = nfa.byte_class_set().clone();
                            if !quitset.is_empty() {
                                set.add_set(&quitset);
                            }
                            set.byte_classes()
                        };

                        let mut dfa = DFA::initial(
                            classes,
                            nfa.pattern_len(),
                            self.config.get_starts(),
                            nfa.look_matcher(),
                            self.config.get_starts_for_each_pattern(),
                            self.config.get_prefilter().map(|p| p.clone()),
                            quitset,
                            Flags::from_nfa(&nfa),
                        )?;
                        determinize::Config::new()
                            .match_kind( self.config.get_match_kind())
                            .quit(quitset)
                            .dfa_size_limit( self.config.get_dfa_size_limit())
                            .determinize_size_limit( self.config.get_determinize_size_limit())
                            .run(nfa, &mut dfa)?;
                        if self.config.get_minimize() {
                            dfa.minimize();
                        }
                        if self.config.get_accelerate() {
                            dfa.accelerate();
                        }
                        
                        if !self.config.get_specialize_start_states() {
                            dfa.special.set_no_special_start_states();
                        }
                        
                        dfa.set_universal_starts();
                        dfa.tt.table.shrink_to_fit();
                        dfa.st.table.shrink_to_fit();
                        dfa.ms.slices.shrink_to_fit();
                        dfa.ms.pattern_ids.shrink_to_fit();
                        Ok(dfa)
                    }

                    pub fn configure( &mut self, config: Config) -> &mut Builder {
                        self.config = self.config.overwrite(config);
                        self
                    }

                    pub fn syntax(
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.thompson.syntax(config);
                        self
                    }

                    pub fn thompson( &mut self, config: thompson::Config) -> &mut Builder {
                        self.thompson.configure(config);
                        self
                    }
                }
                
                impl Default for Builder
                {
                    fn default() -> Builder {
                        Builder::new()
                    }
                }

                pub type OwnedDFA = DFA<alloc::vec::Vec<u32>>;

                #[derive( Clone )]
                pub struct DFA<T> 
                {

                    tt: TransitionTable<T>,
                    st: StartTable<T>,
                    ms: MatchStates<T>,
                    special: Special,
                    accels: Accels<T>,
                    pre:Option<Prefilter>,
                    quitset: ByteSet,
                    flags: Flags,
                }
                
                impl OwnedDFA
                {
                    pub fn new(pattern: &str) -> Result<OwnedDFA, BuildError> { Builder::new().build(pattern) }

                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<OwnedDFA, BuildError> { Builder::new().build_many(patterns) }
                }
                
                impl OwnedDFA
                {
                    pub fn always_match() -> Result<OwnedDFA, BuildError>
                    {
                        let nfa = thompson::NFA::always_match();
                        Builder::new().build_from_nfa(&nfa)
                    }

                    pub fn never_match() -> Result<OwnedDFA, BuildError>
                    {
                        let nfa = thompson::NFA::never_match();
                        Builder::new().build_from_nfa(&nfa)
                    }

                    fn initial(
                        classes: ByteClasses,
                        pattern_len: usize,
                        starts: StartKind,
                        lookm: &LookMatcher,
                        starts_for_each_pattern: bool,
                        pre:Option<Prefilter>,
                        quitset: ByteSet,
                        flags: Flags,
                    ) -> Result<OwnedDFA, BuildError>
                    {
                        let start_pattern_len =
                            if starts_for_each_pattern { Some(pattern_len) } else { None };
                        Ok(DFA {
                            tt: TransitionTable::minimal(classes),
                            st: StartTable::dead(starts, lookm, start_pattern_len)?,
                            ms: MatchStates::empty(pattern_len),
                            special: Special::new(),
                            accels: Accels::empty(),
                            pre,
                            quitset,
                            flags,
                        })
                    }
                }
                
                impl DFA<&[u32]>
                {
                    pub fn config() -> Config {
                        Config::new()
                    }

                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                }

                impl<T: AsRef<[u32]>> DFA<T>
                {
                    pub fn as_ref( &self ) -> DFA<&'_ [u32]> 
                    {
                        DFA 
                        {
                            tt: self.tt.as_ref(),
                            st: self.st.as_ref(),
                            ms: self.ms.as_ref(),
                            special: self.special,
                            accels: self.accels(),
                            pre: self.pre.clone(),
                            quitset: self.quitset,
                            flags: self.flags,
                        }
                    }

                    pub fn to_owned( &self ) -> OwnedDFA 
                    {
                        DFA 
                        {
                            tt: self.tt.to_owned(),
                            st: self.st.to_owned(),
                            ms: self.ms.to_owned(),
                            special: self.special,
                            accels: self.accels().to_owned(),
                            pre: self.pre.clone(),
                            quitset: self.quitset,
                            flags: self.flags,
                        }
                    }

                    pub fn start_kind( &self ) -> StartKind { self.st.kind }
                    
                    pub fn start_map( &self ) -> &StartByteMap { &self.st.start_map }

                    pub fn starts_for_each_pattern( &self ) -> bool { self.st.pattern_len.is_some() }

                    pub fn byte_classes( &self ) -> &ByteClasses { &self.tt.classes }

                    pub fn alphabet_len( &self ) -> usize { self.tt.alphabet_len() }
                    
                    pub fn stride2( &self ) -> usize { self.tt.stride2 }
                    
                    pub fn stride( &self ) -> usize { self.tt.stride() }

                    pub fn memory_usage( &self ) -> usize {
                        self.tt.memory_usage()
                            + self.st.memory_usage()
                            + self.ms.memory_usage()
                            + self.accels.memory_usage()
                    }
                }
                impl<T: AsRef<[u32]>> DFA<T> {

                        pub fn to_sparse( &self ) -> Result<sparse::DFA<Vec<u8>>, BuildError> { sparse::DFA::from_dense(self) }
                        pub fn to_bytes_little_endian( &self ) -> (Vec<u8>, usize) { self.to_bytes::<wire::LE>() }
                        pub fn to_bytes_big_endian( &self ) -> (Vec<u8>, usize) { self.to_bytes::<wire::BE>() }
                        pub fn to_bytes_native_endian( &self ) -> (Vec<u8>, usize) { self.to_bytes::<wire::NE>() }
                        fn to_bytes<E: Endian>( &self ) -> (Vec<u8>, usize) {
                        let len = self.write_to_len();
                        let (mut buf, padding) = wire::alloc_aligned_buffer::<u32>(len);
                        self.as_ref().write_to::<E>(&mut buf[padding..]).unwrap();
                        (buf, padding)
                    }
                    
                    pub fn write_to_little_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> { self.as_ref().write_to::<wire::LE>(dst) }
                    
                    pub fn write_to_big_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> { self.as_ref().write_to::<wire::BE>(dst) }
                    
                    pub fn write_to_native_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> { self.as_ref().write_to::<wire::NE>(dst) }
                    
                    pub fn write_to_len( &self ) -> usize {
                        wire::write_label_len(LABEL)
                        + wire::write_endianness_check_len()
                        + wire::write_version_len()
                        + size_of::<u32>()
                        + self.flags.write_to_len()
                        + self.tt.write_to_len()
                        + self.st.write_to_len()
                        + self.ms.write_to_len()
                        + self.special.write_to_len()
                        + self.accels.write_to_len()
                        + self.quitset.write_to_len()
                    }
                }

                impl<'a> DFA<&'a [u32]> {
                    pub fn from_bytes(
                        slice: &'a [u8],
                    ) -> Result<(DFA<&'a [u32]>, usize), DeserializeError> {
                        let (dfa, nread) = unsafe { DFA::from_bytes_unchecked(slice)? };
                        dfa.accels.validate()?;
                        dfa.ms.validate(&dfa)?;
                        dfa.tt.validate(&dfa)?;
                        dfa.st.validate(&dfa)?;
                        for state in dfa.states() {
                            if dfa.is_accel_state(state.id()) {
                                let index = dfa.accelerator_index(state.id());
                                if index >= dfa.accels.len() {
                                    return Err(DeserializeError::generic(
                                        "found DFA state with invalid accelerator index",
                                    ));
                                }
                                let needles = dfa.accels.needles(index);
                                if !(1 <= needles.len() && needles.len() <= 3) {
                                    return Err(DeserializeError::generic(
                                        "accelerator needles has invalid length",
                                    ));
                                }
                            }
                        }
                        Ok((dfa, nread))
                    }
                    
                    pub unsafe fn from_bytes_unchecked(
                        slice: &'a [u8],
                    ) -> Result<(DFA<&'a [u32]>, usize), DeserializeError>
                    {
                        let mut nr = 0;

                        nr += wire::skip_initial_padding(slice);
                        wire::check_alignment::<StateID>(&slice[nr..])?;
                        nr += wire::read_label(&slice[nr..], LABEL)?;
                        nr += wire::read_endianness_check(&slice[nr..])?;
                        nr += wire::read_version(&slice[nr..], VERSION)?;

                        let _unused = wire::try_read_u32(&slice[nr..], "unused space")?;
                        nr += size_of::<u32>();

                        let (flags, nread) = Flags::from_bytes(&slice[nr..])?;
                        nr += nread;

                        let (tt, nread) = TransitionTable::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (st, nread) = StartTable::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (ms, nread) = MatchStates::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (special, nread) = Special::from_bytes(&slice[nr..])?;
                        nr += nread;
                        special.validate_state_len(tt.len(), tt.stride2)?;

                        let (accels, nread) = Accels::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (quitset, nread) = ByteSet::from_bytes(&slice[nr..])?;
                        nr += nread;
                        
                        let pre = None;
                        Ok((DFA { tt, st, ms, special, accels, pre, quitset, flags }, nr))
                    }
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("dense DFA"));
                        }
                        dst = &mut dst[..nwrite];

                        let mut nw = 0;
                        nw += wire::write_label(LABEL, &mut dst[nw..])?;
                        nw += wire::write_endianness_check::<E>(&mut dst[nw..])?;
                        nw += wire::write_version::<E>(VERSION, &mut dst[nw..])?;
                        nw += {
                            E::write_u32(0, &mut dst[nw..]);
                            size_of::<u32>()
                        };
                        nw += self.flags.write_to::<E>(&mut dst[nw..])?;
                        nw += self.tt.write_to::<E>(&mut dst[nw..])?;
                        nw += self.st.write_to::<E>(&mut dst[nw..])?;
                        nw += self.ms.write_to::<E>(&mut dst[nw..])?;
                        nw += self.special.write_to::<E>(&mut dst[nw..])?;
                        nw += self.accels.write_to::<E>(&mut dst[nw..])?;
                        nw += self.quitset.write_to::<E>(&mut dst[nw..])?;
                        Ok(nw)
                    }
                }

                impl<T> DFA<T>
                {
                    pub fn set_prefilter( &mut self, prefilter:Option<Prefilter>) {
                        self.pre = prefilter
                    }
                }
                
                impl OwnedDFA
                {
                    pub fn set_start_state(
                        &mut self,
                        anchored: Anchored,
                        start: Start,
                        id: StateID,
                    ) {
                        assert!( self.tt.is_valid(id), "invalid start state");
                        self.st.set_start(anchored, start, id);
                    }
                    
                    pub fn set_transition(
                        &mut self,
                        from: StateID,
                        byte: alphabet::Unit,
                        to: StateID,
                    ) {
                        self.tt.set(from, byte, to);
                    }

                    pub fn add_empty_state(&mut self) -> Result<StateID, BuildError> { self.tt.add_empty_state() }

                    pub fn swap_states( &mut self, id1: StateID, id2: StateID) {
                        self.tt.swap(id1, id2);
                    }

                    pub fn remap( &mut self, map: impl Fn(StateID) -> StateID) {
                        for sid in self.tt.table_mut().iter_mut() {
                            *sid = map(*sid);
                        }
                        for sid in self.st.table_mut().iter_mut() {
                            *sid = map(*sid);
                        }
                    }

                    pub fn remap_state(
                        &mut self,
                        id: StateID,
                        map: impl Fn(StateID) -> StateID,
                    ) {
                        self.tt.remap(id, map);
                    }

                    pub fn truncate_states( &mut self, len: usize) {
                        self.tt.truncate(len);
                    }

                    pub fn minimize(&mut self) {
                        Minimizer::new(self).run();
                    }

                    pub fn set_pattern_map(
                        &mut self,
                        map: &BTreeMap<StateID, Vec<PatternID>>,
                    ) -> Result<(), BuildError> {
                        self.ms = self.ms.new_with_map(map)?;
                        Ok( () )
                    }
                    
                    pub fn accelerate(&mut self) {
                        if self.state_len() <= 2 { return; }
                        
                        let mut accels = BTreeMap::new();
                        let (mut cmatch, mut cstart, mut cnormal) = (0, 0, 0);
                        for state in self.states() {
                            if let Some(accel) = state.accelerate( self.byte_classes()) {
                                accels.insert(state.id(), accel);
                                if self.is_match_state(state.id()) {
                                    cmatch += 1;
                                } else if self.is_start_state(state.id()) {
                                    cstart += 1;
                                } else {
                                    assert!(!self.is_dead_state(state.id()));
                                    assert!(!self.is_quit_state(state.id()));
                                    cnormal += 1;
                                }
                            }
                        }

                        if accels.is_empty() { return; }
                        let original_accels_len = accels.len();
                        
                        let mut remapper = Remapper::new(self);
                        let mut new_matches = self.ms.to_map(self);
                        self.special.min_accel = StateID::MAX;
                        self.special.max_accel = StateID::ZERO;
                        let update_special_accel =
                            |special: &mut Special, accel_id: StateID| {
                                special.min_accel = cmp::min(special.min_accel, accel_id);
                                special.max_accel = cmp::max(special.max_accel, accel_id);
                            };
                        if cmatch > 0 && self.special.matches() {
                            let mut next_id = self.special.max_match;
                            let mut cur_id = next_id;
                            while cur_id >= self.special.min_match {
                                if let Some(accel) = accels.remove(&cur_id) {
                                    accels.insert(next_id, accel);
                                    update_special_accel(&mut self.special, next_id);
                                    if cur_id != next_id {
                                        remapper.swap(self, cur_id, next_id);
                                        let cur_pids = new_matches.remove(&cur_id).unwrap();
                                        let next_pids = new_matches.remove(&next_id).unwrap();
                                        new_matches.insert(cur_id, next_pids);
                                        new_matches.insert(next_id, cur_pids);
                                    }
                                    next_id = self.tt.prev_state_id(next_id);
                                }
                                cur_id = self.tt.prev_state_id(cur_id);
                            }
                        }
                        
                        if cnormal > 0 {
                            let mut next_start_id = self.special.min_start;
                            let mut cur_id = self.to_state_id( self.state_len() - 1);
                            let mut next_norm_id =
                                self.tt.next_state_id( self.special.max_start);
                            while cur_id >= next_norm_id {
                                if let Some(accel) = accels.remove(&cur_id) {
                                    remapper.swap(self, next_start_id, cur_id);
                                    remapper.swap(self, next_norm_id, cur_id);
                                    if let Some(accel2) = accels.remove(&next_norm_id) {
                                        accels.insert(cur_id, accel2);
                                    }
                                    if let Some(accel2) = accels.remove(&next_start_id) {
                                        accels.insert(next_norm_id, accel2);
                                    }
                                    accels.insert(next_start_id, accel);
                                    update_special_accel(&mut self.special, next_start_id);
                                    self.special.min_start =
                                        self.tt.next_state_id( self.special.min_start);
                                    self.special.max_start =
                                        self.tt.next_state_id( self.special.max_start);
                                    next_start_id = self.tt.next_state_id(next_start_id);
                                    next_norm_id = self.tt.next_state_id(next_norm_id);
                                }
                                
                                if !accels.contains_key(&cur_id) {
                                    cur_id = self.tt.prev_state_id(cur_id);
                                }
                            }
                        }
                        if cstart > 0 {
                            let mut next_id = self.special.min_start;
                            let mut cur_id = next_id;
                            while cur_id <= self.special.max_start {
                                if let Some(accel) = accels.remove(&cur_id) {
                                    remapper.swap(self, cur_id, next_id);
                                    accels.insert(next_id, accel);
                                    update_special_accel(&mut self.special, next_id);
                                    next_id = self.tt.next_state_id(next_id);
                                }
                                cur_id = self.tt.next_state_id(cur_id);
                            }
                        }
                        
                        remapper.remap(self);
                        self.set_pattern_map(&new_matches).unwrap();
                        self.special.set_max();
                        self.special.validate().expect("special state ranges should validate");
                        self.special
                            .validate_state_len( self.state_len(), self.stride2())
                            .expect(
                                "special state ranges should be consistent with state length",
                            );
                        assert_eq!(
                            self.special.accel_len( self.stride()),
                            original_accels_len,
                            "mismatch with expected number of accelerated states",
                        );
                        let mut prev:Option<StateID> = None;
                        for (id, accel) in accels {
                            assert!(prev.map_or(true, |p| self.tt.next_state_id(p) == id));
                            prev = Some(id);
                            self.accels.add(accel);
                        }
                    }
                    
                    pub fn shuffle(
                        &mut self,
                        mut matches: BTreeMap<StateID, Vec<PatternID>>,
                    ) -> Result<(), BuildError> {
                        self.special.quit_id = self.to_state_id(1);
                        if self.state_len() <= 2 {
                            self.special.set_max();
                            return Ok( () );
                        }
                        let mut is_start: BTreeSet<StateID> = BTreeSet::new();
                        for (start_id, _, _) in self.starts() {
                            if start_id == DEAD {
                                continue;
                            }
                            assert!(
                                !matches.contains_key(&start_id),
                                "{start_id:?} is both a start and a match state, \
                                which is not allowed",
                            );
                            is_start.insert(start_id);
                        }
                        
                        let mut remapper = Remapper::new(self);
                        
                        if matches.is_empty() {
                            self.special.min_match = DEAD;
                            self.special.max_match = DEAD;
                        } else {
                            
                            let mut next_id = self.to_state_id(2);
                            let mut new_matches = BTreeMap::new();
                            self.special.min_match = next_id;
                            for (id, pids) in matches {
                                remapper.swap(self, next_id, id);
                                new_matches.insert(next_id, pids);
                                if is_start.contains(&next_id) {
                                    is_start.remove(&next_id);
                                    is_start.insert(id);
                                }
                                next_id = self.tt.next_state_id(next_id);
                            }
                            matches = new_matches;
                            self.special.max_match = cmp::max(
                                self.special.min_match,
                                self.tt.prev_state_id(next_id),
                            );
                        }
                        
                        {
                            let mut next_id = self.to_state_id(2);
                            if self.special.matches() {
                                next_id = self.tt.next_state_id( self.special.max_match);
                            }
                            self.special.min_start = next_id;
                            for id in is_start {
                                remapper.swap(self, next_id, id);
                                next_id = self.tt.next_state_id(next_id);
                            }
                            self.special.max_start = cmp::max(
                                self.special.min_start,
                                self.tt.prev_state_id(next_id),
                            );
                        }
                        
                        remapper.remap(self);
                        self.set_pattern_map(&matches)?;
                        self.special.set_max();
                        self.special.validate().expect("special state ranges should validate");
                        self.special
                            .validate_state_len( self.state_len(), self.stride2())
                            .expect(
                                "special state ranges should be consistent with state length",
                            );
                        Ok( () )
                    }
                    fn set_universal_starts(&mut self) {
                        assert_eq!(6, Start::len(), "expected 6 start configurations");

                        let start_id = |dfa: &mut OwnedDFA,
                                        anchored: Anchored,
                                        start: Start| {
                            dfa.st.start(anchored, start).expect("valid Input configuration")
                        };
                        if self.start_kind().has_unanchored() {
                            let anchor = Anchored::No;
                            let sid = start_id(self, anchor, Start::NonWordByte);
                            if sid == start_id(self, anchor, Start::WordByte)
                                && sid == start_id(self, anchor, Start::Text)
                                && sid == start_id(self, anchor, Start::LineLF)
                                && sid == start_id(self, anchor, Start::LineCR)
                                && sid == start_id(self, anchor, Start::CustomLineTerminator)
                            {
                                self.st.universal_start_unanchored = Some(sid);
                            }
                        }
                        if self.start_kind().has_anchored() {
                            let anchor = Anchored::Yes;
                            let sid = start_id(self, anchor, Start::NonWordByte);
                            if sid == start_id(self, anchor, Start::WordByte)
                                && sid == start_id(self, anchor, Start::Text)
                                && sid == start_id(self, anchor, Start::LineLF)
                                && sid == start_id(self, anchor, Start::LineCR)
                                && sid == start_id(self, anchor, Start::CustomLineTerminator)
                            {
                                self.st.universal_start_anchored = Some(sid);
                            }
                        }
                    }
                }
                
                impl<T: AsRef<[u32]>> DFA<T>
                {
                    pub fn special( &self ) -> &Special { &self.special }

                        pub fn special_mut(&mut self) -> &mut Special {
                        &mut self.special
                    }

                    pub fn quitset( &self ) -> &ByteSet { &self.quitset }

                    pub fn flags( &self ) -> &Flags { &self.flags }

                    pub fn states( &self ) -> StateIter<'_, T> { self.tt.states() }
                    
                    pub fn state_len( &self ) -> usize { self.tt.len() }

                        pub fn pattern_id_slice(&self, id: StateID) -> &[PatternID] {
                        assert!( self.is_match_state(id));
                        self.ms.pattern_id_slice( self.match_state_index(id))
                    }

                    pub fn match_pattern_len(&self, id: StateID) -> usize {
                        assert!( self.is_match_state(id));
                        self.ms.pattern_len( self.match_state_index(id))
                    }

                    pub fn pattern_len( &self ) -> usize { self.ms.pattern_len }
                        pub fn pattern_map( &self ) -> BTreeMap<StateID, Vec<PatternID>> { self.ms.to_map(self) }

                        pub fn quit_id( &self ) -> StateID { self.to_state_id(1) }
                    
                    pub fn to_index(&self, id: StateID) -> usize {
                        self.tt.to_index(id)
                    }
                        pub fn to_state_id(&self, index: usize) -> StateID {
                        self.tt.to_state_id(index)
                    }

                    pub fn starts( &self ) -> StartStateIter<'_> { self.st.iter() }
                    #[inline( always )] fn match_state_index(&self, id: StateID) -> usize {
                        debug_assert!( self.is_match_state(id));
                        
                        let min = self.special().min_match.as_usize();
                        self.to_index(StateID::new_unchecked(id.as_usize() - min))
                    }
                    fn accelerator_index(&self, id: StateID) -> usize {
                        let min = self.special().min_accel.as_usize();
                        self.to_index(StateID::new_unchecked(id.as_usize() - min))
                    }

                    fn accels( &self ) -> Accels<&[u32]> { self.accels.as_ref() }

                    fn trans( &self ) -> &[StateID] { self.tt.table() }
                }

                impl<T: AsRef<[u32]>> fmt::Debug for DFA<T>
               
               
                {
                    fn fmt( &self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        writeln!(f, "dense::DFA(")?;
                        for state in self.states() {
                            fmt_state_indicator(f, self, state.id())?;
                            let id = if f.alternate() {
                                state.id().as_usize()
                            } else {
                                self.to_index(state.id())
                            };
                            write!(f, "{id:06?}: ")?;
                            state.fmt(f)?;
                            write!(f, "\n")?;
                        }
                        writeln!(f, "")?;
                        for (i, (start_id, anchored, sty)) in self.starts().enumerate() {
                            let id = if f.alternate() {
                                start_id.as_usize()
                            } else {
                                self.to_index(start_id)
                            };
                            if i % self.st.stride == 0 {
                                match anchored {
                                    Anchored::No => writeln!(f, "START-GROUP(unanchored)")?,
                                    Anchored::Yes => writeln!(f, "START-GROUP(anchored)")?,
                                    Anchored::Pattern(pid) => { writeln!(f, "START_GROUP(pattern: {pid:?})")? }
                                }
                            }
                            writeln!(f, "  {sty:?} => {id:06?}")?;
                        }
                        if self.pattern_len() > 1 {
                            writeln!(f, "")?;
                            for i in 0..self.ms.len() {
                                let id = self.ms.match_state_id(self, i);
                                let id = if f.alternate() {
                                    id.as_usize()
                                } else {
                                    self.to_index(id)
                                };
                                write!(f, "MATCH({id:06?}): ")?;
                                for (i, &pid) in self.ms.pattern_id_slice(i).iter().enumerate()
                                {
                                    if i > 0 {
                                        write!(f, ",")?;
                                    }
                                    write!(f, "{pid:?}")?;
                                }
                                writeln!(f, "")?;
                            }
                        }
                        writeln!(f, "state length: {:?}", self.state_len())?;
                        writeln!(f, "pattern length: {:?}", self.pattern_len())?;
                        writeln!(f, "flags: {:?}", self.flags)?;
                        writeln!(f, ")")?;
                        Ok( () )
                    }
                }
                
                unsafe impl<T: AsRef<[u32]>> Automaton for DFA<T> {
                    #[inline( always )] fn is_special_state(&self, id: StateID) -> bool {
                        self.special.is_special_state(id)
                    }

                    #[inline( always )] fn is_dead_state(&self, id: StateID) -> bool {
                        self.special.is_dead_state(id)
                    }

                    #[inline( always )] fn is_quit_state(&self, id: StateID) -> bool {
                        self.special.is_quit_state(id)
                    }

                    #[inline( always )] fn is_match_state(&self, id: StateID) -> bool {
                        self.special.is_match_state(id)
                    }

                    #[inline( always )] fn is_start_state(&self, id: StateID) -> bool {
                        self.special.is_start_state(id)
                    }

                    #[inline( always )] fn is_accel_state(&self, id: StateID) -> bool {
                        self.special.is_accel_state(id)
                    }

                    #[inline( always )] fn next_state(&self, current: StateID, input: u8) -> StateID {
                        let input = self.byte_classes().get(input);
                        let o = current.as_usize() + usize::from(input);
                        self.trans()[o]
                    }

                    #[inline( always )]
                    unsafe fn next_state_unchecked(
                        &self,
                        current: StateID,
                        byte: u8,
                    ) -> StateID {
                        let class = self.byte_classes().get( byte );
                        let o = current.as_usize() + usize::from(class);
                        let next = *self.trans().get_unchecked(o);
                        next
                    }

                    #[inline( always )] fn next_eoi_state(&self, current: StateID) -> StateID {
                        let eoi = self.byte_classes().eoi().as_usize();
                        let o = current.as_usize() + eoi;
                        self.trans()[o]
                    }

                    #[inline( always )] fn pattern_len( &self ) -> usize { self.ms.pattern_len }

                    #[inline( always )] fn match_len(&self, id: StateID) -> usize {
                        self.match_pattern_len(id)
                    }

                    #[inline( always )] fn match_pattern(&self, id: StateID, match_index: usize) -> PatternID {
                        if self.ms.pattern_len == 1 {
                            return PatternID::ZERO;
                        }
                        let state_index = self.match_state_index(id);
                        self.ms.pattern_id(state_index, match_index)
                    }

                    #[inline( always )] fn has_empty( &self ) -> bool { self.flags.has_empty }

                    #[inline( always )] fn is_utf8( &self ) -> bool { self.flags.is_utf8 }

                    #[inline( always )] fn is_always_start_anchored( &self ) -> bool { self.flags.is_always_start_anchored }

                    #[inline( always )] fn start_state(
                        &self,
                        config: &start::Config,
                    ) -> Result<StateID, StartError>
                    {
                        let anchored = config.get_anchored();
                        let start = match config.get_look_behind() {
                            None => Start::Text,
                            Some( byte ) => {
                                if !self.quitset.is_empty() && self.quitset.contains( byte ) {
                                    return Err(StartError::quit( byte ));
                                }
                                self.st.start_map.get( byte )
                            }
                        };
                        self.st.start(anchored, start)
                    }

                    #[inline( always )] fn universal_start_state(&self, mode: Anchored) -> Option<StateID> {
                        match mode {
                            Anchored::No => self.st.universal_start_unanchored,
                            Anchored::Yes => self.st.universal_start_anchored,
                            Anchored::Pattern(_) => None,
                        }
                    }

                    #[inline( always )] fn accelerator(&self, id: StateID) -> &[u8] {
                        if !self.is_accel_state(id) {
                            return &[];
                        }
                        self.accels.needles( self.accelerator_index(id))
                    }

                    #[inline( always )] fn get_prefilter( &self ) -> Option<&Prefilter> { self.pre.as_ref() }
                }

                #[derive( Clone )]
                pub struct TransitionTable<T> {
                    table: T,
                    classes: ByteClasses,
                    stride2: usize,
                }

                impl<'a> TransitionTable<&'a [u32]> {

                    unsafe fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(TransitionTable<&'a [u32]>, usize), DeserializeError>
                    {
                        let slice_start = slice.as_ptr().as_usize();

                        let (state_len, nr) =
                            wire::try_read_u32_as_usize(slice, "state length")?;
                        slice = &slice[nr..];

                        let (stride2, nr) = wire::try_read_u32_as_usize(slice, "stride2")?;
                        slice = &slice[nr..];

                        let (classes, nr) = ByteClasses::from_bytes(slice)?;
                        slice = &slice[nr..];
                        if stride2 > 9 {
                            return Err(DeserializeError::generic(
                                "dense DFA has invalid stride2 (too big)",
                            ));
                        }
                        if stride2 < 1 {
                            return Err(DeserializeError::generic(
                                "dense DFA has invalid stride2 (too small)",
                            ));
                        }
                        
                        let stride =
                            1usize.checked_shl(u32::try_from(stride2).unwrap()).unwrap();
                        if classes.alphabet_len() > stride {
                            return Err(DeserializeError::generic(
                                "alphabet size cannot be bigger than transition table stride",
                            ));
                        }

                        let trans_len =
                            wire::shl(state_len, stride2, "dense table transition length")?;
                        let table_bytes_len = wire::mul(
                            trans_len,
                            StateID::SIZE,
                            "dense table state byte length",
                        )?;
                        wire::check_slice_len(slice, table_bytes_len, "transition table")?;
                        wire::check_alignment::<StateID>(slice)?;
                        let table_bytes = &slice[..table_bytes_len];
                        slice = &slice[table_bytes_len..];
                        
                        let table = ::slice::from_raw_parts(
                            table_bytes.as_ptr().cast::<u32>(),
                            trans_len,
                        );
                        let tt = TransitionTable { table, classes, stride2 };
                        Ok((tt, slice.as_ptr().as_usize() - slice_start))
                    }
                }
                
                impl TransitionTable<Vec<u32>>
                {
                    fn minimal(classes: ByteClasses) -> TransitionTable<Vec<u32>>
                    {
                        let mut tt = TransitionTable {
                            table: vec![],
                            classes,
                            stride2: classes.stride2(),
                        };
                        tt.add_empty_state().unwrap(); 
                        tt.add_empty_state().unwrap(); 
                        tt
                    }
                    fn set( &mut self, from: StateID, unit: alphabet::Unit, to: StateID) {
                        assert!( self.is_valid(from), "invalid 'from' state");
                        assert!( self.is_valid(to), "invalid 'to' state");
                        self.table[from.as_usize() + self.classes.get_by_unit(unit)] =
                            to.as_u32();
                    }
                    fn add_empty_state(&mut self) -> Result<StateID, BuildError> {
                        let next = self.table.len();
                        let id =
                            StateID::new(next).map_err(|_| BuildError::too_many_states())?;
                        self.table.extend(iter::repeat(0).take( self.stride()));
                        Ok(id)
                    }

                    fn swap( &mut self, id1: StateID, id2: StateID) {
                        assert!( self.is_valid(id1), "invalid 'id1' state: {id1:?}");
                        assert!( self.is_valid(id2), "invalid 'id2' state: {id2:?}");
                        for b in 0..self.classes.alphabet_len() {
                            self.table.swap(id1.as_usize() + b, id2.as_usize() + b);
                        }
                    }
                    fn remap( &mut self, id: StateID, map: impl Fn(StateID) -> StateID) {
                        for byte in 0..self.alphabet_len() {
                            let i = id.as_usize() + byte;
                            let next = self.table()[i];
                            self.table_mut()[id.as_usize() + byte] = map(next);
                        }
                    }

                    fn truncate( &mut self, len: usize) {
                        self.table.truncate(len << self.stride2);
                    }
                }

                impl<T: AsRef<[u32]>> TransitionTable<T> {

                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("transition table"));
                        }
                        dst = &mut dst[..nwrite];
                        E::write_u32(u32::try_from( self.len()).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(u32::try_from( self.stride2).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        
                        let n = self.classes.write_to(dst)?;
                        dst = &mut dst[n..];
                        for &sid in self.table() {
                            let n = wire::write_state_id::<E>(sid, &mut dst);
                            dst = &mut dst[n..];
                        }
                        Ok(nwrite)
                    }
                    fn write_to_len( &self ) -> usize {
                        size_of::<u32>()   // state length
                        + size_of::<u32>() // stride2
                        + self.classes.write_to_len()
                        + ( self.table().len() * StateID::SIZE)
                    }
                    fn validate(&self, dfa: &DFA<T>) -> Result<(), DeserializeError>
                    {
                        let sp = &dfa.special;
                        for state in self.states() {
                            // match or start state.
                            if sp.is_special_state(state.id()) {
                                let is_actually_special = sp.is_dead_state(state.id())
                                    || sp.is_quit_state(state.id())
                                    || sp.is_match_state(state.id())
                                    || sp.is_start_state(state.id())
                                    || sp.is_accel_state(state.id());
                                if !is_actually_special {
                                    // This is kind of a cryptic error message...
                                    return Err(DeserializeError::generic(
                                        "found dense state tagged as special but \
                                        wasn't actually special",
                                    ));
                                }
                                if sp.is_match_state(state.id())
                                    && dfa.match_len(state.id()) == 0
                                {
                                    return Err(DeserializeError::generic(
                                        "found match state with zero pattern IDs",
                                    ));
                                }
                            }
                            for (_, to) in state.transitions() {
                                if !self.is_valid(to) {
                                    return Err(DeserializeError::generic(
                                        "found invalid state ID in transition table",
                                    ));
                                }
                            }
                        }
                        Ok( () )
                    }

                    fn as_ref( &self ) -> TransitionTable<&'_ [u32]> {
                        TransitionTable {
                            table: self.table.as_ref(),
                            classes: self.classes.clone(),
                            stride2: self.stride2,
                        }
                    }

                    fn to_owned( &self ) -> TransitionTable<alloc::vec::Vec<u32>> {
                        TransitionTable {
                            table: self.table.as_ref().to_vec(),
                            classes: self.classes.clone(),
                            stride2: self.stride2,
                        }
                    }

                    fn state(&self, id: StateID) -> State<'_> {
                        assert!( self.is_valid(id));

                        let i = id.as_usize();
                        State {
                            id,
                            stride2: self.stride2,
                            transitions: &self.table()[i..i + self.alphabet_len()],
                        }
                    }

                    fn states( &self ) -> StateIter<'_, T> {
                        StateIter {
                            tt: self,
                            it: self.table().chunks( self.stride()).enumerate(),
                        }
                    }

                    fn to_index(&self, id: StateID) -> usize {
                        id.as_usize() >> self.stride2
                    }

                    fn to_state_id(&self, index: usize) -> StateID {
                        StateID::new_unchecked(index << self.stride2)
                    }

                        fn next_state_id(&self, id: StateID) -> StateID {
                        self.to_state_id( self.to_index(id).checked_add(1).unwrap())
                    }

                        fn prev_state_id(&self, id: StateID) -> StateID {
                        self.to_state_id( self.to_index(id).checked_sub(1).unwrap())
                    }

                    fn table( &self ) -> &[StateID] { wire::u32s_to_state_ids( self.table.as_ref()) }

                    fn len( &self ) -> usize { self.table().len() >> self.stride2 }

                    fn stride( &self ) -> usize { 1 << self.stride2 }

                    fn alphabet_len( &self ) -> usize { self.classes.alphabet_len() }

                    fn is_valid(&self, id: StateID) -> bool
                    {
                        let id = id.as_usize();
                        id < self.table().len() && id % self.stride() == 0
                    }

                    fn memory_usage( &self ) -> usize { self.table().len() * StateID::SIZE }
                }
                
                impl<T: AsMut<[u32]>> TransitionTable<T> {

                    fn table_mut(&mut self) -> &mut [StateID] {
                        wire::u32s_to_state_ids_mut( self.table.as_mut())
                    }
                }

                #[derive( Clone )]
                pub struct StartTable<T> {

                    table: T,
                    kind: StartKind,
                    start_map: StartByteMap,
                    stride: usize,
                    pattern_len:Option<usize>,
                    universal_start_unanchored:Option<StateID>,
                    universal_start_anchored:Option<StateID>,
                }
                
                impl StartTable<Vec<u32>>
                {
                    fn dead(
                        kind: StartKind,
                        lookm: &LookMatcher,
                        pattern_len:Option<usize>,
                    ) -> Result<StartTable<Vec<u32>>, BuildError> {
                        if let Some(len) = pattern_len {
                            assert!(len <= PatternID::LIMIT);
                        }
                        let stride = Start::len();
                        
                        let starts_len = stride.checked_mul(2).unwrap();
                        let pattern_starts_len =
                            match stride.checked_mul(pattern_len.unwrap_or(0)) {
                                Some(x) => x,
                                None => return Err(BuildError::too_many_start_states()),
                            };
                        let table_len = match starts_len.checked_add(pattern_starts_len) {
                            Some(x) => x,
                            None => return Err(BuildError::too_many_start_states()),
                        };
                        if let Err(_) = isize::try_from(table_len) {
                            return Err(BuildError::too_many_start_states());
                        }
                        let table = vec![DEAD.as_u32(); table_len];
                        let start_map = StartByteMap::new(lookm);
                        Ok(StartTable {
                            table,
                            kind,
                            start_map,
                            stride,
                            pattern_len,
                            universal_start_unanchored: None,
                            universal_start_anchored: None,
                        })
                    }
                }

                impl<'a> StartTable<&'a [u32]> {
                    unsafe fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(StartTable<&'a [u32]>, usize), DeserializeError>
                    {
                        let slice_start = slice.as_ptr().as_usize();

                        let (kind, nr) = StartKind::from_bytes(slice)?;
                        slice = &slice[nr..];

                        let (start_map, nr) = StartByteMap::from_bytes(slice)?;
                        slice = &slice[nr..];

                        let (stride, nr) =
                            wire::try_read_u32_as_usize(slice, "start table stride")?;
                        slice = &slice[nr..];
                        if stride != Start::len() {
                            return Err(DeserializeError::generic(
                                "invalid starting table stride",
                            ));
                        }

                        let (maybe_pattern_len, nr) =
                            wire::try_read_u32_as_usize(slice, "start table patterns")?;
                        slice = &slice[nr..];
                        let pattern_len = if maybe_pattern_len.as_u32() == u32::MAX {
                            None
                        } else {
                            Some(maybe_pattern_len)
                        };
                        if pattern_len.map_or(false, |len| len > PatternID::LIMIT) {
                            return Err(DeserializeError::generic(
                                "invalid number of patterns",
                            ));
                        }

                        let (universal_unanchored, nr) =
                            wire::try_read_u32(slice, "universal unanchored start")?;
                        slice = &slice[nr..];
                        let universal_start_unanchored = if universal_unanchored == u32::MAX {
                            None
                        } else {
                            Some(StateID::try_from(universal_unanchored).map_err(|e| {
                                DeserializeError::state_id_error(
                                    e,
                                    "universal unanchored start",
                                )
                            })?)
                        };

                        let (universal_anchored, nr) =
                            wire::try_read_u32(slice, "universal anchored start")?;
                        slice = &slice[nr..];
                        let universal_start_anchored = if universal_anchored == u32::MAX {
                            None
                        } else {
                            Some(StateID::try_from(universal_anchored).map_err(|e| {
                                DeserializeError::state_id_error(e, "universal anchored start")
                            })?)
                        };

                        let pattern_table_size = wire::mul(
                            stride,
                            pattern_len.unwrap_or(0),
                            "invalid pattern length",
                        )?;
                        let start_state_len = wire::add(
                            wire::mul(2, stride, "start state stride too big")?,
                            pattern_table_size,
                            "invalid 'any' pattern starts size",
                        )?;
                        let table_bytes_len = wire::mul(
                            start_state_len,
                            StateID::SIZE,
                            "pattern table bytes length",
                        )?;
                        wire::check_slice_len(slice, table_bytes_len, "start ID table")?;
                        wire::check_alignment::<StateID>(slice)?;
                        let table_bytes = &slice[..table_bytes_len];
                        slice = &slice[table_bytes_len..];
                        //
                        // N.B. This is the only not-safe code in this function.
                        let table = ::slice::from_raw_parts(
                            table_bytes.as_ptr().cast::<u32>(),
                            start_state_len,
                        );
                        let st = StartTable {
                            table,
                            kind,
                            start_map,
                            stride,
                            pattern_len,
                            universal_start_unanchored,
                            universal_start_anchored,
                        };
                        Ok((st, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl<T: AsRef<[u32]>> StartTable<T>
                {
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small(
                                "starting table ids",
                            ));
                        }
                        dst = &mut dst[..nwrite];
                        
                        let nw = self.kind.write_to::<E>(dst)?;
                        dst = &mut dst[nw..];
                        
                        let nw = self.start_map.write_to(dst)?;
                        dst = &mut dst[nw..];
                        E::write_u32(u32::try_from( self.stride).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(
                            u32::try_from( self.pattern_len.unwrap_or(0xFFFF_FFFF)).unwrap(),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(
                            self.universal_start_unanchored
                                .map_or(u32::MAX, |sid| sid.as_u32()),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(
                            self.universal_start_anchored.map_or(u32::MAX, |sid| sid.as_u32()),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        for &sid in self.table() {
                            let n = wire::write_state_id::<E>(sid, &mut dst);
                            dst = &mut dst[n..];
                        }
                        Ok(nwrite)
                    }
                    fn write_to_len( &self ) -> usize {
                        self.kind.write_to_len()
                        + self.start_map.write_to_len()
                        + size_of::<u32>() // stride
                        + size_of::<u32>() // # patterns
                        + size_of::<u32>() // universal unanchored start
                        + size_of::<u32>() // universal anchored start
                        + ( self.table().len() * StateID::SIZE)
                    }
                    fn validate(&self, dfa: &DFA<T>) -> Result<(), DeserializeError>
                    {
                        let tt = &dfa.tt;
                        if !self.universal_start_unanchored.map_or(true, |s| tt.is_valid(s)) {
                            return Err(DeserializeError::generic(
                                "found invalid universal unanchored starting state ID",
                            ));
                        }
                        if !self.universal_start_anchored.map_or(true, |s| tt.is_valid(s)) {
                            return Err(DeserializeError::generic(
                                "found invalid universal anchored starting state ID",
                            ));
                        }
                        for &id in self.table() {
                            if !tt.is_valid(id) {
                                return Err(DeserializeError::generic(
                                    "found invalid starting state ID",
                                ));
                            }
                        }
                        Ok( () )
                    }

                    fn as_ref( &self ) -> StartTable<&'_ [u32]> {
                        StartTable {
                            table: self.table.as_ref(),
                            kind: self.kind,
                            start_map: self.start_map.clone(),
                            stride: self.stride,
                            pattern_len: self.pattern_len,
                            universal_start_unanchored: self.universal_start_unanchored,
                            universal_start_anchored: self.universal_start_anchored,
                        }
                    }

                    fn to_owned( &self ) -> StartTable<alloc::vec::Vec<u32>> {
                        StartTable {
                            table: self.table.as_ref().to_vec(),
                            kind: self.kind,
                            start_map: self.start_map.clone(),
                            stride: self.stride,
                            pattern_len: self.pattern_len,
                            universal_start_unanchored: self.universal_start_unanchored,
                            universal_start_anchored: self.universal_start_anchored,
                        }
                    }
                    #[inline( always )] fn start(
                        &self,
                        anchored: Anchored,
                        start: Start,
                    ) -> Result<StateID, StartError>
                    {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => {
                                if !self.kind.has_unanchored() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                start_index
                            }
                            Anchored::Yes => {
                                if !self.kind.has_anchored() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                self.stride + start_index
                            }
                            Anchored::Pattern(pid) => {
                                let len = match self.pattern_len {
                                    None => { return Err(StartError::unsupported_anchored(anchored)) }
                                    Some(len) => len,
                                };
                                if pid.as_usize() >= len {
                                    return Ok(DEAD);
                                }
                                (2 * self.stride)
                                    + ( self.stride * pid.as_usize())
                                    + start_index
                            }
                        };
                        Ok( self.table()[index])
                    }
                    fn iter( &self ) -> StartStateIter<'_> { StartStateIter { st: self.as_ref(), i: 0 } }

                    fn table( &self ) -> &[StateID] { wire::u32s_to_state_ids( self.table.as_ref()) }

                    fn memory_usage( &self ) -> usize { self.table().len() * StateID::SIZE }
                }
                
                impl<T: AsMut<[u32]>> StartTable<T> {

                    fn set_start( &mut self, anchored: Anchored, start: Start, id: StateID) {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => start_index,
                            Anchored::Yes => self.stride + start_index,
                            Anchored::Pattern(pid) => {
                                let pid = pid.as_usize();
                                let len = self
                                    .pattern_len
                                    .expect("start states for each pattern enabled");
                                assert!(pid < len, "invalid pattern ID {pid:?}");
                                self.stride
                                    .checked_mul(pid)
                                    .unwrap()
                                    .checked_add( self.stride.checked_mul(2).unwrap())
                                    .unwrap()
                                    .checked_add(start_index)
                                    .unwrap()
                            }
                        };
                        self.table_mut()[index] = id;
                    }

                    fn table_mut(&mut self) -> &mut [StateID] {
                        wire::u32s_to_state_ids_mut( self.table.as_mut())
                    }
                }

                pub struct StartStateIter<'a> {
                    st: StartTable<&'a [u32]>,
                    i: usize,
                }

                impl<'a> Iterator for StartStateIter<'a> {
                    type Item = (StateID, Anchored, Start);

                    fn next(&mut self) -> Option<(StateID, Anchored, Start)>
                    {
                        let i = self.i;
                        let table = self.st.table();
                        if i >= table.len() {
                            return None;
                        }
                        self.i += 1;
                        let start_type = Start::from_usize(i % self.st.stride).unwrap();
                        let anchored = if i < self.st.stride {
                            Anchored::No
                        } else if i < (2 * self.st.stride) {
                            Anchored::Yes
                        } else {
                            let pid = (i - (2 * self.st.stride)) / self.st.stride;
                            Anchored::Pattern(PatternID::new(pid).unwrap())
                        };
                        
                        Some( (table[i], anchored, start_type))
                    }
                }

                #[derive( Clone, Debug )]
                struct MatchStates<T>
                {

                    slices: T,
                    pattern_ids: T,
                    pattern_len: usize,
                }

                impl<'a> MatchStates<&'a [u32]>
                {
                    unsafe fn from_bytes_unchecked
                    (
                        mut slice: &'a [u8],
                    ) -> Result<(MatchStates<&'a [u32]>, usize), DeserializeError>
                    {
                        let slice_start = slice.as_ptr().as_usize();
                        let (state_len, nr) = wire::try_read_u32_as_usize(slice, "match state length")?;
                        slice = &slice[nr..];
                        
                        let pair_len = wire::mul(2, state_len, "match state offset pairs")?;
                        let slices_bytes_len = wire::mul(
                            pair_len,
                            PatternID::SIZE,
                            "match state slice offset byte length",
                        )?;
                        wire::check_slice_len(slice, slices_bytes_len, "match state slices")?;
                        wire::check_alignment::<PatternID>(slice)?;
                        let slices_bytes = &slice[..slices_bytes_len];
                        slice = &slice[slices_bytes_len..];
                        
                        let slices = ::slice::from_raw_parts(
                            slices_bytes.as_ptr().cast::<u32>(),
                            pair_len,
                        );
                        
                        let (pattern_len, nr) =
                            wire::try_read_u32_as_usize(slice, "pattern length")?;
                        slice = &slice[nr..];
                        
                        let (idlen, nr) =
                            wire::try_read_u32_as_usize(slice, "pattern ID length")?;
                        slice = &slice[nr..];
                        
                        let pattern_ids_len =
                            wire::mul(idlen, PatternID::SIZE, "pattern ID byte length")?;
                        wire::check_slice_len(slice, pattern_ids_len, "match pattern IDs")?;
                        wire::check_alignment::<PatternID>(slice)?;
                        let pattern_ids_bytes = &slice[..pattern_ids_len];
                        slice = &slice[pattern_ids_len..];
                        
                        let pattern_ids = ::slice::from_raw_parts(
                            pattern_ids_bytes.as_ptr().cast::<u32>(),
                            idlen,
                        );

                        let ms = MatchStates { slices, pattern_ids, pattern_len };
                        Ok((ms, slice.as_ptr().as_usize() - slice_start))
                    }
                }
                
                impl MatchStates<Vec<u32>>
                {
                    fn empty(pattern_len: usize) -> MatchStates<Vec<u32>> {
                        assert!(pattern_len <= PatternID::LIMIT);
                        MatchStates { slices: vec![], pattern_ids: vec![], pattern_len }
                    }

                    fn new(
                        matches: &BTreeMap<StateID, Vec<PatternID>>,
                        pattern_len: usize,
                    ) -> Result<MatchStates<Vec<u32>>, BuildError>
                    {
                        let mut m = MatchStates::empty(pattern_len);
                        for (_, pids) in matches.iter() {
                            let start = PatternID::new(m.pattern_ids.len())
                                .map_err(|_| BuildError::too_many_match_pattern_ids())?;
                            m.slices.push(start.as_u32());
                            
                            m.slices.push(u32::try_from(pids.len()).unwrap());
                            for &pid in pids {
                                m.pattern_ids.push(pid.as_u32());
                            }
                        }
                        m.pattern_len = pattern_len;
                        Ok(m)
                    }

                    fn new_with_map(
                        &self,
                        matches: &BTreeMap<StateID, Vec<PatternID>>,
                    ) -> Result<MatchStates<Vec<u32>>, BuildError> { MatchStates::new(matches, self.pattern_len) }
                }

                impl<T: AsRef<[u32]>> MatchStates<T>
                {
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("match states"));
                        }
                        dst = &mut dst[..nwrite];
                        
                        E::write_u32(u32::try_from( self.len()).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        
                        for &pid in self.slices() {
                            let n = wire::write_pattern_id::<E>(pid, &mut dst);
                            dst = &mut dst[n..];
                        }
                        
                        E::write_u32(u32::try_from( self.pattern_len).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        
                        E::write_u32(u32::try_from( self.pattern_ids().len()).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        
                        for &pid in self.pattern_ids() {
                            let n = wire::write_pattern_id::<E>(pid, &mut dst);
                            dst = &mut dst[n..];
                        }

                        Ok(nwrite)
                    }

                    fn write_to_len( &self ) -> usize
                    {
                        size_of::<u32>()
                        + ( self.slices().len() * PatternID::SIZE)
                        + size_of::<u32>()
                        + size_of::<u32>()
                        + ( self.pattern_ids().len() * PatternID::SIZE)
                    }

                    fn validate(&self, dfa: &DFA<T>) -> Result<(), DeserializeError> {
                        if self.len() != dfa.special.match_len(dfa.stride()) {
                            return Err(DeserializeError::generic(
                                "match state length mismatch",
                            ));
                        }
                        for si in 0..self.len() {
                            let start = self.slices()[si * 2].as_usize();
                            let len = self.slices()[si * 2 + 1].as_usize();
                            if start >= self.pattern_ids().len() {
                                return Err(DeserializeError::generic(
                                    "invalid pattern ID start offset",
                                ));
                            }
                            if start + len > self.pattern_ids().len() {
                                return Err(DeserializeError::generic(
                                    "invalid pattern ID length",
                                ));
                            }
                            for mi in 0..len {
                                let pid = self.pattern_id(si, mi);
                                if pid.as_usize() >= self.pattern_len {
                                    return Err(DeserializeError::generic(
                                        "invalid pattern ID",
                                    ));
                                }
                            }
                        }
                        Ok( () )
                    }

                        fn to_map(&self, dfa: &DFA<T>) -> BTreeMap<StateID, Vec<PatternID>>
                    {
                        let mut map = BTreeMap::new();
                        for i in 0..self.len() {
                            let mut pids = vec![];
                            for j in 0..self.pattern_len(i) {
                                pids.push( self.pattern_id(i, j));
                            }
                            map.insert( self.match_state_id(dfa, i), pids);
                        }
                        map
                    }

                    fn as_ref( &self ) -> MatchStates<&'_ [u32]> {
                        MatchStates {
                            slices: self.slices.as_ref(),
                            pattern_ids: self.pattern_ids.as_ref(),
                            pattern_len: self.pattern_len,
                        }
                    }

                    fn to_owned( &self ) -> MatchStates<alloc::vec::Vec<u32>> {
                        MatchStates {
                            slices: self.slices.as_ref().to_vec(),
                            pattern_ids: self.pattern_ids.as_ref().to_vec(),
                            pattern_len: self.pattern_len,
                        }
                    }

                    fn match_state_id(&self, dfa: &DFA<T>, index: usize) -> StateID {
                        assert!(dfa.special.matches(), "no match states to index");
                        let stride2 = u32::try_from(dfa.stride2()).unwrap();
                        let offset = index.checked_shl(stride2).unwrap();
                        let id = dfa.special.min_match.as_usize().checked_add(offset).unwrap();
                        let sid = StateID::new(id).unwrap();
                        assert!(dfa.is_match_state(sid));
                        sid
                    }

                    #[inline( always )] fn pattern_id(&self, state_index: usize, match_index: usize) -> PatternID {
                        self.pattern_id_slice(state_index)[match_index]
                    }
                    #[inline( always )] fn pattern_len(&self, state_index: usize) -> usize {
                        self.slices()[state_index * 2 + 1].as_usize()
                    }
                    #[inline( always )] fn pattern_id_slice(&self, state_index: usize) -> &[PatternID] {
                        let start = self.slices()[state_index * 2].as_usize();
                        let len = self.pattern_len(state_index);
                        &self.pattern_ids()[start..start + len]
                    }

                    #[inline( always )] fn slices( &self ) -> &[PatternID] { wire::u32s_to_pattern_ids( self.slices.as_ref()) }

                    #[inline( always )] fn len( &self ) -> usize {
                        assert_eq!(0, self.slices().len() % 2);
                        self.slices().len() / 2
                    }

                    #[inline( always )] fn pattern_ids( &self ) -> &[PatternID] { wire::u32s_to_pattern_ids( self.pattern_ids.as_ref()) }

                    fn memory_usage( &self ) -> usize { ( self.slices().len() + self.pattern_ids().len()) * PatternID::SIZE }
                }

                #[derive( Clone, Copy, Debug )]
                pub struct Flags 
               
                {
                    pub has_empty: bool,
                    pub is_utf8: bool,
                    pub is_always_start_anchored: bool,
                }

                impl Flags 
                {

                        fn from_nfa(nfa: &thompson::NFA) -> Flags {
                        Flags {
                            has_empty: nfa.has_empty(),
                            is_utf8: nfa.is_utf8(),
                            is_always_start_anchored: nfa.is_always_start_anchored(),
                        }
                    }

                    pub fn from_bytes(
                        slice: &[u8],
                    ) -> Result<(Flags, usize), DeserializeError>
                    {
                        let (bits, nread) = wire::try_read_u32(slice, "flag bitset")?;
                        let flags = Flags {
                            has_empty: bits & (1 << 0) != 0,
                            is_utf8: bits & (1 << 1) != 0,
                            is_always_start_anchored: bits & (1 << 2) != 0,
                        };
                        Ok((flags, nread))
                    }

                    pub fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        fn bool_to_int(b:bool ) -> u32 {
                            if b {
                                1
                            } else {
                                0
                            }
                        }

                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("flag bitset"));
                        }
                        let bits = (bool_to_int( self.has_empty) << 0)
                            | (bool_to_int( self.is_utf8) << 1)
                            | (bool_to_int( self.is_always_start_anchored) << 2);
                        E::write_u32(bits, dst);
                        Ok(nwrite)
                    }

                    pub fn write_to_len( &self ) -> usize { size_of::<u32>() }
                }

                pub struct StateIter<'a, T> {
                    tt: &'a TransitionTable<T>,
                    it: iter::Enumerate<slice::Chunks<'a, StateID>>,
                }

                impl<'a, T: AsRef<[u32]>> Iterator for StateIter<'a, T> {
                    type Item = State<'a>;

                    fn next(&mut self) -> Option<State<'a>> {
                        self.it.next().map(|(index, _)| {
                            let id = self.tt.to_state_id(index);
                            self.tt.state(id)
                        })
                    }
                }

                pub struct State<'a> {
                    id: StateID,
                    stride2: usize,
                    transitions: &'a [StateID],
                }

                impl<'a> State<'a>
                {
                    pub fn transitions( &self ) -> StateTransitionIter<'_> {
                        StateTransitionIter {
                            len: self.transitions.len(),
                            it: self.transitions.iter().enumerate(),
                        }
                    }
                    
                    pub fn sparse_transitions( &self ) -> StateSparseTransitionIter<'_> { StateSparseTransitionIter { dense: self.transitions(), cur: None } }

                    pub fn id( &self ) -> StateID { self.id }

                        fn accelerate(&self, classes: &ByteClasses) -> Option<Accel>
                    {
                        let mut accel = Accel::new();
                        for (class, id) in self.transitions() {
                            if id == self.id() {
                                continue;
                            }
                            for unit in classes.elements(class) {
                                if let Some( byte ) = unit.as_u8() {
                                    if !accel.add( byte ) {
                                        return None;
                                    }
                                }
                            }
                        }
                        if accel.is_empty() {
                            None
                        } else {
                            Some(accel)
                        }
                    }
                }

                impl<'a> fmt::Debug for State<'a>
               
               
                {
                    fn fmt( &self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        for (i, (start, end, sid)) in self.sparse_transitions().enumerate() {
                            let id = if f.alternate() {
                                sid.as_usize()
                            } else {
                                sid.as_usize() >> self.stride2
                            };
                            if i > 0 {
                                write!(f, ",")?;
                            }
                            if start == end {
                                write!(f, "{start:?} => {id:?}")?;
                            } else {
                                write!(f, "{start:?}-{end:?} => {id:?}")?;
                            }
                        }
                        Ok( () )
                    }
                }

                #[derive( Debug )]
                pub struct StateTransitionIter<'a> {
                    len: usize,
                    it: iter::Enumerate<slice::Iter<'a, StateID>>,
                }

                impl<'a> Iterator for StateTransitionIter<'a> {
                    type Item = (alphabet::Unit, StateID);

                    fn next(&mut self) -> Option<(alphabet::Unit, StateID)> {
                        self.it.next().map(|(i, &id)| {
                            let unit = if i + 1 == self.len {
                                alphabet::Unit::eoi(i)
                            } else {
                                let b = u8::try_from(i)
                                    .expect("raw byte alphabet is never exceeded");
                                alphabet::Unit::u8(b)
                            };
                            (unit, id)
                        })
                    }
                }

                #[derive( Debug )]
                pub struct StateSparseTransitionIter<'a> {
                    dense: StateTransitionIter<'a>,
                    cur:Option<(alphabet::Unit, alphabet::Unit, StateID)>,
                }

                impl<'a> Iterator for StateSparseTransitionIter<'a> {
                    type Item = (alphabet::Unit, alphabet::Unit, StateID);

                    fn next(&mut self) -> Option<(alphabet::Unit, alphabet::Unit, StateID)> {
                        while let Some((unit, next)) = self.dense.next() {
                            let (prev_start, prev_end, prev_next) = match self.cur {
                                Some(t) => t,
                                None => {
                                    self.cur = Some((unit, unit, next));
                                    continue;
                                }
                            };
                            if prev_next == next && !unit.is_eoi() {
                                self.cur = Some((prev_start, unit, prev_next));
                            } else {
                                self.cur = Some((unit, unit, next));
                                if prev_next != DEAD {
                                    return Some((prev_start, prev_end, prev_next));
                                }
                            }
                        }
                        if let Some((start, end, next)) = self.cur.take() {
                            if next != DEAD {
                                return Some((start, end, next));
                            }
                        }
                        None
                    }
                }

                #[derive( Clone, Debug )]
                pub struct BuildError {
                    kind: BuildErrorKind,
                }
                
                impl BuildError 
                {

                    #[inline] pub fn is_size_limit_exceeded( &self ) -> bool 
                    {
                        use self::BuildErrorKind::*;
                        match self.kind 
                        {
                            NFA(_) | Unsupported(_) => false,
                            TooManyStates
                            | TooManyStartStates
                            | TooManyMatchPatternIDs
                            | DFAExceededSizeLimit { .. }
                            | DeterminizeExceededSizeLimit { .. } => true,
                        }
                    }
                }

                #[derive( Clone, Debug )]
                enum BuildErrorKind 
                {

                    NFA(thompson::BuildError),
                    Unsupported(&'static str),
                    TooManyStates,
                    TooManyStartStates,
                    TooManyMatchPatternIDs,
                    DFAExceededSizeLimit { limit: usize },
                    DeterminizeExceededSizeLimit { limit: usize },
                }
                
                impl BuildError 
                {

                    fn kind( &self ) -> &BuildErrorKind { &self.kind }

                    pub fn nfa(err: thompson::BuildError) -> BuildError
                    {
                        BuildError { kind: BuildErrorKind::NFA(err) }
                    }

                    pub fn unsupported_dfa_word_boundary_unicode() -> BuildError {
                        let msg = "cannot build DFAs for regexes with Unicode word \
                                boundaries; switch to ASCII word boundaries, or \
                                heuristically enable Unicode word boundaries or use a \
                                different regex engine";
                        BuildError { kind: BuildErrorKind::Unsupported(msg) }
                    }

                    pub fn too_many_states() -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyStates }
                    }

                    pub fn too_many_start_states() -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyStartStates }
                    }

                    pub fn too_many_match_pattern_ids() -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyMatchPatternIDs }
                    }

                    pub fn dfa_exceeded_size_limit(limit: usize) -> BuildError {
                        BuildError { kind: BuildErrorKind::DFAExceededSizeLimit { limit } }
                    }

                    pub fn determinize_exceeded_size_limit(limit: usize) -> BuildError {
                        BuildError {
                            kind: BuildErrorKind::DeterminizeExceededSizeLimit { limit },
                        }
                    }
                }
                
                impl ::error::Error for BuildError
                {
                    fn source( &self ) -> Option<&(dyn ::error::Error + 'static)>
                    {
                        match self.kind() {
                            BuildErrorKind::NFA(ref err) => Some(err),
                            _ => None,
                        }
                    }
                }
                
                impl ::fmt::Display for BuildError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result 
                    {
                        match self.kind() {
                            BuildErrorKind::NFA(_) => write!(f, "error building NFA"),
                            BuildErrorKind::Unsupported(ref msg) => { write!(f, "unsupported regex feature for DFAs: {msg}") }
                            BuildErrorKind::TooManyStates => write!(
                                f,
                                "number of DFA states exceeds limit of {}",
                                StateID::LIMIT,
                            ),
                            BuildErrorKind::TooManyStartStates => {
                                let stride = Start::len();
                                let max = usize::try_from(::isize::MAX).unwrap();
                                let limit = (max - stride) / stride;
                                write!(
                                    f,
                                    "compiling DFA with start states exceeds pattern \
                                    pattern limit of {}",
                                    limit,
                                )
                            }
                            BuildErrorKind::TooManyMatchPatternIDs => write!(
                                f,
                                "compiling DFA with total patterns in all match states \
                                exceeds limit of {}",
                                PatternID::LIMIT,
                            ),
                            BuildErrorKind::DFAExceededSizeLimit { limit } => write!(
                                f,
                                "DFA exceeded size limit of {limit:?} during determinization",
                            ),
                            BuildErrorKind::DeterminizeExceededSizeLimit { limit } => { write!(f, "determinization exceeded size limit of {limit:?}") }
                        }
                    }
                }
            }

            pub mod onepass
            {
                /*!
                A DFA that can return spans for matching capturing groups. */
                use ::
                {
                    *,
                };
                /*
                use alloc::{vec, vec::Vec};

                use crate::{
                    dfa::{remapper::Remapper, DEAD},
                    nfa::thompson::{self, NFA},
                    util::{
                        alphabet::ByteClasses,
                        captures::Captures,
                        escape::DebugByte,
                        int::{Usize, U32, U64, U8},
                        look::{Look, LookSet, UnicodeWordBoundaryError},
                        primitives::{NonMaxUsize, PatternID, StateID},
                        search::{Anchored, Input, Match, MatchError, MatchKind, Span},
                        sparse_set::SparseSet,
                    },
                };
                */

                #[derive( Clone, Debug, Default )]
                pub struct Config {
                    match_kind:Option<MatchKind>,
                    starts_for_each_pattern:Option<bool>,
                    byte_classes:Option<bool>,
                    size_limit:Option<Option<usize>>,
                }

                impl Config
                {
                    pub fn new() -> Config {
                        Config::default()
                    }
                    
                    pub fn match_kind( mut self, kind: MatchKind) -> Config {
                        self.match_kind = Some(kind);
                        self
                    }
                    
                    pub fn starts_for_each_pattern( mut self, yes:bool ) -> Config {
                        self.starts_for_each_pattern = Some(yes);
                        self
                    }

                    pub fn byte_classes( mut self, yes:bool ) -> Config {
                        self.byte_classes = Some(yes);
                        self
                    }
                    
                    pub fn size_limit( mut self, limit:Option<usize>) -> Config {
                        self.size_limit = Some(limit);
                        self
                    }

                    pub fn get_match_kind( &self ) -> MatchKind { self.match_kind.unwrap_or(MatchKind::LeftmostFirst) }
                    
                    pub fn get_starts_for_each_pattern( &self ) -> bool { self.starts_for_each_pattern.unwrap_or( false ) }

                    pub fn get_byte_classes( &self ) -> bool { self.byte_classes.unwrap_or(true) }
                    
                    pub fn get_size_limit( &self ) -> Option<usize> { self.size_limit.unwrap_or( None ) }
                    
                    pub fn overwrite(&self, o: Config) -> Config {
                        Config {
                            match_kind: o.match_kind.or( self.match_kind),
                            starts_for_each_pattern: o
                                .starts_for_each_pattern
                                .or( self.starts_for_each_pattern),
                            byte_classes: o.byte_classes.or( self.byte_classes),
                            size_limit: o.size_limit.or( self.size_limit),
                        }
                    }
                }

                #[derive( Clone, Debug )]
                pub struct Builder {
                    config: Config,
                    thompson: thompson::Compiler,
                }

                impl Builder
                {
                    pub fn new() -> Builder {
                        Builder {
                            config: Config::default(),
                                    thompson: thompson::Compiler::new(),
                        }
                    }
                    
                    pub fn build(&self, pattern: &str) -> Result<DFA, BuildError> { self.build_many(&[pattern]) }
                    
                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<DFA, BuildError>
                    {
                        let nfa =
                            self.thompson.build_many(patterns).map_err(BuildError::nfa)?;
                        self.build_from_nfa(nfa)
                    }

                    pub fn build_from_nfa(&self, nfa: NFA) -> Result<DFA, BuildError> {
                        InternalBuilder::new( self.config.clone(), &nfa).build()
                    }

                    pub fn configure( &mut self, config: Config) -> &mut Builder {
                        self.config = self.config.overwrite(config);
                        self
                    }
                    
                    pub fn syntax(
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.thompson.syntax(config);
                        self
                    }
                    
                    pub fn thompson( &mut self, config: thompson::Config) -> &mut Builder {
                        self.thompson.configure(config);
                        self
                    }
                }
                
                #[derive( Debug )]
                struct InternalBuilder<'a> {

                    dfa: DFA,
                    uncompiled_nfa_ids: Vec<StateID>,
                    nfa_to_dfa_id: Vec<StateID>,
                    stack: Vec<(StateID, Epsilons)>,
                    seen: SparseSet,
                    matched: bool,
                    config: Config,
                    nfa: &'a NFA,
                    classes: ByteClasses,
                }

                impl<'a> InternalBuilder<'a> {

                    fn new(config: Config, nfa: &'a NFA) -> InternalBuilder<'a>
                    {
                        let classes = if !config.get_byte_classes() {
                            ByteClasses::singletons()
                        } else {
                            nfa.byte_classes().clone()
                        };
                        let alphabet_len = classes.alphabet_len().checked_sub(1).unwrap();
                        let stride2 = classes.stride2();
                        let dfa = DFA {
                            config: config.clone(),
                            nfa: nfa.clone(),
                            table: vec![],
                            starts: vec![],
                            min_match_id: StateID::MAX,
                            classes: classes.clone(),
                            alphabet_len,
                            stride2,
                            pateps_offset: alphabet_len,
                            explicit_slot_start: nfa.pattern_len().checked_mul(2).unwrap(),
                        };
                        InternalBuilder {
                            dfa,
                            uncompiled_nfa_ids: vec![],
                            nfa_to_dfa_id: vec![DEAD; nfa.states().len()],
                            stack: vec![],
                            seen: SparseSet::new(nfa.states().len()),
                            matched: false,
                            config,
                            nfa,
                            classes,
                        }
                    }
                    fn build(mut self) -> Result<DFA, BuildError> {
                        self.nfa.look_set_any().available().map_err(BuildError::word)?;
                        for look in self.nfa.look_set_any().iter() {
                            if look.as_repr() > Look::WordUnicodeNegate.as_repr() {
                                return Err(BuildError::unsupported_look(look));
                            }
                        }
                        if self.nfa.pattern_len().as_u64() > PatternEpsilons::PATTERN_ID_LIMIT
                        {
                            return Err(BuildError::too_many_patterns(
                                PatternEpsilons::PATTERN_ID_LIMIT,
                            ));
                        }
                        if self.nfa.group_info().explicit_slot_len() > Slots::LIMIT {
                            return Err(BuildError::not_one_pass(
                                "too many explicit capturing groups (max is 16)",
                            ));
                        }
                        assert_eq!(DEAD, self.add_empty_state()?);
                        
                        let explicit_slot_start = self.nfa.pattern_len() * 2;
                        self.add_start_state(None, self.nfa.start_anchored())?;
                        if self.config.get_starts_for_each_pattern() {
                            for pid in self.nfa.patterns() {
                                self.add_start_state(
                                    Some(pid),
                                    self.nfa.start_pattern(pid).unwrap(),
                                )?;
                            }
                        }
                        while let Some(nfa_id) = self.uncompiled_nfa_ids.pop() {
                            let dfa_id = self.nfa_to_dfa_id[nfa_id];
                            self.matched = false;
                            self.seen.clear();
                            self.stack_push(nfa_id, Epsilons::empty())?;
                            while let Some((id, epsilons)) = self.stack.pop() {
                                match *self.nfa.state(id) {
                                    thompson::State::ByteRange { ref trans } => { self.compile_transition(dfa_id, trans, epsilons)?; }
                                    thompson::State::Sparse(ref sparse) => {
                                        for trans in sparse.transitions.iter() {
                                            self.compile_transition(dfa_id, trans, epsilons)?;
                                        }
                                    }
                                    thompson::State::Dense(ref dense) => {
                                        for trans in dense.iter() {
                                            self.compile_transition(dfa_id, &trans, epsilons)?;
                                        }
                                    }
                                    thompson::State::Look { look, next } => {
                                        let looks = epsilons.looks().insert(look);
                                        self.stack_push(next, epsilons.set_looks(looks))?;
                                    }
                                    thompson::State::Union { ref alternates } => {
                                        for &sid in alternates.iter().rev() {
                                            self.stack_push(sid, epsilons)?;
                                        }
                                    }
                                    thompson::State::BinaryUnion { alt1, alt2 } => {
                                        self.stack_push(alt2, epsilons)?;
                                        self.stack_push(alt1, epsilons)?;
                                    }
                                    thompson::State::Capture { next, slot, .. } => {
                                        let slot = slot.as_usize();
                                        let epsilons = if slot < explicit_slot_start {
                                            epsilons
                                        } else {
                                            let offset = slot - explicit_slot_start;
                                            epsilons.set_slots(epsilons.slots().insert(offset))
                                        };
                                        self.stack_push(next, epsilons)?;
                                    }
                                    thompson::State::Fail => { continue; }
                                    thompson::State::Match { pattern_id } => {
                                        if self.matched {
                                            return Err(BuildError::not_one_pass(
                                                "multiple epsilon transitions to match state",
                                            ));
                                        }
                                        self.matched = true;
                                        self.dfa.set_pattern_epsilons(
                                            dfa_id,
                                            PatternEpsilons::empty()
                                                .set_pattern_id(pattern_id)
                                                .set_epsilons(epsilons),
                                        );
                                    }
                                }
                            }
                        }
                        self.shuffle_states();
                        self.dfa.starts.shrink_to_fit();
                        self.dfa.table.shrink_to_fit();
                        Ok( self.dfa)
                    }
                    fn shuffle_states(&mut self) {
                        let mut remapper = Remapper::new(&self.dfa);
                        let mut next_dest = self.dfa.last_state_id();
                        for i in (0..self.dfa.state_len()).rev() {
                            let id = StateID::must(i);
                            let is_match =
                                self.dfa.pattern_epsilons(id).pattern_id().is_some();
                            if !is_match {
                                continue;
                            }
                            remapper.swap(&mut self.dfa, next_dest, id);
                            self.dfa.min_match_id = next_dest;
                            next_dest = self.dfa.prev_state_id(next_dest).expect(
                                "match states should be a proper subset of all states",
                            );
                        }
                        remapper.remap(&mut self.dfa);
                    }

                    fn compile_transition(
                        &mut self,
                        dfa_id: StateID,
                        trans: &thompson::Transition,
                        epsilons: Epsilons,
                    ) -> Result<(), BuildError>
                    {
                        let next_dfa_id = self.add_dfa_state_for_nfa_state(trans.next)?;
                        for byte in self
                            .classes
                            .representatives(trans.start..=trans.end)
                            .filter_map(|r| r.as_u8())
                        {
                            let oldtrans = self.dfa.transition(dfa_id, byte);
                            let newtrans =
                                Transition::new( self.matched, next_dfa_id, epsilons);
                            if oldtrans.state_id() == DEAD {
                                self.dfa.set_transition(dfa_id, byte, newtrans);
                            } else if oldtrans != newtrans {
                                return Err(BuildError::not_one_pass(
                                    "conflicting transition",
                                ));
                            }
                        }
                        Ok( () )
                    }
                    fn add_start_state(
                        &mut self,
                        pid:Option<PatternID>,
                        nfa_id: StateID,
                    ) -> Result<StateID, BuildError> {
                        match pid {
                            None => assert!( self.dfa.starts.is_empty()),
                            // With a pid, we want it to be at self.dfa.starts[pid+1].
                            Some(pid) => assert!( self.dfa.starts.len() == pid.one_more()),
                        }
                        let dfa_id = self.add_dfa_state_for_nfa_state(nfa_id)?;
                        self.dfa.starts.push(dfa_id);
                        Ok(dfa_id)
                    }
                    fn add_dfa_state_for_nfa_state(
                        &mut self,
                        nfa_id: StateID,
                    ) -> Result<StateID, BuildError> {
                        // likely to wind up being incomplete.
                        let existing_dfa_id = self.nfa_to_dfa_id[nfa_id];
                        if existing_dfa_id != DEAD {
                            return Ok(existing_dfa_id);
                        }
                        let dfa_id = self.add_empty_state()?;
                        self.nfa_to_dfa_id[nfa_id] = dfa_id;
                        self.uncompiled_nfa_ids.push(nfa_id);
                        Ok(dfa_id)
                    }
                    fn add_empty_state(&mut self) -> Result<StateID, BuildError>
                    {
                        let state_limit = Transition::STATE_ID_LIMIT;
                        let next_id = self.dfa.table.len() >> self.dfa.stride2();
                        let id = StateID::new(next_id)
                            .map_err(|_| BuildError::too_many_states(state_limit))?;
                        if id.as_u64() > Transition::STATE_ID_LIMIT {
                            return Err(BuildError::too_many_states(state_limit));
                        }
                        self.dfa
                            .table
                            .extend(core::iter::repeat(Transition(0)).take( self.dfa.stride()));
                        self.dfa.set_pattern_epsilons(id, PatternEpsilons::empty());
                        if let Some(size_limit) = self.config.get_size_limit() {
                            if self.dfa.memory_usage() > size_limit {
                                return Err(BuildError::exceeded_size_limit(size_limit));
                            }
                        }
                        Ok(id)
                    }
                    fn stack_push(
                        &mut self,
                        nfa_id: StateID,
                        epsilons: Epsilons,
                    ) -> Result<(), BuildError> {
                        if !self.seen.insert(nfa_id) {
                            return Err(BuildError::not_one_pass(
                                "multiple epsilon transitions to same state",
                            ));
                        }
                        self.stack.push((nfa_id, epsilons));
                        Ok( () )
                    }
                }
                
                #[derive( Clone )]
                pub struct DFA {

                    config: Config,
                    nfa: NFA,
                    table: Vec<Transition>,
                    starts: Vec<StateID>,
                    min_match_id: StateID,
                    classes: ByteClasses,
                    alphabet_len: usize,
                    stride2: usize,
                    pateps_offset: usize,
                    explicit_slot_start: usize,
                }

                impl DFA {
                    #[inline] pub fn new(pattern: &str) -> Result<DFA, BuildError> { DFA::builder().build(pattern) }
                    
                    #[inline] pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<DFA, BuildError> { DFA::builder().build_many(patterns) }
                    ///
                    ///
                    ///
                    pub fn new_from_nfa(nfa: NFA) -> Result<DFA, BuildError> { DFA::builder().build_from_nfa(nfa) }
                    ///
                    pub fn always_match() -> Result<DFA, BuildError>
                    {
                        let nfa = thompson::NFA::always_match();
                        Builder::new().build_from_nfa(nfa)
                    }
                    ///
                    pub fn never_match() -> Result<DFA, BuildError>
                    {
                        let nfa = thompson::NFA::never_match();
                        Builder::new().build_from_nfa(nfa)
                    }
                    
                    #[inline] pub fn config() -> Config {
                        Config::new()
                    }
                    
                    #[inline] pub fn builder() -> Builder {
                        Builder::new()
                    }
                    
                    #[inline] pub fn create_captures( &self ) -> Captures { Captures::all( self.nfa.group_info().clone()) }
                    
                    #[inline] pub fn create_cache( &self ) -> Cache { Cache::new(self) }
                    
                    #[inline] pub fn reset_cache(&self, cache: &mut Cache) {
                        cache.reset(self);
                    }
                    #[inline] pub fn get_config( &self ) -> &Config { &self.config }
                    #[inline] pub fn get_nfa( &self ) -> &NFA { &self.nfa }
                    #[inline] pub fn pattern_len( &self ) -> usize { self.get_nfa().pattern_len() }
                    #[inline] pub fn state_len( &self ) -> usize { self.table.len() >> self.stride2() }
                    #[inline] pub fn alphabet_len( &self ) -> usize { self.alphabet_len }
                    
                    #[inline] pub fn stride2( &self ) -> usize { self.stride2 }
                    
                    #[inline] pub fn stride( &self ) -> usize { 1 << self.stride2() }
                    #[inline] pub fn memory_usage( &self ) -> usize {
                        use ::mem::size_of;

                        self.table.len() * size_of::<Transition>()
                            + self.starts.len() * size_of::<StateID>()
                    }
                }

                impl DFA {
                    #[inline] pub fn is_match<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                    ) -> bool {
                        let mut input = input.into().earliest(true);
                        if matches!(input.get_anchored(), Anchored::No) {
                            input.set_anchored(Anchored::Yes);
                        }
                        self.try_search_slots(cache, &input, &mut []).unwrap().is_some()
                    }
                    
                    #[inline] pub fn find<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                    ) -> Option<Match>
                    {
                        let mut input = input.into();
                        if matches!(input.get_anchored(), Anchored::No) {
                            input.set_anchored(Anchored::Yes);
                        }
                        if self.get_nfa().pattern_len() == 1 {
                            let mut slots = [None, None];
                            let pid =
                                self.try_search_slots(cache, &input, &mut slots).unwrap()?;
                            let start = slots[0].unwrap().get();
                            let end = slots[1].unwrap().get();
                            return Some(Match::new(pid, Span { start, end }));
                        }
                        let ginfo = self.get_nfa().group_info();
                        let slots_len = ginfo.implicit_slot_len();
                        let mut slots = vec![None; slots_len];
                        let pid = self.try_search_slots(cache, &input, &mut slots).unwrap()?;
                        let start = slots[pid.as_usize() * 2].unwrap().get();
                        let end = slots[pid.as_usize() * 2 + 1].unwrap().get();
                        Some(Match::new(pid, Span { start, end }))
                    }
                    
                    #[inline] pub fn captures<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                        caps: &mut Captures,
                    ) {
                        let mut input = input.into();
                        if matches!(input.get_anchored(), Anchored::No) {
                            input.set_anchored(Anchored::Yes);
                        }
                        self.try_search(cache, &input, caps).unwrap();
                    }
                    
                    #[inline] pub fn try_search(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        caps: &mut Captures,
                    ) -> Result<(), MatchError>
                    {
                        let pid = self.try_search_slots(cache, input, caps.slots_mut())?;
                        caps.set_pattern(pid);
                        Ok( () )
                    }
                    
                    #[inline] pub fn try_search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Result<Option<PatternID>, MatchError>
                    {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        if !utf8empty {
                            return self.try_search_slots_imp(cache, input, slots);
                        }
                        // See PikeVM::try_search_slots for why we do this.
                        let min = self.get_nfa().group_info().implicit_slot_len();
                        if slots.len() >= min {
                            return self.try_search_slots_imp(cache, input, slots);
                        }
                        if self.get_nfa().pattern_len() == 1 {
                            let mut enough = [None, None];
                            let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                            slots.copy_from_slice(&enough[..slots.len()]);
                            return Ok(got);
                        }
                        let mut enough = vec![None; min];
                        let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                        slots.copy_from_slice(&enough[..slots.len()]);
                        Ok(got)
                    }

                    #[inline( never )] fn try_search_slots_imp(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Result<Option<PatternID>, MatchError>
                    {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        match self.search_imp(cache, input, slots)? {
                            None => return Ok( None ),
                            Some(pid) if !utf8empty => return Ok(Some(pid)),
                            Some(pid) => {
                                // are valid.
                                let slot_start = pid.as_usize().wrapping_mul(2);
                                let slot_end = slot_start.wrapping_add(1);
                                let start = slots[slot_start].unwrap().get();
                                let end = slots[slot_end].unwrap().get();
                                if start == end && !input.is_char_boundary(start) {
                                    return Ok( None );
                                }
                                Ok(Some(pid))
                            }
                        }
                    }
                }

                impl DFA
                {
                    fn search_imp(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Result<Option<PatternID>, MatchError> {
                        //
                        //
                        //
                        // input yields a match too. Maybe we adopt that?
                        //
                        // This just might be a tricky DFA to optimize.

                        if input.is_done() {
                            return Ok( None );
                        }
                        let explicit_slots_len = ::cmp::min(
                            Slots::LIMIT,
                            slots.len().saturating_sub( self.explicit_slot_start),
                        );
                        cache.setup_search(explicit_slots_len);
                        for slot in cache.explicit_slots() {
                            *slot = None;
                        }
                        for slot in slots.iter_mut() {
                            *slot = None;
                        }
                        for pid in self.nfa.patterns() {
                            let i = pid.as_usize() * 2;
                            if i >= slots.len() {
                                break;
                            }
                            slots[i] = NonMaxUsize::new(input.start());
                        }
                        let mut pid = None;
                        let mut next_sid = match input.get_anchored() {
                            Anchored::Yes => self.start(),
                            Anchored::Pattern(pid) => self.start_pattern(pid)?,
                            Anchored::No => {
                                if !self.nfa.is_always_start_anchored() {
                                    return Err(MatchError::unsupported_anchored(
                                        Anchored::No,
                                    ));
                                }
                                self.start()
                            }
                        };
                        let leftmost_first =
                            matches!( self.config.get_match_kind(), MatchKind::LeftmostFirst);
                        for at in input.start()..input.end() {
                            let sid = next_sid;
                            let trans = self.transition(sid, input.haystack()[at]);
                            next_sid = trans.state_id();
                            let epsilons = trans.epsilons();
                            if sid >= self.min_match_id {
                                if self.find_match(cache, input, at, sid, slots, &mut pid) {
                                    if input.get_earliest()
                                        || (leftmost_first && trans.match_wins())
                                    {
                                        return Ok(pid);
                                    }
                                }
                            }
                            if sid == DEAD
                                || (!epsilons.looks().is_empty()
                                    && !self.nfa.look_matcher().matches_set_inline(
                                        epsilons.looks(),
                                        input.haystack(),
                                        at,
                                    ))
                            {
                                return Ok(pid);
                            }
                            epsilons.slots().apply(at, cache.explicit_slots());
                        }
                        if next_sid >= self.min_match_id {
                            self.find_match(
                                cache,
                                input,
                                input.end(),
                                next_sid,
                                slots,
                                &mut pid,
                            );
                        }
                        Ok(pid)
                    }
                    #[inline( always )] fn find_match(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        at: usize,
                        sid: StateID,
                        slots: &mut [Option<NonMaxUsize>],
                        matched_pid: &mut Option<PatternID>,
                    ) -> bool {
                        debug_assert!(sid >= self.min_match_id);
                        let pateps = self.pattern_epsilons(sid);
                        let epsilons = pateps.epsilons();
                        if !epsilons.looks().is_empty()
                            && !self.nfa.look_matcher().matches_set_inline(
                                epsilons.looks(),
                                input.haystack(),
                                at,
                            )
                        {
                            return false;
                        }
                        let pid = pateps.pattern_id_unchecked();
                        let slot_end = pid.as_usize().wrapping_mul(2).wrapping_add(1);
                        if slot_end < slots.len() {
                            slots[slot_end] = NonMaxUsize::new(at);
                        }
                        if self.explicit_slot_start < slots.len() {
                            // slice of length equivalent to 'slots[explicit_slot_start..]'.
                            slots[self.explicit_slot_start..]
                                .copy_from_slice(cache.explicit_slots());
                            epsilons.slots().apply(at, &mut slots[self.explicit_slot_start..]);
                        }
                        *matched_pid = Some(pid);
                        true
                    }
                }

                impl DFA {

                    fn start( &self ) -> StateID { self.starts[0] }
                    fn start_pattern(&self, pid: PatternID) -> Result<StateID, MatchError> {
                        if !self.config.get_starts_for_each_pattern() {
                            return Err(MatchError::unsupported_anchored(Anchored::Pattern(
                                pid,
                            )));
                        }
                        Ok( self.starts.get(pid.one_more()).copied().unwrap_or(DEAD))
                    }
                    fn transition(&self, sid: StateID, byte: u8) -> Transition {
                        let offset = sid.as_usize() << self.stride2();
                        let class = self.classes.get( byte ).as_usize();
                        self.table[offset + class]
                    }
                    fn set_transition( &mut self, sid: StateID, byte: u8, to: Transition) {
                        let offset = sid.as_usize() << self.stride2();
                        let class = self.classes.get( byte ).as_usize();
                        self.table[offset + class] = to;
                    }

                    fn sparse_transitions(&self, sid: StateID) -> SparseTransitionIter<'_>
                    {
                        let start = sid.as_usize() << self.stride2();
                        let end = start + self.alphabet_len();
                        SparseTransitionIter {
                            it: self.table[start..end].iter().enumerate(),
                            cur: None,
                        }
                    }
                    fn pattern_epsilons(&self, sid: StateID) -> PatternEpsilons {
                        let offset = sid.as_usize() << self.stride2();
                        PatternEpsilons( self.table[offset + self.pateps_offset].0)
                    }

                    fn set_pattern_epsilons( &mut self, sid: StateID, pateps: PatternEpsilons) {
                        let offset = sid.as_usize() << self.stride2();
                        self.table[offset + self.pateps_offset] = Transition(pateps.0);
                    }
                    fn prev_state_id(&self, id: StateID) -> Option<StateID> {
                        if id == DEAD {
                            None
                        } else {
                            Some(StateID::new_unchecked(id.as_usize().checked_sub(1).unwrap()))
                        }
                    }

                    fn last_state_id( &self ) -> StateID {
                        StateID::new_unchecked(
                            ( self.table.len() >> self.stride2()).checked_sub(1).unwrap(),
                        )
                    }

                    pub(super) fn swap_states( &mut self, id1: StateID, id2: StateID) {
                        let o1 = id1.as_usize() << self.stride2();
                        let o2 = id2.as_usize() << self.stride2();
                        for b in 0..self.stride() {
                            self.table.swap(o1 + b, o2 + b);
                        }
                    }
                    pub(super) fn remap( &mut self, map: impl Fn(StateID) -> StateID) {
                        for i in 0..self.state_len() {
                            let offset = i << self.stride2();
                            for b in 0..self.alphabet_len() {
                                let next = self.table[offset + b].state_id();
                                self.table[offset + b].set_state_id(map(next));
                            }
                        }
                        for i in 0..self.starts.len() {
                            self.starts[i] = map( self.starts[i]);
                        }
                    }
                }

                impl ::fmt::Debug for DFA
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        fn debug_state_transitions(
                            f: &mut ::fmt::Formatter,
                            dfa: &DFA,
                            sid: StateID,
                        ) -> ::fmt::Result {
                            for (i, (start, end, trans)) in
                                dfa.sparse_transitions(sid).enumerate()
                            {
                                let next = trans.state_id();
                                if i > 0 {
                                    write!(f, ",")?;
                                }
                                if start == end {
                                    write!(
                                        f,
                                        "{:?} => {:?}",
                                        DebugByte(start),
                                        next.as_usize(),
                                    )?;
                                } else {
                                    write!(
                                        f,
                                        "{:?}-{:?} => {:?}",
                                        DebugByte(start),
                                        DebugByte(end),
                                        next.as_usize(),
                                    )?;
                                }
                                if trans.match_wins() {
                                    write!(f, " (MW)")?;
                                }
                                if !trans.epsilons().is_empty() {
                                    write!(f, " ({:?})", trans.epsilons())?;
                                }
                            }
                            Ok( () )
                        }

                        writeln!(f, "onepass::DFA(")?;
                        for index in 0..self.state_len() {
                            let sid = StateID::must(index);
                            let pateps = self.pattern_epsilons(sid);
                            if sid == DEAD {
                                write!(f, "D ")?;
                            } else if pateps.pattern_id().is_some() {
                                write!(f, "* ")?;
                            } else {
                                write!(f, "  ")?;
                            }
                            write!(f, "{:06?}", sid.as_usize())?;
                            if !pateps.is_empty() {
                                write!(f, " ({pateps:?})")?;
                            }
                            write!(f, ": ")?;
                            debug_state_transitions(f, self, sid)?;
                            write!(f, "\n")?;
                        }
                        writeln!(f, "")?;
                        for (i, &sid) in self.starts.iter().enumerate() {
                            if i == 0 {
                                writeln!(f, "START(ALL): {:?}", sid.as_usize())?;
                            } else {
                                writeln!(
                                    f,
                                    "START(pattern: {:?}): {:?}",
                                    i - 1,
                                    sid.as_usize(),
                                )?;
                            }
                        }
                        writeln!(f, "state length: {:?}", self.state_len())?;
                        writeln!(f, "pattern length: {:?}", self.pattern_len())?;
                        writeln!(f, ")")?;
                        Ok( () )
                    }
                }

                #[derive( Debug )]
                struct SparseTransitionIter<'a> {
                    it: ::iter::Enumerate<core::slice::Iter<'a, Transition>>,
                    cur:Option<(u8, u8, Transition)>,
                }

                impl<'a> Iterator for SparseTransitionIter<'a> {
                    type Item = (u8, u8, Transition);

                    fn next(&mut self) -> Option<(u8, u8, Transition)> {
                        while let Some((b, &trans)) = self.it.next() {
                            let b = b.as_u8();
                            let (prev_start, prev_end, prev_trans) = match self.cur {
                                Some(t) => t,
                                None => {
                                    self.cur = Some((b, b, trans));
                                    continue;
                                }
                            };
                            if prev_trans == trans {
                                self.cur = Some((prev_start, b, prev_trans));
                            } else {
                                self.cur = Some((b, b, trans));
                                if prev_trans.state_id() != DEAD {
                                    return Some((prev_start, prev_end, prev_trans));
                                }
                            }
                        }
                        if let Some((start, end, trans)) = self.cur.take() {
                            if trans.state_id() != DEAD {
                                return Some((start, end, trans));
                            }
                        }
                        None
                    }
                }
                
                #[derive( Clone, Debug )]
                pub struct Cache {

                    explicit_slots: Vec<Option<NonMaxUsize>>,
                    explicit_slot_len: usize,
                }

                impl Cache
                {
                    pub fn new(re: &DFA) -> Cache {
                        let mut cache = Cache { explicit_slots: vec![], explicit_slot_len: 0 };
                        cache.reset(re);
                        cache
                    }
                    
                    pub fn reset( &mut self, re: &DFA) {
                        let explicit_slot_len = re.get_nfa().group_info().explicit_slot_len();
                        self.explicit_slots.resize(explicit_slot_len, None);
                        self.explicit_slot_len = explicit_slot_len;
                    }
                    
                    pub fn memory_usage( &self ) -> usize { self.explicit_slots.len() * ::mem::size_of::<Option<NonMaxUsize>>() }

                    fn explicit_slots(&mut self) -> &mut [Option<NonMaxUsize>] {
                        &mut self.explicit_slots[..self.explicit_slot_len]
                    }

                    fn setup_search( &mut self, explicit_slot_len: usize) {
                        self.explicit_slot_len = explicit_slot_len;
                    }
                }

                #[derive(Clone, Copy, Eq, PartialEq)]
                struct Transition(u64);

                impl Transition {
                    const STATE_ID_BITS: u64 = 21;
                    const STATE_ID_SHIFT: u64 = 64 - Transition::STATE_ID_BITS;
                    const STATE_ID_LIMIT: u64 = 1 << Transition::STATE_ID_BITS;
                    const MATCH_WINS_SHIFT: u64 = 64 - (Transition::STATE_ID_BITS + 1);
                    const INFO_MASK: u64 = 0x000003FF_FFFFFFFF;

                    fn new(match_wins: bool, sid: StateID, epsilons: Epsilons) -> Transition {
                        let match_wins =
                            if match_wins { 1 << Transition::MATCH_WINS_SHIFT } else { 0 };
                        let sid = sid.as_u64() << Transition::STATE_ID_SHIFT;
                        Transition(sid | match_wins | epsilons.0)
                    }

                    fn is_dead(self) -> bool {
                        self.state_id() == DEAD
                    }
                    fn match_wins( &self ) -> bool { ( self.0 >> Transition::MATCH_WINS_SHIFT & 1) == 1 }

                    fn state_id( &self ) -> StateID {
                        StateID::new_unchecked(
                            ( self.0 >> Transition::STATE_ID_SHIFT).as_usize(),
                        )
                    }

                    fn set_state_id( &mut self, sid: StateID) {
                        *self = Transition::new( self.match_wins(), sid, self.epsilons());
                    }

                    fn epsilons( &self ) -> Epsilons { Epsilons( self.0 & Transition::INFO_MASK) }
                }

                impl ::fmt::Debug for Transition
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        if self.is_dead() {
                            return write!(f, "0");
                        }
                        write!(f, "{}", self.state_id().as_usize())?;
                        if self.match_wins() {
                            write!(f, "-MW")?;
                        }
                        if !self.epsilons().is_empty() {
                            write!(f, "-{:?}", self.epsilons())?;
                        }
                        Ok( () )
                    }
                }
                
                #[derive(Clone, Copy)]
                struct PatternEpsilons(u64);

                impl PatternEpsilons {
                    const PATTERN_ID_BITS: u64 = 22;
                    const PATTERN_ID_SHIFT: u64 = 64 - PatternEpsilons::PATTERN_ID_BITS;
                    const PATTERN_ID_NONE: u64 = 0x00000000_003FFFFF;
                    const PATTERN_ID_LIMIT: u64 = PatternEpsilons::PATTERN_ID_NONE;
                    const PATTERN_ID_MASK: u64 = 0xFFFFFC00_00000000;
                    const EPSILONS_MASK: u64 = 0x000003FF_FFFFFFFF;
                    fn empty() -> PatternEpsilons {
                        PatternEpsilons(
                            PatternEpsilons::PATTERN_ID_NONE
                                << PatternEpsilons::PATTERN_ID_SHIFT,
                        )
                    }
                    fn is_empty(self) -> bool {
                        self.pattern_id().is_none() && self.epsilons().is_empty()
                    }

                    fn pattern_id(self) -> Option<PatternID>
                    {
                        let pid = self.0 >> PatternEpsilons::PATTERN_ID_SHIFT;
                        if pid == PatternEpsilons::PATTERN_ID_LIMIT {
                            None
                        } else {
                            Some(PatternID::new_unchecked(pid.as_usize()))
                        }
                    }
                    fn pattern_id_unchecked(self) -> PatternID {
                        let pid = self.0 >> PatternEpsilons::PATTERN_ID_SHIFT;
                        PatternID::new_unchecked(pid.as_usize())
                    }
                    fn set_pattern_id(self, pid: PatternID) -> PatternEpsilons {
                        PatternEpsilons(
                            (pid.as_u64() << PatternEpsilons::PATTERN_ID_SHIFT)
                                | ( self.0 & PatternEpsilons::EPSILONS_MASK),
                        )
                    }

                    fn epsilons(self) -> Epsilons {
                        Epsilons( self.0 & PatternEpsilons::EPSILONS_MASK)
                    }
                    fn set_epsilons(self, epsilons: Epsilons) -> PatternEpsilons {
                        PatternEpsilons(
                            ( self.0 & PatternEpsilons::PATTERN_ID_MASK)
                                | (u64::from(epsilons.0) & PatternEpsilons::EPSILONS_MASK),
                        )
                    }
                }

                impl ::fmt::Debug for PatternEpsilons
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        if self.is_empty() {
                            return write!(f, "N/A");
                        }
                        if let Some(pid) = self.pattern_id() {
                            write!(f, "{}", pid.as_usize())?;
                        }
                        if !self.epsilons().is_empty() {
                            if self.pattern_id().is_some() {
                                write!(f, "/")?;
                            }
                            write!(f, "{:?}", self.epsilons())?;
                        }
                        Ok( () )
                    }
                }
                
                #[derive(Clone, Copy)]
                struct Epsilons(u64);

                impl Epsilons {
                    const SLOT_MASK: u64 = 0x000003FF_FFFFFC00;
                    const SLOT_SHIFT: u64 = 10;
                    const LOOK_MASK: u64 = 0x00000000_000003FF;
                    fn empty() -> Epsilons {
                        Epsilons(0)
                    }

                    fn is_empty(self) -> bool {
                        self.0 == 0
                    }

                    fn slots(self) -> Slots {
                        Slots(( self.0 >> Epsilons::SLOT_SHIFT).low_u32())
                    }

                    fn set_slots(self, slots: Slots) -> Epsilons {
                        Epsilons(
                            (u64::from(slots.0) << Epsilons::SLOT_SHIFT)
                                | ( self.0 & Epsilons::LOOK_MASK),
                        )
                    }

                    fn looks(self) -> LookSet {
                        LookSet { bits: ( self.0 & Epsilons::LOOK_MASK).low_u32() }
                    }

                    fn set_looks(self, look_set: LookSet) -> Epsilons {
                        Epsilons(
                            ( self.0 & Epsilons::SLOT_MASK)
                                | (u64::from(look_set.bits) & Epsilons::LOOK_MASK),
                        )
                    }
                }

                impl ::fmt::Debug for Epsilons
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let mut wrote = false;
                        if !self.slots().is_empty() {
                            write!(f, "{:?}", self.slots())?;
                            wrote = true;
                        }
                        if !self.looks().is_empty() {
                            if wrote {
                                write!(f, "/")?;
                            }
                            write!(f, "{:?}", self.looks())?;
                            wrote = true;
                        }
                        if !wrote {
                            write!(f, "N/A")?;
                        }
                        Ok( () )
                    }
                }
                
                #[derive(Clone, Copy)]
                struct Slots(u32);

                impl Slots {
                    const LIMIT: usize = 32;

                    fn insert(self, slot: usize) -> Slots {
                        debug_assert!(slot < Slots::LIMIT);
                        Slots( self.0 | (1 << slot.as_u32()))
                    }

                    fn remove(self, slot: usize) -> Slots {
                        debug_assert!(slot < Slots::LIMIT);
                        Slots( self.0 & !(1 << slot.as_u32()))
                    }

                    fn is_empty(self) -> bool {
                        self.0 == 0
                    }

                    fn iter(self) -> SlotsIter {
                        SlotsIter { slots: self }
                    }
                    fn apply(
                        self,
                        at: usize,
                        caller_explicit_slots: &mut [Option<NonMaxUsize>],
                    ) {
                        if self.is_empty() { return; }
                        let at = NonMaxUsize::new(at);
                        for slot in self.iter() {
                            if slot >= caller_explicit_slots.len() {
                                break;
                            }
                            caller_explicit_slots[slot] = at;
                        }
                    }
                }

                impl ::fmt::Debug for Slots
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result
                    {
                        write!(f, "S")?;
                        for slot in self.iter() {
                            write!(f, "-{slot:?}")?;
                        }
                        Ok( () )
                    }
                }

                #[derive( Debug )]
                struct SlotsIter {
                    slots: Slots,
                }

                impl Iterator for SlotsIter {
                    type Item = usize;

                    fn next(&mut self) -> Option<usize> {
                        // Number of zeroes here is always <= u8::MAX, and so fits in a usize.
                        let slot = self.slots.0.trailing_zeros().as_usize();
                        if slot >= Slots::LIMIT {
                            return None;
                        }
                        self.slots = self.slots.remove(slot);
                        Some(slot)
                    }
                }

                #[derive( Clone, Debug )]
                pub struct BuildError {
                    kind: BuildErrorKind,
                }

                #[derive( Clone, Debug )]
                enum BuildErrorKind {
                    NFA(crate::nfa::thompson::BuildError),
                    Word(UnicodeWordBoundaryError),
                    TooManyStates { limit: u64 },
                    TooManyPatterns { limit: u64 },
                    UnsupportedLook { look: Look },
                    ExceededSizeLimit { limit: usize },
                    NotOnePass { msg:&'static str },
                }

                impl BuildError
                {
                    fn nfa(err: crate::nfa::thompson::BuildError) -> BuildError {
                        BuildError { kind: BuildErrorKind::NFA(err) }
                    }

                    fn word(err: UnicodeWordBoundaryError) -> BuildError {
                        BuildError { kind: BuildErrorKind::Word(err) }
                    }

                    fn too_many_states(limit: u64) -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyStates { limit } }
                    }

                    fn too_many_patterns(limit: u64) -> BuildError {
                        BuildError { kind: BuildErrorKind::TooManyPatterns { limit } }
                    }

                    fn unsupported_look(look: Look) -> BuildError {
                        BuildError { kind: BuildErrorKind::UnsupportedLook { look } }
                    }

                    fn exceeded_size_limit(limit: usize) -> BuildError {
                        BuildError { kind: BuildErrorKind::ExceededSizeLimit { limit } }
                    }

                    fn not_one_pass(msg:&'static str) -> BuildError {
                        BuildError { kind: BuildErrorKind::NotOnePass { msg } }
                    }
                }

                        impl ::error::Error for BuildError
                {
                    fn source( &self ) -> Option<&(dyn std::error::Error + 'static)> {
                        use self::BuildErrorKind::*;

                        match self.kind {
                            NFA(ref err) => Some(err),
                            Word(ref err) => Some(err),
                            _ => None,
                        }
                    }
                }

                impl ::fmt::Display for BuildError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        use self::BuildErrorKind::*;

                        match self.kind {
                            NFA(_) => write!(f, "error building NFA"),
                            Word(_) => write!(f, "NFA contains Unicode word boundary"),
                            TooManyStates { limit } => write!(
                                f,
                                "one-pass DFA exceeded a limit of {limit:?} \
                                for number of states",
                            ),
                            TooManyPatterns { limit } => write!(
                                f,
                                "one-pass DFA exceeded a limit of {limit:?} \
                                for number of patterns",
                            ),
                            UnsupportedLook { look } => write!(
                                f,
                                "one-pass DFA does not support the {look:?} assertion",
                            ),
                            ExceededSizeLimit { limit } => write!(
                                f,
                                "one-pass DFA exceeded size limit of {limit:?} during building",
                            ),
                            NotOnePass { msg } => write!(
                                f,
                                "one-pass DFA could not be built because \
                                pattern is not one-pass: {}",
                                msg,
                            ),
                        }
                    }
                }
            }

            pub mod regex
            {
                /*!
                A DFA-backed `Regex`. */
                use ::
                {
                    *,
                };
                /*
                use alloc::vec::Vec;

                use crate::dfa::dense::BuildError;
                use crate::{
                    dfa::{automaton::Automaton, dense},
                    util::{iter, search::Input},
                    Anchored, Match, MatchError,
                };
                use crate::{
                    dfa::{sparse, StartKind},
                    util::search::MatchKind,
                };
                */
                //
                // repeat them for each definition.
                macro_rules! define_regex_type {
                    ($(#[$doc:meta])*) => {
                            $(#[$doc])*
                        pub struct Regex<A = dense::OwnedDFA> {
                            forward: A,
                            reverse: A,
                        }
                    };
                }

                define_regex_type!(
                    #[derive( Clone, Debug )]
                );
                
                impl Regex
                {
                    pub fn new(pattern: &str) -> Result<Regex, BuildError> { Builder::new().build(pattern) }
                    
                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> { Builder::new().build_many(patterns) }
                }
                
                impl Regex<sparse::DFA<Vec<u8>>>
                {
                    pub fn new_sparse(
                        pattern: &str,
                    ) -> Result<Regex<sparse::DFA<Vec<u8>>>, BuildError> { Builder::new().build_sparse(pattern) }
                    
                    pub fn new_many_sparse<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<Regex<sparse::DFA<Vec<u8>>>, BuildError> { Builder::new().build_many_sparse(patterns) }
                }

                impl Regex<dense::DFA<&'static [u32]>>
                {
                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                }

                impl<A: Automaton> Regex<A> {
                    #[inline] pub fn is_match<'h, I: Into<Input<'h>>>(&self, input: I) -> bool {
                        let input = input.into().earliest(true);
                        self.forward().try_search_fwd(&input).map(|x| x.is_some()).unwrap()
                    }
                    
                    #[inline] pub fn find<'h, I: Into<Input<'h>>>(&self, input: I) -> Option<Match> { self.try_search(&input.into()).unwrap() }
                    
                    #[inline] pub fn find_iter<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                    ) -> FindMatches<'r, 'h, A>
                    {
                        let it = iter::Searcher::new(input.into());
                        FindMatches { re: self, it }
                    }
                }
                impl<A: Automaton> Regex<A> {
                    #[inline] pub fn try_search(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, MatchError>
                    {
                        let (fwd, rev) = ( self.forward(), self.reverse());
                        let end = match fwd.try_search_fwd(input)? {
                            None => return Ok( None ),
                            Some(end) => end,
                        };
                        if input.start() == end.offset() {
                            return Ok(Some(Match::new(
                                end.pattern(),
                                end.offset()..end.offset(),
                            )));
                        }

                        if self.is_anchored(input) {
                            return Ok(Some(Match::new(
                                end.pattern(),
                                input.start()..end.offset(),
                            )));
                        }
                        //
                        let revsearch = input
                            .clone()
                            .span(input.start()..end.offset())
                            .anchored(Anchored::Yes)
                            .earliest( false );
                        let start = rev
                            .try_search_rev(&revsearch)?
                            .expect("reverse search must match if forward search does");
                        assert_eq!(
                            start.pattern(),
                            end.pattern(),
                            "forward and reverse search must match same pattern",
                        );
                        assert!(start.offset() <= end.offset());
                        Ok(Some(Match::new(end.pattern(), start.offset()..end.offset())))
                    }
                    fn is_anchored(&self, input: &Input<'_>) -> bool {
                        match input.get_anchored() {
                            Anchored::No => self.forward().is_always_start_anchored(),
                            Anchored::Yes | Anchored::Pattern(_) => true,
                        }
                    }
                }
                impl<A: Automaton> Regex<A>
                {
                    pub fn forward( &self ) -> &A { &self.forward }

                    pub fn reverse( &self ) -> &A { &self.reverse }

                    pub fn pattern_len( &self ) -> usize {
                        assert_eq!( self.forward().pattern_len(), self.reverse().pattern_len());
                        self.forward().pattern_len()
                    }
                }

                #[derive( Debug )]
                pub struct FindMatches<'r, 'h, A> {
                    re: &'r Regex<A>,
                    it: iter::Searcher<'h>,
                }

                impl<'r, 'h, A: Automaton> Iterator for FindMatches<'r, 'h, A> {
                    type Item = Match;

                    #[inline] fn next(&mut self) -> Option<Match>
                    {
                        let FindMatches { re, ref mut it } = *self;
                        it.advance(|input| re.try_search(input))
                    }
                }

                #[derive( Clone, Debug )]
                pub struct Builder {
                        dfa: dense::Builder,
                }

                impl Builder
                {
                    pub fn new() -> Builder {
                        Builder {
                                        dfa: dense::Builder::new(),
                        }
                    }
                    pub fn build(&self, pattern: &str) -> Result<Regex, BuildError> { self.build_many(&[pattern]) }
                    
                    pub fn build_sparse(
                        &self,
                        pattern: &str,
                    ) -> Result<Regex<sparse::DFA<Vec<u8>>>, BuildError> { self.build_many_sparse(&[pattern]) }

                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<Regex, BuildError>
                    {
                        let forward = self.dfa.build_many(patterns)?;
                        let reverse = self
                            .dfa
                            .clone()
                            .configure(
                                dense::Config::new()
                                    .prefilter( None )
                                    .specialize_start_states( false )
                                    .start_kind(StartKind::Anchored)
                                    .match_kind(MatchKind::All),
                            )
                            .thompson(crate::nfa::thompson::Config::new().reverse(true))
                            .build_many(patterns)?;
                        Ok( self.build_from_dfas(forward, reverse))
                    }
                    
                    pub fn build_many_sparse<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<Regex<sparse::DFA<Vec<u8>>>, BuildError>
                    {
                        let re = self.build_many(patterns)?;
                        let forward = re.forward().to_sparse()?;
                        let reverse = re.reverse().to_sparse()?;
                        Ok( self.build_from_dfas(forward, reverse))
                    }

                    pub fn build_from_dfas<A: Automaton>(
                        &self,
                        forward: A,
                        reverse: A,
                    ) -> Regex<A> { Regex { forward, reverse } }
                    
                    pub fn syntax(
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.dfa.syntax(config);
                        self
                    }
                    
                    pub fn thompson(
                        &mut self,
                        config: crate::nfa::thompson::Config,
                    ) -> &mut Builder {
                        self.dfa.thompson(config);
                        self
                    }
                        pub fn dense( &mut self, config: dense::Config) -> &mut Builder {
                        self.dfa.configure(config);
                        self
                    }
                }

                impl Default for Builder
                {
                    fn default() -> Builder {
                        Builder::new()
                    }
                }
            }

            pub mod sparse
            {
                /*!
                Types and routines specific to sparse DFAs. */
                use ::
                {
                    *,
                };
                /*
                use ::iter;
                use ::{fmt, mem::size_of};

                use alloc::{vec, vec::Vec};

                use crate::dfa::dense::{self, BuildError};
                use crate::{
                    dfa::{
                        automaton::{fmt_state_indicator, Automaton, StartError},
                        dense::Flags,
                        special::Special,
                        StartKind, DEAD,
                    },
                    util::{
                        alphabet::{ByteClasses, ByteSet},
                        escape::DebugByte,
                        int::{Pointer, Usize, U16, U32},
                        prefilter::Prefilter,
                        primitives::{PatternID, StateID},
                        search::Anchored,
                        start::{self, Start, StartByteMap},
                        wire::{self, DeserializeError, Endian, SerializeError},
                    },
                };
                */
                const LABEL: &str = "rust-regex-automata-dfa-sparse";
                const VERSION: u32 = 2;

                #[derive( Clone )]
                pub struct DFA<T> {
                    tt: Transitions<T>,
                    st: StartTable<T>,
                    special: Special,
                    pre:Option<Prefilter>,
                    quitset: ByteSet,
                    flags: Flags,
                }
                
                impl DFA<Vec<u8>>
                {
                    pub fn new(pattern: &str) -> Result<DFA<Vec<u8>>, BuildError> {
                        dense::Builder::new()
                            .build(pattern)
                            .and_then(|dense| dense.to_sparse())
                    }
                    
                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<DFA<Vec<u8>>, BuildError> {
                        dense::Builder::new()
                            .build_many(patterns)
                            .and_then(|dense| dense.to_sparse())
                    }
                }
                
                impl DFA<Vec<u8>> {
                    pub fn always_match() -> Result<DFA<Vec<u8>>, BuildError> { dense::DFA::always_match()?.to_sparse() }
                    
                    pub fn never_match() -> Result<DFA<Vec<u8>>, BuildError> { dense::DFA::never_match()?.to_sparse() }

                    pub fn from_dense<T: AsRef<[u32]>>(
                        dfa: &dense::DFA<T>,
                    ) -> Result<DFA<Vec<u8>>, BuildError> {
                        let mut sparse = Vec::with_capacity(StateID::SIZE * dfa.state_len());
                        
                        let mut remap: Vec<StateID> = vec![DEAD; dfa.state_len()];
                        for state in dfa.states() {
                            let pos = sparse.len();

                            remap[dfa.to_index(state.id())] = StateID::new(pos)
                                .map_err(|_| BuildError::too_many_states())?;
                            sparse.push(0);
                            sparse.push(0);

                            let mut transition_len = 0;
                            for (unit1, unit2, _) in state.sparse_transitions() {
                                match (unit1.as_u8(), unit2.as_u8()) {
                                    (Some(b1), Some(b2)) => {
                                        transition_len += 1;
                                        sparse.push(b1);
                                        sparse.push(b2);
                                    }
                                    (None, None) => {}
                                    (Some(_), None) | (None, Some(_)) => { unreachable!() }
                                }
                            }
                            
                            transition_len += 1;
                            sparse.push(0);
                            sparse.push(0);
                            assert_ne!(
                                transition_len, 0,
                                "transition length should be non-zero",
                            );
                            assert!(
                                transition_len <= 257,
                                "expected transition length {transition_len} to be <= 257",
                            );
                            let ntrans = if dfa.is_match_state(state.id()) {
                                transition_len | (1 << 15)
                            } else {
                                transition_len
                            };
                            wire::NE::write_u16(ntrans, &mut sparse[pos..]);
                            let zeros = usize::try_from(transition_len)
                                .unwrap()
                                .checked_mul(StateID::SIZE)
                                .unwrap();
                            sparse.extend(iter::repeat(0).take(zeros));
                            if dfa.is_match_state(state.id()) {
                                let plen = dfa.match_pattern_len(state.id());
                                let mut pos = sparse.len();
                                let zeros = size_of::<u32>()
                                    .checked_mul(plen)
                                    .unwrap()
                                    .checked_add(size_of::<u32>())
                                    .unwrap();
                                sparse.extend(iter::repeat(0).take(zeros));
                                wire::NE::write_u32(
                                    plen.try_into().expect("pattern ID length fits in u32"),
                                    &mut sparse[pos..],
                                );
                                pos += size_of::<u32>();
                                for &pid in dfa.pattern_id_slice(state.id()) {
                                    pos += wire::write_pattern_id::<wire::NE>(
                                        pid,
                                        &mut sparse[pos..],
                                    );
                                }
                            }
                            
                            let accel = dfa.accelerator(state.id());
                            sparse.push(accel.len().try_into().unwrap());
                            sparse.extend_from_slice(accel);
                        }

                        let mut new = DFA {
                            tt: Transitions {
                                sparse,
                                classes: dfa.byte_classes().clone(),
                                state_len: dfa.state_len(),
                                pattern_len: dfa.pattern_len(),
                            },
                            st: StartTable::from_dense_dfa(dfa, &remap)?,
                            special: dfa.special().remap(|id| remap[dfa.to_index(id)]),
                            pre: dfa.get_prefilter().map(|p| p.clone()),
                            quitset: dfa.quitset().clone(),
                            flags: dfa.flags().clone(),
                        };
                        for old_state in dfa.states() {
                            let new_id = remap[dfa.to_index(old_state.id())];
                            let mut new_state = new.tt.state_mut(new_id);
                            let sparse = old_state.sparse_transitions();
                            for (i, (_, _, next)) in sparse.enumerate() {
                                let next = remap[dfa.to_index(next)];
                                new_state.set_next_at(i, next);
                            }
                        }
                        new.tt.sparse.shrink_to_fit();
                        new.st.table.shrink_to_fit();
                        Ok(new)
                    }
                }

                impl<T: AsRef<[u8]>> DFA<T>
                {
                    pub fn as_ref<'a>(&'a self) -> DFA<&'a [u8]> {
                        DFA {
                            tt: self.tt.as_ref(),
                            st: self.st.as_ref(),
                            special: self.special,
                            pre: self.pre.clone(),
                            quitset: self.quitset,
                            flags: self.flags,
                        }
                    }
                    
                    pub fn to_owned( &self ) -> DFA<alloc::vec::Vec<u8>> {
                        DFA {
                            tt: self.tt.to_owned(),
                            st: self.st.to_owned(),
                            special: self.special,
                            pre: self.pre.clone(),
                            quitset: self.quitset,
                            flags: self.flags,
                        }
                    }

                    pub fn start_kind( &self ) -> StartKind { self.st.kind }

                    pub fn starts_for_each_pattern( &self ) -> bool { self.st.pattern_len.is_some() }

                    pub fn byte_classes( &self ) -> &ByteClasses { &self.tt.classes }

                    pub fn memory_usage( &self ) -> usize { self.tt.memory_usage() + self.st.memory_usage() }
                }
                impl<T: AsRef<[u8]>> DFA<T> {
                        pub fn to_bytes_little_endian( &self ) -> Vec<u8> { self.to_bytes::<wire::LE>() }
                        pub fn to_bytes_big_endian( &self ) -> Vec<u8> { self.to_bytes::<wire::BE>() }
                        pub fn to_bytes_native_endian( &self ) -> Vec<u8> { self.to_bytes::<wire::NE>() }
                        fn to_bytes<E: Endian>( &self ) -> Vec<u8>
                    {
                        let mut buf = vec![0; self.write_to_len()];
                        self.write_to::<E>(&mut buf).unwrap();
                        buf
                    }
                    
                    pub fn write_to_little_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> { self.write_to::<wire::LE>(dst) }
                    
                    pub fn write_to_big_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> { self.write_to::<wire::BE>(dst) }
                    
                    pub fn write_to_native_endian(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> { self.write_to::<wire::NE>(dst) }
                    fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let mut nw = 0;
                        nw += wire::write_label(LABEL, &mut dst[nw..])?;
                        nw += wire::write_endianness_check::<E>(&mut dst[nw..])?;
                        nw += wire::write_version::<E>(VERSION, &mut dst[nw..])?;
                        nw += {
                            E::write_u32(0, &mut dst[nw..]);
                            size_of::<u32>()
                        };
                        nw += self.flags.write_to::<E>(&mut dst[nw..])?;
                        nw += self.tt.write_to::<E>(&mut dst[nw..])?;
                        nw += self.st.write_to::<E>(&mut dst[nw..])?;
                        nw += self.special.write_to::<E>(&mut dst[nw..])?;
                        nw += self.quitset.write_to::<E>(&mut dst[nw..])?;
                        Ok(nw)
                    }
                    
                    pub fn write_to_len( &self ) -> usize {
                        wire::write_label_len(LABEL)
                        + wire::write_endianness_check_len()
                        + wire::write_version_len()
                        + size_of::<u32>()
                        + self.flags.write_to_len()
                        + self.tt.write_to_len()
                        + self.st.write_to_len()
                        + self.special.write_to_len()
                        + self.quitset.write_to_len()
                    }
                }

                impl<'a> DFA<&'a [u8]> {
                    pub fn from_bytes(
                        slice: &'a [u8],
                    ) -> Result<(DFA<&'a [u8]>, usize), DeserializeError> {
                        let (dfa, nread) = unsafe { DFA::from_bytes_unchecked(slice)? };
                        let seen = dfa.tt.validate(&dfa.special)?;
                        dfa.st.validate(&dfa.special, &seen)?;
                        Ok((dfa, nread))
                    }
                    
                    pub unsafe fn from_bytes_unchecked(
                        slice: &'a [u8],
                    ) -> Result<(DFA<&'a [u8]>, usize), DeserializeError>
                    {
                        let mut nr = 0;

                        nr += wire::read_label(&slice[nr..], LABEL)?;
                        nr += wire::read_endianness_check(&slice[nr..])?;
                        nr += wire::read_version(&slice[nr..], VERSION)?;

                        let _unused = wire::try_read_u32(&slice[nr..], "unused space")?;
                        nr += size_of::<u32>();

                        let (flags, nread) = Flags::from_bytes(&slice[nr..])?;
                        nr += nread;

                        let (tt, nread) = Transitions::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (st, nread) = StartTable::from_bytes_unchecked(&slice[nr..])?;
                        nr += nread;

                        let (special, nread) = Special::from_bytes(&slice[nr..])?;
                        nr += nread;
                        if special.max.as_usize() >= tt.sparse().len() {
                            return Err(DeserializeError::generic(
                                "max should not be greater than or equal to sparse bytes",
                            ));
                        }

                        let (quitset, nread) = ByteSet::from_bytes(&slice[nr..])?;
                        nr += nread;
                        
                        let pre = None;
                        Ok((DFA { tt, st, special, pre, quitset, flags }, nr))
                    }
                }

                impl<T> DFA<T>
                {
                    pub fn set_prefilter( &mut self, prefilter:Option<Prefilter>) {
                        self.pre = prefilter
                    }
                }

                impl<T: AsRef<[u8]>> fmt::Debug for DFA<T>
               
               
                {
                    fn fmt( &self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        writeln!(f, "sparse::DFA(")?;
                        for state in self.tt.states() {
                            fmt_state_indicator(f, self, state.id())?;
                            writeln!(f, "{:06?}: {:?}", state.id().as_usize(), state)?;
                        }
                        writeln!(f, "")?;
                        for (i, (start_id, anchored, sty)) in self.st.iter().enumerate() {
                            if i % self.st.stride == 0 {
                                match anchored {
                                    Anchored::No => writeln!(f, "START-GROUP(unanchored)")?,
                                    Anchored::Yes => writeln!(f, "START-GROUP(anchored)")?,
                                    Anchored::Pattern(pid) => writeln!(
                                        f,
                                        "START_GROUP(pattern: {:?})",
                                        pid.as_usize()
                                    )?,
                                }
                            }
                            writeln!(f, "  {:?} => {:06?}", sty, start_id.as_usize())?;
                        }
                        writeln!(f, "state length: {:?}", self.tt.state_len)?;
                        writeln!(f, "pattern length: {:?}", self.pattern_len())?;
                        writeln!(f, "flags: {:?}", self.flags)?;
                        writeln!(f, ")")?;
                        Ok( () )
                    }
                }
                
                unsafe impl<T: AsRef<[u8]>> Automaton for DFA<T> {
                    #[inline] fn is_special_state(&self, id: StateID) -> bool {
                        self.special.is_special_state(id)
                    }

                    #[inline] fn is_dead_state(&self, id: StateID) -> bool {
                        self.special.is_dead_state(id)
                    }

                    #[inline] fn is_quit_state(&self, id: StateID) -> bool {
                        self.special.is_quit_state(id)
                    }

                    #[inline] fn is_match_state(&self, id: StateID) -> bool {
                        self.special.is_match_state(id)
                    }

                    #[inline] fn is_start_state(&self, id: StateID) -> bool {
                        self.special.is_start_state(id)
                    }

                    #[inline] fn is_accel_state(&self, id: StateID) -> bool {
                        self.special.is_accel_state(id)
                    }
                    #[inline( always )] fn next_state(&self, current: StateID, input: u8) -> StateID {
                        let input = self.tt.classes.get(input);
                        self.tt.state(current).next(input)
                    }

                    #[inline] unsafe fn next_state_unchecked(
                        &self,
                        current: StateID,
                        input: u8,
                    ) -> StateID {
                        self.next_state(current, input)
                    }

                    #[inline] fn next_eoi_state(&self, current: StateID) -> StateID {
                        self.tt.state(current).next_eoi()
                    }

                    #[inline] fn pattern_len( &self ) -> usize { self.tt.pattern_len }

                    #[inline] fn match_len(&self, id: StateID) -> usize {
                        self.tt.state(id).pattern_len()
                    }

                    #[inline] fn match_pattern(&self, id: StateID, match_index: usize) -> PatternID {
                        if self.tt.pattern_len == 1 {
                            return PatternID::ZERO;
                        }
                        self.tt.state(id).pattern_id(match_index)
                    }

                    #[inline] fn has_empty( &self ) -> bool { self.flags.has_empty }

                    #[inline] fn is_utf8( &self ) -> bool { self.flags.is_utf8 }

                    #[inline] fn is_always_start_anchored( &self ) -> bool { self.flags.is_always_start_anchored }

                    #[inline] fn start_state(
                        &self,
                        config: &start::Config,
                    ) -> Result<StateID, StartError>
                    {
                        let anchored = config.get_anchored();
                        let start = match config.get_look_behind() {
                            None => Start::Text,
                            Some( byte ) => {
                                if !self.quitset.is_empty() && self.quitset.contains( byte ) {
                                    return Err(StartError::quit( byte ));
                                }
                                self.st.start_map.get( byte )
                            }
                        };
                        self.st.start(anchored, start)
                    }

                    #[inline] fn universal_start_state(&self, mode: Anchored) -> Option<StateID> {
                        match mode {
                            Anchored::No => self.st.universal_start_unanchored,
                            Anchored::Yes => self.st.universal_start_anchored,
                            Anchored::Pattern(_) => None,
                        }
                    }

                    #[inline] fn accelerator(&self, id: StateID) -> &[u8] {
                        self.tt.state(id).accelerator()
                    }

                    #[inline] fn get_prefilter( &self ) -> Option<&Prefilter> { self.pre.as_ref() }
                }

                #[derive( Clone )]
                struct Transitions<T> {
                    sparse: T,
                    classes: ByteClasses,
                    state_len: usize,
                    pattern_len: usize,
                }

                impl<'a> Transitions<&'a [u8]> {
                    unsafe fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(Transitions<&'a [u8]>, usize), DeserializeError>
                    {
                        let slice_start = slice.as_ptr().as_usize();

                        let (state_len, nr) =
                            wire::try_read_u32_as_usize(&slice, "state length")?;
                        slice = &slice[nr..];

                        let (pattern_len, nr) =
                            wire::try_read_u32_as_usize(&slice, "pattern length")?;
                        slice = &slice[nr..];

                        let (classes, nr) = ByteClasses::from_bytes(&slice)?;
                        slice = &slice[nr..];

                        let (len, nr) =
                            wire::try_read_u32_as_usize(&slice, "sparse transitions length")?;
                        slice = &slice[nr..];

                        wire::check_slice_len(slice, len, "sparse states byte length")?;
                        let sparse = &slice[..len];
                        slice = &slice[len..];

                        let trans = Transitions { sparse, classes, state_len, pattern_len };
                        Ok((trans, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl<T: AsRef<[u8]>> Transitions<T> {

                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small(
                                "sparse transition table",
                            ));
                        }
                        dst = &mut dst[..nwrite];
                        E::write_u32(u32::try_from( self.state_len).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(u32::try_from( self.pattern_len).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        
                        let n = self.classes.write_to(dst)?;
                        dst = &mut dst[n..];
                        E::write_u32(u32::try_from( self.sparse().len()).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        
                        let mut id = DEAD;
                        while id.as_usize() < self.sparse().len() {
                            let state = self.state(id);
                            let n = state.write_to::<E>(&mut dst)?;
                            dst = &mut dst[n..];
                            id = StateID::new(id.as_usize() + state.write_to_len()).unwrap();
                        }
                        Ok(nwrite)
                    }
                    fn write_to_len( &self ) -> usize {
                        size_of::<u32>()  
                        + size_of::<u32>() 
                        + self.classes.write_to_len()
                        + size_of::<u32>()
                        + self.sparse().len()
                    }
                    fn validate(&self, sp: &Special) -> Result<Seen, DeserializeError>
                    {
                        let mut verified = Seen::new();
                        
                        let mut len = 0;
                        let mut id = DEAD;
                        while id.as_usize() < self.sparse().len() {
                            if sp.is_special_state(id) {
                                let is_actually_special = sp.is_dead_state(id)
                                    || sp.is_quit_state(id)
                                    || sp.is_match_state(id)
                                    || sp.is_start_state(id)
                                    || sp.is_accel_state(id);
                                if !is_actually_special {
                                    return Err(DeserializeError::generic(
                                        "found sparse state tagged as special but \
                                        wasn't actually special",
                                    ));
                                }
                            }
                            let state = self.try_state(sp, id)?;
                            verified.insert(id);
                            id = StateID::new(wire::add(
                                id.as_usize(),
                                state.write_to_len(),
                                "next state ID offset",
                            )?)
                            .map_err(|err| {
                                DeserializeError::state_id_error(err, "next state ID offset")
                            })?;
                            len += 1;
                        }
                        
                        for state in self.states() {
                            for i in 0..state.ntrans {
                                let to = state.next_at(i);
                                if !verified.contains(&to) {
                                        return Err(DeserializeError::generic(
                                            "found transition that points to a \
                                            non-existent state",
                                        ));
                                    }
                            }
                        }
                        if len != self.state_len {
                            return Err(DeserializeError::generic(
                                "mismatching sparse state length",
                            ));
                        }
                        Ok(verified)
                    }

                    fn as_ref( &self ) -> Transitions<&'_ [u8]> {
                        Transitions {
                            sparse: self.sparse(),
                            classes: self.classes.clone(),
                            state_len: self.state_len,
                            pattern_len: self.pattern_len,
                        }
                    }

                    fn to_owned( &self ) -> Transitions<alloc::vec::Vec<u8>> {
                        Transitions {
                            sparse: self.sparse().to_vec(),
                            classes: self.classes.clone(),
                            state_len: self.state_len,
                            pattern_len: self.pattern_len,
                        }
                    }

                    #[inline( always )] fn state(&self, id: StateID) -> State<'_>
                    {
                        let mut state = &self.sparse()[id.as_usize()..];
                        let mut ntrans = wire::read_u16(&state).as_usize();
                        let is_match = (1 << 15) & ntrans != 0;
                        ntrans &= !(1 << 15);
                        state = &state[2..];

                        let (input_ranges, state) = state.split_at(ntrans * 2);
                        let (next, state) = state.split_at(ntrans * StateID::SIZE);
                        let (pattern_ids, state) = if is_match {
                            let npats = wire::read_u32(&state).as_usize();
                            state[4..].split_at(npats * 4)
                        } else {
                            (&[][..], state)
                        };

                        let accel_len = usize::from(state[0]);
                        let accel = &state[1..accel_len + 1];
                        State { id, is_match, ntrans, input_ranges, next, pattern_ids, accel }
                    }
                    fn try_state(
                        &self,
                        sp: &Special,
                        id: StateID,
                    ) -> Result<State<'_>, DeserializeError> {
                        if id.as_usize() > self.sparse().len() {
                            return Err(DeserializeError::generic(
                                "invalid caller provided sparse state ID",
                            ));
                        }
                        let mut state = &self.sparse()[id.as_usize()..];
                        let (mut ntrans, _) =
                            wire::try_read_u16_as_usize(state, "state transition length")?;
                        let is_match = ((1 << 15) & ntrans) != 0;
                        ntrans &= !(1 << 15);
                        state = &state[2..];
                        if ntrans > 257 || ntrans == 0 {
                            return Err(DeserializeError::generic(
                                "invalid transition length",
                            ));
                        }
                        if is_match && !sp.is_match_state(id) {
                            return Err(DeserializeError::generic(
                                "state marked as match but not in match ID range",
                            ));
                        } else if !is_match && sp.is_match_state(id) {
                            return Err(DeserializeError::generic(
                                "state in match ID range but not marked as match state",
                            ));
                        }
                        // pairs come first, followed by a corresponding sequence of state IDs.
                        let input_ranges_len = ntrans.checked_mul(2).unwrap();
                        wire::check_slice_len(state, input_ranges_len, "sparse byte pairs")?;
                        let (input_ranges, state) = state.split_at(input_ranges_len);
                        for pair in input_ranges.chunks(2) {
                            let (start, end) = (pair[0], pair[1]);
                            if start > end {
                                return Err(DeserializeError::generic("invalid input range"));
                            }
                        }
                        // not have any alignment requirements.
                        let next_len = ntrans
                            .checked_mul( self.id_len())
                            .expect("state size * #trans should always fit in a usize");
                        wire::check_slice_len(state, next_len, "sparse trans state IDs")?;
                        let (next, state) = state.split_at(next_len);
                        for idbytes in next.chunks( self.id_len()) {
                            let (id, _) =
                                wire::read_state_id(idbytes, "sparse state ID in try_state")?;
                            wire::check_slice_len(
                                self.sparse(),
                                id.as_usize(),
                                "invalid sparse state ID",
                            )?;
                        }
                        // encoded 32-bit integers.
                        let (pattern_ids, state) = if is_match {
                            let (npats, nr) =
                                wire::try_read_u32_as_usize(state, "pattern ID length")?;
                            let state = &state[nr..];
                            if npats == 0 {
                                return Err(DeserializeError::generic(
                                    "state marked as a match, but pattern length is zero",
                                ));
                            }

                            let pattern_ids_len =
                                wire::mul(npats, 4, "sparse pattern ID byte length")?;
                            wire::check_slice_len(
                                state,
                                pattern_ids_len,
                                "sparse pattern IDs",
                            )?;
                            let (pattern_ids, state) = state.split_at(pattern_ids_len);
                            for patbytes in pattern_ids.chunks(PatternID::SIZE) {
                                wire::read_pattern_id(
                                    patbytes,
                                    "sparse pattern ID in try_state",
                                )?;
                            }
                            (pattern_ids, state)
                        } else {
                            (&[][..], state)
                        };
                        if is_match && pattern_ids.is_empty() {
                            return Err(DeserializeError::generic(
                                "state marked as a match, but has no pattern IDs",
                            ));
                        }
                        if sp.is_match_state(id) && pattern_ids.is_empty() {
                            return Err(DeserializeError::generic(
                                "state marked special as a match, but has no pattern IDs",
                            ));
                        }
                        if sp.is_match_state(id) != is_match {
                            return Err(DeserializeError::generic(
                                "whether state is a match or not is inconsistent",
                            ));
                        }

                        if state.is_empty() {
                            return Err(DeserializeError::generic("no accelerator length"));
                        }
                        let (accel_len, state) = (usize::from(state[0]), &state[1..]);

                        if accel_len > 3 {
                            return Err(DeserializeError::generic(
                                "sparse invalid accelerator length",
                            ));
                        } else if accel_len == 0 && sp.is_accel_state(id) {
                            return Err(DeserializeError::generic(
                                "got no accelerators in state, but in accelerator ID range",
                            ));
                        } else if accel_len > 0 && !sp.is_accel_state(id) {
                            return Err(DeserializeError::generic(
                                "state in accelerator ID range, but has no accelerators",
                            ));
                        }

                        wire::check_slice_len(
                            state,
                            accel_len,
                            "sparse corrupt accelerator length",
                        )?;
                        let (accel, _) = (&state[..accel_len], &state[accel_len..]);

                        let state = State {
                            id,
                            is_match,
                            ntrans,
                            input_ranges,
                            next,
                            pattern_ids,
                            accel,
                        };
                        if sp.is_quit_state(state.next_at(state.ntrans - 1)) {
                            return Err(DeserializeError::generic(
                                "state with EOI transition to quit state is illegal",
                            ));
                        }
                        Ok(state)
                    }
                    fn states( &self ) -> StateIter<'_, T> { StateIter { trans: self, id: DEAD.as_usize() } }

                    fn sparse( &self ) -> &[u8] { self.sparse.as_ref() }

                    fn id_len( &self ) -> usize { StateID::SIZE }

                    fn memory_usage( &self ) -> usize { self.sparse().len() }
                }
                
                impl<T: AsMut<[u8]>> Transitions<T>
                {
                    fn state_mut( &mut self, id: StateID) -> StateMut<'_>
                    {
                        let mut state = &mut self.sparse_mut()[id.as_usize()..];
                        let mut ntrans = wire::read_u16(&state).as_usize();
                        let is_match = (1 << 15) & ntrans != 0;
                        ntrans &= !(1 << 15);
                        state = &mut state[2..];

                        let (input_ranges, state) = state.split_at_mut(ntrans * 2);
                        let (next, state) = state.split_at_mut(ntrans * StateID::SIZE);
                        let (pattern_ids, state) = if is_match {
                            let npats = wire::read_u32(&state).as_usize();
                            state[4..].split_at_mut(npats * 4)
                        } else {
                            (&mut [][..], state)
                        };

                        let accel_len = usize::from(state[0]);
                        let accel = &mut state[1..accel_len + 1];
                        StateMut {
                            id,
                            is_match,
                            ntrans,
                            input_ranges,
                            next,
                            pattern_ids,
                            accel,
                        }
                    }

                    fn sparse_mut(&mut self) -> &mut [u8] {
                        self.sparse.as_mut()
                    }
                }

                #[derive( Clone )]
                struct StartTable<T> {
                    table: T,
                    kind: StartKind,
                    start_map: StartByteMap,
                    stride: usize,
                    pattern_len:Option<usize>,
                    universal_start_unanchored:Option<StateID>,
                    universal_start_anchored:Option<StateID>,
                }
                
                impl StartTable<Vec<u8>>
                {
                    fn new<T: AsRef<[u32]>>(
                        dfa: &dense::DFA<T>,
                        pattern_len:Option<usize>,
                    ) -> StartTable<Vec<u8>>
                    {
                        let stride = Start::len();
                        let len = stride
                            .checked_mul(pattern_len.unwrap_or(0))
                            .unwrap()
                            .checked_add(stride.checked_mul(2).unwrap())
                            .unwrap()
                            .checked_mul(StateID::SIZE)
                            .unwrap();
                        StartTable {
                            table: vec![0; len],
                            kind: dfa.start_kind(),
                            start_map: dfa.start_map().clone(),
                            stride,
                            pattern_len,
                            universal_start_unanchored: dfa
                                .universal_start_state(Anchored::No),
                            universal_start_anchored: dfa.universal_start_state(Anchored::Yes),
                        }
                    }

                    fn from_dense_dfa<T: AsRef<[u32]>>(
                        dfa: &dense::DFA<T>,
                        remap: &[StateID],
                    ) -> Result<StartTable<Vec<u8>>, BuildError>
                    {
                        let start_pattern_len = if dfa.starts_for_each_pattern() {
                            Some(dfa.pattern_len())
                        } else {
                            None
                        };
                        let mut sl = StartTable::new(dfa, start_pattern_len);
                        for (old_start_id, anchored, sty) in dfa.starts() {
                            let new_start_id = remap[dfa.to_index(old_start_id)];
                            sl.set_start(anchored, sty, new_start_id);
                        }
                        if let Some(ref mut id) = sl.universal_start_anchored {
                            *id = remap[dfa.to_index(*id)];
                        }
                        if let Some(ref mut id) = sl.universal_start_unanchored {
                            *id = remap[dfa.to_index(*id)];
                        }
                        Ok(sl)
                    }
                }

                impl<'a> StartTable<&'a [u8]> {
                    unsafe fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(StartTable<&'a [u8]>, usize), DeserializeError>
                    {
                        let slice_start = slice.as_ptr().as_usize();

                        let (kind, nr) = StartKind::from_bytes(slice)?;
                        slice = &slice[nr..];

                        let (start_map, nr) = StartByteMap::from_bytes(slice)?;
                        slice = &slice[nr..];

                        let (stride, nr) =
                            wire::try_read_u32_as_usize(slice, "sparse start table stride")?;
                        slice = &slice[nr..];
                        if stride != Start::len() {
                            return Err(DeserializeError::generic(
                                "invalid sparse starting table stride",
                            ));
                        }

                        let (maybe_pattern_len, nr) =
                            wire::try_read_u32_as_usize(slice, "sparse start table patterns")?;
                        slice = &slice[nr..];
                        let pattern_len = if maybe_pattern_len.as_u32() == u32::MAX {
                            None
                        } else {
                            Some(maybe_pattern_len)
                        };
                        if pattern_len.map_or(false, |len| len > PatternID::LIMIT) {
                            return Err(DeserializeError::generic(
                                "sparse invalid number of patterns",
                            ));
                        }

                        let (universal_unanchored, nr) =
                            wire::try_read_u32(slice, "universal unanchored start")?;
                        slice = &slice[nr..];
                        let universal_start_unanchored = if universal_unanchored == u32::MAX {
                            None
                        } else {
                            Some(StateID::try_from(universal_unanchored).map_err(|e| {
                                DeserializeError::state_id_error(
                                    e,
                                    "universal unanchored start",
                                )
                            })?)
                        };

                        let (universal_anchored, nr) =
                            wire::try_read_u32(slice, "universal anchored start")?;
                        slice = &slice[nr..];
                        let universal_start_anchored = if universal_anchored == u32::MAX {
                            None
                        } else {
                            Some(StateID::try_from(universal_anchored).map_err(|e| {
                                DeserializeError::state_id_error(e, "universal anchored start")
                            })?)
                        };

                        let pattern_table_size = wire::mul(
                            stride,
                            pattern_len.unwrap_or(0),
                            "sparse invalid pattern length",
                        )?;
                        
                        let start_state_len = wire::add(
                            wire::mul(2, stride, "start state stride too big")?,
                            pattern_table_size,
                            "sparse invalid 'any' pattern starts size",
                        )?;
                        let table_bytes_len = wire::mul(
                            start_state_len,
                            StateID::SIZE,
                            "sparse pattern table bytes length",
                        )?;
                        wire::check_slice_len(
                            slice,
                            table_bytes_len,
                            "sparse start ID table",
                        )?;
                        let table = &slice[..table_bytes_len];
                        slice = &slice[table_bytes_len..];

                        let sl = StartTable {
                            table,
                            kind,
                            start_map,
                            stride,
                            pattern_len,
                            universal_start_unanchored,
                            universal_start_anchored,
                        };
                        Ok((sl, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl<T: AsRef<[u8]>> StartTable<T>
                {
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small(
                                "sparse starting table ids",
                            ));
                        }
                        dst = &mut dst[..nwrite];
                        
                        let nw = self.kind.write_to::<E>(dst)?;
                        dst = &mut dst[nw..];
                        
                        let nw = self.start_map.write_to(dst)?;
                        dst = &mut dst[nw..];
                        E::write_u32(u32::try_from( self.stride).unwrap(), dst);
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(
                            u32::try_from( self.pattern_len.unwrap_or(0xFFFF_FFFF)).unwrap(),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(
                            self.universal_start_unanchored
                                .map_or(u32::MAX, |sid| sid.as_u32()),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        E::write_u32(
                            self.universal_start_anchored.map_or(u32::MAX, |sid| sid.as_u32()),
                            dst,
                        );
                        dst = &mut dst[size_of::<u32>()..];
                        for (sid, _, _) in self.iter() {
                            E::write_u32(sid.as_u32(), dst);
                            dst = &mut dst[StateID::SIZE..];
                        }
                        Ok(nwrite)
                    }
                    fn write_to_len( &self ) -> usize {
                        self.kind.write_to_len()
                        + self.start_map.write_to_len()
                        + size_of::<u32>() // stride
                        + size_of::<u32>() // # patterns
                        + size_of::<u32>() // universal unanchored start
                        + size_of::<u32>() // universal anchored start
                        + self.table().len()
                    }
                    fn validate(
                        &self,
                        sp: &Special,
                        seen: &Seen,
                    ) -> Result<(), DeserializeError> {
                        for (id, _, _) in self.iter() {
                            if !seen.contains(&id) {
                                return Err(DeserializeError::generic(
                                    "found invalid start state ID",
                                ));
                            }
                            if sp.is_match_state(id) {
                                return Err(DeserializeError::generic(
                                    "start states cannot be match states",
                                ));
                            }
                        }
                        Ok( () )
                    }

                    fn as_ref( &self ) -> StartTable<&'_ [u8]> {
                        StartTable {
                            table: self.table(),
                            kind: self.kind,
                            start_map: self.start_map.clone(),
                            stride: self.stride,
                            pattern_len: self.pattern_len,
                            universal_start_unanchored: self.universal_start_unanchored,
                            universal_start_anchored: self.universal_start_anchored,
                        }
                    }

                    fn to_owned( &self ) -> StartTable<alloc::vec::Vec<u8>> {
                        StartTable {
                            table: self.table().to_vec(),
                            kind: self.kind,
                            start_map: self.start_map.clone(),
                            stride: self.stride,
                            pattern_len: self.pattern_len,
                            universal_start_unanchored: self.universal_start_unanchored,
                            universal_start_anchored: self.universal_start_anchored,
                        }
                    }
                    fn start(
                        &self,
                        anchored: Anchored,
                        start: Start,
                    ) -> Result<StateID, StartError>
                    {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => {
                                if !self.kind.has_unanchored() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                start_index
                            }
                            Anchored::Yes => {
                                if !self.kind.has_anchored() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                self.stride + start_index
                            }
                            Anchored::Pattern(pid) => {
                                let len = match self.pattern_len {
                                    None => { return Err(StartError::unsupported_anchored(anchored)) }
                                    Some(len) => len,
                                };
                                if pid.as_usize() >= len {
                                    return Ok(DEAD);
                                }
                                (2 * self.stride)
                                    + ( self.stride * pid.as_usize())
                                    + start_index
                            }
                        };
                        let start = index * StateID::SIZE;
                        Ok(wire::read_state_id_unchecked(&self.table()[start..]).0)
                    }

                    fn iter( &self ) -> StartStateIter<'_, T> { StartStateIter { st: self, i: 0 } }

                    fn len( &self ) -> usize { self.table().len() / StateID::SIZE }

                    fn table( &self ) -> &[u8] { self.table.as_ref() }

                    fn memory_usage( &self ) -> usize { self.table().len() }
                }
                
                impl<T: AsMut<[u8]>> StartTable<T> {

                    fn set_start( &mut self, anchored: Anchored, start: Start, id: StateID) {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => start_index,
                            Anchored::Yes => self.stride + start_index,
                            Anchored::Pattern(pid) => {
                                let pid = pid.as_usize();
                                let len = self
                                    .pattern_len
                                    .expect("start states for each pattern enabled");
                                assert!(pid < len, "invalid pattern ID {pid:?}");
                                self.stride
                                    .checked_mul(pid)
                                    .unwrap()
                                    .checked_add( self.stride.checked_mul(2).unwrap())
                                    .unwrap()
                                    .checked_add(start_index)
                                    .unwrap()
                            }
                        };
                        let start = index * StateID::SIZE;
                        let end = start + StateID::SIZE;
                        wire::write_state_id::<wire::NE>(
                            id,
                            &mut self.table.as_mut()[start..end],
                        );
                    }
                }

                struct StartStateIter<'a, T> {
                    st: &'a StartTable<T>,
                    i: usize,
                }

                impl<'a, T: AsRef<[u8]>> Iterator for StartStateIter<'a, T> {
                    type Item = (StateID, Anchored, Start);

                    fn next(&mut self) -> Option<(StateID, Anchored, Start)>
                    {
                        let i = self.i;
                        if i >= self.st.len() {
                            return None;
                        }
                        self.i += 1;
                        let start_type = Start::from_usize(i % self.st.stride).unwrap();
                        let anchored = if i < self.st.stride {
                            Anchored::No
                        } else if i < (2 * self.st.stride) {
                            Anchored::Yes
                        } else {
                            let pid = (i - (2 * self.st.stride)) / self.st.stride;
                            Anchored::Pattern(PatternID::new(pid).unwrap())
                        };
                        let start = i * StateID::SIZE;
                        let end = start + StateID::SIZE;
                        let bytes = self.st.table()[start..end].try_into().unwrap();
                        let id = StateID::from_ne_bytes_unchecked(bytes);
                        Some((id, anchored, start_type))
                    }
                }

                impl<'a, T> fmt::Debug for StartStateIter<'a, T>
               
               
                {
                    fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                        f.debug_struct("StartStateIter").field("i", &self.i).finish()
                    }
                }

                struct StateIter<'a, T> {
                    trans: &'a Transitions<T>,
                    id: usize,
                }

                impl<'a, T: AsRef<[u8]>> Iterator for StateIter<'a, T> {
                    type Item = State<'a>;

                    fn next(&mut self) -> Option<State<'a>> {
                        if self.id >= self.trans.sparse().len() {
                            return None;
                        }
                        let state = self.trans.state(StateID::new_unchecked( self.id));
                        self.id = self.id + state.write_to_len();
                        Some(state)
                    }
                }

                impl<'a, T> fmt::Debug for StateIter<'a, T>
               
               
                {
                    fn fmt( &self, f: &mut fmt::Formatter) -> fmt::Result {
                        f.debug_struct("StateIter").field("id", &self.id).finish()
                    }
                }
                
                #[derive( Clone )]
                struct State<'a> {

                    id: StateID,
                    is_match: bool,
                    ntrans: usize,
                    input_ranges: &'a [u8],
                    next: &'a [u8],
                    pattern_ids: &'a [u8],
                    accel: &'a [u8],
                }

                impl<'a> State<'a> {

                    #[inline( always )] fn next(&self, input: u8) -> StateID {
                        // not by much. There might be a better trade off lurking here.
                        for i in 0..( self.ntrans - 1) {
                            let (start, end) = self.range(i);
                            if start <= input && input <= end {
                                return self.next_at(i);
                            }
                            // is being searched.
                        }
                        DEAD
                    }

                    fn next_eoi( &self ) -> StateID { self.next_at( self.ntrans - 1) }

                    fn id( &self ) -> StateID { self.id }
                    fn range(&self, i: usize) -> (u8, u8) {
                        ( self.input_ranges[i * 2], self.input_ranges[i * 2 + 1])
                    }

                    fn next_at(&self, i: usize) -> StateID {
                        let start = i * StateID::SIZE;
                        let end = start + StateID::SIZE;
                        let bytes = self.next[start..end].try_into().unwrap();
                        StateID::from_ne_bytes_unchecked(bytes)
                    }
                    fn pattern_id(&self, match_index: usize) -> PatternID {
                        let start = match_index * PatternID::SIZE;
                        wire::read_pattern_id_unchecked(&self.pattern_ids[start..]).0
                    }
                    fn pattern_len( &self ) -> usize {
                        assert_eq!(0, self.pattern_ids.len() % 4);
                        self.pattern_ids.len() / 4
                    }

                    fn accelerator( &self ) -> &'a [u8] { self.accel }
                    fn write_to<E: Endian>(
                        &self,
                        mut dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small(
                                "sparse state transitions",
                            ));
                        }

                        let ntrans =
                            if self.is_match { self.ntrans | (1 << 15) } else { self.ntrans };
                        E::write_u16(u16::try_from(ntrans).unwrap(), dst);
                        dst = &mut dst[size_of::<u16>()..];

                        dst[..self.input_ranges.len()].copy_from_slice( self.input_ranges);
                        dst = &mut dst[self.input_ranges.len()..];

                        for i in 0..self.ntrans {
                            E::write_u32( self.next_at(i).as_u32(), dst);
                            dst = &mut dst[StateID::SIZE..];
                        }

                        if self.is_match {
                            E::write_u32(u32::try_from( self.pattern_len()).unwrap(), dst);
                            dst = &mut dst[size_of::<u32>()..];
                            for i in 0..self.pattern_len() {
                                let pid = self.pattern_id(i);
                                E::write_u32(pid.as_u32(), dst);
                                dst = &mut dst[PatternID::SIZE..];
                            }
                        }

                        dst[0] = u8::try_from( self.accel.len()).unwrap();
                        dst[1..][..self.accel.len()].copy_from_slice( self.accel);

                        Ok(nwrite)
                    }
                    fn write_to_len( &self ) -> usize {
                        let mut len = 2
                            + ( self.ntrans * 2)
                            + ( self.ntrans * StateID::SIZE)
                            + (1 + self.accel.len());
                        if self.is_match {
                            len += size_of::<u32>() + self.pattern_ids.len();
                        }
                        len
                    }
                }

                impl<'a> fmt::Debug for State<'a>
               
               
                {
                    fn fmt( &self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let mut printed = false;
                        for i in 0..( self.ntrans - 1) {
                            let next = self.next_at(i);
                            if next == DEAD {
                                continue;
                            }

                            if printed {
                                write!(f, ",")?;
                            }
                            let (start, end) = self.range(i);
                            if start == end {
                                write!(f, "{:?} => {:?}", DebugByte(start), next.as_usize())?;
                            } else {
                                write!(
                                    f,
                                    "{:?}-{:?} => {:?}",
                                    DebugByte(start),
                                    DebugByte(end),
                                    next.as_usize(),
                                )?;
                            }
                            printed = true;
                        }
                        let eoi = self.next_at( self.ntrans - 1);
                        if eoi != DEAD {
                            if printed {
                                write!(f, ",")?;
                            }
                            write!(f, "EOI => {:?}", eoi.as_usize())?;
                        }
                        Ok( () )
                    }
                }
                struct StateMut<'a> {

                    id: StateID,
                    is_match: bool,
                    ntrans: usize,
                    input_ranges: &'a mut [u8],
                    next: &'a mut [u8],
                    pattern_ids: &'a [u8],
                    accel: &'a mut [u8],
                }
                
                impl<'a> StateMut<'a> {

                    fn set_next_at( &mut self, i: usize, next: StateID) {
                        let start = i * StateID::SIZE;
                        let end = start + StateID::SIZE;
                        wire::write_state_id::<wire::NE>(next, &mut self.next[start..end]);
                    }
                }
                
                impl<'a> fmt::Debug for StateMut<'a>
               
               
                {
                    fn fmt( &self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let state = State {
                            id: self.id,
                            is_match: self.is_match,
                            ntrans: self.ntrans,
                            input_ranges: self.input_ranges,
                            next: self.next,
                            pattern_ids: self.pattern_ids,
                            accel: self.accel,
                        };
                        fmt::Debug::fmt(&state, f)
                    }
                }
                // decoding work.
                //
                //
                // "valid" in the sense that everything it points to actually exists.
                //
                // ---AG
                #[derive( Debug )]
                struct Seen {
                    set: alloc::collections::BTreeSet<StateID>,
                    #[cfg(not(feature = "alloc"))]
                    set: ::marker::PhantomData<StateID>,
                }

                impl Seen
                {
                    fn new() -> Seen {
                        Seen { set: alloc::collections::BTreeSet::new() }
                    }
                    fn insert( &mut self, id: StateID) {
                        self.set.insert(id);
                    }
                    fn contains(&self, id: &StateID) -> bool {
                        self.set.contains(id)
                    }
                }

                #[cfg(not(feature = "alloc"))]
                impl Seen
                {
                    fn new() -> Seen {
                        Seen { set: ::marker::PhantomData }
                    }
                    fn insert( &mut self, _id: StateID) {}
                    fn contains(&self, _id: &StateID) -> bool {
                        true
                    }
                }

                /*
                #[inline( always )]
                fn binary_search_ranges(ranges: &[u8], needle: u8) -> Option<usize> {
                    debug_assert!(ranges.len() % 2 == 0, "ranges must have even length");
                    debug_assert!(ranges.len() <= 512, "ranges should be short");

                    let (mut left, mut right) = (0, ranges.len() / 2);
                    while left < right {
                        let mid = (left + right) / 2;
                        let (b1, b2) = (ranges[mid * 2], ranges[mid * 2 + 1]);
                        if needle < b1 {
                            right = mid;
                        } else if needle > b2 {
                            left = mid + 1;
                        } else {
                            return Some(mid);
                        }
                    }
                    None
                }
                */


            }

            pub mod accel
            {
                /*!
                This module defines some core types for dealing with accelerated DFA states. */
                use ::
                {
                    *,
                };
                /*
                use alloc::{vec, vec::Vec};

                use crate::util::{
                    int::Pointer,
                    memchr,
                    wire::{self, DeserializeError, Endian, SerializeError},
                };
                */

                type AccelTy = u32;

                ///

                const ACCEL_TY_SIZE: usize = ::mem::size_of::<AccelTy>();

                const ACCEL_LEN: usize = 4;

                const ACCEL_CAP: usize = 8;
                #[inline( always )]
                pub fn find_fwd(
                    needles: &[u8],
                    haystack: &[u8],
                    at: usize,
                ) -> Option<usize> {
                    let bs = needles;
                    let i = match needles.len() {
                        1 => memchr::memchr(bs[0], &haystack[at..])?,
                        2 => memchr::memchr2(bs[0], bs[1], &haystack[at..])?,
                        3 => memchr::memchr3(bs[0], bs[1], bs[2], &haystack[at..])?,
                        0 => panic!("cannot find with empty needles"),
                        n => panic!("invalid needles length: {n}"),
                    };
                    Some(at + i)
                }
                #[inline( always )]
                pub fn find_rev(
                    needles: &[u8],
                    haystack: &[u8],
                    at: usize,
                ) -> Option<usize> {
                    let bs = needles;
                    match needles.len() {
                        1 => memchr::memrchr(bs[0], &haystack[..at]),
                        2 => memchr::memrchr2(bs[0], bs[1], &haystack[..at]),
                        3 => memchr::memrchr3(bs[0], bs[1], bs[2], &haystack[..at]),
                        0 => panic!("cannot find with empty needles"),
                        n => panic!("invalid needles length: {n}"),
                    }
                }

                #[derive( Clone )]
                pub struct Accels<A> { accels: A, }
                
                impl Accels<Vec<AccelTy>>
                {
                    pub fn empty() -> Accels<Vec<AccelTy>> { Accels { accels: vec![0] } }
                    
                    pub fn add( &mut self, accel: Accel) {
                        self.accels.extend_from_slice(&accel.as_accel_tys());
                        let len = self.len();
                        self.set_len(len + 1);
                    }
                    fn set_len( &mut self, new_len: usize) {
                        let new_len = AccelTy::try_from(new_len).unwrap();
                        self.accels[0] = new_len;
                    }
                }

                impl<'a> Accels<&'a [AccelTy]>
                {
                    pub fn from_bytes_unchecked(
                        mut slice: &'a [u8],
                    ) -> Result<(Accels<&'a [AccelTy]>, usize), DeserializeError>
                    {
                        let slice_start = slice.as_ptr().as_usize();

                        let (accel_len, _) =
                            wire::try_read_u32_as_usize(slice, "accelerators length")?;

                        let accel_tys_len = wire::add(
                            wire::mul(accel_len, 2, "total number of accelerator accel_tys")?,
                            1,
                            "total number of accel_tys",
                        )?;
                        let accel_tys_bytes_len = wire::mul(
                            ACCEL_TY_SIZE,
                            accel_tys_len,
                            "total number of bytes in accelerators",
                        )?;
                        wire::check_slice_len(slice, accel_tys_bytes_len, "accelerators")?;
                        wire::check_alignment::<AccelTy>(slice)?;
                        let accel_tys = &slice[..accel_tys_bytes_len];
                        slice = &slice[accel_tys_bytes_len..];
                        
                        let accels = unsafe {
                            ::slice::from_raw_parts(
                                accel_tys.as_ptr().cast::<AccelTy>(),
                                accel_tys_len,
                            )
                        };
                        Ok((Accels { accels }, slice.as_ptr().as_usize() - slice_start))
                    }
                }

                impl<A: AsRef<[AccelTy]>> Accels<A>
                {
                    pub fn to_owned( &self ) -> Accels<alloc::vec::Vec<AccelTy>> { Accels { accels: self.accels.as_ref().to_vec() } }

                    pub fn as_ref( &self ) -> Accels<&[AccelTy]> { Accels { accels: self.accels.as_ref() } }

                    pub fn as_bytes( &self ) -> &[u8] {
                        let accels = self.accels.as_ref();
                        unsafe {
                            ::slice::from_raw_parts(
                                accels.as_ptr().cast::<u8>(),
                                accels.len() * ACCEL_TY_SIZE,
                            )
                        }
                    }
                    
                    pub fn memory_usage( &self ) -> usize { self.as_bytes().len() }
                    #[inline( always )]
                    pub fn needles(&self, i: usize) -> &[u8] {
                        if i >= self.len() {
                            panic!("invalid accelerator index {i}");
                        }
                        let bytes = self.as_bytes();
                        let offset = ACCEL_TY_SIZE + i * ACCEL_CAP;
                        let len = usize::from(bytes[offset]);
                        &bytes[offset + 1..offset + 1 + len]
                    }

                    pub fn len( &self ) -> usize { usize::try_from( self.accels.as_ref()[0]).unwrap() }
                    fn get(&self, i: usize) -> Option<Accel> {
                        if i >= self.len() {
                            return None;
                        }
                        let offset = ACCEL_TY_SIZE + i * ACCEL_CAP;
                        let accel = Accel::from_slice(&self.as_bytes()[offset..])
                            .expect("Accels must contain valid accelerators");
                        Some(accel)
                    }

                    fn iter( &self ) -> IterAccels<'_, A> { IterAccels { accels: self, i: 0 } }
                    
                    pub fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        assert_eq!(
                            nwrite % ACCEL_TY_SIZE,
                            0,
                            "expected accelerator bytes written to be a multiple \
                            of {ACCEL_TY_SIZE}",
                        );
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("accelerators"));
                        }

                        // The number of accelerators can never exceed AccelTy::MAX.
                        E::write_u32(AccelTy::try_from( self.len()).unwrap(), dst);
                        dst[ACCEL_TY_SIZE..nwrite]
                            .copy_from_slice(&self.as_bytes()[ACCEL_TY_SIZE..nwrite]);
                        Ok(nwrite)
                    }
                    
                    pub fn validate( &self ) -> Result<(), DeserializeError> {
                        for chunk in self.as_bytes()[ACCEL_TY_SIZE..].chunks(ACCEL_CAP) {
                            let _ = Accel::from_slice(chunk)?;
                        }
                        Ok( () )
                    }

                    pub fn write_to_len( &self ) -> usize { self.as_bytes().len() }
                }

                impl<A: AsRef<[AccelTy]>> ::fmt::Debug for Accels<A>
               
               
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result
                    {
                        write!(f, "Accels(")?;
                        let mut list = f.debug_list();
                        for a in self.iter() {
                            list.entry(&a);
                        }
                        list.finish()?;
                        write!(f, ")")
                    }
                }

                #[derive( Debug )]
                struct IterAccels<'a, A: AsRef<[AccelTy]>> {
                    accels: &'a Accels<A>,
                    i: usize,
                }

                impl<'a, A: AsRef<[AccelTy]>> Iterator for IterAccels<'a, A> {
                    type Item = Accel;

                    fn next(&mut self) -> Option<Accel>
                    {
                        let accel = self.accels.get( self.i)?;
                        self.i += 1;
                        Some(accel)
                    }
                }
                
                #[derive( Clone )]
                pub struct Accel {

                    bytes: [u8; ACCEL_CAP],
                }

                impl Accel {

                        pub fn new() -> Accel {
                        Accel { bytes: [0; ACCEL_CAP] }
                    }
                    
                    pub fn from_slice(mut slice: &[u8]) -> Result<Accel, DeserializeError> {
                        slice = &slice[..core::cmp::min(ACCEL_LEN, slice.len())];
                        let bytes = slice
                            .try_into()
                            .map_err(|_| DeserializeError::buffer_too_small("accelerator"))?;
                        Accel::from_bytes(bytes)
                    }

                    fn from_bytes(bytes: [u8; 4]) -> Result<Accel, DeserializeError> {
                        if usize::from(bytes[0]) >= ACCEL_LEN {
                            return Err(DeserializeError::generic(
                                "accelerator bytes cannot have length more than 3",
                            ));
                        }
                        Ok(Accel::from_bytes_unchecked(bytes))
                    }

                    fn from_bytes_unchecked(bytes: [u8; 4]) -> Accel {
                        Accel { bytes: [bytes[0], bytes[1], bytes[2], bytes[3], 0, 0, 0, 0] }
                    }
                        pub fn add( &mut self, byte: u8) -> bool {
                        if self.len() >= 3 {
                            return false;
                        }

                        if byte == b' ' {
                            return false;
                        }
                        assert!(
                            !self.contains( byte ),
                            "accelerator already contains {:?}",
                            crate::util::escape::DebugByte( byte )
                        );
                        self.bytes[self.len() + 1] = byte;
                        self.bytes[0] += 1;
                        true
                    }

                    pub fn len( &self ) -> usize { usize::from( self.bytes[0]) }

                        pub fn is_empty( &self ) -> bool { self.len() == 0 }

                    fn needles( &self ) -> &[u8] { &self.bytes[1..1 + self.len()] }
                        fn contains(&self, byte: u8) -> bool {
                        self.needles().iter().position(|&b| b == byte).is_some()
                    }

                        fn as_accel_tys( &self ) -> [AccelTy; 2] {
                        assert_eq!(ACCEL_CAP, 8);
                        
                        let first =
                            AccelTy::from_ne_bytes( self.bytes[0..4].try_into().unwrap());
                        let second =
                            AccelTy::from_ne_bytes( self.bytes[4..8].try_into().unwrap());
                        [first, second]
                    }
                }

                impl ::fmt::Debug for Accel
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result
                    {
                        write!(f, "Accel(")?;
                        let mut set = f.debug_set();
                        for &b in self.needles() {
                            set.entry(&crate::util::escape::DebugByte(b));
                        }
                        set.finish()?;
                        write!(f, ")")
                    }
                }
            }

            pub mod automaton
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use crate::util::search::PatternSet;
                use crate::{
                    dfa::search,
                    util::{
                        empty,
                        prefilter::Prefilter,
                        primitives::{PatternID, StateID},
                        search::{Anchored, HalfMatch, Input, MatchError},
                        start,
                    },
                };
                */

                pub unsafe trait Automaton
                {
                    fn next_state(&self, current: StateID, input: u8) -> StateID;
                    unsafe fn next_state_unchecked(
                        &self,
                        current: StateID,
                        input: u8,
                    ) -> StateID;
                    fn next_eoi_state(&self, current: StateID) -> StateID;
                    fn start_state(
                        &self,
                        config: &start::Config,
                    ) -> Result<StateID, StartError>;
                    fn start_state_forward(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<StateID, MatchError>
                    {
                        let config = start::Config::from_input_forward(input);
                        self.start_state(&config).map_err(|err| match err {
                            StartError::Quit { byte } => {
                                let offset = input
                                    .start()
                                    .checked_sub(1)
                                    .expect("no quit in start without look-behind");
                                MatchError::quit(byte, offset)
                            }
                            StartError::UnsupportedAnchored { mode } => { MatchError::unsupported_anchored(mode) }
                        })
                    }
                    fn start_state_reverse(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<StateID, MatchError>
                    {
                        let config = start::Config::from_input_reverse(input);
                        self.start_state(&config).map_err(|err| match err {
                            StartError::Quit { byte } => {
                                let offset = input.end();
                                MatchError::quit(byte, offset)
                            }
                            StartError::UnsupportedAnchored { mode } => { MatchError::unsupported_anchored(mode) }
                        })
                    }
                    #[inline] fn universal_start_state(&self, _mode: Anchored) -> Option<StateID> { None }
                    fn is_special_state(&self, id: StateID) -> bool;
                    fn is_dead_state(&self, id: StateID) -> bool;
                    fn is_quit_state(&self, id: StateID) -> bool;
                    fn is_match_state(&self, id: StateID) -> bool;
                    ///
                    fn is_start_state(&self, id: StateID) -> bool;
                    fn is_accel_state(&self, id: StateID) -> bool;

                    ///
                    ///
                    ///

                    ///
                    ///
                    fn pattern_len( &self ) -> usize;

                    fn match_len(&self, id: StateID) -> usize;
                    fn match_pattern(&self, id: StateID, index: usize) -> PatternID;
                    fn has_empty( &self ) -> bool;

                    ///
                    ///
                    ///
                    ///
                    fn is_utf8( &self ) -> bool;
                    fn is_always_start_anchored( &self ) -> bool;
                    #[inline] fn accelerator(&self, _id: StateID) -> &[u8] {
                        &[]
                    }
                    #[inline] fn get_prefilter( &self ) -> Option<&Prefilter> { None }
                    #[inline] fn try_search_fwd(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError>
                    {
                        let utf8empty = self.has_empty() && self.is_utf8();
                        let hm = match search::find_fwd(&self, input)? {
                            None => return Ok( None ),
                            Some(hm) if !utf8empty => return Ok(Some(hm)),
                            Some(hm) => hm,
                        };
                        
                        empty::skip_splits_fwd(input, hm, hm.offset(), |input| {
                            let got = search::find_fwd(&self, input)?;
                            Ok(got.map(|hm| (hm, hm.offset())))
                        })
                    }
                    #[inline] fn try_search_rev(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError>
                    {
                        let utf8empty = self.has_empty() && self.is_utf8();
                        let hm = match search::find_rev(self, input)? {
                            None => return Ok( None ),
                            Some(hm) if !utf8empty => return Ok(Some(hm)),
                            Some(hm) => hm,
                        };
                        empty::skip_splits_rev(input, hm, hm.offset(), |input| {
                            let got = search::find_rev(self, input)?;
                            Ok(got.map(|hm| (hm, hm.offset())))
                        })
                    }
                    #[inline] fn try_search_overlapping_fwd(
                        &self,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError>
                    {
                        let utf8empty = self.has_empty() && self.is_utf8();
                        search::find_overlapping_fwd(self, input, state)?;
                        match state.get_match() {
                            None => Ok( () ),
                            Some(_) if !utf8empty => Ok( () ),
                            Some(_) => skip_empty_utf8_splits_overlapping(
                                input,
                                state,
                                |input, state| {
                                    search::find_overlapping_fwd(self, input, state)
                                },
                            ),
                        }
                    }

                    #[inline] fn try_search_overlapping_rev(
                        &self,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError>
                    {
                        let utf8empty = self.has_empty() && self.is_utf8();
                        search::find_overlapping_rev(self, input, state)?;
                        match state.get_match() {
                            None => Ok( () ),
                            Some(_) if !utf8empty => Ok( () ),
                            Some(_) => skip_empty_utf8_splits_overlapping(
                                input,
                                state,
                                |input, state| {
                                    search::find_overlapping_rev(self, input, state)
                                },
                            ),
                        }
                    }
                    #[inline] fn try_which_overlapping_matches(
                        &self,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), MatchError>
                    {
                        let mut state = OverlappingState::start();
                        while let Some(m) = {
                            self.try_search_overlapping_fwd(input, &mut state)?;
                            state.get_match()
                        } {
                            let _ = patset.insert(m.pattern());
                            if patset.is_full() || input.get_earliest() {
                                break;
                            }
                        }
                        Ok( () )
                    }
                }

                unsafe impl<'a, A: Automaton + ?Sized> Automaton for &'a A {
                    #[inline] fn next_state(&self, current: StateID, input: u8) -> StateID {
                        (**self).next_state(current, input)
                    }

                    #[inline]
                    unsafe fn next_state_unchecked(
                        &self,
                        current: StateID,
                        input: u8,
                    ) -> StateID {
                        (**self).next_state_unchecked(current, input)
                    }

                    #[inline] fn next_eoi_state(&self, current: StateID) -> StateID {
                        (**self).next_eoi_state(current)
                    }

                    #[inline] fn start_state(
                        &self,
                        config: &start::Config,
                    ) -> Result<StateID, StartError> { (**self).start_state(config) }

                    #[inline] fn start_state_forward(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<StateID, MatchError> { (**self).start_state_forward(input) }

                    #[inline] fn start_state_reverse(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<StateID, MatchError> { (**self).start_state_reverse(input) }

                    #[inline] fn universal_start_state(&self, mode: Anchored) -> Option<StateID> { (**self).universal_start_state(mode) }

                    #[inline] fn is_special_state(&self, id: StateID) -> bool {
                        (**self).is_special_state(id)
                    }

                    #[inline] fn is_dead_state(&self, id: StateID) -> bool {
                        (**self).is_dead_state(id)
                    }

                    #[inline] fn is_quit_state(&self, id: StateID) -> bool {
                        (**self).is_quit_state(id)
                    }

                    #[inline] fn is_match_state(&self, id: StateID) -> bool {
                        (**self).is_match_state(id)
                    }

                    #[inline] fn is_start_state(&self, id: StateID) -> bool {
                        (**self).is_start_state(id)
                    }

                    #[inline] fn is_accel_state(&self, id: StateID) -> bool {
                        (**self).is_accel_state(id)
                    }

                    #[inline] fn pattern_len( &self ) -> usize { (**self).pattern_len() }

                    #[inline] fn match_len(&self, id: StateID) -> usize {
                        (**self).match_len(id)
                    }

                    #[inline] fn match_pattern(&self, id: StateID, index: usize) -> PatternID {
                        (**self).match_pattern(id, index)
                    }

                    #[inline] fn has_empty( &self ) -> bool { (**self).has_empty() }

                    #[inline] fn is_utf8( &self ) -> bool { (**self).is_utf8() }

                    #[inline] fn is_always_start_anchored( &self ) -> bool { (**self).is_always_start_anchored() }

                    #[inline] fn accelerator(&self, id: StateID) -> &[u8] {
                        (**self).accelerator(id)
                    }

                    #[inline] fn get_prefilter( &self ) -> Option<&Prefilter> { (**self).get_prefilter() }

                    #[inline] fn try_search_fwd(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError> { (**self).try_search_fwd(input) }

                    #[inline] fn try_search_rev(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError> { (**self).try_search_rev(input) }

                    #[inline] fn try_search_overlapping_fwd(
                        &self,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError> { (**self).try_search_overlapping_fwd(input, state) }

                    #[inline] fn try_search_overlapping_rev(
                        &self,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError> { (**self).try_search_overlapping_rev(input, state) }

                    #[inline] fn try_which_overlapping_matches(
                        &self,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), MatchError> { (**self).try_which_overlapping_matches(input, patset) }
                }

                #[derive( Clone, Debug, Eq, PartialEq )]
                pub struct OverlappingState {
                    pub mat:Option<HalfMatch>,
                    pub id:Option<StateID>,
                    pub at: usize,
                    pub next_match_index:Option<usize>,
                    pub rev_eoi: bool,
                }

                impl OverlappingState
                {
                    pub fn start() -> OverlappingState {
                        OverlappingState {
                            mat: None,
                            id: None,
                            at: 0,
                            next_match_index: None,
                            rev_eoi: false,
                        }
                    }
                    
                    pub fn get_match( &self ) -> Option<HalfMatch> { self.mat }
                }

                #[non_exhaustive] #[derive( Clone, Debug )]
                pub enum StartError {
                    Quit {

                        byte: u8,
                    },
                    UnsupportedAnchored {

                        mode: Anchored,
                    },
                }

                impl StartError
                {
                    pub fn quit(byte: u8) -> StartError {
                        StartError::Quit { byte }
                    }

                    pub fn unsupported_anchored(mode: Anchored) -> StartError {
                        StartError::UnsupportedAnchored { mode }
                    }
                }

                        impl ::error::Error for StartError {}

                impl ::fmt::Display for StartError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        match *self {
                            StartError::Quit { byte } => write!(
                                f,
                                "error computing start state because the look-behind byte \
                                {:?} triggered a quit state",
                                crate::util::escape::DebugByte( byte ),
                            ),
                            StartError::UnsupportedAnchored { mode: Anchored::Yes } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    anchored searches are not supported or enabled"
                                )
                            }
                            StartError::UnsupportedAnchored { mode: Anchored::No } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    unanchored searches are not supported or enabled"
                                )
                            }
                            StartError::UnsupportedAnchored {
                                mode: Anchored::Pattern(pid),
                            } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    anchored searches for a specific pattern ({}) \
                                    are not supported or enabled",
                                    pid.as_usize(),
                                )
                            }
                        }
                    }
                }

                #[cold] #[inline( never )] fn skip_empty_utf8_splits_overlapping<F>(
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                    mut search: F,
                ) -> Result<(), MatchError> where
                F: FnMut(&Input<'_>, &mut OverlappingState) -> Result<(), MatchError>,
                {
                    let mut hm = match state.get_match() {
                        None => return Ok( () ),
                        Some(hm) => hm,
                    };
                    if input.get_anchored().is_anchored() {
                        if !input.is_char_boundary(hm.offset()) {
                            state.mat = None;
                        }
                        return Ok( () );
                    }
                    while !input.is_char_boundary(hm.offset()) {
                        search(input, state)?;
                        hm = match state.get_match() {
                            None => return Ok( () ),
                            Some(hm) => hm,
                        };
                    }
                    Ok( () )
                }

                pub fn fmt_state_indicator<A: Automaton>(
                    f: &mut ::fmt::Formatter<'_>,
                    dfa: A,
                    id: StateID,
                ) -> ::fmt::Result {
                    if dfa.is_dead_state(id) {
                        write!(f, "D")?;
                        if dfa.is_start_state(id) {
                            write!(f, ">")?;
                        } else {
                            write!(f, " ")?;
                        }
                    } else if dfa.is_quit_state(id) {
                        write!(f, "Q ")?;
                    } else if dfa.is_start_state(id) {
                        if dfa.is_accel_state(id) {
                            write!(f, "A>")?;
                        } else {
                            write!(f, " >")?;
                        }
                    } else if dfa.is_match_state(id) {
                        if dfa.is_accel_state(id) {
                            write!(f, "A*")?;
                        } else {
                            write!(f, " *")?;
                        }
                    } else if dfa.is_accel_state(id) {
                        write!(f, "A ")?;
                    } else {
                        write!(f, "  ")?;
                    }
                    Ok( () )
                }
            } pub use self::automaton::{ Automaton, OverlappingState, StartError };

            pub mod determinize
            {
                /*!
                */
                use ::
                {
                    collections::{ BTreeMap },
                    regex::
                    {

                    },
                    *,
                };
                /*
                use alloc::{collections::BTreeMap, vec::Vec};

                use crate::{
                    dfa::{
                        dense::{self, BuildError},
                        DEAD,
                    },
                    nfa::thompson,
                    util::{
                        self,
                        alphabet::{self, ByteSet},
                        determinize::{State, StateBuilderEmpty, StateBuilderNFA},
                        primitives::{PatternID, StateID},
                        search::{Anchored, MatchKind},
                        sparse_set::SparseSets,
                        start::Start,
                    },
                };
                */

                #[derive( Clone, Debug )]
                pub struct Config {
                    match_kind: MatchKind,
                    quit: ByteSet,
                    dfa_size_limit:Option<usize>,
                    determinize_size_limit:Option<usize>,
                }

                impl Config
                {
                    pub fn new() -> Config {
                        Config {
                            match_kind: MatchKind::LeftmostFirst,
                            quit: ByteSet::empty(),
                            dfa_size_limit: None,
                            determinize_size_limit: None,
                        }
                    }

                    pub fn run(
                        &self,
                        nfa: &thompson::NFA,
                        dfa: &mut dense::OwnedDFA,
                    ) -> Result<(), BuildError>
                    {
                        let dead = State::dead();
                        let quit = State::dead();
                        let mut cache = StateMap::default();
                        cache.insert(dead.clone(), DEAD);

                        let runner = Runner {
                            config: self.clone(),
                            nfa,
                            dfa,
                            builder_states:vec![dead, quit],
                            cache,
                            memory_usage_state: 0,
                            sparses: SparseSets::new(nfa.states().len()),
                            stack:vec![],
                            scratch_state_builder: StateBuilderEmpty::new(),
                        };
                        runner.run()
                    }

                    pub fn match_kind( &mut self, kind: MatchKind) -> &mut Config {
                        self.match_kind = kind;
                        self
                    }

                    pub fn quit( &mut self, set: ByteSet) -> &mut Config {
                        self.quit = set;
                        self
                    }

                    pub fn dfa_size_limit( &mut self, bytes:Option<usize>) -> &mut Config {
                        self.dfa_size_limit = bytes;
                        self
                    }

                    pub fn determinize_size_limit(
                        &mut self,
                        bytes:Option<usize>,
                    ) -> &mut Config {
                        self.determinize_size_limit = bytes;
                        self
                    }
                }

                #[derive( Debug )]
                struct Runner<'a> {

                    config: Config,
                    nfa: &'a thompson::NFA,
                    dfa: &'a mut dense::OwnedDFA,
                    builder_states: Vec<State>,
                    cache: StateMap,
                    memory_usage_state: usize,
                    sparses: SparseSets,
                    stack: Vec<StateID>,
                    scratch_state_builder: StateBuilderEmpty,
                }

                type StateMap = std::collections::HashMap<State, StateID>;

                impl<'a> Runner<'a> {

                    fn run(mut self) -> Result<(), BuildError>
                    {
                        if self.nfa.look_set_any().contains_word_unicode()
                        && !self.config.quit.contains_range(0x80, 0xFF)
                        { return Err(BuildError::unsupported_dfa_word_boundary_unicode()); }
                        
                        let representatives: Vec<alphabet::Unit> = self.dfa.byte_classes().representatives(..).collect();
                        let mut uncompiled = vec![];
                        self.add_all_starts(&mut uncompiled)?;
                        while let Some(dfa_id) = uncompiled.pop() 
                        {
                            for &unit in &representatives
                            {
                                if unit.as_u8().map_or(false, |b| self.config.quit.contains(b)) { continue; }
                                
                                let (next_dfa_id, is_new) = self.cached_state(dfa_id, unit)?;
                                self.dfa.set_transition(dfa_id, unit, next_dfa_id);
                                
                                if is_new { uncompiled.push(next_dfa_id); }
                            }
                        }
                        
                        let mut matches: BTreeMap<StateID, Vec<PatternID>> = BTreeMap::new();
                        self.cache.clear();
                        
                        let mut total_pat_len = 0;
                        for (i, state) in self.builder_states.into_iter().enumerate()
                        {
                            if let Some(pat_ids) = state.match_pattern_ids()
                            {
                                let id = self.dfa.to_state_id(i);
                                matches.insert(id, pat_ids);
                            }
                        }
                        self.dfa.shuffle(matches)?;
                        Ok( () )
                    }

                    fn cached_state(
                        &mut self,
                        dfa_id: StateID,
                        unit: alphabet::Unit,
                    ) -> Result<(StateID, bool), BuildError>
                    {
                        let empty_builder = self.get_state_builder();
                        let builder = util::determinize::next(
                            self.nfa,
                            self.config.match_kind,
                            &mut self.sparses,
                            &mut self.stack,
                            &self.builder_states[self.dfa.to_index(dfa_id)],
                            unit,
                            empty_builder,
                        );
                        self.maybe_add_state(builder)
                    }

                    fn add_all_starts(
                        &mut self,
                        dfa_state_ids: &mut Vec<StateID>,
                    ) -> Result<(), BuildError>
                    {
                        assert!(dfa_state_ids.is_empty());
                        if self.dfa.start_kind().has_unanchored() {
                            self.add_start_group(Anchored::No, dfa_state_ids)?;
                        }
                        if self.dfa.start_kind().has_anchored() {
                            self.add_start_group(Anchored::Yes, dfa_state_ids)?;
                        }
                        
                        if self.dfa.starts_for_each_pattern() {
                            for pid in self.nfa.patterns() {
                                self.add_start_group(Anchored::Pattern(pid), dfa_state_ids)?;
                            }
                        }
                        Ok( () )
                    }

                    fn add_start_group(
                        &mut self,
                        anchored: Anchored,
                        dfa_state_ids: &mut Vec<StateID>,
                    ) -> Result<(), BuildError>
                    {
                        let nfa_start = match anchored {
                            Anchored::No => self.nfa.start_unanchored(),
                            Anchored::Yes => self.nfa.start_anchored(),
                            Anchored::Pattern(pid) => { self.nfa.start_pattern(pid).expect("valid pattern ID") }
                        };
                        
                        let (id, is_new) =
                            self.add_one_start(nfa_start, Start::NonWordByte)?;
                        self.dfa.set_start_state(anchored, Start::NonWordByte, id);
                        if is_new {
                            dfa_state_ids.push(id);
                        }

                        if !self.nfa.look_set_prefix_any().contains_word() {
                            self.dfa.set_start_state(anchored, Start::WordByte, id);
                        } else {
                            let (id, is_new) =
                                self.add_one_start(nfa_start, Start::WordByte)?;
                            self.dfa.set_start_state(anchored, Start::WordByte, id);
                            if is_new {
                                dfa_state_ids.push(id);
                            }
                        }
                        if !self.nfa.look_set_prefix_any().contains_anchor() {
                            self.dfa.set_start_state(anchored, Start::Text, id);
                            self.dfa.set_start_state(anchored, Start::LineLF, id);
                            self.dfa.set_start_state(anchored, Start::LineCR, id);
                            self.dfa.set_start_state(
                                anchored,
                                Start::CustomLineTerminator,
                                id,
                            );
                        } else {
                            let (id, is_new) = self.add_one_start(nfa_start, Start::Text)?;
                            self.dfa.set_start_state(anchored, Start::Text, id);
                            if is_new {
                                dfa_state_ids.push(id);
                            }

                            let (id, is_new) = self.add_one_start(nfa_start, Start::LineLF)?;
                            self.dfa.set_start_state(anchored, Start::LineLF, id);
                            if is_new {
                                dfa_state_ids.push(id);
                            }

                            let (id, is_new) = self.add_one_start(nfa_start, Start::LineCR)?;
                            self.dfa.set_start_state(anchored, Start::LineCR, id);
                            if is_new {
                                dfa_state_ids.push(id);
                            }

                            let (id, is_new) =
                                self.add_one_start(nfa_start, Start::CustomLineTerminator)?;
                            self.dfa.set_start_state(
                                anchored,
                                Start::CustomLineTerminator,
                                id,
                            );
                            if is_new {
                                dfa_state_ids.push(id);
                            }
                        }

                        Ok( () )
                    }

                    fn add_one_start(
                        &mut self,
                        nfa_start: StateID,
                        start: Start,
                    ) -> Result<(StateID, bool), BuildError>
                    {
                        let mut builder_matches = self.get_state_builder().into_matches();
                        util::determinize::set_lookbehind_from_start(
                            self.nfa,
                            &start,
                            &mut builder_matches,
                        );
                        self.sparses.set1.clear();
                        util::determinize::epsilon_closure(
                            self.nfa,
                            nfa_start,
                            builder_matches.look_have(),
                            &mut self.stack,
                            &mut self.sparses.set1,
                        );
                        let mut builder = builder_matches.into_nfa();
                        util::determinize::add_nfa_states(
                            &self.nfa,
                            &self.sparses.set1,
                            &mut builder,
                        );
                        self.maybe_add_state(builder)
                    }

                    fn maybe_add_state(
                        &mut self,
                        builder: StateBuilderNFA,
                    ) -> Result<(StateID, bool), BuildError> {
                        if let Some(&cached_id) = self.cache.get(builder.as_bytes()) {
                            self.put_state_builder(builder);
                            return Ok((cached_id, false));
                        }
                        self.add_state(builder).map(|sid| (sid, true))
                    }

                    fn add_state(
                        &mut self,
                        builder: StateBuilderNFA,
                    ) -> Result<StateID, BuildError>
                    {
                        let id = self.dfa.add_empty_state()?;
                        if !self.config.quit.is_empty() {
                            for b in self.config.quit.iter() {
                                self.dfa.set_transition(
                                    id,
                                    alphabet::Unit::u8(b),
                                    self.dfa.quit_id(),
                                );
                            }
                        }
                        let state = builder.to_state();
                        self.memory_usage_state += state.memory_usage();
                        self.builder_states.push(state.clone());
                        self.cache.insert(state, id);
                        self.put_state_builder(builder);
                        if let Some(limit) = self.config.dfa_size_limit {
                            if self.dfa.memory_usage() > limit {
                                return Err(BuildError::dfa_exceeded_size_limit(limit));
                            }
                        }
                        if let Some(limit) = self.config.determinize_size_limit {
                            if self.memory_usage() > limit {
                                return Err(BuildError::determinize_exceeded_size_limit(
                                    limit,
                                ));
                            }
                        }
                        Ok(id)
                    }

                    fn get_state_builder(&mut self) -> StateBuilderEmpty {
                        ::mem::replace(
                            &mut self.scratch_state_builder,
                            StateBuilderEmpty::new(),
                        )
                    }

                    fn put_state_builder( &mut self, builder: StateBuilderNFA) {
                        let _ = ::mem::replace(
                            &mut self.scratch_state_builder,
                            builder.clear(),
                        );
                    }

                    fn memory_usage( &self ) -> usize 
                    {
                        use ::mem::size_of;

                        self.builder_states.len() * size_of::<State>()
                        + self.cache.len() * (size_of::<State>() + size_of::<StateID>())
                        + self.memory_usage_state
                        + self.stack.capacity() * size_of::<StateID>()
                        + self.scratch_state_builder.capacity()
                    }
                }
            }

            pub mod minimize
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use ::{cell::RefCell, fmt, mem};

                use alloc::{collections::BTreeMap, rc::Rc, vec, vec::Vec};

                use crate::{
                    dfa::{automaton::Automaton, dense, DEAD},
                    util::{
                        alphabet,
                        primitives::{PatternID, StateID},
                    },
                };
                */

                pub struct Minimizer<'a> {
                    dfa: &'a mut dense::OwnedDFA,
                    in_transitions: Vec<Vec<Vec<StateID>>>,
                    partitions: Vec<StateSet>,
                    waiting: Vec<StateSet>,
                }

                impl<'a> fmt::Debug for Minimizer<'a>
               
               
                {
                    fn fmt( &self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        f.debug_struct("Minimizer")
                            .field("dfa", &self.dfa)
                            .field("in_transitions", &self.in_transitions)
                            .field("partitions", &self.partitions)
                            .field("waiting", &self.waiting)
                            .finish()
                    }
                }
                
                #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]
                struct StateSet {
                    ids: Rc<RefCell<Vec<StateID>>>,
                }

                impl<'a> Minimizer<'a>
                {
                    pub fn new(dfa: &'a mut dense::OwnedDFA) -> Minimizer<'a>
                    {
                        let in_transitions = Minimizer::incoming_transitions(dfa);
                        let partitions = Minimizer::initial_partitions(dfa);
                        let waiting = partitions.clone();
                        Minimizer { dfa, in_transitions, partitions, waiting }
                    }

                    pub fn run(mut self) {
                        let stride2 = self.dfa.stride2();
                        let as_state_id = |index: usize| -> StateID {
                            StateID::new(index << stride2).unwrap()
                        };
                        let as_index = |id: StateID| -> usize { id.as_usize() >> stride2 };

                        let mut incoming = StateSet::empty();
                        let mut scratch1 = StateSet::empty();
                        let mut scratch2 = StateSet::empty();
                        let mut newparts = vec![];
                        while let Some(set) = self.waiting.pop() {
                            for b in self.dfa.byte_classes().iter() {
                                self.find_incoming_to(b, &set, &mut incoming);
                                //
                                if incoming.is_empty(){ continue; }

                                for p in 0..self.partitions.len() {
                                    self.partitions[p].intersection(&incoming, &mut scratch1);
                                    if scratch1.is_empty() {
                                        newparts.push( self.partitions[p].clone());
                                        continue;
                                    }

                                    self.partitions[p].subtract(&incoming, &mut scratch2);
                                    if scratch2.is_empty() {
                                        newparts.push( self.partitions[p].clone());
                                        continue;
                                    }

                                    let (x, y) =
                                        (scratch1.deep_clone(), scratch2.deep_clone());
                                    newparts.push(x.clone());
                                    newparts.push(y.clone());
                                    match self.find_waiting(&self.partitions[p]) {
                                        Some(i) => {
                                            self.waiting[i] = x;
                                            self.waiting.push(y);
                                        }
                                        None => {
                                            if x.len() <= y.len() {
                                                self.waiting.push(x);
                                            } else {
                                                self.waiting.push(y);
                                            }
                                        }
                                    }
                                }
                                newparts = mem::replace(&mut self.partitions, newparts);
                                newparts.clear();
                            }
                        }
                        // equivalence class of states is the minimum ID in that class.
                        let mut state_to_part = vec![DEAD; self.dfa.state_len()];
                        for p in &self.partitions {
                            p.iter(|id| state_to_part[as_index(id)] = p.min());
                        }
                        let mut minimal_ids = vec![DEAD; self.dfa.state_len()];
                        let mut new_index = 0;
                        for state in self.dfa.states() {
                            if state_to_part[as_index(state.id())] == state.id() {
                                minimal_ids[as_index(state.id())] = as_state_id(new_index);
                                new_index += 1;
                            }
                        }
                        // The total number of states in the minimal DFA.
                        let minimal_count = new_index;
                        
                        let remap = |old| minimal_ids[as_index(state_to_part[as_index(old)])];
                        for id in (0..self.dfa.state_len()).map(as_state_id) {
                            if state_to_part[as_index(id)] != id {
                                continue;
                            }
                            self.dfa.remap_state(id, remap);
                            self.dfa.swap_states(id, minimal_ids[as_index(id)]);
                        }
                        // equivalence class is its representative ID.)
                        self.dfa.truncate_states(minimal_count);
                        
                        let starts: Vec<_> = self.dfa.starts().collect();
                        for (old_start_id, anchored, start_type) in starts {
                            self.dfa.set_start_state(
                                anchored,
                                start_type,
                                remap(old_start_id),
                            );
                        }
                        let mut pmap = BTreeMap::new();
                        for (match_id, pattern_ids) in self.dfa.pattern_map() {
                            let new_id = remap(match_id);
                            pmap.insert(new_id, pattern_ids);
                        }
                        self.dfa.set_pattern_map(&pmap).unwrap();
                        
                        let old = self.dfa.special().clone();
                        let new = self.dfa.special_mut();
                        
                        if old.matches() {
                            new.min_match = StateID::MAX;
                            new.max_match = StateID::ZERO;
                            for i in as_index(old.min_match)..=as_index(old.max_match) {
                                let new_id = remap(as_state_id(i));
                                if new_id < new.min_match {
                                    new.min_match = new_id;
                                }
                                if new_id > new.max_match {
                                    new.max_match = new_id;
                                }
                            }
                        }

                        if old.starts() {
                            new.min_start = StateID::MAX;
                            new.max_start = StateID::ZERO;
                            for i in as_index(old.min_start)..=as_index(old.max_start) {
                                let new_id = remap(as_state_id(i));
                                if new_id == DEAD{ continue; }
                                if new_id < new.min_start {
                                    new.min_start = new_id;
                                }
                                if new_id > new.max_start {
                                    new.max_start = new_id;
                                }
                            }
                            if new.max_start == DEAD {
                                new.min_start = DEAD;
                            }
                        }
                        new.quit_id = remap(new.quit_id);
                        new.set_max();
                    }

                    fn find_waiting(&self, set: &StateSet) -> Option<usize> { self.waiting.iter().position(|s| s == set) }

                    fn find_incoming_to(
                        &self,
                        b: alphabet::Unit,
                        set: &StateSet,
                        incoming: &mut StateSet,
                    ) {
                        incoming.clear();
                        set.iter(|id| {
                            for &inid in
                                &self.in_transitions[self.dfa.to_index(id)][b.as_usize()]
                            {
                                incoming.add(inid);
                            }
                        });
                        incoming.canonicalize();
                    }

                    fn initial_partitions(dfa: &dense::OwnedDFA) -> Vec<StateSet> {
                        // initially based on that.
                        let mut matching: BTreeMap<Vec<PatternID>, StateSet> = BTreeMap::new();
                        let mut is_quit = StateSet::empty();
                        let mut no_match = StateSet::empty();
                        for state in dfa.states() {
                            if dfa.is_match_state(state.id()) {
                                let mut pids = vec![];
                                for i in 0..dfa.match_len(state.id()) {
                                    pids.push(dfa.match_pattern(state.id(), i));
                                }
                                matching
                                    .entry(pids)
                                    .or_insert(StateSet::empty())
                                    .add(state.id());
                            } else if dfa.is_quit_state(state.id()) {
                                is_quit.add(state.id());
                            } else {
                                no_match.add(state.id());
                            }
                        }

                        let mut sets: Vec<StateSet> =
                            matching.into_iter().map(|(_, set)| set).collect();
                        sets.push(no_match);
                        sets.push(is_quit);
                        sets
                    }

                    fn incoming_transitions(dfa: &dense::OwnedDFA) -> Vec<Vec<Vec<StateID>>>
                    {
                        let mut incoming = vec![];
                        for _ in dfa.states() {
                            incoming.push(vec![vec![]; dfa.alphabet_len()]);
                        }
                        for state in dfa.states() {
                            for (b, next) in state.transitions() {
                                incoming[dfa.to_index(next)][b.as_usize()].push(state.id());
                            }
                        }
                        incoming
                    }
                }

                impl StateSet
                {
                    fn empty() -> StateSet {
                        StateSet { ids: Rc::new(RefCell::new(vec![])) }
                    }

                    fn add( &mut self, id: StateID) {
                        self.ids.borrow_mut().push(id);
                    }

                    fn min( &self ) -> StateID { self.ids.borrow()[0] }

                    fn canonicalize(&mut self) {
                        self.ids.borrow_mut().sort();
                        self.ids.borrow_mut().dedup();
                    }

                    fn clear(&mut self) {
                        self.ids.borrow_mut().clear();
                    }

                    fn len( &self ) -> usize { self.ids.borrow().len() }

                    fn is_empty( &self ) -> bool { self.len() == 0 }

                    fn deep_clone( &self ) -> StateSet {
                        let ids = self.ids.borrow().iter().cloned().collect();
                        StateSet { ids: Rc::new(RefCell::new(ids)) }
                    }

                    fn iter<F: FnMut(StateID)>(&self, mut f: F) {
                        for &id in self.ids.borrow().iter() {
                            f(id);
                        }
                    }

                    fn intersection(&self, other: &StateSet, dest: &mut StateSet) {
                        dest.clear();
                        if self.is_empty() || other.is_empty() { return; }

                        let (seta, setb) = ( self.ids.borrow(), other.ids.borrow());
                        let (mut ita, mut itb) = (seta.iter().cloned(), setb.iter().cloned());
                        let (mut a, mut b) = (ita.next().unwrap(), itb.next().unwrap());
                        loop {
                            if a == b {
                                dest.add(a);
                                a = match ita.next() {
                                    None => break,
                                    Some(a) => a,
                                };
                                b = match itb.next() {
                                    None => break,
                                    Some(b) => b,
                                };
                            } else if a < b {
                                a = match ita.next() {
                                    None => break,
                                    Some(a) => a,
                                };
                            } else {
                                b = match itb.next() {
                                    None => break,
                                    Some(b) => b,
                                };
                            }
                        }
                    }

                    fn subtract(&self, other: &StateSet, dest: &mut StateSet) {
                        dest.clear();
                        if self.is_empty() || other.is_empty() {
                            self.iter(|s| dest.add(s));
                            return;
                        }

                        let (seta, setb) = ( self.ids.borrow(), other.ids.borrow());
                        let (mut ita, mut itb) = (seta.iter().cloned(), setb.iter().cloned());
                        let (mut a, mut b) = (ita.next().unwrap(), itb.next().unwrap());
                        loop {
                            if a == b {
                                a = match ita.next() {
                                    None => break,
                                    Some(a) => a,
                                };
                                b = match itb.next() {
                                    None => {
                                        dest.add(a);
                                        break;
                                    }
                                    Some(b) => b,
                                };
                            } else if a < b {
                                dest.add(a);
                                a = match ita.next() {
                                    None => break,
                                    Some(a) => a,
                                };
                            } else {
                                b = match itb.next() {
                                    None => {
                                        dest.add(a);
                                        break;
                                    }
                                    Some(b) => b,
                                };
                            }
                        }
                        for a in ita {
                            dest.add(a);
                        }
                    }
                }
            }

            pub mod remapper
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use alloc::vec::Vec;
                use crate::util::primitives::StateID;
                */
                pub(super) trait Remappable: ::fmt::Debug {

                    fn state_len( &self ) -> usize;

                    fn stride2( &self ) -> usize;

                    fn swap_states( &mut self, id1: StateID, id2: StateID);
                    fn remap( &mut self, map: impl Fn(StateID) -> StateID);
                }
                
                #[derive( Debug )]
                pub(super) struct Remapper {

                    map: Vec<StateID>,
                    idxmap: IndexMapper,
                }

                impl Remapper {

                    pub(super) fn new(r: &impl Remappable) -> Remapper {
                        let idxmap = IndexMapper { stride2: r.stride2() };
                        let map = (0..r.state_len()).map(|i| idxmap.to_state_id(i)).collect();
                        Remapper { map, idxmap }
                    }

                    pub(super) fn swap(
                        &mut self,
                        r: &mut impl Remappable,
                        id1: StateID,
                        id2: StateID,
                    ) {
                        if id1 == id2 { return; }
                        r.swap_states(id1, id2);
                        self.map.swap( self.idxmap.to_index(id1), self.idxmap.to_index(id2));
                    }
                    pub(super) fn remap( mut self, r: &mut impl Remappable) {
                        let oldmap = self.map.clone();
                        for i in 0..r.state_len() {
                            let cur_id = self.idxmap.to_state_id(i);
                            let mut new_id = oldmap[i];
                            if cur_id == new_id {
                                continue;
                            }
                            loop {
                                let id = oldmap[self.idxmap.to_index(new_id)];
                                if cur_id == id {
                                    self.map[i] = new_id;
                                    break;
                                }
                                new_id = id;
                            }
                        }
                        r.remap(|next| self.map[self.idxmap.to_index(next)]);
                    }
                }
                
                #[derive( Debug )]
                struct IndexMapper 
                {
                    stride2: usize,
                }

                impl IndexMapper
                {
                    fn to_index(&self, id: StateID) -> usize { id.as_usize() >> self.stride2 }
                    fn to_state_id(&self, index: usize) -> StateID { StateID::new_unchecked(index << self.stride2) }
                }
                
                mod dense 
                {
                    use regex::automata::{dfa::dense::OwnedDFA, primitives::StateID};

                    use super::Remappable;

                    impl Remappable for OwnedDFA {
                        fn state_len( &self ) -> usize { OwnedDFA::state_len(self) }

                        fn stride2( &self ) -> usize { OwnedDFA::stride2(self) }

                        fn swap_states( &mut self, id1: StateID, id2: StateID) {
                            OwnedDFA::swap_states(self, id1, id2)
                        }

                        fn remap( &mut self, map: impl Fn(StateID) -> StateID) {
                            OwnedDFA::remap(self, map)
                        }
                    }
                }
                
                mod onepass 
                {
                    use regex::automata::{dfa::onepass::DFA, primitives::StateID};

                    use super::Remappable;

                    impl Remappable for DFA {
                        fn state_len( &self ) -> usize { DFA::state_len(self) }

                        fn stride2( &self ) -> usize {
                            0
                        }

                        fn swap_states( &mut self, id1: StateID, id2: StateID) {
                            DFA::swap_states(self, id1, id2)
                        }

                        fn remap( &mut self, map: impl Fn(StateID) -> StateID) {
                            DFA::remap(self, map)
                        }
                    }
                }
            }

            pub mod search
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use crate::{
                    dfa::{
                        accel,
                        automaton::{Automaton, OverlappingState},
                    },
                    util::{
                        prefilter::Prefilter,
                        primitives::StateID,
                        search::{Anchored, HalfMatch, Input, Span},
                    },
                    MatchError,
                };
                */
                #[inline(never)]
                pub fn find_fwd<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    if input.is_done() {
                        return Ok( None );
                    }
                    let pre = if input.get_anchored().is_anchored() {
                        None
                    } else {
                        dfa.get_prefilter()
                    };
                    if pre.is_some() {
                        if input.get_earliest() {
                            find_fwd_imp(dfa, input, pre, true)
                        } else {
                            find_fwd_imp(dfa, input, pre, false)
                        }
                    } else {
                        if input.get_earliest() {
                            find_fwd_imp(dfa, input, None, true)
                        } else {
                            find_fwd_imp(dfa, input, None, false)
                        }
                    }
                }

                #[inline( always )]
                fn find_fwd_imp<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    pre:Option<&'_ Prefilter>,
                    earliest: bool,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    // See 'prefilter_restart' docs for explanation.
                    let universal_start = dfa.universal_start_state(Anchored::No).is_some();
                    let mut mat = None;
                    let mut sid = init_fwd(dfa, input)?;
                    let mut at = input.start();
                    macro_rules! next_unchecked {
                        ($sid:expr, $at:expr) => {{
                            let byte = *input.haystack().get_unchecked($at);
                            dfa.next_state_unchecked($sid, byte)
                        }};
                    }

                    if let Some(ref pre) = pre {
                        let span = Span::from(at..input.end());
                        match pre.find(input.haystack(), span) {
                            None => return Ok(mat),
                            Some(ref span) => {
                                at = span.start;
                                if !universal_start {
                                    sid = prefilter_restart(dfa, &input, at)?;
                                }
                            }
                        }
                    }
                    while at < input.end() {
                        // ensure that 'at' is always in bounds.
                        //
                        // benchmarks apply here.
                        let mut prev_sid;
                        while at < input.end() {
                            prev_sid = unsafe { next_unchecked!(sid, at) };
                            if dfa.is_special_state(prev_sid) || at + 3 >= input.end() {
                                ::mem::swap(&mut prev_sid, &mut sid);
                                break;
                            }
                            at += 1;

                            sid = unsafe { next_unchecked!(prev_sid, at) };
                            if dfa.is_special_state(sid) {
                                break;
                            }
                            at += 1;

                            prev_sid = unsafe { next_unchecked!(sid, at) };
                            if dfa.is_special_state(prev_sid) {
                                ::mem::swap(&mut prev_sid, &mut sid);
                                break;
                            }
                            at += 1;

                            sid = unsafe { next_unchecked!(prev_sid, at) };
                            if dfa.is_special_state(sid) {
                                break;
                            }
                            at += 1;
                        }
                        if dfa.is_special_state(sid) {
                            if dfa.is_start_state(sid) {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => return Ok(mat),
                                        Some(ref span) => {
                                            // candidate match.
                                            //
                                            // state has a self-loop, we can get stuck.
                                            if span.start > at {
                                                at = span.start;
                                                if !universal_start {
                                                    sid = prefilter_restart(dfa, &input, at)?;
                                                }
                                                continue;
                                            }
                                        }
                                    }
                                } else if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    at = accel::find_fwd(needles, input.haystack(), at + 1)
                                        .unwrap_or(input.end());
                                    continue;
                                }
                            } else if dfa.is_match_state(sid) {
                                let pattern = dfa.match_pattern(sid, 0);
                                mat = Some(HalfMatch::new(pattern, at));
                                if earliest {
                                    return Ok(mat);
                                }
                                if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    at = accel::find_fwd(needles, input.haystack(), at + 1)
                                        .unwrap_or(input.end());
                                    continue;
                                }
                            } else if dfa.is_accel_state(sid) {
                                let needs = dfa.accelerator(sid);
                                at = accel::find_fwd(needs, input.haystack(), at + 1)
                                    .unwrap_or(input.end());
                                continue;
                            } else if dfa.is_dead_state(sid) {
                                return Ok(mat);
                            } else {
                                // returns a supposedly valid DFA.
                                return Err(MatchError::quit(input.haystack()[at], at));
                            }
                        }
                        at += 1;
                    }
                    eoi_fwd(dfa, input, &mut sid, &mut mat)?;
                    Ok(mat)
                }

                #[inline(never)]
                pub fn find_rev<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    if input.is_done() {
                        return Ok( None );
                    }
                    if input.get_earliest() {
                        find_rev_imp(dfa, input, true)
                    } else {
                        find_rev_imp(dfa, input, false)
                    }
                }

                #[inline( always )]
                fn find_rev_imp<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    earliest: bool,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    let mut mat = None;
                    let mut sid = init_rev(dfa, input)?;
                    if input.start() == input.end() {
                        eoi_rev(dfa, input, &mut sid, &mut mat)?;
                        return Ok(mat);
                    }

                    let mut at = input.end() - 1;
                    macro_rules! next_unchecked {
                        ($sid:expr, $at:expr) => {{
                            let byte = *input.haystack().get_unchecked($at);
                            dfa.next_state_unchecked($sid, byte)
                        }};
                    }
                    loop {
                        // SAFETY: See comments in 'find_fwd' for a safety argument.
                        let mut prev_sid;
                        while at >= input.start() {
                            prev_sid = unsafe { next_unchecked!(sid, at) };
                            if dfa.is_special_state(prev_sid)
                                || at <= input.start().saturating_add(3)
                            {
                                ::mem::swap(&mut prev_sid, &mut sid);
                                break;
                            }
                            at -= 1;

                            sid = unsafe { next_unchecked!(prev_sid, at) };
                            if dfa.is_special_state(sid) {
                                break;
                            }
                            at -= 1;

                            prev_sid = unsafe { next_unchecked!(sid, at) };
                            if dfa.is_special_state(prev_sid) {
                                ::mem::swap(&mut prev_sid, &mut sid);
                                break;
                            }
                            at -= 1;

                            sid = unsafe { next_unchecked!(prev_sid, at) };
                            if dfa.is_special_state(sid) {
                                break;
                            }
                            at -= 1;
                        }
                        if dfa.is_special_state(sid) {
                            if dfa.is_start_state(sid) {
                                if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    at = accel::find_rev(needles, input.haystack(), at)
                                        .map(|i| i + 1)
                                        .unwrap_or(input.start());
                                }
                            } else if dfa.is_match_state(sid) {
                                let pattern = dfa.match_pattern(sid, 0);
                                mat = Some(HalfMatch::new(pattern, at + 1));
                                if earliest {
                                    return Ok(mat);
                                }
                                if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    at = accel::find_rev(needles, input.haystack(), at)
                                        .map(|i| i + 1)
                                        .unwrap_or(input.start());
                                }
                            } else if dfa.is_accel_state(sid) {
                                let needles = dfa.accelerator(sid);
                                at = accel::find_rev(needles, input.haystack(), at)
                                    .map(|i| i + 1)
                                    .unwrap_or(input.start());
                            } else if dfa.is_dead_state(sid) {
                                return Ok(mat);
                            } else {
                                return Err(MatchError::quit(input.haystack()[at], at));
                            }
                        }
                        if at == input.start() {
                            break;
                        }
                        at -= 1;
                    }
                    eoi_rev(dfa, input, &mut sid, &mut mat)?;
                    Ok(mat)
                }

                #[inline(never)]
                pub fn find_overlapping_fwd<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    state.mat = None;
                    if input.is_done() {
                        return Ok( () );
                    }
                    let pre = if input.get_anchored().is_anchored() {
                        None
                    } else {
                        dfa.get_prefilter()
                    };
                    if pre.is_some() {
                        find_overlapping_fwd_imp(dfa, input, pre, state)
                    } else {
                        find_overlapping_fwd_imp(dfa, input, None, state)
                    }
                }

                #[inline( always )]
                fn find_overlapping_fwd_imp<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    pre:Option<&'_ Prefilter>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    // See 'prefilter_restart' docs for explanation.
                    let universal_start = dfa.universal_start_state(Anchored::No).is_some();
                    let mut sid = match state.id {
                        None => {
                            state.at = input.start();
                            init_fwd(dfa, input)?
                        }
                        Some(sid) => {
                            if let Some(match_index) = state.next_match_index {
                                let match_len = dfa.match_len(sid);
                                if match_index < match_len {
                                    state.next_match_index = Some(match_index + 1);
                                    let pattern = dfa.match_pattern(sid, match_index);
                                    state.mat = Some(HalfMatch::new(pattern, state.at));
                                    return Ok( () );
                                }
                            }
                            state.at += 1;
                            if state.at > input.end() {
                                return Ok( () );
                            }
                            sid
                        }
                    };
                    while state.at < input.end() {
                        sid = dfa.next_state(sid, input.haystack()[state.at]);
                        if dfa.is_special_state(sid) {
                            state.id = Some(sid);
                            if dfa.is_start_state(sid) {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(state.at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => return Ok( () ),
                                        Some(ref span) => {
                                            if span.start > state.at {
                                                state.at = span.start;
                                                if !universal_start {
                                                    sid = prefilter_restart(
                                                        dfa, &input, state.at,
                                                    )?;
                                                }
                                                continue;
                                            }
                                        }
                                    }
                                } else if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    state.at = accel::find_fwd(
                                        needles,
                                        input.haystack(),
                                        state.at + 1,
                                    )
                                    .unwrap_or(input.end());
                                    continue;
                                }
                            } else if dfa.is_match_state(sid) {
                                state.next_match_index = Some(1);
                                let pattern = dfa.match_pattern(sid, 0);
                                state.mat = Some(HalfMatch::new(pattern, state.at));
                                return Ok( () );
                            } else if dfa.is_accel_state(sid) {
                                let needs = dfa.accelerator(sid);
                                state.at =
                                    accel::find_fwd(needs, input.haystack(), state.at + 1)
                                        .unwrap_or(input.end());
                                continue;
                            } else if dfa.is_dead_state(sid) {
                                return Ok( () );
                            } else {
                                return Err(MatchError::quit(
                                    input.haystack()[state.at],
                                    state.at,
                                ));
                            }
                        }
                        state.at += 1;
                    }

                    let result = eoi_fwd(dfa, input, &mut sid, &mut state.mat);
                    state.id = Some(sid);
                    if state.mat.is_some() {
                        state.next_match_index = Some(1);
                    }
                    result
                }

                #[inline(never)]
                pub fn find_overlapping_rev<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    state.mat = None;
                    if input.is_done() {
                        return Ok( () );
                    }
                    let mut sid = match state.id {
                        None => {
                            let sid = init_rev(dfa, input)?;
                            state.id = Some(sid);
                            if input.start() == input.end() {
                                state.rev_eoi = true;
                            } else {
                                state.at = input.end() - 1;
                            }
                            sid
                        }
                        Some(sid) => {
                            if let Some(match_index) = state.next_match_index {
                                let match_len = dfa.match_len(sid);
                                if match_index < match_len {
                                    state.next_match_index = Some(match_index + 1);
                                    let pattern = dfa.match_pattern(sid, match_index);
                                    state.mat = Some(HalfMatch::new(pattern, state.at));
                                    return Ok( () );
                                }
                            }
                            if state.rev_eoi {
                                return Ok( () );
                            } else if state.at == input.start() {
                                // to the final 'eoi_rev' transition.
                                state.rev_eoi = true;
                            } else {
                                // We haven't hit the end of the search yet, so move on.
                                state.at -= 1;
                            }
                            sid
                        }
                    };
                    while !state.rev_eoi {
                        sid = dfa.next_state(sid, input.haystack()[state.at]);
                        if dfa.is_special_state(sid) {
                            state.id = Some(sid);
                            if dfa.is_start_state(sid) {
                                if dfa.is_accel_state(sid) {
                                    let needles = dfa.accelerator(sid);
                                    state.at =
                                        accel::find_rev(needles, input.haystack(), state.at)
                                            .map(|i| i + 1)
                                            .unwrap_or(input.start());
                                }
                            } else if dfa.is_match_state(sid) {
                                state.next_match_index = Some(1);
                                let pattern = dfa.match_pattern(sid, 0);
                                state.mat = Some(HalfMatch::new(pattern, state.at + 1));
                                return Ok( () );
                            } else if dfa.is_accel_state(sid) {
                                let needles = dfa.accelerator(sid);
                                state.at =
                                    accel::find_rev(needles, input.haystack(), state.at)
                                        .map(|i| i + 1)
                                        .unwrap_or(input.start());
                            } else if dfa.is_dead_state(sid) {
                                return Ok( () );
                            } else {
                                return Err(MatchError::quit(
                                    input.haystack()[state.at],
                                    state.at,
                                ));
                            }
                        }
                        if state.at == input.start() {
                            break;
                        }
                        state.at -= 1;
                    }

                    let result = eoi_rev(dfa, input, &mut sid, &mut state.mat);
                    state.rev_eoi = true;
                    state.id = Some(sid);
                    if state.mat.is_some() {
                        state.next_match_index = Some(1);
                    }
                    result
                }

                #[inline( always )]
                fn init_fwd<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                ) -> Result<StateID, MatchError> {
                    let sid = dfa.start_state_forward(input)?;
                    debug_assert!(!dfa.is_match_state(sid));
                    Ok(sid)
                }

                #[inline( always )]
                fn init_rev<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                ) -> Result<StateID, MatchError> {
                    let sid = dfa.start_state_reverse(input)?;
                    debug_assert!(!dfa.is_match_state(sid));
                    Ok(sid)
                }

                #[inline( always )]
                fn eoi_fwd<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    sid: &mut StateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError> {
                    let sp = input.get_span();
                    match input.haystack().get(sp.end) {
                        Some(&b) => {
                            *sid = dfa.next_state(*sid, b);
                            if dfa.is_match_state(*sid) {
                                let pattern = dfa.match_pattern(*sid, 0);
                                *mat = Some(HalfMatch::new(pattern, sp.end));
                            } else if dfa.is_quit_state(*sid) {
                                return Err(MatchError::quit(b, sp.end));
                            }
                        }
                        None => {
                            *sid = dfa.next_eoi_state(*sid);
                            if dfa.is_match_state(*sid) {
                                let pattern = dfa.match_pattern(*sid, 0);
                                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));
                            }
                        }
                    }
                    Ok( () )
                }

                #[inline( always )]
                fn eoi_rev<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    sid: &mut StateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError> {
                    let sp = input.get_span();
                    if sp.start > 0 {
                        let byte = input.haystack()[sp.start - 1];
                        *sid = dfa.next_state(*sid, byte);
                        if dfa.is_match_state(*sid) {
                            let pattern = dfa.match_pattern(*sid, 0);
                            *mat = Some(HalfMatch::new(pattern, sp.start));
                        } else if dfa.is_quit_state(*sid) {
                            return Err(MatchError::quit(byte, sp.start - 1));
                        }
                    } else {
                        *sid = dfa.next_eoi_state(*sid);
                        if dfa.is_match_state(*sid) {
                            let pattern = dfa.match_pattern(*sid, 0);
                            *mat = Some(HalfMatch::new(pattern, 0));
                        }
                    }
                    Ok( () )
                }

                #[inline( always )] fn prefilter_restart<A: Automaton + ?Sized>(
                    dfa: &A,
                    input: &Input<'_>,
                    at: usize,
                ) -> Result<StateID, MatchError> {
                    let mut input = input.clone();
                    input.set_start(at);
                    init_fwd(dfa, &input)
                }
            }

            pub mod special
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use crate::{
                    dfa::DEAD,
                    util::{
                        primitives::StateID,
                        wire::{self, DeserializeError, Endian, SerializeError},
                    },
                };
                */
                macro_rules! err {
                    ($msg:expr) => { return Err(DeserializeError::generic($msg)); };
                }
                // special:
                //
                //   some other match state, even when searching an empty string.)
                //
                //
                //
                //
                //
                // identifier of the last special state in the DFA:
                //
                //
                // we continue searching even after seeing a match):
                //
                //
                //
                //     N = special.max_accel - special.min_accel + 1
                //
                // we need to do:
                //
                //     i = (state_id - special.min_accel) / stride
                //
                // 2^x=stride.)
                //
                // ranges are empty.
                //
                // Loop unrolling, if applicable, has also been left out of the logic above.
                //
                //
                #[derive( Clone, Copy, Debug )]
                pub struct Special {
                    pub max: StateID,
                    pub quit_id: StateID,
                    pub min_match: StateID,
                    pub max_match: StateID,
                    pub min_accel: StateID,
                    pub max_accel: StateID,
                    pub min_start: StateID,
                    pub max_start: StateID,
                }

                impl Special {
                        pub fn new() -> Special {
                        Special {
                            max: DEAD,
                            quit_id: DEAD,
                            min_match: DEAD,
                            max_match: DEAD,
                            min_accel: DEAD,
                            max_accel: DEAD,
                            min_start: DEAD,
                            max_start: DEAD,
                        }
                    }

                        pub fn remap(&self, map: impl Fn(StateID) -> StateID) -> Special {
                        Special {
                            max: map( self.max),
                            quit_id: map( self.quit_id),
                            min_match: map( self.min_match),
                            max_match: map( self.max_match),
                            min_accel: map( self.min_accel),
                            max_accel: map( self.max_accel),
                            min_start: map( self.min_start),
                            max_start: map( self.max_start),
                        }
                    }
                    
                    pub fn from_bytes(
                        mut slice: &[u8],
                    ) -> Result<(Special, usize), DeserializeError> {
                        wire::check_slice_len(slice, 8 * StateID::SIZE, "special states")?;

                        let mut nread = 0;
                        let mut read_id = |what| -> Result<StateID, DeserializeError> {
                            let (id, nr) = wire::try_read_state_id(slice, what)?;
                            nread += nr;
                            slice = &slice[StateID::SIZE..];
                            Ok(id)
                        };

                        let max = read_id("special max id")?;
                        let quit_id = read_id("special quit id")?;
                        let min_match = read_id("special min match id")?;
                        let max_match = read_id("special max match id")?;
                        let min_accel = read_id("special min accel id")?;
                        let max_accel = read_id("special max accel id")?;
                        let min_start = read_id("special min start id")?;
                        let max_start = read_id("special max start id")?;

                        let special = Special {
                            max,
                            quit_id,
                            min_match,
                            max_match,
                            min_accel,
                            max_accel,
                            min_start,
                            max_start,
                        };
                        special.validate()?;
                        assert_eq!(nread, special.write_to_len());
                        Ok((special, nread))
                    }
                    
                    pub fn validate( &self ) -> Result<(), DeserializeError> {
                        // Check that both ends of the range are DEAD or neither are.
                        if self.min_match == DEAD && self.max_match != DEAD {
                            err!("min_match is DEAD, but max_match is not");
                        }
                        if self.min_match != DEAD && self.max_match == DEAD {
                            err!("max_match is DEAD, but min_match is not");
                        }
                        if self.min_accel == DEAD && self.max_accel != DEAD {
                            err!("min_accel is DEAD, but max_accel is not");
                        }
                        if self.min_accel != DEAD && self.max_accel == DEAD {
                            err!("max_accel is DEAD, but min_accel is not");
                        }
                        if self.min_start == DEAD && self.max_start != DEAD {
                            err!("min_start is DEAD, but max_start is not");
                        }
                        if self.min_start != DEAD && self.max_start == DEAD {
                            err!("max_start is DEAD, but min_start is not");
                        }

                        if self.min_match > self.max_match {
                            err!("min_match should not be greater than max_match");
                        }
                        if self.min_accel > self.max_accel {
                            err!("min_accel should not be greater than max_accel");
                        }
                        if self.min_start > self.max_start {
                            err!("min_start should not be greater than max_start");
                        }

                        if self.matches() && self.quit_id >= self.min_match {
                            err!("quit_id should not be greater than min_match");
                        }
                        if self.accels() && self.quit_id >= self.min_accel {
                            err!("quit_id should not be greater than min_accel");
                        }
                        if self.starts() && self.quit_id >= self.min_start {
                            err!("quit_id should not be greater than min_start");
                        }
                        if self.matches() && self.accels() && self.min_accel < self.min_match {
                            err!("min_match should not be greater than min_accel");
                        }
                        if self.matches() && self.starts() && self.min_start < self.min_match {
                            err!("min_match should not be greater than min_start");
                        }
                        if self.accels() && self.starts() && self.min_start < self.min_accel {
                            err!("min_accel should not be greater than min_start");
                        }

                        if self.max < self.quit_id {
                            err!("quit_id should not be greater than max");
                        }
                        if self.max < self.max_match {
                            err!("max_match should not be greater than max");
                        }
                        if self.max < self.max_accel {
                            err!("max_accel should not be greater than max");
                        }
                        if self.max < self.max_start {
                            err!("max_start should not be greater than max");
                        }

                        Ok( () )
                    }
                    
                    pub fn validate_state_len(
                        &self,
                        len: usize,
                        stride2: usize,
                    ) -> Result<(), DeserializeError> {
                        if ( self.max.as_usize() >> stride2) >= len {
                            err!("max should not be greater than or equal to state length");
                        }
                        Ok( () )
                    }

                    pub fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError> {
                        use regex::automata::wire::write_state_id as write;

                        if dst.len() < self.write_to_len() {
                            return Err(SerializeError::buffer_too_small("special state ids"));
                        }

                        let mut nwrite = 0;
                        nwrite += write::<E>( self.max, &mut dst[nwrite..]);
                        nwrite += write::<E>( self.quit_id, &mut dst[nwrite..]);
                        nwrite += write::<E>( self.min_match, &mut dst[nwrite..]);
                        nwrite += write::<E>( self.max_match, &mut dst[nwrite..]);
                        nwrite += write::<E>( self.min_accel, &mut dst[nwrite..]);
                        nwrite += write::<E>( self.max_accel, &mut dst[nwrite..]);
                        nwrite += write::<E>( self.min_start, &mut dst[nwrite..]);
                        nwrite += write::<E>( self.max_start, &mut dst[nwrite..]);

                        assert_eq!(
                            self.write_to_len(),
                            nwrite,
                            "expected to write certain number of bytes",
                        );
                        assert_eq!(
                            nwrite % 8,
                            0,
                            "expected to write multiple of 8 bytes for special states",
                        );
                        Ok(nwrite)
                    }

                    pub fn write_to_len( &self ) -> usize { 8 * StateID::SIZE }
                        pub fn set_max(&mut self) {
                        use ::cmp::max;
                        self.max = max(
                            self.quit_id,
                            max( self.max_match, max( self.max_accel, self.max_start)),
                        );
                    }
                        pub fn set_no_special_start_states(&mut self) {
                        use ::cmp::max;
                        self.max = max( self.quit_id, max( self.max_match, self.max_accel));
                        self.min_start = DEAD;
                        self.max_start = DEAD;
                    }
                    #[inline] pub fn is_special_state(&self, id: StateID) -> bool {
                        id <= self.max
                    }
                    #[inline] pub fn is_dead_state(&self, id: StateID) -> bool {
                        id == DEAD
                    }
                    #[inline] pub fn is_quit_state(&self, id: StateID) -> bool {
                        !self.is_dead_state(id) && self.quit_id == id
                    }
                    #[inline] pub fn is_match_state(&self, id: StateID) -> bool {
                        !self.is_dead_state(id) && self.min_match <= id && id <= self.max_match
                    }
                    #[inline] pub fn is_accel_state(&self, id: StateID) -> bool {
                        !self.is_dead_state(id) && self.min_accel <= id && id <= self.max_accel
                    }
                    #[inline] pub fn is_start_state(&self, id: StateID) -> bool {
                        !self.is_dead_state(id) && self.min_start <= id && id <= self.max_start
                    }
                    #[inline] pub fn match_len(&self, stride: usize) -> usize {
                        if self.matches() {
                            ( self.max_match.as_usize() - self.min_match.as_usize() + stride)
                                / stride
                        } else {
                            0
                        }
                    }
                    #[inline] pub fn matches( &self ) -> bool { self.min_match != DEAD }

                        pub fn accel_len(&self, stride: usize) -> usize {
                        if self.accels() {
                            ( self.max_accel.as_usize() - self.min_accel.as_usize() + stride)
                                / stride
                        } else {
                            0
                        }
                    }
                    #[inline] pub fn accels( &self ) -> bool { self.min_accel != DEAD }
                    #[inline] pub fn starts( &self ) -> bool { self.min_start != DEAD }
                }
            }

            pub mod start
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use ::mem::size_of;
                use crate::util::wire::{self, DeserializeError, Endian, SerializeError};
                */

                #[derive(Clone, Copy, Debug, Eq, PartialEq )]
                pub enum StartKind {

                    Both,
                    Unanchored,
                    Anchored,
                }

                impl StartKind
                {
                    pub fn from_bytes(
                        slice: &[u8],
                    ) -> Result<(StartKind, usize), DeserializeError> {
                        wire::check_slice_len(slice, size_of::<u32>(), "start kind bytes")?;
                        let (n, nr) = wire::try_read_u32(slice, "start kind integer")?;
                        match n {
                            0 => Ok((StartKind::Both, nr)),
                            1 => Ok((StartKind::Unanchored, nr)),
                            2 => Ok((StartKind::Anchored, nr)),
                            _ => Err(DeserializeError::generic("unrecognized start kind")),
                        }
                    }

                    pub fn write_to<E: Endian>(
                        &self,
                        dst: &mut [u8],
                    ) -> Result<usize, SerializeError>
                    {
                        let nwrite = self.write_to_len();
                        if dst.len() < nwrite {
                            return Err(SerializeError::buffer_too_small("start kind"));
                        }
                        let n = match *self {
                            StartKind::Both => 0,
                            StartKind::Unanchored => 1,
                            StartKind::Anchored => 2,
                        };
                        E::write_u32(n, dst);
                        Ok(nwrite)
                    }

                    pub fn write_to_len( &self ) -> usize { size_of::<u32>() }

                    #[inline( always )]
                    pub fn has_unanchored( &self ) -> bool { matches!(*self, StartKind::Both | StartKind::Unanchored) }

                    #[inline( always )]
                    pub fn has_anchored( &self ) -> bool { matches!(*self, StartKind::Both | StartKind::Anchored) }
                }
            } pub use self::start::{ StartKind };
        }
        
        pub mod hybrid
        {
            /*!
            A module for building and searching with lazy deterministic finite automata (DFAs).*/
            use ::
            {
                *,
            };
            /*
            pub use self::{
                error::{BuildError, CacheError, StartError},
                id::LazyStateID,
            };
            */
            pub mod dfa
            {
                /*!
                Types and routines specific to lazy DFAs. */
                use ::
                {
                    *,
                };
                /*
                use ::{iter, mem::size_of};

                use alloc::vec::Vec;

                use crate::{
                    hybrid::{
                        error::{BuildError, CacheError, StartError},
                        id::{LazyStateID, LazyStateIDError},
                        search,
                    },
                    nfa::thompson,
                    util::{
                        alphabet::{self, ByteClasses, ByteSet},
                        determinize::{self, State, StateBuilderEmpty, StateBuilderNFA},
                        empty,
                        prefilter::Prefilter,
                        primitives::{PatternID, StateID as NFAStateID},
                        search::{
                            Anchored, HalfMatch, Input, MatchError, MatchKind, PatternSet,
                        },
                        sparse_set::SparseSets,
                        start::{self, Start, StartByteMap},
                    },
                };
                */
                const MIN_STATES: usize = SENTINEL_STATES + 2;

                const SENTINEL_STATES: usize = 3;

                #[derive( Clone, Debug )]
                pub struct DFA {
                    config: Config,
                    nfa: thompson::NFA,
                    stride2: usize,
                    start_map: StartByteMap,
                    classes: ByteClasses,
                    quitset: ByteSet,
                    cache_capacity: usize,
                }

                impl DFA
                {
                    pub fn new(pattern: &str) -> Result<DFA, BuildError> { DFA::builder().build(pattern) }
                    
                    pub fn new_many<P: AsRef<str>>(patterns: &[P]) -> Result<DFA, BuildError> { DFA::builder().build_many(patterns) }

                    pub fn always_match() -> Result<DFA, BuildError>
                    {
                        let nfa = thompson::NFA::always_match();
                        Builder::new().build_from_nfa(nfa)
                    }

                    pub fn never_match() -> Result<DFA, BuildError>
                    {
                        let nfa = thompson::NFA::never_match();
                        Builder::new().build_from_nfa(nfa)
                    }
                    
                    pub fn config() -> Config {
                        Config::new()
                    }

                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                    
                    pub fn create_cache( &self ) -> Cache { Cache::new(self) }
                    
                    pub fn reset_cache(&self, cache: &mut Cache) {
                        Lazy::new(self, cache).reset_cache()
                    }

                    ///
                    ///
                    ///

                    ///
                    ///
                    pub fn pattern_len( &self ) -> usize { self.nfa.pattern_len() }

                    pub fn byte_classes( &self ) -> &ByteClasses { &self.classes }

                    pub fn get_config( &self ) -> &Config { &self.config }

                    pub fn get_nfa( &self ) -> &thompson::NFA { &self.nfa }
                    fn stride2( &self ) -> usize { self.stride2 }
                    fn stride( &self ) -> usize { 1 << self.stride2() }
                    
                    pub fn memory_usage( &self ) -> usize { 0 }
                }

                impl DFA {
                   #[inline] pub fn try_search_fwd(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError>
                    {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        let hm = match search::find_fwd(self, cache, input)? {
                            None => return Ok( None ),
                            Some(hm) if !utf8empty => return Ok(Some(hm)),
                            Some(hm) => hm,
                        };
                        
                        empty::skip_splits_fwd(input, hm, hm.offset(), |input| {
                            let got = search::find_fwd(self, cache, input)?;
                            Ok(got.map(|hm| (hm, hm.offset())))
                        })
                    }
                    
                    #[inline] pub fn try_search_rev(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, MatchError>
                    {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        let hm = match search::find_rev(self, cache, input)? {
                            None => return Ok( None ),
                            Some(hm) if !utf8empty => return Ok(Some(hm)),
                            Some(hm) => hm,
                        };
                        empty::skip_splits_rev(input, hm, hm.offset(), |input| {
                            let got = search::find_rev(self, cache, input)?;
                            Ok(got.map(|hm| (hm, hm.offset())))
                        })
                    }
                    
                    #[inline] pub fn try_search_overlapping_fwd(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError>
                    {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        search::find_overlapping_fwd(self, cache, input, state)?;
                        match state.get_match() {
                            None => Ok( () ),
                            Some(_) if !utf8empty => Ok( () ),
                            Some(_) => skip_empty_utf8_splits_overlapping(
                                input,
                                state,
                                |input, state| {
                                    search::find_overlapping_fwd(self, cache, input, state)
                                },
                            ),
                        }
                    }
                    
                    #[inline] pub fn try_search_overlapping_rev(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        state: &mut OverlappingState,
                    ) -> Result<(), MatchError>
                    {
                        let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                        search::find_overlapping_rev(self, cache, input, state)?;
                        match state.get_match() {
                            None => Ok( () ),
                            Some(_) if !utf8empty => Ok( () ),
                            Some(_) => skip_empty_utf8_splits_overlapping(
                                input,
                                state,
                                |input, state| {
                                    search::find_overlapping_rev(self, cache, input, state)
                                },
                            ),
                        }
                    }
                    
                    #[inline] pub fn try_which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), MatchError>
                    {
                        let mut state = OverlappingState::start();
                        while let Some(m) = {
                            self.try_search_overlapping_fwd(cache, input, &mut state)?;
                            state.get_match()
                        } {
                            let _ = patset.try_insert(m.pattern());
                            if patset.is_full() || input.get_earliest() {
                                break;
                            }
                        }
                        Ok( () )
                    }
                }

                impl DFA {
                    #[inline] pub fn next_state(
                        &self,
                        cache: &mut Cache,
                        current: LazyStateID,
                        input: u8,
                    ) -> Result<LazyStateID, CacheError>
                    {
                        let class = usize::from( self.classes.get(input));
                        let offset = current.as_usize_untagged() + class;
                        let sid = cache.trans[offset];
                        if !sid.is_unknown() {
                            return Ok(sid);
                        }
                        let unit = alphabet::Unit::u8(input);
                        Lazy::new(self, cache).cache_next_state(current, unit)
                    }
                    
                    #[inline] pub fn next_state_untagged(
                        &self,
                        cache: &Cache,
                        current: LazyStateID,
                        input: u8,
                    ) -> LazyStateID {
                        debug_assert!(!current.is_tagged());
                        let class = usize::from( self.classes.get(input));
                        let offset = current.as_usize_unchecked() + class;
                        cache.trans[offset]
                    }
                    #[inline]
                    pub unsafe fn next_state_untagged_unchecked(
                        &self,
                        cache: &Cache,
                        current: LazyStateID,
                        input: u8,
                    ) -> LazyStateID {
                        debug_assert!(!current.is_tagged());
                        let class = usize::from( self.classes.get(input));
                        let offset = current.as_usize_unchecked() + class;
                        *cache.trans.get_unchecked(offset)
                    }
                    
                    #[inline] pub fn next_eoi_state(
                        &self,
                        cache: &mut Cache,
                        current: LazyStateID,
                    ) -> Result<LazyStateID, CacheError>
                    {
                        let eoi = self.classes.eoi().as_usize();
                        let offset = current.as_usize_untagged() + eoi;
                        let sid = cache.trans[offset];
                        if !sid.is_unknown() {
                            return Ok(sid);
                        }
                        let unit = self.classes.eoi();
                        Lazy::new(self, cache).cache_next_state(current, unit)
                    }
                    #[inline( always )]
                    pub fn start_state(
                        &self,
                        cache: &mut Cache,
                        config: &start::Config,
                    ) -> Result<LazyStateID, StartError>
                    {
                        let lazy = LazyRef::new(self, cache);
                        let anchored = config.get_anchored();
                        let start = match config.get_look_behind() {
                            None => Start::Text,
                            Some( byte ) => {
                                if !self.quitset.is_empty() && self.quitset.contains( byte ) {
                                    return Err(StartError::quit( byte ));
                                }
                                self.start_map.get( byte )
                            }
                        };
                        let start_id = lazy.get_cached_start_id(anchored, start)?;
                        if !start_id.is_unknown() {
                            return Ok(start_id);
                        }
                        Lazy::new(self, cache).cache_start_group(anchored, start)
                    }
                    #[inline( always )]
                    pub fn start_state_forward(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<LazyStateID, MatchError>
                    {
                        let config = start::Config::from_input_forward(input);
                        self.start_state(cache, &config).map_err(|err| match err {
                            StartError::Cache { .. } => MatchError::gave_up(input.start()),
                            StartError::Quit { byte } => {
                                let offset = input
                                    .start()
                                    .checked_sub(1)
                                    .expect("no quit in start without look-behind");
                                MatchError::quit(byte, offset)
                            }
                            StartError::UnsupportedAnchored { mode } => { MatchError::unsupported_anchored(mode) }
                        })
                    }
                    #[inline( always )]
                    pub fn start_state_reverse(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<LazyStateID, MatchError>
                    {
                        let config = start::Config::from_input_reverse(input);
                        self.start_state(cache, &config).map_err(|err| match err {
                            StartError::Cache { .. } => MatchError::gave_up(input.end()),
                            StartError::Quit { byte } => {
                                let offset = input.end();
                                MatchError::quit(byte, offset)
                            }
                            StartError::UnsupportedAnchored { mode } => { MatchError::unsupported_anchored(mode) }
                        })
                    }
                    
                    #[inline] pub fn match_len(&self, cache: &Cache, id: LazyStateID) -> usize {
                        assert!(id.is_match());
                        LazyRef::new(self, cache).get_cached_state(id).match_len()
                    }
                    
                    #[inline] pub fn match_pattern(
                        &self,
                        cache: &Cache,
                        id: LazyStateID,
                        match_index: usize,
                    ) -> PatternID {
                        // to only matter when matches are frequent.
                        if self.pattern_len() == 1 {
                            return PatternID::ZERO;
                        }
                        LazyRef::new(self, cache)
                            .get_cached_state(id)
                            .match_pattern(match_index)
                    }
                }

                #[derive( Clone, Debug )]
                pub struct Cache {
                    // doesn't have the "laziness" component.

                    trans: Vec<LazyStateID>,
                    starts: Vec<LazyStateID>,
                    states: Vec<State>,
                    states_to_id: StateMap,
                    sparses: SparseSets,
                    stack: Vec<NFAStateID>,
                    scratch_state_builder: StateBuilderEmpty,
                    state_saver: StateSaver,
                    memory_usage_state: usize,
                    clear_count: usize,
                    bytes_searched: usize,
                    progress:Option<SearchProgress>,
                }

                impl Cache
                {
                    pub fn new(dfa: &DFA) -> Cache {
                        let mut cache = Cache {
                            trans:vec![],
                            starts:vec![],
                            states:vec![],
                            states_to_id: StateMap::new(),
                            sparses: SparseSets::new(dfa.get_nfa().states().len()),
                            stack:vec![],
                            scratch_state_builder: StateBuilderEmpty::new(),
                            state_saver: StateSaver::none(),
                            memory_usage_state: 0,
                            clear_count: 0,
                            bytes_searched: 0,
                            progress: None,
                        };
                        Lazy { dfa, cache: &mut cache }.init_cache();
                        cache
                    }
                    
                    pub fn reset( &mut self, dfa: &DFA) {
                        Lazy::new(dfa, self).reset_cache()
                    }
                    #[inline] pub fn search_start( &mut self, at: usize) {
                        if let Some(p) = self.progress.take() {
                            self.bytes_searched += p.len();
                        }
                        self.progress = Some(SearchProgress { start: at, at });
                    }
                    
                    #[inline] pub fn search_update( &mut self, at: usize) {
                        let p =
                            self.progress.as_mut().expect("no in-progress search to update");
                        p.at = at;
                    }
                    #[inline] pub fn search_finish( &mut self, at: usize) {
                        let mut p =
                            self.progress.take().expect("no in-progress search to finish");
                        p.at = at;
                        self.bytes_searched += p.len();
                    }
                    
                    pub fn search_total_len( &self ) -> usize { self.bytes_searched + self.progress.as_ref().map_or(0, |p| p.len()) }
                    
                    pub fn clear_count( &self ) -> usize { self.clear_count }
                    
                    pub fn memory_usage( &self ) -> usize {
                        const ID_SIZE: usize = size_of::<LazyStateID>();
                        const STATE_SIZE: usize = size_of::<State>();

                        self.trans.len() * ID_SIZE
                        + self.starts.len() * ID_SIZE
                        + self.states.len() * STATE_SIZE
                        + self.states_to_id.len() * (STATE_SIZE + ID_SIZE)
                        + self.sparses.memory_usage()
                        + self.stack.capacity() * ID_SIZE
                        + self.scratch_state_builder.capacity()
                        + self.memory_usage_state
                    }
                }

                #[derive( Clone, Debug )]
                struct SearchProgress {
                    start: usize,
                    at: usize,
                }

                impl SearchProgress
                {
                    fn len( &self ) -> usize {
                        if self.start <= self.at {
                            self.at - self.start
                        } else {
                            self.start - self.at
                        }
                    }
                }
                
                type StateMap = ::collections::HashMap<State, LazyStateID>;
                
                #[derive( Debug )]
                struct Lazy<'i, 'c> {
                    dfa: &'i DFA,
                    cache: &'c mut Cache,
                }

                impl<'i, 'c> Lazy<'i, 'c> {

                    fn new(dfa: &'i DFA, cache: &'c mut Cache) -> Lazy<'i, 'c> { Lazy { dfa, cache } }
                    fn as_ref<'a>(&'a self) -> LazyRef<'i, 'a> { LazyRef::new( self.dfa, self.cache) }
                    #[cold]
                    #[inline( never )] fn cache_next_state(
                        &mut self,
                        mut current: LazyStateID,
                        unit: alphabet::Unit,
                    ) -> Result<LazyStateID, CacheError>
                    {
                        let stride2 = self.dfa.stride2();
                        let empty_builder = self.get_state_builder();
                        let builder = determinize::next(
                            self.dfa.get_nfa(),
                            self.dfa.get_config().get_match_kind(),
                            &mut self.cache.sparses,
                            &mut self.cache.stack,
                            &self.cache.states[current.as_usize_untagged() >> stride2],
                            unit,
                            empty_builder,
                        );
                        //
                        let save_state = !self.as_ref().state_builder_fits_in_cache(&builder)
                            || self.cache.trans.len() >= LazyStateID::MAX;
                        if save_state {
                            self.save_state(current);
                        }
                        let next = self.add_builder_state(builder, |sid| sid)?;
                        if save_state {
                            current = self.saved_state_id();
                        }
                        // having to re-determinize this transition.
                        self.set_transition(current, unit, next);
                        Ok(next)
                    }
                    #[cold]
                    #[inline( never )] fn cache_start_group(
                        &mut self,
                        anchored: Anchored,
                        start: Start,
                    ) -> Result<LazyStateID, StartError>
                    {
                        let nfa_start_id = match anchored {
                            Anchored::No => self.dfa.get_nfa().start_unanchored(),
                            Anchored::Yes => self.dfa.get_nfa().start_anchored(),
                            Anchored::Pattern(pid) => {
                                if !self.dfa.get_config().get_starts_for_each_pattern() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                match self.dfa.get_nfa().start_pattern(pid) {
                                    None => return Ok( self.as_ref().dead_id()),
                                    Some(sid) => sid,
                                }
                            }
                        };

                        let id = self
                            .cache_start_one(nfa_start_id, start)
                            .map_err(StartError::cache)?;
                        self.set_start_state(anchored, start, id);
                        Ok(id)
                    }
                    ///
                    fn cache_start_one(
                        &mut self,
                        nfa_start_id: NFAStateID,
                        start: Start,
                    ) -> Result<LazyStateID, CacheError>
                    {
                        let mut builder_matches = self.get_state_builder().into_matches();
                        determinize::set_lookbehind_from_start(
                            self.dfa.get_nfa(),
                            &start,
                            &mut builder_matches,
                        );
                        self.cache.sparses.set1.clear();
                        determinize::epsilon_closure(
                            self.dfa.get_nfa(),
                            nfa_start_id,
                            builder_matches.look_have(),
                            &mut self.cache.stack,
                            &mut self.cache.sparses.set1,
                        );
                        let mut builder = builder_matches.into_nfa();
                        determinize::add_nfa_states(
                            &self.dfa.get_nfa(),
                            &self.cache.sparses.set1,
                            &mut builder,
                        );
                        let tag_starts = self.dfa.get_config().get_specialize_start_states();
                        self.add_builder_state(builder, |id| {
                            if tag_starts {
                                id.to_start()
                            } else {
                                id
                            }
                        })
                    }
                    fn add_builder_state(
                        &mut self,
                        builder: StateBuilderNFA,
                        idmap: impl Fn(LazyStateID) -> LazyStateID,
                    ) -> Result<LazyStateID, CacheError> {
                        if let Some(&cached_id) =
                            self.cache.states_to_id.get(builder.as_bytes())
                        {
                            self.put_state_builder(builder);
                            return Ok(cached_id);
                        }
                        let result = self.add_state(builder.to_state(), idmap);
                        self.put_state_builder(builder);
                        result
                    }
                    fn add_state(
                        &mut self,
                        state: State,
                        idmap: impl Fn(LazyStateID) -> LazyStateID,
                    ) -> Result<LazyStateID, CacheError> {
                        if !self.as_ref().state_fits_in_cache(&state) {
                            self.try_clear_cache()?;
                        }
                        let mut id = idmap( self.next_state_id()?);
                        if state.is_match() {
                            id = id.to_match();
                        }
                        self.cache.trans.extend(
                            iter::repeat( self.as_ref().unknown_id()).take( self.dfa.stride()),
                        );
                        
                        if !self.dfa.quitset.is_empty() && !self.as_ref().is_sentinel(id) {
                            let quit_id = self.as_ref().quit_id();
                            for b in self.dfa.quitset.iter() {
                                self.set_transition(id, alphabet::Unit::u8(b), quit_id);
                            }
                        }
                        self.cache.memory_usage_state += state.memory_usage();
                        self.cache.states.push(state.clone());
                        self.cache.states_to_id.insert(state, id);
                        Ok(id)
                    }
                    fn next_state_id(&mut self) -> Result<LazyStateID, CacheError>
                    {
                        let sid = match LazyStateID::new( self.cache.trans.len()) {
                            Ok(sid) => sid,
                            Err(_) => {
                                self.try_clear_cache()?;
                                LazyStateID::new( self.cache.trans.len()).unwrap()
                            }
                        };
                        Ok(sid)
                    }
                    fn try_clear_cache(&mut self) -> Result<(), CacheError>
                    {
                        let c = self.dfa.get_config();
                        if let Some(min_count) = c.get_minimum_cache_clear_count() {
                            if self.cache.clear_count >= min_count {
                                if let Some(min_bytes_per) = c.get_minimum_bytes_per_state() {
                                    let len = self.cache.search_total_len();
                                    let min_bytes =
                                        min_bytes_per.saturating_mul( self.cache.states.len());
                                    if len == 0 {
                                        trace!(
                                            "number of bytes searched is 0, but \
                                            a minimum bytes per state searched ({}) is \
                                            enabled, maybe Cache::search_update \
                                            is not being used?",
                                            min_bytes_per,
                                        );
                                    }
                                    if len < min_bytes {
                                        trace!(
                                            "lazy DFA cache has been cleared {} times, \
                                            which exceeds the limit of {}, \
                                            AND its bytes searched per state is less \
                                            than the configured minimum of {}, \
                                            therefore lazy DFA is giving up \
                                            (bytes searched since cache clear = {}, \
                                            number of states = {})",
                                            self.cache.clear_count,
                                            min_count,
                                            min_bytes_per,
                                            len,
                                            self.cache.states.len(),
                                        );
                                        return Err(CacheError::bad_efficiency());
                                    } else {
                                        trace!(
                                            "lazy DFA cache has been cleared {} times, \
                                            which exceeds the limit of {}, \
                                            AND its bytes searched per state is greater \
                                            than the configured minimum of {}, \
                                            therefore lazy DFA is continuing! \
                                            (bytes searched since cache clear = {}, \
                                            number of states = {})",
                                            self.cache.clear_count,
                                            min_count,
                                            min_bytes_per,
                                            len,
                                            self.cache.states.len(),
                                        );
                                    }
                                } else {
                                    trace!(
                                        "lazy DFA cache has been cleared {} times, \
                                        which exceeds the limit of {}, \
                                        since there is no configured bytes per state \
                                        minimum, lazy DFA is giving up",
                                        self.cache.clear_count,
                                        min_count,
                                    );
                                    return Err(CacheError::too_many_cache_clears());
                                }
                            }
                        }
                        self.clear_cache();
                        Ok( () )
                    }
                    fn reset_cache(&mut self) {
                        self.cache.state_saver = StateSaver::none();
                        self.clear_cache();
                        self.cache.sparses.resize( self.dfa.get_nfa().states().len());
                        self.cache.clear_count = 0;
                        self.cache.progress = None;
                    }
                    fn clear_cache(&mut self) {
                        self.cache.trans.clear();
                        self.cache.starts.clear();
                        self.cache.states.clear();
                        self.cache.states_to_id.clear();
                        self.cache.memory_usage_state = 0;
                        self.cache.clear_count += 1;
                        self.cache.bytes_searched = 0;
                        if let Some(ref mut progress) = self.cache.progress {
                            progress.start = progress.at;
                        }
                        trace!(
                            "lazy DFA cache has been cleared (count: {})",
                            self.cache.clear_count
                        );
                        self.init_cache();
                        if let Some((old_id, state)) = self.cache.state_saver.take_to_save() {
                            // sentinel state.
                            assert!(
                                !self.as_ref().is_sentinel(old_id),
                                "cannot save sentinel state"
                            );
                            let new_id = self
                                .add_state(state, |id| {
                                    if old_id.is_start() {
                                        id.to_start()
                                    } else {
                                        id
                                    }
                                })
                                // 'init_cache' above adds 3, this adds a 4th.
                                .expect("adding one state after cache clear must work");
                            self.cache.state_saver = StateSaver::Saved(new_id);
                        }
                    }
                    fn init_cache(&mut self) {
                        let mut starts_len = Start::len().checked_mul(2).unwrap();
                        if self.dfa.get_config().get_starts_for_each_pattern() {
                            starts_len += Start::len() * self.dfa.pattern_len();
                        }
                        self.cache
                            .starts
                            .extend(iter::repeat( self.as_ref().unknown_id()).take(starts_len));
                        let dead = State::dead();
                        //
                        let unk_id =
                            self.add_state(dead.clone(), |id| id.to_unknown()).unwrap();
                        let dead_id = self.add_state(dead.clone(), |id| id.to_dead()).unwrap();
                        let quit_id = self.add_state(dead.clone(), |id| id.to_quit()).unwrap();
                        assert_eq!(unk_id, self.as_ref().unknown_id());
                        assert_eq!(dead_id, self.as_ref().dead_id());
                        assert_eq!(quit_id, self.as_ref().quit_id());
                        self.set_all_transitions(unk_id, unk_id);
                        self.set_all_transitions(dead_id, dead_id);
                        self.set_all_transitions(quit_id, quit_id);
                        self.cache.states_to_id.insert(dead, dead_id);
                    }
                    fn save_state( &mut self, id: LazyStateID) {
                        let state = self.as_ref().get_cached_state(id).clone();
                        self.cache.state_saver = StateSaver::ToSave { id, state };
                    }
                    fn saved_state_id(&mut self) -> LazyStateID {
                        self.cache
                            .state_saver
                            .take_saved()
                            .expect("state saver does not have saved state ID")
                    }

                    fn set_all_transitions( &mut self, from: LazyStateID, to: LazyStateID) {
                        for unit in self.dfa.classes.representatives(..) {
                            self.set_transition(from, unit, to);
                        }
                    }

                    fn set_transition(
                        &mut self,
                        from: LazyStateID,
                        unit: alphabet::Unit,
                        to: LazyStateID,
                    ) {
                        assert!( self.as_ref().is_valid(from), "invalid 'from' id: {from:?}");
                        assert!( self.as_ref().is_valid(to), "invalid 'to' id: {to:?}");
                        let offset =
                            from.as_usize_untagged() + self.dfa.classes.get_by_unit(unit);
                        self.cache.trans[offset] = to;
                    }
                    fn set_start_state(
                        &mut self,
                        anchored: Anchored,
                        start: Start,
                        id: LazyStateID,
                    ) {
                        assert!( self.as_ref().is_valid(id));
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => start_index,
                            Anchored::Yes => Start::len() + start_index,
                            Anchored::Pattern(pid) => {
                                assert!(
                                    self.dfa.get_config().get_starts_for_each_pattern(),
                                    "attempted to search for a specific pattern \
                                    without enabling starts_for_each_pattern",
                                );
                                let pid = pid.as_usize();
                                (2 * Start::len()) + (Start::len() * pid) + start_index
                            }
                        };
                        self.cache.starts[index] = id;
                    }
                    fn get_state_builder(&mut self) -> StateBuilderEmpty {
                        ::mem::replace(
                            &mut self.cache.scratch_state_builder,
                            StateBuilderEmpty::new(),
                        )
                    }
                    fn put_state_builder( &mut self, builder: StateBuilderNFA) {
                        let _ = ::mem::replace(
                            &mut self.cache.scratch_state_builder,
                            builder.clear(),
                        );
                    }
                }
                
                #[derive( Debug )]
                struct LazyRef<'i, 'c> {
                    dfa: &'i DFA,
                    cache: &'c Cache,
                }

                impl<'i, 'c> LazyRef<'i, 'c> {

                    fn new(dfa: &'i DFA, cache: &'c Cache) -> LazyRef<'i, 'c> { LazyRef { dfa, cache } }
                    #[inline( always )] fn get_cached_start_id(
                        &self,
                        anchored: Anchored,
                        start: Start,
                    ) -> Result<LazyStateID, StartError>
                    {
                        let start_index = start.as_usize();
                        let index = match anchored {
                            Anchored::No => start_index,
                            Anchored::Yes => Start::len() + start_index,
                            Anchored::Pattern(pid) => {
                                if !self.dfa.get_config().get_starts_for_each_pattern() {
                                    return Err(StartError::unsupported_anchored(anchored));
                                }
                                if pid.as_usize() >= self.dfa.pattern_len() {
                                    return Ok( self.dead_id());
                                }
                                (2 * Start::len())
                                    + (Start::len() * pid.as_usize())
                                    + start_index
                            }
                        };
                        Ok( self.cache.starts[index])
                    }

                    fn get_cached_state(&self, sid: LazyStateID) -> &State {
                        let index = sid.as_usize_untagged() >> self.dfa.stride2();
                        &self.cache.states[index]
                    }
                    fn is_sentinel(&self, id: LazyStateID) -> bool {
                        id == self.unknown_id() || id == self.dead_id() || id == self.quit_id()
                    }

                    fn unknown_id( &self ) -> LazyStateID { LazyStateID::new(0).unwrap().to_unknown() }

                    fn dead_id( &self ) -> LazyStateID { LazyStateID::new(1 << self.dfa.stride2()).unwrap().to_dead() }

                    fn quit_id( &self ) -> LazyStateID { LazyStateID::new(2 << self.dfa.stride2()).unwrap().to_quit() }
                    fn is_valid(&self, id: LazyStateID) -> bool {
                        let id = id.as_usize_untagged();
                        id < self.cache.trans.len() && id % self.dfa.stride() == 0
                    }

                    fn state_fits_in_cache(&self, state: &State) -> bool {
                        let needed = self.cache.memory_usage()
                            + self.memory_usage_for_one_more_state(state.memory_usage());
                        trace!(
                            "lazy DFA cache capacity state check: {:?} ?<=? {:?}",
                            needed,
                            self.dfa.cache_capacity
                        );
                        needed <= self.dfa.cache_capacity
                    }
                    fn state_builder_fits_in_cache(&self, state: &StateBuilderNFA) -> bool {
                        let needed = self.cache.memory_usage()
                            + self.memory_usage_for_one_more_state(state.as_bytes().len());
                        trace!(
                            "lazy DFA cache capacity state builder check: {:?} ?<=? {:?}",
                            needed,
                            self.dfa.cache_capacity
                        );
                        needed <= self.dfa.cache_capacity
                    }
                    fn memory_usage_for_one_more_state(
                        &self,
                        state_heap_size: usize,
                    ) -> usize {
                        const ID_SIZE: usize = size_of::<LazyStateID>();
                        const STATE_SIZE: usize = size_of::<State>();

                        self.dfa.stride() * ID_SIZE // additional space needed in trans table
                        + STATE_SIZE // space in cache.states
                        + (STATE_SIZE + ID_SIZE) // space in cache.states_to_id
                        + state_heap_size // heap memory used by state itself
                    }
                }
                
                #[derive( Clone, Debug )]
                enum StateSaver {

                    None,
                    ToSave { id: LazyStateID, state: State },
                    Saved(LazyStateID),
                }

                impl StateSaver {

                    fn none() -> StateSaver {
                        StateSaver::None
                    }
                    fn take_to_save(&mut self) -> Option<(LazyStateID, State)> {
                        match ::mem::replace(self, StateSaver::None) {
                            StateSaver::None | StateSaver::Saved(_) => None,
                            StateSaver::ToSave { id, state } => Some((id, state)),
                        }
                    }
                    fn take_saved(&mut self) -> Option<LazyStateID> {
                        match ::mem::replace(self, StateSaver::None) {
                            StateSaver::None => None,
                            StateSaver::Saved(id) | StateSaver::ToSave { id, .. } => Some(id),
                        }
                    }
                }

                #[derive( Clone, Debug, Default )]
                pub struct Config {
                    match_kind:Option<MatchKind>,
                    pre:Option<Option<Prefilter>>,
                    starts_for_each_pattern:Option<bool>,
                    byte_classes:Option<bool>,
                    unicode_word_boundary:Option<bool>,
                    quitset:Option<ByteSet>,
                    specialize_start_states:Option<bool>,
                    cache_capacity:Option<usize>,
                    skip_cache_capacity_check:Option<bool>,
                    minimum_cache_clear_count:Option<Option<usize>>,
                    minimum_bytes_per_state:Option<Option<usize>>,
                }

                impl Config
                {
                    pub fn new() -> Config {
                        Config::default()
                    }

                    pub fn match_kind( mut self, kind: MatchKind) -> Config {
                        self.match_kind = Some(kind);
                        self
                    }

                    pub fn prefilter( mut self, pre:Option<Prefilter>) -> Config {
                        self.pre = Some(pre);
                        if self.specialize_start_states.is_none() {
                            self.specialize_start_states =
                                Some( self.get_prefilter().is_some());
                        }
                        self
                    }

                    pub fn starts_for_each_pattern( mut self, yes:bool ) -> Config {
                        self.starts_for_each_pattern = Some(yes);
                        self
                    }

                    pub fn byte_classes( mut self, yes:bool ) -> Config {
                        self.byte_classes = Some(yes);
                        self
                    }

                    pub fn unicode_word_boundary( mut self, yes:bool ) -> Config {
                        self.unicode_word_boundary = Some(yes);
                        self
                    }

                    pub fn quit( mut self, byte: u8, yes:bool ) -> Config {
                        if self.get_unicode_word_boundary() && !byte.is_ascii() && !yes {
                            panic!(
                                "cannot set non-ASCII byte to be non-quit when \
                                Unicode word boundaries are enabled"
                            );
                        }
                        if self.quitset.is_none() {
                            self.quitset = Some(ByteSet::empty());
                        }
                        if yes {
                            self.quitset.as_mut().unwrap().add( byte );
                        } else {
                            self.quitset.as_mut().unwrap().remove( byte );
                        }
                        self
                    }
                    
                    pub fn specialize_start_states( mut self, yes:bool ) -> Config {
                        self.specialize_start_states = Some(yes);
                        self
                    }

                    pub fn cache_capacity( mut self, bytes: usize) -> Config {
                        self.cache_capacity = Some(bytes);
                        self
                    }
                    
                    pub fn skip_cache_capacity_check( mut self, yes:bool ) -> Config {
                        self.skip_cache_capacity_check = Some(yes);
                        self
                    }

                    pub fn minimum_cache_clear_count( mut self, min:Option<usize>) -> Config {
                        self.minimum_cache_clear_count = Some(min);
                        self
                    }

                    pub fn minimum_bytes_per_state( mut self, min:Option<usize>) -> Config {
                        self.minimum_bytes_per_state = Some(min);
                        self
                    }

                    pub fn get_match_kind( &self ) -> MatchKind { self.match_kind.unwrap_or(MatchKind::LeftmostFirst) }

                    pub fn get_prefilter( &self ) -> Option<&Prefilter> { self.pre.as_ref().unwrap_or( &None ).as_ref() }

                    pub fn get_starts_for_each_pattern( &self ) -> bool { self.starts_for_each_pattern.unwrap_or( false ) }

                    pub fn get_byte_classes( &self ) -> bool { self.byte_classes.unwrap_or(true) }

                    pub fn get_unicode_word_boundary( &self ) -> bool { self.unicode_word_boundary.unwrap_or( false ) }

                    pub fn get_quit(&self, byte: u8) -> bool {
                        self.quitset.map_or(false, |q| q.contains( byte ))
                    }

                    pub fn get_specialize_start_states( &self ) -> bool { self.specialize_start_states.unwrap_or( false ) }

                    pub fn get_cache_capacity( &self ) -> usize { self.cache_capacity.unwrap_or(2 * (1 << 20)) }

                    pub fn get_skip_cache_capacity_check( &self ) -> bool { self.skip_cache_capacity_check.unwrap_or( false ) }

                    pub fn get_minimum_cache_clear_count( &self ) -> Option<usize> { self.minimum_cache_clear_count.unwrap_or( None ) }

                    pub fn get_minimum_bytes_per_state( &self ) -> Option<usize> { self.minimum_bytes_per_state.unwrap_or( None ) }

                    pub fn get_minimum_cache_capacity(
                        &self,
                        nfa: &thompson::NFA,
                    ) -> Result<usize, BuildError>
                    {
                        let quitset = self.quit_set_from_nfa(nfa)?;
                        let classes = self.byte_classes_from_nfa(nfa, &quitset);
                        let starts = self.get_starts_for_each_pattern();
                        Ok(minimum_cache_capacity(nfa, &classes, starts))
                    }

                    fn byte_classes_from_nfa(
                        &self,
                        nfa: &thompson::NFA,
                        quit: &ByteSet,
                    ) -> ByteClasses {
                        if !self.get_byte_classes() {
                            ByteClasses::singletons()
                        } else {
                            let mut set = nfa.byte_class_set().clone();
                            if !quit.is_empty() {
                                set.add_set(&quit);
                            }
                            set.byte_classes()
                        }
                    }

                    fn quit_set_from_nfa(
                        &self,
                        nfa: &thompson::NFA,
                    ) -> Result<ByteSet, BuildError>
                    {
                        let mut quit = self.quitset.unwrap_or(ByteSet::empty());
                        if nfa.look_set_any().contains_word_unicode() {
                            if self.get_unicode_word_boundary() {
                                for b in 0x80..=0xFF {
                                    quit.add(b);
                                }
                            } else {
                                if !quit.contains_range(0x80, 0xFF) {
                                    return Err(
                                        BuildError::unsupported_dfa_word_boundary_unicode(),
                                    );
                                }
                            }
                        }
                        Ok(quit)
                    }

                    fn overwrite(&self, o: Config) -> Config {
                        Config {
                            match_kind: o.match_kind.or( self.match_kind),
                            pre: o.pre.or_else(|| self.pre.clone()),
                            starts_for_each_pattern: o
                                .starts_for_each_pattern
                                .or( self.starts_for_each_pattern),
                            byte_classes: o.byte_classes.or( self.byte_classes),
                            unicode_word_boundary: o
                                .unicode_word_boundary
                                .or( self.unicode_word_boundary),
                            quitset: o.quitset.or( self.quitset),
                            specialize_start_states: o
                                .specialize_start_states
                                .or( self.specialize_start_states),
                            cache_capacity: o.cache_capacity.or( self.cache_capacity),
                            skip_cache_capacity_check: o
                                .skip_cache_capacity_check
                                .or( self.skip_cache_capacity_check),
                            minimum_cache_clear_count: o
                                .minimum_cache_clear_count
                                .or( self.minimum_cache_clear_count),
                            minimum_bytes_per_state: o
                                .minimum_bytes_per_state
                                .or( self.minimum_bytes_per_state),
                        }
                    }
                }

                #[derive( Clone, Debug )]
                pub struct Builder {
                    config: Config,
                    thompson: thompson::Compiler,
                }

                impl Builder
                {
                    pub fn new() -> Builder {
                        Builder {
                            config: Config::default(),
                                    thompson: thompson::Compiler::new(),
                        }
                    }

                    pub fn build(&self, pattern: &str) -> Result<DFA, BuildError> { self.build_many(&[pattern]) }

                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<DFA, BuildError>
                    {
                        let nfa = self
                            .thompson
                            .clone()
                            .configure(
                                thompson::Config::new()
                                    .which_captures(thompson::WhichCaptures::None),
                            )
                            .build_many(patterns)
                            .map_err(BuildError::nfa)?;
                        self.build_from_nfa(nfa)
                    }

                    pub fn build_from_nfa(
                        &self,
                        nfa: thompson::NFA,
                    ) -> Result<DFA, BuildError>
                    {
                        let quitset = self.config.quit_set_from_nfa(&nfa)?;
                        let classes = self.config.byte_classes_from_nfa(&nfa, &quitset);
                        
                        let min_cache = minimum_cache_capacity(
                            &nfa,
                            &classes,
                            self.config.get_starts_for_each_pattern(),
                        );
                        let mut cache_capacity = self.config.get_cache_capacity();
                        if cache_capacity < min_cache {
                            if self.config.get_skip_cache_capacity_check() {
                                cache_capacity = min_cache;
                            } else {
                                return Err(BuildError::insufficient_cache_capacity(
                                    min_cache,
                                    cache_capacity,
                                ));
                            }
                        }
                        
                        if let Err(err) = minimum_lazy_state_id(&classes) {
                            return Err(BuildError::insufficient_state_id_capacity(err));
                        }
                        let stride2 = classes.stride2();
                        let start_map = StartByteMap::new(nfa.look_matcher());
                        Ok(DFA {
                            config: self.config.clone(),
                            nfa,
                            stride2,
                            start_map,
                            classes,
                            quitset,
                            cache_capacity,
                        })
                    }

                    pub fn configure( &mut self, config: Config) -> &mut Builder {
                        self.config = self.config.overwrite(config);
                        self
                    }

                    pub fn syntax(
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.thompson.syntax(config);
                        self
                    }

                    pub fn thompson( &mut self, config: thompson::Config) -> &mut Builder {
                        self.thompson.configure(config);
                        self
                    }
                }

                #[derive( Clone, Debug, Eq, PartialEq )]
                pub struct OverlappingState
                {
                    pub mat:Option<HalfMatch>,
                    pub id:Option<LazyStateID>,
                    pub at: usize,
                    pub next_match_index:Option<usize>,
                    pub rev_eoi: bool,
                }

                impl OverlappingState
                {
                    pub fn start() -> OverlappingState {
                        OverlappingState {
                            mat: None,
                            id: None,
                            at: 0,
                            next_match_index: None,
                            rev_eoi: false,
                        }
                    }

                    pub fn get_match( &self ) -> Option<HalfMatch> { self.mat }
                }

                #[cold] #[inline( never )] fn skip_empty_utf8_splits_overlapping<F>(
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                    mut search: F,
                ) -> Result<(), MatchError> where
                F: FnMut(&Input<'_>, &mut OverlappingState) -> Result<(), MatchError>,
                {
                    let mut hm = match state.get_match() {
                        None => return Ok( () ),
                        Some(hm) => hm,
                    };
                    if input.get_anchored().is_anchored() {
                        if !input.is_char_boundary(hm.offset()) {
                            state.mat = None;
                        }
                        return Ok( () );
                    }
                    while !input.is_char_boundary(hm.offset()) {
                        search(input, state)?;
                        hm = match state.get_match() {
                            None => return Ok( () ),
                            Some(hm) => hm,
                        };
                    }
                    Ok( () )
                }
                fn minimum_lazy_state_id(
                    classes: &ByteClasses,
                ) -> Result<LazyStateID, LazyStateIDError> {
                    let stride = 1 << classes.stride2();
                    let min_state_index = MIN_STATES.checked_sub(1).unwrap();
                    LazyStateID::new(min_state_index * stride)
                }
                fn minimum_cache_capacity(
                    nfa: &thompson::NFA,
                    classes: &ByteClasses,
                    starts_for_each_pattern: bool,
                ) -> usize {
                    const ID_SIZE: usize = size_of::<LazyStateID>();
                    const STATE_SIZE: usize = size_of::<State>();

                    let stride = 1 << classes.stride2();
                    let states_len = nfa.states().len();
                    let sparses = 2 * states_len * NFAStateID::SIZE;
                    let trans = MIN_STATES * stride * ID_SIZE;

                    let mut starts = Start::len() * ID_SIZE;
                    if starts_for_each_pattern {
                        starts += (Start::len() * nfa.pattern_len()) * ID_SIZE;
                    }
                    assert!(MIN_STATES >= 5, "minimum number of states has to be at least 5");
                    let non_sentinel = MIN_STATES.checked_sub(SENTINEL_STATES).unwrap();
                    //
                    // small.
                    let dead_state_size = State::dead().memory_usage();
                    let max_state_size = 5 + 4 + (nfa.pattern_len() * 4) + (states_len * 5);
                    let states = (SENTINEL_STATES * (STATE_SIZE + dead_state_size))
                        + (non_sentinel * (STATE_SIZE + max_state_size));
                    let states_to_sid = (MIN_STATES * STATE_SIZE) + (MIN_STATES * ID_SIZE);
                    let stack = states_len * NFAStateID::SIZE;
                    let scratch_state_builder = max_state_size;

                    trans
                        + starts
                        + states
                        + states_to_sid
                        + sparses
                        + stack
                        + scratch_state_builder
                }
            }
            
            pub mod error
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use crate::{hybrid::id::LazyStateIDError, nfa, util::search::Anchored};
                */
                #[derive( Clone, Debug )]
                pub struct BuildError 
                {
                    kind: BuildErrorKind,
                }

                #[derive( Clone, Debug )]
                pub enum BuildErrorKind 
                {
                    NFA(nfa::thompson::BuildError),
                    InsufficientCacheCapacity { minimum: usize, given: usize },
                    InsufficientStateIDCapacity { err: LazyStateIDError },
                    Unsupported(&'static str),
                }

                impl BuildError
                {
                    pub fn nfa(err: nfa::thompson::BuildError) -> BuildError {
                        BuildError { kind: BuildErrorKind::NFA(err) }
                    }

                    pub fn insufficient_cache_capacity(
                        minimum: usize,
                        given: usize,
                    ) -> BuildError {
                        BuildError {
                            kind: BuildErrorKind::InsufficientCacheCapacity { minimum, given },
                        }
                    }

                    pub fn insufficient_state_id_capacity(
                        err: LazyStateIDError,
                    ) -> BuildError {
                        BuildError {
                            kind: BuildErrorKind::InsufficientStateIDCapacity { err },
                        }
                    }

                    pub fn unsupported_dfa_word_boundary_unicode() -> BuildError {
                        let msg = "cannot build lazy DFAs for regexes with Unicode word \
                                boundaries; switch to ASCII word boundaries, or \
                                heuristically enable Unicode word boundaries or use a \
                                different regex engine";
                        BuildError { kind: BuildErrorKind::Unsupported(msg) }
                    }
                }
                
                impl ::error::Error for BuildError
                {
                    fn source( &self ) -> Option<&(dyn std::error::Error + 'static)>
                    {
                        match self.kind {
                            BuildErrorKind::NFA(ref err) => Some(err),
                            _ => None,
                        }
                    }
                }

                impl ::fmt::Display for BuildError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result 
                    {
                        match self.kind 
                        {
                            BuildErrorKind::NFA(_) => write!(f, "error building NFA"),
                            BuildErrorKind::InsufficientCacheCapacity { minimum, given } => {
                                write!(
                                    f,
                                    "given cache capacity ({given}) is smaller than \
                                    minimum required ({minimum})",
                                )
                            }
                            BuildErrorKind::InsufficientStateIDCapacity { ref err } => { err.fmt(f) }
                            BuildErrorKind::Unsupported(ref msg) => { write!(f, "unsupported regex feature for DFAs: {msg}") }
                        }
                    }
                }
                #[non_exhaustive] #[derive( Clone, Debug )]
                pub enum StartError {
                    Cache {

                        err: CacheError,
                    },
                    Quit {

                        byte: u8,
                    },
                    UnsupportedAnchored {

                        mode: Anchored,
                    },
                }

                impl StartError
                {
                    pub fn cache(err: CacheError) -> StartError {
                        StartError::Cache { err }
                    }

                    pub fn quit(byte: u8) -> StartError {
                        StartError::Quit { byte }
                    }

                    pub fn unsupported_anchored(mode: Anchored) -> StartError {
                        StartError::UnsupportedAnchored { mode }
                    }
                }

                        impl ::error::Error for StartError
                {
                    fn source( &self ) -> Option<&(dyn std::error::Error + 'static)> {
                        match *self {
                            StartError::Cache { ref err } => Some(err),
                            _ => None,
                        }
                    }
                }

                impl ::fmt::Display for StartError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        match *self {
                            StartError::Cache { .. } => write!(
                                f,
                                "error computing start state because of cache inefficiency"
                            ),
                            StartError::Quit { byte } => write!(
                                f,
                                "error computing start state because the look-behind byte \
                                {:?} triggered a quit state",
                                crate::util::escape::DebugByte( byte ),
                            ),
                            StartError::UnsupportedAnchored { mode: Anchored::Yes } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    anchored searches are not supported or enabled"
                                )
                            }
                            StartError::UnsupportedAnchored { mode: Anchored::No } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    unanchored searches are not supported or enabled"
                                )
                            }
                            StartError::UnsupportedAnchored {
                                mode: Anchored::Pattern(pid),
                            } => {
                                write!(
                                    f,
                                    "error computing start state because \
                                    anchored searches for a specific pattern ({}) \
                                    are not supported or enabled",
                                    pid.as_usize(),
                                )
                            }
                        }
                    }
                }
                
                #[derive( Clone, Debug )]
                pub struct CacheError( () );

                impl CacheError
                {
                    pub fn too_many_cache_clears() -> CacheError {
                        CacheError( () )
                    }

                    pub fn bad_efficiency() -> CacheError {
                        CacheError( () )
                    }
                }

                        impl ::error::Error for CacheError {}

                impl ::fmt::Display for CacheError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                    {
                        write!(f, "lazy DFA cache has been cleared too many times")
                    }
                }
            }
            
            pub mod id
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */

                #[derive(
                    Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
                )]
                pub struct LazyStateID(u32);

                impl LazyStateID 
                {
                    #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
                    const MAX_BIT: usize = 31;
                    #[cfg(target_pointer_width = "16")]
                    const MAX_BIT: usize = 15;
                    const MASK_UNKNOWN: usize = 1 << (LazyStateID::MAX_BIT);
                    const MASK_DEAD: usize = 1 << (LazyStateID::MAX_BIT - 1);
                    const MASK_QUIT: usize = 1 << (LazyStateID::MAX_BIT - 2);
                    const MASK_START: usize = 1 << (LazyStateID::MAX_BIT - 3);
                    const MASK_MATCH: usize = 1 << (LazyStateID::MAX_BIT - 4);
                    pub const MAX: usize = LazyStateID::MASK_MATCH - 1;
                    #[inline] pub fn new(id: usize) -> Result<LazyStateID, LazyStateIDError> 
                    {
                        if id > LazyStateID::MAX {
                            let attempted = u64::try_from(id).unwrap();
                            return Err(LazyStateIDError { attempted });
                        }
                        Ok(LazyStateID::new_unchecked(id))
                    }
                    #[inline] const fn new_unchecked(id: usize) -> LazyStateID {
                        LazyStateID(id as u32)
                    }
                    #[inline] pub fn as_usize_untagged( &self ) -> usize { self.as_usize_unchecked() & LazyStateID::MAX }
                    #[inline] pub const fn as_usize_unchecked( &self ) -> usize { self.0 as usize }
                    #[inline] pub const fn to_unknown( &self ) -> LazyStateID {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_UNKNOWN,
                        )
                    }

                    #[inline] pub const fn to_dead( &self ) -> LazyStateID {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_DEAD,
                        )
                    }

                    #[inline] pub const fn to_quit( &self ) -> LazyStateID {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_QUIT,
                        )
                    }

                    #[inline] pub const fn to_start( &self ) -> LazyStateID {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_START,
                        )
                    }

                    #[inline] pub const fn to_match( &self ) -> LazyStateID 
                    {
                        LazyStateID::new_unchecked(
                            self.as_usize_unchecked() | LazyStateID::MASK_MATCH,
                        )
                    }
                    #[inline] pub const fn is_tagged( &self ) -> bool { self.as_usize_unchecked() > LazyStateID::MAX }
                    #[inline] pub const fn is_unknown( &self ) -> bool { self.as_usize_unchecked() & LazyStateID::MASK_UNKNOWN > 0 }
                    #[inline] pub const fn is_dead( &self ) -> bool { self.as_usize_unchecked() & LazyStateID::MASK_DEAD > 0 }
                    #[inline] pub const fn is_quit( &self ) -> bool { self.as_usize_unchecked() & LazyStateID::MASK_QUIT > 0 }
                    #[inline] pub const fn is_start( &self ) -> bool { self.as_usize_unchecked() & LazyStateID::MASK_START > 0 }
                    #[inline] pub const fn is_match( &self ) -> bool { self.as_usize_unchecked() & LazyStateID::MASK_MATCH > 0 }
                }
                
                #[derive( Clone, Debug, Eq, PartialEq )]
                pub struct LazyStateIDError {
                    attempted: u64,
                }

                impl LazyStateIDError
                {
                    pub fn attempted( &self ) -> u64 { self.attempted }
                }
                
                impl ::error::Error for LazyStateIDError {}

                impl ::fmt::Display for LazyStateIDError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result
                    {
                        write!(
                            f,
                            "failed to create LazyStateID from {:?}, which exceeds {:?}",
                            self.attempted(),
                            LazyStateID::MAX,
                        )
                    }
                }
            }
            
            pub mod regex
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use crate::{
                    hybrid::{
                        dfa::{self, DFA},
                        error::BuildError,
                    },
                    nfa::thompson,
                    util::{
                        iter,
                        search::{Anchored, Input, Match, MatchError, MatchKind},
                    },
                };
                */
                #[derive( Debug )]
                pub struct Regex {

                    forward: DFA,
                    reverse: DFA,
                }

                impl Regex
                {
                    pub fn new(pattern: &str) -> Result<Regex, BuildError> { Regex::builder().build(pattern) }
                    
                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> { Regex::builder().build_many(patterns) }
                    
                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                    
                    pub fn create_cache( &self ) -> Cache { Cache::new(self) }
                    
                    pub fn reset_cache(&self, cache: &mut Cache) {
                        self.forward().reset_cache(&mut cache.forward);
                        self.reverse().reset_cache(&mut cache.reverse);
                    }
                }

                impl Regex {

                    #[inline] pub fn is_match<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                    ) -> bool {
                        self.forward()
                            .try_search_fwd(&mut cache.forward, &input.into().earliest(true))
                            .unwrap()
                            .is_some()
                    }
                    
                    #[inline] pub fn find<'h, I: Into<Input<'h>>>(
                        &self,
                        cache: &mut Cache,
                        input: I,
                    ) -> Option<Match> { self.try_search(cache, &input.into()).unwrap() }
                    
                    #[inline] pub fn find_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        cache: &'c mut Cache,
                        input: I,
                    ) -> FindMatches<'r, 'c, 'h>
                    {
                        let it = iter::Searcher::new(input.into());
                        FindMatches { re: self, cache, it }
                    }
                }
                impl Regex {
                    #[inline] pub fn try_search(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, MatchError>
                    {
                        let (fcache, rcache) = (&mut cache.forward, &mut cache.reverse);
                        let end = match self.forward().try_search_fwd(fcache, input)? {
                            None => return Ok( None ),
                            Some(end) => end,
                        };
                        if input.start() == end.offset() {
                            return Ok(Some(Match::new(
                                end.pattern(),
                                end.offset()..end.offset(),
                            )));
                        }

                        if self.is_anchored(input) {
                            return Ok(Some(Match::new(
                                end.pattern(),
                                input.start()..end.offset(),
                            )));
                        }
                        
                        let revsearch = input
                            .clone()
                            .span(input.start()..end.offset())
                            .anchored(Anchored::Yes)
                            .earliest( false );
                        let start = self
                            .reverse()
                            .try_search_rev(rcache, &revsearch)?
                            .expect("reverse search must match if forward search does");
                        debug_assert_eq!(
                            start.pattern(),
                            end.pattern(),
                            "forward and reverse search must match same pattern",
                        );
                        debug_assert!(start.offset() <= end.offset());
                        Ok(Some(Match::new(end.pattern(), start.offset()..end.offset())))
                    }
                    fn is_anchored(&self, input: &Input<'_>) -> bool {
                        match input.get_anchored() {
                            Anchored::No => { self.forward().get_nfa().is_always_start_anchored() }
                            Anchored::Yes | Anchored::Pattern(_) => true,
                        }
                    }
                }
                impl Regex
                {
                    pub fn forward( &self ) -> &DFA { &self.forward }
                    
                    pub fn reverse( &self ) -> &DFA { &self.reverse }

                    pub fn pattern_len( &self ) -> usize {
                        assert_eq!( self.forward().pattern_len(), self.reverse().pattern_len());
                        self.forward().pattern_len()
                    }
                }

                

                #[derive( Debug )]
                pub struct FindMatches<'r, 'c, 'h> {
                    re: &'r Regex,
                    cache: &'c mut Cache,
                    it: iter::Searcher<'h>,
                }

                impl<'r, 'c, 'h> Iterator for FindMatches<'r, 'c, 'h> {
                    type Item = Match;

                    #[inline] fn next(&mut self) -> Option<Match>
                    {
                        let FindMatches { re, ref mut cache, ref mut it } = *self;
                        it.advance(|input| re.try_search(cache, input))
                    }
                }

                #[derive(Debug, Clone)]
                pub struct Cache {
                    forward: dfa::Cache,
                    reverse: dfa::Cache,
                }

                impl Cache
                {
                    pub fn new(re: &Regex) -> Cache {
                        let forward = dfa::Cache::new(re.forward());
                        let reverse = dfa::Cache::new(re.reverse());
                        Cache { forward, reverse }
                    }
                    
                    pub fn reset( &mut self, re: &Regex) {
                        self.forward.reset(re.forward());
                        self.reverse.reset(re.reverse());
                    }

                    pub fn forward(&mut self) -> &dfa::Cache {
                        &self.forward
                    }

                    pub fn reverse(&mut self) -> &dfa::Cache {
                        &self.reverse
                    }
                    
                    pub fn forward_mut(&mut self) -> &mut dfa::Cache {
                        &mut self.forward
                    }
                    
                    pub fn reverse_mut(&mut self) -> &mut dfa::Cache {
                        &mut self.reverse
                    }

                    pub fn as_parts( &self ) -> (&dfa::Cache, &dfa::Cache) { (&self.forward, &self.reverse) }
                    
                    pub fn as_parts_mut(&mut self) -> (&mut dfa::Cache, &mut dfa::Cache) {
                        (&mut self.forward, &mut self.reverse)
                    }
                    
                    pub fn memory_usage( &self ) -> usize { self.forward.memory_usage() + self.reverse.memory_usage() }
                }

                #[derive( Clone, Debug )]
                pub struct Builder {
                    dfa: dfa::Builder,
                }

                impl Builder
                {
                    pub fn new() -> Builder {
                        Builder { dfa: DFA::builder() }
                    }
                    
                    pub fn build(&self, pattern: &str) -> Result<Regex, BuildError> { self.build_many(&[pattern]) }

                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<Regex, BuildError>
                    {
                        let forward = self.dfa.build_many(patterns)?;
                        let reverse = self
                            .dfa
                            .clone()
                            .configure(
                                DFA::config()
                                    .prefilter( None )
                                    .specialize_start_states( false )
                                    .match_kind(MatchKind::All),
                            )
                            .thompson(thompson::Config::new().reverse(true))
                            .build_many(patterns)?;
                        Ok( self.build_from_dfas(forward, reverse))
                    }
                    
                    pub fn build_from_dfas(&self, forward: DFA, reverse: DFA) -> Regex {
                        Regex { forward, reverse }
                    }
                    
                    pub fn syntax(
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        self.dfa.syntax(config);
                        self
                    }
                    
                    pub fn thompson( &mut self, config: thompson::Config) -> &mut Builder {
                        self.dfa.thompson(config);
                        self
                    }
                    
                    pub fn dfa( &mut self, config: dfa::Config) -> &mut Builder {
                        self.dfa.configure(config);
                        self
                    }
                }

                impl Default for Builder
                {
                    fn default() -> Builder {
                        Builder::new()
                    }
                }
            }
            
            pub mod search
            {
                /*!
                A lazy DFA backed `Regex`. */
                use ::
                {
                    *,
                };
                /*
                use crate::{
                    hybrid::{
                        dfa::{Cache, OverlappingState, DFA},
                        id::LazyStateID,
                    },
                    util::{
                        prefilter::Prefilter,
                        search::{HalfMatch, Input, MatchError, Span},
                    },
                };
                */
                #[inline(never)]
                pub fn find_fwd(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    if input.is_done() {
                        return Ok( None );
                    }
                    let pre = if input.get_anchored().is_anchored() {
                        None
                    } else {
                        dfa.get_config().get_prefilter()
                    };
                    if pre.is_some() {
                        if input.get_earliest() {
                            find_fwd_imp(dfa, cache, input, pre, true)
                        } else {
                            find_fwd_imp(dfa, cache, input, pre, false)
                        }
                    } else {
                        if input.get_earliest() {
                            find_fwd_imp(dfa, cache, input, None, true)
                        } else {
                            find_fwd_imp(dfa, cache, input, None, false)
                        }
                    }
                }

                #[inline( always )]
                fn find_fwd_imp(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    pre:Option<&'_ Prefilter>,
                    earliest: bool,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    // See 'prefilter_restart' docs for explanation.
                    let universal_start = dfa.get_nfa().look_set_prefix_any().is_empty();
                    let mut mat = None;
                    let mut sid = init_fwd(dfa, cache, input)?;
                    let mut at = input.start();
                    macro_rules! next_unchecked {
                        ($sid:expr, $at:expr) => {{
                            let byte = *input.haystack().get_unchecked($at);
                            dfa.next_state_untagged_unchecked(cache, $sid, byte)
                        }};
                    }

                    if let Some(ref pre) = pre {
                        let span = Span::from(at..input.end());
                        match pre.find(input.haystack(), span) {
                            None => return Ok(mat),
                            Some(ref span) => {
                                at = span.start;
                                if !universal_start {
                                    sid = prefilter_restart(dfa, cache, &input, at)?;
                                }
                            }
                        }
                    }
                    cache.search_start(at);
                    while at < input.end() {
                        if sid.is_tagged() {
                            cache.search_update(at);
                            sid = dfa
                                .next_state(cache, sid, input.haystack()[at])
                                .map_err(|_| gave_up(at))?;
                        } else {
                            //
                            //
                            //     regex-cli find half hybrid -p '(?m)^.+$' -UBb bigfile
                            //
                            //
                            //     regex-cli find half hybrid -p 'ZQZQZQZQ' -UBb bigfile
                            //
                            // And there are three different configurations:
                            //
                            //      unroll3: both the outer and inner loops below
                            //
                            //
                            //    unroll3   1.67s      1.45s        0.61s
                            //
                            //
                            //
                            // tagging be disabled when there isn't a prefilter!)
                            //
                            // loop unrolling that specifically targets self-transitions.
                            //
                            //
                            // NOTE: I used 'OpenSubtitles2018.raw.sample.en' for 'bigfile'.
                            //
                            // self-transition case.
                            let mut prev_sid = sid;
                            while at < input.end() {
                                prev_sid = unsafe { next_unchecked!(sid, at) };
                                if prev_sid.is_tagged() || at + 3 >= input.end() {
                                    ::mem::swap(&mut prev_sid, &mut sid);
                                    break;
                                }
                                at += 1;

                                sid = unsafe { next_unchecked!(prev_sid, at) };
                                if sid.is_tagged() {
                                    break;
                                }
                                at += 1;

                                prev_sid = unsafe { next_unchecked!(sid, at) };
                                if prev_sid.is_tagged() {
                                    ::mem::swap(&mut prev_sid, &mut sid);
                                    break;
                                }
                                at += 1;

                                sid = unsafe { next_unchecked!(prev_sid, at) };
                                if sid.is_tagged() {
                                    break;
                                }
                                at += 1;
                            }
                            // 'next_state', which will do NFA powerset construction for us.
                            if sid.is_unknown() {
                                cache.search_update(at);
                                sid = dfa
                                    .next_state(cache, prev_sid, input.haystack()[at])
                                    .map_err(|_| gave_up(at))?;
                            }
                        }
                        if sid.is_tagged() {
                            if sid.is_start() {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => {
                                            cache.search_finish(span.end);
                                            return Ok(mat);
                                        }
                                        Some(ref span) => {
                                            // candidate match.
                                            //
                                            // state has a self-loop, we can get stuck.
                                            if span.start > at {
                                                at = span.start;
                                                if !universal_start {
                                                    sid = prefilter_restart(
                                                        dfa, cache, &input, at,
                                                    )?;
                                                }
                                                continue;
                                            }
                                        }
                                    }
                                }
                            } else if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                mat = Some(HalfMatch::new(pattern, at));
                                if earliest {
                                    cache.search_finish(at);
                                    return Ok(mat);
                                }
                            } else if sid.is_dead() {
                                cache.search_finish(at);
                                return Ok(mat);
                            } else if sid.is_quit() {
                                cache.search_finish(at);
                                return Err(MatchError::quit(input.haystack()[at], at));
                            } else {
                                debug_assert!(sid.is_unknown());
                                unreachable!("sid being unknown is a bug");
                            }
                        }
                        at += 1;
                    }
                    eoi_fwd(dfa, cache, input, &mut sid, &mut mat)?;
                    cache.search_finish(input.end());
                    Ok(mat)
                }

                #[inline(never)]
                pub fn find_rev(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    if input.is_done() {
                        return Ok( None );
                    }
                    if input.get_earliest() {
                        find_rev_imp(dfa, cache, input, true)
                    } else {
                        find_rev_imp(dfa, cache, input, false)
                    }
                }

                #[inline( always )]
                fn find_rev_imp(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    earliest: bool,
                ) -> Result<Option<HalfMatch>, MatchError> {
                    let mut mat = None;
                    let mut sid = init_rev(dfa, cache, input)?;
                    if input.start() == input.end() {
                        eoi_rev(dfa, cache, input, &mut sid, &mut mat)?;
                        return Ok(mat);
                    }

                    let mut at = input.end() - 1;
                    macro_rules! next_unchecked {
                        ($sid:expr, $at:expr) => {{
                            let byte = *input.haystack().get_unchecked($at);
                            dfa.next_state_untagged_unchecked(cache, $sid, byte)
                        }};
                    }
                    cache.search_start(at);
                    loop {
                        if sid.is_tagged() {
                            cache.search_update(at);
                            sid = dfa
                                .next_state(cache, sid, input.haystack()[at])
                                .map_err(|_| gave_up(at))?;
                        } else {
                            // SAFETY: See comments in 'find_fwd' for a safety argument.
                            //
                            // difference. Take this command for example:
                            //
                            //     regex-cli find match hybrid -p '(?m)^.+$' -UBb bigfile
                            //
                            //
                            // the unrolling but add in bounds checks, then we get 2.86s.
                            //
                            // NOTE: I used 'OpenSubtitles2018.raw.sample.en' for 'bigfile'.
                            let mut prev_sid = sid;
                            while at >= input.start() {
                                prev_sid = unsafe { next_unchecked!(sid, at) };
                                if prev_sid.is_tagged()
                                    || at <= input.start().saturating_add(3)
                                {
                                    ::mem::swap(&mut prev_sid, &mut sid);
                                    break;
                                }
                                at -= 1;

                                sid = unsafe { next_unchecked!(prev_sid, at) };
                                if sid.is_tagged() {
                                    break;
                                }
                                at -= 1;

                                prev_sid = unsafe { next_unchecked!(sid, at) };
                                if prev_sid.is_tagged() {
                                    ::mem::swap(&mut prev_sid, &mut sid);
                                    break;
                                }
                                at -= 1;

                                sid = unsafe { next_unchecked!(prev_sid, at) };
                                if sid.is_tagged() {
                                    break;
                                }
                                at -= 1;
                            }
                            // 'next_state', which will do NFA powerset construction for us.
                            if sid.is_unknown() {
                                cache.search_update(at);
                                sid = dfa
                                    .next_state(cache, prev_sid, input.haystack()[at])
                                    .map_err(|_| gave_up(at))?;
                            }
                        }
                        if sid.is_tagged() {
                            if sid.is_start() {
                                // do nothing
                            } else if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                mat = Some(HalfMatch::new(pattern, at + 1));
                                if earliest {
                                    cache.search_finish(at);
                                    return Ok(mat);
                                }
                            } else if sid.is_dead() {
                                cache.search_finish(at);
                                return Ok(mat);
                            } else if sid.is_quit() {
                                cache.search_finish(at);
                                return Err(MatchError::quit(input.haystack()[at], at));
                            } else {
                                debug_assert!(sid.is_unknown());
                                unreachable!("sid being unknown is a bug");
                            }
                        }
                        if at == input.start() {
                            break;
                        }
                        at -= 1;
                    }
                    cache.search_finish(input.start());
                    eoi_rev(dfa, cache, input, &mut sid, &mut mat)?;
                    Ok(mat)
                }

                #[inline(never)]
                pub fn find_overlapping_fwd(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    state.mat = None;
                    if input.is_done() {
                        return Ok( () );
                    }
                    let pre = if input.get_anchored().is_anchored() {
                        None
                    } else {
                        dfa.get_config().get_prefilter()
                    };
                    if pre.is_some() {
                        find_overlapping_fwd_imp(dfa, cache, input, pre, state)
                    } else {
                        find_overlapping_fwd_imp(dfa, cache, input, None, state)
                    }
                }

                #[inline( always )]
                fn find_overlapping_fwd_imp(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    pre:Option<&'_ Prefilter>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    // See 'prefilter_restart' docs for explanation.
                    let universal_start = dfa.get_nfa().look_set_prefix_any().is_empty();
                    let mut sid = match state.id {
                        None => {
                            state.at = input.start();
                            init_fwd(dfa, cache, input)?
                        }
                        Some(sid) => {
                            if let Some(match_index) = state.next_match_index {
                                let match_len = dfa.match_len(cache, sid);
                                if match_index < match_len {
                                    state.next_match_index = Some(match_index + 1);
                                    let pattern = dfa.match_pattern(cache, sid, match_index);
                                    state.mat = Some(HalfMatch::new(pattern, state.at));
                                    return Ok( () );
                                }
                            }
                            state.at += 1;
                            if state.at > input.end() {
                                return Ok( () );
                            }
                            sid
                        }
                    };
                    cache.search_start(state.at);
                    while state.at < input.end() {
                        sid = dfa
                            .next_state(cache, sid, input.haystack()[state.at])
                            .map_err(|_| gave_up(state.at))?;
                        if sid.is_tagged() {
                            state.id = Some(sid);
                            if sid.is_start() {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(state.at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => return Ok( () ),
                                        Some(ref span) => {
                                            if span.start > state.at {
                                                state.at = span.start;
                                                if !universal_start {
                                                    sid = prefilter_restart(
                                                        dfa, cache, &input, state.at,
                                                    )?;
                                                }
                                                continue;
                                            }
                                        }
                                    }
                                }
                            } else if sid.is_match() {
                                state.next_match_index = Some(1);
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                state.mat = Some(HalfMatch::new(pattern, state.at));
                                cache.search_finish(state.at);
                                return Ok( () );
                            } else if sid.is_dead() {
                                cache.search_finish(state.at);
                                return Ok( () );
                            } else if sid.is_quit() {
                                cache.search_finish(state.at);
                                return Err(MatchError::quit(
                                    input.haystack()[state.at],
                                    state.at,
                                ));
                            } else {
                                debug_assert!(sid.is_unknown());
                                unreachable!("sid being unknown is a bug");
                            }
                        }
                        state.at += 1;
                        cache.search_update(state.at);
                    }

                    let result = eoi_fwd(dfa, cache, input, &mut sid, &mut state.mat);
                    state.id = Some(sid);
                    if state.mat.is_some() {
                        state.next_match_index = Some(1);
                    }
                    cache.search_finish(input.end());
                    result
                }

                #[inline(never)]
                pub fn find_overlapping_rev(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    state: &mut OverlappingState,
                ) -> Result<(), MatchError> {
                    state.mat = None;
                    if input.is_done() {
                        return Ok( () );
                    }
                    let mut sid = match state.id {
                        None => {
                            let sid = init_rev(dfa, cache, input)?;
                            state.id = Some(sid);
                            if input.start() == input.end() {
                                state.rev_eoi = true;
                            } else {
                                state.at = input.end() - 1;
                            }
                            sid
                        }
                        Some(sid) => {
                            if let Some(match_index) = state.next_match_index {
                                let match_len = dfa.match_len(cache, sid);
                                if match_index < match_len {
                                    state.next_match_index = Some(match_index + 1);
                                    let pattern = dfa.match_pattern(cache, sid, match_index);
                                    state.mat = Some(HalfMatch::new(pattern, state.at));
                                    return Ok( () );
                                }
                            }
                            if state.rev_eoi {
                                return Ok( () );
                            } else if state.at == input.start() {
                                // to the final 'eoi_rev' transition.
                                state.rev_eoi = true;
                            } else {
                                // We haven't hit the end of the search yet, so move on.
                                state.at -= 1;
                            }
                            sid
                        }
                    };
                    cache.search_start(state.at);
                    while !state.rev_eoi {
                        sid = dfa
                            .next_state(cache, sid, input.haystack()[state.at])
                            .map_err(|_| gave_up(state.at))?;
                        if sid.is_tagged() {
                            state.id = Some(sid);
                            if sid.is_start() {
                                // do nothing
                            } else if sid.is_match() {
                                state.next_match_index = Some(1);
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                state.mat = Some(HalfMatch::new(pattern, state.at + 1));
                                cache.search_finish(state.at);
                                return Ok( () );
                            } else if sid.is_dead() {
                                cache.search_finish(state.at);
                                return Ok( () );
                            } else if sid.is_quit() {
                                cache.search_finish(state.at);
                                return Err(MatchError::quit(
                                    input.haystack()[state.at],
                                    state.at,
                                ));
                            } else {
                                debug_assert!(sid.is_unknown());
                                unreachable!("sid being unknown is a bug");
                            }
                        }
                        if state.at == input.start() {
                            break;
                        }
                        state.at -= 1;
                        cache.search_update(state.at);
                    }

                    let result = eoi_rev(dfa, cache, input, &mut sid, &mut state.mat);
                    state.rev_eoi = true;
                    state.id = Some(sid);
                    if state.mat.is_some() {
                        state.next_match_index = Some(1);
                    }
                    cache.search_finish(input.start());
                    result
                }

                #[inline( always )]
                fn init_fwd(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                ) -> Result<LazyStateID, MatchError> {
                    let sid = dfa.start_state_forward(cache, input)?;
                    debug_assert!(!sid.is_match());
                    Ok(sid)
                }

                #[inline( always )]
                fn init_rev(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                ) -> Result<LazyStateID, MatchError> {
                    let sid = dfa.start_state_reverse(cache, input)?;
                    debug_assert!(!sid.is_match());
                    Ok(sid)
                }

                #[inline( always )]
                fn eoi_fwd(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    sid: &mut LazyStateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError> {
                    let sp = input.get_span();
                    match input.haystack().get(sp.end) {
                        Some(&b) => {
                            *sid =
                                dfa.next_state(cache, *sid, b).map_err(|_| gave_up(sp.end))?;
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, *sid, 0);
                                *mat = Some(HalfMatch::new(pattern, sp.end));
                            } else if sid.is_quit() {
                                return Err(MatchError::quit(b, sp.end));
                            }
                        }
                        None => {
                            *sid = dfa
                                .next_eoi_state(cache, *sid)
                                .map_err(|_| gave_up(input.haystack().len()))?;
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, *sid, 0);
                                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));
                            }
                            debug_assert!(!sid.is_quit());
                        }
                    }
                    Ok( () )
                }

                #[inline( always )]
                fn eoi_rev(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    sid: &mut LazyStateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError> {
                    let sp = input.get_span();
                    if sp.start > 0 {
                        let byte = input.haystack()[sp.start - 1];
                        *sid = dfa
                            .next_state(cache, *sid, byte)
                            .map_err(|_| gave_up(sp.start))?;
                        if sid.is_match() {
                            let pattern = dfa.match_pattern(cache, *sid, 0);
                            *mat = Some(HalfMatch::new(pattern, sp.start));
                        } else if sid.is_quit() {
                            return Err(MatchError::quit(byte, sp.start - 1));
                        }
                    } else {
                        *sid =
                            dfa.next_eoi_state(cache, *sid).map_err(|_| gave_up(sp.start))?;
                        if sid.is_match() {
                            let pattern = dfa.match_pattern(cache, *sid, 0);
                            *mat = Some(HalfMatch::new(pattern, 0));
                        }
                        debug_assert!(!sid.is_quit());
                    }
                    Ok( () )
                }

                #[inline( always )] fn prefilter_restart(
                    dfa: &DFA,
                    cache: &mut Cache,
                    input: &Input<'_>,
                    at: usize,
                ) -> Result<LazyStateID, MatchError> {
                    let mut input = input.clone();
                    input.set_start(at);
                    init_fwd(dfa, cache, &input)
                }

                #[inline( always )]
                fn gave_up(offset: usize) -> MatchError {
                    MatchError::gave_up(offset)
                }
            }
        }

        pub mod integers
        {
            /*!
            Provides several traits for converting between both fixed size integers and integers
            whose size varies based on the target (like `usize`).*/
            use ::
            {
                *,
            };
            /*
            */
            pub trait U8 {
                fn as_usize(self) -> usize;
            }

            impl U8 for u8 {
                fn as_usize(self) -> usize {
                    usize::from(self)
                }
            }

            pub trait U16 {
                fn as_usize(self) -> usize;
                fn low_u8(self) -> u8;
                fn high_u8(self) -> u8;
            }

            impl U16 for u16 {
                fn as_usize(self) -> usize {
                    usize::from(self)
                }

                fn low_u8(self) -> u8 {
                    self as u8
                }

                fn high_u8(self) -> u8 {
                    (self >> 8) as u8
                }
            }

            pub trait U32 {
                fn as_usize(self) -> usize;
                fn low_u8(self) -> u8;
                fn low_u16(self) -> u16;
                fn high_u16(self) -> u16;
            }

            impl U32 for u32 {
                fn as_usize(self) -> usize {
                    #[cfg(debug_assertions)]
                    {
                        usize::try_from(self).expect("u32 overflowed usize")
                    }
                    #[cfg(not(debug_assertions))]
                    {
                        self as usize
                    }
                }

                fn low_u8(self) -> u8 {
                    self as u8
                }

                fn low_u16(self) -> u16 {
                    self as u16
                }

                fn high_u16(self) -> u16 {
                    (self >> 16) as u16
                }
            }

            pub trait U64 {
                fn as_usize(self) -> usize;
                fn low_u8(self) -> u8;
                fn low_u16(self) -> u16;
                fn low_u32(self) -> u32;
                fn high_u32(self) -> u32;
            }

            impl U64 for u64 {
                fn as_usize(self) -> usize {
                    #[cfg(debug_assertions)]
                    {
                        usize::try_from(self).expect("u64 overflowed usize")
                    }
                    #[cfg(not(debug_assertions))]
                    {
                        self as usize
                    }
                }

                fn low_u8(self) -> u8 {
                    self as u8
                }

                fn low_u16(self) -> u16 {
                    self as u16
                }

                fn low_u32(self) -> u32 {
                    self as u32
                }

                fn high_u32(self) -> u32 {
                    (self >> 32) as u32
                }
            }

            pub trait I32 {
                fn as_usize(self) -> usize;
                fn to_bits(self) -> u32;
                fn from_bits(n: u32) -> i32;
            }

            impl I32 for i32 {
                fn as_usize(self) -> usize {
                    #[cfg(debug_assertions)]
                    {
                        usize::try_from(self).expect("i32 overflowed usize")
                    }
                    #[cfg(not(debug_assertions))]
                    {
                        self as usize
                    }
                }

                fn to_bits(self) -> u32 {
                    self as u32
                }

                fn from_bits(n: u32) -> i32 {
                    n as i32
                }
            }

            pub trait Usize {
                fn as_u8(self) -> u8;
                fn as_u16(self) -> u16;
                fn as_u32(self) -> u32;
                fn as_u64(self) -> u64;
            }

            impl Usize for usize {
                fn as_u8(self) -> u8 {
                    #[cfg(debug_assertions)]
                    {
                        u8::try_from(self).expect("usize overflowed u8")
                    }
                    #[cfg(not(debug_assertions))]
                    {
                        self as u8
                    }
                }

                fn as_u16(self) -> u16 {
                    #[cfg(debug_assertions)]
                    {
                        u16::try_from(self).expect("usize overflowed u16")
                    }
                    #[cfg(not(debug_assertions))]
                    {
                        self as u16
                    }
                }

                fn as_u32(self) -> u32 {
                    #[cfg(debug_assertions)]
                    {
                        u32::try_from(self).expect("usize overflowed u32")
                    }
                    #[cfg(not(debug_assertions))]
                    {
                        self as u32
                    }
                }

                fn as_u64(self) -> u64 {
                    #[cfg(debug_assertions)]
                    {
                        u64::try_from(self).expect("usize overflowed u64")
                    }
                    #[cfg(not(debug_assertions))]
                    {
                        self as u64
                    }
                }
            }
            // back to pointers.) So add 'as_usize' conversions here too for completeness.
            //

            pub trait Pointer {
                fn as_usize(self) -> usize;
            }

            impl<T> Pointer for *const T {
                fn as_usize(self) -> usize {
                    self as usize
                }
            }
        }
        
        pub mod meta
        {
            /*!
            Provides a regex matcher that composes several other regex matchers automatically.*/
            use ::
            {
                *,
            };
            /*
            */
            pub mod error
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use regex_syntax::{ast, hir};
                use crate::{nfa, util::search::MatchError, PatternID};
                */

                #[derive( Clone, Debug )]
                pub struct BuildError {
                    kind: BuildErrorKind,
                }

                #[derive( Clone, Debug )]
                enum BuildErrorKind {
                    Syntax { pid: PatternID, err: regex_syntax::Error },
                    NFA(nfa::thompson::BuildError),
                }

                impl BuildError
                {
                    pub fn pattern( &self ) -> Option<PatternID> {
                        match self.kind {
                            BuildErrorKind::Syntax { pid, .. } => Some(pid),
                            _ => None,
                        }
                    }
                    
                    pub fn size_limit( &self ) -> Option<usize> {
                        match self.kind {
                            BuildErrorKind::NFA(ref err) => err.size_limit(),
                            _ => None,
                        }
                    }
                    
                    pub fn syntax_error( &self ) -> Option<&regex_syntax::Error> {
                        match self.kind {
                            BuildErrorKind::Syntax { ref err, .. } => Some(err),
                            _ => None,
                        }
                    }

                    pub fn ast(pid: PatternID, err: ast::Error) -> BuildError {
                        let err = regex_syntax::Error::from(err);
                        BuildError { kind: BuildErrorKind::Syntax { pid, err } }
                    }

                    pub fn hir(pid: PatternID, err: hir::Error) -> BuildError {
                        let err = regex_syntax::Error::from(err);
                        BuildError { kind: BuildErrorKind::Syntax { pid, err } }
                    }

                    pub fn nfa(err: nfa::thompson::BuildError) -> BuildError {
                        BuildError { kind: BuildErrorKind::NFA(err) }
                    }
                }

                        impl ::error::Error for BuildError
                {
                    fn source( &self ) -> Option<&(dyn std::error::Error + 'static)>
                    {
                        match self.kind {
                            BuildErrorKind::Syntax { ref err, .. } => Some(err),
                            BuildErrorKind::NFA(ref err) => Some(err),
                        }
                    }
                }

                impl ::fmt::Display for BuildError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result 
                    {
                        match self.kind {
                            BuildErrorKind::Syntax { pid, .. } => { write!(f, "error parsing pattern {}", pid.as_usize()) }
                            BuildErrorKind::NFA(_) => write!(f, "error building NFA"),
                        }
                    }
                }

                #[derive( Debug )]
                pub enum RetryError {
                    Quadratic(RetryQuadraticError),
                    Fail(RetryFailError),
                }
                
                impl ::error::Error for RetryError {}

                impl ::fmt::Display for RetryError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        match *self {
                            RetryError::Quadratic(ref err) => err.fmt(f),
                            RetryError::Fail(ref err) => err.fmt(f),
                        }
                    }
                }

                impl From<MatchError> for RetryError
                {
                    fn from(merr: MatchError) -> RetryError {
                        RetryError::Fail(RetryFailError::from(merr))
                    }
                }
                
                #[derive( Debug )]
                pub struct RetryQuadraticError( () );

                impl RetryQuadraticError               
                {
                    pub fn new() -> RetryQuadraticError {
                        RetryQuadraticError( () )
                    }
                }
                
                impl ::error::Error for RetryQuadraticError {}

                impl ::fmt::Display for RetryQuadraticError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                    {
                        write!(f, "regex engine gave up to avoid quadratic behavior")
                    }
                }

                impl From<RetryQuadraticError> for RetryError
                {
                    fn from(err: RetryQuadraticError) -> RetryError {
                        RetryError::Quadratic(err)
                    }
                }
                
                #[derive( Debug )]
                pub struct RetryFailError {
                    offset: usize,
                }

                impl RetryFailError
                {
                    pub fn from_offset(offset: usize) -> RetryFailError {
                        RetryFailError { offset }
                    }
                }

                        impl ::error::Error for RetryFailError {}

                impl ::fmt::Display for RetryFailError
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                    {
                        write!(f, "regex engine failed at offset {:?}", self.offset)
                    }
                }

                impl From<RetryFailError> for RetryError
                {
                    fn from(err: RetryFailError) -> RetryError {
                        RetryError::Fail(err)
                    }
                }

                impl From<MatchError> for RetryFailError
                {
                    fn from(merr: MatchError) -> RetryFailError {
                        use crate::util::search::MatchErrorKind::*;

                        match *merr.kind() {
                            Quit { offset, .. } => RetryFailError::from_offset(offset),
                            GaveUp { offset } => RetryFailError::from_offset(offset),
                            HaystackTooLong { .. } | UnsupportedAnchored { .. } => { unreachable!("found impossible error in meta engine: {merr}") }
                        }
                    }
                }
            } pub use self::error::{ BuildError };

            pub mod limited
            {
                /*!
                This module defines two bespoke reverse DFA searching routines.*/
                use ::
                {
                    *,
                };
                /*
                use crate::{
                    meta::error::{RetryError, RetryQuadraticError},
                    HalfMatch, Input, MatchError,
                };
                */
                pub fn dfa_try_search_half_rev(
                    dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,
                    input: &Input<'_>,
                    min_start: usize,
                ) -> Result<Option<HalfMatch>, RetryError> {
                    use crate::dfa::Automaton;

                    let mut mat = None;
                    let mut sid = dfa.start_state_reverse(input)?;
                    if input.start() == input.end() {
                        dfa_eoi_rev(dfa, input, &mut sid, &mut mat)?;
                        return Ok(mat);
                    }
                    let mut at = input.end() - 1;
                    loop {
                        sid = dfa.next_state(sid, input.haystack()[at]);
                        if dfa.is_special_state(sid) {
                            if dfa.is_match_state(sid) {
                                let pattern = dfa.match_pattern(sid, 0);
                                mat = Some(HalfMatch::new(pattern, at + 1));
                            } else if dfa.is_dead_state(sid) {
                                return Ok(mat);
                            } else if dfa.is_quit_state(sid) {
                                return Err(MatchError::quit(input.haystack()[at], at).into());
                            }
                        }
                        if at == input.start() {
                            break;
                        }
                        at -= 1;
                        if at < min_start {
                            trace!(
                                "reached position {at} which is before the previous literal \
                                match, quitting to avoid quadratic behavior",
                            );
                            return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                        }
                    }
                    let was_dead = dfa.is_dead_state(sid);
                    dfa_eoi_rev(dfa, input, &mut sid, &mut mat)?;
                    //
                    // This only happens when all of the following are true:
                    //
                    // 3) The FSM reports we could possibly find a longer match.
                    //
                    //
                    //
                    // state by virtue of it represents the end-of-input.)
                    if at == input.start()
                        && mat.map_or(false, |m| m.offset() > input.start())
                        && !was_dead
                    {
                        trace!(
                            "reached beginning of search at offset {at} without hitting \
                            a dead state, quitting to avoid potential false positive match",
                        );
                        return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                    }
                    Ok(mat)
                }
                
                pub fn hybrid_try_search_half_rev(
                    dfa: &crate::hybrid::dfa::DFA,
                    cache: &mut crate::hybrid::dfa::Cache,
                    input: &Input<'_>,
                    min_start: usize,
                ) -> Result<Option<HalfMatch>, RetryError> {
                    let mut mat = None;
                    let mut sid = dfa.start_state_reverse(cache, input)?;
                    if input.start() == input.end() {
                        hybrid_eoi_rev(dfa, cache, input, &mut sid, &mut mat)?;
                        return Ok(mat);
                    }
                    let mut at = input.end() - 1;
                    loop {
                        sid = dfa
                            .next_state(cache, sid, input.haystack()[at])
                            .map_err(|_| MatchError::gave_up(at))?;
                        if sid.is_tagged() {
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                mat = Some(HalfMatch::new(pattern, at + 1));
                            } else if sid.is_dead() {
                                return Ok(mat);
                            } else if sid.is_quit() {
                                return Err(MatchError::quit(input.haystack()[at], at).into());
                            }
                        }
                        if at == input.start() {
                            break;
                        }
                        at -= 1;
                        if at < min_start {
                            trace!(
                                "reached position {at} which is before the previous literal \
                                match, quitting to avoid quadratic behavior",
                            );
                            return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                        }
                    }
                    let was_dead = sid.is_dead();
                    hybrid_eoi_rev(dfa, cache, input, &mut sid, &mut mat)?;
                    if at == input.start()
                        && mat.map_or(false, |m| m.offset() > input.start())
                        && !was_dead
                    {
                        trace!(
                            "reached beginning of search at offset {at} without hitting \
                            a dead state, quitting to avoid potential false positive match",
                        );
                        return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                    }
                    Ok(mat)
                }
                
                #[inline( always )]
                fn dfa_eoi_rev(
                    dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,
                    input: &Input<'_>,
                    sid: &mut crate::util::primitives::StateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError> {
                    use crate::dfa::Automaton;

                    let sp = input.get_span();
                    if sp.start > 0 {
                        let byte = input.haystack()[sp.start - 1];
                        *sid = dfa.next_state(*sid, byte);
                        if dfa.is_match_state(*sid) {
                            let pattern = dfa.match_pattern(*sid, 0);
                            *mat = Some(HalfMatch::new(pattern, sp.start));
                        } else if dfa.is_quit_state(*sid) {
                            return Err(MatchError::quit(byte, sp.start - 1));
                        }
                    } else {
                        *sid = dfa.next_eoi_state(*sid);
                        if dfa.is_match_state(*sid) {
                            let pattern = dfa.match_pattern(*sid, 0);
                            *mat = Some(HalfMatch::new(pattern, 0));
                        }
                        debug_assert!(!dfa.is_quit_state(*sid));
                    }
                    Ok( () )
                }

                #[inline( always )]
                fn hybrid_eoi_rev(
                    dfa: &crate::hybrid::dfa::DFA,
                    cache: &mut crate::hybrid::dfa::Cache,
                    input: &Input<'_>,
                    sid: &mut crate::hybrid::LazyStateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError> {
                    let sp = input.get_span();
                    if sp.start > 0 {
                        let byte = input.haystack()[sp.start - 1];
                        *sid = dfa
                            .next_state(cache, *sid, byte)
                            .map_err(|_| MatchError::gave_up(sp.start))?;
                        if sid.is_match() {
                            let pattern = dfa.match_pattern(cache, *sid, 0);
                            *mat = Some(HalfMatch::new(pattern, sp.start));
                        } else if sid.is_quit() {
                            return Err(MatchError::quit(byte, sp.start - 1));
                        }
                    } else {
                        *sid = dfa
                            .next_eoi_state(cache, *sid)
                            .map_err(|_| MatchError::gave_up(sp.start))?;
                        if sid.is_match() {
                            let pattern = dfa.match_pattern(cache, *sid, 0);
                            *mat = Some(HalfMatch::new(pattern, 0));
                        }
                        debug_assert!(!sid.is_quit());
                    }
                    Ok( () )
                }
            }

            pub mod literal
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use alloc::{vec, vec::Vec};
                use regex_syntax::hir::Hir;
                use crate::{meta::regex::RegexInfo, util::search::MatchKind};
                */
                pub fn alternation_literals(
                    info: &RegexInfo,
                    hirs: &[&Hir],
                ) -> Option<Vec<Vec<u8>>> {
                    use regex_syntax::hir::{HirKind, Literal};
                    
                    if !cfg!(feature = "perf-literal-multisubstring") {
                        return None;
                    }
                    
                    if hirs.len() != 1
                        || !info.props()[0].look_set().is_empty()
                        || info.props()[0].explicit_captures_len() > 0
                        || !info.props()[0].is_alternation_literal()
                        || info.config().get_match_kind() != MatchKind::LeftmostFirst
                    {
                        return None;
                    }
                    let hir = &hirs[0];
                    let alts = match *hir.kind() {
                        HirKind::Alternation(ref alts) => alts,
                        _ => return None, // one literal isn't worth it
                    };

                    let mut lits = vec![];
                    for alt in alts {
                        let mut lit = vec![];
                        match *alt.kind() {
                            HirKind::Literal(Literal(ref bytes)) => { lit.extend_from_slice(bytes) }
                            HirKind::Concat(ref exprs) => {
                                for e in exprs {
                                    match *e.kind() {
                                        HirKind::Literal(Literal(ref bytes)) => { lit.extend_from_slice(bytes); }
                                        _ => unreachable!("expected literal, got {e:?}"),
                                    }
                                }
                            }
                            _ => unreachable!("expected literal or concat, got {alt:?}"),
                        }
                        lits.push(lit);
                    }
                    
                    if lits.len() < 3000 {
                        return None;
                    }
                    Some(lits)
                }
            }

            pub mod regex
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use ::{
                    borrow::Borrow,
                    panic::{RefUnwindSafe, UnwindSafe},
                };

                use alloc::{boxed::Box, sync::Arc, vec, vec::Vec};

                use regex_syntax::{
                    ast,
                    hir::{self, Hir},
                };

                use crate::{
                    meta::{
                        error::BuildError,
                        strategy::{self, Strategy},
                        wrappers,
                    },
                    nfa::thompson::WhichCaptures,
                    util::{
                        captures::{Captures, GroupInfo},
                        iter,
                        pool::{Pool, PoolGuard},
                        prefilter::Prefilter,
                        primitives::{NonMaxUsize, PatternID},
                        search::{HalfMatch, Input, Match, MatchKind, PatternSet, Span},
                    },
                };
                */
                type CachePool = Pool<Cache, CachePoolFn>;

                type CachePoolGuard<'a> = PoolGuard<'a, Cache, CachePoolFn>;
                type CachePoolFn =
                    Box<dyn Fn() -> Cache + Send + Sync + UnwindSafe + RefUnwindSafe>;
                #[derive( Debug )]
                pub struct Regex {

                    imp: Arc<RegexI>,
                    pool: CachePool,
                }
                
                #[derive( Debug )]
                struct RegexI {

                    strat: Arc<dyn Strategy>,
                    info: RegexInfo,
                }

                impl Regex
                {
                    pub fn new(pattern: &str) -> Result<Regex, BuildError> { Regex::builder().build(pattern) }
                    
                    pub fn new_many<P: AsRef<str>>(
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> { Regex::builder().build_many(patterns) }
                    
                    pub fn config() -> Config {
                        Config::new()
                    }

                    pub fn builder() -> Builder {
                        Builder::new()
                    }
                }

                impl Regex {

                    ///

                    ///
                    ///

                    ///
                    ///
                    ///

                    ///
                    ///
                    ///

                    ///
                    ///
                    ///
                    ///
                    #[inline] pub fn is_match<'h, I: Into<Input<'h>>>(&self, input: I) -> bool {
                        let input = input.into().earliest(true);
                        if self.imp.info.is_impossible(&input) {
                            return false;
                        }
                        let mut guard = self.pool.get();
                        let result = self.imp.strat.is_match(&mut guard, &input);
                        PoolGuard::put(guard);
                        result
                    }
                    
                    #[inline] pub fn find<'h, I: Into<Input<'h>>>(&self, input: I) -> Option<Match> { self.search(&input.into()) }
                    
                    #[inline] pub fn captures<'h, I: Into<Input<'h>>>(
                        &self,
                        input: I,
                        caps: &mut Captures,
                    ) {
                        self.search_captures(&input.into(), caps)
                    }
                    
                    #[inline] pub fn find_iter<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                    ) -> FindMatches<'r, 'h>
                    {
                        let cache = self.pool.get();
                        let it = iter::Searcher::new(input.into());
                        FindMatches { re: self, cache, it }
                    }
                    ///

                    ///
                   #[inline] pub fn captures_iter<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                    ) -> CapturesMatches<'r, 'h>
                    {
                        let cache = self.pool.get();
                        let caps = self.create_captures();
                        let it = iter::Searcher::new(input.into());
                        CapturesMatches { re: self, cache, caps, it }
                    }
                    ///

                    ///

                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    #[inline] pub fn split<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                    ) -> Split<'r, 'h> { Split { finder: self.find_iter(input), last: 0 } }
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    ///
                    pub fn splitn<'r, 'h, I: Into<Input<'h>>>(
                        &'r self,
                        input: I,
                        limit: usize,
                    ) -> SplitN<'r, 'h> { SplitN { splits: self.split(input), limit } }
                }

                impl Regex {
                    #[inline] pub fn search(&self, input: &Input<'_>) -> Option<Match> {
                        if self.imp.info.captures_disabled()
                            || self.imp.info.is_impossible(input)
                        {
                            return None;
                        }
                        let mut guard = self.pool.get();
                        let result = self.imp.strat.search(&mut guard, input);
                        //
                        //
                        PoolGuard::put(guard);
                        result
                    }
                    ///
                    ///
                    #[inline] pub fn search_half(&self, input: &Input<'_>) -> Option<HalfMatch> {
                        if self.imp.info.captures_disabled()
                            || self.imp.info.is_impossible(input)
                        {
                            return None;
                        }
                        let mut guard = self.pool.get();
                        let result = self.imp.strat.search_half(&mut guard, input);
                        PoolGuard::put(guard);
                        result
                    }
                    
                    #[inline] pub fn search_captures(&self, input: &Input<'_>, caps: &mut Captures) {
                        caps.set_pattern( None );
                        let pid = self.search_slots(input, caps.slots_mut());
                        caps.set_pattern(pid);
                    }
                    
                    #[inline] pub fn search_slots(
                        &self,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if self.imp.info.captures_disabled()
                            || self.imp.info.is_impossible(input)
                        {
                            return None;
                        }
                        let mut guard = self.pool.get();
                        let result = self.imp.strat.search_slots(&mut guard, input, slots);
                        PoolGuard::put(guard);
                        result
                    }
                    
                    #[inline] pub fn which_overlapping_matches(
                        &self,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        if self.imp.info.is_impossible(input) { return; }
                        let mut guard = self.pool.get();
                        let result = self
                            .imp
                            .strat
                            .which_overlapping_matches(&mut guard, input, patset);
                        PoolGuard::put(guard);
                        result
                    }
                }
                impl Regex {
                    ///
                    #[inline] pub fn search_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<Match> {
                        if self.imp.info.captures_disabled()
                            || self.imp.info.is_impossible(input)
                        {
                            return None;
                        }
                        self.imp.strat.search(cache, input)
                    }
                    
                    #[inline] pub fn search_half_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        if self.imp.info.captures_disabled()
                            || self.imp.info.is_impossible(input)
                        {
                            return None;
                        }
                        self.imp.strat.search_half(cache, input)
                    }
                    
                    #[inline] pub fn search_captures_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        caps: &mut Captures,
                    ) {
                        caps.set_pattern( None );
                        let pid = self.search_slots_with(cache, input, caps.slots_mut());
                        caps.set_pattern(pid);
                    }
                    ///

                    #[inline] pub fn search_slots_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if self.imp.info.captures_disabled()
                            || self.imp.info.is_impossible(input)
                        {
                            return None;
                        }
                        self.imp.strat.search_slots(cache, input, slots)
                    }
                    
                    #[inline] pub fn which_overlapping_matches_with(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        if self.imp.info.is_impossible(input) { return; }
                        self.imp.strat.which_overlapping_matches(cache, input, patset)
                    }
                }
                impl Regex
                {
                    pub fn create_captures( &self ) -> Captures { Captures::all( self.group_info().clone()) }
                    ///
                    pub fn create_cache( &self ) -> Cache { self.imp.strat.create_cache() }
                    
                    pub fn pattern_len( &self ) -> usize { self.imp.info.pattern_len() }
                    ///
                    ///

                    ///
                    ///
                    ///
                    pub fn captures_len( &self ) -> usize {
                        self.imp
                            .info
                            .props_union()
                            .explicit_captures_len()
                            .saturating_add( self.pattern_len())
                    }
                    ///
                    ///

                    ///
                    ///
                    ///
                    #[inline] pub fn static_captures_len( &self ) -> Option<usize> {
                        self.imp
                            .info
                            .props_union()
                            .static_explicit_captures_len()
                            .map(|len| len.saturating_add(1))
                    }

                   #[inline] pub fn group_info( &self ) -> &GroupInfo { self.imp.strat.group_info() }
                    
                    #[inline] pub fn get_config( &self ) -> &Config { self.imp.info.config() }

                    ///
                    ///

                    #[inline] pub fn is_accelerated( &self ) -> bool { self.imp.strat.is_accelerated() }
                    
                    #[inline] pub fn memory_usage( &self ) -> usize { self.imp.strat.memory_usage() }
                }

                impl Clone for Regex
                {
                    fn clone( &self ) -> Regex {
                        let imp = Arc::clone(&self.imp);
                        let pool = {
                            let strat = Arc::clone(&imp.strat);
                            let create: CachePoolFn = Box::new(move || strat.create_cache());
                            Pool::new(create)
                        };
                        Regex { imp, pool }
                    }
                }

                #[derive( Clone, Debug )]
                pub struct RegexInfo(Arc<RegexInfoI>);

                #[derive( Clone, Debug )]
                struct RegexInfoI {
                    config: Config,
                    props: Vec<hir::Properties>,
                    props_union: hir::Properties,
                }

                impl RegexInfo
                {
                    fn new(config: Config, hirs: &[&Hir]) -> RegexInfo {
                        // as if they were in one big alternation.
                        let mut props = vec![];
                        for hir in hirs.iter() {
                            props.push(hir.properties().clone());
                        }
                        let props_union = hir::Properties::union(&props);

                        RegexInfo(Arc::new(RegexInfoI { config, props, props_union }))
                    }

                    pub fn config( &self ) -> &Config { &self.0.config }

                    pub fn props( &self ) -> &[hir::Properties] { &self.0.props }

                    pub fn props_union( &self ) -> &hir::Properties { &self.0.props_union }

                    pub fn pattern_len( &self ) -> usize { self.props().len() }

                    pub fn memory_usage( &self ) -> usize {
                        self.props().iter().map(|p| p.memory_usage()).sum::<usize>()
                            + self.props_union().memory_usage()
                    }
                    #[inline( always )]
                    pub fn is_anchored_start(&self, input: &Input<'_>) -> bool {
                        input.get_anchored().is_anchored() || self.is_always_anchored_start()
                    }
                    #[inline( always )]
                    pub fn is_always_anchored_start( &self ) -> bool {
                        use regex_syntax::hir::Look;
                        self.props_union().look_set_prefix().contains(Look::Start)
                    }
                    #[inline( always )]
                    pub fn is_always_anchored_end( &self ) -> bool {
                        use regex_syntax::hir::Look;
                        self.props_union().look_set_suffix().contains(Look::End)
                    }

                    fn captures_disabled( &self ) -> bool { matches!( self.config().get_which_captures(), WhichCaptures::None) }
                    #[inline( always )] fn is_impossible(&self, input: &Input<'_>) -> bool {
                        // match at position 0.
                        if input.start() > 0 && self.is_always_anchored_start() {
                            return true;
                        }

                        if input.end() < input.haystack().len()
                            && self.is_always_anchored_end()
                        {
                            return true;
                        }
                        let minlen = match self.props_union().minimum_len() {
                            None => return false,
                            Some(minlen) => minlen,
                        };
                        if input.get_span().len() < minlen {
                            return true;
                        }
                        // to match, we can bail early.
                        //
                        // I don't think we can apply the maximum otherwise unfortunately.
                        if self.is_anchored_start(input) && self.is_always_anchored_end() {
                            let maxlen = match self.props_union().maximum_len() {
                                None => return false,
                                Some(maxlen) => maxlen,
                            };
                            if input.get_span().len() > maxlen {
                                return true;
                            }
                        }
                        false
                    }
                }

                

                #[derive( Debug )]
                pub struct FindMatches<'r, 'h> {
                    re: &'r Regex,
                    cache: CachePoolGuard<'r>,
                    it: iter::Searcher<'h>,
                }

                impl<'r, 'h> FindMatches<'r, 'h> {

                    #[inline] pub fn regex( &self ) -> &'r Regex { self.re }
                    
                    #[inline] pub fn input<'s>(&'s self) -> &'s Input<'h> { self.it.input() }
                }

                impl<'r, 'h> Iterator for FindMatches<'r, 'h> {
                    type Item = Match;

                    #[inline] fn next(&mut self) -> Option<Match>
                    {
                        let FindMatches { re, ref mut cache, ref mut it } = *self;
                        it.advance(|input| Ok(re.search_with(cache, input)))
                    }

                    #[inline] fn count(self) -> usize {
                        let FindMatches { re, mut cache, it } = self;
                        
                        let cache = &mut *cache;
                        it.into_half_matches_iter(
                            |input| Ok(re.search_half_with(cache, input)),
                        )
                        .count()
                    }
                }

                impl<'r, 'h> ::iter::FusedIterator for FindMatches<'r, 'h> {}
                
                #[derive( Debug )]
                pub struct CapturesMatches<'r, 'h> {
                    re: &'r Regex,
                    cache: CachePoolGuard<'r>,
                    caps: Captures,
                    it: iter::Searcher<'h>,
                }

                impl<'r, 'h> CapturesMatches<'r, 'h> {

                    #[inline] pub fn regex( &self ) -> &'r Regex { self.re }
                    
                    #[inline] pub fn input<'s>(&'s self) -> &'s Input<'h> { self.it.input() }
                }

                impl<'r, 'h> Iterator for CapturesMatches<'r, 'h> {
                    type Item = Captures;

                    #[inline] fn next(&mut self) -> Option<Captures> {
                        // Splitting 'self' apart seems necessary to appease borrowck.
                        let CapturesMatches { re, ref mut cache, ref mut caps, ref mut it } =
                            *self;
                        let _ = it.advance(|input| {
                            re.search_captures_with(cache, input, caps);
                            Ok(caps.get_match())
                        });
                        if caps.is_match() {
                            Some(caps.clone())
                        } else {
                            None
                        }
                    }

                    #[inline] fn count(self) -> usize {
                        let CapturesMatches { re, mut cache, it, .. } = self;
                        
                        let cache = &mut *cache;
                        it.into_half_matches_iter(
                            |input| Ok(re.search_half_with(cache, input)),
                        )
                        .count()
                    }
                }

                impl<'r, 'h> ::iter::FusedIterator for CapturesMatches<'r, 'h> {}

                

                #[derive( Debug )]
                pub struct Split<'r, 'h> {
                    finder: FindMatches<'r, 'h>,
                    last: usize,
                }

                impl<'r, 'h> Split<'r, 'h> 
                {
                    #[inline] pub fn input<'s>(&'s self) -> &'s Input<'h> { self.finder.input() }
                }

                impl<'r, 'h> Iterator for Split<'r, 'h> {
                    type Item = Span;

                    fn next(&mut self) -> Option<Span> {
                        match self.finder.next() {
                            None => {
                                let len = self.finder.it.input().haystack().len();
                                if self.last > len {
                                    None
                                } else {
                                    let span = Span::from( self.last..len);
                                    self.last = len + 1; // Next call will return None
                                    Some(span)
                                }
                            }
                            Some(m) => {
                                let span = Span::from( self.last..m.start());
                                self.last = m.end();
                                Some(span)
                            }
                        }
                    }
                }

                impl<'r, 'h> ::iter::FusedIterator for Split<'r, 'h> {}

                ///

                #[derive( Debug )]
                pub struct SplitN<'r, 'h> {
                    splits: Split<'r, 'h>,
                    limit: usize,
                }

                impl<'r, 'h> SplitN<'r, 'h> {
                    #[inline] pub fn input<'s>(&'s self) -> &'s Input<'h> { self.splits.input() }
                }

                impl<'r, 'h> Iterator for SplitN<'r, 'h> {
                    type Item = Span;

                    fn next(&mut self) -> Option<Span> {
                        if self.limit == 0 {
                            return None;
                        }

                        self.limit -= 1;
                        if self.limit > 0 {
                            return self.splits.next();
                        }

                        let len = self.splits.finder.it.input().haystack().len();
                        if self.splits.last > len {
                            // We've already returned all substrings.
                            None
                        } else {
                            // self.n == 0, so future calls will return None immediately
                            Some(Span::from( self.splits.last..len))
                        }
                    }

                    fn size_hint( &self ) -> (usize, Option<usize>) { (0, Some( self.limit)) }
                }

                impl<'r, 'h> ::iter::FusedIterator for SplitN<'r, 'h> {}

                #[derive(Debug, Clone)]
                pub struct Cache {
                    pub capmatches: Captures,
                    pub pikevm: wrappers::PikeVMCache,
                    pub backtrack: wrappers::BoundedBacktrackerCache,
                    pub onepass: wrappers::OnePassCache,
                    pub hybrid: wrappers::HybridCache,
                    pub revhybrid: wrappers::ReverseHybridCache,
                }

                impl Cache
                {
                    pub fn new(re: &Regex) -> Cache {
                        re.create_cache()
                    }
                    
                    pub fn reset( &mut self, re: &Regex) {
                        re.imp.strat.reset_cache(self)
                    }
                    
                    pub fn memory_usage( &self ) -> usize {
                        let mut bytes = 0;
                        bytes += self.pikevm.memory_usage();
                        bytes += self.backtrack.memory_usage();
                        bytes += self.onepass.memory_usage();
                        bytes += self.hybrid.memory_usage();
                        bytes += self.revhybrid.memory_usage();
                        bytes
                    }
                }

                #[derive( Clone, Debug, Default )]
                pub struct Config {
                    match_kind:Option<MatchKind>,
                    utf8_empty:Option<bool>,
                    autopre:Option<bool>,
                    pre:Option<Option<Prefilter>>,
                    which_captures:Option<WhichCaptures>,
                    nfa_size_limit:Option<Option<usize>>,
                    onepass_size_limit:Option<Option<usize>>,
                    hybrid_cache_capacity:Option<usize>,
                    hybrid:Option<bool>,
                    dfa:Option<bool>,
                    dfa_size_limit:Option<Option<usize>>,
                    dfa_state_limit:Option<Option<usize>>,
                    onepass:Option<bool>,
                    backtrack:Option<bool>,
                    byte_classes:Option<bool>,
                    line_terminator:Option<u8>,
                }

                impl Config
                {
                    pub fn new() -> Config {
                        Config::default()
                    }
                    
                    pub fn match_kind(self, kind: MatchKind) -> Config {
                        Config { match_kind: Some(kind), ..self }
                    }
                    
                    pub fn utf8_empty(self, yes:bool ) -> Config {
                        Config { utf8_empty: Some(yes), ..self }
                    }

                    pub fn auto_prefilter(self, yes:bool ) -> Config {
                        Config { autopre: Some(yes), ..self }
                    }

                    ///

                    ///
                    ///
                    ///
                    ///
                    pub fn prefilter(self, pre:Option<Prefilter>) -> Config {
                        Config { pre: Some(pre), ..self }
                    }
                    ///
                    ///
                    ///
                    ///
                    ///

                    ///
                    ///
                    ///
                    ///
                    ///
                    pub fn which_captures( mut self, which_captures: WhichCaptures) -> Config {
                        self.which_captures = Some(which_captures);
                        self
                    }
                    ///
                    pub fn nfa_size_limit(self, limit:Option<usize>) -> Config {
                        Config { nfa_size_limit: Some(limit), ..self }
                    }

                    pub fn onepass_size_limit(self, limit:Option<usize>) -> Config {
                        Config { onepass_size_limit: Some(limit), ..self }
                    }

                    pub fn hybrid_cache_capacity(self, limit: usize) -> Config {
                        Config { hybrid_cache_capacity: Some(limit), ..self }
                    }
                    
                    pub fn dfa_size_limit(self, limit:Option<usize>) -> Config {
                        Config { dfa_size_limit: Some(limit), ..self }
                    }
                    
                    pub fn dfa_state_limit(self, limit:Option<usize>) -> Config {
                        Config { dfa_state_limit: Some(limit), ..self }
                    }
                    
                    pub fn byte_classes(self, yes:bool ) -> Config {
                        Config { byte_classes: Some(yes), ..self }
                    }
                    
                    pub fn line_terminator(self, byte: u8) -> Config {
                        Config { line_terminator: Some( byte ), ..self }
                    }
                    
                    pub fn hybrid(self, yes:bool ) -> Config {
                        Config { hybrid: Some(yes), ..self }
                    }
                    
                    pub fn dfa(self, yes:bool ) -> Config {
                        Config { dfa: Some(yes), ..self }
                    }
                    
                    pub fn onepass(self, yes:bool ) -> Config {
                        Config { onepass: Some(yes), ..self }
                    }
                    
                    pub fn backtrack(self, yes:bool ) -> Config {
                        Config { backtrack: Some(yes), ..self }
                    }
                    
                    pub fn get_match_kind( &self ) -> MatchKind { self.match_kind.unwrap_or(MatchKind::LeftmostFirst) }
                    
                    pub fn get_utf8_empty( &self ) -> bool { self.utf8_empty.unwrap_or(true) }
                    
                    pub fn get_auto_prefilter( &self ) -> bool { self.autopre.unwrap_or(true) }
                    
                    pub fn get_prefilter( &self ) -> Option<&Prefilter> { self.pre.as_ref().unwrap_or( &None ).as_ref() }
                    
                    pub fn get_which_captures( &self ) -> WhichCaptures { self.which_captures.unwrap_or(WhichCaptures::All) }

                    pub fn get_nfa_size_limit( &self ) -> Option<usize> { self.nfa_size_limit.unwrap_or(Some(10 * (1 << 20))) }
                    
                    pub fn get_onepass_size_limit( &self ) -> Option<usize> { self.onepass_size_limit.unwrap_or(Some(1 * (1 << 20))) }
                    
                    pub fn get_hybrid_cache_capacity( &self ) -> usize { self.hybrid_cache_capacity.unwrap_or(2 * (1 << 20)) }

                    pub fn get_dfa_size_limit( &self ) -> Option<usize> {
                        // for just those outgoing transitions to skip ahead very quickly.
                        //
                        //
                        // that cost if we know it's likely to be blown by a large margin.
                        self.dfa_size_limit.unwrap_or(Some(40 * (1 << 10)))
                    }
                    
                    pub fn get_dfa_state_limit( &self ) -> Option<usize> {
                        // Again, as with the size limit, we keep this very small.
                        self.dfa_state_limit.unwrap_or(Some(30))
                    }
                    
                    pub fn get_byte_classes( &self ) -> bool { self.byte_classes.unwrap_or(true) }
                    
                    pub fn get_line_terminator( &self ) -> u8 { self.line_terminator.unwrap_or(b'\n') }
                    
                    pub fn get_hybrid( &self ) -> bool {
                                {
                            self.hybrid.unwrap_or(true)
                        }
                        #[cfg(not(feature = "hybrid"))]
                        {
                            false
                        }
                    }
                    
                    pub fn get_dfa( &self ) -> bool {
                                {
                            self.dfa.unwrap_or(true)
                        }
                        #[cfg(not(feature = "dfa-build"))]
                        {
                            false
                        }
                    }
                    
                    pub fn get_onepass( &self ) -> bool { self.onepass.unwrap_or(true) }
                    
                    pub fn get_backtrack( &self ) -> bool { self.backtrack.unwrap_or(true) }
                    
                    pub fn overwrite(&self, o: Config) -> Config {
                        Config {
                            match_kind: o.match_kind.or( self.match_kind),
                            utf8_empty: o.utf8_empty.or( self.utf8_empty),
                            autopre: o.autopre.or( self.autopre),
                            pre: o.pre.or_else(|| self.pre.clone()),
                            which_captures: o.which_captures.or( self.which_captures),
                            nfa_size_limit: o.nfa_size_limit.or( self.nfa_size_limit),
                            onepass_size_limit: o
                                .onepass_size_limit
                                .or( self.onepass_size_limit),
                            hybrid_cache_capacity: o
                                .hybrid_cache_capacity
                                .or( self.hybrid_cache_capacity),
                            hybrid: o.hybrid.or( self.hybrid),
                            dfa: o.dfa.or( self.dfa),
                            dfa_size_limit: o.dfa_size_limit.or( self.dfa_size_limit),
                            dfa_state_limit: o.dfa_state_limit.or( self.dfa_state_limit),
                            onepass: o.onepass.or( self.onepass),
                            backtrack: o.backtrack.or( self.backtrack),
                            byte_classes: o.byte_classes.or( self.byte_classes),
                            line_terminator: o.line_terminator.or( self.line_terminator),
                        }
                    }
                }

                #[derive( Clone, Debug )]
                pub struct Builder {
                    config: Config,
                    ast: ast::parse::ParserBuilder,
                    hir: hir::translate::TranslatorBuilder,
                }

                impl Builder
                {
                    pub fn new() -> Builder {
                        Builder {
                            config: Config::default(),
                            ast: ast::parse::ParserBuilder::new(),
                            hir: hir::translate::TranslatorBuilder::new(),
                        }
                    }
                    
                    pub fn build(&self, pattern: &str) -> Result<Regex, BuildError> { self.build_many(&[pattern]) }

                    pub fn build_many<P: AsRef<str>>(
                        &self,
                        patterns: &[P],
                    ) -> Result<Regex, BuildError> {
                        use regex::automata::primitives::IteratorIndexExt;
                        log! {
                            for (pid, p) in patterns.iter().with_pattern_ids() {
                                let p = p.as_ref();
                                let maxoff = p
                                    .char_indices()
                                    .map(|(i, ch)| i + ch.len_utf8())
                                    .take(1000)
                                    .last()
                                    .unwrap_or(0);
                                if maxoff < p.len() {
                                } else {
                                }
                            }
                        }
                        let (mut asts, mut hirs) = (vec![], vec![]);
                        for (pid, p) in patterns.iter().with_pattern_ids() {
                            let ast = self
                                .ast
                                .build()
                                .parse(p.as_ref())
                                .map_err(|err| BuildError::ast(pid, err))?;
                            asts.push(ast);
                        }
                        for ((pid, p), ast) in
                            patterns.iter().with_pattern_ids().zip(asts.iter())
                        {
                            let hir = self
                                .hir
                                .build()
                                .translate(p.as_ref(), ast)
                                .map_err(|err| BuildError::hir(pid, err))?;
                            hirs.push(hir);
                        }
                        self.build_many_from_hir(&hirs)
                    }
                    ///
                    pub fn build_from_hir(&self, hir: &Hir) -> Result<Regex, BuildError> { self.build_many_from_hir(&[hir]) }
                    ///
                    pub fn build_many_from_hir<H: Borrow<Hir>>(
                        &self,
                        hirs: &[H],
                    ) -> Result<Regex, BuildError>
                    {
                        let config = self.config.clone();
                        
                        let hirs: Vec<&Hir> = hirs.iter().map(|hir| hir.borrow()).collect();
                        let info = RegexInfo::new(config, &hirs);
                        let strat = strategy::new(&info, &hirs)?;
                        let pool = {
                            let strat = Arc::clone(&strat);
                            let create: CachePoolFn = Box::new(move || strat.create_cache());
                            Pool::new(create)
                        };
                        Ok(Regex { imp: Arc::new(RegexI { strat, info }), pool })
                    }

                    pub fn configure( &mut self, config: Config) -> &mut Builder {
                        self.config = self.config.overwrite(config);
                        self
                    }
                    
                    pub fn syntax(
                        &mut self,
                        config: crate::util::syntax::Config,
                    ) -> &mut Builder {
                        config.apply_ast(&mut self.ast);
                        config.apply_hir(&mut self.hir);
                        self
                    }
                }
            } pub use self::regex::{ Builder, Cache, CapturesMatches, Config, FindMatches, Regex, Split, SplitN };

            pub mod reverse
            {
                /*!
                A module dedicated to plucking inner literals out of a regex pattern, and then constructing a prefilter for them.*/
                use ::
                {
                    *,
                };
                /*
                use alloc::vec::Vec;
                use regex_syntax::hir::{self, literal, Hir, HirKind};
                use crate::{util::prefilter::Prefilter, MatchKind};
                */

                pub fn extract(hirs: &[&Hir]) -> Option<(Hir, Prefilter)> {
                    if hirs.len() != 1 {
                        return None;
                    }
                    let mut concat = match top_concat(hirs[0]) {
                        Some(concat) => concat,
                        None => {
                            return None;
                        }
                    };
                    for i in 1..concat.len() {
                        let hir = &concat[i];
                        let pre = match prefilter(hir) {
                            None => continue,
                            Some(pre) => pre,
                        };
                        
                        if !pre.is_fast() {
                            continue;
                        }
                        let concat_suffix = Hir::concat(concat.split_off(i));
                        let concat_prefix = Hir::concat(concat);
                        
                        let pre2 = match prefilter(&concat_suffix) {
                            None => pre,
                            Some(pre2) => {
                                if pre2.is_fast() {
                                    pre2
                                } else {
                                    pre
                                }
                            }
                        };
                        return Some((concat_prefix, pre2));
                    }
                    None
                }

                fn prefilter(hir: &Hir) -> Option<Prefilter> {
                    let mut extractor = literal::Extractor::new();
                    extractor.kind(literal::ExtractKind::Prefix);
                    let mut prefixes = extractor.extract(hir);
                    
                    prefixes.make_inexact();
                    prefixes.optimize_for_prefix_by_preference();
                    prefixes
                        .literals()
                        .and_then(|lits| Prefilter::new(MatchKind::LeftmostFirst, lits))
                }

                fn top_concat(mut hir: &Hir) -> Option<Vec<Hir>> {
                    loop {
                        hir = match hir.kind() {
                            HirKind::Empty
                            | HirKind::Literal(_)
                            | HirKind::Class(_)
                            | HirKind::Look(_)
                            | HirKind::Repetition(_)
                            | HirKind::Alternation(_) => return None,
                            HirKind::Capture(hir::Capture { ref sub, .. }) => sub,
                            HirKind::Concat(ref subs) => {
                                let concat =
                                    Hir::concat(subs.iter().map(|h| flatten(h)).collect());
                                return match concat.into_kind() {
                                    HirKind::Concat(xs) => Some(xs),
                                    _ => return None,
                                };
                            }
                        };
                    }
                }

                fn flatten(hir: &Hir) -> Hir {
                    match hir.kind() {
                        HirKind::Empty => Hir::empty(),
                        HirKind::Literal(hir::Literal(ref x)) => Hir::literal(x.clone()),
                        HirKind::Class(ref x) => Hir::class(x.clone()),
                        HirKind::Look(ref x) => Hir::look(x.clone()),
                        HirKind::Repetition(ref x) => Hir::repetition(x.with(flatten(&x.sub))),
                        HirKind::Capture(hir::Capture { ref sub, .. }) => flatten(sub),
                        HirKind::Alternation(ref xs) => { Hir::alternation(xs.iter().map(|x| flatten(x)).collect()) }
                        HirKind::Concat(ref xs) => { Hir::concat(xs.iter().map(|x| flatten(x)).collect()) }
                    }
                }
            }

            pub mod stopat
            {
                /*!
                This module defines two bespoke forward DFA search routines. One for the lazy DFA and one for the fully compiled DFA.*/
                use ::
                {
                    *,
                };
                /*
                use crate::{meta::error::RetryFailError, HalfMatch, Input, MatchError};
                */
                pub fn dfa_try_search_half_fwd(
                    dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,
                    input: &Input<'_>,
                ) -> Result<Result<HalfMatch, usize>, RetryFailError> 
                {
                    use crate::dfa::{accel, Automaton};

                    let mut mat = None;
                    let mut sid = dfa.start_state_forward(input)?;
                    let mut at = input.start();
                    while at < input.end() {
                        sid = dfa.next_state(sid, input.haystack()[at]);
                        if dfa.is_special_state(sid) {
                            if dfa.is_match_state(sid) {
                                let pattern = dfa.match_pattern(sid, 0);
                                mat = Some(HalfMatch::new(pattern, at));
                                if input.get_earliest() {
                                    return Ok(mat.ok_or(at));
                                }
                                if dfa.is_accel_state(sid) {
                                    let needs = dfa.accelerator(sid);
                                    at = accel::find_fwd(needs, input.haystack(), at)
                                        .unwrap_or(input.end());
                                    continue;
                                }
                            } else if dfa.is_accel_state(sid) {
                                let needs = dfa.accelerator(sid);
                                at = accel::find_fwd(needs, input.haystack(), at)
                                    .unwrap_or(input.end());
                                continue;
                            } else if dfa.is_dead_state(sid) {
                                return Ok(mat.ok_or(at));
                            } else if dfa.is_quit_state(sid) {
                                return Err(MatchError::quit(input.haystack()[at], at).into());
                            } else {
                                debug_assert!(dfa.is_start_state(sid));
                            }
                        }
                        at += 1;
                    }
                    dfa_eoi_fwd(dfa, input, &mut sid, &mut mat)?;
                    Ok(mat.ok_or(at))
                }

                pub fn hybrid_try_search_half_fwd(
                    dfa: &crate::hybrid::dfa::DFA,
                    cache: &mut crate::hybrid::dfa::Cache,
                    input: &Input<'_>,
                ) -> Result<Result<HalfMatch, usize>, RetryFailError> {
                    let mut mat = None;
                    let mut sid = dfa.start_state_forward(cache, input)?;
                    let mut at = input.start();
                    while at < input.end() {
                        sid = dfa
                            .next_state(cache, sid, input.haystack()[at])
                            .map_err(|_| MatchError::gave_up(at))?;
                        if sid.is_tagged() {
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, sid, 0);
                                mat = Some(HalfMatch::new(pattern, at));
                                if input.get_earliest() {
                                    return Ok(mat.ok_or(at));
                                }
                            } else if sid.is_dead() {
                                return Ok(mat.ok_or(at));
                            } else if sid.is_quit() {
                                return Err(MatchError::quit(input.haystack()[at], at).into());
                            } else {
                                debug_assert!(!sid.is_unknown());
                                debug_assert!(sid.is_start());
                            }
                        }
                        at += 1;
                    }
                    hybrid_eoi_fwd(dfa, cache, input, &mut sid, &mut mat)?;
                    Ok(mat.ok_or(at))
                }
                
                #[inline( always )]
                fn dfa_eoi_fwd(
                    dfa: &crate::dfa::dense::DFA<alloc::vec::Vec<u32>>,
                    input: &Input<'_>,
                    sid: &mut crate::util::primitives::StateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError> {
                    use crate::dfa::Automaton;

                    let sp = input.get_span();
                    match input.haystack().get(sp.end) {
                        Some(&b) => {
                            *sid = dfa.next_state(*sid, b);
                            if dfa.is_match_state(*sid) {
                                let pattern = dfa.match_pattern(*sid, 0);
                                *mat = Some(HalfMatch::new(pattern, sp.end));
                            } else if dfa.is_quit_state(*sid) {
                                return Err(MatchError::quit(b, sp.end));
                            }
                        }
                        None => {
                            *sid = dfa.next_eoi_state(*sid);
                            if dfa.is_match_state(*sid) {
                                let pattern = dfa.match_pattern(*sid, 0);
                                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));
                            }
                            debug_assert!(!dfa.is_quit_state(*sid));
                        }
                    }
                    Ok( () )
                }

                #[inline( always )]
                fn hybrid_eoi_fwd(
                    dfa: &crate::hybrid::dfa::DFA,
                    cache: &mut crate::hybrid::dfa::Cache,
                    input: &Input<'_>,
                    sid: &mut crate::hybrid::LazyStateID,
                    mat: &mut Option<HalfMatch>,
                ) -> Result<(), MatchError> {
                    let sp = input.get_span();
                    match input.haystack().get(sp.end) {
                        Some(&b) => {
                            *sid = dfa
                                .next_state(cache, *sid, b)
                                .map_err(|_| MatchError::gave_up(sp.end))?;
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, *sid, 0);
                                *mat = Some(HalfMatch::new(pattern, sp.end));
                            } else if sid.is_quit() {
                                return Err(MatchError::quit(b, sp.end));
                            }
                        }
                        None => {
                            *sid = dfa
                                .next_eoi_state(cache, *sid)
                                .map_err(|_| MatchError::gave_up(input.haystack().len()))?;
                            if sid.is_match() {
                                let pattern = dfa.match_pattern(cache, *sid, 0);
                                *mat = Some(HalfMatch::new(pattern, input.haystack().len()));
                            }
                            debug_assert!(!sid.is_quit());
                        }
                    }
                    Ok( () )
                }
            }

            pub mod strategy
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use ::{
                    fmt::Debug,
                    panic::{RefUnwindSafe, UnwindSafe},
                };

                use alloc::sync::Arc;

                use regex_syntax::hir::{literal, Hir};

                use crate::{
                    meta::{
                        error::{BuildError, RetryError, RetryFailError, RetryQuadraticError},
                        regex::{Cache, RegexInfo},
                        reverse_inner, wrappers,
                    },
                    nfa::thompson::{self, WhichCaptures, NFA},
                    util::{
                        captures::{Captures, GroupInfo},
                        look::LookMatcher,
                        prefilter::{self, Prefilter, PrefilterI},
                        primitives::{NonMaxUsize, PatternID},
                        search::{Anchored, HalfMatch, Input, Match, MatchKind, PatternSet},
                    },
                };
                */
                pub(super) trait Strategy:
                    Debug + Send + Sync + RefUnwindSafe + UnwindSafe + 'static
               
                {
                    fn group_info( &self ) -> &GroupInfo;

                    fn create_cache( &self ) -> Cache;

                    fn reset_cache(&self, cache: &mut Cache);

                    fn is_accelerated( &self ) -> bool;

                    fn memory_usage( &self ) -> usize;

                    fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match>;

                    fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch>;

                    fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool;

                    fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID>;

                    fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    );
                }

                pub(super) fn new(
                    info: &RegexInfo,
                    hirs: &[&Hir],
                ) -> Result<Arc<dyn Strategy>, BuildError> {
                    let pre = if info.is_always_anchored_start() {
                        None
                    } else if let Some(pre) = info.config().get_prefilter() {
                        Some(pre.clone())
                    } else if info.config().get_auto_prefilter() {
                        let kind = info.config().get_match_kind();
                        let prefixes = crate::util::prefilter::prefixes(kind, hirs);
                        if let Some(pre) = Pre::from_prefixes(info, &prefixes) {
                            return Ok(pre);
                        }
                        if let Some(pre) = Pre::from_alternation_literals(info, hirs) {
                            return Ok(pre);
                        }
                        prefixes.literals().and_then(|strings| {
                            Prefilter::new(kind, strings)
                        })
                    } else {
                        None
                    };
                    let mut core = ::new(info.clone(), pre.clone(), hirs)?;
                    core = match ReverseAnchored::new(core) {
                        Err(core) => core,
                        Ok(ra) => {
                            return Ok(Arc::new(ra));
                        }
                    };
                    core = match ReverseSuffix::new(core, hirs) {
                        Err(core) => core,
                        Ok(rs) => {
                            return Ok(Arc::new(rs));
                        }
                    };
                    core = match ReverseInner::new(core, hirs) {
                        Err(core) => core,
                        Ok(ri) => {
                            return Ok(Arc::new(ri));
                        }
                    };
                    Ok(Arc::new(core))
                }

                #[derive( Clone, Debug )]
                struct Pre<P> {
                    pre: P,
                    group_info: GroupInfo,
                }

                impl<P: PrefilterI> Pre<P>
                {
                    fn new(pre: P) -> Arc<dyn Strategy>
                    {
                        let group_info = GroupInfo::new([[None::<&str>]]).unwrap();
                        Arc::new(Pre { pre, group_info })
                    }
                }
                // define it on an arbitrary type.
                impl Pre<()>
                {
                    fn from_prefixes(
                        info: &RegexInfo,
                        prefixes: &literal::Seq,
                    ) -> Option<Arc<dyn Strategy>>
                    {
                        let kind = info.config().get_match_kind();
                        
                        if !prefixes.is_exact() {
                            return None;
                        }
                        if info.pattern_len() != 1 {
                            return None;
                        }
                        if info.props()[0].explicit_captures_len() != 0 {
                            return None;
                        }

                        if !info.props()[0].look_set().is_empty() {
                            return None;
                        }

                        if kind != MatchKind::LeftmostFirst {
                            return None;
                        }
                        
                        let prefixes = prefixes.literals().unwrap();
                        
                        let choice = match prefilter::Choice::new(kind, prefixes) {
                            Some(choice) => choice,
                            None => {
                                return None;
                            }
                        };
                        let strat: Arc<dyn Strategy> = match choice {
                            prefilter::Choice::Memchr(pre) => Pre::new(pre),
                            prefilter::Choice::Memchr2(pre) => Pre::new(pre),
                            prefilter::Choice::Memchr3(pre) => Pre::new(pre),
                            prefilter::Choice::Memmem(pre) => Pre::new(pre),
                            prefilter::Choice::Teddy(pre) => Pre::new(pre),
                            prefilter::Choice::ByteSet(pre) => Pre::new(pre),
                            prefilter::Choice::AhoCorasick(pre) => Pre::new(pre),
                        };
                        
                        Some( strat)
                    }
                    fn from_alternation_literals(
                        info: &RegexInfo,
                        hirs: &[&Hir],
                    ) -> Option<Arc<dyn Strategy>> {
                        use crate::util::prefilter::AhoCorasick;

                        let lits = crate::meta::literal::alternation_literals(info, hirs)?;
                        let ac = AhoCorasick::new(MatchKind::LeftmostFirst, &lits)?;
                        Some(Pre::new(ac))
                    }
                }
                
                impl<P: PrefilterI> Strategy for Pre<P> {
                    #[inline( always )] fn group_info( &self ) -> &GroupInfo { &self.group_info }

                    fn create_cache( &self ) -> Cache {
                        Cache {
                            capmatches: Captures::all( self.group_info().clone()),
                            pikevm: wrappers::PikeVMCache::none(),
                            backtrack: wrappers::BoundedBacktrackerCache::none(),
                            onepass: wrappers::OnePassCache::none(),
                            hybrid: wrappers::HybridCache::none(),
                            revhybrid: wrappers::ReverseHybridCache::none(),
                        }
                    }

                    fn reset_cache(&self, _cache: &mut Cache) {}

                    fn is_accelerated( &self ) -> bool { self.pre.is_fast() }

                    fn memory_usage( &self ) -> usize { self.pre.memory_usage() }

                    #[inline( always )] fn search(&self, _cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        if input.is_done() {
                            return None;
                        }
                        if input.get_anchored().is_anchored() {
                            return self
                                .pre
                                .prefix(input.haystack(), input.get_span())
                                .map(|sp| Match::new(PatternID::ZERO, sp));
                        }
                        self.pre
                            .find(input.haystack(), input.get_span())
                            .map(|sp| Match::new(PatternID::ZERO, sp))
                    }

                    #[inline( always )] fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> { self.search(cache, input).map(|m| HalfMatch::new(m.pattern(), m.end())) }

                    #[inline( always )] fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        self.search(cache, input).is_some()
                    }

                    #[inline( always )] fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID>
                    {
                        let m = self.search(cache, input)?;
                        if let Some(slot) = slots.get_mut(0) {
                            *slot = NonMaxUsize::new(m.start());
                        }
                        if let Some(slot) = slots.get_mut(1) {
                            *slot = NonMaxUsize::new(m.end());
                        }
                        Some(m.pattern())
                    }

                    #[inline( always )] fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        if self.search(cache, input).is_some() {
                            patset.insert(PatternID::ZERO);
                        }
                    }
                }

                #[derive( Debug )]
                struct Core {
                    info: RegexInfo,
                    pre:Option<Prefilter>,
                    nfa: NFA,
                    nfarev:Option<NFA>,
                    pikevm: wrappers::PikeVM,
                    backtrack: wrappers::BoundedBacktracker,
                    onepass: wrappers::OnePass,
                    hybrid: wrappers::Hybrid,
                    dfa: wrappers::DFA,
                }

                impl Core
                {
                    fn new(
                        info: RegexInfo,
                        pre:Option<Prefilter>,
                        hirs: &[&Hir],
                    ) -> Result<Core, BuildError>
                    {
                        let mut lookm = LookMatcher::new();
                        lookm.set_line_terminator(info.config().get_line_terminator());
                        let thompson_config = thompson::Config::new()
                            .utf8(info.config().get_utf8_empty())
                            .nfa_size_limit(info.config().get_nfa_size_limit())
                            .shrink( false )
                            .which_captures(info.config().get_which_captures())
                            .look_matcher(lookm);
                        let nfa = thompson::Compiler::new()
                            .configure(thompson_config.clone())
                            .build_many_from_hir(hirs)
                            .map_err(BuildError::nfa)?;
                        let pikevm = wrappers::PikeVM::new(&info, pre.clone(), &nfa)?;
                        let backtrack =
                            wrappers::BoundedBacktracker::new(&info, pre.clone(), &nfa)?;
                        let onepass = wrappers::OnePass::new(&info, &nfa);
                        let (nfarev, hybrid, dfa) =
                            if !info.config().get_hybrid() && !info.config().get_dfa() {
                                (None, wrappers::Hybrid::none(), wrappers::DFA::none())
                            } else {
                                let nfarev = thompson::Compiler::new()
                                    .configure(
                                        thompson_config
                                            .clone()
                                            .which_captures(WhichCaptures::None)
                                            .reverse(true),
                                    )
                                    .build_many_from_hir(hirs)
                                    .map_err(BuildError::nfa)?;
                                let dfa = if !info.config().get_dfa() {
                                    wrappers::DFA::none()
                                } else {
                                    wrappers::DFA::new(&info, pre.clone(), &nfa, &nfarev)
                                };
                                let hybrid = if !info.config().get_hybrid() {
                                    wrappers::Hybrid::none()
                                } else if dfa.is_some() {
                                    wrappers::Hybrid::none()
                                } else {
                                    wrappers::Hybrid::new(&info, pre.clone(), &nfa, &nfarev)
                                };
                                (Some(nfarev), hybrid, dfa)
                            };
                        Ok(Core {
                            info,
                            pre,
                            nfa,
                            nfarev,
                            pikevm,
                            backtrack,
                            onepass,
                            hybrid,
                            dfa,
                        })
                    }

                    #[inline( always )] fn try_search_mayfail(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<Result<Option<Match>, RetryFailError>> {
                        if let Some(e) = self.dfa.get(input) {
                            trace!("using full DFA for search at {:?}", input.get_span());
                            Some(e.try_search(input))
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!("using lazy DFA for search at {:?}", input.get_span());
                            Some(e.try_search(&mut cache.hybrid, input))
                        } else {
                            None
                        }
                    }

                    fn search_nofail(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<Match>
                    {
                        let caps = &mut cache.capmatches;
                        caps.set_pattern( None );
                        let pid = if let Some(ref e) = self.onepass.get(input) {
                            trace!("using OnePass for search at {:?}", input.get_span());
                            e.search_slots(&mut cache.onepass, input, caps.slots_mut())
                        } else if let Some(ref e) = self.backtrack.get(input) {
                            trace!(
                                "using BoundedBacktracker for search at {:?}",
                                input.get_span()
                            );
                            e.search_slots(&mut cache.backtrack, input, caps.slots_mut())
                        } else {
                            trace!("using PikeVM for search at {:?}", input.get_span());
                            let e = self.pikevm.get();
                            e.search_slots(&mut cache.pikevm, input, caps.slots_mut())
                        };
                        caps.set_pattern(pid);
                        caps.get_match()
                    }

                    fn search_half_nofail(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch>
                    {
                        let m = self.search_nofail(cache, input)?;
                        Some(HalfMatch::new(m.pattern(), m.end()))
                    }

                    fn search_slots_nofail(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if let Some(ref e) = self.onepass.get(input) {
                            trace!(
                                "using OnePass for capture search at {:?}",
                                input.get_span()
                            );
                            e.search_slots(&mut cache.onepass, input, slots)
                        } else if let Some(ref e) = self.backtrack.get(input) {
                            trace!(
                                "using BoundedBacktracker for capture search at {:?}",
                                input.get_span()
                            );
                            e.search_slots(&mut cache.backtrack, input, slots)
                        } else {
                            trace!(
                                "using PikeVM for capture search at {:?}",
                                input.get_span()
                            );
                            let e = self.pikevm.get();
                            e.search_slots(&mut cache.pikevm, input, slots)
                        }
                    }

                    fn is_match_nofail(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if let Some(ref e) = self.onepass.get(input) {
                            trace!(
                                "using OnePass for is-match search at {:?}",
                                input.get_span()
                            );
                            e.search_slots(&mut cache.onepass, input, &mut []).is_some()
                        } else if let Some(ref e) = self.backtrack.get(input) {
                            trace!(
                                "using BoundedBacktracker for is-match search at {:?}",
                                input.get_span()
                            );
                            e.is_match(&mut cache.backtrack, input)
                        } else {
                            trace!(
                                "using PikeVM for is-match search at {:?}",
                                input.get_span()
                            );
                            let e = self.pikevm.get();
                            e.is_match(&mut cache.pikevm, input)
                        }
                    }

                    fn is_capture_search_needed(&self, slots_len: usize) -> bool {
                        slots_len > self.nfa.group_info().implicit_slot_len()
                    }
                }

                impl Strategy for Core {
                    #[inline( always )] fn group_info( &self ) -> &GroupInfo { self.nfa.group_info() }

                    #[inline( always )] fn create_cache( &self ) -> Cache {
                        Cache {
                            capmatches: Captures::all( self.group_info().clone()),
                            pikevm: self.pikevm.create_cache(),
                            backtrack: self.backtrack.create_cache(),
                            onepass: self.onepass.create_cache(),
                            hybrid: self.hybrid.create_cache(),
                            revhybrid: wrappers::ReverseHybridCache::none(),
                        }
                    }

                    #[inline( always )] fn reset_cache(&self, cache: &mut Cache) {
                        cache.pikevm.reset(&self.pikevm);
                        cache.backtrack.reset(&self.backtrack);
                        cache.onepass.reset(&self.onepass);
                        cache.hybrid.reset(&self.hybrid);
                    }

                    fn is_accelerated( &self ) -> bool { self.pre.as_ref().map_or(false, |pre| pre.is_fast()) }

                    fn memory_usage( &self ) -> usize {
                        self.info.memory_usage()
                            + self.pre.as_ref().map_or(0, |pre| pre.memory_usage())
                            + self.nfa.memory_usage()
                            + self.nfarev.as_ref().map_or(0, |nfa| nfa.memory_usage())
                            + self.onepass.memory_usage()
                            + self.dfa.memory_usage()
                    }

                    #[inline( always )] fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        return if let Some(e) = self.dfa.get(input) {
                            trace!("using full DFA for full search at {:?}", input.get_span());
                            match e.try_search(input) {
                                Ok(x) => x,
                                Err(_err) => {
                                    trace!("full DFA search failed: {_err}");
                                    self.search_nofail(cache, input)
                                }
                            }
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!("using lazy DFA for full search at {:?}", input.get_span());
                            match e.try_search(&mut cache.hybrid, input) {
                                Ok(x) => x,
                                Err(_err) => {
                                    trace!("lazy DFA search failed: {_err}");
                                    self.search_nofail(cache, input)
                                }
                            }
                        } else {
                            self.search_nofail(cache, input)
                        };
                    }

                    #[inline( always )] fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        // DFA.
                        if let Some(e) = self.dfa.get(input) {
                            trace!("using full DFA for half search at {:?}", input.get_span());
                            match e.try_search_half_fwd(input) {
                                Ok(x) => x,
                                Err(_err) => {
                                    trace!("full DFA half search failed: {_err}");
                                    self.search_half_nofail(cache, input)
                                }
                            }
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!("using lazy DFA for half search at {:?}", input.get_span());
                            match e.try_search_half_fwd(&mut cache.hybrid, input) {
                                Ok(x) => x,
                                Err(_err) => {
                                    trace!("lazy DFA half search failed: {_err}");
                                    self.search_half_nofail(cache, input)
                                }
                            }
                        } else {
                            self.search_half_nofail(cache, input)
                        }
                    }

                    #[inline( always )] fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if let Some(e) = self.dfa.get(input) {
                            trace!(
                                "using full DFA for is-match search at {:?}",
                                input.get_span()
                            );
                            match e.try_search_half_fwd(input) {
                                Ok(x) => x.is_some(),
                                Err(_err) => {
                                    trace!("full DFA half search failed: {_err}");
                                    self.is_match_nofail(cache, input)
                                }
                            }
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!(
                                "using lazy DFA for is-match search at {:?}",
                                input.get_span()
                            );
                            match e.try_search_half_fwd(&mut cache.hybrid, input) {
                                Ok(x) => x.is_some(),
                                Err(_err) => {
                                    trace!("lazy DFA half search failed: {_err}");
                                    self.is_match_nofail(cache, input)
                                }
                            }
                        } else {
                            self.is_match_nofail(cache, input)
                        }
                    }

                    #[inline( always )] fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        // we try to save the caller from themselves if they do.
                        if !self.is_capture_search_needed(slots.len()) {
                            trace!("asked for slots unnecessarily, trying fast path");
                            let m = self.search(cache, input)?;
                            copy_match_to_slots(m, slots);
                            return Some(m.pattern());
                        }
                        // advantageous to try and do a full/lazy DFA scan first.
                        //
                        // and doesn't cost too much here.
                        if self.onepass.get(&input).is_some() {
                            return self.search_slots_nofail(cache, &input, slots);
                        }
                        let m = match self.try_search_mayfail(cache, input) {
                            Some(Ok(Some(m))) => m,
                            Some(Ok( None )) => return None,
                            Some(Err(_err)) => {
                                trace!("fast capture search failed: {_err}");
                                return self.search_slots_nofail(cache, input, slots);
                            }
                            None => { return self.search_slots_nofail(cache, input, slots); }
                        };
                        trace!(
                            "match found at {}..{} in capture search, \
                            using another engine to find captures",
                            m.start(),
                            m.end(),
                        );
                        let input = input
                            .clone()
                            .span(m.start()..m.end())
                            .anchored(Anchored::Pattern(m.pattern()));
                        Some(
                            self.search_slots_nofail(cache, &input, slots)
                                .expect("should find a match"),
                        )
                    }

                    #[inline( always )] fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        if let Some(e) = self.dfa.get(input) {
                            trace!(
                                "using full DFA for overlapping search at {:?}",
                                input.get_span()
                            );
                            let _err = match e.try_which_overlapping_matches(input, patset) {
                                Ok( () ) => return,
                                Err(err) => err,
                            };
                            trace!("fast overlapping search failed: {_err}");
                        } else if let Some(e) = self.hybrid.get(input) {
                            trace!(
                                "using lazy DFA for overlapping search at {:?}",
                                input.get_span()
                            );
                            let _err = match e.try_which_overlapping_matches(
                                &mut cache.hybrid,
                                input,
                                patset,
                            ) {
                                Ok( () ) => { return; }
                                Err(err) => err,
                            };
                            trace!("fast overlapping search failed: {_err}");
                        }
                        trace!(
                            "using PikeVM for overlapping search at {:?}",
                            input.get_span()
                        );
                        let e = self.pikevm.get();
                        e.which_overlapping_matches(&mut cache.pikevm, input, patset)
                    }
                }

                #[derive( Debug )]
                struct ReverseAnchored {
                    core: Core,
                }

                impl ReverseAnchored
                {
                    fn new(core: Core) -> Result<ReverseAnchored, Core> {
                        if !core.info.is_always_anchored_end() {
                            return Err(core);
                        }
                        if core.info.is_always_anchored_start() {
                            return Err(core);
                        }

                        if !core.hybrid.is_some() && !core.dfa.is_some() {
                            return Err(core);
                        }
                        Ok(ReverseAnchored { core })
                    }

                    #[inline( always )] fn try_search_half_anchored_rev(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError>
                    {
                        let input = input.clone().anchored(Anchored::Yes);
                        if let Some(e) = self.core.dfa.get(&input) {
                            trace!(
                                "using full DFA for reverse anchored search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_rev(&input)
                        } else if let Some(e) = self.core.hybrid.get(&input) {
                            trace!(
                                "using lazy DFA for reverse anchored search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_rev(&mut cache.hybrid, &input)
                        } else {
                            unreachable!("ReverseAnchored always has a DFA")
                        }
                    }
                }
                // is equivalent to the length of the haystack.
                impl Strategy for ReverseAnchored {
                    #[inline( always )] fn group_info( &self ) -> &GroupInfo { self.core.group_info() }

                    #[inline( always )] fn create_cache( &self ) -> Cache { self.core.create_cache() }

                    #[inline( always )] fn reset_cache(&self, cache: &mut Cache) {
                        self.core.reset_cache(cache);
                    }

                    fn is_accelerated( &self ) -> bool {
                        // a standard forward search.
                        true
                    }

                    fn memory_usage( &self ) -> usize { self.core.memory_usage() }

                    #[inline( always )] fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search(cache, input);
                        }
                        match self.try_search_half_anchored_rev(cache, input) {
                            Err(_err) => {
                                trace!("fast reverse anchored search failed: {_err}");
                                self.core.search_nofail(cache, input)
                            }
                            Ok( None ) => None,
                            Ok(Some(hm)) => { Some(Match::new(hm.pattern(), hm.offset()..input.end())) }
                        }
                    }

                    #[inline( always )] fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_half(cache, input);
                        }
                        match self.try_search_half_anchored_rev(cache, input) {
                            Err(_err) => {
                                trace!("fast reverse anchored search failed: {_err}");
                                self.core.search_half_nofail(cache, input)
                            }
                            Ok( None ) => None,
                            Ok(Some(hm)) => { Some(HalfMatch::new(hm.pattern(), input.end())) }
                        }
                    }

                    #[inline( always )] fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if input.get_anchored().is_anchored() {
                            return self.core.is_match(cache, input);
                        }
                        match self.try_search_half_anchored_rev(cache, input) {
                            Err(_err) => {
                                trace!("fast reverse anchored search failed: {_err}");
                                self.core.is_match_nofail(cache, input)
                            }
                            Ok( None ) => false,
                            Ok(Some(_)) => true,
                        }
                    }

                    #[inline( always )] fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_slots(cache, input, slots);
                        }
                        match self.try_search_half_anchored_rev(cache, input) {
                            Err(_err) => {
                                trace!("fast reverse anchored search failed: {_err}");
                                self.core.search_slots_nofail(cache, input, slots)
                            }
                            Ok( None ) => None,
                            Ok(Some(hm)) => {
                                if !self.core.is_capture_search_needed(slots.len()) {
                                    trace!("asked for slots unnecessarily, skipping captures");
                                    let m = Match::new(hm.pattern(), hm.offset()..input.end());
                                    copy_match_to_slots(m, slots);
                                    return Some(m.pattern());
                                }
                                let start = hm.offset();
                                let input = input
                                    .clone()
                                    .span(start..input.end())
                                    .anchored(Anchored::Pattern(hm.pattern()));
                                self.core.search_slots_nofail(cache, &input, slots)
                            }
                        }
                    }

                    #[inline( always )] fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        self.core.which_overlapping_matches(cache, input, patset)
                    }
                }

                #[derive( Debug )]
                struct ReverseSuffix {
                    core: Core,
                    pre: Prefilter,
                }

                impl ReverseSuffix
                {
                    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseSuffix, Core> {
                        if !core.info.config().get_auto_prefilter() {
                            
                            return Err(core);
                        }
                        //
                        if core.info.is_always_anchored_start() {
                            return Err(core);
                        }

                        if !core.hybrid.is_some() && !core.dfa.is_some() {
                            
                            return Err(core);
                        }
                        if core.pre.as_ref().map_or(false, |p| p.is_fast()) {
                            
                            return Err(core);
                        }
                        let kind = core.info.config().get_match_kind();
                        let suffixes = crate::util::prefilter::suffixes(kind, hirs);
                        let lcs = match suffixes.longest_common_suffix() {
                            None => {
                                
                                return Err(core);
                            }
                            Some(lcs) if lcs.is_empty() => {
                                
                                return Err(core);
                            }
                            Some(lcs) => lcs,
                        };
                        let pre = match Prefilter::new(kind, &[lcs]) {
                            Some(pre) => pre,
                            None => {
                                
                                return Err(core);
                            }
                        };
                        if !pre.is_fast() {
                            return Err(core);
                        }
                        Ok(ReverseSuffix { core, pre })
                    }

                    #[inline( always )] fn try_search_half_start(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryError>
                    {
                        let mut span = input.get_span();
                        let mut min_start = 0;
                        loop {
                            let litmatch = match self.pre.find(input.haystack(), span) {
                                None => return Ok( None ),
                                Some(span) => span,
                            };
                            trace!("reverse suffix scan found suffix match at {litmatch:?}");
                            let revinput = input
                                .clone()
                                .anchored(Anchored::Yes)
                                .span(input.start()..litmatch.end);
                            match self
                                .try_search_half_rev_limited(cache, &revinput, min_start)?
                            {
                                None => {
                                    if span.start >= span.end {
                                        break;
                                    }
                                    span.start = litmatch.start.checked_add(1).unwrap();
                                }
                                Some(hm) => return Ok(Some(hm)),
                            }
                            min_start = litmatch.end;
                        }
                        Ok( None )
                    }

                    #[inline( always )] fn try_search_half_fwd(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                        if let Some(e) = self.core.dfa.get(&input) {
                            trace!(
                                "using full DFA for forward reverse suffix search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_fwd(&input)
                        } else if let Some(e) = self.core.hybrid.get(&input) {
                            trace!(
                                "using lazy DFA for forward reverse suffix search at {:?}",
                                input.get_span()
                            );
                            e.try_search_half_fwd(&mut cache.hybrid, &input)
                        } else {
                            unreachable!("ReverseSuffix always has a DFA")
                        }
                    }

                    #[inline( always )] fn try_search_half_rev_limited(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                        if let Some(e) = self.core.dfa.get(&input) {
                            trace!(
                                "using full DFA for reverse suffix search at {:?}, \
                                but will be stopped at {} to avoid quadratic behavior",
                                input.get_span(),
                                min_start,
                            );
                            e.try_search_half_rev_limited(&input, min_start)
                        } else if let Some(e) = self.core.hybrid.get(&input) {
                            trace!(
                                "using lazy DFA for reverse suffix search at {:?}, \
                                but will be stopped at {} to avoid quadratic behavior",
                                input.get_span(),
                                min_start,
                            );
                            e.try_search_half_rev_limited(&mut cache.hybrid, &input, min_start)
                        } else {
                            unreachable!("ReverseSuffix always has a DFA")
                        }
                    }
                }

                impl Strategy for ReverseSuffix {
                    #[inline( always )] fn group_info( &self ) -> &GroupInfo { self.core.group_info() }

                    #[inline( always )] fn create_cache( &self ) -> Cache { self.core.create_cache() }

                    #[inline( always )] fn reset_cache(&self, cache: &mut Cache) {
                        self.core.reset_cache(cache);
                    }

                    fn is_accelerated( &self ) -> bool { self.pre.is_fast() }

                    fn memory_usage( &self ) -> usize { self.core.memory_usage() + self.pre.memory_usage() }

                    #[inline( always )] fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search(cache, input);
                        }
                        match self.try_search_half_start(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse suffix optimization failed: {_err}");
                                self.core.search(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!("reverse suffix reverse fast search failed: {_err}");
                                self.core.search_nofail(cache, input)
                            }
                            Ok( None ) => None,
                            Ok(Some(hm_start)) => {
                                let fwdinput = input
                                    .clone()
                                    .anchored(Anchored::Pattern(hm_start.pattern()))
                                    .span(hm_start.offset()..input.end());
                                match self.try_search_half_fwd(cache, &fwdinput) {
                                    Err(_err) => {
                                        trace!(
                                            "reverse suffix forward fast search failed: {_err}"
                                        );
                                        self.core.search_nofail(cache, input)
                                    }
                                    Ok( None ) => {
                                        unreachable!(
                                            "suffix match plus reverse match implies \
                                            there must be a match",
                                        )
                                    }
                                    Ok(Some(hm_end)) => Some(Match::new(
                                        hm_start.pattern(),
                                        hm_start.offset()..hm_end.offset(),
                                    )),
                                }
                            }
                        }
                    }

                    #[inline( always )] fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_half(cache, input);
                        }
                        match self.try_search_half_start(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse suffix half optimization failed: {_err}");
                                self.core.search_half(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!(
                                    "reverse suffix reverse fast half search failed: {_err}"
                                );
                                self.core.search_half_nofail(cache, input)
                            }
                            Ok( None ) => None,
                            Ok(Some(hm_start)) => {
                                // correct match because of greediness.
                                let fwdinput = input
                                    .clone()
                                    .anchored(Anchored::Pattern(hm_start.pattern()))
                                    .span(hm_start.offset()..input.end());
                                match self.try_search_half_fwd(cache, &fwdinput) {
                                    Err(_err) => {
                                        trace!(
                                            "reverse suffix forward fast search failed: {_err}"
                                        );
                                        self.core.search_half_nofail(cache, input)
                                    }
                                    Ok( None ) => {
                                        unreachable!(
                                            "suffix match plus reverse match implies \
                                            there must be a match",
                                        )
                                    }
                                    Ok(Some(hm_end)) => Some(hm_end),
                                }
                            }
                        }
                    }

                    #[inline( always )] fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if input.get_anchored().is_anchored() {
                            return self.core.is_match(cache, input);
                        }
                        match self.try_search_half_start(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse suffix half optimization failed: {_err}");
                                self.core.is_match_nofail(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!(
                                    "reverse suffix reverse fast half search failed: {_err}"
                                );
                                self.core.is_match_nofail(cache, input)
                            }
                            Ok( None ) => false,
                            Ok(Some(_)) => true,
                        }
                    }

                    #[inline( always )] fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_slots(cache, input, slots);
                        }
                        if !self.core.is_capture_search_needed(slots.len()) {
                            trace!("asked for slots unnecessarily, trying fast path");
                            let m = self.search(cache, input)?;
                            copy_match_to_slots(m, slots);
                            return Some(m.pattern());
                        }
                        let hm_start = match self.try_search_half_start(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                trace!("reverse suffix captures optimization failed: {_err}");
                                return self.core.search_slots(cache, input, slots);
                            }
                            Err(RetryError::Fail(_err)) => {
                                trace!(
                                    "reverse suffix reverse fast captures search failed: \
                                        {_err}"
                                );
                                return self.core.search_slots_nofail(cache, input, slots);
                            }
                            Ok( None ) => return None,
                            Ok(Some(hm_start)) => hm_start,
                        };
                        trace!(
                            "match found at {}..{} in capture search, \
                            using another engine to find captures",
                            hm_start.offset(),
                            input.end(),
                        );
                        let start = hm_start.offset();
                        let input = input
                            .clone()
                            .span(start..input.end())
                            .anchored(Anchored::Pattern(hm_start.pattern()));
                        self.core.search_slots_nofail(cache, &input, slots)
                    }

                    #[inline( always )] fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        self.core.which_overlapping_matches(cache, input, patset)
                    }
                }

                #[derive( Debug )]
                struct ReverseInner {
                    core: Core,
                    preinner: Prefilter,
                    nfarev: NFA,
                    hybrid: wrappers::ReverseHybrid,
                    dfa: wrappers::ReverseDFA,
                }

                impl ReverseInner
                {
                    fn new(core: Core, hirs: &[&Hir]) -> Result<ReverseInner, Core> {
                        if !core.info.config().get_auto_prefilter() {
                            
                            return Err(core);
                        }
                        if core.info.config().get_match_kind() != MatchKind::LeftmostFirst {
                            return Err(core);
                        }
                        //
                        if core.info.is_always_anchored_start() {
                            
                            return Err(core);
                        }

                        if !core.hybrid.is_some() && !core.dfa.is_some() {
                            
                            return Err(core);
                        }
                        if core.pre.as_ref().map_or(false, |p| p.is_fast()) {
                            
                            return Err(core);
                        } else if core.pre.is_some() {
                        }
                        let (concat_prefix, preinner) = match reverse_inner::extract(hirs) {
                            Some(x) => x,
                            None => return Err(core),
                        };
                        
                        let mut lookm = LookMatcher::new();
                        lookm.set_line_terminator(core.info.config().get_line_terminator());
                        let thompson_config = thompson::Config::new()
                            .reverse(true)
                            .utf8(core.info.config().get_utf8_empty())
                            .nfa_size_limit(core.info.config().get_nfa_size_limit())
                            .shrink( false )
                            .which_captures(WhichCaptures::None)
                            .look_matcher(lookm);
                        let result = thompson::Compiler::new()
                            .configure(thompson_config)
                            .build_from_hir(&concat_prefix);
                        let nfarev = match result {
                            Ok(nfarev) => nfarev,
                            Err(_err) => {
                                return Err(core);
                            }
                        };
                        
                        let dfa = if !core.info.config().get_dfa() {
                            wrappers::ReverseDFA::none()
                        } else {
                            wrappers::ReverseDFA::new(&core.info, &nfarev)
                        };
                        let hybrid = if !core.info.config().get_hybrid() {
                            wrappers::ReverseHybrid::none()
                        } else if dfa.is_some() {
                            
                            wrappers::ReverseHybrid::none()
                        } else {
                            wrappers::ReverseHybrid::new(&core.info, &nfarev)
                        };
                        Ok(ReverseInner { core, preinner, nfarev, hybrid, dfa })
                    }

                    #[inline( always )] fn try_search_full(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, RetryError>
                    {
                        let mut span = input.get_span();
                        let mut min_match_start = 0;
                        let mut min_pre_start = 0;
                        loop {
                            let litmatch = match self.preinner.find(input.haystack(), span) {
                                None => return Ok( None ),
                                Some(span) => span,
                            };
                            if litmatch.start < min_pre_start {
                                return Err(RetryError::Quadratic(RetryQuadraticError::new()));
                            }
                            
                            let revinput = input
                                .clone()
                                .anchored(Anchored::Yes)
                                .span(input.start()..litmatch.start);
                            match self.try_search_half_rev_limited(
                                cache,
                                &revinput,
                                min_match_start,
                            )? {
                                None => {
                                    if span.start >= span.end {
                                        break;
                                    }
                                    span.start = litmatch.start.checked_add(1).unwrap();
                                }
                                Some(hm_start) => {
                                    let fwdinput = input
                                        .clone()
                                        .anchored(Anchored::Pattern(hm_start.pattern()))
                                        .span(hm_start.offset()..input.end());
                                    match self.try_search_half_fwd_stopat(cache, &fwdinput)? {
                                        Err(stopat) => {
                                            min_pre_start = stopat;
                                            span.start =
                                                litmatch.start.checked_add(1).unwrap();
                                        }
                                        Ok(hm_end) => {
                                            return Ok(Some(Match::new(
                                                hm_start.pattern(),
                                                hm_start.offset()..hm_end.offset(),
                                            )))
                                        }
                                    }
                                }
                            }
                            min_match_start = litmatch.end;
                        }
                        Ok( None )
                    }

                    #[inline( always )] fn try_search_half_fwd_stopat(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {
                        if let Some(e) = self.core.dfa.get(&input) {
                            e.try_search_half_fwd_stopat(&input)
                        } else if let Some(e) = self.core.hybrid.get(&input) {
                            e.try_search_half_fwd_stopat(&mut cache.hybrid, &input)
                        } else {
                            unreachable!("ReverseInner always has a DFA")
                        }
                    }

                    #[inline( always )] fn try_search_half_rev_limited(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                        if let Some(e) = self.dfa.get(&input) {
                            e.try_search_half_rev_limited(&input, min_start)
                        } else if let Some(e) = self.hybrid.get(&input) {
                            e.try_search_half_rev_limited(
                                &mut cache.revhybrid,
                                &input,
                                min_start,
                            )
                        } else {
                            unreachable!("ReverseInner always has a DFA")
                        }
                    }
                }

                impl Strategy for ReverseInner {
                    #[inline( always )] fn group_info( &self ) -> &GroupInfo { self.core.group_info() }

                    #[inline( always )] fn create_cache( &self ) -> Cache {
                        let mut cache = self.core.create_cache();
                        cache.revhybrid = self.hybrid.create_cache();
                        cache
                    }

                    #[inline( always )] fn reset_cache(&self, cache: &mut Cache) {
                        self.core.reset_cache(cache);
                        cache.revhybrid.reset(&self.hybrid);
                    }

                    fn is_accelerated( &self ) -> bool { self.preinner.is_fast() }

                    fn memory_usage( &self ) -> usize {
                        self.core.memory_usage()
                            + self.preinner.memory_usage()
                            + self.nfarev.memory_usage()
                            + self.dfa.memory_usage()
                    }

                    #[inline( always )] fn search(&self, cache: &mut Cache, input: &Input<'_>) -> Option<Match> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search(cache, input);
                        }
                        match self.try_search_full(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                self.core.search(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                self.core.search_nofail(cache, input)
                            }
                            Ok(matornot) => matornot,
                        }
                    }

                    #[inline( always )] fn search_half(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                    ) -> Option<HalfMatch> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_half(cache, input);
                        }
                        match self.try_search_full(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                self.core.search_half(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                self.core.search_half_nofail(cache, input)
                            }
                            Ok( None ) => None,
                            Ok(Some(m)) => Some(HalfMatch::new(m.pattern(), m.end())),
                        }
                    }

                    #[inline( always )] fn is_match(&self, cache: &mut Cache, input: &Input<'_>) -> bool {
                        if input.get_anchored().is_anchored() {
                            return self.core.is_match(cache, input);
                        }
                        match self.try_search_full(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                self.core.is_match_nofail(cache, input)
                            }
                            Err(RetryError::Fail(_err)) => {
                                self.core.is_match_nofail(cache, input)
                            }
                            Ok( None ) => false,
                            Ok(Some(_)) => true,
                        }
                    }

                    #[inline( always )] fn search_slots(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        if input.get_anchored().is_anchored() {
                            return self.core.search_slots(cache, input, slots);
                        }
                        if !self.core.is_capture_search_needed(slots.len()) {
                            let m = self.search(cache, input)?;
                            copy_match_to_slots(m, slots);
                            return Some(m.pattern());
                        }
                        let m = match self.try_search_full(cache, input) {
                            Err(RetryError::Quadratic(_err)) => {
                                return self.core.search_slots(cache, input, slots);
                            }
                            Err(RetryError::Fail(_err)) => {
                                return self.core.search_slots_nofail(cache, input, slots);
                            }
                            Ok( None ) => return None,
                            Ok(Some(m)) => m,
                        };
                        
                        let input = input
                            .clone()
                            .span(m.start()..m.end())
                            .anchored(Anchored::Pattern(m.pattern()));
                        self.core.search_slots_nofail(cache, &input, slots)
                    }

                    #[inline( always )] fn which_overlapping_matches(
                        &self,
                        cache: &mut Cache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        self.core.which_overlapping_matches(cache, input, patset)
                    }
                }

                #[inline( always )] fn copy_match_to_slots(m: Match, slots: &mut [Option<NonMaxUsize>])
                {
                    let slot_start = m.pattern().as_usize() * 2;
                    let slot_end = slot_start + 1;
                    if let Some(slot) = slots.get_mut(slot_start) {
                        *slot = NonMaxUsize::new(m.start());
                    }
                    if let Some(slot) = slots.get_mut(slot_end) {
                        *slot = NonMaxUsize::new(m.end());
                    }
                }
            }

            pub mod wrappers
            {
                /*!
                This module contains a boat load of wrappers around each of our internal regex engines. */
                use ::
                {
                    *,
                };
                /*
                use alloc::vec::Vec;

                use crate::{
                    meta::{
                        error::{BuildError, RetryError, RetryFailError},
                        regex::RegexInfo,
                    },
                    nfa::thompson::{pikevm, NFA},
                    util::{prefilter::Prefilter, primitives::NonMaxUsize},
                    HalfMatch, Input, Match, MatchKind, PatternID, PatternSet,
                };

                use crate::dfa;
                #[cfg(feature = "dfa-onepass")]
                use crate::dfa::onepass;
                use crate::hybrid;
                #[cfg(feature = "nfa-backtrack")]
                use crate::nfa::thompson::backtrack;
                */
                #[derive( Debug )]
                pub struct PikeVM(PikeVMEngine);

                impl PikeVM
                {
                    pub fn new(
                        info: &RegexInfo,
                        pre:Option<Prefilter>,
                        nfa: &NFA,
                    ) -> Result<PikeVM, BuildError> { PikeVMEngine::new(info, pre, nfa).map(PikeVM) }

                    pub fn create_cache( &self ) -> PikeVMCache { PikeVMCache::none() }

                    #[inline( always )]
                    pub fn get( &self ) -> &PikeVMEngine { &self.0 }
                }

                #[derive( Debug )]
                pub struct PikeVMEngine(pikevm::PikeVM);

                impl PikeVMEngine
                {
                    pub fn new(
                        info: &RegexInfo,
                        pre:Option<Prefilter>,
                        nfa: &NFA,
                    ) -> Result<PikeVMEngine, BuildError>
                    {
                        let pikevm_config = pikevm::Config::new()
                            .match_kind(info.config().get_match_kind())
                            .prefilter(pre);
                        let engine = pikevm::Builder::new()
                            .configure(pikevm_config)
                            .build_from_nfa(nfa.clone())
                            .map_err(BuildError::nfa)?;
                        Ok(PikeVMEngine(engine))
                    }

                    #[inline( always )]
                    pub fn is_match(
                        &self,
                        cache: &mut PikeVMCache,
                        input: &Input<'_>,
                    ) -> bool {
                        self.0.is_match(cache.get(&self.0), input.clone())
                    }

                    #[inline( always )]
                    pub fn search_slots(
                        &self,
                        cache: &mut PikeVMCache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> { self.0.search_slots(cache.get(&self.0), input, slots) }

                    #[inline( always )]
                    pub fn which_overlapping_matches(
                        &self,
                        cache: &mut PikeVMCache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) {
                        self.0.which_overlapping_matches(cache.get(&self.0), input, patset)
                    }
                }

                #[derive( Clone, Debug )]
                pub struct PikeVMCache(Option<pikevm::Cache>);

                impl PikeVMCache
                {
                    pub fn none() -> PikeVMCache {
                        PikeVMCache( None )
                    }

                    pub fn reset( &mut self, builder: &PikeVM) {
                        self.get(&builder.get().0).reset(&builder.get().0);
                    }

                    pub fn memory_usage( &self ) -> usize { self.0.as_ref().map_or(0, |c| c.memory_usage()) }

                    fn get( &mut self, vm: &pikevm::PikeVM) -> &mut pikevm::Cache {
                        self.0.get_or_insert_with(|| vm.create_cache())
                    }
                }

                #[derive( Debug )]
                pub struct BoundedBacktracker(Option<BoundedBacktrackerEngine>);

                impl BoundedBacktracker
                {
                    pub fn new(
                        info: &RegexInfo,
                        pre:Option<Prefilter>,
                        nfa: &NFA,
                    ) -> Result<BoundedBacktracker, BuildError> { BoundedBacktrackerEngine::new(info, pre, nfa).map(BoundedBacktracker) }

                    pub fn create_cache( &self ) -> BoundedBacktrackerCache { BoundedBacktrackerCache::none() }

                    #[inline( always )]
                    pub fn get(
                        &self,
                        input: &Input<'_>,
                    ) -> Option<&BoundedBacktrackerEngine>
                    {
                        let engine = self.0.as_ref()?;
                        if input.get_earliest() && input.haystack().len() > 128 {
                            return None;
                        }
                        
                        if input.get_span().len() > engine.max_haystack_len() {
                            return None;
                        }
                        Some(engine)
                    }
                }

                #[derive( Debug )]
                pub struct BoundedBacktrackerEngine(
                    backtrack::BoundedBacktracker
                );

                impl BoundedBacktrackerEngine
                {
                    pub fn new(
                        info: &RegexInfo,
                        pre:Option<Prefilter>,
                        nfa: &NFA,
                    ) -> Result<Option<BoundedBacktrackerEngine>, BuildError> {
                        if !info.config().get_backtrack()
                            || info.config().get_match_kind() != MatchKind::LeftmostFirst
                        {
                            return Ok( None );
                        }
                        let backtrack_config = backtrack::Config::new().prefilter(pre);
                        let engine = backtrack::Builder::new()
                            .configure(backtrack_config)
                            .build_from_nfa(nfa.clone())
                            .map_err(BuildError::nfa)?;
                        Ok(Some(BoundedBacktrackerEngine(engine)))
                    }

                    #[inline( always )]
                    pub fn is_match(
                        &self,
                        cache: &mut BoundedBacktrackerCache,
                        input: &Input<'_>,
                    ) -> bool {
                        self.0.try_is_match(cache.get(&self.0), input.clone()).unwrap()
                    }

                    #[inline( always )]
                    pub fn search_slots(
                        &self,
                        cache: &mut BoundedBacktrackerCache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> { self.0.try_search_slots(cache.get(&self.0), input, slots).unwrap() }

                    #[inline( always )] fn max_haystack_len( &self ) -> usize { self.0.max_haystack_len() }
                }

                #[derive( Clone, Debug )]
                pub struct BoundedBacktrackerCache(
                    Option<backtrack::Cache>
                );

                impl BoundedBacktrackerCache
                {
                    pub fn none() -> BoundedBacktrackerCache {
                        BoundedBacktrackerCache( None )
                    }

                    pub fn reset( &mut self, builder: &BoundedBacktracker) {
                        if let Some(ref e) = builder.0 {
                            self.get(&e.0).reset(&e.0);
                        }
                    }

                    pub fn memory_usage( &self ) -> usize { self.0.as_ref().map_or(0, |c| c.memory_usage()) }
                    
                    fn get(
                        &mut self,
                        bb: &backtrack::BoundedBacktracker,
                    ) -> &mut backtrack::Cache {
                        self.0.get_or_insert_with(|| bb.create_cache())
                    }
                }

                #[derive( Debug )]
                pub struct OnePass(Option<OnePassEngine>);

                impl OnePass
                {
                    pub fn new(info: &RegexInfo, nfa: &NFA) -> OnePass {
                        OnePass(OnePassEngine::new(info, nfa))
                    }

                    pub fn create_cache( &self ) -> OnePassCache { OnePassCache::new(self) }

                    #[inline( always )]
                    pub fn get(&self, input: &Input<'_>) -> Option<&OnePassEngine>
                    {
                        let engine = self.0.as_ref()?;
                        if !input.get_anchored().is_anchored()
                            && !engine.get_nfa().is_always_start_anchored()
                        {
                            return None;
                        }
                        Some(engine)
                    }

                    pub fn memory_usage( &self ) -> usize { self.0.as_ref().map_or(0, |e| e.memory_usage()) }
                }

                #[derive( Debug )]
                pub struct OnePassEngine(
                    onepass::DFA
                );

                impl OnePassEngine
                {
                    pub fn new(info: &RegexInfo, nfa: &NFA) -> Option<OnePassEngine> {
                        if !info.config().get_onepass() {
                                return None;
                            }
                            
                            if info.props_union().explicit_captures_len() == 0
                                && !info.props_union().look_set().contains_word_unicode()
                            {
                                return None;
                            }
                            let onepass_config = onepass::Config::new()
                                .match_kind(info.config().get_match_kind())
                                .starts_for_each_pattern(true)
                                .byte_classes(info.config().get_byte_classes())
                                .size_limit(info.config().get_onepass_size_limit());
                            let result = onepass::Builder::new()
                                .configure(onepass_config)
                                .build_from_nfa(nfa.clone());
                            let engine = match result {
                                Ok(engine) => engine,
                                Err(_err) => {
                                    return None;
                                }
                            };
                            
                            Some(OnePassEngine(engine))
                    }

                    #[inline( always )]
                    pub fn search_slots(
                        &self,
                        cache: &mut OnePassCache,
                        input: &Input<'_>,
                        slots: &mut [Option<NonMaxUsize>],
                    ) -> Option<PatternID> {
                        self.0
                                .try_search_slots(cache.0.as_mut().unwrap(), input, slots)
                                .unwrap()
                    }

                    pub fn memory_usage( &self ) -> usize { self.0.memory_usage() }

                    #[inline( always )] fn get_nfa( &self ) -> &NFA { self.0.get_nfa() }
                }

                #[derive( Clone, Debug )]
                pub struct OnePassCache(
                    Option<onepass::Cache>
                );

                impl OnePassCache
                {
                    pub fn none() -> OnePassCache {
                        OnePassCache( None )
                    }

                    pub fn new(builder: &OnePass) -> OnePassCache {
                        OnePassCache(builder.0.as_ref().map(|e| e.0.create_cache()))
                    }

                    pub fn reset( &mut self, builder: &OnePass) {
                        if let Some(ref e) = builder.0 {
                            self.0.as_mut().unwrap().reset(&e.0);
                        }
                    }

                    pub fn memory_usage( &self ) -> usize { self.0.as_ref().map_or(0, |c| c.memory_usage()) }
                }

                #[derive( Debug )]
                pub struct Hybrid(Option<HybridEngine>);

                impl Hybrid
                {
                    pub fn none() -> Hybrid {
                        Hybrid( None )
                    }

                    pub fn new(
                        info: &RegexInfo,
                        pre:Option<Prefilter>,
                        nfa: &NFA,
                        nfarev: &NFA,
                    ) -> Hybrid {
                        Hybrid(HybridEngine::new(info, pre, nfa, nfarev))
                    }

                    pub fn create_cache( &self ) -> HybridCache { HybridCache::new(self) }

                    #[inline( always )]
                    pub fn get(&self, _input: &Input<'_>) -> Option<&HybridEngine>
                    {
                        let engine = self.0.as_ref()?;
                        Some(engine)
                    }

                    pub fn is_some( &self ) -> bool { self.0.is_some() }
                }

                #[derive( Debug )]
                pub struct HybridEngine(
                    hybrid::regex::Regex
                );

                impl HybridEngine
                {
                    pub fn new(
                        info: &RegexInfo,
                        pre:Option<Prefilter>,
                        nfa: &NFA,
                        nfarev: &NFA,
                    ) -> Option<HybridEngine> 
                    {
                        if !info.config().get_hybrid() {
                            return None;
                        }
                        let dfa_config = hybrid::dfa::Config::new()
                            .match_kind(info.config().get_match_kind())
                            .prefilter(pre.clone())
                            .starts_for_each_pattern(true)
                            .byte_classes(info.config().get_byte_classes())
                            .unicode_word_boundary(true)
                            .specialize_start_states(pre.is_some())
                            .cache_capacity(info.config().get_hybrid_cache_capacity())
                            .skip_cache_capacity_check( false )
                            .minimum_cache_clear_count(Some(3))
                            .minimum_bytes_per_state(Some(10));
                        let result = hybrid::dfa::Builder::new()
                            .configure(dfa_config.clone())
                            .build_from_nfa(nfa.clone());
                        let fwd = match result {
                            Ok(fwd) => fwd,
                            Err(_err) => {
                                return None;
                            }
                        };
                        let result = hybrid::dfa::Builder::new()
                            .configure(
                                dfa_config
                                    .clone()
                                    .match_kind(MatchKind::All)
                                    .prefilter( None )
                                    .specialize_start_states( false ),
                            )
                            .build_from_nfa(nfarev.clone());
                        let rev = match result {
                            Ok(rev) => rev,
                            Err(_err) => {
                                return None;
                            }
                        };
                        let engine =
                            hybrid::regex::Builder::new().build_from_dfas(fwd, rev);
                        Some(HybridEngine(engine))
                    }

                    #[inline( always )]
                    pub fn try_search(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, RetryFailError> {
                        let cache = cache.0.as_mut().unwrap();
                        self.0.try_search(cache, input).map_err(|e| e.into())
                    }

                    #[inline( always )]
                    pub fn try_search_half_fwd(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> 
                    {
                        let fwd = self.0.forward();
                        let mut fwdcache = cache.0.as_mut().unwrap().as_parts_mut().0;
                        fwd.try_search_fwd(&mut fwdcache, input).map_err(|e| e.into())
                    }

                    #[inline( always )]
                    pub fn try_search_half_fwd_stopat(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {
                        let dfa = self.0.forward();
                        let mut cache = cache.0.as_mut().unwrap().as_parts_mut().0;
                        regex::automata::meta::stopat::hybrid_try_search_half_fwd(
                        dfa, &mut cache, input,
                        )
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                                let rev = self.0.reverse();
                            let mut revcache = cache.0.as_mut().unwrap().as_parts_mut().1;
                            rev.try_search_rev(&mut revcache, input).map_err(|e| e.into())
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev_limited(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                                let dfa = self.0.reverse();
                            let mut cache = cache.0.as_mut().unwrap().as_parts_mut().1;
                            crate::meta::limited::hybrid_try_search_half_rev(
                                dfa, &mut cache, input, min_start,
                            )
                    }
                    #[inline] pub fn try_which_overlapping_matches(
                        &self,
                        cache: &mut HybridCache,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), RetryFailError> {
                            let fwd = self.0.forward();
                        let mut fwdcache = cache.0.as_mut().unwrap().as_parts_mut().0;
                        fwd.try_which_overlapping_matches(&mut fwdcache, input, patset)
                            .map_err(|e| e.into())
                    }
                }

                #[derive( Clone, Debug )]
                pub struct HybridCache(
                    Option<hybrid::regex::Cache>
                );

                impl HybridCache
                {
                    pub fn none() -> HybridCache { HybridCache( None )
                    }

                    pub fn new(builder: &Hybrid) -> HybridCache {
                            HybridCache(builder.0.as_ref().map(|e| e.0.create_cache()))
                    }

                    pub fn reset( &mut self, builder: &Hybrid) {
                                if let Some(ref e) = builder.0 {
                            self.0.as_mut().unwrap().reset(&e.0);
                        }
                    }

                    pub fn memory_usage( &self ) -> usize {
                            self.0.as_ref().map_or(0, |c| c.memory_usage())
                    }
                }

                #[derive( Debug )]
                pub struct DFA(Option<DFAEngine>);

                impl DFA
                {
                    pub fn none() -> DFA {
                        DFA( None )
                    }

                    pub fn new(
                        info: &RegexInfo,
                        pre:Option<Prefilter>,
                        nfa: &NFA,
                        nfarev: &NFA,
                    ) -> DFA {
                        DFA(DFAEngine::new(info, pre, nfa, nfarev))
                    }

                    #[inline( always )]
                    pub fn get(&self, _input: &Input<'_>) -> Option<&DFAEngine>
                    {
                        let engine = self.0.as_ref()?;
                        Some(engine)
                    }

                    pub fn is_some( &self ) -> bool { self.0.is_some() }

                    pub fn memory_usage( &self ) -> usize { self.0.as_ref().map_or(0, |e| e.memory_usage()) }
                }

                #[derive( Debug )]
                pub struct DFAEngine(
                    dfa::regex::Regex
                );

                impl DFAEngine
                {
                    pub fn new(
                        info: &RegexInfo,
                        pre:Option<Prefilter>,
                        nfa: &NFA,
                        nfarev: &NFA,
                    ) -> Option<DFAEngine>
                    {
                        if !info.config().get_dfa() {
                                return None;
                            }
                            
                            if let Some(state_limit) = info.config().get_dfa_state_limit() {
                                if nfa.states().len() > state_limit {
                                    return None;
                                }
                            }
                            
                            let size_limit = info.config().get_dfa_size_limit().map(|n| n / 4);
                            let dfa_config = dfa::dense::Config::new()
                                .match_kind(info.config().get_match_kind())
                                .prefilter(pre.clone())
                                
                                .starts_for_each_pattern(true)
                                .byte_classes(info.config().get_byte_classes())
                                .unicode_word_boundary(true)
                                .specialize_start_states(pre.is_some())
                                .determinize_size_limit(size_limit)
                                .dfa_size_limit(size_limit);
                            let result = dfa::dense::Builder::new()
                                .configure(dfa_config.clone())
                                .build_from_nfa(&nfa);
                            let fwd = match result {
                                Ok(fwd) => fwd,
                                Err(_err) => {
                                    return None;
                                }
                            };
                            let result = dfa::dense::Builder::new()
                                .configure(
                                    dfa_config
                                        .clone()
                                        .start_kind(dfa::StartKind::Anchored)
                                        .match_kind(MatchKind::All)
                                        .prefilter( None )
                                        .specialize_start_states( false ),
                                )
                                .build_from_nfa(&nfarev);
                            let rev = match result {
                                Ok(rev) => rev,
                                Err(_err) => {
                                    return None;
                                }
                            };
                            let engine = dfa::regex::Builder::new().build_from_dfas(fwd, rev);
                            Some(DFAEngine(engine))
                        
                    }

                    #[inline( always )]
                    pub fn try_search(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<Match>, RetryFailError> {  self.0.try_search(input).map_err(|e| e.into())
                    }

                    #[inline( always )]
                    pub fn try_search_half_fwd(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                        use crate::dfa::Automaton;
                            self.0.forward().try_search_fwd(input).map_err(|e| e.into())
                    }

                    #[inline( always )]
                    pub fn try_search_half_fwd_stopat(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Result<HalfMatch, usize>, RetryFailError> {
                            let dfa = self.0.forward();
                            crate::meta::stopat::dfa_try_search_half_fwd(dfa, input)
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev(
                        &self,
                        input: &Input<'_>,
                    ) -> Result<Option<HalfMatch>, RetryFailError> {
                                use crate::dfa::Automaton;
                            self.0.reverse().try_search_rev(&input).map_err(|e| e.into())
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev_limited(
                        &self,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                                let dfa = self.0.reverse();
                            crate::meta::limited::dfa_try_search_half_rev(
                                dfa, input, min_start,
                            )
                    }
                    #[inline] pub fn try_which_overlapping_matches(
                        &self,
                        input: &Input<'_>,
                        patset: &mut PatternSet,
                    ) -> Result<(), RetryFailError> {
                                use crate::dfa::Automaton;
                            self.0
                                .forward()
                                .try_which_overlapping_matches(input, patset)
                                .map_err(|e| e.into())
                    }

                    pub fn memory_usage( &self ) -> usize {
                               self.0.forward().memory_usage() + self.0.reverse().memory_usage()
                    }
                }

                #[derive( Debug )]
                pub struct ReverseHybrid(Option<ReverseHybridEngine>);

                impl ReverseHybrid
                {
                    pub fn none() -> ReverseHybrid {
                        ReverseHybrid( None )
                    }

                    pub fn new(info: &RegexInfo, nfarev: &NFA) -> ReverseHybrid {
                        ReverseHybrid(ReverseHybridEngine::new(info, nfarev))
                    }

                    pub fn create_cache( &self ) -> ReverseHybridCache { ReverseHybridCache::new(self) }

                    #[inline( always )]
                    pub fn get(
                        &self,
                        _input: &Input<'_>,
                    ) -> Option<&ReverseHybridEngine>
                    {
                        let engine = self.0.as_ref()?;
                        Some(engine)
                    }
                }

                #[derive( Debug )]
                pub struct ReverseHybridEngine(
                    hybrid::dfa::DFA
                );

                impl ReverseHybridEngine
                {
                    pub fn new(
                        info: &RegexInfo,
                        nfarev: &NFA,
                    ) -> Option<ReverseHybridEngine> {
                                if !info.config().get_hybrid() {
                                return None;
                            }
                            
                            let dfa_config = hybrid::dfa::Config::new()
                                .match_kind(MatchKind::All)
                                .prefilter( None )
                                .starts_for_each_pattern( false )
                                .byte_classes(info.config().get_byte_classes())
                                .unicode_word_boundary(true)
                                .specialize_start_states( false )
                                .cache_capacity(info.config().get_hybrid_cache_capacity())
                                .skip_cache_capacity_check( false )
                                .minimum_cache_clear_count(Some(3))
                                .minimum_bytes_per_state(Some(10));
                            let result = hybrid::dfa::Builder::new()
                                .configure(dfa_config)
                                .build_from_nfa(nfarev.clone());
                            let rev = match result {
                                Ok(rev) => rev,
                                Err(_err) => {
                                    return None;
                                }
                            };
                            Some(ReverseHybridEngine(rev))
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev_limited(
                        &self,
                        cache: &mut ReverseHybridCache,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                                let dfa = &self.0;
                            let mut cache = cache.0.as_mut().unwrap();
                            crate::meta::limited::hybrid_try_search_half_rev(
                                dfa, &mut cache, input, min_start,
                            )
                    }
                }

                #[derive( Clone, Debug )]
                pub struct ReverseHybridCache(
                    Option<hybrid::dfa::Cache>
                );

                impl ReverseHybridCache
                {
                    pub fn none() -> ReverseHybridCache { ReverseHybridCache( None ) }

                    pub fn new(builder: &ReverseHybrid) -> ReverseHybridCache { ReverseHybridCache(builder.0.as_ref().map(|e| e.0.create_cache())) }

                    pub fn reset( &mut self, builder: &ReverseHybrid) {
                                if let Some(ref e) = builder.0 {
                            self.0.as_mut().unwrap().reset(&e.0);
                        }
                    }

                    pub fn memory_usage( &self ) -> usize {
                                self.0.as_ref().map_or(0, |c| c.memory_usage())
                    }
                }

                #[derive( Debug )]
                pub struct ReverseDFA(Option<ReverseDFAEngine>);

                impl ReverseDFA
                {
                    pub fn none() -> ReverseDFA {
                        ReverseDFA( None )
                    }

                    pub fn new(info: &RegexInfo, nfarev: &NFA) -> ReverseDFA {
                        ReverseDFA(ReverseDFAEngine::new(info, nfarev))
                    }

                    #[inline( always )]
                    pub fn get(&self, _input: &Input<'_>) -> Option<&ReverseDFAEngine>
                    {
                        let engine = self.0.as_ref()?;
                        Some(engine)
                    }

                    pub fn is_some( &self ) -> bool { self.0.is_some() }

                    pub fn memory_usage( &self ) -> usize { self.0.as_ref().map_or(0, |e| e.memory_usage()) }
                }

                #[derive( Debug )]
                pub struct ReverseDFAEngine(
                    dfa::dense::DFA<Vec<u32>>
                );

                impl ReverseDFAEngine
                {
                    pub fn new(
                        info: &RegexInfo,
                        nfarev: &NFA,
                    ) -> Option<ReverseDFAEngine> {
                                if !info.config().get_dfa() {
                                return None;
                            }
                            
                            if let Some(state_limit) = info.config().get_dfa_state_limit() {
                                if nfarev.states().len() > state_limit {
                                    return None;
                                }
                            }
                            let size_limit = info.config().get_dfa_size_limit().map(|n| n / 2);
                            let dfa_config = dfa::dense::Config::new()
                                .match_kind(MatchKind::All)
                                .prefilter( None )
                                .accelerate( false )
                                .start_kind(dfa::StartKind::Anchored)
                                .starts_for_each_pattern( false )
                                .byte_classes(info.config().get_byte_classes())
                                .unicode_word_boundary(true)
                                .specialize_start_states( false )
                                .determinize_size_limit(size_limit)
                                .dfa_size_limit(size_limit);
                            let result = dfa::dense::Builder::new()
                                .configure(dfa_config)
                                .build_from_nfa(&nfarev);
                            let rev = match result {
                                Ok(rev) => rev,
                                Err(_err) => {
                                    return None;
                                }
                            };
                            Some(ReverseDFAEngine(rev))
                    }

                    #[inline( always )]
                    pub fn try_search_half_rev_limited(
                        &self,
                        input: &Input<'_>,
                        min_start: usize,
                    ) -> Result<Option<HalfMatch>, RetryError> {
                                 let dfa = &self.0;
                            crate::meta::limited::dfa_try_search_half_rev(
                                dfa, input, min_start,
                            )
                    }

                    pub fn memory_usage( &self ) -> usize {self.0.memory_usage()}
                }
            }
        }
        
        pub mod nfa
        {
            /*!
            Provides non-deterministic finite automata (NFA) and regex engines that use them. */
            use ::
            {
                *,
            };
            /*
            */
            pub mod thompson
            {
                /*!
                Defines a Thompson NFA and provides the [`PikeVM`](pikevm::PikeVM) and [`BoundedBacktracker`](backtrack::BoundedBacktracker) regex engines.*/
                use ::
                {
                    *,
                };
                /*
                pub use self::{
                    builder::Builder,
                    error::BuildError,
                    nfa::{
                        DenseTransitions, PatternIter, SparseTransitions, State, Transition,
                        NFA,
                    },
                };
                #[cfg(feature = "syntax")]
                pub use compiler::{Compiler, Config, WhichCaptures};
                pub mod __
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }
                */
                pub mod backtrack
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    use alloc::{vec, vec::Vec};

                    use crate::{
                        nfa::thompson::{self, BuildError, State, NFA},
                        util::{
                            captures::Captures,
                            empty, iter,
                            prefilter::Prefilter,
                            primitives::{NonMaxUsize, PatternID, SmallIndex, StateID},
                            search::{Anchored, HalfMatch, Input, Match, MatchError, Span},
                        },
                    };
                    */


                    pub fn min_visited_capacity(nfa: &NFA, input: &Input<'_>) -> usize {
                        div_ceil(nfa.states().len() * (input.get_span().len() + 1), 8)
                    }
                    #[derive( Clone, Debug, Default )]
                    pub struct Config {
                        pre:Option<Option<Prefilter>>,
                        visited_capacity:Option<usize>,
                    }

                    impl Config {

                        pub fn new() -> Config {
                            Config::default()
                        }
                        ///
                        pub fn prefilter( mut self, pre:Option<Prefilter>) -> Config {
                            self.pre = Some(pre);
                            self
                        }

                        ///
                        pub fn visited_capacity( mut self, capacity: usize) -> Config {
                            self.visited_capacity = Some(capacity);
                            self
                        }

                        pub fn get_prefilter( &self ) -> Option<&Prefilter> { self.pre.as_ref().unwrap_or( &None ).as_ref() }
                        pub fn get_visited_capacity( &self ) -> usize {
                            const DEFAULT: usize = 256 * (1 << 10); // 256 KB
                            self.visited_capacity.unwrap_or(DEFAULT)
                        }
                        pub fn overwrite(&self, o: Config) -> Config {
                            Config {
                                pre: o.pre.or_else(|| self.pre.clone()),
                                visited_capacity: o.visited_capacity.or( self.visited_capacity),
                            }
                        }
                    }

                    #[derive( Clone, Debug )]
                    pub struct Builder {
                        config: Config,
                            thompson: thompson::Compiler,
                    }

                    impl Builder {

                        pub fn new() -> Builder {
                            Builder {
                                config: Config::default(),
                                            thompson: thompson::Compiler::new(),
                            }
                        }
                            pub fn build(
                            &self,
                            pattern: &str,
                        ) -> Result<BoundedBacktracker, BuildError> { self.build_many(&[pattern]) }

                            pub fn build_many<P: AsRef<str>>(
                            &self,
                            patterns: &[P],
                        ) -> Result<BoundedBacktracker, BuildError> {
                            let nfa = self.thompson.build_many(patterns)?;
                            self.build_from_nfa(nfa)
                        }

                        pub fn build_from_nfa(
                            &self,
                            nfa: NFA,
                        ) -> Result<BoundedBacktracker, BuildError> {
                            nfa.look_set_any().available().map_err(BuildError::word)?;
                            Ok(BoundedBacktracker { config: self.config.clone(), nfa })
                        }
                        pub fn configure( &mut self, config: Config) -> &mut Builder {
                            self.config = self.config.overwrite(config);
                            self
                        }
                            pub fn syntax(
                            &mut self,
                            config: crate::util::syntax::Config,
                        ) -> &mut Builder {
                            self.thompson.syntax(config);
                            self
                        }
                            pub fn thompson( &mut self, config: thompson::Config) -> &mut Builder {
                            self.thompson.configure(config);
                            self
                        }
                    }
                    #[derive( Clone, Debug )]
                    pub struct BoundedBacktracker {
                        config: Config,
                        nfa: NFA,
                    }

                    impl BoundedBacktracker {
                            pub fn new(pattern: &str) -> Result<BoundedBacktracker, BuildError> { BoundedBacktracker::builder().build(pattern) }

                            pub fn new_many<P: AsRef<str>>(
                            patterns: &[P],
                        ) -> Result<BoundedBacktracker, BuildError> { BoundedBacktracker::builder().build_many(patterns) }
                        
                        pub fn new_from_nfa(nfa: NFA) -> Result<BoundedBacktracker, BuildError> { BoundedBacktracker::builder().build_from_nfa(nfa) }
                        
                        pub fn always_match() -> Result<BoundedBacktracker, BuildError> {
                            let nfa = thompson::NFA::always_match();
                            BoundedBacktracker::new_from_nfa(nfa)
                        }

                        pub fn never_match() -> Result<BoundedBacktracker, BuildError> {
                            let nfa = thompson::NFA::never_match();
                            BoundedBacktracker::new_from_nfa(nfa)
                        }

                        pub fn config() -> Config {
                            Config::new()
                        }
                        
                        pub fn builder() -> Builder {
                            Builder::new()
                        }
                        pub fn create_cache( &self ) -> Cache { Cache::new(self) }
                        pub fn create_captures( &self ) -> Captures { Captures::all( self.get_nfa().group_info().clone()) }

                        pub fn reset_cache(&self, cache: &mut Cache) {
                            cache.reset(self);
                        }
                        pub fn pattern_len( &self ) -> usize { self.nfa.pattern_len() }

                        #[inline] pub fn get_config( &self ) -> &Config { &self.config }

                        #[inline] pub fn get_nfa( &self ) -> &NFA { &self.nfa }

                        #[inline] pub fn max_haystack_len( &self ) -> usize {
                            let capacity = 8 * self.get_config().get_visited_capacity();
                            let blocks = div_ceil(capacity, Visited::BLOCK_SIZE);
                            let real_capacity = blocks.saturating_mul(Visited::BLOCK_SIZE);
                            (real_capacity / self.nfa.states().len()).saturating_sub(1)
                        }
                    }

                    impl BoundedBacktracker 
                    {

                        #[inline] pub fn try_is_match<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                        ) -> Result<bool, MatchError> {
                            let input = input.into().earliest(true);
                            self.try_search_slots(cache, &input, &mut []).map(|pid| pid.is_some())
                        }

                        #[inline] pub fn try_find<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                        ) -> Result<Option<Match>, MatchError> {
                            let input = input.into();
                            if self.get_nfa().pattern_len() == 1 {
                                let mut slots = [None, None];
                                let pid = match self.try_search_slots(cache, &input, &mut slots)? {
                                    None => return Ok( None ),
                                    Some(pid) => pid,
                                };
                                let start = match slots[0] {
                                    None => return Ok( None ),
                                    Some(s) => s.get(),
                                };
                                let end = match slots[1] {
                                    None => return Ok( None ),
                                    Some(s) => s.get(),
                                };
                                return Ok(Some(Match::new(pid, Span { start, end })));
                            }
                            let ginfo = self.get_nfa().group_info();
                            let slots_len = ginfo.implicit_slot_len();
                            let mut slots = vec![None; slots_len];
                            let pid = match self.try_search_slots(cache, &input, &mut slots)? {
                                None => return Ok( None ),
                                Some(pid) => pid,
                            };
                            let start = match slots[pid.as_usize() * 2] {
                                None => return Ok( None ),
                                Some(s) => s.get(),
                            };
                            let end = match slots[pid.as_usize() * 2 + 1] {
                                None => return Ok( None ),
                                Some(s) => s.get(),
                            };
                            Ok(Some(Match::new(pid, Span { start, end })))
                        }

                        #[inline] pub fn try_captures<'h, I: Into<Input<'h>>>(
                            &self,
                            cache: &mut Cache,
                            input: I,
                            caps: &mut Captures,
                        ) -> Result<(), MatchError> { self.try_search(cache, &input.into(), caps) }

                        #[inline] pub fn try_find_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                            &'r self,
                            cache: &'c mut Cache,
                            input: I,
                        ) -> TryFindMatches<'r, 'c, 'h> {
                            let caps = Captures::matches( self.get_nfa().group_info().clone());
                            let it = iter::Searcher::new(input.into());
                            TryFindMatches { re: self, cache, caps, it }
                        }

                        #[inline] pub fn try_captures_iter<'r, 'c, 'h, I: Into<Input<'h>>>(
                            &'r self,
                            cache: &'c mut Cache,
                            input: I,
                        ) -> TryCapturesMatches<'r, 'c, 'h> {
                            let caps = self.create_captures();
                            let it = iter::Searcher::new(input.into());
                            TryCapturesMatches { re: self, cache, caps, it }
                        }
                    }

                    impl BoundedBacktracker
                    {

                        #[inline] pub fn try_search(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            caps: &mut Captures,
                        ) -> Result<(), MatchError> {
                            caps.set_pattern( None );
                            let pid = self.try_search_slots(cache, input, caps.slots_mut())?;
                            caps.set_pattern(pid);
                            Ok( () )
                        }

                        #[inline] pub fn try_search_slots(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Result<Option<PatternID>, MatchError> {
                            let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                            if !utf8empty {
                                let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;
                                return Ok(maybe_hm.map(|hm| hm.pattern()));
                            }
                            let min = self.get_nfa().group_info().implicit_slot_len();
                            if slots.len() >= min {
                                let maybe_hm = self.try_search_slots_imp(cache, input, slots)?;
                                return Ok(maybe_hm.map(|hm| hm.pattern()));
                            }
                            if self.get_nfa().pattern_len() == 1 {
                                let mut enough = [None, None];
                                let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                                slots.copy_from_slice(&enough[..slots.len()]);
                                return Ok(got.map(|hm| hm.pattern()));
                            }
                            let mut enough = vec![None; min];
                            let got = self.try_search_slots_imp(cache, input, &mut enough)?;
                            slots.copy_from_slice(&enough[..slots.len()]);
                            Ok(got.map(|hm| hm.pattern()))
                        }
                        
                        #[inline( never )] fn try_search_slots_imp(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Result<Option<HalfMatch>, MatchError> {
                            let utf8empty = self.get_nfa().has_empty() && self.get_nfa().is_utf8();
                            let hm = match self.search_imp(cache, input, slots)? {
                                None => return Ok( None ),
                                Some(hm) if !utf8empty => return Ok(Some(hm)),
                                Some(hm) => hm,
                            };
                            empty::skip_splits_fwd(input, hm, hm.offset(), |input| {
                                Ok(self
                                    .search_imp(cache, input, slots)?
                                    .map(|hm| (hm, hm.offset())))
                            })
                        }

                        fn search_imp(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Result<Option<HalfMatch>, MatchError> {
                            for slot in slots.iter_mut() {
                                *slot = None;
                            }
                            cache.setup_search(&self, input)?;
                            if input.is_done() {
                                return Ok( None );
                            }
                            let (anchored, start_id) = match input.get_anchored() {
                                Anchored::No => (
                                    self.nfa.is_always_start_anchored(),
                                    self.nfa.start_anchored(),
                                ),
                                Anchored::Yes => (true, self.nfa.start_anchored()),
                                Anchored::Pattern(pid) => match self.nfa.start_pattern(pid) {
                                    None => return Ok( None ),
                                    Some(sid) => (true, sid),
                                },
                            };
                            if anchored {
                                let at = input.start();
                                return Ok( self.backtrack(cache, input, at, start_id, slots));
                            }
                            let pre = self.get_config().get_prefilter();
                            let mut at = input.start();
                            while at <= input.end() {
                                if let Some(ref pre) = pre {
                                    let span = Span::from(at..input.end());
                                    match pre.find(input.haystack(), span) {
                                        None => break,
                                        Some(ref span) => at = span.start,
                                    }
                                }
                                if let Some(hm) = self.backtrack(cache, input, at, start_id, slots)
                                {
                                    return Ok(Some(hm));
                                }
                                at += 1;
                            }
                            Ok( None )
                        }

                        #[inline( always )] fn backtrack(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            at: usize,
                            start_id: StateID,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<HalfMatch> {
                            cache.stack.push(Frame::Step { sid: start_id, at });
                            while let Some(frame) = cache.stack.pop() {
                                match frame {
                                    Frame::Step { sid, at } => {
                                        if let Some(hm) = self.step(cache, input, sid, at, slots) {
                                            return Some(hm);
                                        }
                                    }
                                    Frame::RestoreCapture { slot, offset } => { slots[slot] = offset; }
                                }
                            }
                            None
                        }

                        #[inline( always )] fn step(
                            &self,
                            cache: &mut Cache,
                            input: &Input<'_>,
                            mut sid: StateID,
                            mut at: usize,
                            slots: &mut [Option<NonMaxUsize>],
                        ) -> Option<HalfMatch> {
                            loop {
                                if !cache.visited.insert(sid, at - input.start()) {
                                    return None;
                                }
                                match *self.nfa.state(sid) {
                                    State::ByteRange { ref trans } => {
                                        if at >= input.end() {
                                            return None;
                                        }
                                        if !trans.matches(input.haystack(), at) {
                                            return None;
                                        }
                                        sid = trans.next;
                                        at += 1;
                                    }
                                    State::Sparse(ref sparse) => {
                                        if at >= input.end() {
                                            return None;
                                        }
                                        sid = sparse.matches(input.haystack(), at)?;
                                        at += 1;
                                    }
                                    State::Dense(ref dense) => {
                                        if at >= input.end() {
                                            return None;
                                        }
                                        sid = dense.matches(input.haystack(), at)?;
                                        at += 1;
                                    }
                                    State::Look { look, next } => {
                                        if !self.nfa.look_matcher().matches_inline(
                                            look,
                                            input.haystack(),
                                            at,
                                        ) {
                                            return None;
                                        }
                                        sid = next;
                                    }
                                    State::Union { ref alternates } => {
                                        sid = match alternates.get(0) {
                                            None => return None,
                                            Some(&sid) => sid,
                                        };
                                        cache.stack.extend(
                                            alternates[1..]
                                                .iter()
                                                .copied()
                                                .rev()
                                                .map(|sid| Frame::Step { sid, at }),
                                        );
                                    }
                                    State::BinaryUnion { alt1, alt2 } => {
                                        sid = alt1;
                                        cache.stack.push(Frame::Step { sid: alt2, at });
                                    }
                                    State::Capture { next, slot, .. } => {
                                        if slot.as_usize() < slots.len() {
                                            cache.stack.push(Frame::RestoreCapture {
                                                slot,
                                                offset: slots[slot],
                                            });
                                            slots[slot] = NonMaxUsize::new(at);
                                        }
                                        sid = next;
                                    }
                                    State::Fail => return None,
                                    State::Match { pattern_id } => { return Some(HalfMatch::new(pattern_id, at)); }
                                }
                            }
                        }
                    }

                    #[derive( Debug )]
                    pub struct TryFindMatches<'r, 'c, 'h> {
                        re: &'r BoundedBacktracker,
                        cache: &'c mut Cache,
                        caps: Captures,
                        it: iter::Searcher<'h>,
                    }

                    impl<'r, 'c, 'h> Iterator for TryFindMatches<'r, 'c, 'h> {
                        type Item = Result<Match, MatchError>;

                        #[inline] fn next(&mut self) -> Option<Result<Match, MatchError>>
                        {
                            let TryFindMatches { re, ref mut cache, ref mut caps, ref mut it } =
                                *self;
                            it.try_advance(|input| {
                                re.try_search(cache, input, caps)?;
                                Ok(caps.get_match())
                            })
                            .transpose()
                        }
                    }

                    #[derive( Debug )]
                    pub struct TryCapturesMatches<'r, 'c, 'h> {
                        re: &'r BoundedBacktracker,
                        cache: &'c mut Cache,
                        caps: Captures,
                        it: iter::Searcher<'h>,
                    }

                    impl<'r, 'c, 'h> Iterator for TryCapturesMatches<'r, 'c, 'h> {
                        type Item = Result<Captures, MatchError>;

                        #[inline] fn next(&mut self) -> Option<Result<Captures, MatchError>> {
                            let TryCapturesMatches { re, ref mut cache, ref mut caps, ref mut it } =
                                *self;
                            let _ = it
                                .try_advance(|input| {
                                    re.try_search(cache, input, caps)?;
                                    Ok(caps.get_match())
                                })
                                .transpose()?;
                            if caps.is_match() {
                                Some(Ok(caps.clone()))
                            } else {
                                None
                            }
                        }
                    }

                    #[derive( Clone, Debug )]
                    pub struct Cache 
                    {

                        stack: Vec<Frame>,
                        visited: Visited,
                    }

                    impl Cache {

                        pub fn new(re: &BoundedBacktracker) -> Cache {
                            Cache { stack: vec![], visited: Visited::new(re) }
                        }

                        pub fn reset( &mut self, re: &BoundedBacktracker) {
                            self.visited.reset(re);
                        }

                        pub fn memory_usage( &self ) -> usize {
                            self.stack.len() * ::mem::size_of::<Frame>()
                                + self.visited.memory_usage()
                        }

                        fn setup_search(
                            &mut self,
                            re: &BoundedBacktracker,
                            input: &Input<'_>,
                        ) -> Result<(), MatchError> {
                            self.stack.clear();
                            self.visited.setup_search(re, input)?;
                            Ok( () )
                        }
                    }

                    #[derive( Clone, Debug )]
                    enum Frame {

                        Step { sid: StateID, at: usize },
                        RestoreCapture { slot: SmallIndex, offset:Option<NonMaxUsize> },
                    }

                    #[derive( Clone, Debug )]
                    struct Visited {

                        bitset: Vec<usize>,
                        stride: usize,
                    }

                    impl Visited {

                        const BLOCK_SIZE: usize = 8 * ::mem::size_of::<usize>();

                        fn new(re: &BoundedBacktracker) -> Visited 
                        {
                            let mut visited = Visited { bitset: vec![], stride: 0 };
                            visited.reset(re);
                            visited
                        }

                        fn insert( &mut self, sid: StateID, at: usize) -> bool 
                        {
                            let table_index = sid.as_usize() * self.stride + at;
                            let block_index = table_index / Visited::BLOCK_SIZE;
                            let bit = table_index % Visited::BLOCK_SIZE;
                            let block_with_bit = 1 << bit;
                            if self.bitset[block_index] & block_with_bit != 0 {
                                return false;
                            }
                            self.bitset[block_index] |= block_with_bit;
                            true
                        }

                        fn reset( &mut self, _: &BoundedBacktracker) {
                            self.bitset.truncate(0);
                        }

                        fn setup_search(
                            &mut self,
                            re: &BoundedBacktracker,
                            input: &Input<'_>,
                        ) -> Result<(), MatchError> {
                            let haylen = input.get_span().len();
                            let err = || MatchError::haystack_too_long(haylen);
                            self.stride = haylen + 1;
                            let needed_capacity =
                                match re.get_nfa().states().len().checked_mul( self.stride) {
                                    None => return Err(err()),
                                    Some(capacity) => capacity,
                                };
                            let max_capacity = 8 * re.get_config().get_visited_capacity();
                            if needed_capacity > max_capacity {
                                return Err(err());
                            }
                            let needed_blocks = div_ceil(needed_capacity, Visited::BLOCK_SIZE);
                            self.bitset.truncate(needed_blocks);
                            for block in self.bitset.iter_mut() {
                                *block = 0;
                            }
                            if needed_blocks > self.bitset.len() {
                                self.bitset.resize(needed_blocks, 0);
                            }
                            Ok( () )
                        }

                        fn memory_usage( &self ) -> usize { self.bitset.len() * ::mem::size_of::<usize>() }
                    }

                    fn div_ceil( lhs:usize, rhs:usize ) -> usize
                    {
                        if lhs % rhs == 0 { lhs / rhs }
                        else { (lhs / rhs) + 1 }
                    }
                }

                pub mod builder
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    use ::mem;

                    use alloc::{sync::Arc, vec, vec::Vec};

                    use crate::{
                        nfa::thompson::{
                            error::BuildError,
                            nfa::{self, SparseTransitions, Transition, NFA},
                        },
                        util::{
                            look::{Look, LookMatcher},
                            primitives::{IteratorIndexExt, PatternID, SmallIndex, StateID},
                        },
                    };

                    */

                    #[derive( Clone, Debug, Eq, PartialEq )]
                    enum State {
                        Empty {

                            next: StateID,
                        },
                        ByteRange { trans: Transition },
                        Sparse { transitions: Vec<Transition> },
                        Look { look: Look, next: StateID },
                        CaptureStart {

                            pattern_id: PatternID,
                            group_index: SmallIndex,
                            next: StateID,
                        },
                        CaptureEnd {

                            pattern_id: PatternID,
                            group_index: SmallIndex,
                            next: StateID,
                        },
                        Union { alternates: Vec<StateID> },
                        UnionReverse { alternates: Vec<StateID> },
                        Fail,
                        Match { pattern_id: PatternID },
                    }

                    impl State {

                        fn goto( &self ) -> Option<StateID> {
                            match *self {
                                State::Empty { next } => Some(next),
                                State::Union { ref alternates } if alternates.len() == 1 => { Some(alternates[0]) }
                                State::UnionReverse { ref alternates }
                                    if alternates.len() == 1 =>
                                {
                                    Some(alternates[0])
                                }
                                _ => None,
                            }
                        }

                        fn memory_usage( &self ) -> usize {
                            match *self {
                                State::Empty { .. }
                                | State::ByteRange { .. }
                                | State::Look { .. }
                                | State::CaptureStart { .. }
                                | State::CaptureEnd { .. }
                                | State::Fail
                                | State::Match { .. } => 0,
                                State::Sparse { ref transitions } => { transitions.len() * mem::size_of::<Transition>() }
                                State::Union { ref alternates } => { alternates.len() * mem::size_of::<StateID>() }
                                State::UnionReverse { ref alternates } => { alternates.len() * mem::size_of::<StateID>() }
                            }
                        }
                    }

                    #[derive( Clone, Debug, Default )]
                    pub struct Builder {

                        pattern_id:Option<PatternID>,
                        states: Vec<State>,
                        start_pattern: Vec<StateID>,
                        captures: Vec<Vec<Option<Arc<str>>>>,
                        memory_states: usize,
                        utf8: bool,
                        reverse: bool,
                        look_matcher: LookMatcher,
                        size_limit:Option<usize>,
                    }

                    impl Builder {

                        pub fn new() -> Builder {
                            Builder::default()
                        }

                        pub fn clear(&mut self) {
                            self.pattern_id = None;
                            self.states.clear();
                            self.start_pattern.clear();
                            self.captures.clear();
                            self.memory_states = 0;
                        }

                        pub fn build(
                            &self,
                            start_anchored: StateID,
                            start_unanchored: StateID,
                        ) -> Result<NFA, BuildError>
                        {
                            assert!( self.pattern_id.is_none(), "must call 'finish_pattern' first");

                            let mut nfa = nfa::Inner::default();
                            nfa.set_utf8( self.utf8);
                            nfa.set_reverse( self.reverse);
                            nfa.set_look_matcher( self.look_matcher.clone());
                            let mut empties = vec![];
                            let mut remap = vec![];
                            remap.resize( self.states.len(), StateID::ZERO);

                            nfa.set_starts(start_anchored, start_unanchored, &self.start_pattern);
                            nfa.set_captures(&self.captures).map_err(BuildError::captures)?;
                            
                            for (sid, state) in self.states.iter().with_state_ids() {
                                match *state {
                                    State::Empty { next } => { empties.push((sid, next)); }
                                    State::ByteRange { trans } => { remap[sid] = nfa.add(nfa::State::ByteRange { trans }); }
                                    State::Sparse { ref transitions } => {
                                        remap[sid] = match transitions.len() {
                                            0 => nfa.add(nfa::State::Fail),
                                            1 => nfa.add(nfa::State::ByteRange {
                                                trans: transitions[0],
                                            }),
                                            _ => {
                                                let transitions =
                                                    transitions.to_vec().into_boxed_slice();
                                                let sparse = SparseTransitions { transitions };
                                                nfa.add(nfa::State::Sparse(sparse))
                                            }
                                        }
                                    }
                                    State::Look { look, next } => { remap[sid] = nfa.add(nfa::State::Look { look, next }); }
                                    State::CaptureStart { pattern_id, group_index, next } => {
                                        let slot = nfa
                                            .group_info()
                                            .slot(pattern_id, group_index.as_usize())
                                            .expect("invalid capture index");
                                        let slot =
                                            SmallIndex::new(slot).expect("a small enough slot");
                                        remap[sid] = nfa.add(nfa::State::Capture {
                                            next,
                                            pattern_id,
                                            group_index,
                                            slot,
                                        });
                                    }
                                    State::CaptureEnd { pattern_id, group_index, next } => {
                                        let slot = nfa
                                            .group_info()
                                            .slot(pattern_id, group_index.as_usize())
                                            .expect("invalid capture index")
                                            .checked_add(1)
                                            .unwrap();
                                        let slot =
                                            SmallIndex::new(slot).expect("a small enough slot");
                                        remap[sid] = nfa.add(nfa::State::Capture {
                                            next,
                                            pattern_id,
                                            group_index,
                                            slot,
                                        });
                                    }
                                    State::Union { ref alternates } => {
                                        if alternates.is_empty() {
                                            remap[sid] = nfa.add(nfa::State::Fail);
                                        } else if alternates.len() == 1 {
                                            empties.push((sid, alternates[0]));
                                            remap[sid] = alternates[0];
                                        } else if alternates.len() == 2 {
                                            remap[sid] = nfa.add(nfa::State::BinaryUnion {
                                                alt1: alternates[0],
                                                alt2: alternates[1],
                                            });
                                        } else {
                                            let alternates =
                                                alternates.to_vec().into_boxed_slice();
                                            remap[sid] = nfa.add(nfa::State::Union { alternates });
                                        }
                                    }
                                    State::UnionReverse { ref alternates } => {
                                        if alternates.is_empty() {
                                            remap[sid] = nfa.add(nfa::State::Fail);
                                        } else if alternates.len() == 1 {
                                            empties.push((sid, alternates[0]));
                                            remap[sid] = alternates[0];
                                        } else if alternates.len() == 2 {
                                            remap[sid] = nfa.add(nfa::State::BinaryUnion {
                                                alt1: alternates[1],
                                                alt2: alternates[0],
                                            });
                                        } else {
                                            let mut alternates =
                                                alternates.to_vec().into_boxed_slice();
                                            alternates.reverse();
                                            remap[sid] = nfa.add(nfa::State::Union { alternates });
                                        }
                                    }
                                    State::Fail => { remap[sid] = nfa.add(nfa::State::Fail); }
                                    State::Match { pattern_id } => { remap[sid] = nfa.add(nfa::State::Match { pattern_id }); }
                                }
                            }
                            
                            let mut remapped = vec![false; self.states.len()];
                            for &(empty_id, empty_next) in empties.iter() {
                                if remapped[empty_id]{ continue; }
                                
                                let mut new_next = empty_next;
                                while let Some(next) = self.states[new_next].goto() {
                                    new_next = next;
                                }
                                remap[empty_id] = remap[new_next];
                                remapped[empty_id] = true;
                                
                                let mut next2 = empty_next;
                                while let Some(next) = self.states[next2].goto() {
                                    remap[next2] = remap[new_next];
                                    remapped[next2] = true;
                                    next2 = next;
                                }
                            }
                            
                            nfa.remap(&remap);
                            let final_nfa = nfa.into_nfa();
                            Ok(final_nfa)
                        }

                        pub fn start_pattern(&mut self) -> Result<PatternID, BuildError> {
                            assert!( self.pattern_id.is_none(), "must call 'finish_pattern' first");

                            let proposed = self.start_pattern.len();
                            let pid = PatternID::new(proposed)
                                .map_err(|_| BuildError::too_many_patterns(proposed))?;
                            self.pattern_id = Some(pid);
                            self.start_pattern.push(StateID::ZERO);
                            Ok(pid)
                        }

                        pub fn finish_pattern(
                            &mut self,
                            start_id: StateID,
                        ) -> Result<PatternID, BuildError> {
                            let pid = self.current_pattern_id();
                            self.start_pattern[pid] = start_id;
                            self.pattern_id = None;
                            Ok(pid)
                        }

                        pub fn current_pattern_id( &self ) -> PatternID { self.pattern_id.expect("must call 'start_pattern' first") }

                        pub fn pattern_len( &self ) -> usize { self.start_pattern.len() }

                        pub fn add_empty(&mut self) -> Result<StateID, BuildError> { self.add(State::Empty { next: StateID::ZERO }) }

                        pub fn add_union(
                            &mut self,
                            alternates: Vec<StateID>,
                        ) -> Result<StateID, BuildError> { self.add(State::Union { alternates }) }

                        pub fn add_union_reverse(
                            &mut self,
                            alternates: Vec<StateID>,
                        ) -> Result<StateID, BuildError> { self.add(State::UnionReverse { alternates }) }

                        pub fn add_range(
                            &mut self,
                            trans: Transition,
                        ) -> Result<StateID, BuildError> { self.add(State::ByteRange { trans }) }

                        pub fn add_sparse(
                            &mut self,
                            transitions: Vec<Transition>,
                        ) -> Result<StateID, BuildError> { self.add(State::Sparse { transitions }) }

                        pub fn add_look(
                            &mut self,
                            next: StateID,
                            look: Look,
                        ) -> Result<StateID, BuildError> { self.add(State::Look { look, next }) }

                        pub fn add_capture_start
                        (
                            &mut self,
                            next: StateID,
                            group_index: u32,
                            name:Option<Arc<str>>,
                        ) -> Result<StateID, BuildError>
                        {
                            let p = self.current_pattern_id();
                            let group_index = match SmallIndex::try_from(group_index) {
                                Err(_) => { return Err(BuildError::invalid_capture_index(group_index)) }
                                Ok(group_index) => group_index,
                            };
                            
                            if p.as_usize() >= self.captures.len() {
                                for _ in 0..=( p.as_usize() - self.captures.len() ) {
                                    self.captures.push(vec![]);
                                }
                            }
                            
                            if group_index.as_usize() >= self.captures[p].len() {
                                for _ in 0..(group_index.as_usize() - self.captures[p].len()) {
                                    self.captures[p].push( None );
                                }
                                self.captures[p].push(name);
                            }
                            self.add(State::CaptureStart { pattern_id: p, group_index, next })
                        }

                        pub fn add_capture_end
                        (
                            &mut self,
                            n: StateID,
                            i: u32,
                        ) -> Result<StateID, BuildError>
                        {
                            let p = self.current_pattern_id();
                            let i = match SmallIndex::try_from( i )
                            {
                                Err(_) => { return Err(BuildError::invalid_capture_index( i )) }
                                Ok( i ) => i,
                            };

                            self.add(State::CaptureEnd { pattern_id: p, group_index:i, next:n })
                        }

                        pub fn add_fail(&mut self) -> Result<StateID, BuildError> { self.add(State::Fail) }

                        pub fn add_match(&mut self) -> Result<StateID, BuildError>
                        {
                            let pattern_id = self.current_pattern_id();
                            let s = self.add(State::Match { pattern_id })?;
                            Ok( s )
                        }

                        fn add( &mut self, s:State) -> Result<StateID, BuildError>
                        {
                            let i = StateID::new( self.states.len()).map_err(|_| BuildError::too_many_states( self.states.len()))?;
                            self.memory_states += s.memory_usage();
                            self.states.push( s );
                            self.check_size_limit()?;
                            Ok( i )
                        }

                        pub fn patch
                        (
                            &mut self,
                            f: StateID,
                            t: StateID,
                        ) -> Result<(), BuildError> 
                        {
                            let o = self.memory_states;
                            match self.states[ f ]
                            {
                                State::Empty { ref mut n } => { *n = t; }
                                State::ByteRange { ref mut n } => { n.next = t; }
                                State::Sparse { .. } => { panic!("cannot patch from a sparse NFA state") }
                                State::Look { ref mut n, .. } =>
                                {
                                    *n = t;
                                }
                                State::Union { ref mut n } =>
                                {
                                    n.push( t );
                                    self.memory_states += mem::size_of::<StateID>();
                                }
                                State::UnionReverse { ref mut n } =>
                                {
                                    n.push( t );
                                    self.memory_states += mem::size_of::<StateID>();
                                }
                                State::CaptureStart { ref mut n, .. } => { *n = t; }
                                State::CaptureEnd { ref mut n, .. } => { *n = t; }
                                State::Fail => {}
                                State::Match { .. } => {}
                            }
                            
                            if o != self.memory_states { self.check_size_limit()?; }

                            Ok( () )
                        }

                        pub fn set_utf8( &mut self, y:bool ) { self.utf8 = y; }

                        pub fn get_utf8( &self ) -> bool { self.utf8 }

                        pub fn set_reverse( &mut self, yes:bool ) { self.reverse = yes; }

                        pub fn get_reverse( &self ) -> bool { self.reverse }

                        pub fn set_look_matcher( &mut self, m: LookMatcher ) { self.look_matcher = m; }

                        pub fn get_look_matcher( &self ) -> &LookMatcher { &self.look_matcher }

                        pub fn set_size_limit( &mut self, limit:Option<usize> ) -> Result<(), BuildError>
                        {
                            self.size_limit = limit;
                            self.check_size_limit()
                        }

                        pub fn get_size_limit( &self ) -> Option<usize> { self.size_limit }

                        pub fn memory_usage( &self ) -> usize { self.states.len() * mem::size_of::<State>() + self.memory_states }

                        fn check_size_limit( &self ) -> Result<(), BuildError>
                        {
                            if let Some( l ) = self.size_limit
                            {
                                if self.memory_usage() > l { return Err( BuildError::exceeded_size_limit( l ) ); }
                            }

                            Ok( () )
                        }
                    }


                }

                pub mod compiler
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }

                pub mod error
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }

                pub mod literal_trie
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }

                pub mod map
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }

                pub mod nfa
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }

                pub mod pikevm
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }

                pub mod range_trie
                {
                    /*!
                    */
                    use ::
                    {
                        *,
                    };
                    /*
                    */
                }
            }
        }
        pub mod primitives
        {
            /*!
            Lower level primitive types that are useful in a variety of circumstances. */
            use ::
            {
                *,
            };
            /*
            use ::num::NonZeroUsize;
            use alloc::vec::Vec;
            use crate::util::int::{Usize, U16, U32, U64};
            */

            
            #[derive(Clone, Copy, Eq, Hash, PartialEq, PartialOrd, Ord)]
            #[repr(transparent)]
            pub struct NonMaxUsize(NonZeroUsize);

            impl NonMaxUsize {

                ///

                #[inline] pub fn new(value: usize) -> Option<NonMaxUsize> { NonZeroUsize::new(value.wrapping_add(1)).map(NonMaxUsize)}
                
                #[inline] pub fn get(self) -> usize {
                    self.0.get().wrapping_sub(1)
                }
            }
            
            impl ::fmt::Debug for NonMaxUsize
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    write!(f, "{:?}", self.get())
                }
            }


            
            

            ///



            ///

            ///

            ///
            #[derive(
                Clone, Copy, Debug, Default, Eq, Hash, PartialEq, PartialOrd, Ord,
            )]
            #[repr(transparent)]
            pub struct SmallIndex(u32);

            impl SmallIndex {

                #[cfg(any(target_pointer_width = "32", target_pointer_width = "64"))]
                pub const MAX: SmallIndex =
                    // FIXME: Use as_usize() once const functions in traits are stable.
                    SmallIndex::new_unchecked(core::i32::MAX as usize - 1);


                #[cfg(target_pointer_width = "16")]
                pub const MAX: SmallIndex =
                    SmallIndex::new_unchecked(core::isize::MAX - 1);


                pub const LIMIT: usize = SmallIndex::MAX.as_usize() + 1;


                pub const ZERO: SmallIndex = SmallIndex::new_unchecked(0);


                pub const SIZE: usize = ::mem::size_of::<SmallIndex>();


                #[inline] pub fn new(index: usize) -> Result<SmallIndex, SmallIndexError> { SmallIndex::try_from(index) }
                
                #[inline]
                pub const fn new_unchecked(index: usize) -> SmallIndex {
                    // FIXME: Use as_u32() once const functions in traits are stable.
                    SmallIndex(index as u32)
                }


                #[inline] pub fn must(index: usize) -> SmallIndex {
                    SmallIndex::new(index).expect("invalid small index")
                }
                
                #[inline]
                pub const fn as_usize(&self) -> usize {
                    // FIXME: Use as_usize() once const functions in traits are stable.
                    self.0 as usize
                }
                
                #[inline]
                pub const fn as_u64(&self) -> u64 {
                    // FIXME: Use u64::from() once const functions in traits are stable.
                    self.0 as u64
                }
                
                #[inline]
                pub const fn as_u32(&self) -> u32 {
                    self.0
                }
                
                #[inline]
                pub const fn as_i32(&self) -> i32 {
                    // This is OK because we guarantee that our max value is <= i32::MAX.
                    self.0 as i32
               }
                
                #[inline] pub fn one_more(&self) -> usize {
                    self.as_usize() + 1
               }
                
                #[inline] pub fn from_ne_bytes(
                    bytes: [u8; 4],
                ) -> Result<SmallIndex, SmallIndexError> {
                    let id = u32::from_ne_bytes(bytes);
                    if id > SmallIndex::MAX.as_u32() {
                        return Err(SmallIndexError { attempted: u64::from(id) });
                    }
                    Ok(SmallIndex::new_unchecked(id.as_usize()))
               }
                
                #[inline] pub fn from_ne_bytes_unchecked(bytes: [u8; 4]) -> SmallIndex {
                    SmallIndex::new_unchecked(u32::from_ne_bytes(bytes).as_usize())
               }
                
                #[inline] pub fn to_ne_bytes(&self) -> [u8; 4] {
                    self.0.to_ne_bytes()
                }
            }

            impl<T> ::ops::Index<SmallIndex> for [T] {
                type Output = T;

                #[inline] fn index(&self, index: SmallIndex) -> &T {
                    &self[index.as_usize()]
                }
            }

            impl<T> ::ops::IndexMut<SmallIndex> for [T] {
                #[inline] fn index_mut(&mut self, index: SmallIndex) -> &mut T {
                    &mut self[index.as_usize()]
                }
            }

            impl<T> ::ops::Index<SmallIndex> for Vec<T>
            {
                type Output = T;

                #[inline] fn index(&self, index: SmallIndex) -> &T {
                    &self[index.as_usize()]
                }
            }

            impl<T> ::ops::IndexMut<SmallIndex> for Vec<T> {
                #[inline] fn index_mut(&mut self, index: SmallIndex) -> &mut T {
                    &mut self[index.as_usize()]
                }
            }

            impl From<u8> for SmallIndex {
                fn from(index: u8) -> SmallIndex {
                    SmallIndex::new_unchecked(usize::from(index))
                }
            }

            impl TryFrom<u16> for SmallIndex {
                type Error = SmallIndexError;
                fn try_from(index: u16) -> Result<SmallIndex, SmallIndexError> {
                    if u32::from(index) > SmallIndex::MAX.as_u32() {
                        return Err(SmallIndexError { attempted: u64::from(index) });
                    }
                    Ok(SmallIndex::new_unchecked(index.as_usize()))
                }
            }

            impl TryFrom<u32> for SmallIndex {
                type Error = SmallIndexError;
                fn try_from(index: u32) -> Result<SmallIndex, SmallIndexError> {
                    if index > SmallIndex::MAX.as_u32() {
                        return Err(SmallIndexError { attempted: u64::from(index) });
                    }
                    Ok(SmallIndex::new_unchecked(index.as_usize()))
                }
            }

            impl TryFrom<u64> for SmallIndex {
                type Error = SmallIndexError;
                fn try_from(index: u64) -> Result<SmallIndex, SmallIndexError> {
                    if index > SmallIndex::MAX.as_u64() {
                        return Err(SmallIndexError { attempted: index });
                    }
                    Ok(SmallIndex::new_unchecked(index.as_usize()))
                }
            }

            impl TryFrom<usize> for SmallIndex {
                type Error = SmallIndexError;
                fn try_from(index: usize) -> Result<SmallIndex, SmallIndexError> {
                    if index > SmallIndex::MAX.as_usize() {
                        return Err(SmallIndexError { attempted: index.as_u64() });
                    }
                    Ok(SmallIndex::new_unchecked(index))
                }
            }
            
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct SmallIndexError {
                attempted: u64,
            }

            impl SmallIndexError 
            {

                pub fn attempted(&self) -> u64 {
                    self.attempted
                }
            }

            impl ::error::Error for SmallIndexError {}

            impl ::fmt::Display for SmallIndexError
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    write!(
                        f,
                        "failed to create small index from {:?}, which exceeds {:?}",
                        self.attempted(),
                        SmallIndex::MAX,
                    )
                }
            }

            #[derive(Clone, Debug)]
            pub struct SmallIndexIter {
                rng: ::ops::Range<usize>,
            }

            impl Iterator for SmallIndexIter {
                type Item = SmallIndex;
                fn next(&mut self) -> Option<SmallIndex> {
                    if self.rng.start >= self.rng.end {
                        return None;
                    }
                    let next_id = self.rng.start + 1;
                    let id = ::mem::replace(&mut self.rng.start, next_id);
                    Some(SmallIndex::new_unchecked(id))
                }
            }

            macro_rules! index_type_impls {
                ($name:ident, $err:ident, $iter:ident, $withiter:ident) => {
                    impl $name {

                        pub const MAX: $name = $name(SmallIndex::MAX);


                        pub const LIMIT: usize = SmallIndex::LIMIT;


                        pub const ZERO: $name = $name(SmallIndex::ZERO);


                        pub const SIZE: usize = SmallIndex::SIZE;
                        
                        #[inline] pub fn new(value: usize) -> Result<$name, $err> { SmallIndex::new(value).map($name).map_err($err) }
                        
                        #[inline] pub const fn new_unchecked(value: usize) -> $name {
                            $name(SmallIndex::new_unchecked(value))
                        }

                        #[inline] pub fn must(value: usize) -> $name {
                            $name::new(value).expect(concat!(
                                "invalid ",
                                stringify!($name),
                                " value"
                            ))
                        }

                        #[inline] pub const fn as_usize(&self) -> usize {
                            self.0.as_usize()
                        }

                        #[inline] pub const fn as_u64(&self) -> u64 {
                            self.0.as_u64()
                        }

                        #[inline] pub const fn as_u32(&self) -> u32 {
                            self.0.as_u32()
                        }

                        #[inline] pub const fn as_i32(&self) -> i32 {
                            self.0.as_i32()
                        }

                        #[inline] pub fn one_more(&self) -> usize {
                            self.0.one_more()
                        }

                        #[inline] pub fn from_ne_bytes(bytes: [u8; 4]) -> Result<$name, $err> { SmallIndex::from_ne_bytes(bytes).map($name).map_err($err) }

                        #[inline] pub fn from_ne_bytes_unchecked(bytes: [u8; 4]) -> $name {
                            $name(SmallIndex::from_ne_bytes_unchecked(bytes))
                        }

                        #[inline] pub fn to_ne_bytes(&self) -> [u8; 4] {
                            self.0.to_ne_bytes()
                        }
                        
                        pub fn iter(len: usize) -> $iter {
                            $iter::new(len)
                        }
                    }
                    
                    impl ::fmt::Debug for $name {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            f.debug_tuple(stringify!($name)).field(&self.as_u32()).finish()
                        }
                    }

                    impl<T> ::ops::Index<$name> for [T] {
                        type Output = T;

                        #[inline]
                        fn index(&self, index: $name) -> &T {
                            &self[index.as_usize()]
                        }
                    }

                    impl<T> ::ops::IndexMut<$name> for [T] {
                        #[inline]
                        fn index_mut(&mut self, index: $name) -> &mut T {
                            &mut self[index.as_usize()]
                        }
                    }

                        impl<T> ::ops::Index<$name> for Vec<T> {
                        type Output = T;

                        #[inline]
                        fn index(&self, index: $name) -> &T {
                            &self[index.as_usize()]
                        }
                    }

                        impl<T> ::ops::IndexMut<$name> for Vec<T> {
                        #[inline]
                        fn index_mut(&mut self, index: $name) -> &mut T {
                            &mut self[index.as_usize()]
                        }
                    }

                    impl From<u8> for $name {
                        fn from(value: u8) -> $name {
                            $name(SmallIndex::from(value))
                        }
                    }

                    impl TryFrom<u16> for $name {
                        type Error = $err;

                        fn try_from(value: u16) -> Result<$name, $err> { SmallIndex::try_from(value).map($name).map_err($err) }
                    }

                    impl TryFrom<u32> for $name {
                        type Error = $err;

                        fn try_from(value: u32) -> Result<$name, $err> { SmallIndex::try_from(value).map($name).map_err($err) }
                    }

                    impl TryFrom<u64> for $name {
                        type Error = $err;

                        fn try_from(value: u64) -> Result<$name, $err> { SmallIndex::try_from(value).map($name).map_err($err) }
                    }

                    impl TryFrom<usize> for $name {
                        type Error = $err;

                        fn try_from(value: usize) -> Result<$name, $err> { SmallIndex::try_from(value).map($name).map_err($err) }
                    }
                    
                    #[derive( Clone, Debug, Eq, PartialEq )]
                    pub struct $err(SmallIndexError);

                    impl $err {

                        pub fn attempted(&self) -> u64 {
                            self.0.attempted()
                        }
                    }

                    impl ::error::Error for $err {}

                    impl ::fmt::Display for $err {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(
                                f,
                                "failed to create {} from {:?}, which exceeds {:?}",
                                stringify!($name),
                                self.attempted(),
                                $name::MAX,
                            )
                        }
                    }

                    #[derive(Clone, Debug)]
                    pub struct $iter(SmallIndexIter);

                    impl $iter {
                        fn new(len: usize) -> $iter {
                            assert!(
                                len <= $name::LIMIT,
                                "cannot create iterator for {} when number of \
                                elements exceed {:?}",
                                stringify!($name),
                                $name::LIMIT,
                            );
                            $iter(SmallIndexIter { rng: 0..len })
                        }
                    }

                    impl Iterator for $iter {
                        type Item = $name;

                        fn next(&mut self) -> Option<$name> { self.0.next().map($name) }
                    }
                    #[derive(Clone, Debug)]
                    pub struct $withiter<I> {
                        it: I,
                        ids: $iter,
                    }

                    impl<I: Iterator + ExactSizeIterator> $withiter<I> {
                        fn new(it: I) -> $withiter<I> {
                            let ids = $name::iter(it.len());
                            $withiter { it, ids }
                        }
                    }

                    impl<I: Iterator + ExactSizeIterator> Iterator for $withiter<I> {
                        type Item = ($name, I::Item);

                        fn next(&mut self) -> Option<($name, I::Item)> {
                            let item = self.it.next()?;
                            let id = self.ids.next().unwrap();
                            Some((id, item))
                        }
                    }
                };
            }
           
            #[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]
            #[repr(transparent)]
            pub struct PatternID(SmallIndex);
            #[derive(Clone, Copy, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]
            #[repr(transparent)]
            pub struct StateID(SmallIndex);

            index_type_impls!(PatternID, PatternIDError, PatternIDIter, WithPatternIDIter);
            index_type_impls!(StateID, StateIDError, StateIDIter, WithStateIDIter);
            pub trait IteratorIndexExt: Iterator {
                fn with_pattern_ids(self) -> WithPatternIDIter<Self> where Self: Sized + ExactSizeIterator,
                {
                    WithPatternIDIter::new(self)
                }

                fn with_state_ids(self) -> WithStateIDIter<Self> where Self: Sized + ExactSizeIterator,
                {
                    WithStateIDIter::new(self)
                }
            }

            impl<I: Iterator> IteratorIndexExt for I {}
        }

        pub mod search
        {
            /*!
            Types and routines that support the search APIs of most regex engines.*/
            use ::
            {
                *,
            };
            /*
            use ::ops::{Range, RangeBounds};
            use crate::util::{escape::DebugByte, primitives::PatternID, utf8};
            */


            
            ///

            ///

            ///

            

            

            
            #[derive(Clone)]
            pub struct Input<'h> {
                haystack: &'h [u8],
                span: Span,
                anchored: Anchored,
                earliest: bool,
            }

            impl<'h> Input<'h> {

                #[inline] pub fn new<H: ?Sized + AsRef<[u8]>>(haystack: &'h H) -> Input<'h> {
                    let haystack = haystack.as_ref();
                    Input {
                        haystack,
                        span: Span { start: 0, end: haystack.len() },
                        anchored: Anchored::No,
                        earliest: false,
                    }
                }


                
                

                

                
                
                
                
                
                #[inline] pub fn span<S: Into<Span>>(mut self, span: S) -> Input<'h> {
                    self.set_span(span);
                    self
                }

                #[inline] pub fn range<R: RangeBounds<usize>>(mut self, range: R) -> Input<'h> {
                    self.set_range(range);
                    self
                }
                
                #[inline] pub fn anchored(mut self, mode: Anchored) -> Input<'h> {
                    self.set_anchored(mode);
                    self
                }
                
                #[inline] pub fn earliest(mut self, yes: bool) -> Input<'h> {
                    self.set_earliest(yes);
                    self
                }
                
                #[inline] pub fn set_span<S: Into<Span>>(&mut self, span: S) {
                    let span = span.into();
                    assert!(
                        span.end <= self.haystack.len()
                            && span.start <= span.end.wrapping_add(1),
                        "invalid span {:?} for haystack of length {}",
                        span,
                        self.haystack.len(),
                    );
                    self.span = span;
                }

                #[inline] pub fn set_range<R: RangeBounds<usize>>(&mut self, range: R) {
                    use ::ops::Bound;
                    let start = match range.start_bound() {
                        Bound::Included(&i) => i,
                        // Can this case ever happen? Range syntax doesn't support it...
                        Bound::Excluded(&i) => i.checked_add(1).unwrap(),
                        Bound::Unbounded => 0,
                    };
                    let end = match range.end_bound() {
                        Bound::Included(&i) => i.checked_add(1).unwrap(),
                        Bound::Excluded(&i) => i,
                        Bound::Unbounded => self.haystack().len(),
                    };
                    self.set_span(Span { start, end });
                }


                

                

                
                #[inline] pub fn set_start(&mut self, start: usize) {
                    self.set_span(Span { start, ..self.get_span() });
                }


                

                

                
                #[inline] pub fn set_end(&mut self, end: usize) {
                    self.set_span(Span { end, ..self.get_span() });
                }


                

                
                #[inline] pub fn set_anchored(&mut self, mode: Anchored) {
                    self.anchored = mode;
                }


                

                
                #[inline] pub fn set_earliest(&mut self, yes: bool) {
                    self.earliest = yes;
                }

                
                #[inline] pub fn haystack(&self) -> &'h [u8] {
                    self.haystack
                }

                

                
                #[inline] pub fn start(&self) -> usize {
                    self.get_span().start
                }

                

                
                #[inline] pub fn end(&self) -> usize {
                    self.get_span().end
                }


                
                #[inline] pub fn get_span(&self) -> Span {
                    self.span
                }


                
                #[inline] pub fn get_range(&self) -> Range<usize> { self.get_span().range() }


                
                
                #[inline] pub fn get_anchored(&self) -> Anchored {
                    self.anchored
                }

                
                #[inline] pub fn get_earliest(&self) -> bool {
                    self.earliest
                }
                

                
                #[inline] pub fn is_done(&self) -> bool {
                    self.get_span().start > self.get_span().end
                }
                

                
                #[inline] pub fn is_char_boundary(&self, offset: usize) -> bool {
                    utf8::is_boundary(self.haystack(), offset)
                }
            }

            impl<'h> ::fmt::Debug for Input<'h>
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    use crate::util::escape::DebugHaystack;

                    f.debug_struct("Input")
                        .field("haystack", &DebugHaystack(self.haystack()))
                        .field("span", &self.span)
                        .field("anchored", &self.anchored)
                        .field("earliest", &self.earliest)
                        .finish()
                }
            }

            impl<'h, H: ?Sized + AsRef<[u8]>> From<&'h H> for Input<'h> {
                fn from(haystack: &'h H) -> Input<'h> { Input::new(haystack) }
            }
           
            #[derive( Clone, Copy, Eq, Hash, PartialEq )]
            pub struct Span {

                pub start: usize,
                pub end: usize,
            }

            impl Span {

                #[inline] pub fn range(&self) -> Range<usize> { Range::from(*self) }


                #[inline] pub fn is_empty(&self) -> bool {
                    self.start >= self.end
                }

                #[inline] pub fn len(&self) -> usize {
                    self.end.saturating_sub(self.start)
               }
                
                #[inline] pub fn contains(&self, offset: usize) -> bool {
                    !self.is_empty() && self.start <= offset && offset <= self.end
               }
                
                #[inline] pub fn offset(&self, offset: usize) -> Span {
                    Span { start: self.start + offset, end: self.end + offset }
                }
            }

            impl ::fmt::Debug for Span
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    write!(f, "{}..{}", self.start, self.end)
                }
            }

            impl ::ops::Index<Span> for [u8] {
                type Output = [u8];

                #[inline] fn index(&self, index: Span) -> &[u8] {
                    &self[index.range()]
                }
            }

            impl ::ops::IndexMut<Span> for [u8] {
                #[inline] fn index_mut(&mut self, index: Span) -> &mut [u8] {
                    &mut self[index.range()]
                }
            }

            impl ::ops::Index<Span> for str {
                type Output = str;

                #[inline] fn index(&self, index: Span) -> &str {
                    &self[index.range()]
                }
            }

            impl From<Range<usize>> for Span {
                #[inline] fn from(range: Range<usize>) -> Span {
                    Span { start: range.start, end: range.end }
                }
            }

            impl From<Span> for Range<usize> {
                #[inline] fn from(span: Span) -> Range<usize> { Range { start: span.start, end: span.end } }
            }

            impl PartialEq<Range<usize>> for Span {
                #[inline] fn eq(&self, range: &Range<usize>) -> bool {
                    self.start == range.start && self.end == range.end
                }
            }

            impl PartialEq<Span> for Range<usize> {
                #[inline] fn eq(&self, span: &Span) -> bool {
                    self.start == span.start && self.end == span.end
                }
            }

            #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
            pub struct HalfMatch {

                pattern: PatternID,                offset: usize,
            }

            impl HalfMatch {

                #[inline] pub fn new(pattern: PatternID, offset: usize) -> HalfMatch {
                    HalfMatch { pattern, offset }
               }
                
                #[inline] pub fn must(pattern: usize, offset: usize) -> HalfMatch {
                    HalfMatch::new(PatternID::new(pattern).unwrap(), offset)
               }
                
                #[inline] pub fn pattern(&self) -> PatternID {
                    self.pattern
               }
                
                #[inline] pub fn offset(&self) -> usize {
                    self.offset
                }
            }
           
            #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
            pub struct Match {

                pattern: PatternID,
                span: Span,
            }

            impl Match {

                ///
                

                
                #[inline] pub fn new<S: Into<Span>>(pattern: PatternID, span: S) -> Match {
                    let span: Span = span.into();
                    assert!(span.start <= span.end, "invalid match span");
                    Match { pattern, span }
                }

                #[inline] pub fn must<S: Into<Span>>(pattern: usize, span: S) -> Match {
                    Match::new(PatternID::must(pattern), span)
               }
                
                #[inline] pub fn pattern(&self) -> PatternID {
                    self.pattern
                }

                #[inline] pub fn start(&self) -> usize {
                    self.span().start
                }

                #[inline] pub fn end(&self) -> usize {
                    self.span().end
                }

                #[inline] pub fn range(&self) -> ::ops::Range<usize> { self.span().range() }


                #[inline] pub fn span(&self) -> Span {
                    self.span
               }
                
                #[inline] pub fn is_empty(&self) -> bool {
                    self.span().is_empty()
                }

                #[inline] pub fn len(&self) -> usize {
                    self.span().len()
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct PatternSet {
                len: usize,
                which: alloc::boxed::Box<[bool]>,
            }

            impl PatternSet
            {
                pub fn new(capacity: usize) -> PatternSet {
                    assert!(
                        capacity <= PatternID::LIMIT,
                        "pattern set capacity exceeds limit of {}",
                        PatternID::LIMIT,
                    );
                    PatternSet {
                        len: 0,
                        which:vec![false; capacity].into_boxed_slice(),
                    }
                }

                pub fn clear(&mut self) {
                    self.len = 0;
                    for matched in self.which.iter_mut() {
                        *matched = false;
                    }
                }

                pub fn contains(&self, pid: PatternID) -> bool {
                    pid.as_usize() < self.capacity() && self.which[pid]
                }
                

                pub fn insert(&mut self, pid: PatternID) -> bool {
                    self.try_insert(pid)
                        .expect("PatternSet should have sufficient capacity")
                }
                
                pub fn try_insert(
                    &mut self,
                    pid: PatternID,
                ) -> Result<bool, PatternSetInsertError> {
                    if pid.as_usize() >= self.capacity() {
                        return Err(PatternSetInsertError {
                            attempted: pid,
                            capacity: self.capacity(),
                        });
                    }
                    if self.which[pid] {
                        return Ok(false);
                    }
                    self.len += 1;
                    self.which[pid] = true;
                    Ok(true)
                }

                /*
                // API evolution flexibility, we leave it out for now.


                

                ///

                pub fn remove(&mut self, pid: PatternID) -> bool {
                    if !self.which[pid] {
                        return false;
                    }
                    self.len -= 1;
                    self.which[pid] = false;
                    true
                }
                */
                pub fn is_empty(&self) -> bool {
                    self.len() == 0
                }

                pub fn is_full(&self) -> bool {
                    self.len() == self.capacity()
                }

                pub fn len(&self) -> usize {
                    self.len
                }

                pub fn capacity(&self) -> usize {
                    self.which.len()
                }

                pub fn iter(&self) -> PatternSetIter<'_> { PatternSetIter { it: self.which.iter().enumerate() } }
            }

            #[derive(Clone, Debug)]
            pub struct PatternSetInsertError {
                attempted: PatternID,
                capacity: usize,
            }

            impl ::error::Error for PatternSetInsertError {}

            impl ::fmt::Display for PatternSetInsertError
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    write!(
                        f,
                        "failed to insert pattern ID {} into pattern set \
                        with insufficient capacity of {}",
                        self.attempted.as_usize(),
                        self.capacity,
                    )
                }
            }

            #[derive(Clone, Debug)]
            pub struct PatternSetIter<'a> { it: ::iter::Enumerate<core::slice::Iter<'a, bool>>, }

            impl<'a> Iterator for PatternSetIter<'a>
            {
                type Item = PatternID;
                fn next(&mut self) -> Option<PatternID> {
                    while let Some((index, &yes)) = self.it.next() {
                        if yes {
                            return Some(PatternID::new_unchecked(index));
                        }
                    }
                    None
                }

                fn size_hint(&self) -> (usize, Option<usize>) {
                    self.it.size_hint()
                }
            }

            impl<'a> DoubleEndedIterator for PatternSetIter<'a> {
                fn next_back(&mut self) -> Option<PatternID> {
                    while let Some((index, &yes)) = self.it.next_back() {
                        if yes {
                            return Some(PatternID::new_unchecked(index));
                        }
                    }
                    None
                }
            }


            
            ///

            
            ///

            
            
            
            #[derive(Clone, Copy, Debug, Eq, PartialEq )]
            pub enum Anchored {
                ///

                No,
                Yes,
                Pattern(PatternID),
            }

            impl Anchored {
                
                #[inline] pub fn is_anchored(&self) -> bool {
                    matches!(*self, Anchored::Yes | Anchored::Pattern(_))
                }
                
                #[inline] pub fn pattern(&self) -> Option<PatternID> {
                    match *self {
                        Anchored::Pattern(pid) => Some(pid),
                        _ => None,
                    }
                }
            }


            
            

            

            
            
            
            #[non_exhaustive] #[derive( Clone, Copy, Default, Debug, Eq, PartialEq)]
            pub enum MatchKind {

                All,
                #[default]
                LeftmostFirst,
                //
            }

            impl MatchKind {
                pub fn continue_past_first_match(&self) -> bool {
                    *self == MatchKind::All
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct MatchError(
                alloc::boxed::Box<MatchErrorKind>
            );

            impl MatchError 
            {

                pub fn new(kind: MatchErrorKind) -> MatchError {
                        {
                        MatchError(alloc::boxed::Box::new(kind))
                    }
                    #[cfg(not(feature = "alloc"))]
                    {
                        MatchError(kind)
                    }
                }

                pub fn kind(&self) -> &MatchErrorKind {
                    &self.0
                }

                pub fn quit(byte: u8, offset: usize) -> MatchError {
                    MatchError::new(MatchErrorKind::Quit { byte, offset })
                }

                pub fn gave_up(offset: usize) -> MatchError {
                    MatchError::new(MatchErrorKind::GaveUp { offset })
                }

                pub fn haystack_too_long(len: usize) -> MatchError {
                    MatchError::new(MatchErrorKind::HaystackTooLong { len })
                }

                pub fn unsupported_anchored(mode: Anchored) -> MatchError {
                    MatchError::new(MatchErrorKind::UnsupportedAnchored { mode })
                }
            }


            ///
            #[non_exhaustive] #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum MatchErrorKind {
                Quit {

                    byte: u8,
                    offset: usize,
                },                GaveUp {
                    offset: usize,
                },
                HaystackTooLong {

                    len: usize,
                },                UnsupportedAnchored {

                    mode: Anchored,
                },
            }

            impl ::error::Error for MatchError {}

            impl ::fmt::Display for MatchError
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    match *self.kind() {
                        MatchErrorKind::Quit { byte, offset } => write!(
                            f,
                            "quit search after observing byte {:?} at offset {}",
                            DebugByte(byte),
                            offset,
                        ),
                        MatchErrorKind::GaveUp { offset } => { write!(f, "gave up searching at offset {offset}") }
                        MatchErrorKind::HaystackTooLong { len } => { write!(f, "haystack of length {len} is too long") }
                        MatchErrorKind::UnsupportedAnchored { mode: Anchored::Yes } => { write!(f, "anchored searches are not supported or enabled") }
                        MatchErrorKind::UnsupportedAnchored { mode: Anchored::No } => { write!(f, "unanchored searches are not supported or enabled") }
                        MatchErrorKind::UnsupportedAnchored {
                            mode: Anchored::Pattern(pid),
                        } => {
                            write!(
                                f,
                                "anchored searches for a specific pattern ({}) are \
                                not supported or enabled",
                                pid.as_usize(),
                            )
                        }
                    }
                }
            }


        }
        
        pub mod wire
        {
            /*!
            Types and routines that support the wire format of finite automata. */
            use ::
            {
                *,
            };
            /*
            */
        }
    }

    pub mod builders
    {
        /*!
        This module defines an internal builder that encapsulates all interaction with meta::Regex construction,
        and then 4 public API builders that wrap around it.*/
        use ::
        {
            regex::
            {
                automata::{ meta, nfa::thompson::WhichCaptures, util::syntax, MatchKind, },
                error::{ Error },
            },
            string::{ String, ToString },
            sync::{ Arc },
            *,
        };
        /*
        */

        ///
        #[derive( Clone, Debug )]
        struct Builder {
            pats: Vec<String>,
            metac: meta::Config,
            syntaxc: syntax::Config,
        }

        impl Default for Builder {
            fn default() -> Builder {
                let metac = meta::Config::new()
                    .nfa_size_limit(Some(10 * (1 << 20)))
                    .hybrid_cache_capacity(2 * (1 << 20));
                Builder { pats: vec![], metac, syntaxc: syntax::Config::default() }
            }
        }

        impl Builder {
            fn new<I, S>(patterns: I) -> Builder
            where
                S: AsRef<str>,
                I: IntoIterator<Item = S>,
            {
                let mut b = Builder::default();
                b.pats.extend(patterns.into_iter().map(|p| p.as_ref().to_string()));
                b
            }

            fn build_one_string( &self ) -> Result<crate::Regex, Error> {
                assert_eq!(1, self.pats.len());
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::LeftmostFirst)
                    .utf8_empty(true);
                let syntaxc = self.syntaxc.clone().utf8(true);
                let pattern = Arc::from( self.pats[0].as_str());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build(&pattern)
                    .map(|meta| crate::Regex { meta, pattern })
                    .map_err(Error::from_meta_build_error)
            }

            fn build_one_bytes( &self ) -> Result<crate::bytes::Regex, Error> {
                assert_eq!(1, self.pats.len());
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::LeftmostFirst)
                    .utf8_empty( false );
                let syntaxc = self.syntaxc.clone().utf8( false );
                let pattern = Arc::from( self.pats[0].as_str());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build(&pattern)
                    .map(|meta| crate::bytes::Regex { meta, pattern })
                    .map_err(Error::from_meta_build_error)
            }

            fn build_many_string( &self ) -> Result<crate::RegexSet, Error> {
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::All)
                    .utf8_empty(true)
                    .which_captures(WhichCaptures::None);
                let syntaxc = self.syntaxc.clone().utf8(true);
                let patterns = Arc::from( self.pats.as_slice());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build_many(&patterns)
                    .map(|meta| crate::RegexSet { meta, patterns })
                    .map_err(Error::from_meta_build_error)
            }

            fn build_many_bytes( &self ) -> Result<crate::bytes::RegexSet, Error> {
                let metac = self
                    .metac
                    .clone()
                    .match_kind(MatchKind::All)
                    .utf8_empty( false )
                    .which_captures(WhichCaptures::None);
                let syntaxc = self.syntaxc.clone().utf8( false );
                let patterns = Arc::from( self.pats.as_slice());
                meta::Builder::new()
                    .configure(metac)
                    .syntax(syntaxc)
                    .build_many(&patterns)
                    .map(|meta| crate::bytes::RegexSet { meta, patterns })
                    .map_err(Error::from_meta_build_error)
            }

            fn case_insensitive( &mut self, yes:bool ) -> &mut Builder {
                self.syntaxc = self.syntaxc.case_insensitive(yes);
                self
            }

            fn multi_line( &mut self, yes:bool ) -> &mut Builder {
                self.syntaxc = self.syntaxc.multi_line(yes);
                self
            }

            fn dot_matches_new_line( &mut self, yes:bool ) -> &mut Builder {
                self.syntaxc = self.syntaxc.dot_matches_new_line(yes);
                self
            }

            fn crlf( &mut self, yes:bool ) -> &mut Builder {
                self.syntaxc = self.syntaxc.crlf(yes);
                self
            }

            fn line_terminator( &mut self, byte: u8) -> &mut Builder {
                self.metac = self.metac.clone().line_terminator( byte );
                self.syntaxc = self.syntaxc.line_terminator( byte );
                self
            }

            fn swap_greed( &mut self, yes:bool ) -> &mut Builder {
                self.syntaxc = self.syntaxc.swap_greed(yes);
                self
            }

            fn ignore_whitespace( &mut self, yes:bool ) -> &mut Builder {
                self.syntaxc = self.syntaxc.ignore_whitespace(yes);
                self
            }

            fn unicode( &mut self, yes:bool ) -> &mut Builder {
                self.syntaxc = self.syntaxc.unicode(yes);
                self
            }

            fn octal( &mut self, yes:bool ) -> &mut Builder {
                self.syntaxc = self.syntaxc.octal(yes);
                self
            }

            fn size_limit( &mut self, limit: usize) -> &mut Builder {
                self.metac = self.metac.clone().nfa_size_limit(Some(limit));
                self
            }

            fn dfa_size_limit( &mut self, limit: usize) -> &mut Builder {
                self.metac = self.metac.clone().hybrid_cache_capacity(limit);
                self
            }

            fn nest_limit( &mut self, limit: u32) -> &mut Builder {
                self.syntaxc = self.syntaxc.nest_limit(limit);
                self
            }
        }

        pub mod string 
        {
            use crate::{error::Error, Regex, RegexSet};

            use super::Builder;


            #[derive( Clone, Debug )]
            pub struct RegexBuilder {
                builder: Builder,
            }

            impl RegexBuilder {
                pub fn new(pattern: &str) -> RegexBuilder {
                    RegexBuilder { builder: Builder::new([pattern]) }
                }

                pub fn build( &self ) -> Result<Regex, Error> { self.builder.build_one_string() }

                pub fn unicode( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.unicode(yes);
                    self
                }

                pub fn case_insensitive( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.case_insensitive(yes);
                    self
                }

                pub fn multi_line( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.multi_line(yes);
                    self
                }

                pub fn dot_matches_new_line(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexBuilder {
                    self.builder.dot_matches_new_line(yes);
                    self
                }

                pub fn crlf( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.crlf(yes);
                    self
                }

                pub fn line_terminator( &mut self, byte: u8) -> &mut RegexBuilder {
                    self.builder.line_terminator( byte );
                    self
                }

                pub fn swap_greed( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.swap_greed(yes);
                    self
                }

                pub fn ignore_whitespace( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.ignore_whitespace(yes);
                    self
                }

                pub fn octal( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.octal(yes);
                    self
                }

                pub fn size_limit( &mut self, bytes: usize) -> &mut RegexBuilder {
                    self.builder.size_limit(bytes);
                    self
                }

                pub fn dfa_size_limit( &mut self, bytes: usize) -> &mut RegexBuilder {
                    self.builder.dfa_size_limit(bytes);
                    self
                }

                pub fn nest_limit( &mut self, limit: u32) -> &mut RegexBuilder {
                    self.builder.nest_limit(limit);
                    self
                }
            }

            #[derive( Clone, Debug )]
            pub struct RegexSetBuilder {
                builder: Builder,
            }

            impl RegexSetBuilder {
                pub fn new<I, S>(patterns: I) -> RegexSetBuilder where I: IntoIterator<Item = S>,
                    S: AsRef<str>,
                {
                    RegexSetBuilder { builder: Builder::new(patterns) }
                }

                pub fn build( &self ) -> Result<RegexSet, Error> { self.builder.build_many_string() }

                pub fn unicode( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.unicode(yes);
                    self
                }

                pub fn case_insensitive( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.case_insensitive(yes);
                    self
                }

                pub fn multi_line( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.multi_line(yes);
                    self
                }

                pub fn dot_matches_new_line(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder {
                    self.builder.dot_matches_new_line(yes);
                    self
                }

                pub fn crlf( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.crlf(yes);
                    self
                }

                pub fn line_terminator( &mut self, byte: u8) -> &mut RegexSetBuilder {
                    self.builder.line_terminator( byte );
                    self
                }
                
                pub fn swap_greed( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.swap_greed(yes);
                    self
                }

                pub fn ignore_whitespace(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder {
                    self.builder.ignore_whitespace(yes);
                    self
                }

                pub fn octal( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.octal(yes);
                    self
                }

                pub fn size_limit( &mut self, bytes: usize) -> &mut RegexSetBuilder {
                    self.builder.size_limit(bytes);
                    self
                }

                pub fn dfa_size_limit(
                    &mut self,
                    bytes: usize,
                ) -> &mut RegexSetBuilder {
                    self.builder.dfa_size_limit(bytes);
                    self
                }

                pub fn nest_limit( &mut self, limit: u32) -> &mut RegexSetBuilder {
                    self.builder.nest_limit(limit);
                    self
                }
            }
        }

        pub mod bytes 
        {
            use crate::{
                bytes::{Regex, RegexSet},
                error::Error,
            };

            use super::Builder;


            #[derive( Clone, Debug )]
            pub struct RegexBuilder {
                builder: Builder,
            }

            impl RegexBuilder {
                pub fn new(pattern: &str) -> RegexBuilder {
                    RegexBuilder { builder: Builder::new([pattern]) }
                }

                pub fn build( &self ) -> Result<Regex, Error> { self.builder.build_one_bytes() }

                pub fn unicode( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.unicode(yes);
                    self
                }

                pub fn case_insensitive( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.case_insensitive(yes);
                    self
                }

                pub fn multi_line( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.multi_line(yes);
                    self
                }

                pub fn dot_matches_new_line(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexBuilder {
                    self.builder.dot_matches_new_line(yes);
                    self
                }

                pub fn crlf( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.crlf(yes);
                    self
                }

                pub fn line_terminator( &mut self, byte: u8) -> &mut RegexBuilder {
                    self.builder.line_terminator( byte );
                    self
                }

                pub fn swap_greed( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.swap_greed(yes);
                    self
                }

                pub fn ignore_whitespace( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.ignore_whitespace(yes);
                    self
                }

                pub fn octal( &mut self, yes:bool ) -> &mut RegexBuilder {
                    self.builder.octal(yes);
                    self
                }

                pub fn size_limit( &mut self, bytes: usize) -> &mut RegexBuilder {
                    self.builder.size_limit(bytes);
                    self
                }

                pub fn dfa_size_limit( &mut self, bytes: usize) -> &mut RegexBuilder {
                    self.builder.dfa_size_limit(bytes);
                    self
                }

                pub fn nest_limit( &mut self, limit: u32) -> &mut RegexBuilder {
                    self.builder.nest_limit(limit);
                    self
                }
            }

            #[derive( Clone, Debug )]
            pub struct RegexSetBuilder {
                builder: Builder,
            }

            impl RegexSetBuilder {
                pub fn new<I, S>(patterns: I) -> RegexSetBuilder where I: IntoIterator<Item = S>,
                    S: AsRef<str>,
                {
                    RegexSetBuilder { builder: Builder::new(patterns) }
                }

                pub fn build( &self ) -> Result<RegexSet, Error> { self.builder.build_many_bytes() }

                pub fn unicode( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.unicode(yes);
                    self
                }

                pub fn case_insensitive( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.case_insensitive(yes);
                    self
                }

                pub fn multi_line( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.multi_line(yes);
                    self
                }

                pub fn dot_matches_new_line(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder {
                    self.builder.dot_matches_new_line(yes);
                    self
                }

                pub fn crlf( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.crlf(yes);
                    self
                }

                pub fn line_terminator( &mut self, byte: u8) -> &mut RegexSetBuilder {
                    self.builder.line_terminator( byte );
                    self
                }
                
                pub fn swap_greed( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.swap_greed(yes);
                    self
                }

                pub fn ignore_whitespace(
                    &mut self,
                    yes: bool,
                ) -> &mut RegexSetBuilder {
                    self.builder.ignore_whitespace(yes);
                    self
                }

                pub fn octal( &mut self, yes:bool ) -> &mut RegexSetBuilder {
                    self.builder.octal(yes);
                    self
                }

                pub fn size_limit( &mut self, bytes: usize) -> &mut RegexSetBuilder {
                    self.builder.size_limit(bytes);
                    self
                }

                pub fn dfa_size_limit(
                    &mut self,
                    bytes: usize,
                ) -> &mut RegexSetBuilder {
                    self.builder.dfa_size_limit(bytes);
                    self
                }

                pub fn nest_limit( &mut self, limit: u32) -> &mut RegexSetBuilder {
                    self.builder.nest_limit(limit);
                    self
                }
            }
        }
    } pub use self::builders::string::{ * };

    pub mod error
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        use alloc::string::{String, ToString};
        use regex_automata::meta;
        */

        #[non_exhaustive]
        #[derive(Clone, PartialEq)]
        pub enum Error {

            Syntax(String),
            CompiledTooBig(usize),
        }

        impl Error {
            pub fn from_meta_build_error(err: meta::BuildError) -> Error {
                if let Some(size_limit) = err.size_limit() {
                    Error::CompiledTooBig(size_limit)
                } else if let Some(ref err) = err.syntax_error() {
                    Error::Syntax(err.to_string())
                } else {
                    Error::Syntax(err.to_string())
                }
            }
        }

        impl ::error::Error for Error {
            // TODO: Remove this method entirely on the next breaking semver release.
            #[allow(deprecated)]
            fn description( &self ) -> &str {
                match *self {
                    Error::Syntax(ref err) => err,
                    Error::CompiledTooBig(_) => "compiled program too big",
                }
            }
        }

        impl ::fmt::Display for Error {
            fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                match *self {
                    Error::Syntax(ref err) => err.fmt(f),
                    Error::CompiledTooBig(limit) => write!(
                        f,
                        "Compiled regex exceeds size limit of {limit} bytes.",
                    ),
                }
            }
        }
        
        impl ::fmt::Debug for Error {
            fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                match *self {
                    Error::Syntax(ref err) =>
                    {
                        let hr: String = ::iter::repeat('~').take(79).collect();
                        writeln!(f, "Syntax(")?;
                        writeln!(f, "{hr}")?;
                        writeln!(f, "{err}")?;
                        writeln!(f, "{hr}")?;
                        write!(f, ")")?;
                        Ok( () )
                    }
                    Error::CompiledTooBig(limit) => { f.debug_tuple("CompiledTooBig").field(&limit).finish() }
                }
            }
        }
    } pub use self::error::{ Error };

    pub mod bytes
    {
        /*!
        Search for regex matches in `&[u8]` haystacks. */
        use ::
        {
            *,
        };

        pub use super::{builders::bytes::*, regex::bytes::*, expression::set::bytes::*};
        /*
        */
        pub mod search
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */

            pub fn find_byte(needle: u8, haystack: &[u8]) -> Option<usize> 
            {
                #[cfg(not(feature = "perf-literal"))]
                fn imp(needle: u8, haystack: &[u8]) -> Option<usize> { haystack.iter().position(|&b| b == needle) }

                #[cfg(feature = "perf-literal")]
                fn imp(needle: u8, haystack: &[u8]) -> Option<usize> { memchr::memchr(needle, haystack) }

                imp(needle, haystack)
            }
        }

    }

    pub mod pattern
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        use ::str::pattern::{Pattern, SearchStep, Searcher, Utf8Pattern};
        use crate::{Matches, Regex};
        */
        #[derive( Debug )]
        pub struct RegexSearcher<'r, 't> {
            haystack: &'t str,
            it: Matches<'r, 't>,
            last_step_end: usize,
            next_match:Option<(usize, usize)>,
        }

        impl<'r> Pattern for &'r Regex {
            type Searcher<'t> = RegexSearcher<'r, 't>;
            fn into_searcher<'t>(self, haystack: &'t str) -> RegexSearcher<'r, 't> {
                RegexSearcher {
                    haystack,
                    it: self.find_iter(haystack),
                    last_step_end: 0,
                    next_match: None,
                }
            }

            fn as_utf8_pattern<'p>(&'p self) -> Option<Utf8Pattern<'p>> { None }
        }

        unsafe impl<'r, 't> Searcher<'t> for RegexSearcher<'r, 't> {
            #[inline]
            fn haystack( &self ) -> &'t str { self.haystack }

            #[inline]
            fn next(&mut self) -> SearchStep {
                if let Some((s, e)) = self.next_match {
                    self.next_match = None;
                    self.last_step_end = e;
                    return SearchStep::Match(s, e);
                }
                match self.it.next() {
                    None => {
                        if self.last_step_end < self.haystack().len() {
                            let last = self.last_step_end;
                            self.last_step_end = self.haystack().len();
                            SearchStep::Reject(last, self.haystack().len())
                        } else {
                            SearchStep::Done
                        }
                    }
                    Some(m) =>
                    {
                        let (s, e) = (m.start(), m.end());
                        if s == self.last_step_end {
                            self.last_step_end = e;
                            SearchStep::Match(s, e)
                        } else {
                            self.next_match = Some((s, e));
                            let last = self.last_step_end;
                            self.last_step_end = s;
                            SearchStep::Reject(last, s)
                        }
                    }
                }
            }
        }
    }

    pub mod expression
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */
        pub mod bytes
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            use alloc::{borrow::Cow, string::String, sync::Arc, vec::Vec};

            use regex_automata::{meta, util::captures, Input, PatternID};

            use crate::{bytes::RegexBuilder, error::Error};
            */

            #[derive( Clone )]
            pub struct Regex {
                pub meta: meta::Regex,
                pub pattern: Arc<str>,
            }

            impl ::fmt::Display for Regex
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "{}", self.as_str())
                }
            }

            impl ::fmt::Debug for Regex
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    f.debug_tuple("Regex").field(&self.as_str()).finish()
                }
            }

            impl ::str::FromStr for Regex {
                type Err = Error;
                fn from_str(s: &str) -> Result<Regex, Error> { Regex::new(s) }
            }

            impl TryFrom<&str> for Regex {
                type Error = Error;
                fn try_from(s: &str) -> Result<Regex, Error> { Regex::new(s) }
            }

            impl TryFrom<String> for Regex {
                type Error = Error;
                fn try_from(s: String) -> Result<Regex, Error> { Regex::new(&s) }
            }

            impl Regex 
            {

                pub fn new(re: &str) -> Result<Regex, Error> { RegexBuilder::new(re).build()}
                
                #[inline] pub fn is_match(&self, haystack: &[u8]) -> bool {
                    self.is_match_at(haystack, 0)
               }
                
                #[inline] pub fn find<'h>(&self, haystack: &'h [u8]) -> Option<Match<'h>> { self.find_at(haystack, 0)}
                
                #[inline] pub fn find_iter<'r, 'h>(&'r self, haystack: &'h [u8]) -> Matches<'r, 'h> { Matches { haystack, it: self.meta.find_iter(haystack) }}
                
                #[inline] pub fn captures<'h>(&self, haystack: &'h [u8]) -> Option<Captures<'h>> { self.captures_at(haystack, 0)}
                
                #[inline] pub fn captures_iter<'r, 'h>(
                    &'r self,
                    haystack: &'h [u8],
                ) -> CaptureMatches<'r, 'h> { CaptureMatches { haystack, it: self.meta.captures_iter(haystack) }}
                
                #[inline] pub fn split<'r, 'h>(&'r self, haystack: &'h [u8]) -> Split<'r, 'h> { Split { haystack, it: self.meta.split(haystack) }}
                
                #[inline] pub fn splitn<'r, 'h>(
                    &'r self,
                    haystack: &'h [u8],
                    limit: usize,
                ) -> SplitN<'r, 'h> { SplitN { haystack, it: self.meta.splitn(haystack, limit) }}
                
                #[inline] pub fn replace<'h, R: Replacer>(
                    &self,
                    haystack: &'h [u8],
                    rep: R,
                ) -> Cow<'h, [u8]> { self.replacen(haystack, 1, rep)}
                
                #[inline] pub fn replace_all<'h, R: Replacer>(
                    &self,
                    haystack: &'h [u8],
                    rep: R,
                ) -> Cow<'h, [u8]> { self.replacen(haystack, 0, rep)}
                
                #[inline] pub fn replacen<'h, R: Replacer>(
                    &self,
                    haystack: &'h [u8],
                    limit: usize,
                    mut rep: R,
                ) -> Cow<'h, [u8]> {
                    if let Some(rep) = rep.no_expansion() {
                        let mut it = self.find_iter(haystack).enumerate().peekable();
                        if it.peek().is_none() {
                            return Cow::Borrowed(haystack);
                        }
                        let mut new = Vec::with_capacity(haystack.len());
                        let mut last_match = 0;
                        for (i, m) in it {
                            new.extend_from_slice(&haystack[last_match..m.start()]);
                            new.extend_from_slice(&rep);
                            last_match = m.end();
                            if limit > 0 && i >= limit - 1 {
                                break;
                            }
                        }
                        new.extend_from_slice(&haystack[last_match..]);
                        return Cow::Owned(new);
                    }
                    
                    let mut it = self.captures_iter(haystack).enumerate().peekable();
                    if it.peek().is_none() {
                        return Cow::Borrowed(haystack);
                    }
                    let mut new = Vec::with_capacity(haystack.len());
                    let mut last_match = 0;
                    for (i, cap) in it {
                        let m = cap.get(0).unwrap();
                        new.extend_from_slice(&haystack[last_match..m.start()]);
                        rep.replace_append(&cap, &mut new);
                        last_match = m.end();
                        if limit > 0 && i >= limit - 1 {
                            break;
                        }
                    }
                    new.extend_from_slice(&haystack[last_match..]);
                    Cow::Owned(new)
                }
            }

            impl Regex {

                #[inline] pub fn shortest_match(&self, haystack: &[u8]) -> Option<usize> { self.shortest_match_at(haystack, 0)}
                
                #[inline] pub fn shortest_match_at(
                    &self,
                    haystack: &[u8],
                    start: usize,
                ) -> Option<usize> {
                    let input =
                        Input::new(haystack).earliest(true).span(start..haystack.len());
                    self.meta.search_half(&input).map(|hm| hm.offset())
               }
                
                #[inline] pub fn is_match_at(&self, haystack: &[u8], start: usize) -> bool {
                    self.meta.is_match(Input::new(haystack).span(start..haystack.len()))
               }
                
                #[inline] pub fn find_at<'h>(
                    &self,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Match<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta.find(input).map(|m| Match::new(haystack, m.start(), m.end()))
               }
                
                #[inline] pub fn captures_at<'h>(
                    &self,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Captures<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut caps = self.meta.create_captures();
                    self.meta.captures(input, &mut caps);
                    if caps.is_match() {
                        let static_captures_len = self.static_captures_len();
                        Some(Captures { haystack, caps, static_captures_len })
                    } else {
                        None
                    }
               }
                
                #[inline] pub fn captures_read<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h [u8],
                ) -> Option<Match<'h>> { self.captures_read_at(locs, haystack, 0)}
                
                #[inline] pub fn captures_read_at<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Match<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta.search_captures(&input, &mut locs.0);
                    locs.0.get_match().map(|m| Match::new(haystack, m.start(), m.end()))
                }
                #[doc(hidden)]
                #[inline] pub fn read_captures_at<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h [u8],
                    start: usize,
                ) -> Option<Match<'h>> { self.captures_read_at(locs, haystack, start) }
            }

            impl Regex {

                #[inline] pub fn as_str( &self ) -> &str { &self.pattern }

                #[inline] pub fn capture_names( &self ) -> CaptureNames<'_> { CaptureNames( self.meta.group_info().pattern_names(PatternID::ZERO)) }

                #[inline] pub fn captures_len( &self ) -> usize { self.meta.group_info().group_len(PatternID::ZERO) }
                
                #[inline] pub fn static_captures_len( &self ) -> Option<usize> { self.meta.static_captures_len()}
                
                #[inline] pub fn capture_locations( &self ) -> CaptureLocations { CaptureLocations( self.meta.create_captures()) }

                #[doc(hidden)]
                #[inline] pub fn locations( &self ) -> CaptureLocations { self.capture_locations() }
            }

            #[derive(Copy, Clone, Eq, PartialEq)]
            pub struct Match<'h> {
                haystack: &'h [u8],
                start: usize,
                end: usize,
            }

            impl<'h> Match<'h> {

                #[inline] pub fn start( &self ) -> usize { self.start }

                #[inline] pub fn end( &self ) -> usize { self.end }

                #[inline] pub fn is_empty( &self ) -> bool { self.start == self.end }

                #[inline] pub fn len( &self ) -> usize { self.end - self.start }
                
                #[inline] pub fn range( &self ) -> ::ops::Range<usize> { self.start..self.end }

                #[inline] pub fn as_bytes( &self ) -> &'h [u8] { &self.haystack[self.range()] }

                #[inline] fn new(haystack: &'h [u8], start: usize, end: usize) -> Match<'h> { Match { haystack, start, end } }
            }

            impl<'h> ::fmt::Debug for Match<'h>
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    use regex_automata::util::escape::DebugHaystack;

                    let mut fmt = f.debug_struct("Match");
                    fmt.field("start", &self.start)
                        .field("end", &self.end)
                        .field("bytes", &DebugHaystack(&self.as_bytes()));

                    fmt.finish()
                }
            }

            impl<'h> From<Match<'h>> for &'h [u8] {
                fn from(m: Match<'h>) -> &'h [u8] {
                    m.as_bytes()
                }
            }

            impl<'h> From<Match<'h>> for ::ops::Range<usize> {
                fn from(m: Match<'h>) -> ::ops::Range<usize> { m.range() }
            }


            pub struct Captures<'h> {
                haystack: &'h [u8],
                caps: captures::Captures,
                static_captures_len:Option<usize>,
            }

            impl<'h> Captures<'h> {

                #[inline] pub fn get(&self, i: usize) -> Option<Match<'h>> {
                    self.caps
                        .get_group(i)
                        .map(|sp| Match::new( self.haystack, sp.start, sp.end))
                }

                #[inline] pub fn get_match( &self ) -> Match<'h> { self.get(0).unwrap() }

                #[inline] pub fn name(&self, name: &str) -> Option<Match<'h>> {
                    self.caps
                        .get_group_by_name(name)
                        .map(|sp| Match::new( self.haystack, sp.start, sp.end))
                }

                pub fn extract<const N: usize>( &self ) -> (&'h [u8], [&'h [u8]; N])
                {
                    let len = self
                        .static_captures_len
                        .expect("number of capture groups can vary in a match")
                        .checked_sub(1)
                        .expect("number of groups is always greater than zero");
                    assert_eq!(N, len, "asked for {N} groups, but must ask for {len}");
                    self.caps.extract_bytes( self.haystack)
               }
                
                #[inline] pub fn expand(&self, replacement: &[u8], dst: &mut Vec<u8>) {
                    self.caps.interpolate_bytes_into( self.haystack, replacement, dst);
                }

                #[inline] pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 'h> { SubCaptureMatches { haystack: self.haystack, it: self.caps.iter() } }

                #[inline] pub fn len( &self ) -> usize { self.caps.group_len() }
            }

            impl<'h> ::fmt::Debug for Captures<'h>
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    struct CapturesDebugMap<'a> { caps: &'a Captures<'a>, }

                    impl<'a> ::fmt::Debug for CapturesDebugMap<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            let mut map = f.debug_map();
                            let names =
                                self.caps.caps.group_info().pattern_names(PatternID::ZERO);
                            for (group_index, maybe_name) in names.enumerate() {
                                let key = Key(group_index, maybe_name);
                                match self.caps.get(group_index) {
                                    None => map.entry(&key, &None::<()>),
                                    Some(mat) => map.entry(&key, &Value(mat)),
                                };
                            }
                            map.finish()
                        }
                    }

                    struct Key<'a>(usize, Option<&'a str>);

                    impl<'a> ::fmt::Debug for Key<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(f, "{}", self.0)?;
                            if let Some(name) = self.1 {
                                write!(f, "/{name:?}")?;
                            }
                            Ok( () )
                        }
                    }

                    struct Value<'a>(Match<'a>);

                    impl<'a> ::fmt::Debug for Value<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            use regex_automata::util::escape::DebugHaystack;

                            write!(
                                f,
                                "{}..{}/{:?}",
                                self.0.start(),
                                self.0.end(),
                                DebugHaystack( self.0.as_bytes())
                            )
                        }
                    }

                    f.debug_tuple("Captures")
                        .field(&CapturesDebugMap { caps: self })
                        .finish()
                }
            }

            impl<'h> ::ops::Index<usize> for Captures<'h>
            {
                type Output = [u8];
                fn index<'a>(&'a self, i: usize) -> &'a [u8] {
                    self.get(i)
                        .map(|m| m.as_bytes())
                        .unwrap_or_else(|| panic!("no group at index '{i}'"))
                }
            }

            impl<'h, 'n> ::ops::Index<&'n str> for Captures<'h>
            {
                type Output = [u8];
                fn index<'a>(&'a self, name: &'n str) -> &'a [u8] {
                    self.name(name)
                        .map(|m| m.as_bytes())
                        .unwrap_or_else(|| panic!("no group named '{name}'"))
                }
            }

            #[derive( Clone, Debug )]
            pub struct CaptureLocations(captures::Captures);


            #[doc(hidden)]
            pub type Locations = CaptureLocations;

            impl CaptureLocations {
                #[inline] pub fn get(&self, i: usize) -> Option<(usize, usize)> { self.0.get_group(i).map(|sp| (sp.start, sp.end)) }

                #[inline] pub fn len( &self ) -> usize { self.0.group_info().group_len(PatternID::ZERO) }

                #[doc(hidden)]
                #[inline] pub fn pos(&self, i: usize) -> Option<(usize, usize)> { self.get(i) }
            }

            #[derive( Debug )]
            pub struct Matches<'r, 'h> {
                haystack: &'h [u8],
                it: meta::FindMatches<'r, 'h>,
            }

            impl<'r, 'h> Iterator for Matches<'r, 'h>
            {
                type Item = Match<'h>;

                #[inline] fn next(&mut self) -> Option<Match<'h>> {
                    self.it
                        .next()
                        .map(|sp| Match::new( self.haystack, sp.start(), sp.end()))
                }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for Matches<'r, 'h> {}

            #[derive( Debug )]
            pub struct CaptureMatches<'r, 'h> {
                haystack: &'h [u8],
                it: meta::CapturesMatches<'r, 'h>,
            }

            impl<'r, 'h> Iterator for CaptureMatches<'r, 'h>
            {
                type Item = Captures<'h>;

                #[inline] fn next(&mut self) -> Option<Captures<'h>> {
                    let static_captures_len = self.it.regex().static_captures_len();
                    self.it.next().map(|caps| Captures {
                        haystack: self.haystack,
                        caps,
                        static_captures_len,
                    })
                }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'r, 'h> ::iter::FusedIterator for CaptureMatches<'r, 'h> {}

            #[derive( Debug )]
            pub struct Split<'r, 'h> {
                haystack: &'h [u8],
                it: meta::Split<'r, 'h>,
            }

            impl<'r, 'h> Iterator for Split<'r, 'h>
            {
                type Item = &'h [u8];

                #[inline] fn next(&mut self) -> Option<&'h [u8]> { self.it.next().map(|span| &self.haystack[span]) }
            }

            impl<'r, 'h> ::iter::FusedIterator for Split<'r, 'h> {}

            #[derive( Debug )]
            pub struct SplitN<'r, 'h> {
                haystack: &'h [u8],
                it: meta::SplitN<'r, 'h>,
            }

            impl<'r, 'h> Iterator for SplitN<'r, 'h>
            {
                type Item = &'h [u8];

                #[inline] fn next(&mut self) -> Option<&'h [u8]> { self.it.next().map(|span| &self.haystack[span]) }

                #[inline] fn size_hint( &self ) -> (usize, Option<usize>) { self.it.size_hint() }
            }

            impl<'r, 'h> ::iter::FusedIterator for SplitN<'r, 'h> {}

            #[derive( Clone, Debug )]
            pub struct CaptureNames<'r>(captures::GroupInfoPatternNames<'r>);

            impl<'r> Iterator for CaptureNames<'r>
            {
                type Item = Option<&'r str>;

                #[inline] fn next(&mut self) -> Option<Option<&'r str>> { self.0.next() }

                #[inline] fn size_hint( &self ) -> (usize, Option<usize>) { self.0.size_hint() }

                #[inline] fn count(self) -> usize {
                    self.0.count()
                }
            }

            impl<'r> ExactSizeIterator for CaptureNames<'r> {}

            impl<'r> ::iter::FusedIterator for CaptureNames<'r> {}
            #[derive( Clone, Debug )]
            pub struct SubCaptureMatches<'c, 'h> {
                haystack: &'h [u8],
                it: captures::CapturesPatternIter<'c>,
            }

            impl<'c, 'h> Iterator for SubCaptureMatches<'c, 'h>
            {
                type Item = Option<Match<'h>>;

                #[inline] fn next(&mut self) -> Option<Option<Match<'h>>> {
                    self.it.next().map(|group| {
                        group.map(|sp| Match::new( self.haystack, sp.start, sp.end))
                    })
                }

                #[inline] fn size_hint( &self ) -> (usize, Option<usize>) { self.it.size_hint() }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'c, 'h> ExactSizeIterator for SubCaptureMatches<'c, 'h> {}

            impl<'c, 'h> ::iter::FusedIterator for SubCaptureMatches<'c, 'h> {}


            pub trait Replacer {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>);
                fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>> { None }
                fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> { ReplacerRef(self) }
            }

            impl<'a, const N: usize> Replacer for &'a [u8; N] {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(&**self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> { no_expansion(self) }
            }

            impl<const N: usize> Replacer for [u8; N] {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(&*self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> { no_expansion(self) }
            }

            impl<'a> Replacer for &'a [u8] {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(*self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> { no_expansion(self) }
            }

            impl<'a> Replacer for &'a Vec<u8> {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(*self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> { no_expansion(self) }
            }

            impl Replacer for Vec<u8> {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand(self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> { no_expansion(self) }
            }

            impl<'a> Replacer for Cow<'a, [u8]> {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand( self.as_ref(), dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> { no_expansion(self) }
            }

            impl<'a> Replacer for &'a Cow<'a, [u8]> {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    caps.expand( self.as_ref(), dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> { no_expansion(self) }
            }

            impl<F, T> Replacer for F
            where
                F: FnMut(&Captures<'_>) -> T,
                T: AsRef<[u8]>,
            {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    dst.extend_from_slice((*self)(caps).as_ref());
                }
            }

            #[derive( Debug )]
            pub struct ReplacerRef<'a, R: ?Sized>(&'a mut R);

            impl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R> {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut Vec<u8>) {
                    self.0.replace_append(caps, dst)
                }

                fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, [u8]>> { self.0.no_expansion() }
            }

            #[derive( Clone, Debug )]
            pub struct NoExpand<'s>(pub &'s [u8]);

            impl<'s> Replacer for NoExpand<'s> {
                fn replace_append( &mut self, _: &Captures<'_>, dst: &mut Vec<u8>) {
                    dst.extend_from_slice( self.0);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, [u8]>> { Some(Cow::Borrowed( self.0)) }
            }
            
            fn no_expansion<T: AsRef<[u8]>>(replacement: &T) -> Option<Cow<'_, [u8]>> {
                let replacement = replacement.as_ref();
                match crate::find_byte::find_byte(b'$', replacement) {
                    Some(_) => None,
                    None => Some(Cow::Borrowed(replacement)),
                }
            }


        }

        pub mod string
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            use alloc::{borrow::Cow, string::String, sync::Arc};

            use regex_automata::{meta, util::captures, Input, PatternID};

            use crate::{error::Error, RegexBuilder};
            */

            #[derive( Clone )]
            pub struct Regex {
                pub meta: meta::Regex,
                pub pattern: Arc<str>,
            }

            impl ::fmt::Display for Regex
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "{}", self.as_str())
                }
            }

            impl ::fmt::Debug for Regex
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    f.debug_tuple("Regex").field(&self.as_str()).finish()
                }
            }

            impl ::str::FromStr for Regex {
                type Err = Error;
                fn from_str(s: &str) -> Result<Regex, Error> { Regex::new(s) }
            }

            impl TryFrom<&str> for Regex {
                type Error = Error;
                fn try_from(s: &str) -> Result<Regex, Error> { Regex::new(s) }
            }

            impl TryFrom<String> for Regex {
                type Error = Error;
                fn try_from(s: String) -> Result<Regex, Error> { Regex::new(&s) }
            }

            impl Regex 
            {

                pub fn new(re: &str) -> Result<Regex, Error> { RegexBuilder::new(re).build()}
                
                #[inline] pub fn is_match(&self, haystack: &str) -> bool {
                    self.is_match_at(haystack, 0)
               }
                
                #[inline] pub fn find<'h>(&self, haystack: &'h str) -> Option<Match<'h>> { self.find_at(haystack, 0)}
                
                #[inline] pub fn find_iter<'r, 'h>(&'r self, haystack: &'h str) -> Matches<'r, 'h> { Matches { haystack, it: self.meta.find_iter(haystack) }}
                
                #[inline] pub fn captures<'h>(&self, haystack: &'h str) -> Option<Captures<'h>> { self.captures_at(haystack, 0)}
                
                #[inline] pub fn captures_iter<'r, 'h>(
                    &'r self,
                    haystack: &'h str,
                ) -> CaptureMatches<'r, 'h> { CaptureMatches { haystack, it: self.meta.captures_iter(haystack) }}
                
                #[inline] pub fn split<'r, 'h>(&'r self, haystack: &'h str) -> Split<'r, 'h> { Split { haystack, it: self.meta.split(haystack) }}
                
                #[inline] pub fn splitn<'r, 'h>(
                    &'r self,
                    haystack: &'h str,
                    limit: usize,
                ) -> SplitN<'r, 'h> { SplitN { haystack, it: self.meta.splitn(haystack, limit) }}
                
                #[inline] pub fn replace<'h, R: Replacer>(
                    &self,
                    haystack: &'h str,
                    rep: R,
                ) -> Cow<'h, str> { self.replacen(haystack, 1, rep)}
                
                #[inline] pub fn replace_all<'h, R: Replacer>(
                    &self,
                    haystack: &'h str,
                    rep: R,
                ) -> Cow<'h, str> { self.replacen(haystack, 0, rep)}
                
                #[inline] pub fn replacen<'h, R: Replacer>(
                    &self,
                    haystack: &'h str,
                    limit: usize,
                    mut rep: R,
                ) -> Cow<'h, str> {
                    if let Some(rep) = rep.no_expansion() {
                        let mut it = self.find_iter(haystack).enumerate().peekable();
                        if it.peek().is_none() {
                            return Cow::Borrowed(haystack);
                        }
                        let mut new = String::with_capacity(haystack.len());
                        let mut last_match = 0;
                        for (i, m) in it {
                            new.push_str(&haystack[last_match..m.start()]);
                            new.push_str(&rep);
                            last_match = m.end();
                            if limit > 0 && i >= limit - 1 {
                                break;
                            }
                        }
                        new.push_str(&haystack[last_match..]);
                        return Cow::Owned(new);
                    }
                    
                    let mut it = self.captures_iter(haystack).enumerate().peekable();
                    if it.peek().is_none() {
                        return Cow::Borrowed(haystack);
                    }
                    let mut new = String::with_capacity(haystack.len());
                    let mut last_match = 0;
                    for (i, cap) in it {
                        let m = cap.get(0).unwrap();
                        new.push_str(&haystack[last_match..m.start()]);
                        rep.replace_append(&cap, &mut new);
                        last_match = m.end();
                        if limit > 0 && i >= limit - 1 {
                            break;
                        }
                    }
                    new.push_str(&haystack[last_match..]);
                    Cow::Owned(new)
                }
            }

            impl Regex {

                #[inline] pub fn shortest_match(&self, haystack: &str) -> Option<usize> { self.shortest_match_at(haystack, 0)}
                
                #[inline] pub fn shortest_match_at(
                    &self,
                    haystack: &str,
                    start: usize,
                ) -> Option<usize> {
                    let input =
                        Input::new(haystack).earliest(true).span(start..haystack.len());
                    self.meta.search_half(&input).map(|hm| hm.offset())
               }
                
                #[inline] pub fn is_match_at(&self, haystack: &str, start: usize) -> bool {
                    let input =
                        Input::new(haystack).earliest(true).span(start..haystack.len());
                    self.meta.search_half(&input).is_some()
               }
                
                #[inline] pub fn find_at<'h>(
                    &self,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Match<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta
                        .search(&input)
                        .map(|m| Match::new(haystack, m.start(), m.end()))
               }
                
                #[inline] pub fn captures_at<'h>(
                    &self,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Captures<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    let mut caps = self.meta.create_captures();
                    self.meta.search_captures(&input, &mut caps);
                    if caps.is_match() {
                        let static_captures_len = self.static_captures_len();
                        Some(Captures { haystack, caps, static_captures_len })
                    } else {
                        None
                    }
               }
                
                #[inline] pub fn captures_read<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h str,
                ) -> Option<Match<'h>> { self.captures_read_at(locs, haystack, 0)}
                
                #[inline] pub fn captures_read_at<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Match<'h>> {
                    let input = Input::new(haystack).span(start..haystack.len());
                    self.meta.search_captures(&input, &mut locs.0);
                    locs.0.get_match().map(|m| Match::new(haystack, m.start(), m.end()))
                }
                #[doc(hidden)]
                #[inline] pub fn read_captures_at<'h>(
                    &self,
                    locs: &mut CaptureLocations,
                    haystack: &'h str,
                    start: usize,
                ) -> Option<Match<'h>> { self.captures_read_at(locs, haystack, start) }
            }

            impl Regex {

                #[inline] pub fn as_str( &self ) -> &str { &self.pattern }

                
                
                
                #[inline] pub fn capture_names( &self ) -> CaptureNames<'_> { CaptureNames( self.meta.group_info().pattern_names(PatternID::ZERO)) }

                
                
                #[inline] pub fn captures_len( &self ) -> usize { self.meta.group_info().group_len(PatternID::ZERO) }
                
                #[inline] pub fn static_captures_len( &self ) -> Option<usize> { self.meta.static_captures_len() }
                
                #[inline] pub fn capture_locations( &self ) -> CaptureLocations { CaptureLocations( self.meta.create_captures()) }

                #[doc(hidden)]
                #[inline] pub fn locations( &self ) -> CaptureLocations { self.capture_locations() }
            }
            #[derive(Copy, Clone, Eq, PartialEq)]
            pub struct Match<'h> {
                haystack: &'h str,
                start: usize,
                end: usize,
            }

            impl<'h> Match<'h> {
                #[inline] pub fn start( &self ) -> usize { self.start }
                
                #[inline] pub fn end( &self ) -> usize { self.end }

                #[inline] pub fn is_empty( &self ) -> bool { self.start == self.end }

                #[inline] pub fn len( &self ) -> usize { self.end - self.start }
                
                #[inline] pub fn range( &self ) -> ::ops::Range<usize> { self.start..self.end }

                #[inline] pub fn as_str( &self ) -> &'h str { &self.haystack[self.range()] }

                #[inline] fn new(haystack: &'h str, start: usize, end: usize) -> Match<'h> { Match { haystack, start, end } }
            }

            impl<'h> ::fmt::Debug for Match<'h>
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    f.debug_struct("Match")
                        .field("start", &self.start)
                        .field("end", &self.end)
                        .field("string", &self.as_str())
                        .finish()
                }
            }

            impl<'h> From<Match<'h>> for &'h str {
                fn from(m: Match<'h>) -> &'h str {
                    m.as_str()
                }
            }

            impl<'h> From<Match<'h>> for ::ops::Range<usize> {
                fn from(m: Match<'h>) -> ::ops::Range<usize> { m.range() }
            }
            ///
            pub struct Captures<'h> {
                haystack: &'h str,
                caps: captures::Captures,
                static_captures_len:Option<usize>,
            }

            impl<'h> Captures<'h> {
                
                
                #[inline] pub fn get(&self, i: usize) -> Option<Match<'h>> {
                    self.caps
                        .get_group(i)
                        .map(|sp| Match::new( self.haystack, sp.start, sp.end))
                }

                

                ///

                #[inline] pub fn get_match( &self ) -> Match<'h> { self.get(0).unwrap() }
                
                #[inline] pub fn name(&self, name: &str) -> Option<Match<'h>> {
                    self.caps
                        .get_group_by_name(name)
                        .map(|sp| Match::new( self.haystack, sp.start, sp.end))
                }
                

                

                
                pub fn extract<const N: usize>( &self ) -> (&'h str, [&'h str; N])
                {
                    let len = self
                    .static_captures_len
                    .expect("number of capture groups can vary in a match")
                    .checked_sub(1)
                    .expect("number of groups is always greater than zero");
                    assert_eq!(N, len, "asked for {N} groups, but must ask for {len}");
                    self.caps.extract( self.haystack)
                }
                
                #[inline] pub fn expand(&self, replacement: &str, dst: &mut String) { self.caps.interpolate_string_into( self.haystack, replacement, dst); }
                #[inline] pub fn iter<'c>(&'c self) -> SubCaptureMatches<'c, 'h> { SubCaptureMatches { haystack: self.haystack, it: self.caps.iter() } }
                #[inline] pub fn len( &self ) -> usize { self.caps.group_len() }
            }

            impl<'h> ::fmt::Debug for Captures<'h>
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    struct CapturesDebugMap<'a> { caps: &'a Captures<'a>, }

                    impl<'a> ::fmt::Debug for CapturesDebugMap<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            let mut map = f.debug_map();
                            let names =
                                self.caps.caps.group_info().pattern_names(PatternID::ZERO);
                            for (group_index, maybe_name) in names.enumerate() {
                                let key = Key(group_index, maybe_name);
                                match self.caps.get(group_index) {
                                    None => map.entry(&key, &None::<()>),
                                    Some(mat) => map.entry(&key, &Value(mat)),
                                };
                            }
                            map.finish()
                        }
                    }

                    struct Key<'a>(usize, Option<&'a str>);

                    impl<'a> ::fmt::Debug for Key<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(f, "{}", self.0)?;
                            if let Some(name) = self.1 {
                                write!(f, "/{name:?}")?;
                            }
                            Ok( () )
                        }
                    }

                    struct Value<'a>(Match<'a>);

                    impl<'a> ::fmt::Debug for Value<'a> {
                        fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                            write!(
                                f,
                                "{}..{}/{:?}",
                                self.0.start(),
                                self.0.end(),
                                self.0.as_str()
                            )
                        }
                    }

                    f.debug_tuple("Captures")
                        .field(&CapturesDebugMap { caps: self })
                        .finish()
                }
            }

            impl<'h> ::ops::Index<usize> for Captures<'h>
            {
                type Output = str;
                fn index<'a>(&'a self, i: usize) -> &'a str {
                    self.get(i)
                        .map(|m| m.as_str())
                        .unwrap_or_else(|| panic!("no group at index '{i}'"))
                }
            }

            impl<'h, 'n> ::ops::Index<&'n str> for Captures<'h>
            {
                type Output = str;
                fn index<'a>(&'a self, name: &'n str) -> &'a str {
                    self.name(name)
                        .map(|m| m.as_str())
                        .unwrap_or_else(|| panic!("no group named '{name}'"))
                }
            }
            
            #[derive( Clone, Debug )]
            pub struct CaptureLocations(captures::Captures);
            #[doc(hidden)]
            pub type Locations = CaptureLocations;

            impl CaptureLocations
            {
                #[inline] pub fn get(&self, i: usize) -> Option<(usize, usize)> { self.0.get_group(i).map(|sp| (sp.start, sp.end)) }
                #[inline] pub fn len( &self ) -> usize { self.0.group_info().group_len(PatternID::ZERO) }
                #[inline] pub fn pos(&self, i: usize) -> Option<(usize, usize)> { self.get(i) }
            }
            
            #[derive( Debug )]
            pub struct Matches<'r, 'h> {
                haystack: &'h str,
                it: meta::FindMatches<'r, 'h>,
            }

            impl<'r, 'h> Iterator for Matches<'r, 'h>
            {
                type Item = Match<'h>;

                #[inline] fn next(&mut self) -> Option<Match<'h>>
                {
                    self.it
                    .next()
                    .map(|sp| Match::new( self.haystack, sp.start(), sp.end()))
                }

                #[inline] fn count(self) -> usize { self.it.count() }
            }

            impl<'r, 'h> ::iter::FusedIterator for Matches<'r, 'h> {}
            
            #[derive( Debug )]
            pub struct CaptureMatches<'r, 'h> {
                haystack: &'h str,
                it: meta::CapturesMatches<'r, 'h>,
            }

            impl<'r, 'h> Iterator for CaptureMatches<'r, 'h>
            {
                type Item = Captures<'h>;

                #[inline] fn next(&mut self) -> Option<Captures<'h>> {
                    let static_captures_len = self.it.regex().static_captures_len();
                    self.it.next().map(|caps| Captures {
                        haystack: self.haystack,
                        caps,
                        static_captures_len,
                    })
                }

                #[inline] fn count(self) -> usize { self.it.count() }
            }

            impl<'r, 'h> ::iter::FusedIterator for CaptureMatches<'r, 'h> {}
            
            #[derive( Debug )]
            pub struct Split<'r, 'h> {
                haystack: &'h str,
                it: meta::Split<'r, 'h>,
            }

            impl<'r, 'h> Iterator for Split<'r, 'h>
            {
                type Item = &'h str;

                #[inline] fn next(&mut self) -> Option<&'h str> { self.it.next().map(|span| &self.haystack[span]) }
            }

            impl<'r, 'h> ::iter::FusedIterator for Split<'r, 'h> {}
            
            #[derive( Debug )]
            pub struct SplitN<'r, 'h> {
                haystack: &'h str,
                it: meta::SplitN<'r, 'h>,
            }

            impl<'r, 'h> Iterator for SplitN<'r, 'h>
            {
                type Item = &'h str;

                #[inline] fn next(&mut self) -> Option<&'h str> { self.it.next().map(|span| &self.haystack[span]) }

                #[inline] fn size_hint( &self ) -> (usize, Option<usize>) { self.it.size_hint() }
            }

            impl<'r, 'h> ::iter::FusedIterator for SplitN<'r, 'h> {}

            #[derive( Clone, Debug )]
            pub struct CaptureNames<'r>(captures::GroupInfoPatternNames<'r>);

            impl<'r> Iterator for CaptureNames<'r>
            {
                type Item = Option<&'r str>;

                #[inline] fn next(&mut self) -> Option<Option<&'r str>> { self.0.next() }

                #[inline] fn size_hint( &self ) -> (usize, Option<usize>) { self.0.size_hint() }

                #[inline] fn count(self) -> usize {
                    self.0.count()
                }
            }

            impl<'r> ExactSizeIterator for CaptureNames<'r> {}

            impl<'r> ::iter::FusedIterator for CaptureNames<'r> {}
            #[derive( Clone, Debug )]
            pub struct SubCaptureMatches<'c, 'h> {
                haystack: &'h str,
                it: captures::CapturesPatternIter<'c>,
            }

            impl<'c, 'h> Iterator for SubCaptureMatches<'c, 'h>
            {
                type Item = Option<Match<'h>>;

                #[inline] fn next(&mut self) -> Option<Option<Match<'h>>> {
                    self.it.next().map(|group| {
                        group.map(|sp| Match::new( self.haystack, sp.start, sp.end))
                    })
                }

                #[inline] fn size_hint( &self ) -> (usize, Option<usize>) { self.it.size_hint() }

                #[inline] fn count(self) -> usize {
                    self.it.count()
                }
            }

            impl<'c, 'h> ExactSizeIterator for SubCaptureMatches<'c, 'h> {}

            impl<'c, 'h> ::iter::FusedIterator for SubCaptureMatches<'c, 'h> {}
            ///
            pub trait Replacer {

                ///

                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut String);
                fn no_expansion<'r>(&'r mut self) -> Option<Cow<'r, str>> { None }
                
                fn by_ref<'r>(&'r mut self) -> ReplacerRef<'r, Self> { ReplacerRef(self) }
            }

            impl<'a> Replacer for &'a str {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut String) {
                    caps.expand(*self, dst);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> { no_expansion(self) }
            }

            impl<'a> Replacer for &'a String {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_str().replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> { no_expansion(self) }
            }

            impl Replacer for String {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_str().replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> { no_expansion(self) }
            }

            impl<'a> Replacer for Cow<'a, str> {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_ref().replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> { no_expansion(self) }
            }

            impl<'a> Replacer for &'a Cow<'a, str> {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.as_ref().replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> { no_expansion(self) }
            }

            impl<F, T> Replacer for F
            where
                F: FnMut(&Captures<'_>) -> T,
                T: AsRef<str>,
            {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut String) {
                    dst.push_str((*self)(caps).as_ref());
                }
            }

            #[derive( Debug )]
            pub struct ReplacerRef<'a, R: ?Sized>(&'a mut R);

            impl<'a, R: Replacer + ?Sized + 'a> Replacer for ReplacerRef<'a, R> {
                fn replace_append( &mut self, caps: &Captures<'_>, dst: &mut String) {
                    self.0.replace_append(caps, dst)
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> { self.0.no_expansion() }
            }

            #[derive( Clone, Debug )]
            pub struct NoExpand<'s>(pub &'s str);

            impl<'s> Replacer for NoExpand<'s> {
                fn replace_append( &mut self, _: &Captures<'_>, dst: &mut String) {
                    dst.push_str( self.0);
                }

                fn no_expansion(&mut self) -> Option<Cow<'_, str>> { Some(Cow::Borrowed( self.0)) }
            }
            
            fn no_expansion<T: AsRef<str>>(replacement: &T) -> Option<Cow<'_, str>> {
                let replacement = replacement.as_ref();
                match crate::find_byte::find_byte(b'$', replacement.as_bytes()) {
                    Some(_) => None,
                    None => Some(Cow::Borrowed(replacement)),
                }
            }
        }

        pub mod set
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub mod bytes
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use alloc::string::String;
                use regex_automata::{meta, Input, PatternID, PatternSet, PatternSetIter};
                use crate::{bytes::RegexSetBuilder, Error};
                */

                
                

                

                
                ///
                
                ///
                #[derive( Clone )]
                pub struct RegexSet {
                    pub meta: meta::Regex,
                    pub patterns: alloc::sync::Arc<[String]>,
                }

                impl RegexSet
                {
                    pub fn new<I, S>(exprs: I) -> Result<RegexSet, Error>
                    where
                        S: AsRef<str>,
                        I: IntoIterator<Item = S>,
                    {
                        RegexSetBuilder::new(exprs).build()
                    }
                    
                    pub fn empty() -> RegexSet {
                        let empty: [&str; 0] = [];
                        RegexSetBuilder::new(empty).build().unwrap()
                    }
                    
                    #[inline] pub fn is_match(&self, haystack: &[u8]) -> bool {
                        self.is_match_at(haystack, 0)
                    }
                    
                    #[inline] pub fn is_match_at(&self, haystack: &[u8], start: usize) -> bool {
                        self.meta.is_match(Input::new(haystack).span(start..haystack.len()))
                    }

                    ///
                    #[inline] pub fn matches(&self, haystack: &[u8]) -> SetMatches {
                        self.matches_at(haystack, 0)
                    }
                    
                    #[inline] pub fn matches_at(&self, haystack: &[u8], start: usize) -> SetMatches {
                        let input = Input::new(haystack).span(start..haystack.len());
                        let mut patset = PatternSet::new( self.meta.pattern_len());
                        self.meta.which_overlapping_matches(&input, &mut patset);
                        SetMatches(patset)
                    }
                    #[doc(hidden)]
                    #[inline] pub fn matches_read_at(
                        &self,
                        matches: &mut [bool],
                        haystack: &[u8],
                        start: usize,
                    ) -> bool {
                        // 'SetMatches', which is basically just a newtype around PatternSet.
                        let mut patset = PatternSet::new( self.meta.pattern_len());
                        let mut input = Input::new(haystack);
                        input.set_start(start);
                        self.meta.which_overlapping_matches(&input, &mut patset);
                        for pid in patset.iter() {
                            matches[pid] = true;
                        }
                        !patset.is_empty()
                    }
                    #[doc(hidden)]
                    #[inline] pub fn read_matches_at(
                        &self,
                        matches: &mut [bool],
                        haystack: &[u8],
                        start: usize,
                    ) -> bool {
                        self.matches_read_at(matches, haystack, start)
                    }
                    #[inline] pub fn len( &self ) -> usize { self.meta.pattern_len() }
                    
                    #[inline] pub fn is_empty( &self ) -> bool { self.meta.pattern_len() == 0 }
                    #[inline] pub fn patterns( &self ) -> &[String] { &self.patterns }
                }

                impl Default for RegexSet
                {
                    fn default() -> Self {
                        RegexSet::empty()
                    }
                }

                #[derive( Clone, Debug )]
                pub struct SetMatches(PatternSet);

                impl SetMatches {
                    #[inline] pub fn matched_any( &self ) -> bool { !self.0.is_empty() }
                    
                    pub fn matched_all( &self ) -> bool { self.0.is_full() }
                    #[inline] pub fn matched(&self, index: usize) -> bool {
                        self.0.contains(PatternID::new_unchecked(index))
                    }
                    
                    #[inline] pub fn len( &self ) -> usize { self.0.capacity() }
                    ///
                    ///
                    ///
                    #[inline] pub fn iter( &self ) -> SetMatchesIter<'_> { SetMatchesIter( self.0.iter()) }
                }

                impl IntoIterator for SetMatches {
                    type IntoIter = SetMatchesIntoIter;
                    type Item = usize;

                    fn into_iter(self) -> Self::IntoIter {
                        let it = 0..self.0.capacity();
                        SetMatchesIntoIter { patset: self.0, it }
                    }
                }

                impl<'a> IntoIterator for &'a SetMatches {
                    type IntoIter = SetMatchesIter<'a>;
                    type Item = usize;

                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }

                
                #[derive( Debug )]
                pub struct SetMatchesIntoIter {
                    patset: PatternSet,
                    it: ::ops::Range<usize>,
                }

                impl Iterator for SetMatchesIntoIter {
                    type Item = usize;

                    fn next(&mut self) -> Option<usize> {
                        loop {
                            let id = self.it.next()?;
                            if self.patset.contains(PatternID::new_unchecked(id)) {
                                return Some(id);
                            }
                        }
                    }

                    fn size_hint( &self ) -> (usize, Option<usize>) { self.it.size_hint() }
                }

                impl DoubleEndedIterator for SetMatchesIntoIter
                {
                    fn next_back(&mut self) -> Option<usize> {
                        loop {
                            let id = self.it.next_back()?;
                            if self.patset.contains(PatternID::new_unchecked(id)) {
                                return Some(id);
                            }
                        }
                    }
                }

                impl ::iter::FusedIterator for SetMatchesIntoIter {}

                #[derive( Clone, Debug )]
                pub struct SetMatchesIter<'a>(PatternSetIter<'a>);

                impl<'a> Iterator for SetMatchesIter<'a> {
                    type Item = usize;

                    fn next(&mut self) -> Option<usize> { self.0.next().map(|pid| pid.as_usize()) }

                    fn size_hint( &self ) -> (usize, Option<usize>) { self.0.size_hint() }
                }

                impl<'a> DoubleEndedIterator for SetMatchesIter<'a>
                {
                    fn next_back(&mut self) -> Option<usize> { self.0.next_back().map(|pid| pid.as_usize()) }
                }

                impl<'a> ::iter::FusedIterator for SetMatchesIter<'a> {}

                impl ::fmt::Debug for RegexSet
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                    {
                        write!(f, "RegexSet({:?})", self.patterns())
                    }
                }
            }

            pub mod string
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use alloc::string::String;

                use regex_automata::{meta, Input, PatternID, PatternSet, PatternSetIter};

                use crate::{Error, RegexSetBuilder};
                */

                

                

                
                ///
                
                ///
                #[derive( Clone )]
                pub struct RegexSet {
                    pub meta: meta::Regex,
                    pub patterns: alloc::sync::Arc<[String]>,
                }

                impl RegexSet
                {
                    pub fn new<I, S>(exprs: I) -> Result<RegexSet, Error>
                    where
                        S: AsRef<str>,
                        I: IntoIterator<Item = S>,
                    {
                        RegexSetBuilder::new(exprs).build()
                    }
                    
                    pub fn empty() -> RegexSet {
                        let empty: [&str; 0] = [];
                        RegexSetBuilder::new(empty).build().unwrap()
                    }
                    
                    #[inline] pub fn is_match(&self, haystack: &str) -> bool {
                        self.is_match_at(haystack, 0)
                    }
                    
                    #[inline] pub fn is_match_at(&self, haystack: &str, start: usize) -> bool {
                        self.meta.is_match(Input::new(haystack).span(start..haystack.len()))
                    }

                    ///
                    #[inline] pub fn matches(&self, haystack: &str) -> SetMatches {
                        self.matches_at(haystack, 0)
                    }
                    
                    #[inline] pub fn matches_at(&self, haystack: &str, start: usize) -> SetMatches {
                        let input = Input::new(haystack).span(start..haystack.len());
                        let mut patset = PatternSet::new( self.meta.pattern_len());
                        self.meta.which_overlapping_matches(&input, &mut patset);
                        SetMatches(patset)
                    }
                    #[doc(hidden)]
                    #[inline] pub fn matches_read_at(
                        &self,
                        matches: &mut [bool],
                        haystack: &str,
                        start: usize,
                    ) -> bool {
                        // 'SetMatches', which is basically just a newtype around PatternSet.
                        let mut patset = PatternSet::new( self.meta.pattern_len());
                        let mut input = Input::new(haystack);
                        input.set_start(start);
                        self.meta.which_overlapping_matches(&input, &mut patset);
                        for pid in patset.iter() {
                            matches[pid] = true;
                        }
                        !patset.is_empty()
                    }
                    #[doc(hidden)]
                    #[inline] pub fn read_matches_at(
                        &self,
                        matches: &mut [bool],
                        haystack: &str,
                        start: usize,
                    ) -> bool {
                        self.matches_read_at(matches, haystack, start)
                    }
                    #[inline] pub fn len( &self ) -> usize { self.meta.pattern_len() }
                    
                    #[inline] pub fn is_empty( &self ) -> bool { self.meta.pattern_len() == 0 }
                    #[inline] pub fn patterns( &self ) -> &[String] { &self.patterns }
                }

                impl Default for RegexSet
                {
                    fn default() -> Self {
                        RegexSet::empty()
                    }
                }

                #[derive( Clone, Debug )]
                pub struct SetMatches(PatternSet);

                impl SetMatches {
                    #[inline] pub fn matched_any( &self ) -> bool { !self.0.is_empty() }
                    
                    pub fn matched_all( &self ) -> bool { self.0.is_full() }
                    #[inline] pub fn matched(&self, index: usize) -> bool {
                        self.0.contains(PatternID::new_unchecked(index))
                    }
                    
                    #[inline] pub fn len( &self ) -> usize { self.0.capacity() }
                    ///
                    ///
                    ///
                    #[inline] pub fn iter( &self ) -> SetMatchesIter<'_> { SetMatchesIter( self.0.iter()) }
                }

                impl IntoIterator for SetMatches {
                    type IntoIter = SetMatchesIntoIter;
                    type Item = usize;

                    fn into_iter(self) -> Self::IntoIter {
                        let it = 0..self.0.capacity();
                        SetMatchesIntoIter { patset: self.0, it }
                    }
                }

                impl<'a> IntoIterator for &'a SetMatches {
                    type IntoIter = SetMatchesIter<'a>;
                    type Item = usize;

                    fn into_iter(self) -> Self::IntoIter {
                        self.iter()
                    }
                }

                
                #[derive( Debug )]
                pub struct SetMatchesIntoIter {
                    patset: PatternSet,
                    it: ::ops::Range<usize>,
                }

                impl Iterator for SetMatchesIntoIter {
                    type Item = usize;

                    fn next(&mut self) -> Option<usize> {
                        loop {
                            let id = self.it.next()?;
                            if self.patset.contains(PatternID::new_unchecked(id)) {
                                return Some(id);
                            }
                        }
                    }

                    fn size_hint( &self ) -> (usize, Option<usize>) { self.it.size_hint() }
                }

                impl DoubleEndedIterator for SetMatchesIntoIter
                {
                    fn next_back(&mut self) -> Option<usize> {
                        loop {
                            let id = self.it.next_back()?;
                            if self.patset.contains(PatternID::new_unchecked(id)) {
                                return Some(id);
                            }
                        }
                    }
                }

                impl ::iter::FusedIterator for SetMatchesIntoIter {}

                #[derive( Clone, Debug )]
                pub struct SetMatchesIter<'a>(PatternSetIter<'a>);

                impl<'a> Iterator for SetMatchesIter<'a> {
                    type Item = usize;

                    fn next(&mut self) -> Option<usize> { self.0.next().map(|pid| pid.as_usize()) }

                    fn size_hint( &self ) -> (usize, Option<usize>) { self.0.size_hint() }
                }

                impl<'a> DoubleEndedIterator for SetMatchesIter<'a>
                {
                    fn next_back(&mut self) -> Option<usize> { self.0.next_back().map(|pid| pid.as_usize()) }
                }

                impl<'a> ::iter::FusedIterator for SetMatchesIter<'a> {}

                impl ::fmt::Debug for RegexSet
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
                    {
                        write!(f, "RegexSet({:?})", self.patterns())
                    }
                }
            }
        }
    } pub use self::expression::{ string::{ * }, set::string::{ * }, };

    pub mod syntax
    {
        /*!
        This crate provides a robust regular expression parser. */
        use ::
        {
            *,
        };
        /*
        pub use crate::
        {
            error::Error,
            parser::{parse, Parser, ParserBuilder},
            unicode::UnicodeWordError,
        };
        */    
        pub mod ast
        {
            /*!
            Defines an abstract syntax for regular expressions. */
            use ::
            {
                *,
            };
            /*
            use ::cmp::Ordering;
            use alloc::{boxed::Box, string::String, vec, vec::Vec};
            pub use crate::ast::visitor::{visit, Visitor};
            */
            pub mod parse
            {
                /*!
                Provides a regular expression parser. */
                use ::
                {
                    *,
                };
                /*
                use ::{
                    borrow::Borrow,
                    cell::{Cell, RefCell},
                    mem,
                };

                use alloc::{
                    boxed::Box,
                    string::{String, ToString},
                    vec,
                    vec::Vec,
                };

                use crate::{
                    ast::{self, Ast, Position, Span},
                    either::Either,
                    is_escapeable_character, is_meta_character,
                };
                */
                type Result<T> = ::result::Result<T, ast::Error>;
                #[derive( Clone, Debug, Eq, PartialEq )]
                enum Primitive {
                    Literal(ast::Literal),
                    Assertion(ast::Assertion),
                    Dot(Span),
                    Perl(ast::ClassPerl),
                    Unicode(ast::ClassUnicode),
                }

                impl Primitive {

                    fn span( &self ) -> &Span {
                        match *self {
                            Primitive::Literal(ref x) => &x.span,
                            Primitive::Assertion(ref x) => &x.span,
                            Primitive::Dot(ref span) => span,
                            Primitive::Perl(ref x) => &x.span,
                            Primitive::Unicode(ref x) => &x.span,
                        }
                    }

                    fn into_ast(self) -> Ast {
                        match self {
                            Primitive::Literal(lit) => Ast::literal(lit),
                            Primitive::Assertion(assert) => Ast::assertion(assert),
                            Primitive::Dot(span) => Ast::dot(span),
                            Primitive::Perl(cls) => Ast::class_perl(cls),
                            Primitive::Unicode(cls) => Ast::class_unicode(cls),
                        }
                    }
                    fn into_class_set_item<P: Borrow<Parser>>(
                        self,
                        p: &ParserI<'_, P>,
                    ) -> Result<ast::ClassSetItem> {
                        use self::Primitive::*;
                        use crate::ast::ClassSetItem;

                        match self {
                            Literal(lit) => Ok(ClassSetItem::Literal(lit)),
                            Perl(cls) => Ok(ClassSetItem::Perl(cls)),
                            Unicode(cls) => Ok(ClassSetItem::Unicode(cls)),
                            x => Err(p.error(*x.span(), ast::ErrorKind::ClassEscapeInvalid)),
                        }
                    }
                    fn into_class_literal<P: Borrow<Parser>>(
                        self,
                        p: &ParserI<'_, P>,
                    ) -> Result<ast::Literal> {
                        use self::Primitive::*;

                        match self {
                            Literal(lit) => Ok(lit),
                            x => Err(p.error(*x.span(), ast::ErrorKind::ClassRangeLiteral)),
                        }
                    }
                }

                fn is_hex(c: char) -> bool {
                    ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')
                }

                fn is_capture_char(c: char, first:bool ) -> bool {
                    if first {
                        c == '_' || c.is_alphabetic()
                    } else {
                        c == '_' || c == '.' || c == '[' || c == ']' || c.is_alphanumeric()
                    }
                }

                #[derive( Clone, Debug )]
                pub struct ParserBuilder {
                    ignore_whitespace: bool,
                    nest_limit: u32,
                    octal: bool,
                    empty_min_range: bool,
                }

                impl Default for ParserBuilder
                {
                    fn default() -> ParserBuilder {
                        ParserBuilder::new()
                    }
                }

                impl ParserBuilder
                {
                    pub fn new() -> ParserBuilder {
                        ParserBuilder {
                            ignore_whitespace: false,
                            nest_limit: 250,
                            octal: false,
                            empty_min_range: false,
                        }
                    }

                    pub fn build( &self ) -> Parser {
                        Parser {
                            pos: Cell::new(Position { offset: 0, line: 1, column: 1 }),
                            capture_index: Cell::new(0),
                            nest_limit: self.nest_limit,
                            octal: self.octal,
                            empty_min_range: self.empty_min_range,
                            initial_ignore_whitespace: self.ignore_whitespace,
                            ignore_whitespace: Cell::new( self.ignore_whitespace),
                            comments: RefCell::new(vec![]),
                            stack_group: RefCell::new(vec![]),
                            stack_class: RefCell::new(vec![]),
                            capture_names: RefCell::new(vec![]),
                            scratch: RefCell::new(String::new()),
                        }
                    }

                    pub fn nest_limit( &mut self, limit: u32) -> &mut ParserBuilder {
                        self.nest_limit = limit;
                        self
                    }

                    pub fn octal( &mut self, yes:bool ) -> &mut ParserBuilder {
                        self.octal = yes;
                        self
                    }
                    
                    pub fn ignore_whitespace( &mut self, yes:bool ) -> &mut ParserBuilder {
                        self.ignore_whitespace = yes;
                        self
                    }

                    pub fn empty_min_range( &mut self, yes:bool ) -> &mut ParserBuilder {
                        self.empty_min_range = yes;
                        self
                    }
                }

                #[derive( Clone, Debug )]
                pub struct Parser {

                    pos: Cell<Position>,
                    capture_index: Cell<u32>,
                    nest_limit: u32,
                    octal: bool,
                    initial_ignore_whitespace: bool,
                    empty_min_range: bool,
                    ignore_whitespace: Cell<bool>,
                    comments: RefCell<Vec<ast::Comment>>,
                    stack_group: RefCell<Vec<GroupState>>,
                    stack_class: RefCell<Vec<ClassState>>,
                    capture_names: RefCell<Vec<ast::CaptureName>>,
                    scratch: RefCell<String>,
                }

                #[derive( Clone, Debug )]
                struct ParserI<'s, P> {

                    parser: P,
                    pattern: &'s str,
                }
                
                #[derive( Clone, Debug )]
                enum GroupState {

                    Group {

                        concat: ast::Concat,
                        group: ast::Group,
                        ignore_whitespace: bool,
                    },
                    Alternation(ast::Alternation),
                }

                #[derive( Clone, Debug )]
                enum ClassState {

                    Open {

                        union: ast::ClassSetUnion,
                        set: ast::ClassBracketed,
                    },
                    Op {

                        kind: ast::ClassSetBinaryOpKind,
                        lhs: ast::ClassSet,
                    },
                }

                impl Parser
                {
                    pub fn new() -> Parser {
                        ParserBuilder::new().build()
                    }

                    pub fn parse( &mut self, pattern: &str) -> Result<Ast> { ParserI::new(self, pattern).parse() }
                    
                    pub fn parse_with_comments(
                        &mut self,
                        pattern: &str,
                    ) -> Result<ast::WithComments> { ParserI::new(self, pattern).parse_with_comments() }

                    fn reset( &self ) {
                        self.pos.set(Position { offset: 0, line: 1, column: 1 });
                        self.ignore_whitespace.set( self.initial_ignore_whitespace);
                        self.comments.borrow_mut().clear();
                        self.stack_group.borrow_mut().clear();
                        self.stack_class.borrow_mut().clear();
                    }
                }

                impl<'s, P: Borrow<Parser>> ParserI<'s, P> {

                    fn new(parser: P, pattern: &'s str) -> ParserI<'s, P> { ParserI { parser, pattern } }

                    fn parser( &self ) -> &Parser { self.parser.borrow() }

                    fn pattern( &self ) -> &str { self.pattern }

                    fn error(&self, span: Span, kind: ast::ErrorKind) -> ast::Error {
                        ast::Error { kind, pattern: self.pattern().to_string(), span }
                    }
                    fn offset( &self ) -> usize { self.parser().pos.get().offset }

                    fn line( &self ) -> usize { self.parser().pos.get().line }

                    fn column( &self ) -> usize { self.parser().pos.get().column }
                    fn next_capture_index(&self, span: Span) -> Result<u32>
                    {
                        let current = self.parser().capture_index.get();
                        let i = current.checked_add(1).ok_or_else(|| {
                            self.error(span, ast::ErrorKind::CaptureLimitExceeded)
                        })?;
                        self.parser().capture_index.set(i);
                        Ok(i)
                    }
                    fn add_capture_name(&self, cap: &ast::CaptureName) -> Result<()>
                    {
                        let mut names = self.parser().capture_names.borrow_mut();
                        match names
                            .binary_search_by_key(&cap.name.as_str(), |c| c.name.as_str())
                        {
                            Err(i) => {
                                names.insert(i, cap.clone());
                                Ok( () )
                            }
                            Ok(i) => Err( self.error(
                                cap.span,
                                ast::ErrorKind::GroupNameDuplicate { original: names[i].span },
                            )),
                        }
                    }

                    fn ignore_whitespace( &self ) -> bool { self.parser().ignore_whitespace.get() }

                    fn char( &self ) -> char { self.char_at( self.offset()) }

                    fn char_at(&self, i: usize) -> char {
                        self.pattern()[i..]
                            .chars()
                            .next()
                            .unwrap_or_else(|| panic!("expected char at offset {i}"))
                    }

                    fn bump( &self ) -> bool {
                        if self.is_eof() {
                            return false;
                        }
                        let Position { mut offset, mut line, mut column } = self.pos();
                        if self.char() == '\n' {
                            line = line.checked_add(1).unwrap();
                            column = 1;
                        } else {
                            column = column.checked_add(1).unwrap();
                        }
                        offset += self.char().len_utf8();
                        self.parser().pos.set(Position { offset, line, column });
                        self.pattern()[self.offset()..].chars().next().is_some()
                    }
                    fn bump_if(&self, prefix: &str) -> bool {
                        if self.pattern()[self.offset()..].starts_with(prefix) {
                            for _ in 0..prefix.chars().count() {
                                self.bump();
                            }
                            true
                        } else {
                            false
                        }
                    }
                    fn is_lookaround_prefix( &self ) -> bool {
                        self.bump_if("?=")
                            || self.bump_if("?!")
                            || self.bump_if("?<=")
                            || self.bump_if("?<!")
                    }
                    fn bump_and_bump_space( &self ) -> bool {
                        if !self.bump() {
                            return false;
                        }
                        self.bump_space();
                        !self.is_eof()
                    }
                    fn bump_space( &self ) {
                        if !self.ignore_whitespace() { return; }
                        while !self.is_eof() {
                            if self.char().is_whitespace() {
                                self.bump();
                            } else if self.char() == '#' {
                                let start = self.pos();
                                let mut comment_text = String::new();
                                self.bump();
                                while !self.is_eof() {
                                    let c = self.char();
                                    self.bump();
                                    if c == '\n' {
                                        break;
                                    }
                                    comment_text.push(c);
                                }
                                let comment = ast::Comment {
                                    span: Span::new(start, self.pos()),
                                    comment: comment_text,
                                };
                                self.parser().comments.borrow_mut().push(comment);
                            } else {
                                break;
                            }
                        }
                    }

                    fn peek( &self ) -> Option<char> {
                        if self.is_eof() {
                            return None;
                        }
                        self.pattern()[self.offset() + self.char().len_utf8()..].chars().next()
                    }
                    fn peek_space( &self ) -> Option<char> {
                        if !self.ignore_whitespace() {
                            return self.peek();
                        }
                        if self.is_eof() {
                            return None;
                        }
                        let mut start = self.offset() + self.char().len_utf8();
                        let mut in_comment = false;
                        for (i, c) in self.pattern()[start..].char_indices() {
                            if c.is_whitespace() {
                                continue;
                            } else if !in_comment && c == '#' {
                                in_comment = true;
                            } else if in_comment && c == '\n' {
                                in_comment = false;
                            } else {
                                start += i;
                                break;
                            }
                        }
                        self.pattern()[start..].chars().next()
                    }

                    fn is_eof( &self ) -> bool { self.offset() == self.pattern().len() }
                    fn pos( &self ) -> Position { self.parser().pos.get() }
                    fn span( &self ) -> Span { Span::splat( self.pos()) }

                    fn span_char( &self ) -> Span {
                        let mut next = Position {
                            offset: self.offset().checked_add( self.char().len_utf8()).unwrap(),
                            line: self.line(),
                            column: self.column().checked_add(1).unwrap(),
                        };
                        if self.char() == '\n' {
                            next.line += 1;
                            next.column = 1;
                        }
                        Span::new( self.pos(), next)
                    }

                    #[inline( never )] fn push_alternate(&self, mut concat: ast::Concat) -> Result<ast::Concat> {
                        assert_eq!( self.char(), '|');
                        concat.span.end = self.pos();
                        self.push_or_add_alternation(concat);
                        self.bump();
                        Ok(ast::Concat { span: self.span(), asts: vec![] })
                    }
                    fn push_or_add_alternation(&self, concat: ast::Concat) {
                        use self::GroupState::*;

                        let mut stack = self.parser().stack_group.borrow_mut();
                        if let Some(&mut Alternation(ref mut alts)) = stack.last_mut() {
                            alts.asts.push(concat.into_ast());
                            return;
                        }
                        stack.push(Alternation(ast::Alternation {
                            span: Span::new(concat.span.start, self.pos()),
                            asts: vec![concat.into_ast()],
                        }));
                    }

                    #[inline( never )] fn push_group(&self, mut concat: ast::Concat) -> Result<ast::Concat> {
                        assert_eq!( self.char(), '(');
                        match self.parse_group()? {
                            Either::Left(set) => {
                                let ignore = set.flags.flag_state(ast::Flag::IgnoreWhitespace);
                                if let Some(v) = ignore {
                                    self.parser().ignore_whitespace.set(v);
                                }

                                concat.asts.push(Ast::flags(set));
                                Ok(concat)
                            }
                            Either::Right(group) => {
                                let old_ignore_whitespace = self.ignore_whitespace();
                                let new_ignore_whitespace = group
                                    .flags()
                                    .and_then(|f| f.flag_state(ast::Flag::IgnoreWhitespace))
                                    .unwrap_or(old_ignore_whitespace);
                                self.parser().stack_group.borrow_mut().push(
                                    GroupState::Group {
                                        concat,
                                        group,
                                        ignore_whitespace: old_ignore_whitespace,
                                    },
                                );
                                self.parser().ignore_whitespace.set(new_ignore_whitespace);
                                Ok(ast::Concat { span: self.span(), asts: vec![] })
                            }
                        }
                    }

                    #[inline( never )] fn pop_group(&self, mut group_concat: ast::Concat) -> Result<ast::Concat> {
                        use self::GroupState::*;

                        assert_eq!( self.char(), ')');
                        let mut stack = self.parser().stack_group.borrow_mut();
                        let (mut prior_concat, mut group, ignore_whitespace, alt) = match stack
                            .pop()
                        {
                            Some(Group { concat, group, ignore_whitespace }) => { (concat, group, ignore_whitespace, None) }
                            Some(Alternation(alt)) => match stack.pop() {
                                Some(Group { concat, group, ignore_whitespace }) => { (concat, group, ignore_whitespace, Some(alt)) }
                                None | Some(Alternation(_)) => {
                                    return Err( self.error(
                                        self.span_char(),
                                        ast::ErrorKind::GroupUnopened,
                                    ));
                                }
                            },
                            None => {
                                return Err(self
                                    .error( self.span_char(), ast::ErrorKind::GroupUnopened));
                            }
                        };
                        self.parser().ignore_whitespace.set(ignore_whitespace);
                        group_concat.span.end = self.pos();
                        self.bump();
                        group.span.end = self.pos();
                        match alt {
                            Some(mut alt) => {
                                alt.span.end = group_concat.span.end;
                                alt.asts.push(group_concat.into_ast());
                                group.ast = Box::new(alt.into_ast());
                            }
                            None => { group.ast = Box::new(group_concat.into_ast()); }
                        }
                        prior_concat.asts.push(Ast::group(group));
                        Ok(prior_concat)
                    }

                    #[inline( never )] fn pop_group_end(&self, mut concat: ast::Concat) -> Result<Ast> {
                        concat.span.end = self.pos();
                        let mut stack = self.parser().stack_group.borrow_mut();
                        let ast = match stack.pop() {
                            None => Ok(concat.into_ast()),
                            Some(GroupState::Alternation(mut alt)) => {
                                alt.span.end = self.pos();
                                alt.asts.push(concat.into_ast());
                                Ok(Ast::alternation(alt))
                            }
                            Some(GroupState::Group { group, .. }) => {
                                return Err(
                                    self.error(group.span, ast::ErrorKind::GroupUnclosed)
                                );
                            }
                        };
                        match stack.pop() {
                            None => ast,
                            Some(GroupState::Alternation(_)) => { unreachable!() }
                            Some(GroupState::Group { group, .. }) => { Err( self.error(group.span, ast::ErrorKind::GroupUnclosed)) }
                        }
                    }

                    #[inline( never )] fn push_class_open(
                        &self,
                        parent_union: ast::ClassSetUnion,
                    ) -> Result<ast::ClassSetUnion> {
                        assert_eq!( self.char(), '[');

                        let (nested_set, nested_union) = self.parse_set_class_open()?;
                        self.parser()
                            .stack_class
                            .borrow_mut()
                            .push(ClassState::Open { union: parent_union, set: nested_set });
                        Ok(nested_union)
                    }

                    #[inline( never )] fn pop_class(
                        &self,
                        nested_union: ast::ClassSetUnion,
                    ) -> Result<Either<ast::ClassSetUnion, ast::ClassBracketed>> {
                        assert_eq!( self.char(), ']');

                        let item = ast::ClassSet::Item(nested_union.into_item());
                        let prevset = self.pop_class_op(item);
                        let mut stack = self.parser().stack_class.borrow_mut();
                        match stack.pop() {
                            None => {
                                // We can never observe an empty stack:
                                //
                                panic!("unexpected empty character class stack")
                            }
                            Some(ClassState::Op { .. }) => { panic!("unexpected ClassState::Op") }
                            Some(ClassState::Open { mut union, mut set }) => {
                                self.bump();
                                set.span.end = self.pos();
                                set.kind = prevset;
                                if stack.is_empty() {
                                    Ok(Either::Right(set))
                                } else {
                                    union.push(ast::ClassSetItem::Bracketed(Box::new(set)));
                                    Ok(Either::Left(union))
                                }
                            }
                        }
                    }

                    #[inline( never )] fn unclosed_class_error( &self ) -> ast::Error {
                        for state in self.parser().stack_class.borrow().iter().rev() {
                            if let ClassState::Open { ref set, .. } = *state {
                                return self.error(set.span, ast::ErrorKind::ClassUnclosed);
                            }
                        }
                        panic!("no open character class found")
                    }

                    #[inline( never )] fn push_class_op(
                        &self,
                        next_kind: ast::ClassSetBinaryOpKind,
                        next_union: ast::ClassSetUnion,
                    ) -> ast::ClassSetUnion {
                        let item = ast::ClassSet::Item(next_union.into_item());
                        let new_lhs = self.pop_class_op(item);
                        self.parser()
                            .stack_class
                            .borrow_mut()
                            .push(ClassState::Op { kind: next_kind, lhs: new_lhs });
                        ast::ClassSetUnion { span: self.span(), items: vec![] }
                    }

                    #[inline( never )] fn pop_class_op(&self, rhs: ast::ClassSet) -> ast::ClassSet {
                        let mut stack = self.parser().stack_class.borrow_mut();
                        let (kind, lhs) = match stack.pop() {
                            Some(ClassState::Op { kind, lhs }) => (kind, lhs),
                            Some(state @ ClassState::Open { .. }) => {
                                stack.push(state);
                                return rhs;
                            }
                            None => unreachable!(),
                        };
                        let span = Span::new(lhs.span().start, rhs.span().end);
                        ast::ClassSet::BinaryOp(ast::ClassSetBinaryOp {
                            span,
                            kind,
                            lhs: Box::new(lhs),
                            rhs: Box::new(rhs),
                        })
                    }
                }

                impl<'s, P: Borrow<Parser>> ParserI<'s, P> {

                    fn parse( &self ) -> Result<Ast> { self.parse_with_comments().map(|astc| astc.ast) }
                    fn parse_with_comments( &self ) -> Result<ast::WithComments> {
                        assert_eq!( self.offset(), 0, "parser can only be used once");
                        self.parser().reset();
                        let mut concat = ast::Concat { span: self.span(), asts: vec![] };
                        loop {
                            self.bump_space();
                            if self.is_eof() {
                                break;
                            }
                            match self.char() {
                                '(' => concat = self.push_group(concat)?,
                                ')' => concat = self.pop_group(concat)?,
                                '|' => concat = self.push_alternate(concat)?,
                                '[' => {
                                    let class = self.parse_set_class()?;
                                    concat.asts.push(Ast::class_bracketed(class));
                                }
                                '?' => {
                                    concat = self.parse_uncounted_repetition(
                                        concat,
                                        ast::RepetitionKind::ZeroOrOne,
                                    )?;
                                }
                                '*' => {
                                    concat = self.parse_uncounted_repetition(
                                        concat,
                                        ast::RepetitionKind::ZeroOrMore,
                                    )?;
                                }
                                '+' => {
                                    concat = self.parse_uncounted_repetition(
                                        concat,
                                        ast::RepetitionKind::OneOrMore,
                                    )?;
                                }
                                '{' => { concat = self.parse_counted_repetition(concat)?; }
                                _ => concat.asts.push( self.parse_primitive()?.into_ast()),
                            }
                        }
                        let ast = self.pop_group_end(concat)?;
                        NestLimiter::new(self).check(&ast)?;
                        Ok(ast::WithComments {
                            ast,
                            comments: mem::replace(
                                &mut *self.parser().comments.borrow_mut(),
                                vec![] ),
                        })
                    }

                    #[inline( never )] fn parse_uncounted_repetition(
                        &self,
                        mut concat: ast::Concat,
                        kind: ast::RepetitionKind,
                    ) -> Result<ast::Concat> {
                        assert!(
                            self.char() == '?' || self.char() == '*' || self.char() == '+'
                        );
                        let op_start = self.pos();
                        let ast = match concat.asts.pop() {
                            Some(ast) => ast,
                            None => {
                                return Err(
                                    self.error( self.span(), ast::ErrorKind::RepetitionMissing)
                                )
                            }
                        };
                        match ast {
                            Ast::Empty(_) | Ast::Flags(_) => {
                                return Err(
                                    self.error( self.span(), ast::ErrorKind::RepetitionMissing)
                                )
                            }
                            _ => {}
                        }
                        let mut greedy = true;
                        if self.bump() && self.char() == '?' {
                            greedy = false;
                            self.bump();
                        }
                        concat.asts.push(Ast::repetition(ast::Repetition {
                            span: ast.span().with_end( self.pos()),
                            op: ast::RepetitionOp {
                                span: Span::new(op_start, self.pos()),
                                kind,
                            },
                            greedy,
                            ast: Box::new(ast),
                        }));
                        Ok(concat)
                    }

                    #[inline( never )] fn parse_counted_repetition(
                        &self,
                        mut concat: ast::Concat,
                    ) -> Result<ast::Concat> {
                        assert!( self.char() == '{');
                        let start = self.pos();
                        let ast = match concat.asts.pop() {
                            Some(ast) => ast,
                            None => {
                                return Err(
                                    self.error( self.span(), ast::ErrorKind::RepetitionMissing)
                                )
                            }
                        };
                        match ast {
                            Ast::Empty(_) | Ast::Flags(_) => {
                                return Err(
                                    self.error( self.span(), ast::ErrorKind::RepetitionMissing)
                                )
                            }
                            _ => {}
                        }
                        if !self.bump_and_bump_space() {
                            return Err( self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::RepetitionCountUnclosed,
                            ));
                        }
                        let count_start = specialize_err(
                            self.parse_decimal(),
                            ast::ErrorKind::DecimalEmpty,
                            ast::ErrorKind::RepetitionCountDecimalEmpty,
                        );
                        if self.is_eof() {
                            return Err( self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::RepetitionCountUnclosed,
                            ));
                        }
                        let range = if self.char() == ',' {
                            if !self.bump_and_bump_space() {
                                return Err( self.error(
                                    Span::new(start, self.pos()),
                                    ast::ErrorKind::RepetitionCountUnclosed,
                                ));
                            }
                            if self.char() != '}' {
                                let count_start = match count_start {
                                    Ok(c) => c,
                                    Err(err)
                                        if err.kind
                                            == ast::ErrorKind::RepetitionCountDecimalEmpty =>
                                    {
                                        if self.parser().empty_min_range {
                                            0
                                        } else {
                                            return Err(err);
                                        }
                                    }
                                    err => err?,
                                };
                                let count_end = specialize_err(
                                    self.parse_decimal(),
                                    ast::ErrorKind::DecimalEmpty,
                                    ast::ErrorKind::RepetitionCountDecimalEmpty,
                                )?;
                                ast::RepetitionRange::Bounded(count_start, count_end)
                            } else {
                                ast::RepetitionRange::AtLeast(count_start?)
                            }
                        } else {
                            ast::RepetitionRange::Exactly(count_start?)
                        };

                        if self.is_eof() || self.char() != '}' {
                            return Err( self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::RepetitionCountUnclosed,
                            ));
                        }

                        let mut greedy = true;
                        if self.bump_and_bump_space() && self.char() == '?' {
                            greedy = false;
                            self.bump();
                        }

                        let op_span = Span::new(start, self.pos());
                        if !range.is_valid() {
                            return Err(
                                self.error(op_span, ast::ErrorKind::RepetitionCountInvalid)
                            );
                        }
                        concat.asts.push(Ast::repetition(ast::Repetition {
                            span: ast.span().with_end( self.pos()),
                            op: ast::RepetitionOp {
                                span: op_span,
                                kind: ast::RepetitionKind::Range(range),
                            },
                            greedy,
                            ast: Box::new(ast),
                        }));
                        Ok(concat)
                    }

                    #[inline( never )] fn parse_group( &self ) -> Result<Either<ast::SetFlags, ast::Group>> {
                        assert_eq!( self.char(), '(');
                        let open_span = self.span_char();
                        self.bump();
                        self.bump_space();
                        if self.is_lookaround_prefix() {
                            return Err( self.error(
                                Span::new(open_span.start, self.span().end),
                                ast::ErrorKind::UnsupportedLookAround,
                            ));
                        }
                        let inner_span = self.span();
                        let mut starts_with_p = true;
                        if self.bump_if("?P<") || {
                            starts_with_p = false;
                            self.bump_if("?<")
                        } {
                            let capture_index = self.next_capture_index(open_span)?;
                            let name = self.parse_capture_name(capture_index)?;
                            Ok(Either::Right(ast::Group {
                                span: open_span,
                                kind: ast::GroupKind::CaptureName { starts_with_p, name },
                                ast: Box::new(Ast::empty( self.span())),
                            }))
                        } else if self.bump_if("?") {
                            if self.is_eof() {
                                return Err(
                                    self.error(open_span, ast::ErrorKind::GroupUnclosed)
                                );
                            }
                            let flags = self.parse_flags()?;
                            let char_end = self.char();
                            self.bump();
                            if char_end == ')' {
                                if flags.items.is_empty() {
                                    return Err( self.error(
                                        inner_span,
                                        ast::ErrorKind::RepetitionMissing,
                                    ));
                                }
                                Ok(Either::Left(ast::SetFlags {
                                    span: Span { end: self.pos(), ..open_span },
                                    flags,
                                }))
                            } else {
                                assert_eq!(char_end, ':');
                                Ok(Either::Right(ast::Group {
                                    span: open_span,
                                    kind: ast::GroupKind::NonCapturing(flags),
                                    ast: Box::new(Ast::empty( self.span())),
                                }))
                            }
                        } else {
                            let capture_index = self.next_capture_index(open_span)?;
                            Ok(Either::Right(ast::Group {
                                span: open_span,
                                kind: ast::GroupKind::CaptureIndex(capture_index),
                                ast: Box::new(Ast::empty( self.span())),
                            }))
                        }
                    }

                    #[inline( never )] fn parse_capture_name(
                        &self,
                        capture_index: u32,
                    ) -> Result<ast::CaptureName> {
                        if self.is_eof() {
                            return Err(self
                                .error( self.span(), ast::ErrorKind::GroupNameUnexpectedEof));
                        }
                        let start = self.pos();
                        loop {
                            if self.char() == '>' {
                                break;
                            }
                            if !is_capture_char( self.char(), self.pos() == start) {
                                return Err( self.error(
                                    self.span_char(),
                                    ast::ErrorKind::GroupNameInvalid,
                                ));
                            }
                            if !self.bump() {
                                break;
                            }
                        }
                        let end = self.pos();
                        if self.is_eof() {
                            return Err(self
                                .error( self.span(), ast::ErrorKind::GroupNameUnexpectedEof));
                        }
                        assert_eq!( self.char(), '>');
                        self.bump();
                        let name = &self.pattern()[start.offset..end.offset];
                        if name.is_empty() {
                            return Err( self.error(
                                Span::new(start, start),
                                ast::ErrorKind::GroupNameEmpty,
                            ));
                        }
                        let capname = ast::CaptureName {
                            span: Span::new(start, end),
                            name: name.to_string(),
                            index: capture_index,
                        };
                        self.add_capture_name(&capname)?;
                        Ok(capname)
                    }

                    #[inline( never )] fn parse_flags( &self ) -> Result<ast::Flags>
                    {
                        let mut flags = ast::Flags { span: self.span(), items: vec![] };
                        let mut last_was_negation = None;
                        while self.char() != ':' && self.char() != ')' {
                            if self.char() == '-' {
                                last_was_negation = Some( self.span_char());
                                let item = ast::FlagsItem {
                                    span: self.span_char(),
                                    kind: ast::FlagsItemKind::Negation,
                                };
                                if let Some(i) = flags.add_item(item) {
                                    return Err( self.error(
                                        self.span_char(),
                                        ast::ErrorKind::FlagRepeatedNegation {
                                            original: flags.items[i].span,
                                        },
                                    ));
                                }
                            } else {
                                last_was_negation = None;
                                let item = ast::FlagsItem {
                                    span: self.span_char(),
                                    kind: ast::FlagsItemKind::Flag( self.parse_flag()?),
                                };
                                if let Some(i) = flags.add_item(item) {
                                    return Err( self.error(
                                        self.span_char(),
                                        ast::ErrorKind::FlagDuplicate {
                                            original: flags.items[i].span,
                                        },
                                    ));
                                }
                            }
                            if !self.bump() {
                                return Err(
                                    self.error( self.span(), ast::ErrorKind::FlagUnexpectedEof)
                                );
                            }
                        }
                        if let Some(span) = last_was_negation {
                            return Err( self.error(span, ast::ErrorKind::FlagDanglingNegation));
                        }
                        flags.span.end = self.pos();
                        Ok(flags)
                    }

                    #[inline( never )] fn parse_flag( &self ) -> Result<ast::Flag> {
                        match self.char() {
                            'i' => Ok(ast::Flag::CaseInsensitive),
                            'm' => Ok(ast::Flag::MultiLine),
                            's' => Ok(ast::Flag::DotMatchesNewLine),
                            'U' => Ok(ast::Flag::SwapGreed),
                            'u' => Ok(ast::Flag::Unicode),
                            'R' => Ok(ast::Flag::CRLF),
                            'x' => Ok(ast::Flag::IgnoreWhitespace),
                            _ => {
                                Err(self
                                    .error( self.span_char(), ast::ErrorKind::FlagUnrecognized))
                            }
                        }
                    }

                    fn parse_primitive( &self ) -> Result<Primitive> {
                        match self.char() {
                            '\\' => self.parse_escape(),
                            '.' => {
                                let ast = Primitive::Dot( self.span_char());
                                self.bump();
                                Ok(ast)
                            }
                            '^' => {
                                let ast = Primitive::Assertion(ast::Assertion {
                                    span: self.span_char(),
                                    kind: ast::AssertionKind::StartLine,
                                });
                                self.bump();
                                Ok(ast)
                            }
                            '$' => {
                                let ast = Primitive::Assertion(ast::Assertion {
                                    span: self.span_char(),
                                    kind: ast::AssertionKind::EndLine,
                                });
                                self.bump();
                                Ok(ast)
                            }
                            c => {
                                let ast = Primitive::Literal(ast::Literal {
                                    span: self.span_char(),
                                    kind: ast::LiteralKind::Verbatim,
                                    c,
                                });
                                self.bump();
                                Ok(ast)
                            }
                        }
                    }

                    #[inline( never )] fn parse_escape( &self ) -> Result<Primitive> {
                        assert_eq!( self.char(), '\\');
                        let start = self.pos();
                        if !self.bump() {
                            return Err( self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::EscapeUnexpectedEof,
                            ));
                        }
                        let c = self.char();
                        match c {
                            '0'..='7' => {
                                if !self.parser().octal {
                                    return Err( self.error(
                                        Span::new(start, self.span_char().end),
                                        ast::ErrorKind::UnsupportedBackreference,
                                    ));
                                }
                                let mut lit = self.parse_octal();
                                lit.span.start = start;
                                return Ok(Primitive::Literal(lit));
                            }
                            '8'..='9' if !self.parser().octal => {
                                return Err( self.error(
                                    Span::new(start, self.span_char().end),
                                    ast::ErrorKind::UnsupportedBackreference,
                                ));
                            }
                            'x' | 'u' | 'U' => {
                                let mut lit = self.parse_hex()?;
                                lit.span.start = start;
                                return Ok(Primitive::Literal(lit));
                            }
                            'p' | 'P' => {
                                let mut cls = self.parse_unicode_class()?;
                                cls.span.start = start;
                                return Ok(Primitive::Unicode(cls));
                            }
                            'd' | 's' | 'w' | 'D' | 'S' | 'W' => {
                                let mut cls = self.parse_perl_class();
                                cls.span.start = start;
                                return Ok(Primitive::Perl(cls));
                            }
                            _ => {}
                        }
                        
                        self.bump();
                        let span = Span::new(start, self.pos());
                        if is_meta_character(c) {
                            return Ok(Primitive::Literal(ast::Literal {
                                span,
                                kind: ast::LiteralKind::Meta,
                                c,
                            }));
                        }
                        if is_escapeable_character(c) {
                            return Ok(Primitive::Literal(ast::Literal {
                                span,
                                kind: ast::LiteralKind::Superfluous,
                                c,
                            }));
                        }
                        let special = |kind, c| {
                            Ok(Primitive::Literal(ast::Literal {
                                span,
                                kind: ast::LiteralKind::Special(kind),
                                c,
                            }))
                        };
                        match c {
                            'a' => special(ast::SpecialLiteralKind::Bell, '\x07'),
                            'f' => special(ast::SpecialLiteralKind::FormFeed, '\x0C'),
                            't' => special(ast::SpecialLiteralKind::Tab, '\t'),
                            'n' => special(ast::SpecialLiteralKind::LineFeed, '\n'),
                            'r' => special(ast::SpecialLiteralKind::CarriageReturn, '\r'),
                            'v' => special(ast::SpecialLiteralKind::VerticalTab, '\x0B'),
                            'A' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::StartText,
                            })),
                            'z' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::EndText,
                            })),
                            'b' => {
                                let mut wb = ast::Assertion {
                                    span,
                                    kind: ast::AssertionKind::WordBoundary,
                                };
                                if !self.is_eof() && self.char() == '{' {
                                    if let Some(kind) =
                                        self.maybe_parse_special_word_boundary(start)?
                                    {
                                        wb.kind = kind;
                                        wb.span.end = self.pos();
                                    }
                                }
                                Ok(Primitive::Assertion(wb))
                            }
                            'B' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::NotWordBoundary,
                            })),
                            '<' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::WordBoundaryStartAngle,
                            })),
                            '>' => Ok(Primitive::Assertion(ast::Assertion {
                                span,
                                kind: ast::AssertionKind::WordBoundaryEndAngle,
                            })),
                            _ => Err( self.error(span, ast::ErrorKind::EscapeUnrecognized)),
                        }
                    }
                    fn maybe_parse_special_word_boundary(
                        &self,
                        wb_start: Position,
                    ) -> Result<Option<ast::AssertionKind>> {
                        assert_eq!( self.char(), '{');

                        let is_valid_char = |c| match c {
                            'A'..='Z' | 'a'..='z' | '-' => true,
                            _ => false,
                        };
                        let start = self.pos();
                        if !self.bump_and_bump_space() {
                            return Err( self.error(
                                Span::new(wb_start, self.pos()),
                                ast::ErrorKind::SpecialWordOrRepetitionUnexpectedEof,
                            ));
                        }
                        let start_contents = self.pos();
                        if !is_valid_char( self.char()) {
                            self.parser().pos.set(start);
                            return Ok( None );
                        }

                        // Now collect up our chars until we see a '}'.
                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();
                        while !self.is_eof() && is_valid_char( self.char()) {
                            scratch.push( self.char());
                            self.bump_and_bump_space();
                        }
                        if self.is_eof() || self.char() != '}' {
                            return Err( self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::SpecialWordBoundaryUnclosed,
                            ));
                        }
                        let end = self.pos();
                        self.bump();
                        let kind = match scratch.as_str() {
                            "start" => ast::AssertionKind::WordBoundaryStart,
                            "end" => ast::AssertionKind::WordBoundaryEnd,
                            "start-half" => ast::AssertionKind::WordBoundaryStartHalf,
                            "end-half" => ast::AssertionKind::WordBoundaryEndHalf,
                            _ => {
                                return Err( self.error(
                                    Span::new(start_contents, end),
                                    ast::ErrorKind::SpecialWordBoundaryUnrecognized,
                                ))
                            }
                        };
                        Ok(Some(kind))
                    }

                    #[inline( never )] fn parse_octal( &self ) -> ast::Literal {
                        assert!( self.parser().octal);
                        assert!('0' <= self.char() && self.char() <= '7');
                        let start = self.pos();
                        while self.bump()
                            && '0' <= self.char()
                            && self.char() <= '7'
                            && self.pos().offset - start.offset <= 2
                        {}
                        let end = self.pos();
                        let octal = &self.pattern()[start.offset..end.offset];
                        let codepoint =
                            u32::from_str_radix(octal, 8).expect("valid octal number");
                        let c = char::from_u32(codepoint).expect("Unicode scalar value");
                        ast::Literal {
                            span: Span::new(start, end),
                            kind: ast::LiteralKind::Octal,
                            c,
                        }
                    }

                    #[inline( never )] fn parse_hex( &self ) -> Result<ast::Literal> {
                        assert!(
                            self.char() == 'x' || self.char() == 'u' || self.char() == 'U'
                        );

                        let hex_kind = match self.char() {
                            'x' => ast::HexLiteralKind::X,
                            'u' => ast::HexLiteralKind::UnicodeShort,
                            _ => ast::HexLiteralKind::UnicodeLong,
                        };
                        if !self.bump_and_bump_space() {
                            return Err(
                                self.error( self.span(), ast::ErrorKind::EscapeUnexpectedEof)
                            );
                        }
                        if self.char() == '{' {
                            self.parse_hex_brace(hex_kind)
                        } else {
                            self.parse_hex_digits(hex_kind)
                        }
                    }

                    #[inline( never )] fn parse_hex_digits(
                        &self,
                        kind: ast::HexLiteralKind,
                    ) -> Result<ast::Literal>
                    {
                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();

                        let start = self.pos();
                        for i in 0..kind.digits() {
                            if i > 0 && !self.bump_and_bump_space() {
                                return Err(self
                                    .error( self.span(), ast::ErrorKind::EscapeUnexpectedEof));
                            }
                            if !is_hex( self.char()) {
                                return Err( self.error(
                                    self.span_char(),
                                    ast::ErrorKind::EscapeHexInvalidDigit,
                                ));
                            }
                            scratch.push( self.char());
                        }
                        self.bump_and_bump_space();
                        let end = self.pos();
                        let hex = scratch.as_str();
                        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {
                            None => Err( self.error(
                                Span::new(start, end),
                                ast::ErrorKind::EscapeHexInvalid,
                            )),
                            Some(c) => Ok(ast::Literal {
                                span: Span::new(start, end),
                                kind: ast::LiteralKind::HexFixed(kind),
                                c,
                            }),
                        }
                    }

                    #[inline( never )] fn parse_hex_brace(
                        &self,
                        kind: ast::HexLiteralKind,
                    ) -> Result<ast::Literal>
                    {
                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();

                        let brace_pos = self.pos();
                        let start = self.span_char().end;
                        while self.bump_and_bump_space() && self.char() != '}' {
                            if !is_hex( self.char()) {
                                return Err( self.error(
                                    self.span_char(),
                                    ast::ErrorKind::EscapeHexInvalidDigit,
                                ));
                            }
                            scratch.push( self.char());
                        }
                        if self.is_eof() {
                            return Err( self.error(
                                Span::new(brace_pos, self.pos()),
                                ast::ErrorKind::EscapeUnexpectedEof,
                            ));
                        }
                        let end = self.pos();
                        let hex = scratch.as_str();
                        assert_eq!( self.char(), '}');
                        self.bump_and_bump_space();

                        if hex.is_empty() {
                            return Err( self.error(
                                Span::new(brace_pos, self.pos()),
                                ast::ErrorKind::EscapeHexEmpty,
                            ));
                        }
                        match u32::from_str_radix(hex, 16).ok().and_then(char::from_u32) {
                            None => Err( self.error(
                                Span::new(start, end),
                                ast::ErrorKind::EscapeHexInvalid,
                            )),
                            Some(c) => Ok(ast::Literal {
                                span: Span::new(start, self.pos()),
                                kind: ast::LiteralKind::HexBrace(kind),
                                c,
                            }),
                        }
                    }
                    fn parse_decimal( &self ) -> Result<u32>
                    {
                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();

                        while !self.is_eof() && self.char().is_whitespace() {
                            self.bump();
                        }
                        let start = self.pos();
                        while !self.is_eof() && '0' <= self.char() && self.char() <= '9' {
                            scratch.push( self.char());
                            self.bump_and_bump_space();
                        }
                        let span = Span::new(start, self.pos());
                        while !self.is_eof() && self.char().is_whitespace() {
                            self.bump_and_bump_space();
                        }
                        let digits = scratch.as_str();
                        if digits.is_empty() {
                            return Err( self.error(span, ast::ErrorKind::DecimalEmpty));
                        }
                        match u32::from_str_radix(digits, 10).ok() {
                            Some(n) => Ok(n),
                            None => Err( self.error(span, ast::ErrorKind::DecimalInvalid)),
                        }
                    }

                    #[inline( never )] fn parse_set_class( &self ) -> Result<ast::ClassBracketed> {
                        assert_eq!( self.char(), '[');

                        let mut union =
                            ast::ClassSetUnion { span: self.span(), items: vec![] };
                        loop {
                            self.bump_space();
                            if self.is_eof() {
                                return Err( self.unclosed_class_error());
                            }
                            match self.char() {
                                '[' => {
                                    if !self.parser().stack_class.borrow().is_empty() {
                                        if let Some(cls) = self.maybe_parse_ascii_class() {
                                            union.push(ast::ClassSetItem::Ascii(cls));
                                            continue;
                                        }
                                    }
                                    union = self.push_class_open(union)?;
                                }
                                ']' => match self.pop_class(union)? {
                                    Either::Left(nested_union) => { union = nested_union; }
                                    Either::Right(class) => return Ok(class),
                                },
                                '&' if self.peek() == Some('&') => {
                                    assert!( self.bump_if("&&"));
                                    union = self.push_class_op(
                                        ast::ClassSetBinaryOpKind::Intersection,
                                        union,
                                    );
                                }
                                '-' if self.peek() == Some('-') => {
                                    assert!( self.bump_if("--"));
                                    union = self.push_class_op(
                                        ast::ClassSetBinaryOpKind::Difference,
                                        union,
                                    );
                                }
                                '~' if self.peek() == Some('~') => {
                                    assert!( self.bump_if("~~"));
                                    union = self.push_class_op(
                                        ast::ClassSetBinaryOpKind::SymmetricDifference,
                                        union,
                                    );
                                }
                                _ => { union.push( self.parse_set_class_range()?); }
                            }
                        }
                    }

                    #[inline( never )] fn parse_set_class_range( &self ) -> Result<ast::ClassSetItem>
                    {
                        let prim1 = self.parse_set_class_item()?;
                        self.bump_space();
                        if self.is_eof() {
                            return Err( self.unclosed_class_error());
                        }

                        if self.char() != '-'
                            || self.peek_space() == Some(']')
                            || self.peek_space() == Some('-')
                        {
                            return prim1.into_class_set_item(self);
                        }
                        if !self.bump_and_bump_space() {
                            return Err( self.unclosed_class_error());
                        }
                        let prim2 = self.parse_set_class_item()?;
                        let range = ast::ClassSetRange {
                            span: Span::new(prim1.span().start, prim2.span().end),
                            start: prim1.into_class_literal(self)?,
                            end: prim2.into_class_literal(self)?,
                        };
                        if !range.is_valid() {
                            return Err(
                                self.error(range.span, ast::ErrorKind::ClassRangeInvalid)
                            );
                        }
                        Ok(ast::ClassSetItem::Range(range))
                    }

                    #[inline( never )] fn parse_set_class_item( &self ) -> Result<Primitive> {
                        if self.char() == '\\' {
                            self.parse_escape()
                        } else {
                            let x = Primitive::Literal(ast::Literal {
                                span: self.span_char(),
                                kind: ast::LiteralKind::Verbatim,
                                c: self.char(),
                            });
                            self.bump();
                            Ok(x)
                        }
                    }

                    #[inline( never )] fn parse_set_class_open(
                        &self,
                    ) -> Result<(ast::ClassBracketed, ast::ClassSetUnion)> {
                        assert_eq!( self.char(), '[');
                        let start = self.pos();
                        if !self.bump_and_bump_space() {
                            return Err( self.error(
                                Span::new(start, self.pos()),
                                ast::ErrorKind::ClassUnclosed,
                            ));
                        }

                        let negated = if self.char() != '^' {
                            false
                        } else {
                            if !self.bump_and_bump_space() {
                                return Err( self.error(
                                    Span::new(start, self.pos()),
                                    ast::ErrorKind::ClassUnclosed,
                                ));
                            }
                            true
                        };
                        
                        let mut union =
                            ast::ClassSetUnion { span: self.span(), items: vec![] };
                        while self.char() == '-' {
                            union.push(ast::ClassSetItem::Literal(ast::Literal {
                                span: self.span_char(),
                                kind: ast::LiteralKind::Verbatim,
                                c: '-',
                            }));
                            if !self.bump_and_bump_space() {
                                return Err( self.error(
                                    Span::new(start, start),
                                    ast::ErrorKind::ClassUnclosed,
                                ));
                            }
                        }
                        if union.items.is_empty() && self.char() == ']' {
                            union.push(ast::ClassSetItem::Literal(ast::Literal {
                                span: self.span_char(),
                                kind: ast::LiteralKind::Verbatim,
                                c: ']',
                            }));
                            if !self.bump_and_bump_space() {
                                return Err( self.error(
                                    Span::new(start, self.pos()),
                                    ast::ErrorKind::ClassUnclosed,
                                ));
                            }
                        }
                        let set = ast::ClassBracketed {
                            span: Span::new(start, self.pos()),
                            negated,
                            kind: ast::ClassSet::union(ast::ClassSetUnion {
                                span: Span::new(union.span.start, union.span.start),
                                items: vec![],
                            }),
                        };
                        Ok((set, union))
                    }

                    #[inline( never )] fn maybe_parse_ascii_class( &self ) -> Option<ast::ClassAscii> 
                    {
                        assert_eq!( self.char(), '[');
                        
                        let start = self.pos();
                        let mut negated = false;
                        if !self.bump() || self.char() != ':' {
                            self.parser().pos.set(start);
                            return None;
                        }
                        if !self.bump() {
                            self.parser().pos.set(start);
                            return None;
                        }
                        if self.char() == '^' {
                            negated = true;
                            if !self.bump() {
                                self.parser().pos.set(start);
                                return None;
                            }
                        }
                        let name_start = self.offset();
                        while self.char() != ':' && self.bump() {}
                        if self.is_eof() {
                            self.parser().pos.set(start);
                            return None;
                        }
                        let name = &self.pattern()[name_start..self.offset()];
                        if !self.bump_if(":]") {
                            self.parser().pos.set(start);
                            return None;
                        }
                        let kind = match ast::ClassAsciiKind::from_name(name) {
                            Some(kind) => kind,
                            None => {
                                self.parser().pos.set(start);
                                return None;
                            }
                        };
                        
                        Some(ast::ClassAscii {
                            span: Span::new(start, self.pos()),
                            kind,
                            negated,
                        })
                    }

                    #[inline( never )] fn parse_unicode_class( &self ) -> Result<ast::ClassUnicode> 
                    {
                        assert!( self.char() == 'p' || self.char() == 'P');

                        let mut scratch = self.parser().scratch.borrow_mut();
                        scratch.clear();

                        let negated = self.char() == 'P';
                        if !self.bump_and_bump_space() {
                            return Err(
                                self.error( self.span(), ast::ErrorKind::EscapeUnexpectedEof)
                            );
                        }
                        let (start, kind) = if self.char() == '{' {
                            let start = self.span_char().end;
                            while self.bump_and_bump_space() && self.char() != '}' {
                                scratch.push( self.char());
                            }
                            if self.is_eof() {
                                return Err(self
                                    .error( self.span(), ast::ErrorKind::EscapeUnexpectedEof));
                            }
                            assert_eq!( self.char(), '}');
                            self.bump();

                            let name = scratch.as_str();
                            if let Some(i) = name.find("!=") {
                                (
                                    start,
                                    ast::ClassUnicodeKind::NamedValue {
                                        op: ast::ClassUnicodeOpKind::NotEqual,
                                        name: name[..i].to_string(),
                                        value: name[i + 2..].to_string(),
                                    },
                                )
                            } else if let Some(i) = name.find(':') {
                                (
                                    start,
                                    ast::ClassUnicodeKind::NamedValue {
                                        op: ast::ClassUnicodeOpKind::Colon,
                                        name: name[..i].to_string(),
                                        value: name[i + 1..].to_string(),
                                    },
                                )
                            } else if let Some(i) = name.find('=') {
                                (
                                    start,
                                    ast::ClassUnicodeKind::NamedValue {
                                        op: ast::ClassUnicodeOpKind::Equal,
                                        name: name[..i].to_string(),
                                        value: name[i + 1..].to_string(),
                                    },
                                )
                            } else {
                                (start, ast::ClassUnicodeKind::Named(name.to_string()))
                            }
                        } else {
                            let start = self.pos();
                            let c = self.char();
                            if c == '\\' {
                                return Err( self.error(
                                    self.span_char(),
                                    ast::ErrorKind::UnicodeClassInvalid,
                                ));
                            }
                            self.bump_and_bump_space();
                            let kind = ast::ClassUnicodeKind::OneLetter(c);
                            (start, kind)
                        };
                        Ok(ast::ClassUnicode {
                            span: Span::new(start, self.pos()),
                            negated,
                            kind,
                        })
                    }

                    #[inline( never )] fn parse_perl_class( &self ) -> ast::ClassPerl {
                        let c = self.char();
                        let span = self.span_char();
                        self.bump();
                        let (negated, kind) = match c {
                            'd' => (false, ast::ClassPerlKind::Digit),
                            'D' => (true, ast::ClassPerlKind::Digit),
                            's' => (false, ast::ClassPerlKind::Space),
                            'S' => (true, ast::ClassPerlKind::Space),
                            'w' => (false, ast::ClassPerlKind::Word),
                            'W' => (true, ast::ClassPerlKind::Word),
                            c => panic!("expected valid Perl class but got '{c}'"),
                        };
                        ast::ClassPerl { span, kind, negated }
                    }
                }
                
                #[derive( Debug )]
                struct NestLimiter<'p, 's, P> {

                    p: &'p ParserI<'s, P>,
                    depth: u32,
                }

                impl<'p, 's, P: Borrow<Parser>> NestLimiter<'p, 's, P>               
                {
                    fn new(p: &'p ParserI<'s, P>) -> NestLimiter<'p, 's, P> { NestLimiter { p, depth: 0 } }

                    #[inline( never )] fn check(self, ast: &Ast) -> Result<()> { ast::visit(ast, self) }

                    fn increment_depth( &mut self, span: &Span) -> Result<()>
                    {
                        let new = self.depth.checked_add(1).ok_or_else(|| {
                            self.p.error(
                                span.clone(),
                                ast::ErrorKind::NestLimitExceeded(u32::MAX),
                            )
                        })?;
                        let limit = self.p.parser().nest_limit;
                        if new > limit {
                            return Err( self.p.error(
                                span.clone(),
                                ast::ErrorKind::NestLimitExceeded(limit),
                            ));
                        }
                        self.depth = new;
                        Ok( () )
                    }

                    fn decrement_depth(&mut self) {
                        self.depth = self.depth.checked_sub(1).unwrap();
                    }
                }

                impl<'p, 's, P: Borrow<Parser>> ast::Visitor for NestLimiter<'p, 's, P> {
                    type Output = ();
                    type Err = ast::Error;

                    fn finish(self) -> Result<()> { Ok( () ) }

                    fn visit_pre( &mut self, ast: &Ast) -> Result<()>
                    {
                        let span = match *ast {
                            Ast::Empty(_)
                            | Ast::Flags(_)
                            | Ast::Literal(_)
                            | Ast::Dot(_)
                            | Ast::Assertion(_)
                            | Ast::ClassUnicode(_)
                            | Ast::ClassPerl(_) => { return Ok( () ); }
                            Ast::ClassBracketed(ref x) => &x.span,
                            Ast::Repetition(ref x) => &x.span,
                            Ast::Group(ref x) => &x.span,
                            Ast::Alternation(ref x) => &x.span,
                            Ast::Concat(ref x) => &x.span,
                        };
                        self.increment_depth(span)
                    }

                    fn visit_post( &mut self, ast: &Ast) -> Result<()> {
                        match *ast {
                            Ast::Empty(_)
                            | Ast::Flags(_)
                            | Ast::Literal(_)
                            | Ast::Dot(_)
                            | Ast::Assertion(_)
                            | Ast::ClassUnicode(_)
                            | Ast::ClassPerl(_) => { Ok( () ) }
                            Ast::ClassBracketed(_)
                            | Ast::Repetition(_)
                            | Ast::Group(_)
                            | Ast::Alternation(_)
                            | Ast::Concat(_) => {
                                self.decrement_depth();
                                Ok( () )
                            }
                        }
                    }

                    fn visit_class_set_item_pre(
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<()>
                    {
                        let span = match *ast {
                            ast::ClassSetItem::Empty(_)
                            | ast::ClassSetItem::Literal(_)
                            | ast::ClassSetItem::Range(_)
                            | ast::ClassSetItem::Ascii(_)
                            | ast::ClassSetItem::Unicode(_)
                            | ast::ClassSetItem::Perl(_) => { return Ok( () ); }
                            ast::ClassSetItem::Bracketed(ref x) => &x.span,
                            ast::ClassSetItem::Union(ref x) => &x.span,
                        };
                        self.increment_depth(span)
                    }

                    fn visit_class_set_item_post(
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<()> {
                        match *ast {
                            ast::ClassSetItem::Empty(_)
                            | ast::ClassSetItem::Literal(_)
                            | ast::ClassSetItem::Range(_)
                            | ast::ClassSetItem::Ascii(_)
                            | ast::ClassSetItem::Unicode(_)
                            | ast::ClassSetItem::Perl(_) => {
                                // These are all base cases, so we don't decrement depth.
                                Ok( () )
                            }
                            ast::ClassSetItem::Bracketed(_) | ast::ClassSetItem::Union(_) => {
                                self.decrement_depth();
                                Ok( () )
                            }
                        }
                    }

                    fn visit_class_set_binary_op_pre(
                        &mut self,
                        ast: &ast::ClassSetBinaryOp,
                    ) -> Result<()> { self.increment_depth(&ast.span) }

                    fn visit_class_set_binary_op_post(
                        &mut self,
                        _ast: &ast::ClassSetBinaryOp,
                    ) -> Result<()> {
                        self.decrement_depth();
                        Ok( () )
                    }
                }
                fn specialize_err<T>(
                    result: Result<T>,
                    from: ast::ErrorKind,
                    to: ast::ErrorKind,
                ) -> Result<T> {
                    if let Err(e) = result {
                        if e.kind == from {
                            Err(ast::Error { kind: to, pattern: e.pattern, span: e.span })
                        } else {
                            Err(e)
                        }
                    } else {
                        result
                    }
                }
            }

            pub mod print
            {
                /*!
                Provides a regular expression printer for `Ast`.*/
                use ::
                {
                    *,
                };
                /*
                use ::fmt;

                use crate::ast::{
                    self,
                    visitor::{self, Visitor},
                    Ast,
                };
                */

                #[derive( Clone, Debug )]
                struct PrinterBuilder {
                    _priv: (),
                }

                impl Default for PrinterBuilder               
                {
                    fn default() -> PrinterBuilder {
                        PrinterBuilder::new()
                    }
                }

                impl PrinterBuilder
                {
                    fn new() -> PrinterBuilder {
                        PrinterBuilder { _priv: () }
                    }

                    fn build( &self ) -> Printer { Printer { _priv: () } }
                }

                #[derive( Debug )]
                pub struct Printer {
                    _priv: (),
                }

                impl Printer
                {
                    pub fn new() -> Printer {
                        PrinterBuilder::new().build()
                    }
                    
                    pub fn print<W: fmt::Write>( &mut self, ast: &Ast, wtr: W) -> fmt::Result {
                        visitor::visit(ast, Writer { wtr })
                    }
                }

                #[derive( Debug )]
                struct Writer<W> { wtr: W, }

                impl<W: fmt::Write> Visitor for Writer<W> {
                    type Output = ();
                    type Err = fmt::Error;

                    fn finish(self) -> fmt::Result {
                        Ok( () )
                    }

                    fn visit_pre( &mut self, ast: &Ast) -> fmt::Result {
                        match *ast {
                            Ast::Group(ref x) => self.fmt_group_pre(x),
                            Ast::ClassBracketed(ref x) => self.fmt_class_bracketed_pre(x),
                            _ => Ok( () ),
                        }
                    }

                    fn visit_post( &mut self, ast: &Ast) -> fmt::Result {
                        match *ast {
                            Ast::Empty(_) => Ok( () ),
                            Ast::Flags(ref x) => self.fmt_set_flags(x),
                            Ast::Literal(ref x) => self.fmt_literal(x),
                            Ast::Dot(_) => self.wtr.write_str("."),
                            Ast::Assertion(ref x) => self.fmt_assertion(x),
                            Ast::ClassPerl(ref x) => self.fmt_class_perl(x),
                            Ast::ClassUnicode(ref x) => self.fmt_class_unicode(x),
                            Ast::ClassBracketed(ref x) => self.fmt_class_bracketed_post(x),
                            Ast::Repetition(ref x) => self.fmt_repetition(x),
                            Ast::Group(ref x) => self.fmt_group_post(x),
                            Ast::Alternation(_) => Ok( () ),
                            Ast::Concat(_) => Ok( () ),
                        }
                    }

                    fn visit_alternation_in(&mut self) -> fmt::Result {
                        self.wtr.write_str("|")
                    }

                    fn visit_class_set_item_pre(
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<(), Self::Err> {
                        match *ast {
                            ast::ClassSetItem::Bracketed(ref x) => { self.fmt_class_bracketed_pre(x) }
                            _ => Ok( () ),
                        }
                    }

                    fn visit_class_set_item_post(
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<(), Self::Err> {
                        use crate::ast::ClassSetItem::*;

                        match *ast {
                            Empty(_) => Ok( () ),
                            Literal(ref x) => self.fmt_literal(x),
                            Range(ref x) => {
                                self.fmt_literal(&x.start)?;
                                self.wtr.write_str("-")?;
                                self.fmt_literal(&x.end)?;
                                Ok( () )
                            }
                            Ascii(ref x) => self.fmt_class_ascii(x),
                            Unicode(ref x) => self.fmt_class_unicode(x),
                            Perl(ref x) => self.fmt_class_perl(x),
                            Bracketed(ref x) => self.fmt_class_bracketed_post(x),
                            Union(_) => Ok( () ),
                        }
                    }

                    fn visit_class_set_binary_op_in(
                        &mut self,
                        ast: &ast::ClassSetBinaryOp,
                    ) -> Result<(), Self::Err> { self.fmt_class_set_binary_op_kind(&ast.kind) }
                }

                impl<W: fmt::Write> Writer<W>
                {
                    fn fmt_group_pre( &mut self, ast: &ast::Group) -> fmt::Result {
                        use crate::ast::GroupKind::*;
                        match ast.kind {
                            CaptureIndex(_) => self.wtr.write_str("("),
                            CaptureName { ref name, starts_with_p } => {
                                let start = if starts_with_p { "(?P<" } else { "(?<" };
                                self.wtr.write_str(start)?;
                                self.wtr.write_str(&name.name)?;
                                self.wtr.write_str(">")?;
                                Ok( () )
                            }
                            NonCapturing(ref flags) => {
                                self.wtr.write_str("(?")?;
                                self.fmt_flags(flags)?;
                                self.wtr.write_str(":")?;
                                Ok( () )
                            }
                        }
                    }

                    fn fmt_group_post( &mut self, _ast: &ast::Group) -> fmt::Result {
                        self.wtr.write_str(")")
                    }

                    fn fmt_repetition( &mut self, ast: &ast::Repetition) -> fmt::Result {
                        use crate::ast::RepetitionKind::*;
                        match ast.op.kind {
                            ZeroOrOne if ast.greedy => self.wtr.write_str("?"),
                            ZeroOrOne => self.wtr.write_str("??"),
                            ZeroOrMore if ast.greedy => self.wtr.write_str("*"),
                            ZeroOrMore => self.wtr.write_str("*?"),
                            OneOrMore if ast.greedy => self.wtr.write_str("+"),
                            OneOrMore => self.wtr.write_str("+?"),
                            Range(ref x) => {
                                self.fmt_repetition_range(x)?;
                                if !ast.greedy {
                                    self.wtr.write_str("?")?;
                                }
                                Ok( () )
                            }
                        }
                    }

                    fn fmt_repetition_range(
                        &mut self,
                        ast: &ast::RepetitionRange,
                    ) -> fmt::Result {
                        use crate::ast::RepetitionRange::*;
                        match *ast {
                            Exactly(x) => write!( self.wtr, "{{{x}}}"),
                            AtLeast(x) => write!( self.wtr, "{{{x},}}"),
                            Bounded(x, y) => write!( self.wtr, "{{{x},{y}}}"),
                        }
                    }

                    fn fmt_literal( &mut self, ast: &ast::Literal) -> fmt::Result {
                        use crate::ast::LiteralKind::*;

                        match ast.kind {
                            Verbatim => self.wtr.write_char(ast.c),
                            Meta | Superfluous => write!( self.wtr, r"\{}", ast.c),
                            Octal => write!( self.wtr, r"\{:o}", u32::from(ast.c)),
                            HexFixed(ast::HexLiteralKind::X) => { write!( self.wtr, r"\x{:02X}", u32::from(ast.c)) }
                            HexFixed(ast::HexLiteralKind::UnicodeShort) => { write!( self.wtr, r"\u{:04X}", u32::from(ast.c)) }
                            HexFixed(ast::HexLiteralKind::UnicodeLong) => { write!( self.wtr, r"\U{:08X}", u32::from(ast.c)) }
                            HexBrace(ast::HexLiteralKind::X) => { write!( self.wtr, r"\x{{{:X}}}", u32::from(ast.c)) }
                            HexBrace(ast::HexLiteralKind::UnicodeShort) => { write!( self.wtr, r"\u{{{:X}}}", u32::from(ast.c)) }
                            HexBrace(ast::HexLiteralKind::UnicodeLong) => { write!( self.wtr, r"\U{{{:X}}}", u32::from(ast.c)) }
                            Special(ast::SpecialLiteralKind::Bell) => { self.wtr.write_str(r"\a") }
                            Special(ast::SpecialLiteralKind::FormFeed) => { self.wtr.write_str(r"\f") }
                            Special(ast::SpecialLiteralKind::Tab) => self.wtr.write_str(r"\t"),
                            Special(ast::SpecialLiteralKind::LineFeed) => { self.wtr.write_str(r"\n") }
                            Special(ast::SpecialLiteralKind::CarriageReturn) => { self.wtr.write_str(r"\r") }
                            Special(ast::SpecialLiteralKind::VerticalTab) => { self.wtr.write_str(r"\v") }
                            Special(ast::SpecialLiteralKind::Space) => { self.wtr.write_str(r"\ ") }
                        }
                    }

                    fn fmt_assertion( &mut self, ast: &ast::Assertion) -> fmt::Result {
                        use crate::ast::AssertionKind::*;
                        match ast.kind {
                            StartLine => self.wtr.write_str("^"),
                            EndLine => self.wtr.write_str("$"),
                            StartText => self.wtr.write_str(r"\A"),
                            EndText => self.wtr.write_str(r"\z"),
                            WordBoundary => self.wtr.write_str(r"\b"),
                            NotWordBoundary => self.wtr.write_str(r"\B"),
                            WordBoundaryStart => self.wtr.write_str(r"\b{start}"),
                            WordBoundaryEnd => self.wtr.write_str(r"\b{end}"),
                            WordBoundaryStartAngle => self.wtr.write_str(r"\<"),
                            WordBoundaryEndAngle => self.wtr.write_str(r"\>"),
                            WordBoundaryStartHalf => self.wtr.write_str(r"\b{start-half}"),
                            WordBoundaryEndHalf => self.wtr.write_str(r"\b{end-half}"),
                        }
                    }

                    fn fmt_set_flags( &mut self, ast: &ast::SetFlags) -> fmt::Result {
                        self.wtr.write_str("(?")?;
                        self.fmt_flags(&ast.flags)?;
                        self.wtr.write_str(")")?;
                        Ok( () )
                    }

                    fn fmt_flags( &mut self, ast: &ast::Flags) -> fmt::Result {
                        use crate::ast::{Flag, FlagsItemKind};

                        for item in &ast.items {
                            match item.kind {
                                FlagsItemKind::Negation => self.wtr.write_str("-"),
                                FlagsItemKind::Flag(ref flag) => match *flag {
                                    Flag::CaseInsensitive => self.wtr.write_str("i"),
                                    Flag::MultiLine => self.wtr.write_str("m"),
                                    Flag::DotMatchesNewLine => self.wtr.write_str("s"),
                                    Flag::SwapGreed => self.wtr.write_str("U"),
                                    Flag::Unicode => self.wtr.write_str("u"),
                                    Flag::CRLF => self.wtr.write_str("R"),
                                    Flag::IgnoreWhitespace => self.wtr.write_str("x"),
                                },
                            }?;
                        }
                        Ok( () )
                    }

                    fn fmt_class_bracketed_pre(
                        &mut self,
                        ast: &ast::ClassBracketed,
                    ) -> fmt::Result {
                        if ast.negated {
                            self.wtr.write_str("[^")
                        } else {
                            self.wtr.write_str("[")
                        }
                    }

                    fn fmt_class_bracketed_post(
                        &mut self,
                        _ast: &ast::ClassBracketed,
                    ) -> fmt::Result {
                        self.wtr.write_str("]")
                    }

                    fn fmt_class_set_binary_op_kind(
                        &mut self,
                        ast: &ast::ClassSetBinaryOpKind,
                    ) -> fmt::Result {
                        use crate::ast::ClassSetBinaryOpKind::*;
                        match *ast {
                            Intersection => self.wtr.write_str("&&"),
                            Difference => self.wtr.write_str("--"),
                            SymmetricDifference => self.wtr.write_str("~~"),
                        }
                    }

                    fn fmt_class_perl( &mut self, ast: &ast::ClassPerl) -> fmt::Result {
                        use crate::ast::ClassPerlKind::*;
                        match ast.kind {
                            Digit if ast.negated => self.wtr.write_str(r"\D"),
                            Digit => self.wtr.write_str(r"\d"),
                            Space if ast.negated => self.wtr.write_str(r"\S"),
                            Space => self.wtr.write_str(r"\s"),
                            Word if ast.negated => self.wtr.write_str(r"\W"),
                            Word => self.wtr.write_str(r"\w"),
                        }
                    }

                    fn fmt_class_ascii( &mut self, ast: &ast::ClassAscii) -> fmt::Result {
                        use crate::ast::ClassAsciiKind::*;
                        match ast.kind {
                            Alnum if ast.negated => self.wtr.write_str("[:^alnum:]"),
                            Alnum => self.wtr.write_str("[:alnum:]"),
                            Alpha if ast.negated => self.wtr.write_str("[:^alpha:]"),
                            Alpha => self.wtr.write_str("[:alpha:]"),
                            Ascii if ast.negated => self.wtr.write_str("[:^ascii:]"),
                            Ascii => self.wtr.write_str("[:ascii:]"),
                            Blank if ast.negated => self.wtr.write_str("[:^blank:]"),
                            Blank => self.wtr.write_str("[:blank:]"),
                            Cntrl if ast.negated => self.wtr.write_str("[:^cntrl:]"),
                            Cntrl => self.wtr.write_str("[:cntrl:]"),
                            Digit if ast.negated => self.wtr.write_str("[:^digit:]"),
                            Digit => self.wtr.write_str("[:digit:]"),
                            Graph if ast.negated => self.wtr.write_str("[:^graph:]"),
                            Graph => self.wtr.write_str("[:graph:]"),
                            Lower if ast.negated => self.wtr.write_str("[:^lower:]"),
                            Lower => self.wtr.write_str("[:lower:]"),
                            Print if ast.negated => self.wtr.write_str("[:^print:]"),
                            Print => self.wtr.write_str("[:print:]"),
                            Punct if ast.negated => self.wtr.write_str("[:^punct:]"),
                            Punct => self.wtr.write_str("[:punct:]"),
                            Space if ast.negated => self.wtr.write_str("[:^space:]"),
                            Space => self.wtr.write_str("[:space:]"),
                            Upper if ast.negated => self.wtr.write_str("[:^upper:]"),
                            Upper => self.wtr.write_str("[:upper:]"),
                            Word if ast.negated => self.wtr.write_str("[:^word:]"),
                            Word => self.wtr.write_str("[:word:]"),
                            Xdigit if ast.negated => self.wtr.write_str("[:^xdigit:]"),
                            Xdigit => self.wtr.write_str("[:xdigit:]"),
                        }
                    }

                    fn fmt_class_unicode( &mut self, ast: &ast::ClassUnicode) -> fmt::Result {
                        use crate::ast::ClassUnicodeKind::*;
                        use crate::ast::ClassUnicodeOpKind::*;

                        if ast.negated {
                            self.wtr.write_str(r"\P")?;
                        } else {
                            self.wtr.write_str(r"\p")?;
                        }
                        match ast.kind {
                            OneLetter(c) => self.wtr.write_char(c),
                            Named(ref x) => write!( self.wtr, "{{{}}}", x),
                            NamedValue { op: Equal, ref name, ref value } => { write!( self.wtr, "{{{}={}}}", name, value) }
                            NamedValue { op: Colon, ref name, ref value } => { write!( self.wtr, "{{{}:{}}}", name, value) }
                            NamedValue { op: NotEqual, ref name, ref value } => { write!( self.wtr, "{{{}!={}}}", name, value) }
                        }
                    }
                }
            }

            pub mod visitor
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use alloc::{vec, vec::Vec};
                use crate::ast::{self, Ast};
                */
                pub trait Visitor {

                    type Output;

                    type Err;
                    fn finish(self) -> Result<Self::Output, Self::Err>;

                    fn start(&mut self) {}
                    fn visit_pre( &mut self, _ast: &Ast) -> Result<(), Self::Err> { Ok( () ) }
                    fn visit_post( &mut self, _ast: &Ast) -> Result<(), Self::Err> { Ok( () ) }
                    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> { Ok( () ) }

                    fn visit_concat_in(&mut self) -> Result<(), Self::Err> { Ok( () ) }
                    fn visit_class_set_item_pre(
                        &mut self,
                        _ast: &ast::ClassSetItem,
                    ) -> Result<(), Self::Err> { Ok( () ) }
                    fn visit_class_set_item_post(
                        &mut self,
                        _ast: &ast::ClassSetItem,
                    ) -> Result<(), Self::Err> { Ok( () ) }
                    fn visit_class_set_binary_op_pre(
                        &mut self,
                        _ast: &ast::ClassSetBinaryOp,
                    ) -> Result<(), Self::Err> { Ok( () ) }
                    fn visit_class_set_binary_op_post(
                        &mut self,
                        _ast: &ast::ClassSetBinaryOp,
                    ) -> Result<(), Self::Err> { Ok( () ) }
                    fn visit_class_set_binary_op_in(
                        &mut self,
                        _ast: &ast::ClassSetBinaryOp,
                    ) -> Result<(), Self::Err> { Ok( () ) }
                }

                pub fn visit<V: Visitor>(ast: &Ast, visitor: V) -> Result<V::Output, V::Err> { HeapVisitor::new().visit(ast, visitor) }
                struct HeapVisitor<'a> {
                    stack: Vec<(&'a Ast, Frame<'a>)>,
                    stack_class: Vec<(ClassInduct<'a>, ClassFrame<'a>)>,
                }
                enum Frame<'a> {
                    Repetition(&'a ast::Repetition),
                    Group(&'a ast::Group),
                    Concat {

                        head: &'a Ast,
                        tail: &'a [Ast],
                    },
                    Alternation {

                        head: &'a Ast,
                        tail: &'a [Ast],
                    },
                }
                enum ClassFrame<'a> {
                    Union {

                        head: &'a ast::ClassSetItem,
                        tail: &'a [ast::ClassSetItem],
                    },
                    Binary { op: &'a ast::ClassSetBinaryOp },
                    BinaryLHS {
                        op: &'a ast::ClassSetBinaryOp,
                        lhs: &'a ast::ClassSet,
                        rhs: &'a ast::ClassSet,
                    },
                    BinaryRHS { op: &'a ast::ClassSetBinaryOp, rhs: &'a ast::ClassSet },
                }
                enum ClassInduct<'a> {
                    Item(&'a ast::ClassSetItem),
                    BinaryOp(&'a ast::ClassSetBinaryOp),
                }

                impl<'a> HeapVisitor<'a>
                {
                    fn new() -> HeapVisitor<'a> { HeapVisitor { stack: vec![], stack_class: vec![] } }

                    fn visit<V: Visitor>(
                        &mut self,
                        mut ast: &'a Ast,
                        mut visitor: V,
                    ) -> Result<V::Output, V::Err> {
                        self.stack.clear();
                        self.stack_class.clear();

                        visitor.start();
                        loop {
                            visitor.visit_pre(ast)?;
                            if let Some(x) = self.induct(ast, &mut visitor)? {
                                let child = x.child();
                                self.stack.push((ast, x));
                                ast = child;
                                continue;
                            }
                            visitor.visit_post(ast)?;
                            loop {
                                let (post_ast, frame) = match self.stack.pop() {
                                    None => return visitor.finish(),
                                    Some((post_ast, frame)) => (post_ast, frame),
                                };
                                if let Some(x) = self.pop(frame) {
                                    match x {
                                        Frame::Alternation { .. } => { visitor.visit_alternation_in()?; }
                                        Frame::Concat { .. } => { visitor.visit_concat_in()?; }
                                        _ => {}
                                    }
                                    ast = x.child();
                                    self.stack.push((post_ast, x));
                                    break;
                                }
                                visitor.visit_post(post_ast)?;
                            }
                        }
                    }
                    fn induct<V: Visitor>(
                        &mut self,
                        ast: &'a Ast,
                        visitor: &mut V,
                    ) -> Result<Option<Frame<'a>>, V::Err> {
                        Ok(match *ast {
                            Ast::ClassBracketed(ref x) => {
                                self.visit_class(x, visitor)?;
                                None
                            }
                            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),
                            Ast::Group(ref x) => Some(Frame::Group(x)),
                            Ast::Concat(ref x) if x.asts.is_empty() => None,
                            Ast::Concat(ref x) => { Some(Frame::Concat { head: &x.asts[0], tail: &x.asts[1..] }) }
                            Ast::Alternation(ref x) if x.asts.is_empty() => None,
                            Ast::Alternation(ref x) => Some(Frame::Alternation {
                                head: &x.asts[0],
                                tail: &x.asts[1..],
                            }),
                            _ => None,
                        })
                    }
                    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {
                        match induct {
                            Frame::Repetition(_) => None,
                            Frame::Group(_) => None,
                            Frame::Concat { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })
                                }
                            }
                            Frame::Alternation { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(Frame::Alternation {
                                        head: &tail[0],
                                        tail: &tail[1..],
                                    })
                                }
                            }
                        }
                    }

                    fn visit_class<V: Visitor>(
                        &mut self,
                        ast: &'a ast::ClassBracketed,
                        visitor: &mut V,
                    ) -> Result<(), V::Err>
                    {
                        let mut ast = ClassInduct::from_bracketed(ast);
                        loop {
                            self.visit_class_pre(&ast, visitor)?;
                            if let Some(x) = self.induct_class(&ast) {
                                let child = x.child();
                                self.stack_class.push((ast, x));
                                ast = child;
                                continue;
                            }
                            self.visit_class_post(&ast, visitor)?;
                            loop {
                                let (post_ast, frame) = match self.stack_class.pop() {
                                    None => return Ok( () ),
                                    Some((post_ast, frame)) => (post_ast, frame),
                                };
                                if let Some(x) = self.pop_class(frame) {
                                    if let ClassFrame::BinaryRHS { ref op, .. } = x {
                                        visitor.visit_class_set_binary_op_in(op)?;
                                    }
                                    ast = x.child();
                                    self.stack_class.push((post_ast, x));
                                    break;
                                }
                                self.visit_class_post(&post_ast, visitor)?;
                            }
                        }
                    }

                    fn visit_class_pre<V: Visitor>(
                        &self,
                        ast: &ClassInduct<'a>,
                        visitor: &mut V,
                    ) -> Result<(), V::Err> {
                        match *ast {
                            ClassInduct::Item(item) => { visitor.visit_class_set_item_pre(item)?; }
                            ClassInduct::BinaryOp(op) => { visitor.visit_class_set_binary_op_pre(op)?; }
                        }
                        Ok( () )
                    }

                    fn visit_class_post<V: Visitor>(
                        &self,
                        ast: &ClassInduct<'a>,
                        visitor: &mut V,
                    ) -> Result<(), V::Err> {
                        match *ast {
                            ClassInduct::Item(item) => { visitor.visit_class_set_item_post(item)?; }
                            ClassInduct::BinaryOp(op) => { visitor.visit_class_set_binary_op_post(op)?; }
                        }
                        Ok( () )
                    }
                    fn induct_class(&self, ast: &ClassInduct<'a>) -> Option<ClassFrame<'a>> {
                        match *ast {
                            ClassInduct::Item(&ast::ClassSetItem::Bracketed(ref x)) => {
                                match x.kind {
                                    ast::ClassSet::Item(ref item) => { Some(ClassFrame::Union { head: item, tail: &[] }) }
                                    ast::ClassSet::BinaryOp(ref op) => { Some(ClassFrame::Binary { op }) }
                                }
                            }
                            ClassInduct::Item(&ast::ClassSetItem::Union(ref x)) => {
                                if x.items.is_empty() {
                                    None
                                } else {
                                    Some(ClassFrame::Union {
                                        head: &x.items[0],
                                        tail: &x.items[1..],
                                    })
                                }
                            }
                            ClassInduct::BinaryOp(op) => { Some(ClassFrame::BinaryLHS { op, lhs: &op.lhs, rhs: &op.rhs }) }
                            _ => None,
                        }
                    }
                    fn pop_class(&self, induct: ClassFrame<'a>) -> Option<ClassFrame<'a>> {
                        match induct {
                            ClassFrame::Union { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(ClassFrame::Union {
                                        head: &tail[0],
                                        tail: &tail[1..],
                                    })
                                }
                            }
                            ClassFrame::Binary { .. } => None,
                            ClassFrame::BinaryLHS { op, rhs, .. } => { Some(ClassFrame::BinaryRHS { op, rhs }) }
                            ClassFrame::BinaryRHS { .. } => None,
                        }
                    }
                }

                impl<'a> Frame<'a>
                {
                    fn child( &self ) -> &'a Ast {
                        match *self {
                            Frame::Repetition(rep) => &rep.ast,
                            Frame::Group(group) => &group.ast,
                            Frame::Concat { head, .. } => head,
                            Frame::Alternation { head, .. } => head,
                        }
                    }
                }

                impl<'a> ClassFrame<'a>
                {
                    fn child( &self ) -> ClassInduct<'a> {
                        match *self {
                            ClassFrame::Union { head, .. } => ClassInduct::Item(head),
                            ClassFrame::Binary { op, .. } => ClassInduct::BinaryOp(op),
                            ClassFrame::BinaryLHS { ref lhs, .. } => { ClassInduct::from_set(lhs) }
                            ClassFrame::BinaryRHS { ref rhs, .. } => { ClassInduct::from_set(rhs) }
                        }
                    }
                }

                impl<'a> ClassInduct<'a>
                {
                    fn from_bracketed(ast: &'a ast::ClassBracketed) -> ClassInduct<'a> { ClassInduct::from_set(&ast.kind) }

                    fn from_set(ast: &'a ast::ClassSet) -> ClassInduct<'a> {
                        match *ast {
                            ast::ClassSet::Item(ref item) => ClassInduct::Item(item),
                            ast::ClassSet::BinaryOp(ref op) => ClassInduct::BinaryOp(op),
                        }
                    }
                }

                impl<'a> ::fmt::Debug for ClassFrame<'a>
               
               
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        let x = match *self {
                            ClassFrame::Union { .. } => "Union",
                            ClassFrame::Binary { .. } => "Binary",
                            ClassFrame::BinaryLHS { .. } => "BinaryLHS",
                            ClassFrame::BinaryRHS { .. } => "BinaryRHS",
                        };
                        write!(f, "{x}")
                    }
                }

                impl<'a> ::fmt::Debug for ClassInduct<'a>
               
               
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                        let x = match *self {
                            ClassInduct::Item(it) => match *it {
                                ast::ClassSetItem::Empty(_) => "Item(Empty)",
                                ast::ClassSetItem::Literal(_) => "Item(Literal)",
                                ast::ClassSetItem::Range(_) => "Item(Range)",
                                ast::ClassSetItem::Ascii(_) => "Item(Ascii)",
                                ast::ClassSetItem::Perl(_) => "Item(Perl)",
                                ast::ClassSetItem::Unicode(_) => "Item(Unicode)",
                                ast::ClassSetItem::Bracketed(_) => "Item(Bracketed)",
                                ast::ClassSetItem::Union(_) => "Item(Union)",
                            },
                            ClassInduct::BinaryOp(it) => match it.kind {
                                ast::ClassSetBinaryOpKind::Intersection => { "BinaryOp(Intersection)" }
                                ast::ClassSetBinaryOpKind::Difference => { "BinaryOp(Difference)" }
                                ast::ClassSetBinaryOpKind::SymmetricDifference => { "BinaryOp(SymmetricDifference)" }
                            },
                        };
                        write!(f, "{x}")
                    }
                }
            }
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Error {
                kind: ErrorKind,
                pattern: String,
                span: Span,
            }

            impl Error 
            {

                pub fn kind( &self ) -> &ErrorKind { &self.kind }
                
                pub fn pattern( &self ) -> &str { &self.pattern }

                pub fn span( &self ) -> &Span { &self.span }

                pub fn auxiliary_span( &self ) -> Option<&Span> {
                    use self::ErrorKind::*;
                    match self.kind {
                        FlagDuplicate { ref original } => Some(original),
                        FlagRepeatedNegation { ref original, .. } => Some(original),
                        GroupNameDuplicate { ref original, .. } => Some(original),
                        _ => None,
                    }
                }
            }

            #[non_exhaustive] #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum ErrorKind {

                CaptureLimitExceeded,
                ClassEscapeInvalid,
                ClassRangeInvalid,
                ClassRangeLiteral,
                ClassUnclosed,
                DecimalEmpty,
                DecimalInvalid,
                EscapeHexEmpty,
                EscapeHexInvalid,
                EscapeHexInvalidDigit,
                EscapeUnexpectedEof,
                EscapeUnrecognized,
                FlagDanglingNegation,
                FlagDuplicate {
                    original: Span,
                },
                FlagRepeatedNegation {
                    original: Span,
                },
                FlagUnexpectedEof,
                FlagUnrecognized,
                GroupNameDuplicate {
                    original: Span,
                },
                GroupNameEmpty,
                GroupNameInvalid,
                GroupNameUnexpectedEof,
                GroupUnclosed,
                GroupUnopened,
                NestLimitExceeded(u32),
                RepetitionCountInvalid,
                RepetitionCountDecimalEmpty,
                RepetitionCountUnclosed,
                RepetitionMissing,
                SpecialWordBoundaryUnclosed,
                SpecialWordBoundaryUnrecognized,
                SpecialWordOrRepetitionUnexpectedEof,
                UnicodeClassInvalid,
                UnsupportedBackreference,
                UnsupportedLookAround,
            }

                impl ::error::Error for Error {}

            impl ::fmt::Display for Error
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    crate::error::Formatter::from(self).fmt(f)
                }
            }

            impl ::fmt::Display for ErrorKind
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    use self::ErrorKind::*;
                    match *self {
                        CaptureLimitExceeded => write!(
                            f,
                            "exceeded the maximum number of \
                            capturing groups ({})",
                            u32::MAX
                        ),
                        ClassEscapeInvalid => { write!(f, "invalid escape sequence found in character class") }
                        ClassRangeInvalid => write!(
                            f,
                            "invalid character class range, \
                            the start must be <= the end"
                        ),
                        ClassRangeLiteral => { write!(f, "invalid range boundary, must be a literal") }
                        ClassUnclosed => write!(f, "unclosed character class"),
                        DecimalEmpty => write!(f, "decimal literal empty"),
                        DecimalInvalid => write!(f, "decimal literal invalid"),
                        EscapeHexEmpty => write!(f, "hexadecimal literal empty"),
                        EscapeHexInvalid => { write!(f, "hexadecimal literal is not a Unicode scalar value") }
                        EscapeHexInvalidDigit => write!(f, "invalid hexadecimal digit"),
                        EscapeUnexpectedEof => write!(
                            f,
                            "incomplete escape sequence, \
                            reached end of pattern prematurely"
                        ),
                        EscapeUnrecognized => write!(f, "unrecognized escape sequence"),
                        FlagDanglingNegation => { write!(f, "dangling flag negation operator") }
                        FlagDuplicate { .. } => write!(f, "duplicate flag"),
                        FlagRepeatedNegation { .. } => { write!(f, "flag negation operator repeated") }
                        FlagUnexpectedEof => { write!(f, "expected flag but got end of regex") }
                        FlagUnrecognized => write!(f, "unrecognized flag"),
                        GroupNameDuplicate { .. } => { write!(f, "duplicate capture group name") }
                        GroupNameEmpty => write!(f, "empty capture group name"),
                        GroupNameInvalid => write!(f, "invalid capture group character"),
                        GroupNameUnexpectedEof => write!(f, "unclosed capture group name"),
                        GroupUnclosed => write!(f, "unclosed group"),
                        GroupUnopened => write!(f, "unopened group"),
                        NestLimitExceeded(limit) => write!(
                            f,
                            "exceed the maximum number of \
                            nested parentheses/brackets ({})",
                            limit
                        ),
                        RepetitionCountInvalid => write!(
                            f,
                            "invalid repetition count range, \
                            the start must be <= the end"
                        ),
                        RepetitionCountDecimalEmpty => { write!(f, "repetition quantifier expects a valid decimal") }
                        RepetitionCountUnclosed => { write!(f, "unclosed counted repetition") }
                        RepetitionMissing => { write!(f, "repetition operator missing expression") }
                        SpecialWordBoundaryUnclosed => {
                            write!(
                                f,
                                "special word boundary assertion is either \
                                unclosed or contains an invalid character",
                            )
                        }
                        SpecialWordBoundaryUnrecognized => {
                            write!(
                                f,
                                "unrecognized special word boundary assertion, \
                                valid choices are: start, end, start-half \
                                or end-half",
                            )
                        }
                        SpecialWordOrRepetitionUnexpectedEof => {
                            write!(
                                f,
                                "found either the beginning of a special word \
                                boundary or a bounded repetition on a \\b with \
                                an opening brace, but no closing brace",
                            )
                        }
                        UnicodeClassInvalid => { write!(f, "invalid Unicode character class") }
                        UnsupportedBackreference => { write!(f, "backreferences are not supported") }
                        UnsupportedLookAround => write!(
                            f,
                            "look-around, including look-ahead and look-behind, \
                            is not supported"
                        ),
                    }
                }
            }

            #[derive(Clone, Copy, Eq, PartialEq)]
            pub struct Span {

                pub start: Position,
                pub end: Position,
            }

            impl ::fmt::Debug for Span
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(f, "Span({:?}, {:?})", self.start, self.end)
                }
            }

            impl Ord for Span {
                fn cmp(&self, other: &Span) -> Ordering {
                    (&self.start, &self.end).cmp(&(&other.start, &other.end))
                }
            }

            impl PartialOrd for Span {
                fn partial_cmp(&self, other: &Span) -> Option<Ordering> { Some( self.cmp(other)) }
            }

            #[derive(Clone, Copy, Eq, PartialEq)]
            pub struct Position {
                pub offset: usize,
                pub line: usize,
                pub column: usize,
            }

            impl ::fmt::Debug for Position
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    write!(
                        f,
                        "Position(o: {:?}, l: {:?}, c: {:?})",
                        self.offset, self.line, self.column
                    )
                }
            }

            impl Ord for Position {
                fn cmp(&self, other: &Position) -> Ordering {
                    self.offset.cmp(&other.offset)
                }
            }

            impl PartialOrd for Position {
                fn partial_cmp(&self, other: &Position) -> Option<Ordering> { Some( self.cmp(other)) }
            }

            impl Span            
            {

                pub fn new(start: Position, end: Position) -> Span {
                    Span { start, end }
                }

                pub fn splat(pos: Position) -> Span {
                    Span::new(pos, pos)
                }

                pub fn with_start(self, pos: Position) -> Span {
                    Span { start: pos, ..self }
                }

                pub fn with_end(self, pos: Position) -> Span {
                    Span { end: pos, ..self }
                }

                pub fn is_one_line( &self ) -> bool { self.start.line == self.end.line }

                pub fn is_empty( &self ) -> bool { self.start.offset == self.end.offset }
            }

            impl Position {

                

                pub fn new(offset: usize, line: usize, column: usize) -> Position {
                    Position { offset, line, column }
                }
            }
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct WithComments {

                pub ast: Ast,
                pub comments: Vec<Comment>,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Comment {

                pub span: Span,
                pub comment: String,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum Ast {

                Empty(Box<Span>),
                Flags(Box<SetFlags>),
                Literal(Box<Literal>),
                Dot(Box<Span>),
                Assertion(Box<Assertion>),
                ClassUnicode(Box<ClassUnicode>),
                ClassPerl(Box<ClassPerl>),
                ClassBracketed(Box<ClassBracketed>),
                Repetition(Box<Repetition>),
                Group(Box<Group>),
                Alternation(Box<Alternation>),
                Concat(Box<Concat>),
            }

            impl Ast 
            {

                pub fn empty(span: Span) -> Ast {
                    Ast::Empty(Box::new(span))
                }

                pub fn flags(e: SetFlags) -> Ast {
                    Ast::Flags(Box::new(e))
                }

                pub fn literal(e: Literal) -> Ast {
                    Ast::Literal(Box::new(e))
                }

                pub fn dot(span: Span) -> Ast {
                    Ast::Dot(Box::new(span))
                }

                pub fn assertion(e: Assertion) -> Ast {
                    Ast::Assertion(Box::new(e))
                }

                pub fn class_unicode(e: ClassUnicode) -> Ast {
                    Ast::ClassUnicode(Box::new(e))
                }

                pub fn class_perl(e: ClassPerl) -> Ast {
                    Ast::ClassPerl(Box::new(e))
                }

                pub fn class_bracketed(e: ClassBracketed) -> Ast {
                    Ast::ClassBracketed(Box::new(e))
                }

                pub fn repetition(e: Repetition) -> Ast {
                    Ast::Repetition(Box::new(e))
                }

                pub fn group(e: Group) -> Ast {
                    Ast::Group(Box::new(e))
                }

                pub fn alternation(e: Alternation) -> Ast {
                    Ast::Alternation(Box::new(e))
                }

                pub fn concat(e: Concat) -> Ast {
                    Ast::Concat(Box::new(e))
                }

                pub fn span( &self ) -> &Span {
                    match *self {
                        Ast::Empty(ref span) => span,
                        Ast::Flags(ref x) => &x.span,
                        Ast::Literal(ref x) => &x.span,
                        Ast::Dot(ref span) => span,
                        Ast::Assertion(ref x) => &x.span,
                        Ast::ClassUnicode(ref x) => &x.span,
                        Ast::ClassPerl(ref x) => &x.span,
                        Ast::ClassBracketed(ref x) => &x.span,
                        Ast::Repetition(ref x) => &x.span,
                        Ast::Group(ref x) => &x.span,
                        Ast::Alternation(ref x) => &x.span,
                        Ast::Concat(ref x) => &x.span,
                    }
                }

                pub fn is_empty( &self ) -> bool {
                    match *self {
                        Ast::Empty(_) => true,
                        _ => false,
                    }
                }
                fn has_subexprs( &self ) -> bool {
                    match *self {
                        Ast::Empty(_)
                        | Ast::Flags(_)
                        | Ast::Literal(_)
                        | Ast::Dot(_)
                        | Ast::Assertion(_)
                        | Ast::ClassUnicode(_)
                        | Ast::ClassPerl(_) => false,
                        Ast::ClassBracketed(_)
                        | Ast::Repetition(_)
                        | Ast::Group(_)
                        | Ast::Alternation(_)
                        | Ast::Concat(_) => true,
                    }
                }
            }
            
            impl ::fmt::Display for Ast
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    use crate::ast::print::Printer;
                    Printer::new().print(self, f)
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Alternation {

                pub span: Span,
                pub asts: Vec<Ast>,
            }

            impl Alternation {
                pub fn into_ast(mut self) -> Ast {
                    match self.asts.len() {
                        0 => Ast::empty( self.span),
                        1 => self.asts.pop().unwrap(),
                        _ => Ast::alternation(self),
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Concat {

                pub span: Span,
                pub asts: Vec<Ast>,
            }

            impl Concat {
                pub fn into_ast(mut self) -> Ast {
                    match self.asts.len() {
                        0 => Ast::empty( self.span),
                        1 => self.asts.pop().unwrap(),
                        _ => Ast::concat(self),
                    }
                }
            }
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Literal {

                pub span: Span,
                pub kind: LiteralKind,
                pub c: char,
            }

            impl Literal {
                pub fn byte( &self ) -> Option<u8> {
                    match self.kind {
                        LiteralKind::HexFixed(HexLiteralKind::X) => { u8::try_from( self.c).ok() }
                        _ => None,
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum LiteralKind {

                Verbatim,
                Meta,
                Superfluous,
                Octal,
                HexFixed(HexLiteralKind),
                HexBrace(HexLiteralKind),
                Special(SpecialLiteralKind),
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum SpecialLiteralKind {

                Bell,
                FormFeed,
                Tab,
                LineFeed,
                CarriageReturn,
                VerticalTab,
                Space,
            }
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum HexLiteralKind {
                X,
                UnicodeShort,
                UnicodeLong,
            }

            impl HexLiteralKind {
                pub fn digits( &self ) -> u32 {
                    match *self {
                        HexLiteralKind::X => 2,
                        HexLiteralKind::UnicodeShort => 4,
                        HexLiteralKind::UnicodeLong => 8,
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct ClassPerl {

                pub span: Span,
                pub kind: ClassPerlKind,
                pub negated: bool,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum ClassPerlKind {

                Digit,
                Space,
                Word,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct ClassAscii {

                pub span: Span,
                pub kind: ClassAsciiKind,
                pub negated: bool,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum ClassAsciiKind {

                Alnum,
                Alpha,
                Ascii,
                Blank,
                Cntrl,
                Digit,
                Graph,
                Lower,
                Print,
                Punct,
                Space,
                Upper,
                Word,
                Xdigit,
            }

            impl ClassAsciiKind 
            {

                pub fn from_name(name: &str) -> Option<ClassAsciiKind> {
                    use self::ClassAsciiKind::*;
                    match name {
                        "alnum" => Some(Alnum),
                        "alpha" => Some(Alpha),
                        "ascii" => Some(Ascii),
                        "blank" => Some(Blank),
                        "cntrl" => Some(Cntrl),
                        "digit" => Some(Digit),
                        "graph" => Some(Graph),
                        "lower" => Some(Lower),
                        "print" => Some(Print),
                        "punct" => Some(Punct),
                        "space" => Some(Space),
                        "upper" => Some(Upper),
                        "word" => Some(Word),
                        "xdigit" => Some(Xdigit),
                        _ => None,
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct ClassUnicode {

                pub span: Span,
                pub negated: bool,
                pub kind: ClassUnicodeKind,
            }

            impl ClassUnicode 
            {

                pub fn is_negated( &self ) -> bool {
                    match self.kind {
                        ClassUnicodeKind::NamedValue {
                            op: ClassUnicodeOpKind::NotEqual,
                            ..
                        } => !self.negated,
                        _ => self.negated,
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum ClassUnicodeKind {

                OneLetter(char),
                Named(String),
                NamedValue {

                    op: ClassUnicodeOpKind,
                    name: String,
                    value: String,
                },
            }
            
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum ClassUnicodeOpKind {

                Equal,
                Colon,
                NotEqual,
            }

            impl ClassUnicodeOpKind 
            {

                pub fn is_equal( &self ) -> bool {
                    match *self {
                        ClassUnicodeOpKind::Equal | ClassUnicodeOpKind::Colon => true,
                        _ => false,
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct ClassBracketed {

                pub span: Span,
                pub negated: bool,
                pub kind: ClassSet,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum ClassSet {
                Item(ClassSetItem),
                BinaryOp(ClassSetBinaryOp),
            }

            impl ClassSet 
            {

                pub fn union(ast: ClassSetUnion) -> ClassSet {
                    ClassSet::Item(ClassSetItem::Union(ast))
                }

                pub fn span( &self ) -> &Span {
                    match *self {
                        ClassSet::Item(ref x) => x.span(),
                        ClassSet::BinaryOp(ref x) => &x.span,
                    }
                }

                fn is_empty( &self ) -> bool {
                    match *self {
                        ClassSet::Item(ClassSetItem::Empty(_)) => true,
                        _ => false,
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum ClassSetItem {
                Empty(Span),
                Literal(Literal),
                Range(ClassSetRange),
                Ascii(ClassAscii),
                Unicode(ClassUnicode),
                Perl(ClassPerl),
                Bracketed(Box<ClassBracketed>),
                Union(ClassSetUnion),
            }

            impl ClassSetItem 
            {

                pub fn span( &self ) -> &Span {
                    match *self {
                        ClassSetItem::Empty(ref span) => span,
                        ClassSetItem::Literal(ref x) => &x.span,
                        ClassSetItem::Range(ref x) => &x.span,
                        ClassSetItem::Ascii(ref x) => &x.span,
                        ClassSetItem::Perl(ref x) => &x.span,
                        ClassSetItem::Unicode(ref x) => &x.span,
                        ClassSetItem::Bracketed(ref x) => &x.span,
                        ClassSetItem::Union(ref x) => &x.span,
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct ClassSetRange {

                pub span: Span,
                pub start: Literal,
                pub end: Literal,
            }

            impl ClassSetRange 
            {

                pub fn is_valid( &self ) -> bool { self.start.c <= self.end.c }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct ClassSetUnion {
                pub span: Span,
                pub items: Vec<ClassSetItem>,
            }

            impl ClassSetUnion {
                pub fn push( &mut self, item: ClassSetItem) {
                    if self.items.is_empty() {
                        self.span.start = item.span().start;
                    }
                    self.span.end = item.span().end;
                    self.items.push(item);
                }

                pub fn into_item(mut self) -> ClassSetItem {
                    match self.items.len() {
                        0 => ClassSetItem::Empty( self.span),
                        1 => self.items.pop().unwrap(),
                        _ => ClassSetItem::Union(self),
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct ClassSetBinaryOp {

                pub span: Span,
                pub kind: ClassSetBinaryOpKind,
                pub lhs: Box<ClassSet>,
                pub rhs: Box<ClassSet>,
            }
            #[derive(Clone, Copy, Debug, Eq, PartialEq )]
            pub enum ClassSetBinaryOpKind {

                Intersection,
                Difference,
                SymmetricDifference,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Assertion {

                pub span: Span,
                pub kind: AssertionKind,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum AssertionKind
            {
                StartLine,
                EndLine,
                StartText,
                EndText,
                WordBoundary,
                NotWordBoundary,
                WordBoundaryStart,
                WordBoundaryEnd,
                WordBoundaryStartAngle,
                WordBoundaryEndAngle,
                WordBoundaryStartHalf,
                WordBoundaryEndHalf,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Repetition 
            {

                pub span: Span,
                pub op: RepetitionOp,
                pub greedy: bool,
                pub ast: Box<Ast>,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct RepetitionOp 
            {
                pub span: Span,
                pub kind: RepetitionKind,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum RepetitionKind 
            {

                ZeroOrOne,
                ZeroOrMore,
                OneOrMore,
                Range(RepetitionRange),
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum RepetitionRange 
            {

                Exactly(u32),
                AtLeast(u32),
                Bounded(u32, u32),
            }

            impl RepetitionRange 
            
            {

                pub fn is_valid( &self ) -> bool {
                    match *self {
                        RepetitionRange::Bounded(s, e) if s > e => false,
                        _ => true,
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Group 
            {

                pub span: Span,
                pub kind: GroupKind,
                pub ast: Box<Ast>,
            }

            impl Group 
            {
                pub fn flags( &self ) -> Option<&Flags> {
                    match self.kind {
                        GroupKind::NonCapturing(ref flags) => Some(flags),
                        _ => None,
                    }
                }

                pub fn is_capturing( &self ) -> bool {
                    match self.kind {
                        GroupKind::CaptureIndex(_) | GroupKind::CaptureName { .. } => true,
                        GroupKind::NonCapturing(_) => false,
                    }
                }
                
                pub fn capture_index( &self ) -> Option<u32> {
                    match self.kind {
                        GroupKind::CaptureIndex(i) => Some(i),
                        GroupKind::CaptureName { ref name, .. } => Some(name.index),
                        GroupKind::NonCapturing(_) => None,
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum GroupKind 
            {

                CaptureIndex(u32),
                CaptureName {

                    starts_with_p: bool,
                    name: CaptureName,
                },
                NonCapturing(Flags),
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct CaptureName 
            {

                pub span: Span,
                pub name: String,
                pub index: u32,
            }
            
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct SetFlags 
            {

                pub span: Span,
                pub flags: Flags,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Flags {

                pub span: Span,
                pub items: Vec<FlagsItem>,
            }

            impl Flags {
                pub fn add_item( &mut self, item: FlagsItem) -> Option<usize> {
                    for (i, x) in self.items.iter().enumerate() {
                        if x.kind == item.kind {
                            return Some(i);
                        }
                    }
                    self.items.push(item);
                    None
                }
                
                pub fn flag_state(&self, flag: Flag) -> Option<bool> {
                    let mut negated = false;
                    for x in &self.items {
                        match x.kind {
                            FlagsItemKind::Negation => { negated = true; }
                            FlagsItemKind::Flag(ref xflag) if xflag == &flag => { return Some(!negated); }
                            _ => {}
                        }
                    }
                    None
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct FlagsItem {

                pub span: Span,
                pub kind: FlagsItemKind,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum FlagsItemKind {
                Negation,
                Flag(Flag),
            }

            impl FlagsItemKind 
            {

                pub fn is_negation( &self ) -> bool {
                    match *self {
                        FlagsItemKind::Negation => true,
                        _ => false,
                    }
                }
            }

            #[derive(Clone, Copy, Debug, Eq, PartialEq )]
            pub enum Flag {

                CaseInsensitive,
                MultiLine,
                DotMatchesNewLine,
                SwapGreed,
                Unicode,
                CRLF,
                IgnoreWhitespace,
            }
            
            impl Drop for Ast {
                fn drop(&mut self) {
                    use ::mem;

                    match *self {
                        Ast::Empty(_)
                        | Ast::Flags(_)
                        | Ast::Literal(_)
                        | Ast::Dot(_)
                        | Ast::Assertion(_)
                        | Ast::ClassUnicode(_)
                        | Ast::ClassPerl(_)
                        // Bracketed classes are recursive, they get their own Drop impl.
                        | Ast::ClassBracketed(_) => return,
                        Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,
                        Ast::Group(ref x) if !x.ast.has_subexprs() => return,
                        Ast::Alternation(ref x) if x.asts.is_empty() => return,
                        Ast::Concat(ref x) if x.asts.is_empty() => return,
                        _ => {}
                    }

                    let empty_span = || Span::splat(Position::new(0, 0, 0));
                    let empty_ast = || Ast::empty(empty_span());
                    let mut stack = vec![mem::replace(self, empty_ast())];
                    while let Some(mut ast) = stack.pop() {
                        match ast {
                            Ast::Empty(_)
                            | Ast::Flags(_)
                            | Ast::Literal(_)
                            | Ast::Dot(_)
                            | Ast::Assertion(_)
                            | Ast::ClassUnicode(_)
                            | Ast::ClassPerl(_)
                            | Ast::ClassBracketed(_) => {}
                            Ast::Repetition(ref mut x) => { stack.push(mem::replace(&mut x.ast, empty_ast())); }
                            Ast::Group(ref mut x) => { stack.push(mem::replace(&mut x.ast, empty_ast())); }
                            Ast::Alternation(ref mut x) => { stack.extend(x.asts.drain(..)); }
                            Ast::Concat(ref mut x) => { stack.extend(x.asts.drain(..)); }
                        }
                    }
                }
            }
            
            impl Drop for ClassSet {
                fn drop(&mut self) {
                    use ::mem;

                    match *self {
                        ClassSet::Item(ref item) => match *item {
                            ClassSetItem::Empty(_)
                            | ClassSetItem::Literal(_)
                            | ClassSetItem::Range(_)
                            | ClassSetItem::Ascii(_)
                            | ClassSetItem::Unicode(_)
                            | ClassSetItem::Perl(_) => return,
                            ClassSetItem::Bracketed(ref x) => {
                                if x.kind.is_empty() {
                                    return;
                                }
                            }
                            ClassSetItem::Union(ref x) => {
                                if x.items.is_empty() {
                                    return;
                                }
                            }
                        },
                        ClassSet::BinaryOp(ref op) => {
                            if op.lhs.is_empty() && op.rhs.is_empty() {
                                return;
                            }
                        }
                    }

                    let empty_span = || Span::splat(Position::new(0, 0, 0));
                    let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));
                    let mut stack = vec![mem::replace(self, empty_set())];
                    while let Some(mut set) = stack.pop() {
                        match set {
                            ClassSet::Item(ref mut item) => match *item {
                                ClassSetItem::Empty(_)
                                | ClassSetItem::Literal(_)
                                | ClassSetItem::Range(_)
                                | ClassSetItem::Ascii(_)
                                | ClassSetItem::Unicode(_)
                                | ClassSetItem::Perl(_) => {}
                                ClassSetItem::Bracketed(ref mut x) => { stack.push(mem::replace(&mut x.kind, empty_set())); }
                                ClassSetItem::Union(ref mut x) => { stack.extend(x.items.drain(..).map(ClassSet::Item)); }
                            },
                            ClassSet::BinaryOp(ref mut op) => {
                                stack.push(mem::replace(&mut op.lhs, empty_set()));
                                stack.push(mem::replace(&mut op.rhs, empty_set()));
                            }
                        }
                    }
                }
            }

        }
    
        pub mod debug
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */

            pub struct Byte(pub u8);

            impl ::fmt::Debug for Byte
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    // be better...
                    if self.0 == b' ' {
                        return write!(f, "' '");
                    }
                    // 10 bytes is enough to cover any output from ascii::escape_default.
                    let mut bytes = [0u8; 10];
                    let mut len = 0;
                    for (i, mut b) in ::ascii::escape_default( self.0).enumerate() {
                        // capitalize \xab to \xAB
                        if i >= 2 && b'a' <= b && b <= b'f' {
                            b -= 32;
                        }
                        bytes[len] = b;
                        len += 1;
                    }
                    write!(f, "{}", ::str::from_utf8(&bytes[..len]).unwrap())
                }
            }


            pub struct Bytes<'a>(pub &'a [u8]);

            impl<'a> ::fmt::Debug for Bytes<'a>
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    write!(f, "\"")?;
                    let mut bytes = self.0;
                    while let Some(result) = utf8_decode(bytes) {
                        let ch = match result {
                            Ok(ch) => ch,
                            Err( byte ) => {
                                write!(f, r"\x{byte:02x}")?;
                                bytes = &bytes[1..];
                                continue;
                            }
                        };
                        bytes = &bytes[ch.len_utf8()..];
                        match ch {
                            '\0' => write!(f, "\\0")?,
                            // ASCII control characters except \0, \n, \r, \t
                            '\x01'..='\x08'
                            | '\x0b'
                            | '\x0c'
                            | '\x0e'..='\x19'
                            | '\x7f' => { write!(f, "\\x{:02x}", u32::from(ch))?; }
                            '\n' | '\r' | '\t' | _ => { write!(f, "{}", ch.escape_debug())?; }
                        }
                    }
                    write!(f, "\"")?;
                    Ok( () )
                }
            }


            pub fn utf8_decode(bytes: &[u8]) -> Option<Result<char, u8>> {
                fn len(byte: u8) -> Option<usize> {
                    if byte <= 0x7F {
                        return Some(1);
                    } else if byte & 0b1100_0000 == 0b1000_0000 {
                        return None;
                    } else if byte <= 0b1101_1111 {
                        Some(2)
                    } else if byte <= 0b1110_1111 {
                        Some(3)
                    } else if byte <= 0b1111_0111 {
                        Some(4)
                    } else {
                        None
                    }
                }

                if bytes.is_empty() {
                    return None;
                }
                let len = match len(bytes[0]) {
                    None => return Some(Err(bytes[0])),
                    Some(len) if len > bytes.len() => return Some(Err(bytes[0])),
                    Some(1) => return Some(Ok(char::from(bytes[0]))),
                    Some(len) => len,
                };
                match ::str::from_utf8(&bytes[..len]) {
                    Ok(s) => Some(Ok(s.chars().next().unwrap())),
                    Err(_) => Some(Err(bytes[0])),
                }
            }
        }
    
        pub mod either
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum Either<Left, Right> {
                Left(Left),
                Right(Right),
            }
        }
    
        pub mod error
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            use alloc::{
                format,
                string::{String, ToString},
                vec,
                vec::Vec,
            };

            use crate::{ast, hir};
            */

            #[non_exhaustive] #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum Error {
                Parse(ast::Error),
                Translate(hir::Error),
            }

            impl From<ast::Error> for Error {
                fn from(err: ast::Error) -> Error {
                    Error::Parse(err)
                }
            }

            impl From<hir::Error> for Error {
                fn from(err: hir::Error) -> Error {
                    Error::Translate(err)
                }
            }

                impl ::error::Error for Error {}

            impl ::fmt::Display for Error
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    match *self {
                        Error::Parse(ref x) => x.fmt(f),
                        Error::Translate(ref x) => x.fmt(f),
                    }
                }
            }
            
            #[derive( Debug )]
            pub struct Formatter<'e, E> {

                pattern: &'e str,
                err: &'e E,
                span: &'e ast::Span,
                aux_span:Option<&'e ast::Span>,
            }

            impl<'e> From<&'e ast::Error> for Formatter<'e, ast::ErrorKind> {
                fn from(err: &'e ast::Error) -> Self {
                    Formatter {
                        pattern: err.pattern(),
                        err: err.kind(),
                        span: err.span(),
                        aux_span: err.auxiliary_span(),
                    }
                }
            }

            impl<'e> From<&'e hir::Error> for Formatter<'e, hir::ErrorKind> {
                fn from(err: &'e hir::Error) -> Self {
                    Formatter {
                        pattern: err.pattern(),
                        err: err.kind(),
                        span: err.span(),
                        aux_span: None,
                    }
                }
            }

            impl<'e, E: ::fmt::Display> ::fmt::Display for Formatter<'e, E>
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    let spans = Spans::from_formatter(self);
                    if self.pattern.contains('\n') {
                        let divider = repeat_char('~', 79);

                        writeln!(f, "regex parse error:")?;
                        writeln!(f, "{divider}")?;
                        let notated = spans.notate();
                        write!(f, "{notated}")?;
                        writeln!(f, "{divider}")?;
                        if !spans.multi_line.is_empty() {
                            let mut notes = vec![];
                            for span in &spans.multi_line {
                                notes.push(format!(
                                    "on line {} (column {}) through line {} (column {})",
                                    span.start.line,
                                    span.start.column,
                                    span.end.line,
                                    span.end.column - 1
                                ));
                            }
                            writeln!(f, "{}", notes.join("\n"))?;
                        }
                        write!(f, "error: {}", self.err)?;
                    } else {
                        writeln!(f, "regex parse error:")?;
                        let notated = Spans::from_formatter(self).notate();
                        write!(f, "{notated}")?;
                        write!(f, "error: {}", self.err)?;
                    }
                    Ok( () )
                }
            }
            ///
            struct Spans<'p> {

                pattern: &'p str,
                line_number_width: usize,
                by_line: Vec<Vec<ast::Span>>,
                multi_line: Vec<ast::Span>,
            }

            impl<'p> Spans<'p> {
                fn from_formatter<'e, E: ::fmt::Display>(
                    fmter: &'p Formatter<'e, E>,
                ) -> Spans<'p> {
                    let mut line_count = fmter.pattern.lines().count();
                    if fmter.pattern.ends_with('\n') {
                        line_count += 1;
                    }
                    let line_number_width =
                        if line_count <= 1 { 0 } else { line_count.to_string().len() };
                    let mut spans = Spans {
                        pattern: &fmter.pattern,
                        line_number_width,
                        by_line: vec![vec![]; line_count],
                        multi_line: vec![],
                    };
                    spans.add(fmter.span.clone());
                    if let Some(span) = fmter.aux_span {
                        spans.add(span.clone());
                    }
                    spans
                }

                fn add( &mut self, span: ast::Span) {
                    if span.is_one_line() {
                        let i = span.start.line - 1; // because lines are 1-indexed
                        self.by_line[i].push(span);
                        self.by_line[i].sort();
                    } else {
                        self.multi_line.push(span);
                        self.multi_line.sort();
                    }
                }
                fn notate( &self ) -> String {
                    let mut notated = String::new();
                    for (i, line) in self.pattern.lines().enumerate() {
                        if self.line_number_width > 0 {
                            notated.push_str(&self.left_pad_line_number(i + 1));
                            notated.push_str(": ");
                        } else {
                            notated.push_str("    ");
                        }
                        notated.push_str(line);
                        notated.push('\n');
                        if let Some(notes) = self.notate_line(i) {
                            notated.push_str(&notes);
                            notated.push('\n');
                        }
                    }
                    notated
                }
                fn notate_line(&self, i: usize) -> Option<String> {
                    let spans = &self.by_line[i];
                    if spans.is_empty() {
                        return None;
                    }
                    let mut notes = String::new();
                    for _ in 0..self.line_number_padding() {
                        notes.push(' ');
                    }
                    let mut pos = 0;
                    for span in spans {
                        for _ in pos..(span.start.column - 1) {
                            notes.push(' ');
                            pos += 1;
                        }
                        let note_len = span.end.column.saturating_sub(span.start.column);
                        for _ in 0..core::cmp::max(1, note_len) {
                            notes.push('^');
                            pos += 1;
                        }
                    }
                    Some(notes)
                }
                fn left_pad_line_number(&self, n: usize) -> String {
                    let n = n.to_string();
                    let pad = self.line_number_width.checked_sub(n.len()).unwrap();
                    let mut result = repeat_char(' ', pad);
                    result.push_str(&n);
                    result
                }
                fn line_number_padding( &self ) -> usize {
                    if self.line_number_width == 0 {
                        4
                    } else {
                        2 + self.line_number_width
                    }
                }
            }

            fn repeat_char(c: char, count: usize) -> String {
                ::iter::repeat(c).take(count).collect()
            }

        }
    
        pub mod hir
        {
            /*!
            Defines a high-level intermediate (HIR) representation for regular expressions. */
            use ::
            {
                *,
            };
            /*
            use ::{char, cmp};

            use alloc::{
                boxed::Box,
                format,
                string::{String, ToString},
                vec,
                vec::Vec,
            };

            use crate::{
                ast::Span,
                hir::interval::{Interval, IntervalSet, IntervalSetIter},
                unicode,
            };

            pub use crate::{
                hir::visitor::{visit, Visitor},
                unicode::CaseFoldError,
            };
            */
            pub mod interval
            {
                /*!
                Contains an *internal* implementation of interval sets. */
                use ::
                {
                    *,
                };
                /*
                use ::{char, cmp, fmt::Debug, slice};
                use alloc::vec::Vec;
                use crate::unicode;
                */
                #[derive( Clone, Debug )]
                pub struct IntervalSet<I>
                {

                    ranges: Vec<I>,
                    folded: bool,
                }

                impl<I: Interval> Eq for IntervalSet<I> {}
                // strictly an optimization.
                impl<I: Interval> PartialEq for IntervalSet<I>
                {
                    fn eq(&self, other: &IntervalSet<I>) -> bool {
                        self.ranges.eq(&other.ranges)
                    }
                }

                impl<I: Interval> IntervalSet<I>
                {
                    pub fn new<T: IntoIterator<Item = I>>(intervals: T) -> IntervalSet<I>
                    {
                        let ranges: Vec<I> = intervals.into_iter().collect();
                        
                        let folded = ranges.is_empty();
                        let mut set = IntervalSet { ranges, folded };
                        set.canonicalize();
                        set
                    }

                    pub fn push( &mut self, interval: I) {
                        self.ranges.push(interval);
                        self.canonicalize();
                        self.folded = false;
                    }

                    pub fn iter( &self ) -> IntervalSetIter<'_, I> { IntervalSetIter( self.ranges.iter()) }

                    pub fn intervals( &self ) -> &[I] { &self.ranges }
                    
                    pub fn case_fold_simple(&mut self) -> Result<(), unicode::CaseFoldError> {
                        if self.folded {
                            return Ok( () );
                        }
                        let len = self.ranges.len();
                        for i in 0..len {
                            let range = self.ranges[i];
                            if let Err(err) = range.case_fold_simple(&mut self.ranges) {
                                self.canonicalize();
                                return Err(err);
                            }
                        }
                        self.canonicalize();
                        self.folded = true;
                        Ok( () )
                    }

                    pub fn union( &mut self, other: &IntervalSet<I>) {
                        if other.ranges.is_empty() || self.ranges == other.ranges { return; }
                        // This could almost certainly be done more efficiently.
                        self.ranges.extend(&other.ranges);
                        self.canonicalize();
                        self.folded = self.folded && other.folded;
                    }

                    pub fn intersect( &mut self, other: &IntervalSet<I>) {
                        if self.ranges.is_empty() { return; }
                        if other.ranges.is_empty() {
                            self.ranges.clear();
                            self.folded = true;
                            return;
                        }
                        let drain_end = self.ranges.len();

                        let mut ita = 0..drain_end;
                        let mut itb = 0..other.ranges.len();
                        let mut a = ita.next().unwrap();
                        let mut b = itb.next().unwrap();
                        loop {
                            if let Some(ab) = self.ranges[a].intersect(&other.ranges[b]) {
                                self.ranges.push(ab);
                            }
                            let (it, aorb) =
                                if self.ranges[a].upper() < other.ranges[b].upper() {
                                    (&mut ita, &mut a)
                                } else {
                                    (&mut itb, &mut b)
                                };
                            match it.next() {
                                Some(v) => *aorb = v,
                                None => break,
                            }
                        }
                        self.ranges.drain(..drain_end);
                        self.folded = self.folded && other.folded;
                    }

                    pub fn difference( &mut self, other: &IntervalSet<I>) {
                        if self.ranges.is_empty() || other.ranges.is_empty() { return; }
                        //
                        // Simplifications are most welcome!
                        //
                        // each class.
                        let drain_end = self.ranges.len();
                        let (mut a, mut b) = (0, 0);
                        'LOOP: while a < drain_end && b < other.ranges.len() {
                            // range, then we can skip it and move on.
                            if other.ranges[b].upper() < self.ranges[a].lower() {
                                b += 1;
                                continue;
                            }
                            if self.ranges[a].upper() < other.ranges[b].lower() {
                                let range = self.ranges[a];
                                self.ranges.push(range);
                                a += 1;
                                continue;
                            }
                            // Otherwise, we have overlapping ranges.
                            assert!(!self.ranges[a].is_intersection_empty(&other.ranges[b]));
                            //
                            // subtraction three times before moving on to the next `a` range.
                            let mut range = self.ranges[a];
                            while b < other.ranges.len()
                                && !range.is_intersection_empty(&other.ranges[b])
                            {
                                let old_range = range;
                                range = match range.difference(&other.ranges[b]) {
                                    (None, None) => {
                                        a += 1;
                                        continue 'LOOP;
                                    }
                                    (Some(range1), None) | (None, Some(range1)) => range1,
                                    (Some(range1), Some(range2)) => {
                                        self.ranges.push(range1);
                                        range2
                                    }
                                };
                                if other.ranges[b].upper() > old_range.upper() {
                                    break;
                                }
                                b += 1;
                            }
                            self.ranges.push(range);
                            a += 1;
                        }
                        while a < drain_end {
                            let range = self.ranges[a];
                            self.ranges.push(range);
                            a += 1;
                        }
                        self.ranges.drain(..drain_end);
                        self.folded = self.folded && other.folded;
                    }

                    pub fn symmetric_difference( &mut self, other: &IntervalSet<I>) {
                        // TODO(burntsushi): Fix this so that it amortizes allocation.
                        let mut intersection = self.clone();
                        intersection.intersect(other);
                        self.union(other);
                        self.difference(&intersection);
                    }
                    
                    pub fn negate(&mut self) {
                        if self.ranges.is_empty() {
                            let (min, max) = (I::Bound::min_value(), I::Bound::max_value());
                            self.ranges.push(I::create(min, max));
                            self.folded = true;
                            return;
                        }
                        let drain_end = self.ranges.len();
                        if self.ranges[0].lower() > I::Bound::min_value() {
                            let upper = self.ranges[0].lower().decrement();
                            self.ranges.push(I::create(I::Bound::min_value(), upper));
                        }
                        for i in 1..drain_end {
                            let lower = self.ranges[i - 1].upper().increment();
                            let upper = self.ranges[i].lower().decrement();
                            self.ranges.push(I::create(lower, upper));
                        }
                        if self.ranges[drain_end - 1].upper() < I::Bound::max_value() {
                            let lower = self.ranges[drain_end - 1].upper().increment();
                            self.ranges.push(I::create(lower, I::Bound::max_value()));
                        }
                        self.ranges.drain(..drain_end);
                        //
                    }

                    fn canonicalize(&mut self) {
                        if self.is_canonical() { return; }
                        self.ranges.sort();
                        assert!(!self.ranges.is_empty());
                        
                        let drain_end = self.ranges.len();
                        for oldi in 0..drain_end {
                            if self.ranges.len() > drain_end {
                                let (last, rest) = self.ranges.split_last_mut().unwrap();
                                if let Some(union) = last.union(&rest[oldi]) {
                                    *last = union;
                                    continue;
                                }
                            }
                            let range = self.ranges[oldi];
                            self.ranges.push(range);
                        }
                        self.ranges.drain(..drain_end);
                    }

                    fn is_canonical( &self ) -> bool {
                        for pair in self.ranges.windows(2) {
                            if pair[0] >= pair[1] {
                                return false;
                            }
                            if pair[0].is_contiguous(&pair[1]) {
                                return false;
                            }
                        }
                        true
                    }
                }

                #[derive( Debug )]
                pub struct IntervalSetIter<'a, I>(slice::Iter<'a, I>);

                impl<'a, I> Iterator for IntervalSetIter<'a, I> {
                    type Item = &'a I;

                    fn next(&mut self) -> Option<&'a I> { self.0.next() }
                }

                pub trait Interval:
                    Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord
                {
                    type Bound: Bound;

                    fn lower( &self ) -> Self::Bound;
                    fn upper( &self ) -> Self::Bound;
                    fn set_lower( &mut self, bound: Self::Bound);
                    fn set_upper( &mut self, bound: Self::Bound);
                    fn case_fold_simple(
                        &self,
                        intervals: &mut Vec<Self>,
                    ) -> Result<(), unicode::CaseFoldError>;

                    fn create(lower: Self::Bound, upper: Self::Bound) -> Self {
                        let mut int = Self::default();
                        if lower <= upper {
                            int.set_lower(lower);
                            int.set_upper(upper);
                        } else {
                            int.set_lower(upper);
                            int.set_upper(lower);
                        }
                        int
                    }

                    fn union(&self, other: &Self) -> Option<Self> {
                        if !self.is_contiguous(other) {
                            return None;
                        }
                        let lower = cmp::min( self.lower(), other.lower());
                        let upper = cmp::max( self.upper(), other.upper());
                        Some(Self::create(lower, upper))
                    }

                    fn intersect(&self, other: &Self) -> Option<Self>
                    {
                        let lower = cmp::max( self.lower(), other.lower());
                        let upper = cmp::min( self.upper(), other.upper());
                        if lower <= upper {
                            Some(Self::create(lower, upper))
                        } else {
                            None
                        }
                    }
                    fn difference(&self, other: &Self) -> (Option<Self>, Option<Self>) {
                        if self.is_subset(other) {
                            return (None, None);
                        }
                        if self.is_intersection_empty(other) {
                            return (Some( self.clone()), None);
                        }
                        let add_lower = other.lower() > self.lower();
                        let add_upper = other.upper() < self.upper();
                        assert!(add_lower || add_upper);
                        let mut ret = (None, None);
                        if add_lower {
                            let upper = other.lower().decrement();
                            ret.0 = Some(Self::create( self.lower(), upper));
                        }
                        if add_upper {
                            let lower = other.upper().increment();
                            let range = Self::create(lower, self.upper());
                            if ret.0.is_none() {
                                ret.0 = Some(range);
                            } else {
                                ret.1 = Some(range);
                            }
                        }
                        ret
                    }
                    fn is_contiguous(&self, other: &Self) -> bool {
                        let lower1 = self.lower().as_u32();
                        let upper1 = self.upper().as_u32();
                        let lower2 = other.lower().as_u32();
                        let upper2 = other.upper().as_u32();
                        cmp::max(lower1, lower2) <= cmp::min(upper1, upper2).saturating_add(1)
                    }
                    fn is_intersection_empty(&self, other: &Self) -> bool {
                        let (lower1, upper1) = ( self.lower(), self.upper());
                        let (lower2, upper2) = (other.lower(), other.upper());
                        cmp::max(lower1, lower2) > cmp::min(upper1, upper2)
                    }

                    fn is_subset(&self, other: &Self) -> bool {
                        let (lower1, upper1) = ( self.lower(), self.upper());
                        let (lower2, upper2) = (other.lower(), other.upper());
                        (lower2 <= lower1 && lower1 <= upper2)
                            && (lower2 <= upper1 && upper1 <= upper2)
                    }
                }

                pub trait Bound:
                    Copy + Clone + Debug + Eq + PartialEq + PartialOrd + Ord
               
                {
                    fn min_value() -> Self;
                    fn max_value() -> Self;
                    fn as_u32(self) -> u32;
                    fn increment(self) -> Self;
                    fn decrement(self) -> Self;
                }

                impl Bound for u8
                {
                    fn min_value() -> Self {
                        u8::MIN
                    }
                    fn max_value() -> Self {
                        u8::MAX
                    }
                    fn as_u32(self) -> u32 {
                        u32::from(self)
                    }
                    fn increment(self) -> Self {
                        self.checked_add(1).unwrap()
                    }
                    fn decrement(self) -> Self {
                        self.checked_sub(1).unwrap()
                    }
                }

                impl Bound for char
                {
                    fn min_value() -> Self {
                        '\x00'
                    }
                    fn max_value() -> Self {
                        '\u{10FFFF}'
                    }
                    fn as_u32(self) -> u32 {
                        u32::from(self)
                    }

                    fn increment(self) -> Self {
                        match self {
                            '\u{D7FF}' => '\u{E000}',
                            c => char::from_u32(u32::from(c).checked_add(1).unwrap()).unwrap(),
                        }
                    }

                    fn decrement(self) -> Self {
                        match self {
                            '\u{E000}' => '\u{D7FF}',
                            c => char::from_u32(u32::from(c).checked_sub(1).unwrap()).unwrap(),
                        }
                    }
                }
            }

            pub mod literal
            {
                /*!
                Provides literal extraction from `Hir` expressions. */
                use ::
                {
                    *,
                };
                /*
                use ::{cmp, mem, num::NonZeroUsize};

                use alloc::{vec, vec::Vec};

                use crate::hir::{self, Hir};
                */

                #[derive( Clone, Debug )]
                pub struct Extractor {
                    kind: ExtractKind,
                    limit_class: usize,
                    limit_repeat: usize,
                    limit_literal_len: usize,
                    limit_total: usize,
                }

                impl Extractor
                {
                    pub fn new() -> Extractor {
                        Extractor {
                            kind: ExtractKind::Prefix,
                            limit_class: 10,
                            limit_repeat: 10,
                            limit_literal_len: 100,
                            limit_total: 250,
                        }
                    }

                    pub fn extract(&self, hir: &Hir) -> Seq {
                        use crate::hir::HirKind::*;

                        match *hir.kind() {
                            Empty | Look(_) => Seq::singleton(self::Literal::exact(vec![])),
                            Literal(hir::Literal(ref bytes)) => {
                                let mut seq =
                                    Seq::singleton(self::Literal::exact(bytes.to_vec()));
                                self.enforce_literal_len(&mut seq);
                                seq
                            }
                            Class(hir::Class::Unicode(ref cls)) => { self.extract_class_unicode(cls) }
                            Class(hir::Class::Bytes(ref cls)) => self.extract_class_bytes(cls),
                            Repetition(ref rep) => self.extract_repetition(rep),
                            Capture(hir::Capture { ref sub, .. }) => self.extract(sub),
                            Concat(ref hirs) => match self.kind {
                                ExtractKind::Prefix => self.extract_concat(hirs.iter()),
                                ExtractKind::Suffix => self.extract_concat(hirs.iter().rev()),
                            },
                            Alternation(ref hirs) => { self.extract_alternation(hirs.iter()) }
                        }
                    }

                    pub fn kind( &mut self, kind: ExtractKind) -> &mut Extractor {
                        self.kind = kind;
                        self
                    }
                    
                    pub fn limit_class( &mut self, limit: usize) -> &mut Extractor {
                        self.limit_class = limit;
                        self
                    }
                    
                    pub fn limit_repeat( &mut self, limit: usize) -> &mut Extractor {
                        self.limit_repeat = limit;
                        self
                    }

                    pub fn limit_literal_len( &mut self, limit: usize) -> &mut Extractor {
                        self.limit_literal_len = limit;
                        self
                    }
                    
                    pub fn limit_total( &mut self, limit: usize) -> &mut Extractor {
                        self.limit_total = limit;
                        self
                    }

                    fn extract_concat<'a, I: Iterator<Item = &'a Hir>>(&self, it: I) -> Seq {
                        let mut seq = Seq::singleton(self::Literal::exact(vec![]));
                        for hir in it {
                            if seq.is_inexact() {
                                break;
                            }
                            seq = self.cross(seq, &mut self.extract(hir));
                        }
                        seq
                    }

                    fn extract_alternation<'a, I: Iterator<Item = &'a Hir>>(
                        &self,
                        it: I,
                    ) -> Seq {
                        let mut seq = Seq::empty();
                        for hir in it {
                            if !seq.is_finite() {
                                break;
                            }
                            seq = self.union(seq, &mut self.extract(hir));
                        }
                        seq
                    }

                    fn extract_repetition(&self, rep: &hir::Repetition) -> Seq {
                        let mut subseq = self.extract(&rep.sub);
                        match *rep {
                            hir::Repetition { min: 0, max, greedy, .. } => {
                                if max != Some(1) {
                                    subseq.make_inexact();
                                }
                                let mut empty = Seq::singleton(Literal::exact(vec![]));
                                if !greedy {
                                    mem::swap(&mut subseq, &mut empty);
                                }
                                self.union(subseq, &mut empty)
                            }
                            hir::Repetition { min, max: Some(max), .. } if min == max => {
                                assert!(min > 0);
                                let limit =
                                    u32::try_from( self.limit_repeat).unwrap_or(u32::MAX);
                                let mut seq = Seq::singleton(Literal::exact(vec![]));
                                for _ in 0..cmp::min(min, limit) {
                                    if seq.is_inexact() {
                                        break;
                                    }
                                    seq = self.cross(seq, &mut subseq.clone());
                                }
                                if usize::try_from(min).is_err() || min > limit {
                                    seq.make_inexact();
                                }
                                seq
                            }
                            hir::Repetition { min, .. } => {
                                assert!(min > 0);
                                let limit =
                                    u32::try_from( self.limit_repeat).unwrap_or(u32::MAX);
                                let mut seq = Seq::singleton(Literal::exact(vec![]));
                                for _ in 0..cmp::min(min, limit) {
                                    if seq.is_inexact() {
                                        break;
                                    }
                                    seq = self.cross(seq, &mut subseq.clone());
                                }
                                seq.make_inexact();
                                seq
                            }
                        }
                    }
                    fn extract_class_unicode(&self, cls: &hir::ClassUnicode) -> Seq {
                        if self.class_over_limit_unicode(cls) {
                            return Seq::infinite();
                        }
                        let mut seq = Seq::empty();
                        for r in cls.iter() {
                            for ch in r.start()..=r.end() {
                                seq.push(Literal::from(ch));
                            }
                        }
                        self.enforce_literal_len(&mut seq);
                        seq
                    }
                    fn extract_class_bytes(&self, cls: &hir::ClassBytes) -> Seq {
                        if self.class_over_limit_bytes(cls) {
                            return Seq::infinite();
                        }
                        let mut seq = Seq::empty();
                        for r in cls.iter() {
                            for b in r.start()..=r.end() {
                                seq.push(Literal::from(b));
                            }
                        }
                        self.enforce_literal_len(&mut seq);
                        seq
                    }
                    fn class_over_limit_unicode(&self, cls: &hir::ClassUnicode) -> bool {
                        let mut count = 0;
                        for r in cls.iter() {
                            if count > self.limit_class {
                                return true;
                            }
                            count += r.len();
                        }
                        count > self.limit_class
                    }
                    fn class_over_limit_bytes(&self, cls: &hir::ClassBytes) -> bool {
                        let mut count = 0;
                        for r in cls.iter() {
                            if count > self.limit_class {
                                return true;
                            }
                            count += r.len();
                        }
                        count > self.limit_class
                    }
                    fn cross(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {
                        if seq1.max_cross_len(seq2).map_or(false, |len| len > self.limit_total)
                        {
                            seq2.make_infinite();
                        }
                        if let ExtractKind::Suffix = self.kind {
                            seq1.cross_reverse(seq2);
                        } else {
                            seq1.cross_forward(seq2);
                        }
                        assert!(seq1.len().map_or(true, |x| x <= self.limit_total));
                        self.enforce_literal_len(&mut seq1);
                        seq1
                    }
                    fn union(&self, mut seq1: Seq, seq2: &mut Seq) -> Seq {
                        if seq1.max_union_len(seq2).map_or(false, |len| len > self.limit_total)
                        {
                            match self.kind {
                                ExtractKind::Prefix => {
                                    seq1.keep_first_bytes(4);
                                    seq2.keep_first_bytes(4);
                                }
                                ExtractKind::Suffix => {
                                    seq1.keep_last_bytes(4);
                                    seq2.keep_last_bytes(4);
                                }
                            }
                            seq1.dedup();
                            seq2.dedup();
                            if seq1
                                .max_union_len(seq2)
                                .map_or(false, |len| len > self.limit_total)
                            {
                                seq2.make_infinite();
                            }
                        }
                        seq1.union(seq2);
                        assert!(seq1.len().map_or(true, |x| x <= self.limit_total));
                        seq1
                    }
                    fn enforce_literal_len(&self, seq: &mut Seq) {
                        let len = self.limit_literal_len;
                        match self.kind {
                            ExtractKind::Prefix => seq.keep_first_bytes(len),
                            ExtractKind::Suffix => seq.keep_last_bytes(len),
                        }
                    }
                }

                impl Default for Extractor
                {
                    fn default() -> Extractor {
                        Extractor::new()
                    }
                }

                #[non_exhaustive] #[derive( Clone, Debug )]
                pub enum ExtractKind {

                    Prefix,
                    Suffix,
                }

                impl ExtractKind
                {
                    pub fn is_prefix( &self ) -> bool { matches!(*self, ExtractKind::Prefix) }

                    pub fn is_suffix( &self ) -> bool { matches!(*self, ExtractKind::Suffix) }
                }

                impl Default for ExtractKind
                {
                    fn default() -> ExtractKind {
                        ExtractKind::Prefix
                    }
                }
                ///
                #[derive(Clone, Eq, PartialEq)]
                pub struct Seq {
                    literals:Option<Vec<Literal>>,
                }

                impl Seq {
                    #[inline] pub fn empty() -> Seq {
                        Seq { literals: Some(vec![]) }
                    }
                    
                    #[inline] pub fn infinite() -> Seq {
                        Seq { literals: None }
                    }
                    #[inline] pub fn singleton(lit: Literal) -> Seq {
                        Seq { literals: Some(vec![lit]) }
                    }
                    #[inline] pub fn new<I, B>(it: I) -> Seq
                    where
                        I: IntoIterator<Item = B>,
                        B: AsRef<[u8]>,
                    {
                        it.into_iter().map(|b| Literal::exact(b.as_ref())).collect()
                    }
                    
                    #[inline] pub fn literals( &self ) -> Option<&[Literal]> { self.literals.as_deref() }
                    
                    #[inline] pub fn push( &mut self, lit: Literal) {
                        let lits = match self.literals {
                            None => return,
                            Some(ref mut lits) => lits,
                        };
                        if lits.last().map_or(false, |m| m == &lit) { return; }
                        lits.push(lit);
                    }
                    #[inline] pub fn make_inexact(&mut self) {
                        let lits = match self.literals {
                            None => return,
                            Some(ref mut lits) => lits,
                        };
                        for lit in lits.iter_mut() {
                            lit.make_inexact();
                        }
                    }
                    #[inline] pub fn make_infinite(&mut self) {
                        self.literals = None;
                    }
                    
                    #[inline] pub fn cross_forward( &mut self, other: &mut Seq) {
                        let (lits1, lits2) = match self.cross_preamble(other) {
                            None => return,
                            Some((lits1, lits2)) => (lits1, lits2),
                        };
                        let newcap = lits1.len().saturating_mul(lits2.len());
                        for selflit in mem::replace(lits1, Vec::with_capacity(newcap)) {
                            if !selflit.is_exact() {
                                lits1.push(selflit);
                                continue;
                            }
                            for otherlit in lits2.iter() {
                                let mut newlit = Literal::exact(Vec::with_capacity(
                                    selflit.len() + otherlit.len(),
                                ));
                                newlit.extend(&selflit);
                                newlit.extend(&otherlit);
                                if !otherlit.is_exact() {
                                    newlit.make_inexact();
                                }
                                lits1.push(newlit);
                            }
                        }
                        lits2.drain(..);
                        self.dedup();
                    }
                    
                    #[inline] pub fn cross_reverse( &mut self, other: &mut Seq) {
                        let (lits1, lits2) = match self.cross_preamble(other) {
                            None => return,
                            Some((lits1, lits2)) => (lits1, lits2),
                        };

                        let newcap = lits1.len().saturating_mul(lits2.len());
                        let selflits = mem::replace(lits1, Vec::with_capacity(newcap));
                        for (i, otherlit) in lits2.drain(..).enumerate() {
                            for selflit in selflits.iter() {
                                if !selflit.is_exact() {
                                    if i == 0 {
                                        lits1.push(selflit.clone());
                                    }
                                    continue;
                                }
                                let mut newlit = Literal::exact(Vec::with_capacity(
                                    otherlit.len() + selflit.len(),
                                ));
                                newlit.extend(&otherlit);
                                newlit.extend(&selflit);
                                if !otherlit.is_exact() {
                                    newlit.make_inexact();
                                }
                                lits1.push(newlit);
                            }
                        }
                        self.dedup();
                    }
                    fn cross_preamble<'a>(
                        &'a mut self,
                        other: &'a mut Seq,
                    ) -> Option<(&'a mut Vec<Literal>, &'a mut Vec<Literal>)>
                    {
                        let lits2 = match other.literals {
                            None => {
                                if self.min_literal_len() == Some(0) {
                                    *self = Seq::infinite();
                                } else {
                                    self.make_inexact();
                                }
                                return None;
                            }
                            Some(ref mut lits) => lits,
                        };
                        let lits1 = match self.literals {
                            None => {
                                lits2.drain(..);
                                return None;
                            }
                            Some(ref mut lits) => lits,
                        };
                        
                        Some( (lits1, lits2))
                    }
                    #[inline] pub fn union( &mut self, other: &mut Seq) {
                        let lits2 = match other.literals {
                            None => {
                                self.make_infinite();
                                return;
                            }
                            Some(ref mut lits) => lits.drain(..),
                        };
                        let lits1 = match self.literals {
                            None => return,
                            Some(ref mut lits) => lits,
                        };
                        lits1.extend(lits2);
                        self.dedup();
                    }
                    
                    #[inline] pub fn union_into_empty( &mut self, other: &mut Seq) {
                        let lits2 = other.literals.as_mut().map(|lits| lits.drain(..));
                        let lits1 = match self.literals {
                            None => return,
                            Some(ref mut lits) => lits,
                        };
                        let first_empty = match lits1.iter().position(|m| m.is_empty()) {
                            None => return,
                            Some(i) => i,
                        };
                        let lits2 = match lits2 {
                            None => {
                                self.literals = None;
                                return;
                            }
                            Some(lits) => lits,
                        };
                        lits1.retain(|m| !m.is_empty());
                        lits1.splice(first_empty..first_empty, lits2);
                        self.dedup();
                    }
                    #[inline] pub fn dedup(&mut self) {
                        if let Some(ref mut lits) = self.literals {
                            lits.dedup_by(|lit1, lit2| {
                                if lit1.as_bytes() != lit2.as_bytes() {
                                    return false;
                                }
                                if lit1.is_exact() != lit2.is_exact() {
                                    lit1.make_inexact();
                                    lit2.make_inexact();
                                }
                                true
                            });
                        }
                    }
                    #[inline] pub fn sort(&mut self) {
                        if let Some(ref mut lits) = self.literals {
                            lits.sort();
                        }
                    }
                    #[inline] pub fn reverse_literals(&mut self) {
                        if let Some(ref mut lits) = self.literals {
                            for lit in lits.iter_mut() {
                                lit.reverse();
                            }
                        }
                    }
                    
                    #[inline] pub fn minimize_by_preference(&mut self) {
                        if let Some(ref mut lits) = self.literals {
                            PreferenceTrie::minimize(lits, false);
                        }
                    }
                    
                    #[inline] pub fn keep_first_bytes( &mut self, len: usize) {
                        if let Some(ref mut lits) = self.literals {
                            for m in lits.iter_mut() {
                                m.keep_first_bytes(len);
                            }
                        }
                    }
                    
                    #[inline] pub fn keep_last_bytes( &mut self, len: usize) {
                        if let Some(ref mut lits) = self.literals {
                            for m in lits.iter_mut() {
                                m.keep_last_bytes(len);
                            }
                        }
                    }
                    #[inline] pub fn is_finite( &self ) -> bool { self.literals.is_some() }
                    #[inline] pub fn is_empty( &self ) -> bool { self.len() == Some(0) }
                    
                    #[inline] pub fn len( &self ) -> Option<usize> { self.literals.as_ref().map(|lits| lits.len()) }
                    #[inline] pub fn is_exact( &self ) -> bool { self.literals().map_or(false, |lits| lits.iter().all(|x| x.is_exact())) }
                    #[inline] pub fn is_inexact( &self ) -> bool { self.literals().map_or(true, |lits| lits.iter().all(|x| !x.is_exact())) }
                    
                    #[inline] pub fn max_union_len(&self, other: &Seq) -> Option<usize>
                    {
                        let len1 = self.len()?;
                        let len2 = other.len()?;
                        Some(len1.saturating_add(len2))
                    }
                    
                    #[inline] pub fn max_cross_len(&self, other: &Seq) -> Option<usize>
                    {
                        let len1 = self.len()?;
                        let len2 = other.len()?;
                        Some(len1.saturating_mul(len2))
                    }
                    #[inline] pub fn min_literal_len( &self ) -> Option<usize> { self.literals.as_ref()?.iter().map(|x| x.len()).min() }
                    #[inline] pub fn max_literal_len( &self ) -> Option<usize> { self.literals.as_ref()?.iter().map(|x| x.len()).max() }
                    
                    #[inline] pub fn longest_common_prefix( &self ) -> Option<&[u8]>
                    {
                        let lits = match self.literals {
                            None => return None,
                            Some(ref lits) => lits,
                        };
                        if lits.len() == 0 {
                            return None;
                        }
                        let base = lits[0].as_bytes();
                        let mut len = base.len();
                        for m in lits.iter().skip(1) {
                            len = m
                                .as_bytes()
                                .iter()
                                .zip(base[..len].iter())
                                .take_while(|&(a, b)| a == b)
                                .count();
                            if len == 0 {
                                return Some(&[]);
                            }
                        }
                        Some(&base[..len])
                    }
                    #[inline] pub fn longest_common_suffix( &self ) -> Option<&[u8]>
                    {
                        let lits = match self.literals {
                            None => return None,
                            Some(ref lits) => lits,
                        };
                        if lits.len() == 0 {
                            return None;
                        }
                        let base = lits[0].as_bytes();
                        let mut len = base.len();
                        for m in lits.iter().skip(1) {
                            len = m
                                .as_bytes()
                                .iter()
                                .rev()
                                .zip(base[base.len() - len..].iter().rev())
                                .take_while(|&(a, b)| a == b)
                                .count();
                            if len == 0 {
                                return Some(&[]);
                            }
                        }
                        Some(&base[base.len() - len..])
                    }
                    
                    #[inline] pub fn optimize_for_prefix_by_preference(&mut self) {
                        self.optimize_by_preference(true);
                    }
                    
                    #[inline] pub fn optimize_for_suffix_by_preference(&mut self) {
                        self.optimize_by_preference( false );
                    }

                    fn optimize_by_preference( &mut self, prefix:bool ) {
                        let origlen = match self.len() {
                            None => return,
                            Some(len) => len,
                        };
                        
                        if self.min_literal_len().map_or(false, |len| len == 0) {
                            self.make_infinite();
                            return;
                        }

                        if prefix {
                            if let Some(ref mut lits) = self.literals {
                                PreferenceTrie::minimize(lits, true);
                            }
                        }

                        let fix = if prefix {
                            self.longest_common_prefix()
                        } else {
                            self.longest_common_suffix()
                        };
                        if let Some(fix) = fix {
                            if prefix
                                && origlen > 1
                                && fix.len() >= 1
                                && fix.len() <= 3
                                && rank(fix[0]) < 200
                            {
                                self.keep_first_bytes(1);
                                self.dedup();
                                return;
                            }

                            let isfast =
                                self.is_exact() && self.len().map_or(false, |len| len <= 16);
                            let usefix = fix.len() > 4 || (fix.len() > 1 && !isfast);
                            if usefix {
                                if prefix {
                                    self.keep_first_bytes(fix.len());
                                } else {
                                    self.keep_last_bytes(fix.len());
                                }
                                self.dedup();
                                assert_eq!(Some(1), self.len());
                            }
                        }
                        
                        let exact:Option<Seq> =
                            if self.is_exact() { Some( self.clone()) } else { None };
                            
                        const ATTEMPTS: [(usize, usize); 5] =
                            [(5, 10), (4, 10), (3, 64), (2, 64), (1, 10)];
                        for (keep, limit) in ATTEMPTS {
                            let len = match self.len() {
                                None => break,
                                Some(len) => len,
                            };
                            if len <= limit {
                                break;
                            }
                            if prefix {
                                self.keep_first_bytes(keep);
                            } else {
                                self.keep_last_bytes(keep);
                            }
                            if prefix {
                                if let Some(ref mut lits) = self.literals {
                                    PreferenceTrie::minimize(lits, true);
                                }
                            }
                        }
                        
                        if let Some(lits) = self.literals() {
                            if lits.iter().any(|lit| lit.is_poisonous()) {
                                self.make_infinite();
                            }
                        }
                        
                        if let Some(exact) = exact {
                            if !self.is_finite() {
                                *self = exact;
                                return;
                            }
                            
                            if self.min_literal_len().map_or(true, |len| len <= 2) {
                                *self = exact;
                                return;
                            }
                            
                            if self.len().map_or(true, |len| len > 64) {
                                *self = exact;
                                return;
                            }
                        }
                    }
                }

                impl ::fmt::Debug for Seq
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result
                    {
                        write!(f, "Seq")?;
                        if let Some(lits) = self.literals() {
                            f.debug_list().entries(lits.iter()).finish()
                        } else {
                            write!(f, "[]")
                        }
                    }
                }

                impl FromIterator<Literal> for Seq
                {
                    fn from_iter<T: IntoIterator<Item = Literal>>(it: T) -> Seq {
                        let mut seq = Seq::empty();
                        for literal in it {
                            seq.push(literal);
                        }
                        seq
                    }
                }

                #[derive(Clone, Eq, PartialEq, PartialOrd, Ord)]
                pub struct Literal {
                    bytes: Vec<u8>,
                    exact: bool,
                }

                impl Literal {

                    #[inline] pub fn exact<B: Into<Vec<u8>>>(bytes: B) -> Literal {
                        Literal { bytes: bytes.into(), exact: true }
                    }
                    #[inline] pub fn inexact<B: Into<Vec<u8>>>(bytes: B) -> Literal {
                        Literal { bytes: bytes.into(), exact: false }
                    }
                    #[inline] pub fn as_bytes( &self ) -> &[u8] { &self.bytes }
                    #[inline] pub fn into_bytes(self) -> Vec<u8> { self.bytes }
                    #[inline] pub fn len( &self ) -> usize { self.as_bytes().len() }
                    #[inline] pub fn is_empty( &self ) -> bool { self.len() == 0 }
                    #[inline] pub fn is_exact( &self ) -> bool { self.exact }
                    
                    #[inline] pub fn make_inexact(&mut self) {
                        self.exact = false;
                    }
                    #[inline] pub fn reverse(&mut self) {
                        self.bytes.reverse();
                    }
                    #[inline] pub fn extend( &mut self, lit: &Literal) {
                        if !self.is_exact() { return; }
                        self.bytes.extend_from_slice(&lit.bytes);
                    }
                    
                    #[inline] pub fn keep_first_bytes( &mut self, len: usize) {
                        if len >= self.len() { return; }
                        self.make_inexact();
                        self.bytes.truncate(len);
                    }
                    
                    #[inline] pub fn keep_last_bytes( &mut self, len: usize) {
                        if len >= self.len() { return; }
                        self.make_inexact();
                        self.bytes.drain(..self.len() - len);
                    }
                    fn is_poisonous( &self ) -> bool { self.is_empty() || ( self.len() == 1 && rank( self.as_bytes()[0]) >= 250) }
                }

                impl From<u8> for Literal
                {
                    fn from(byte: u8) -> Literal {
                        Literal::exact(vec![byte])
                    }
                }

                impl From<char> for Literal
                {
                    fn from(ch: char) -> Literal {
                        use alloc::string::ToString;
                        Literal::exact(ch.encode_utf8(&mut [0; 4]).to_string())
                    }
                }

                impl AsRef<[u8]> for Literal
                {
                    fn as_ref( &self ) -> &[u8] { self.as_bytes() }
                }

                impl ::fmt::Debug for Literal
                {
                    fn fmt( &self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                        let tag = if self.exact { "E" } else { "I" };
                        f.debug_tuple(tag)
                            .field(&crate::debug::Bytes( self.as_bytes()))
                            .finish()
                    }
                }
                
                #[derive( Debug )]
                struct PreferenceTrie {

                    states: Vec<State>,
                    matches: Vec<Option<NonZeroUsize>>,
                    next_literal_index: usize,
                }

                #[derive(Debug, Default)]
                struct State {
                    trans: Vec<(u8, usize)>,
                }

                impl PreferenceTrie
                {
                    fn minimize(literals: &mut Vec<Literal>, keep_exact:bool ) {
                        let mut trie = PreferenceTrie {
                            states: vec![],
                            matches: vec![],
                            next_literal_index: 1,
                        };
                        let mut make_inexact = vec![];
                        literals.retain_mut(|lit| match trie.insert(lit.as_bytes()) {
                            Ok(_) => true,
                            Err(i) => {
                                if !keep_exact {
                                    make_inexact.push(i.checked_sub(1).unwrap());
                                }
                                false
                            }
                        });
                        for i in make_inexact {
                            literals[i].make_inexact();
                        }
                    }
                    ///
                    fn insert( &mut self, bytes: &[u8]) -> Result<usize, usize>
                    {
                        let mut prev = self.root();
                        if let Some(idx) = self.matches[prev] {
                            return Err(idx.get());
                        }
                        for &b in bytes.iter() {
                            match self.states[prev].trans.binary_search_by_key(&b, |t| t.0) {
                                Ok(i) => {
                                    prev = self.states[prev].trans[i].1;
                                    if let Some(idx) = self.matches[prev] {
                                        return Err(idx.get());
                                    }
                                }
                                Err(i) => {
                                    let next = self.create_state();
                                    self.states[prev].trans.insert(i, (b, next));
                                    prev = next;
                                }
                            }
                        }
                        let idx = self.next_literal_index;
                        self.next_literal_index += 1;
                        self.matches[prev] = NonZeroUsize::new(idx);
                        Ok(idx)
                    }

                    fn root(&mut self) -> usize {
                        if !self.states.is_empty() {
                            0
                        } else {
                            self.create_state()
                        }
                    }

                    fn create_state(&mut self) -> usize {
                        let id = self.states.len();
                        self.states.push(State::default());
                        self.matches.push( None );
                        id
                    }
                }

                pub fn rank(byte: u8) -> u8 {
                    crate::rank::BYTE_FREQUENCIES[usize::from( byte )]
                }
            }

            pub mod print
            {
                /*!
                This module provides a regular expression printer for `Hir`. */
                use ::
                {
                    *,
                };
                /*
                use ::fmt;

                use crate::{
                    hir::{
                        self,
                        visitor::{self, Visitor},
                        Hir, HirKind,
                    },
                    is_meta_character,
                };
                */

                #[derive( Clone, Debug )]
                struct PrinterBuilder {
                    _priv: (),
                }

                impl Default for PrinterBuilder
                {
                    fn default() -> PrinterBuilder {
                        PrinterBuilder::new()
                    }
                }

                impl PrinterBuilder
                {
                    fn new() -> PrinterBuilder {
                        PrinterBuilder { _priv: () }
                    }

                    fn build( &self ) -> Printer { Printer { _priv: () } }
                }
                
                #[derive( Debug )]
                pub struct Printer {
                    _priv: (),
                }

                impl Printer
                {
                    pub fn new() -> Printer {
                        PrinterBuilder::new().build()
                    }
                    
                    pub fn print<W: fmt::Write>( &mut self, hir: &Hir, wtr: W) -> fmt::Result {
                        visitor::visit(hir, Writer { wtr })
                    }
                }

                #[derive( Debug )]
                struct Writer<W> { wtr: W, }

                impl<W: fmt::Write> Visitor for Writer<W> {
                    type Output = ();
                    type Err = fmt::Error;

                    fn finish(self) -> fmt::Result {
                        Ok( () )
                    }

                    fn visit_pre( &mut self, hir: &Hir) -> fmt::Result {
                        match *hir.kind() {
                            HirKind::Empty => { self.wtr.write_str(r"(?:)")?; }
                            
                            HirKind::Repetition(_) => {}
                            HirKind::Literal(hir::Literal(ref bytes)) => {
                                let result = ::str::from_utf8(bytes);
                                let len = result.map_or(bytes.len(), |s| s.chars().count());
                                if len > 1 {
                                    self.wtr.write_str(r"(?:")?;
                                }
                                match result {
                                    Ok(string) => {
                                        for c in string.chars() {
                                            self.write_literal_char(c)?;
                                        }
                                    }
                                    Err(_) => {
                                        for &b in bytes.iter() {
                                            self.write_literal_byte(b)?;
                                        }
                                    }
                                }
                                if len > 1 {
                                    self.wtr.write_str(r")")?;
                                }
                            }
                            HirKind::Class(hir::Class::Unicode(ref cls)) => {
                                if cls.ranges().is_empty() {
                                    return self.wtr.write_str("[a&&b]");
                                }
                                self.wtr.write_str("[")?;
                                for range in cls.iter() {
                                    if range.start() == range.end() {
                                        self.write_literal_char(range.start())?;
                                    } else if u32::from(range.start()) + 1
                                        == u32::from(range.end())
                                    {
                                        self.write_literal_char(range.start())?;
                                        self.write_literal_char(range.end())?;
                                    } else {
                                        self.write_literal_char(range.start())?;
                                        self.wtr.write_str("-")?;
                                        self.write_literal_char(range.end())?;
                                    }
                                }
                                self.wtr.write_str("]")?;
                            }
                            HirKind::Class(hir::Class::Bytes(ref cls)) => {
                                if cls.ranges().is_empty() {
                                    return self.wtr.write_str("[a&&b]");
                                }
                                self.wtr.write_str("(?-u:[")?;
                                for range in cls.iter() {
                                    if range.start() == range.end() {
                                        self.write_literal_class_byte(range.start())?;
                                    } else if range.start() + 1 == range.end() {
                                        self.write_literal_class_byte(range.start())?;
                                        self.write_literal_class_byte(range.end())?;
                                    } else {
                                        self.write_literal_class_byte(range.start())?;
                                        self.wtr.write_str("-")?;
                                        self.write_literal_class_byte(range.end())?;
                                    }
                                }
                                self.wtr.write_str("])")?;
                            }
                            HirKind::Look(ref look) => match *look {
                                hir::Look::Start => { self.wtr.write_str(r"\A")?; }
                                hir::Look::End => { self.wtr.write_str(r"\z")?; }
                                hir::Look::StartLF => { self.wtr.write_str("(?m:^)")?; }
                                hir::Look::EndLF => { self.wtr.write_str("(?m:$)")?; }
                                hir::Look::StartCRLF => { self.wtr.write_str("(?mR:^)")?; }
                                hir::Look::EndCRLF => { self.wtr.write_str("(?mR:$)")?; }
                                hir::Look::WordAscii => { self.wtr.write_str(r"(?-u:\b)")?; }
                                hir::Look::WordAsciiNegate => { self.wtr.write_str(r"(?-u:\B)")?; }
                                hir::Look::WordUnicode => { self.wtr.write_str(r"\b")?; }
                                hir::Look::WordUnicodeNegate => { self.wtr.write_str(r"\B")?; }
                                hir::Look::WordStartAscii => { self.wtr.write_str(r"(?-u:\b{start})")?; }
                                hir::Look::WordEndAscii => { self.wtr.write_str(r"(?-u:\b{end})")?; }
                                hir::Look::WordStartUnicode => { self.wtr.write_str(r"\b{start}")?; }
                                hir::Look::WordEndUnicode => { self.wtr.write_str(r"\b{end}")?; }
                                hir::Look::WordStartHalfAscii => { self.wtr.write_str(r"(?-u:\b{start-half})")?; }
                                hir::Look::WordEndHalfAscii => { self.wtr.write_str(r"(?-u:\b{end-half})")?; }
                                hir::Look::WordStartHalfUnicode => { self.wtr.write_str(r"\b{start-half}")?; }
                                hir::Look::WordEndHalfUnicode => { self.wtr.write_str(r"\b{end-half}")?; }
                            },
                            HirKind::Capture(hir::Capture { ref name, .. }) => {
                                self.wtr.write_str("(")?;
                                if let Some(ref name) = *name {
                                    write!( self.wtr, "?P<{name}>")?;
                                }
                            }
                            
                            HirKind::Concat(_) | HirKind::Alternation(_) => { self.wtr.write_str(r"(?:")?; }
                        }
                        Ok( () )
                    }

                    fn visit_post( &mut self, hir: &Hir) -> fmt::Result {
                        match *hir.kind() {
                            // Handled during visit_pre
                            HirKind::Empty
                            | HirKind::Literal(_)
                            | HirKind::Class(_)
                            | HirKind::Look(_) => {}
                            HirKind::Repetition(ref x) => {
                                match (x.min, x.max) {
                                    (0, Some(1)) => { self.wtr.write_str("?")?; }
                                    (0, None) => { self.wtr.write_str("*")?; }
                                    (1, None) => { self.wtr.write_str("+")?; }
                                    (1, Some(1)) => {
                                        // 'a{1}' and 'a{1}?' are exactly equivalent to 'a'.
                                        return Ok( () );
                                    }
                                    (m, None) => { write!( self.wtr, "{{{m},}}")?; }
                                    (m, Some(n)) if m == n => {
                                        write!( self.wtr, "{{{m}}}")?;
                                        return Ok( () );
                                    }
                                    (m, Some(n)) => { write!( self.wtr, "{{{m},{n}}}")?; }
                                }
                                if !x.greedy {
                                    self.wtr.write_str("?")?;
                                }
                            }
                            HirKind::Capture(_)
                            | HirKind::Concat(_)
                            | HirKind::Alternation(_) => { self.wtr.write_str(r")")?; }
                        }
                        Ok( () )
                    }

                    fn visit_alternation_in(&mut self) -> fmt::Result {
                        self.wtr.write_str("|")
                    }
                }

                impl<W: fmt::Write> Writer<W>
                {
                    fn write_literal_char( &mut self, c: char) -> fmt::Result {
                        if is_meta_character(c) {
                            self.wtr.write_str("\\")?;
                        }
                        self.wtr.write_char(c)
                    }

                    fn write_literal_byte( &mut self, b: u8) -> fmt::Result {
                        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {
                            self.write_literal_char(char::try_from(b).unwrap())
                        } else {
                            write!( self.wtr, "(?-u:\\x{b:02X})")
                        }
                    }

                    fn write_literal_class_byte( &mut self, b: u8) -> fmt::Result {
                        if b <= 0x7F && !b.is_ascii_control() && !b.is_ascii_whitespace() {
                            self.write_literal_char(char::try_from(b).unwrap())
                        } else {
                            write!( self.wtr, "\\x{b:02X}")
                        }
                    }
                }
            }

            pub mod translate
            {
                /*!
                Defines a translator that converts an `Ast` to an `Hir`. */
                use ::
                {
                    *,
                };
                /*
                use ::cell::{Cell, RefCell};

                use alloc::{boxed::Box, string::ToString, vec, vec::Vec};

                use crate::{
                    ast::{self, Ast, Span, Visitor},
                    either::Either,
                    hir::{self, Error, ErrorKind, Hir, HirKind},
                    unicode::{self, ClassQuery},
                };
                */
                type Result<T> = ::result::Result<T, Error>;

                #[derive( Clone, Debug )]
                pub struct TranslatorBuilder {
                    utf8: bool,
                    line_terminator: u8,
                    flags: Flags,
                }

                impl Default for TranslatorBuilder
                {
                    fn default() -> TranslatorBuilder {
                        TranslatorBuilder::new()
                    }
                }

                impl TranslatorBuilder
                {
                    pub fn new() -> TranslatorBuilder {
                        TranslatorBuilder {
                            utf8: true,
                            line_terminator: b'\n',
                            flags: Flags::default(),
                        }
                    }

                    pub fn build( &self ) -> Translator {
                        Translator {
                            stack: RefCell::new(vec![]),
                            flags: Cell::new( self.flags),
                            utf8: self.utf8,
                            line_terminator: self.line_terminator,
                        }
                    }
                    
                    pub fn utf8( &mut self, yes:bool ) -> &mut TranslatorBuilder {
                        self.utf8 = yes;
                        self
                    }
                    
                    pub fn line_terminator( &mut self, byte: u8) -> &mut TranslatorBuilder {
                        self.line_terminator = byte;
                        self
                    }

                    pub fn case_insensitive( &mut self, yes:bool ) -> &mut TranslatorBuilder {
                        self.flags.case_insensitive = if yes { Some(true) } else { None };
                        self
                    }

                    pub fn multi_line( &mut self, yes:bool ) -> &mut TranslatorBuilder {
                        self.flags.multi_line = if yes { Some(true) } else { None };
                        self
                    }
                    
                    pub fn dot_matches_new_line(
                        &mut self,
                        yes: bool,
                    ) -> &mut TranslatorBuilder {
                        self.flags.dot_matches_new_line = if yes { Some(true) } else { None };
                        self
                    }

                    pub fn crlf( &mut self, yes:bool ) -> &mut TranslatorBuilder {
                        self.flags.crlf = if yes { Some(true) } else { None };
                        self
                    }

                    pub fn swap_greed( &mut self, yes:bool ) -> &mut TranslatorBuilder {
                        self.flags.swap_greed = if yes { Some(true) } else { None };
                        self
                    }

                    pub fn unicode( &mut self, yes:bool ) -> &mut TranslatorBuilder {
                        self.flags.unicode = if yes { None } else { Some( false ) };
                        self
                    }
                }
                
                #[derive( Clone, Debug )]
                pub struct Translator {

                    stack: RefCell<Vec<HirFrame>>,
                    flags: Cell<Flags>,
                    utf8: bool,
                    line_terminator: u8,
                }

                impl Translator
                {
                    pub fn new() -> Translator {
                        TranslatorBuilder::new().build()
                    }
                    
                    pub fn translate( &mut self, pattern: &str, ast: &Ast) -> Result<Hir> { ast::visit(ast, TranslatorI::new(self, pattern)) }
                }
                
                #[derive( Clone, Debug )]
                enum HirFrame {
                    Expr(Hir),
                    Literal(Vec<u8>),
                    ClassUnicode(hir::ClassUnicode),
                    ClassBytes(hir::ClassBytes),
                    Repetition,
                    Group {
                        old_flags: Flags,
                    },
                    Concat,
                    Alternation,
                    AlternationBranch,
                }

                impl HirFrame {

                    fn unwrap_expr(self) -> Hir {
                        match self {
                            HirFrame::Expr(expr) => expr,
                            HirFrame::Literal(lit) => Hir::literal(lit),
                            _ => panic!("tried to unwrap expr from HirFrame, got: {self:?}"),
                        }
                    }
                    fn unwrap_class_unicode(self) -> hir::ClassUnicode {
                        match self {
                            HirFrame::ClassUnicode(cls) => cls,
                            _ => panic!(
                                "tried to unwrap Unicode class \
                                from HirFrame, got: {:?}",
                                self
                            ),
                        }
                    }
                    fn unwrap_class_bytes(self) -> hir::ClassBytes {
                        match self {
                            HirFrame::ClassBytes(cls) => cls,
                            _ => panic!(
                                "tried to unwrap byte class \
                                from HirFrame, got: {:?}",
                                self
                            ),
                        }
                    }
                    fn unwrap_repetition(self) {
                        match self {
                            HirFrame::Repetition => {}
                            _ => {
                                panic!(
                                    "tried to unwrap repetition from HirFrame, got: {self:?}"
                                )
                            }
                        }
                    }
                    fn unwrap_group(self) -> Flags {
                        match self {
                            HirFrame::Group { old_flags } => old_flags,
                            _ => { panic!("tried to unwrap group from HirFrame, got: {self:?}") }
                        }
                    }
                    fn unwrap_alternation_pipe(self) {
                        match self {
                            HirFrame::AlternationBranch => {}
                            _ => { panic!("tried to unwrap alt pipe from HirFrame, got: {self:?}") }
                        }
                    }
                }

                impl<'t, 'p> Visitor for TranslatorI<'t, 'p> {
                    type Output = Hir;
                    type Err = Error;

                    fn finish(self) -> Result<Hir> {
                        // ... otherwise, we should have exactly one HIR on the stack.
                        assert_eq!( self.trans().stack.borrow().len(), 1);
                        Ok( self.pop().unwrap().unwrap_expr())
                    }

                    fn visit_pre( &mut self, ast: &Ast) -> Result<()> {
                        match *ast {
                            Ast::ClassBracketed(_) => {
                                if self.flags().unicode() {
                                    let cls = hir::ClassUnicode::empty();
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let cls = hir::ClassBytes::empty();
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            Ast::Repetition(_) => self.push(HirFrame::Repetition),
                            Ast::Group(ref x) => {
                                let old_flags = x
                                    .flags()
                                    .map(|ast| self.set_flags(ast))
                                    .unwrap_or_else(|| self.flags());
                                self.push(HirFrame::Group { old_flags });
                            }
                            Ast::Concat(_) => { self.push(HirFrame::Concat); }
                            Ast::Alternation(ref x) => {
                                self.push(HirFrame::Alternation);
                                if !x.asts.is_empty() {
                                    self.push(HirFrame::AlternationBranch);
                                }
                            }
                            _ => {}
                        }
                        Ok( () )
                    }

                    fn visit_post( &mut self, ast: &Ast) -> Result<()> {
                        match *ast {
                            Ast::Empty(_) => { self.push(HirFrame::Expr(Hir::empty())); }
                            Ast::Flags(ref x) => {
                                self.set_flags(&x.flags);
                                //
                                // consistency sake.
                                self.push(HirFrame::Expr(Hir::empty()));
                            }
                            Ast::Literal(ref x) => match self.ast_literal_to_scalar(x)? {
                                Either::Right( byte ) => self.push_byte( byte ),
                                Either::Left(ch) => match self.case_fold_char(x.span, ch)? {
                                    None => self.push_char(ch),
                                    Some(expr) => self.push(HirFrame::Expr(expr)),
                                },
                            },
                            Ast::Dot(ref span) => { self.push(HirFrame::Expr( self.hir_dot(**span)?)); }
                            Ast::Assertion(ref x) => { self.push(HirFrame::Expr( self.hir_assertion(x)?)); }
                            Ast::ClassPerl(ref x) => {
                                if self.flags().unicode() {
                                    let cls = self.hir_perl_unicode_class(x)?;
                                    let hcls = hir::Class::Unicode(cls);
                                    self.push(HirFrame::Expr(Hir::class(hcls)));
                                } else {
                                    let cls = self.hir_perl_byte_class(x)?;
                                    let hcls = hir::Class::Bytes(cls);
                                    self.push(HirFrame::Expr(Hir::class(hcls)));
                                }
                            }
                            Ast::ClassUnicode(ref x) => {
                                let cls = hir::Class::Unicode( self.hir_unicode_class(x)?);
                                self.push(HirFrame::Expr(Hir::class(cls)));
                            }
                            Ast::ClassBracketed(ref ast) => {
                                if self.flags().unicode() {
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    self.unicode_fold_and_negate(
                                        &ast.span,
                                        ast.negated,
                                        &mut cls,
                                    )?;
                                    let expr = Hir::class(hir::Class::Unicode(cls));
                                    self.push(HirFrame::Expr(expr));
                                } else {
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    self.bytes_fold_and_negate(
                                        &ast.span,
                                        ast.negated,
                                        &mut cls,
                                    )?;
                                    let expr = Hir::class(hir::Class::Bytes(cls));
                                    self.push(HirFrame::Expr(expr));
                                }
                            }
                            Ast::Repetition(ref x) => {
                                let expr = self.pop().unwrap().unwrap_expr();
                                self.pop().unwrap().unwrap_repetition();
                                self.push(HirFrame::Expr( self.hir_repetition(x, expr)));
                            }
                            Ast::Group(ref x) => {
                                let expr = self.pop().unwrap().unwrap_expr();
                                let old_flags = self.pop().unwrap().unwrap_group();
                                self.trans().flags.set(old_flags);
                                self.push(HirFrame::Expr( self.hir_capture(x, expr)));
                            }
                            Ast::Concat(_) => {
                                let mut exprs = vec![];
                                while let Some(expr) = self.pop_concat_expr() {
                                    if !matches!(*expr.kind(), HirKind::Empty) {
                                        exprs.push(expr);
                                    }
                                }
                                exprs.reverse();
                                self.push(HirFrame::Expr(Hir::concat(exprs)));
                            }
                            Ast::Alternation(_) => {
                                let mut exprs = vec![];
                                while let Some(expr) = self.pop_alt_expr() {
                                    self.pop().unwrap().unwrap_alternation_pipe();
                                    exprs.push(expr);
                                }
                                exprs.reverse();
                                self.push(HirFrame::Expr(Hir::alternation(exprs)));
                            }
                        }
                        Ok( () )
                    }

                    fn visit_alternation_in(&mut self) -> Result<()> {
                        self.push(HirFrame::AlternationBranch);
                        Ok( () )
                    }

                    fn visit_class_set_item_pre(
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<()> {
                        match *ast {
                            ast::ClassSetItem::Bracketed(_) => {
                                if self.flags().unicode() {
                                    let cls = hir::ClassUnicode::empty();
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let cls = hir::ClassBytes::empty();
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            _ => {}
                        }
                        Ok( () )
                    }

                    fn visit_class_set_item_post(
                        &mut self,
                        ast: &ast::ClassSetItem,
                    ) -> Result<()> {
                        match *ast {
                            ast::ClassSetItem::Empty(_) => {}
                            ast::ClassSetItem::Literal(ref x) => {
                                if self.flags().unicode() {
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    cls.push(hir::ClassUnicodeRange::new(x.c, x.c));
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    let byte = self.class_literal_byte(x)?;
                                    cls.push(hir::ClassBytesRange::new(byte, byte));
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            ast::ClassSetItem::Range(ref x) => {
                                if self.flags().unicode() {
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    cls.push(hir::ClassUnicodeRange::new(x.start.c, x.end.c));
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    let start = self.class_literal_byte(&x.start)?;
                                    let end = self.class_literal_byte(&x.end)?;
                                    cls.push(hir::ClassBytesRange::new(start, end));
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            ast::ClassSetItem::Ascii(ref x) => {
                                if self.flags().unicode() {
                                    let xcls = self.hir_ascii_unicode_class(x)?;
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    cls.union(&xcls);
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let xcls = self.hir_ascii_byte_class(x)?;
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    cls.union(&xcls);
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            ast::ClassSetItem::Unicode(ref x) => {
                                let xcls = self.hir_unicode_class(x)?;
                                let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                cls.union(&xcls);
                                self.push(HirFrame::ClassUnicode(cls));
                            }
                            ast::ClassSetItem::Perl(ref x) => {
                                if self.flags().unicode() {
                                    let xcls = self.hir_perl_unicode_class(x)?;
                                    let mut cls = self.pop().unwrap().unwrap_class_unicode();
                                    cls.union(&xcls);
                                    self.push(HirFrame::ClassUnicode(cls));
                                } else {
                                    let xcls = self.hir_perl_byte_class(x)?;
                                    let mut cls = self.pop().unwrap().unwrap_class_bytes();
                                    cls.union(&xcls);
                                    self.push(HirFrame::ClassBytes(cls));
                                }
                            }
                            ast::ClassSetItem::Bracketed(ref ast) => {
                                if self.flags().unicode() {
                                    let mut cls1 = self.pop().unwrap().unwrap_class_unicode();
                                    self.unicode_fold_and_negate(
                                        &ast.span,
                                        ast.negated,
                                        &mut cls1,
                                    )?;

                                    let mut cls2 = self.pop().unwrap().unwrap_class_unicode();
                                    cls2.union(&cls1);
                                    self.push(HirFrame::ClassUnicode(cls2));
                                } else {
                                    let mut cls1 = self.pop().unwrap().unwrap_class_bytes();
                                    self.bytes_fold_and_negate(
                                        &ast.span,
                                        ast.negated,
                                        &mut cls1,
                                    )?;

                                    let mut cls2 = self.pop().unwrap().unwrap_class_bytes();
                                    cls2.union(&cls1);
                                    self.push(HirFrame::ClassBytes(cls2));
                                }
                            }
                            // This is handled automatically by the visitor.
                            ast::ClassSetItem::Union(_) => {}
                        }
                        Ok( () )
                    }

                    fn visit_class_set_binary_op_pre(
                        &mut self,
                        _op: &ast::ClassSetBinaryOp,
                    ) -> Result<()> {
                        if self.flags().unicode() {
                            let cls = hir::ClassUnicode::empty();
                            self.push(HirFrame::ClassUnicode(cls));
                        } else {
                            let cls = hir::ClassBytes::empty();
                            self.push(HirFrame::ClassBytes(cls));
                        }
                        Ok( () )
                    }

                    fn visit_class_set_binary_op_in(
                        &mut self,
                        _op: &ast::ClassSetBinaryOp,
                    ) -> Result<()> {
                        if self.flags().unicode() {
                            let cls = hir::ClassUnicode::empty();
                            self.push(HirFrame::ClassUnicode(cls));
                        } else {
                            let cls = hir::ClassBytes::empty();
                            self.push(HirFrame::ClassBytes(cls));
                        }
                        Ok( () )
                    }

                    fn visit_class_set_binary_op_post(
                        &mut self,
                        op: &ast::ClassSetBinaryOp,
                    ) -> Result<()> {
                        use crate::ast::ClassSetBinaryOpKind::*;

                        if self.flags().unicode() {
                            let mut rhs = self.pop().unwrap().unwrap_class_unicode();
                            let mut lhs = self.pop().unwrap().unwrap_class_unicode();
                            let mut cls = self.pop().unwrap().unwrap_class_unicode();
                            if self.flags().case_insensitive() {
                                rhs.try_case_fold_simple().map_err(|_| {
                                    self.error(
                                        op.rhs.span().clone(),
                                        ErrorKind::UnicodeCaseUnavailable,
                                    )
                                })?;
                                lhs.try_case_fold_simple().map_err(|_| {
                                    self.error(
                                        op.lhs.span().clone(),
                                        ErrorKind::UnicodeCaseUnavailable,
                                    )
                                })?;
                            }
                            match op.kind {
                                Intersection => lhs.intersect(&rhs),
                                Difference => lhs.difference(&rhs),
                                SymmetricDifference => lhs.symmetric_difference(&rhs),
                            }
                            cls.union(&lhs);
                            self.push(HirFrame::ClassUnicode(cls));
                        } else {
                            let mut rhs = self.pop().unwrap().unwrap_class_bytes();
                            let mut lhs = self.pop().unwrap().unwrap_class_bytes();
                            let mut cls = self.pop().unwrap().unwrap_class_bytes();
                            if self.flags().case_insensitive() {
                                rhs.case_fold_simple();
                                lhs.case_fold_simple();
                            }
                            match op.kind {
                                Intersection => lhs.intersect(&rhs),
                                Difference => lhs.difference(&rhs),
                                SymmetricDifference => lhs.symmetric_difference(&rhs),
                            }
                            cls.union(&lhs);
                            self.push(HirFrame::ClassBytes(cls));
                        }
                        Ok( () )
                    }
                }

                #[derive( Clone, Debug )]
                struct TranslatorI<'t, 'p> {
                    trans: &'t Translator,
                    pattern: &'p str,
                }

                impl<'t, 'p> TranslatorI<'t, 'p> {

                    fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> { TranslatorI { trans, pattern } }

                    fn trans( &self ) -> &Translator { &self.trans }

                    fn push(&self, frame: HirFrame) {
                        self.trans().stack.borrow_mut().push(frame);
                    }

                    fn push_char(&self, ch: char) {
                        let mut buf = [0; 4];
                        let bytes = ch.encode_utf8(&mut buf).as_bytes();
                        let mut stack = self.trans().stack.borrow_mut();
                        if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {
                            literal.extend_from_slice(bytes);
                        } else {
                            stack.push(HirFrame::Literal(bytes.to_vec()));
                        }
                    }

                    fn push_byte(&self, byte: u8) {
                        let mut stack = self.trans().stack.borrow_mut();
                        if let Some(HirFrame::Literal(ref mut literal)) = stack.last_mut() {
                            literal.push( byte );
                        } else {
                            stack.push(HirFrame::Literal(vec![byte]));
                        }
                    }

                    fn pop( &self ) -> Option<HirFrame> { self.trans().stack.borrow_mut().pop() }
                    fn pop_concat_expr( &self ) -> Option<Hir>
                    {
                        let frame = self.pop()?;
                        match frame {
                            HirFrame::Concat => None,
                            HirFrame::Expr(expr) => Some(expr),
                            HirFrame::Literal(lit) => Some(Hir::literal(lit)),
                            HirFrame::ClassUnicode(_) => { unreachable!("expected expr or concat, got Unicode class") }
                            HirFrame::ClassBytes(_) => { unreachable!("expected expr or concat, got byte class") }
                            HirFrame::Repetition => { unreachable!("expected expr or concat, got repetition") }
                            HirFrame::Group { .. } => { unreachable!("expected expr or concat, got group") }
                            HirFrame::Alternation => { unreachable!("expected expr or concat, got alt marker") }
                            HirFrame::AlternationBranch => { unreachable!("expected expr or concat, got alt branch marker") }
                        }
                    }
                    fn pop_alt_expr( &self ) -> Option<Hir>
                    {
                        let frame = self.pop()?;
                        match frame {
                            HirFrame::Alternation => None,
                            HirFrame::Expr(expr) => Some(expr),
                            HirFrame::Literal(lit) => Some(Hir::literal(lit)),
                            HirFrame::ClassUnicode(_) => { unreachable!("expected expr or alt, got Unicode class") }
                            HirFrame::ClassBytes(_) => { unreachable!("expected expr or alt, got byte class") }
                            HirFrame::Repetition => { unreachable!("expected expr or alt, got repetition") }
                            HirFrame::Group { .. } => { unreachable!("expected expr or alt, got group") }
                            HirFrame::Concat => { unreachable!("expected expr or alt, got concat marker") }
                            HirFrame::AlternationBranch => { unreachable!("expected expr or alt, got alt branch marker") }
                        }
                    }

                    fn error(&self, span: Span, kind: ErrorKind) -> Error {
                        Error { kind, pattern: self.pattern.to_string(), span }
                    }

                    fn flags( &self ) -> Flags { self.trans().flags.get() }
                    fn set_flags(&self, ast_flags: &ast::Flags) -> Flags {
                        let old_flags = self.flags();
                        let mut new_flags = Flags::from_ast(ast_flags);
                        new_flags.merge(&old_flags);
                        self.trans().flags.set(new_flags);
                        old_flags
                    }

                    fn ast_literal_to_scalar(
                        &self,
                        lit: &ast::Literal,
                    ) -> Result<Either<char, u8>> {
                        if self.flags().unicode() {
                            return Ok(Either::Left(lit.c));
                        }
                        let byte = match lit.byte() {
                            None => return Ok(Either::Left(lit.c)),
                            Some( byte ) => byte,
                        };
                        if byte <= 0x7F {
                            return Ok(Either::Left(char::try_from( byte ).unwrap()));
                        }
                        if self.trans().utf8 {
                            return Err( self.error(lit.span, ErrorKind::InvalidUtf8));
                        }
                        Ok(Either::Right( byte ))
                    }

                    fn case_fold_char(&self, span: Span, c: char) -> Result<Option<Hir>> {
                        if !self.flags().case_insensitive() {
                            return Ok( None );
                        }
                        if self.flags().unicode() {
                            // If case folding won't do anything, then don't bother trying.
                            let map = unicode::SimpleCaseFolder::new()
                                .map(|f| f.overlaps(c, c))
                                .map_err(|_| {
                                    self.error(span, ErrorKind::UnicodeCaseUnavailable)
                                })?;
                            if !map {
                                return Ok( None );
                            }
                            let mut cls =
                                hir::ClassUnicode::new(vec![hir::ClassUnicodeRange::new(
                                    c, c,
                                )]);
                            cls.try_case_fold_simple().map_err(|_| {
                                self.error(span, ErrorKind::UnicodeCaseUnavailable)
                            })?;
                            Ok(Some(Hir::class(hir::Class::Unicode(cls))))
                        } else {
                            if !c.is_ascii() {
                                return Ok( None );
                            }
                            // If case folding won't do anything, then don't bother trying.
                            match c {
                                'A'..='Z' | 'a'..='z' => {}
                                _ => return Ok( None ),
                            }
                            let mut cls =
                                hir::ClassBytes::new(vec![hir::ClassBytesRange::new(
                                    u8::try_from(c).unwrap(),
                                    u8::try_from(c).unwrap(),
                                )]);
                            cls.case_fold_simple();
                            Ok(Some(Hir::class(hir::Class::Bytes(cls))))
                        }
                    }

                    fn hir_dot(&self, span: Span) -> Result<Hir>
                    {
                        let (utf8, lineterm, flags) =
                            ( self.trans().utf8, self.trans().line_terminator, self.flags());
                        if utf8 && (!flags.unicode() || !lineterm.is_ascii()) {
                            return Err( self.error(span, ErrorKind::InvalidUtf8));
                        }
                        let dot = if flags.dot_matches_new_line() {
                            if flags.unicode() {
                                hir::Dot::AnyChar
                            } else {
                                hir::Dot::AnyByte
                            }
                        } else {
                            if flags.unicode() {
                                if flags.crlf() {
                                    hir::Dot::AnyCharExceptCRLF
                                } else {
                                    if !lineterm.is_ascii() {
                                        return Err(
                                            self.error(span, ErrorKind::InvalidLineTerminator)
                                        );
                                    }
                                    hir::Dot::AnyCharExcept(char::from(lineterm))
                                }
                            } else {
                                if flags.crlf() {
                                    hir::Dot::AnyByteExceptCRLF
                                } else {
                                    hir::Dot::AnyByteExcept(lineterm)
                                }
                            }
                        };
                        Ok(Hir::dot(dot))
                    }

                    fn hir_assertion(&self, asst: &ast::Assertion) -> Result<Hir>
                    {
                        let unicode = self.flags().unicode();
                        let multi_line = self.flags().multi_line();
                        let crlf = self.flags().crlf();
                        Ok(match asst.kind {
                            ast::AssertionKind::StartLine => Hir::look(if multi_line {
                                if crlf {
                                    hir::Look::StartCRLF
                                } else {
                                    hir::Look::StartLF
                                }
                            } else {
                                hir::Look::Start
                            }),
                            ast::AssertionKind::EndLine => Hir::look(if multi_line {
                                if crlf {
                                    hir::Look::EndCRLF
                                } else {
                                    hir::Look::EndLF
                                }
                            } else {
                                hir::Look::End
                            }),
                            ast::AssertionKind::StartText => Hir::look(hir::Look::Start),
                            ast::AssertionKind::EndText => Hir::look(hir::Look::End),
                            ast::AssertionKind::WordBoundary => Hir::look(if unicode {
                                hir::Look::WordUnicode
                            } else {
                                hir::Look::WordAscii
                            }),
                            ast::AssertionKind::NotWordBoundary => Hir::look(if unicode {
                                hir::Look::WordUnicodeNegate
                            } else {
                                hir::Look::WordAsciiNegate
                            }),
                            ast::AssertionKind::WordBoundaryStart
                            | ast::AssertionKind::WordBoundaryStartAngle => {
                                Hir::look(if unicode {
                                    hir::Look::WordStartUnicode
                                } else {
                                    hir::Look::WordStartAscii
                                })
                            }
                            ast::AssertionKind::WordBoundaryEnd
                            | ast::AssertionKind::WordBoundaryEndAngle => {
                                Hir::look(if unicode {
                                    hir::Look::WordEndUnicode
                                } else {
                                    hir::Look::WordEndAscii
                                })
                            }
                            ast::AssertionKind::WordBoundaryStartHalf => {
                                Hir::look(if unicode {
                                    hir::Look::WordStartHalfUnicode
                                } else {
                                    hir::Look::WordStartHalfAscii
                                })
                            }
                            ast::AssertionKind::WordBoundaryEndHalf => Hir::look(if unicode {
                                hir::Look::WordEndHalfUnicode
                            } else {
                                hir::Look::WordEndHalfAscii
                            }),
                        })
                    }

                    fn hir_capture(&self, group: &ast::Group, expr: Hir) -> Hir {
                        let (index, name) = match group.kind {
                            ast::GroupKind::CaptureIndex(index) => (index, None),
                            ast::GroupKind::CaptureName { ref name, .. } => { (name.index, Some(name.name.clone().into_boxed_str())) }
                            ast::GroupKind::NonCapturing(_) => return expr,
                        };
                        Hir::capture(hir::Capture { index, name, sub: Box::new(expr) })
                    }

                    fn hir_repetition(&self, rep: &ast::Repetition, expr: Hir) -> Hir {
                        let (min, max) = match rep.op.kind {
                            ast::RepetitionKind::ZeroOrOne => (0, Some(1)),
                            ast::RepetitionKind::ZeroOrMore => (0, None),
                            ast::RepetitionKind::OneOrMore => (1, None),
                            ast::RepetitionKind::Range(ast::RepetitionRange::Exactly(m)) => { (m, Some(m)) }
                            ast::RepetitionKind::Range(ast::RepetitionRange::AtLeast(m)) => { (m, None) }
                            ast::RepetitionKind::Range(ast::RepetitionRange::Bounded(
                                m,
                                n,
                            )) => (m, Some(n)),
                        };
                        let greedy =
                            if self.flags().swap_greed() { !rep.greedy } else { rep.greedy };
                        Hir::repetition(hir::Repetition {
                            min,
                            max,
                            greedy,
                            sub: Box::new(expr),
                        })
                    }

                    fn hir_unicode_class(
                        &self,
                        ast_class: &ast::ClassUnicode,
                    ) -> Result<hir::ClassUnicode> {
                        use crate::ast::ClassUnicodeKind::*;

                        if !self.flags().unicode() {
                            return Err(
                                self.error(ast_class.span, ErrorKind::UnicodeNotAllowed)
                            );
                        }
                        let query = match ast_class.kind {
                            OneLetter(name) => ClassQuery::OneLetter(name),
                            Named(ref name) => ClassQuery::Binary(name),
                            NamedValue { ref name, ref value, .. } => ClassQuery::ByValue {
                                property_name: name,
                                property_value: value,
                            },
                        };
                        let mut result = self.convert_unicode_class_error(
                            &ast_class.span,
                            unicode::class(query),
                        );
                        if let Ok(ref mut class) = result {
                            self.unicode_fold_and_negate(
                                &ast_class.span,
                                ast_class.negated,
                                class,
                            )?;
                        }
                        result
                    }

                    fn hir_ascii_unicode_class(
                        &self,
                        ast: &ast::ClassAscii,
                    ) -> Result<hir::ClassUnicode>
                    {
                        let mut cls = hir::ClassUnicode::new(
                            ascii_class_as_chars(&ast.kind)
                                .map(|(s, e)| hir::ClassUnicodeRange::new(s, e)),
                        );
                        self.unicode_fold_and_negate(&ast.span, ast.negated, &mut cls)?;
                        Ok(cls)
                    }

                    fn hir_ascii_byte_class(
                        &self,
                        ast: &ast::ClassAscii,
                    ) -> Result<hir::ClassBytes>
                    {
                        let mut cls = hir::ClassBytes::new(
                            ascii_class(&ast.kind)
                                .map(|(s, e)| hir::ClassBytesRange::new(s, e)),
                        );
                        self.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls)?;
                        Ok(cls)
                    }

                    fn hir_perl_unicode_class(
                        &self,
                        ast_class: &ast::ClassPerl,
                    ) -> Result<hir::ClassUnicode> {
                        use crate::ast::ClassPerlKind::*;

                        assert!( self.flags().unicode());
                        let result = match ast_class.kind {
                            Digit => unicode::perl_digit(),
                            Space => unicode::perl_space(),
                            Word => unicode::perl_word(),
                        };
                        let mut class =
                            self.convert_unicode_class_error(&ast_class.span, result)?;
                        if ast_class.negated {
                            class.negate();
                        }
                        Ok(class)
                    }

                    fn hir_perl_byte_class(
                        &self,
                        ast_class: &ast::ClassPerl,
                    ) -> Result<hir::ClassBytes> {
                        use crate::ast::ClassPerlKind::*;

                        assert!(!self.flags().unicode());
                        let mut class = match ast_class.kind {
                            Digit => hir_ascii_class_bytes(&ast::ClassAsciiKind::Digit),
                            Space => hir_ascii_class_bytes(&ast::ClassAsciiKind::Space),
                            Word => hir_ascii_class_bytes(&ast::ClassAsciiKind::Word),
                        };
                        if ast_class.negated {
                            class.negate();
                        }

                        if self.trans().utf8 && !class.is_ascii() {
                            return Err( self.error(ast_class.span, ErrorKind::InvalidUtf8));
                        }
                        Ok(class)
                    }
                    fn convert_unicode_class_error(
                        &self,
                        span: &Span,
                        result: ::result::Result<hir::ClassUnicode, unicode::Error>,
                    ) -> Result<hir::ClassUnicode> {
                        result.map_err(|err| {
                            let sp = span.clone();
                            match err {
                                unicode::Error::PropertyNotFound => { self.error(sp, ErrorKind::UnicodePropertyNotFound) }
                                unicode::Error::PropertyValueNotFound => { self.error(sp, ErrorKind::UnicodePropertyValueNotFound) }
                                unicode::Error::PerlClassNotFound => { self.error(sp, ErrorKind::UnicodePerlClassNotFound) }
                            }
                        })
                    }

                    fn unicode_fold_and_negate(
                        &self,
                        span: &Span,
                        negated: bool,
                        class: &mut hir::ClassUnicode,
                    ) -> Result<()> {
                        if self.flags().case_insensitive() {
                            class.try_case_fold_simple().map_err(|_| {
                                self.error(span.clone(), ErrorKind::UnicodeCaseUnavailable)
                            })?;
                        }
                        if negated {
                            class.negate();
                        }
                        Ok( () )
                    }

                    fn bytes_fold_and_negate(
                        &self,
                        span: &Span,
                        negated: bool,
                        class: &mut hir::ClassBytes,
                    ) -> Result<()> {
                        if self.flags().case_insensitive() {
                            class.case_fold_simple();
                        }
                        if negated {
                            class.negate();
                        }
                        if self.trans().utf8 && !class.is_ascii() {
                            return Err( self.error(span.clone(), ErrorKind::InvalidUtf8));
                        }
                        Ok( () )
                    }
                    fn class_literal_byte(&self, ast: &ast::Literal) -> Result<u8> {
                        match self.ast_literal_to_scalar(ast)? {
                            Either::Right( byte ) => Ok( byte ),
                            Either::Left(ch) => {
                                if ch.is_ascii() {
                                    Ok(u8::try_from(ch).unwrap())
                                } else {
                                    // do Unicode case folding.
                                    Err( self.error(ast.span, ErrorKind::UnicodeNotAllowed))
                                }
                            }
                        }
                    }
                }
                
                #[derive(Clone, Copy, Debug, Default)]
                struct Flags {
                    case_insensitive:Option<bool>,
                    multi_line:Option<bool>,
                    dot_matches_new_line:Option<bool>,
                    swap_greed:Option<bool>,
                    unicode:Option<bool>,
                    crlf:Option<bool>,
                }

                impl Flags
                {
                    fn from_ast(ast: &ast::Flags) -> Flags {
                        let mut flags = Flags::default();
                        let mut enable = true;
                        for item in &ast.items {
                            match item.kind {
                                ast::FlagsItemKind::Negation => { enable = false; }
                                ast::FlagsItemKind::Flag(ast::Flag::CaseInsensitive) => { flags.case_insensitive = Some(enable); }
                                ast::FlagsItemKind::Flag(ast::Flag::MultiLine) => { flags.multi_line = Some(enable); }
                                ast::FlagsItemKind::Flag(ast::Flag::DotMatchesNewLine) => { flags.dot_matches_new_line = Some(enable); }
                                ast::FlagsItemKind::Flag(ast::Flag::SwapGreed) => { flags.swap_greed = Some(enable); }
                                ast::FlagsItemKind::Flag(ast::Flag::Unicode) => { flags.unicode = Some(enable); }
                                ast::FlagsItemKind::Flag(ast::Flag::CRLF) => { flags.crlf = Some(enable); }
                                ast::FlagsItemKind::Flag(ast::Flag::IgnoreWhitespace) => {}
                            }
                        }
                        flags
                    }

                    fn merge( &mut self, previous: &Flags) {
                        if self.case_insensitive.is_none() {
                            self.case_insensitive = previous.case_insensitive;
                        }
                        if self.multi_line.is_none() {
                            self.multi_line = previous.multi_line;
                        }
                        if self.dot_matches_new_line.is_none() {
                            self.dot_matches_new_line = previous.dot_matches_new_line;
                        }
                        if self.swap_greed.is_none() {
                            self.swap_greed = previous.swap_greed;
                        }
                        if self.unicode.is_none() {
                            self.unicode = previous.unicode;
                        }
                        if self.crlf.is_none() {
                            self.crlf = previous.crlf;
                        }
                    }

                    fn case_insensitive( &self ) -> bool { self.case_insensitive.unwrap_or( false ) }

                    fn multi_line( &self ) -> bool { self.multi_line.unwrap_or( false ) }

                    fn dot_matches_new_line( &self ) -> bool { self.dot_matches_new_line.unwrap_or( false ) }

                    fn swap_greed( &self ) -> bool { self.swap_greed.unwrap_or( false ) }

                    fn unicode( &self ) -> bool { self.unicode.unwrap_or(true) }

                    fn crlf( &self ) -> bool { self.crlf.unwrap_or( false ) }
                }

                fn hir_ascii_class_bytes(kind: &ast::ClassAsciiKind) -> hir::ClassBytes {
                    let ranges: Vec<_> = ascii_class(kind)
                        .map(|(s, e)| hir::ClassBytesRange::new(s, e))
                        .collect();
                    hir::ClassBytes::new(ranges)
                }

                fn ascii_class(kind: &ast::ClassAsciiKind) -> impl Iterator<Item = (u8, u8)> {
                    use crate::ast::ClassAsciiKind::*;

                    let slice:&'static [(u8, u8)] = match *kind {
                        Alnum => &[(b'0', b'9'), (b'A', b'Z'), (b'a', b'z')],
                        Alpha => &[(b'A', b'Z'), (b'a', b'z')],
                        Ascii => &[(b'\x00', b'\x7F')],
                        Blank => &[(b'\t', b'\t'), (b' ', b' ')],
                        Cntrl => &[(b'\x00', b'\x1F'), (b'\x7F', b'\x7F')],
                        Digit => &[(b'0', b'9')],
                        Graph => &[(b'!', b'~')],
                        Lower => &[(b'a', b'z')],
                        Print => &[(b' ', b'~')],
                        Punct => &[(b'!', b'/'), (b':', b'@'), (b'[', b'`'), (b'{', b'~')],
                        Space => &[
                            (b'\t', b'\t'),
                            (b'\n', b'\n'),
                            (b'\x0B', b'\x0B'),
                            (b'\x0C', b'\x0C'),
                            (b'\r', b'\r'),
                            (b' ', b' '),
                        ],
                        Upper => &[(b'A', b'Z')],
                        Word => &[(b'0', b'9'), (b'A', b'Z'), (b'_', b'_'), (b'a', b'z')],
                        Xdigit => &[(b'0', b'9'), (b'A', b'F'), (b'a', b'f')],
                    };
                    slice.iter().copied()
                }

                fn ascii_class_as_chars(
                    kind: &ast::ClassAsciiKind,
                ) -> impl Iterator<Item = (char, char)> { ascii_class(kind).map(|(s, e)| (char::from(s), char::from(e))) }
            }

            pub mod visitor
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                use alloc::{vec, vec::Vec};
                use crate::hir::{self, Hir, HirKind};
                */

                pub trait Visitor {

                    type Output;

                    type Err;
                    fn finish(self) -> Result<Self::Output, Self::Err>;

                    fn start(&mut self) {}
                    fn visit_pre( &mut self, _hir: &Hir) -> Result<(), Self::Err> { Ok( () ) }
                    fn visit_post( &mut self, _hir: &Hir) -> Result<(), Self::Err> { Ok( () ) }

                    fn visit_alternation_in(&mut self) -> Result<(), Self::Err> { Ok( () ) }

                    fn visit_concat_in(&mut self) -> Result<(), Self::Err> { Ok( () ) }
                }

                pub fn visit<V: Visitor>(hir: &Hir, visitor: V) -> Result<V::Output, V::Err> { HeapVisitor::new().visit(hir, visitor) }
                struct HeapVisitor<'a> { stack: Vec<(&'a Hir, Frame<'a>)>, }
                enum Frame<'a> {
                    Repetition(&'a hir::Repetition),
                    Capture(&'a hir::Capture),
                    Concat {

                        head: &'a Hir,
                        tail: &'a [Hir],
                    },
                    Alternation {

                        head: &'a Hir,
                        tail: &'a [Hir],
                    },
                }

                impl<'a> HeapVisitor<'a>
                {
                    fn new() -> HeapVisitor<'a> { HeapVisitor { stack: vec![] } }

                    fn visit<V: Visitor>(
                        &mut self,
                        mut hir: &'a Hir,
                        mut visitor: V,
                    ) -> Result<V::Output, V::Err> {
                        self.stack.clear();

                        visitor.start();
                        loop {
                            visitor.visit_pre(hir)?;
                            if let Some(x) = self.induct(hir) {
                                let child = x.child();
                                self.stack.push((hir, x));
                                hir = child;
                                continue;
                            }
                            visitor.visit_post(hir)?;
                            loop {
                                let (post_hir, frame) = match self.stack.pop() {
                                    None => return visitor.finish(),
                                    Some((post_hir, frame)) => (post_hir, frame),
                                };
                                if let Some(x) = self.pop(frame) {
                                    match x {
                                        Frame::Alternation { .. } => { visitor.visit_alternation_in()?; }
                                        Frame::Concat { .. } => { visitor.visit_concat_in()?; }
                                        _ => {}
                                    }
                                    hir = x.child();
                                    self.stack.push((post_hir, x));
                                    break;
                                }
                                visitor.visit_post(post_hir)?;
                            }
                        }
                    }
                    fn induct( &mut self, hir: &'a Hir) -> Option<Frame<'a>> {
                        match *hir.kind() {
                            HirKind::Repetition(ref x) => Some(Frame::Repetition(x)),
                            HirKind::Capture(ref x) => Some(Frame::Capture(x)),
                            HirKind::Concat(ref x) if x.is_empty() => None,
                            HirKind::Concat(ref x) => { Some(Frame::Concat { head: &x[0], tail: &x[1..] }) }
                            HirKind::Alternation(ref x) if x.is_empty() => None,
                            HirKind::Alternation(ref x) => { Some(Frame::Alternation { head: &x[0], tail: &x[1..] }) }
                            _ => None,
                        }
                    }
                    fn pop(&self, induct: Frame<'a>) -> Option<Frame<'a>> {
                        match induct {
                            Frame::Repetition(_) => None,
                            Frame::Capture(_) => None,
                            Frame::Concat { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(Frame::Concat { head: &tail[0], tail: &tail[1..] })
                                }
                            }
                            Frame::Alternation { tail, .. } => {
                                if tail.is_empty() {
                                    None
                                } else {
                                    Some(Frame::Alternation {
                                        head: &tail[0],
                                        tail: &tail[1..],
                                    })
                                }
                            }
                        }
                    }
                }

                impl<'a> Frame<'a>               
                {
                    fn child( &self ) -> &'a Hir {
                        match *self {
                            Frame::Repetition(rep) => &rep.sub,
                            Frame::Capture(capture) => &capture.sub,
                            Frame::Concat { head, .. } => head,
                            Frame::Alternation { head, .. } => head,
                        }
                    }
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Error 
            {

                kind: ErrorKind,
                pattern: String,
                span: Span,
            }

            impl Error 
            {

                pub fn kind( &self ) -> &ErrorKind { &self.kind }
                
                pub fn pattern( &self ) -> &str { &self.pattern }

                pub fn span( &self ) -> &Span { &self.span }
            }

            #[non_exhaustive] #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum ErrorKind {
                UnicodeNotAllowed,
                InvalidUtf8,
                InvalidLineTerminator,
                UnicodePropertyNotFound,
                UnicodePropertyValueNotFound,
                UnicodePerlClassNotFound,
                UnicodeCaseUnavailable,
            }

                impl ::error::Error for Error {}

            impl ::fmt::Display for Error
           
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    crate::error::Formatter::from(self).fmt(f)
                }
            }

            impl ::fmt::Display for ErrorKind
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    use self::ErrorKind::*;

                    let msg = match *self {
                        UnicodeNotAllowed => "Unicode not allowed here",
                        InvalidUtf8 => "pattern can match invalid UTF-8",
                        InvalidLineTerminator => "invalid line terminator, must be ASCII",
                        UnicodePropertyNotFound => "Unicode property not found",
                        UnicodePropertyValueNotFound => "Unicode property value not found",
                        UnicodePerlClassNotFound => {
                            "Unicode-aware Perl class not found \
                            (make sure the unicode-perl feature is enabled)"
                        }
                        UnicodeCaseUnavailable => {
                            "Unicode-aware case insensitivity matching is not available \
                            (make sure the unicode-case feature is enabled)"
                        }
                    };
                    f.write_str(msg)
                }
            }
            
            #[derive(Clone, Eq, PartialEq)]
            pub struct Hir {

                kind: HirKind,
                props: Properties,
            }

            impl Hir 
            {

                pub fn kind( &self ) -> &HirKind { &self.kind }

                pub fn into_kind(mut self) -> HirKind {
                    ::mem::replace(&mut self.kind, HirKind::Empty)
                }

                pub fn properties( &self ) -> &Properties { &self.props }

                fn into_parts(mut self) -> (HirKind, Properties) {
                    (
                        ::mem::replace(&mut self.kind, HirKind::Empty),
                        ::mem::replace(&mut self.props, Properties::empty()),
                    )
                }
            }
            
            impl Hir {

                ///

                #[inline] pub fn empty() -> Hir {
                    let props = Properties::empty();
                    Hir { kind: HirKind::Empty, props }
               }
                
                #[inline] pub fn fail() -> Hir {
                    let class = Class::Bytes(ClassBytes::empty());
                    let props = Properties::class(&class);
                    Hir { kind: HirKind::Class(class), props }
                }

                
                
                #[inline] pub fn literal<B: Into<Box<[u8]>>>(lit: B) -> Hir {
                    let bytes = lit.into();
                    if bytes.is_empty() {
                        return Hir::empty();
                    }

                    let lit = Literal(bytes);
                    let props = Properties::literal(&lit);
                    Hir { kind: HirKind::Literal(lit), props }
               }
                
                #[inline] pub fn class(class: Class) -> Hir {
                    if class.is_empty() {
                        return Hir::fail();
                    } else if let Some(bytes) = class.literal() {
                        return Hir::literal(bytes);
                    }
                    let props = Properties::class(&class);
                    Hir { kind: HirKind::Class(class), props }
                }

                #[inline] pub fn look(look: Look) -> Hir {
                    let props = Properties::look(look);
                    Hir { kind: HirKind::Look(look), props }
                }

                #[inline] pub fn repetition(mut rep: Repetition) -> Hir {
                    if rep.sub.properties().maximum_len() == Some(0) {
                        rep.min = cmp::min(rep.min, 1);
                        rep.max = rep.max.map(|n| cmp::min(n, 1)).or(Some(1));
                    }
                    // (like '\P{any}').
                    //
                    // Additionally, the regex 'a{1}' is always equivalent to 'a'.
                    if rep.min == 0 && rep.max == Some(0) {
                        return Hir::empty();
                    } else if rep.min == 1 && rep.max == Some(1) {
                        return *rep.sub;
                    }
                    let props = Properties::repetition(&rep);
                    Hir { kind: HirKind::Repetition(rep), props }
               }
                
                #[inline] pub fn capture(capture: Capture) -> Hir {
                    let props = Properties::capture(&capture);
                    Hir { kind: HirKind::Capture(capture), props }
                }

                pub fn concat(subs: Vec<Hir>) -> Hir {
                    let mut new = vec![];
                    let mut prior_lit:Option<Vec<u8>> = None;
                    for sub in subs {
                        let (kind, props) = sub.into_parts();
                        match kind {
                            HirKind::Literal(Literal(bytes)) => {
                                if let Some(ref mut prior_bytes) = prior_lit {
                                    prior_bytes.extend_from_slice(&bytes);
                                } else {
                                    prior_lit = Some(bytes.to_vec());
                                }
                            }
                            HirKind::Concat(subs2) => {
                                for sub2 in subs2 {
                                    let (kind2, props2) = sub2.into_parts();
                                    match kind2 {
                                        HirKind::Literal(Literal(bytes)) => {
                                            if let Some(ref mut prior_bytes) = prior_lit {
                                                prior_bytes.extend_from_slice(&bytes);
                                            } else {
                                                prior_lit = Some(bytes.to_vec());
                                            }
                                        }
                                        kind2 => {
                                            if let Some(prior_bytes) = prior_lit.take() {
                                                new.push(Hir::literal(prior_bytes));
                                            }
                                            new.push(Hir { kind: kind2, props: props2 });
                                        }
                                    }
                                }
                            }
                            // We can just skip empty HIRs.
                            HirKind::Empty => {}
                            kind => {
                                if let Some(prior_bytes) = prior_lit.take() {
                                    new.push(Hir::literal(prior_bytes));
                                }
                                new.push(Hir { kind, props });
                            }
                        }
                    }
                    if let Some(prior_bytes) = prior_lit.take() {
                        new.push(Hir::literal(prior_bytes));
                    }
                    if new.is_empty() {
                        return Hir::empty();
                    } else if new.len() == 1 {
                        return new.pop().unwrap();
                    }
                    let props = Properties::concat(&new);
                    Hir { kind: HirKind::Concat(new), props }
                }

                

                pub fn alternation(subs: Vec<Hir>) -> Hir {
                    // simplification happening. We're just flattening alternations.
                    let mut new = Vec::with_capacity(subs.len());
                    for sub in subs {
                        let (kind, props) = sub.into_parts();
                        match kind {
                            HirKind::Alternation(subs2) => { new.extend(subs2); }
                            kind => { new.push(Hir { kind, props }); }
                        }
                    }
                    if new.is_empty() {
                        return Hir::fail();
                    } else if new.len() == 1 {
                        return new.pop().unwrap();
                    }
                    // don't handle anything else.
                    if let Some(singletons) = singleton_chars(&new) {
                        let it = singletons
                            .into_iter()
                            .map(|ch| ClassUnicodeRange { start: ch, end: ch });
                        return Hir::class(Class::Unicode(ClassUnicode::new(it)));
                    }
                    if let Some(singletons) = singleton_bytes(&new) {
                        let it = singletons
                            .into_iter()
                            .map(|b| ClassBytesRange { start: b, end: b });
                        return Hir::class(Class::Bytes(ClassBytes::new(it)));
                    }
                    if let Some(cls) = class_chars(&new) {
                        return Hir::class(cls);
                    }
                    if let Some(cls) = class_bytes(&new) {
                        return Hir::class(cls);
                    }
                    new = match lift_common_prefix(new) {
                        Ok(hir) => return hir,
                        Err(unchanged) => unchanged,
                    };
                    let props = Properties::alternation(&new);
                    Hir { kind: HirKind::Alternation(new), props }
                }

                #[inline] pub fn dot(dot: Dot) -> Hir {
                    match dot {
                        Dot::AnyChar => Hir::class(Class::Unicode(ClassUnicode::new([
                            ClassUnicodeRange::new('\0','\u{10FFFF}'),
                        ]))),
                        Dot::AnyByte => Hir::class(Class::Bytes(ClassBytes::new([
                            ClassBytesRange::new(b'\0', b'\xFF'),
                        ]))),
                        Dot::AnyCharExcept(ch) => {
                            let mut cls =
                                ClassUnicode::new([ClassUnicodeRange::new(ch, ch)]);
                            cls.negate();
                            Hir::class(Class::Unicode(cls))
                        }
                        Dot::AnyCharExceptLF => {
                            Hir::class(Class::Unicode(ClassUnicode::new([
                                ClassUnicodeRange::new('\0','\x09'),
                                ClassUnicodeRange::new('\x0B','\u{10FFFF}'),
                            ])))
                        }
                        Dot::AnyCharExceptCRLF => {
                            Hir::class(Class::Unicode(ClassUnicode::new([
                                ClassUnicodeRange::new('\0','\x09'),
                                ClassUnicodeRange::new('\x0B','\x0C'),
                                ClassUnicodeRange::new('\x0E','\u{10FFFF}'),
                            ])))
                        }
                        Dot::AnyByteExcept( byte ) => {
                            let mut cls =
                                ClassBytes::new([ClassBytesRange::new(byte, byte)]);
                            cls.negate();
                            Hir::class(Class::Bytes(cls))
                        }
                        Dot::AnyByteExceptLF => {
                            Hir::class(Class::Bytes(ClassBytes::new([
                                ClassBytesRange::new(b'\0', b'\x09'),
                                ClassBytesRange::new(b'\x0B', b'\xFF'),
                            ])))
                        }
                        Dot::AnyByteExceptCRLF => {
                            Hir::class(Class::Bytes(ClassBytes::new([
                                ClassBytesRange::new(b'\0', b'\x09'),
                                ClassBytesRange::new(b'\x0B', b'\x0C'),
                                ClassBytesRange::new(b'\x0E', b'\xFF'),
                            ])))
                        }
                    }
                }
            }
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub enum HirKind {
                Empty,
                Literal(Literal),
                Class(Class),
                Look(Look),
                Repetition(Repetition),
                Capture(Capture),
                Concat(Vec<Hir>),
                Alternation(Vec<Hir>),
            }

            impl HirKind 
            {

                pub fn subs( &self ) -> &[Hir] {
                    use ::slice::from_ref;

                    match *self {
                        HirKind::Empty
                        | HirKind::Literal(_)
                        | HirKind::Class(_)
                        | HirKind::Look(_) => &[],
                        HirKind::Repetition(Repetition { ref sub, .. }) => from_ref(sub),
                        HirKind::Capture(Capture { ref sub, .. }) => from_ref(sub),
                        HirKind::Concat(ref subs) => subs,
                        HirKind::Alternation(ref subs) => subs,
                    }
                }
            }

            impl ::fmt::Debug for Hir
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    self.kind.fmt(f)
                }
            }

            impl ::fmt::Display for Hir
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    crate::hir::print::Printer::new().print(self, f)
                }
            }
            #[derive(Clone, Eq, PartialEq)]
            pub struct Literal(pub Box<[u8]>);

            impl ::fmt::Debug for Literal
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    crate::debug::Bytes(&self.0).fmt(f)
                }
            }
            #[derive(Clone, Eq, PartialEq)]
            pub enum Class {

                Unicode(ClassUnicode),
                Bytes(ClassBytes),
            }

            impl Class
            {
                pub fn case_fold_simple(&mut self) {
                    match *self {
                        Class::Unicode(ref mut x) => x.case_fold_simple(),
                        Class::Bytes(ref mut x) => x.case_fold_simple(),
                    }
                }
                
                pub fn try_case_fold_simple(
                    &mut self,
                ) -> ::result::Result<(), CaseFoldError> {
                    match *self {
                        Class::Unicode(ref mut x) => x.try_case_fold_simple()?,
                        Class::Bytes(ref mut x) => x.case_fold_simple(),
                    }
                    Ok( () )
                }

                pub fn negate(&mut self) {
                    match *self {
                        Class::Unicode(ref mut x) => x.negate(),
                        Class::Bytes(ref mut x) => x.negate(),
                    }
                }

                pub fn is_utf8( &self ) -> bool {
                    match *self {
                        Class::Unicode(_) => true,
                        Class::Bytes(ref x) => x.is_ascii(),
                    }
                }
                
                pub fn minimum_len( &self ) -> Option<usize> {
                    match *self {
                        Class::Unicode(ref x) => x.minimum_len(),
                        Class::Bytes(ref x) => x.minimum_len(),
                    }
                }

                pub fn maximum_len( &self ) -> Option<usize> {
                    match *self {
                        Class::Unicode(ref x) => x.maximum_len(),
                        Class::Bytes(ref x) => x.maximum_len(),
                    }
                }

                pub fn is_empty( &self ) -> bool {
                    match *self {
                        Class::Unicode(ref x) => x.ranges().is_empty(),
                        Class::Bytes(ref x) => x.ranges().is_empty(),
                    }
                }

                pub fn literal( &self ) -> Option<Vec<u8>> {
                    match *self {
                        Class::Unicode(ref x) => x.literal(),
                        Class::Bytes(ref x) => x.literal(),
                    }
                }
            }

            impl ::fmt::Debug for Class
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    use crate::debug::Byte;

                    let mut fmter = f.debug_set();
                    match *self {
                        Class::Unicode(ref cls) => {
                            for r in cls.ranges().iter() {
                                fmter.entry(&(r.start..=r.end));
                            }
                        }
                        Class::Bytes(ref cls) => {
                            for r in cls.ranges().iter() {
                                fmter.entry(&(Byte(r.start)..=Byte(r.end)));
                            }
                        }
                    }
                    fmter.finish()
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct ClassUnicode {
                set: IntervalSet<ClassUnicodeRange>,
            }

            impl ClassUnicode {
                pub fn new<I>(ranges: I) -> ClassUnicode where I: IntoIterator<Item = ClassUnicodeRange>,
                {
                    ClassUnicode { set: IntervalSet::new(ranges) }
                }

                pub fn empty() -> ClassUnicode {
                    ClassUnicode::new(vec![])
                }

                pub fn push( &mut self, range: ClassUnicodeRange) {
                    self.set.push(range);
                }
                
                pub fn iter( &self ) -> ClassUnicodeIter<'_> { ClassUnicodeIter( self.set.iter()) }

                pub fn ranges( &self ) -> &[ClassUnicodeRange] { self.set.intervals() }

                pub fn case_fold_simple(&mut self) {
                    self.set
                        .case_fold_simple()
                        .expect("unicode-case feature must be enabled");
                }

                pub fn try_case_fold_simple(
                    &mut self,
                ) -> ::result::Result<(), CaseFoldError> { self.set.case_fold_simple() }

                pub fn negate(&mut self) {
                    self.set.negate();
                }

                pub fn union( &mut self, other: &ClassUnicode) {
                    self.set.union(&other.set);
                }

                pub fn intersect( &mut self, other: &ClassUnicode) {
                    self.set.intersect(&other.set);
                }

                pub fn difference( &mut self, other: &ClassUnicode) {
                    self.set.difference(&other.set);
                }

                pub fn symmetric_difference( &mut self, other: &ClassUnicode) {
                    self.set.symmetric_difference(&other.set);
                }

                pub fn is_ascii( &self ) -> bool { self.set.intervals().last().map_or(true, |r| r.end <= '\x7F') }

                pub fn minimum_len( &self ) -> Option<usize> {
                    let first = self.ranges().get(0)?;
                    Some(first.start.len_utf8())
                }

                pub fn maximum_len( &self ) -> Option<usize> {
                    let last = self.ranges().last()?;
                    Some(last.end.len_utf8())
                }

                pub fn literal( &self ) -> Option<Vec<u8>> {
                    let rs = self.ranges();
                    if rs.len() == 1 && rs[0].start == rs[0].end {
                        Some(rs[0].start.encode_utf8(&mut [0; 4]).to_string().into_bytes())
                    } else {
                        None
                    }
                }

                pub fn to_byte_class( &self ) -> Option<ClassBytes> {
                    if !self.is_ascii() {
                        return None;
                    }
                    Some(ClassBytes::new( self.ranges().iter().map(|r| {
                        ClassBytesRange {
                            start: u8::try_from(r.start).unwrap(),
                            end: u8::try_from(r.end).unwrap(),
                        }
                    })))
                }
            }

            #[derive( Debug )]
            pub struct ClassUnicodeIter<'a>(IntervalSetIter<'a, ClassUnicodeRange>);

            impl<'a> Iterator for ClassUnicodeIter<'a>
            {
                type Item = &'a ClassUnicodeRange;
                fn next(&mut self) -> Option<&'a ClassUnicodeRange> { self.0.next() }
            }

            #[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]
            pub struct ClassUnicodeRange {
                start: char,
                end: char,
            }

            impl ::fmt::Debug for ClassUnicodeRange
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    let start = if !self.start.is_whitespace() && !self.start.is_control()
                    {
                        self.start.to_string()
                    } else {
                        format!("0x{:X}", u32::from( self.start))
                    };
                    let end = if !self.end.is_whitespace() && !self.end.is_control() {
                        self.end.to_string()
                    } else {
                        format!("0x{:X}", u32::from( self.end))
                    };
                    f.debug_struct("ClassUnicodeRange")
                        .field("start", &start)
                        .field("end", &end)
                        .finish()
                }
            }

            impl Interval for ClassUnicodeRange {
                type Bound = char;

                #[inline] fn lower( &self ) -> char { self.start }
                
                #[inline] fn upper( &self ) -> char { self.end }
                
                #[inline] fn set_lower( &mut self, bound: char) {
                    self.start = bound;
                }
                
                #[inline] fn set_upper( &mut self, bound: char) {
                    self.end = bound;
                }

                fn case_fold_simple(
                    &self,
                    ranges: &mut Vec<ClassUnicodeRange>,
                ) -> Result<(), unicode::CaseFoldError> {
                    let mut folder = unicode::SimpleCaseFolder::new()?;
                    if !folder.overlaps( self.start, self.end) {
                        return Ok( () );
                    }
                    let (start, end) = (u32::from( self.start), u32::from( self.end));
                    for cp in (start..=end).filter_map(char::from_u32) {
                        for &cp_folded in folder.mapping(cp) {
                            ranges.push(ClassUnicodeRange::new(cp_folded, cp_folded));
                        }
                    }
                    Ok( () )
                }
            }

            impl ClassUnicodeRange 
            {

                pub fn new(start: char, end: char) -> ClassUnicodeRange {
                    ClassUnicodeRange::create(start, end)
                }

                pub fn start( &self ) -> char { self.start }

                pub fn end( &self ) -> char { self.end }

                pub fn len( &self ) -> usize {
                    let diff = 1 + u32::from( self.end) - u32::from( self.start);
                    usize::try_from(diff).expect("char class len fits in usize")
                }
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct ClassBytes {
                set: IntervalSet<ClassBytesRange>,
            }

            impl ClassBytes {
                pub fn new<I>(ranges: I) -> ClassBytes where I: IntoIterator<Item = ClassBytesRange>,
                {
                    ClassBytes { set: IntervalSet::new(ranges) }
                }

                pub fn empty() -> ClassBytes {
                    ClassBytes::new(vec![])
                }

                pub fn push( &mut self, range: ClassBytesRange) {
                    self.set.push(range);
                }
                
                pub fn iter( &self ) -> ClassBytesIter<'_> { ClassBytesIter( self.set.iter()) }

                pub fn ranges( &self ) -> &[ClassBytesRange] { self.set.intervals() }

                pub fn case_fold_simple(&mut self) {
                    self.set.case_fold_simple().expect("ASCII case folding never fails");
                }

                pub fn negate(&mut self) {
                    self.set.negate();
                }

                pub fn union( &mut self, other: &ClassBytes) {
                    self.set.union(&other.set);
                }

                pub fn intersect( &mut self, other: &ClassBytes) {
                    self.set.intersect(&other.set);
                }

                pub fn difference( &mut self, other: &ClassBytes) {
                    self.set.difference(&other.set);
                }

                pub fn symmetric_difference( &mut self, other: &ClassBytes) {
                    self.set.symmetric_difference(&other.set);
                }

                pub fn is_ascii( &self ) -> bool { self.set.intervals().last().map_or(true, |r| r.end <= 0x7F) }

                pub fn minimum_len( &self ) -> Option<usize> {
                    if self.ranges().is_empty() {
                        None
                    } else {
                        Some(1)
                    }
                }

                pub fn maximum_len( &self ) -> Option<usize> {
                    if self.ranges().is_empty() {
                        None
                    } else {
                        Some(1)
                    }
                }

                pub fn literal( &self ) -> Option<Vec<u8>> {
                    let rs = self.ranges();
                    if rs.len() == 1 && rs[0].start == rs[0].end {
                        Some(vec![rs[0].start])
                    } else {
                        None
                    }
                }

                pub fn to_unicode_class( &self ) -> Option<ClassUnicode> {
                    if !self.is_ascii() {
                        return None;
                    }
                    Some(ClassUnicode::new( self.ranges().iter().map(|r| {
                        ClassUnicodeRange {
                            start: char::from(r.start),
                            end: char::from(r.end),
                        }
                    })))
                }
            }

            #[derive( Debug )]
            pub struct ClassBytesIter<'a>(IntervalSetIter<'a, ClassBytesRange>);

            impl<'a> Iterator for ClassBytesIter<'a>
            {
                type Item = &'a ClassBytesRange;
                fn next(&mut self) -> Option<&'a ClassBytesRange> { self.0.next() }
            }

            #[derive(Clone, Copy, Default, Eq, PartialEq, PartialOrd, Ord)]
            pub struct ClassBytesRange {
                start: u8,
                end: u8,
            }

            impl Interval for ClassBytesRange {
                type Bound = u8;

                #[inline] fn lower( &self ) -> u8 { self.start }
                
                #[inline] fn upper( &self ) -> u8 { self.end }
                
                #[inline] fn set_lower( &mut self, bound: u8) {
                    self.start = bound;
                }
                
                #[inline] fn set_upper( &mut self, bound: u8) {
                    self.end = bound;
                }
                fn case_fold_simple(
                    &self,
                    ranges: &mut Vec<ClassBytesRange>,
                ) -> Result<(), unicode::CaseFoldError> {
                    if !ClassBytesRange::new(b'a', b'z').is_intersection_empty(self) {
                        let lower = cmp::max( self.start, b'a');
                        let upper = cmp::min( self.end, b'z');
                        ranges.push(ClassBytesRange::new(lower - 32, upper - 32));
                    }
                    if !ClassBytesRange::new(b'A', b'Z').is_intersection_empty(self) {
                        let lower = cmp::max( self.start, b'A');
                        let upper = cmp::min( self.end, b'Z');
                        ranges.push(ClassBytesRange::new(lower + 32, upper + 32));
                    }
                    Ok( () )
                }
            }

            impl ClassBytesRange 
            {

                pub fn new(start: u8, end: u8) -> ClassBytesRange {
                    ClassBytesRange::create(start, end)
                }

                pub fn start( &self ) -> u8 { self.start }

                pub fn end( &self ) -> u8 { self.end }

                pub fn len( &self ) -> usize {
                    usize::from( self.end.checked_sub( self.start).unwrap())
                        .checked_add(1)
                        .unwrap()
                }
            }

            impl ::fmt::Debug for ClassBytesRange
            {
                fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
                    f.debug_struct("ClassBytesRange")
                        .field("start", &crate::debug::Byte( self.start))
                        .field("end", &crate::debug::Byte( self.end))
                        .finish()
                }
            }

            #[derive(Clone, Copy, Debug, Eq, PartialEq )]
            pub enum Look {
                Start = 1 << 0,
                End = 1 << 1,
                StartLF = 1 << 2,
                EndLF = 1 << 3,
                StartCRLF = 1 << 4,
                EndCRLF = 1 << 5,
                WordAscii = 1 << 6,
                WordAsciiNegate = 1 << 7,
                WordUnicode = 1 << 8,
                WordUnicodeNegate = 1 << 9,
                WordStartAscii = 1 << 10,
                WordEndAscii = 1 << 11,
                WordStartUnicode = 1 << 12,
                WordEndUnicode = 1 << 13,
                WordStartHalfAscii = 1 << 14,
                WordEndHalfAscii = 1 << 15,
                WordStartHalfUnicode = 1 << 16,
                WordEndHalfUnicode = 1 << 17,
            }

            impl Look {
                #[inline]
                pub const fn reversed(self) -> Look {
                    match self {
                        Look::Start => Look::End,
                        Look::End => Look::Start,
                        Look::StartLF => Look::EndLF,
                        Look::EndLF => Look::StartLF,
                        Look::StartCRLF => Look::EndCRLF,
                        Look::EndCRLF => Look::StartCRLF,
                        Look::WordAscii => Look::WordAscii,
                        Look::WordAsciiNegate => Look::WordAsciiNegate,
                        Look::WordUnicode => Look::WordUnicode,
                        Look::WordUnicodeNegate => Look::WordUnicodeNegate,
                        Look::WordStartAscii => Look::WordEndAscii,
                        Look::WordEndAscii => Look::WordStartAscii,
                        Look::WordStartUnicode => Look::WordEndUnicode,
                        Look::WordEndUnicode => Look::WordStartUnicode,
                        Look::WordStartHalfAscii => Look::WordEndHalfAscii,
                        Look::WordEndHalfAscii => Look::WordStartHalfAscii,
                        Look::WordStartHalfUnicode => Look::WordEndHalfUnicode,
                        Look::WordEndHalfUnicode => Look::WordStartHalfUnicode,
                    }
                }
                
                #[inline]
                pub const fn as_repr(self) -> u32 {
                    self as u32
                }
                
                #[inline]
                pub const fn from_repr(repr: u32) -> Option<Look> {
                    match repr {
                        0b00_0000_0000_0000_0001 => Some(Look::Start),
                        0b00_0000_0000_0000_0010 => Some(Look::End),
                        0b00_0000_0000_0000_0100 => Some(Look::StartLF),
                        0b00_0000_0000_0000_1000 => Some(Look::EndLF),
                        0b00_0000_0000_0001_0000 => Some(Look::StartCRLF),
                        0b00_0000_0000_0010_0000 => Some(Look::EndCRLF),
                        0b00_0000_0000_0100_0000 => Some(Look::WordAscii),
                        0b00_0000_0000_1000_0000 => Some(Look::WordAsciiNegate),
                        0b00_0000_0001_0000_0000 => Some(Look::WordUnicode),
                        0b00_0000_0010_0000_0000 => Some(Look::WordUnicodeNegate),
                        0b00_0000_0100_0000_0000 => Some(Look::WordStartAscii),
                        0b00_0000_1000_0000_0000 => Some(Look::WordEndAscii),
                        0b00_0001_0000_0000_0000 => Some(Look::WordStartUnicode),
                        0b00_0010_0000_0000_0000 => Some(Look::WordEndUnicode),
                        0b00_0100_0000_0000_0000 => Some(Look::WordStartHalfAscii),
                        0b00_1000_0000_0000_0000 => Some(Look::WordEndHalfAscii),
                        0b01_0000_0000_0000_0000 => Some(Look::WordStartHalfUnicode),
                        0b10_0000_0000_0000_0000 => Some(Look::WordEndHalfUnicode),
                        _ => None,
                    }
                }
                
                #[inline]
                pub const fn as_char(self) -> char {
                    match self {
                        Look::Start => 'A',
                        Look::End => 'z',
                        Look::StartLF => '^',
                        Look::EndLF => '$',
                        Look::StartCRLF => 'r',
                        Look::EndCRLF => 'R',
                        Look::WordAscii => 'b',
                        Look::WordAsciiNegate => 'B',
                        Look::WordUnicode => '',
                        Look::WordUnicodeNegate => '',
                        Look::WordStartAscii => '<',
                        Look::WordEndAscii => '>',
                        Look::WordStartUnicode => '',
                        Look::WordEndUnicode => '',
                        Look::WordStartHalfAscii => '',
                        Look::WordEndHalfAscii => '',
                        Look::WordStartHalfUnicode => '',
                        Look::WordEndHalfUnicode => '',
                    }
                }
            }
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Capture {

                pub index: u32,
                pub name:Option<Box<str>>,
                pub sub: Box<Hir>,
            }

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Repetition {

                pub min: u32,
                pub max:Option<u32>,
                pub greedy: bool,
                pub sub: Box<Hir>,
            }

            impl Repetition {
                pub fn with(&self, sub: Hir) -> Repetition {
                    Repetition {
                        min: self.min,
                        max: self.max,
                        greedy: self.greedy,
                        sub: Box::new(sub),
                    }
                }
            }

            #[non_exhaustive] #[derive( Clone, Copy, Debug, Eq, PartialEq )]
            pub enum Dot 
            {
                AnyChar,
                AnyByte,
                AnyCharExcept(char),
                AnyCharExceptLF,
                AnyCharExceptCRLF,
                AnyByteExcept(u8),
                AnyByteExceptLF,
                AnyByteExceptCRLF,
            }
            
            impl Drop for Hir {
                fn drop(&mut self) {
                    use ::mem;

                    match *self.kind() {
                        HirKind::Empty
                        | HirKind::Literal(_)
                        | HirKind::Class(_)
                        | HirKind::Look(_) => return,
                        HirKind::Capture(ref x) if x.sub.kind.subs().is_empty() => return,
                        HirKind::Repetition(ref x) if x.sub.kind.subs().is_empty() => { return }
                        HirKind::Concat(ref x) if x.is_empty() => return,
                        HirKind::Alternation(ref x) if x.is_empty() => return,
                        _ => {}
                    }

                    let mut stack = vec![mem::replace(self, Hir::empty())];
                    while let Some(mut expr) = stack.pop() {
                        match expr.kind {
                            HirKind::Empty
                            | HirKind::Literal(_)
                            | HirKind::Class(_)
                            | HirKind::Look(_) => {}
                            HirKind::Capture(ref mut x) => { stack.push(mem::replace(&mut x.sub, Hir::empty())); }
                            HirKind::Repetition(ref mut x) => { stack.push(mem::replace(&mut x.sub, Hir::empty())); }
                            HirKind::Concat(ref mut x) => { stack.extend(x.drain(..)); }
                            HirKind::Alternation(ref mut x) => { stack.extend(x.drain(..)); }
                        }
                    }
                }
            }
            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Properties(Box<PropertiesI>);
            #[derive( Clone, Debug, Eq, PartialEq )]
            struct PropertiesI {
                minimum_len:Option<usize>,
                maximum_len:Option<usize>,
                look_set: LookSet,
                look_set_prefix: LookSet,
                look_set_suffix: LookSet,
                look_set_prefix_any: LookSet,
                look_set_suffix_any: LookSet,
                utf8: bool,
                explicit_captures_len: usize,
                static_explicit_captures_len:Option<usize>,
                literal: bool,
                alternation_literal: bool,
            }

            impl Properties {
                #[inline] pub fn minimum_len( &self ) -> Option<usize> { self.0.minimum_len}
                
                #[inline] pub fn maximum_len( &self ) -> Option<usize> { self.0.maximum_len}
                
                #[inline] pub fn look_set( &self ) -> LookSet { self.0.look_set }
                
                #[inline] pub fn look_set_prefix( &self ) -> LookSet { self.0.look_set_prefix }
                
                #[inline] pub fn look_set_prefix_any( &self ) -> LookSet { self.0.look_set_prefix_any }
                
                #[inline] pub fn look_set_suffix( &self ) -> LookSet { self.0.look_set_suffix }
                
                #[inline] pub fn look_set_suffix_any( &self ) -> LookSet { self.0.look_set_suffix_any }
                
                #[inline] pub fn is_utf8( &self ) -> bool { self.0.utf8 }
                
                #[inline] pub fn explicit_captures_len( &self ) -> usize { self.0.explicit_captures_len }
                
                #[inline] pub fn static_explicit_captures_len( &self ) -> Option<usize> { self.0.static_explicit_captures_len}
                
                #[inline] pub fn is_literal( &self ) -> bool { self.0.literal }
                
                #[inline] pub fn is_alternation_literal( &self ) -> bool { self.0.alternation_literal }
                
                #[inline] pub fn memory_usage( &self ) -> usize { ::mem::size_of::<PropertiesI>() }
                
                pub fn union<I, P>(props: I) -> Properties where I: IntoIterator<Item = P>,
                    P: ::borrow::Borrow<Properties>,
                {
                    let mut it = props.into_iter().peekable();
                    let fix = if it.peek().is_none() {
                        LookSet::empty()
                    } else {
                        LookSet::full()
                    };
                    let static_explicit_captures_len =
                        it.peek().and_then(|p| p.borrow().static_explicit_captures_len());
                    let mut props = PropertiesI {
                        minimum_len: None,
                        maximum_len: None,
                        look_set: LookSet::empty(),
                        look_set_prefix: fix,
                        look_set_suffix: fix,
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        utf8: true,
                        explicit_captures_len: 0,
                        static_explicit_captures_len,
                        literal: false,
                        alternation_literal: true,
                    };
                    let (mut min_poisoned, mut max_poisoned) = (false, false);
                    for prop in it {
                        let p = prop.borrow();
                        props.look_set.set_union(p.look_set());
                        props.look_set_prefix.set_intersect(p.look_set_prefix());
                        props.look_set_suffix.set_intersect(p.look_set_suffix());
                        props.look_set_prefix_any.set_union(p.look_set_prefix_any());
                        props.look_set_suffix_any.set_union(p.look_set_suffix_any());
                        props.utf8 = props.utf8 && p.is_utf8();
                        props.explicit_captures_len = props
                            .explicit_captures_len
                            .saturating_add(p.explicit_captures_len());
                        if props.static_explicit_captures_len
                            != p.static_explicit_captures_len()
                        {
                            props.static_explicit_captures_len = None;
                        }
                        props.alternation_literal =
                            props.alternation_literal && p.is_literal();
                        if !min_poisoned {
                            if let Some(xmin) = p.minimum_len() {
                                if props.minimum_len.map_or(true, |pmin| xmin < pmin) {
                                    props.minimum_len = Some(xmin);
                                }
                            } else {
                                props.minimum_len = None;
                                min_poisoned = true;
                            }
                        }
                        if !max_poisoned {
                            if let Some(xmax) = p.maximum_len() {
                                if props.maximum_len.map_or(true, |pmax| xmax > pmax) {
                                    props.maximum_len = Some(xmax);
                                }
                            } else {
                                props.maximum_len = None;
                                max_poisoned = true;
                            }
                        }
                    }
                    Properties(Box::new(props))
                }
            }

            impl Properties {
                fn empty() -> Properties {
                    let inner = PropertiesI {
                        minimum_len: Some(0),
                        maximum_len: Some(0),
                        look_set: LookSet::empty(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        //
                        //
                        // since it too can match the empty string.
                        utf8: true,
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: false,
                        alternation_literal: false,
                    };
                    Properties(Box::new(inner))
                }

                fn literal(lit: &Literal) -> Properties {
                    let inner = PropertiesI {
                        minimum_len: Some(lit.0.len()),
                        maximum_len: Some(lit.0.len()),
                        look_set: LookSet::empty(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        utf8: ::str::from_utf8(&lit.0).is_ok(),
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: true,
                        alternation_literal: true,
                    };
                    Properties(Box::new(inner))
                }

                fn class(class: &Class) -> Properties {
                    let inner = PropertiesI {
                        minimum_len: class.minimum_len(),
                        maximum_len: class.maximum_len(),
                        look_set: LookSet::empty(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        utf8: class.is_utf8(),
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: false,
                        alternation_literal: false,
                    };
                    Properties(Box::new(inner))
                }

                fn look(look: Look) -> Properties {
                    let inner = PropertiesI {
                        minimum_len: Some(0),
                        maximum_len: Some(0),
                        look_set: LookSet::singleton(look),
                        look_set_prefix: LookSet::singleton(look),
                        look_set_suffix: LookSet::singleton(look),
                        look_set_prefix_any: LookSet::singleton(look),
                        look_set_suffix_any: LookSet::singleton(look),
                        //
                        utf8: true,
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: false,
                        alternation_literal: false,
                    };
                    Properties(Box::new(inner))
                }

                fn repetition(rep: &Repetition) -> Properties {
                    let p = rep.sub.properties();
                    let minimum_len = p.minimum_len().map(|child_min| {
                        let rep_min = usize::try_from(rep.min).unwrap_or(usize::MAX);
                        child_min.saturating_mul(rep_min)
                    });
                    let maximum_len = rep.max.and_then(|rep_max| {
                        let rep_max = usize::try_from(rep_max).ok()?;
                        let child_max = p.maximum_len()?;
                        child_max.checked_mul(rep_max)
                    });

                    let mut inner = PropertiesI {
                        minimum_len,
                        maximum_len,
                        look_set: p.look_set(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: p.look_set_prefix_any(),
                        look_set_suffix_any: p.look_set_suffix_any(),
                        utf8: p.is_utf8(),
                        explicit_captures_len: p.explicit_captures_len(),
                        static_explicit_captures_len: p.static_explicit_captures_len(),
                        literal: false,
                        alternation_literal: false,
                    };
                    if rep.min > 0 {
                        inner.look_set_prefix = p.look_set_prefix();
                        inner.look_set_suffix = p.look_set_suffix();
                    }
                    if rep.min == 0
                        && inner.static_explicit_captures_len.map_or(false, |len| len > 0)
                    {
                        if rep.max == Some(0) {
                            inner.static_explicit_captures_len = Some(0);
                        } else {
                            inner.static_explicit_captures_len = None;
                        }
                    }
                    Properties(Box::new(inner))
                }

                fn capture(capture: &Capture) -> Properties {
                    let p = capture.sub.properties();
                    Properties(Box::new(PropertiesI {
                        explicit_captures_len: p.explicit_captures_len().saturating_add(1),
                        static_explicit_captures_len: p
                            .static_explicit_captures_len()
                            .map(|len| len.saturating_add(1)),
                        literal: false,
                        alternation_literal: false,
                        ..*p.0.clone()
                    }))
                }

                fn concat(concat: &[Hir]) -> Properties {
                    let mut props = PropertiesI {
                        minimum_len: Some(0),
                        maximum_len: Some(0),
                        look_set: LookSet::empty(),
                        look_set_prefix: LookSet::empty(),
                        look_set_suffix: LookSet::empty(),
                        look_set_prefix_any: LookSet::empty(),
                        look_set_suffix_any: LookSet::empty(),
                        utf8: true,
                        explicit_captures_len: 0,
                        static_explicit_captures_len: Some(0),
                        literal: true,
                        alternation_literal: true,
                    };
                    for x in concat.iter() {
                        let p = x.properties();
                        props.look_set.set_union(p.look_set());
                        props.utf8 = props.utf8 && p.is_utf8();
                        props.explicit_captures_len = props
                            .explicit_captures_len
                            .saturating_add(p.explicit_captures_len());
                        props.static_explicit_captures_len = p
                            .static_explicit_captures_len()
                            .and_then(|len1| {
                                Some((len1, props.static_explicit_captures_len?))
                            })
                            .and_then(|(len1, len2)| Some(len1.saturating_add(len2)));
                        props.literal = props.literal && p.is_literal();
                        props.alternation_literal =
                            props.alternation_literal && p.is_alternation_literal();
                        if let Some(minimum_len) = props.minimum_len {
                            match p.minimum_len() {
                                None => props.minimum_len = None,
                                Some(len) => {
                                    // higher than what our number types permit.
                                    props.minimum_len =
                                        Some(minimum_len.saturating_add(len));
                                }
                            }
                        }
                        if let Some(maximum_len) = props.maximum_len {
                            match p.maximum_len() {
                                None => props.maximum_len = None,
                                Some(len) => { props.maximum_len = maximum_len.checked_add(len) }
                            }
                        }
                    }
                    let mut it = concat.iter();
                    while let Some(x) = it.next() {
                        props.look_set_prefix.set_union(x.properties().look_set_prefix());
                        props
                            .look_set_prefix_any
                            .set_union(x.properties().look_set_prefix_any());
                        if x.properties().maximum_len().map_or(true, |x| x > 0) {
                            break;
                        }
                    }
                    // Same thing for the suffix properties, but in reverse.
                    let mut it = concat.iter().rev();
                    while let Some(x) = it.next() {
                        props.look_set_suffix.set_union(x.properties().look_set_suffix());
                        props
                            .look_set_suffix_any
                            .set_union(x.properties().look_set_suffix_any());
                        if x.properties().maximum_len().map_or(true, |x| x > 0) {
                            break;
                        }
                    }
                    Properties(Box::new(props))
                }

                fn alternation(alts: &[Hir]) -> Properties {
                    Properties::union(alts.iter().map(|hir| hir.properties()))
                }
            }

            #[derive(Clone, Copy, Default, Eq, PartialEq)]
            pub struct LookSet {
                pub bits: u32,
            }

            impl LookSet {

                #[inline] pub fn empty() -> LookSet {
                    LookSet { bits: 0 }
                }
                
                #[inline] pub fn full() -> LookSet {
                    LookSet { bits: !0 }
                }

                #[inline] pub fn singleton(look: Look) -> LookSet {
                    LookSet::empty().insert(look)
                }

                #[inline] pub fn len(self) -> usize {
                    usize::try_from( self.bits.count_ones()).unwrap()
                }

                #[inline] pub fn is_empty(self) -> bool {
                    self.len() == 0
                }
                
                #[inline] pub fn contains(self, look: Look) -> bool {
                    self.bits & look.as_repr() != 0
               }
                
                #[inline] pub fn contains_anchor( &self ) -> bool { self.contains_anchor_haystack() || self.contains_anchor_line() }
                
                #[inline] pub fn contains_anchor_haystack( &self ) -> bool { self.contains(Look::Start) || self.contains(Look::End) }
                
                #[inline] pub fn contains_anchor_line( &self ) -> bool {
                    self.contains(Look::StartLF)
                        || self.contains(Look::EndLF)
                        || self.contains(Look::StartCRLF)
                        || self.contains(Look::EndCRLF)
               }
                
                #[inline] pub fn contains_anchor_lf( &self ) -> bool { self.contains(Look::StartLF) || self.contains(Look::EndLF) }
                
                #[inline] pub fn contains_anchor_crlf( &self ) -> bool { self.contains(Look::StartCRLF) || self.contains(Look::EndCRLF) }
                
                #[inline] pub fn contains_word(self) -> bool {
                    self.contains_word_unicode() || self.contains_word_ascii()
               }
                
                #[inline] pub fn contains_word_unicode(self) -> bool {
                    self.contains(Look::WordUnicode)
                        || self.contains(Look::WordUnicodeNegate)
                        || self.contains(Look::WordStartUnicode)
                        || self.contains(Look::WordEndUnicode)
                        || self.contains(Look::WordStartHalfUnicode)
                        || self.contains(Look::WordEndHalfUnicode)
               }
                
                #[inline] pub fn contains_word_ascii(self) -> bool {
                    self.contains(Look::WordAscii)
                        || self.contains(Look::WordAsciiNegate)
                        || self.contains(Look::WordStartAscii)
                        || self.contains(Look::WordEndAscii)
                        || self.contains(Look::WordStartHalfAscii)
                        || self.contains(Look::WordEndHalfAscii)
                }

                #[inline] pub fn iter(self) -> LookSetIter {
                    LookSetIter { set: self }
               }
                
                #[inline] pub fn insert(self, look: Look) -> LookSet {
                    LookSet { bits: self.bits | look.as_repr() }
               }
                
                #[inline] pub fn set_insert( &mut self, look: Look) {
                    *self = self.insert(look);
               }
                
                #[inline] pub fn remove(self, look: Look) -> LookSet {
                    LookSet { bits: self.bits & !look.as_repr() }
               }
                
                #[inline] pub fn set_remove( &mut self, look: Look) {
                    *self = self.remove(look);
               }
                
                #[inline] pub fn subtract(self, other: LookSet) -> LookSet {
                    LookSet { bits: self.bits & !other.bits }
               }
                
                #[inline] pub fn set_subtract( &mut self, other: LookSet) {
                    *self = self.subtract(other);
                }

                #[inline] pub fn union(self, other: LookSet) -> LookSet {
                    LookSet { bits: self.bits | other.bits }
               }
                
                #[inline] pub fn set_union( &mut self, other: LookSet) {
                    *self = self.union(other);
                }

                #[inline] pub fn intersect(self, other: LookSet) -> LookSet {
                    LookSet { bits: self.bits & other.bits }
               }
                
                #[inline] pub fn set_intersect( &mut self, other: LookSet) {
                    *self = self.intersect(other);
                }
                
                #[inline] pub fn read_repr(slice: &[u8]) -> LookSet {
                    let bits = u32::from_ne_bytes(slice[..4].try_into().unwrap());
                    LookSet { bits }
                }
                
                #[inline] pub fn write_repr(self, s: &mut [u8])
                {
                    let r = self.bits.to_ne_bytes();
                    s[0] = r[0];
                    s[1] = r[1];
                    s[2] = r[2];
                    s[3] = r[3];
                }
            }

            impl ::fmt::Debug for LookSet
            {
                fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {
                    if self.is_empty() {
                        return write!(f, "");
                    }
                    for look in self.iter() {
                        write!(f, "{}", look.as_char())?;
                    }
                    Ok( () )
                }
            }

            #[derive( Clone, Debug )]
            pub struct LookSetIter {
                set: LookSet,
            }

            impl Iterator for LookSetIter {
                type Item = Look;

                #[inline] fn next(&mut self) -> Option<Look> {
                    if self.set.is_empty() {
                        return None;
                    }
                    let bit = u16::try_from( self.set.bits.trailing_zeros()).unwrap();
                    let look = Look::from_repr(1 << bit)?;
                    self.set = self.set.remove(look);
                    Some(look)
                }
            }
            
            fn class_chars(hirs: &[Hir]) -> Option<Class> {
                let mut cls = ClassUnicode::new(vec![]);
                for hir in hirs.iter() {
                    match *hir.kind() {
                        HirKind::Class(Class::Unicode(ref cls2)) => { cls.union(cls2); }
                        HirKind::Class(Class::Bytes(ref cls2)) => { cls.union(&cls2.to_unicode_class()?); }
                        _ => return None,
                    };
                }
                Some(Class::Unicode(cls))
            }
            
            fn class_bytes(hirs: &[Hir]) -> Option<Class> {
                let mut cls = ClassBytes::new(vec![]);
                for hir in hirs.iter() {
                    match *hir.kind() {
                        HirKind::Class(Class::Unicode(ref cls2)) => { cls.union(&cls2.to_byte_class()?); }
                        HirKind::Class(Class::Bytes(ref cls2)) => { cls.union(cls2); }
                        _ => return None,
                    };
                }
                Some(Class::Bytes(cls))
            }
            
            fn singleton_chars(hirs: &[Hir]) -> Option<Vec<char>> {
                let mut singletons = vec![];
                for hir in hirs.iter() {
                    let literal = match *hir.kind() {
                        HirKind::Literal(Literal(ref bytes)) => bytes,
                        _ => return None,
                    };
                    let ch = match crate::debug::utf8_decode(literal) {
                        None => return None,
                        Some(Err(_)) => return None,
                        Some(Ok(ch)) => ch,
                    };
                    if literal.len() != ch.len_utf8() {
                        return None;
                    }
                    singletons.push(ch);
                }
                Some(singletons)
            }
            
            fn singleton_bytes(hirs: &[Hir]) -> Option<Vec<u8>> {
                let mut singletons = vec![];
                for hir in hirs.iter() {
                    let literal = match *hir.kind() {
                        HirKind::Literal(Literal(ref bytes)) => bytes,
                        _ => return None,
                    };
                    if literal.len() != 1 {
                        return None;
                    }
                    singletons.push(literal[0]);
                }
                Some(singletons)
            }
            
            fn lift_common_prefix(hirs: Vec<Hir>) -> Result<Hir, Vec<Hir>> {
                if hirs.len() <= 1 {
                    return Err(hirs);
                }
                let mut prefix = match hirs[0].kind() {
                    HirKind::Concat(ref xs) => &**xs,
                    _ => return Err(hirs),
                };
                if prefix.is_empty() {
                    return Err(hirs);
                }
                for h in hirs.iter().skip(1) {
                    let concat = match h.kind() {
                        HirKind::Concat(ref xs) => xs,
                        _ => return Err(hirs),
                    };
                    let common_len = prefix
                        .iter()
                        .zip(concat.iter())
                        .take_while(|(x, y)| x == y)
                        .count();
                    prefix = &prefix[..common_len];
                    if prefix.is_empty() {
                        return Err(hirs);
                    }
                }
                let len = prefix.len();
                assert_ne!(0, len);
                let mut prefix_concat = vec![];
                let mut suffix_alts = vec![];
                for h in hirs {
                    let mut concat = match h.into_kind() {
                        HirKind::Concat(xs) => xs,
                        // have a concat.
                        _ => unreachable!(),
                    };
                    suffix_alts.push(Hir::concat(concat.split_off(len)));
                    if prefix_concat.is_empty() {
                        prefix_concat = concat;
                    }
                }
                let mut concat = prefix_concat;
                concat.push(Hir::alternation(suffix_alts));
                Ok(Hir::concat(concat))
            }
        }
    
        pub mod parser
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            use crate::{ast, hir, Error};
            */

            pub fn parse(pattern: &str) -> Result<hir::Hir, Error> { Parser::new().parse(pattern) }

            #[derive( Clone, Debug, Default )]
            pub struct ParserBuilder {
                ast: ast::parse::ParserBuilder,
                hir: hir::translate::TranslatorBuilder,
            }

            impl ParserBuilder 
            {

                pub fn new() -> ParserBuilder {
                    ParserBuilder::default()
                }

                pub fn build( &self ) -> Parser { Parser { ast: self.ast.build(), hir: self.hir.build() } }

                pub fn nest_limit( &mut self, limit: u32) -> &mut ParserBuilder {
                    self.ast.nest_limit(limit);
                    self
                }
                
                pub fn octal( &mut self, yes:bool ) -> &mut ParserBuilder {
                    self.ast.octal(yes);
                    self
                }

                pub fn utf8( &mut self, yes:bool ) -> &mut ParserBuilder {
                    self.hir.utf8(yes);
                    self
                }

                pub fn ignore_whitespace( &mut self, yes:bool ) -> &mut ParserBuilder {
                    self.ast.ignore_whitespace(yes);
                    self
                }

                pub fn case_insensitive( &mut self, yes:bool ) -> &mut ParserBuilder {
                    self.hir.case_insensitive(yes);
                    self
                }

                pub fn multi_line( &mut self, yes:bool ) -> &mut ParserBuilder {
                    self.hir.multi_line(yes);
                    self
                }

                pub fn dot_matches_new_line( &mut self, yes:bool ) -> &mut ParserBuilder {
                    self.hir.dot_matches_new_line(yes);
                    self
                }
                
                pub fn crlf( &mut self, yes:bool ) -> &mut ParserBuilder {
                    self.hir.crlf(yes);
                    self
                }

                pub fn line_terminator( &mut self, byte: u8) -> &mut ParserBuilder {
                    self.hir.line_terminator( byte );
                    self
                }

                pub fn swap_greed( &mut self, yes:bool ) -> &mut ParserBuilder {
                    self.hir.swap_greed(yes);
                    self
                }

                pub fn unicode( &mut self, yes:bool ) -> &mut ParserBuilder {
                    self.hir.unicode(yes);
                    self
                }
            }
            #[derive( Clone, Debug )]
            pub struct Parser {
                ast: ast::parse::Parser,
                hir: hir::translate::Translator,
            }

            impl Parser 
            {

                pub fn new() -> Parser {
                    ParserBuilder::new().build()
                }

                pub fn parse( &mut self, pattern: &str) -> Result<hir::Hir, Error> {
                    let ast = self.ast.parse(pattern)?;
                    let hir = self.hir.translate(pattern, &ast)?;
                    Ok(hir)
                }
            }
        }
        
        pub mod rank
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub const BYTE_FREQUENCIES: [u8; 256] = 
            [
                55, 
                52, 
                51, 
                50, 
                49, 
                48, 
                47, 
                46, 
                45, 
                103,
                242,
                66, 
                67, 
                229,
                44, 
                43, 
                42, 
                41, 
                40, 
                39, 
                38, 
                37, 
                36, 
                35, 
                34, 
                33, 
                56, 
                32, 
                31, 
                30, 
                29, 
                28, 
                255,
                148,
                164,
                149,
                136,
                160,
                155,
                173,
                221,
                222,
                134,
                122,
                232,
                202,
                215,
                224,
                208,
                220,
                204,
                187,
                183,
                179,
                177,
                168,
                178,
                200,
                226,
                195,
                154,
                184,
                174,
                126,
                120,
                191,
                157,
                194,
                170,
                189,
                162,
                161,
                150,
                193,
                142,
                137,
                171,
                176,
                185,
                167,
                186,
                112,
                175,
                192,
                188,
                156,
                140,
                143,
                123,
                133,
                128,
                147,
                138,
                146,
                114,
                223,
                151,
                249,
                216,
                238,
                236,
                253,
                227,
                218,
                230,
                247,
                135,
                180,
                241,
                233,
                246,
                244,
                231,
                139,
                245,
                243,
                251,
                235,
                201,
                196,
                240,
                214,
                152,
                182,
                205,
                181,
                127,
                27, 
                212,
                211,
                210,
                213,
                228,
                197,
                169,
                159,
                131,
                172,
                105,
                80, 
                98, 
                96, 
                97, 
                81, 
                207,
                145,
                116,
                115,
                144,
                130,
                153,
                121,
                107,
                132,
                109,
                110,
                124,
                111,
                82, 
                108,
                118,
                141,
                113,
                129,
                119,
                125,
                165,
                117,
                92, 
                106,
                83, 
                72, 
                99, 
                93, 
                65, 
                79, 
                166,
                237,
                163,
                199,
                190,
                225,
                209,
                203,
                198,
                217,
                219,
                206,
                234,
                248,
                158,
                239,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
                255,
            ];
        }

        pub fn escape(text: &str) -> String
        {
            let mut quoted = String::new();
            escape_into(text, &mut quoted);
            quoted
        }

        pub fn escape_into(text: &str, buf: &mut String)
        {
            buf.reserve(text.len());

            for c in text.chars()
            {
                if is::meta_character(c) { buf.push('\\'); }

                buf.push(c);
            }
        }
    }

    pub fn escape( pattern:&str ) -> String
    {
        syntax::escape( pattern )
    }

    pub fn longest_common_prefix<'a, I, S>( iter: I ) -> Option<&'a str> where
    I: IntoIterator<Item=&'a S>,
    S: 'a + ?Sized + AsRef<str>
    {
        let mut iter = iter.into_iter();

        let mut pfx = iter.next()?.as_ref();

        for s in iter {
            let s = s.as_ref();

            let n = pfx.chars().zip( s.chars() )
                .take_while( |&( a, b )| a == b )
                .map( |( ch, _ )| ch.len_utf8() ).sum();

            if n == 0 {
                return None;
            } else {
                pfx = &pfx[..n];
            }
        }

        Some( pfx )
    }
    
    pub fn backward_word( n: usize, buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let mut chars = buf[..cur].char_indices().rev();

        for _ in 0..n 
        {
            iter::drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }

            iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }
        }

        match chars.next()
        {
            Some( ( ind, ch ) ) => ind + ch.len_utf8(),
            None => 0
        }
    }

    pub fn forward_word( n: usize, buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        for _ in 0..n 
        {
            iter::drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }
            iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }
        }

        match chars.next()
        {
            Some( ( ind, _ ) ) => cur + ind,
            None => buf.len()
        }
    }

    pub fn back_n_words( n: usize, buf:&str, cur: usize, word_break:&str ) -> ops::Range<usize>
    {
        let prev = regex::backward_word( 1, buf, cur, word_break );
        let end = regex::word_end( &buf, prev, word_break );

        if n > 1 {
            let start = regex::backward_word( n - 1, buf, prev, word_break );
            start..end
        } else {
            prev..end
        }
    }

    pub fn forward_n_words( n: usize, buf:&str, cur: usize, word_break:&str ) -> ops::Range<usize>
    {
        let start = next_word( 1, buf, cur, word_break );

        if n > 1 {
            let last = next_word( n - 1, buf, start, word_break );
            let end = regex::word_end( buf, last, word_break );
            start..end
        } else {
            let end = regex::word_end( buf, start, word_break );
            start..end
        }
    }

    pub fn first_word( buf:&str, word_break:&str ) -> Option<usize>
    {
        let mut chars = buf.char_indices();

        iter::drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );

        chars.next().map( |( idx, _ )| idx )
    }

    pub fn word_start( buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let fwd = match buf[cur..].chars().next() {
            Some( ch ) => word_break.contains( ch ),
            None => return buf.len()
        };

        if fwd {
            next_word( 1, buf, cur, word_break )
        } else {
            let mut chars = buf[..cur].char_indices().rev();

            iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );

            match chars.next() {
                Some( ( idx, ch ) ) => idx + ch.len_utf8(),
                None => 0
            }
        }
    }

    pub fn next_word( n: usize, buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        for _ in 0..n 
        {
            iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }

            iter::drop_while( &mut chars, |( _, ch )| word_break.contains( ch ) );
            if chars.clone().next().is_none() { break; }
        }

        match chars.next() 
        {
            Some( ( idx, _ ) ) => cur + idx,
            None => buf.len()
        }
    }

    pub fn word_end( buf:&str, cur: usize, word_break:&str ) -> usize
    {
        let mut chars = buf[cur..].char_indices();

        iter::drop_while( &mut chars, |( _, ch )| !word_break.contains( ch ) );

        match chars.next()
        {
            Some( ( idx, _ ) ) => cur + idx,
            None => buf.len()
        }
    }
    
    pub fn find_matching_parenthesis( s:&str, quotes:&str, open:char, close:char ) -> Option<usize>
    {
        let mut chars = s.char_indices().rev();
        let mut level = 0;
        let mut string_delim = None;

        while let Some( ( ind, ch ) ) = chars.next()
        {
            if string_delim == Some( ch ) {
                string_delim = None;
            } else if quotes.contains( ch ) {
                string_delim = Some( ch );
            } else if string_delim.is_none() && ch == close {
                level += 1;
            } else if string_delim.is_none() && ch == open {
                level -= 1;

                if level == 0 {
                    return Some( ind );
                }
            }
        }

        None
    }

    pub fn match_name( name:&str, value:&str ) -> bool
    {
        name == value || ( name.starts_with( value ) && name.as_bytes()[value.len()] == b'-' )
    }

    pub fn contains( needle:&str, haystack:&str ) -> bool
    {
        let haystack = match Regex::new( haystack )
        {
            Ok( x ) => x,
            Err( e ) =>
            {
                println!( "Regex new error: {:?}", e );
                return false;
            }
        };

        haystack.is_match( needle )
    }

    pub fn find_first_group( ptn: &str, text:&str ) -> Option<String>
    {
        let re = match regex::Regex::new( ptn )
        {
            Ok( x ) => x,
            Err(_ ) => return None,
        };

        match re.captures( text )
        {
            Some( Caps ) =>
            {
                if let Some( x ) = caps.get(1) { return Some(x.as_str().to_owned() ); }
            }

            None => { return None; }
        }

        None
    }

    pub fn replace_all( text: &str, ptn: &str, ptn_to:&str ) -> String
    {
        let re = regex::Regex::new( ptn ).unwrap();
        let result = re.replace_all( text, ptn_to);
        result.to_string()
    }
}

pub mod result
{
    pub use std::result::{ * };
    use ::
    {
        error::{ OverError, ParseError },
        *,
    };

    pub type OverResult<T> = Result<T, OverError>;    
    /*
    */
    pub type ParseResult<T> = Result<T, ParseError>;
}

pub mod shell
{
    /*!
    */
    use ::
    {
        collections::{ HashMap, HashSet },
        error::no::{ errno },
        io::{ Write },
        regex::{ Regex },
        types::{ * },
        uuid::{ Uuid },
        *,
    };
    /*
    */
    #[derive( Debug, Clone )]
    pub struct Shell
    {
        pub jobs: HashMap<i32, Job>,
        pub aliases: HashMap<String, String>,
        pub envs: HashMap<String, String>,
        pub funcs: HashMap<String, String>,
        pub cmd: String,
        pub current_dir: String,
        pub previous_dir: String,
        pub previous_cmd: String,
        pub previous_status: i32,
        pub is_login: bool,
        pub exit_on_error: bool,
        pub has_terminal: bool,
        pub session_id: String,
    }
    
    impl Shell
    {
        pub fn new() -> Shell
        {
            let uuid = Uuid::new_v4().as_hyphenated().to_string();
            let current_dir = get::current_directory();
            let has_terminal = has::terminal();
            let ( session_id, _ ) = uuid.split_at( 13 );
            Shell
            {
                jobs: HashMap::new(),
                aliases: HashMap::new(),
                envs: HashMap::new(),
                funcs: HashMap::new(),
                cmd: String::new(),
                current_dir: current_dir.clone(),
                previous_dir: String::new(),
                previous_cmd: String::new(),
                previous_status: 0,
                is_login: false,
                exit_on_error: false,
                has_terminal,
                session_id: session_id.to_string(),
            }
        }
    }
}

pub mod slice
{
    pub use std::slice::{ * };
}

pub mod str
{
    pub use std::str::{ * };
    use ::
    {
        borrow::{ Borrow, BorrowMut, Cow },
        boxed::{ Box },
        cmp::{ Ordering },
        convert::{ Infallible },
        ffi::{ OsStr, OsString },
        fs::{ File },
        hash::{ Hash, Hasher },
        io::{ Read, Write },
        iter::{ FromIterator, FusedIterator },
        marker::{ PhantomData },
        smallvec::{ Array, SmallVec },
        string::{ String },
        *,
    };
    /*
    */
    macro_rules! eq_str 
    {
        ( $rhs:ty ) =>
        {
            impl<'a, A: Array<Item = u8>> PartialEq<$rhs> for SmallString<A>
            {
                #[inline] fn eq( &self, rhs:&$rhs ) -> bool { self[..] == rhs[..] }
            }
        };
    }

    pub struct Prefixes<'a>
    {
        s:&'a str,
        iter: CharIndices<'a>,
    }

    #[inline] pub fn prefixes( s:&str ) -> Prefixes
    {
        Prefixes
        {
            s,
            iter: s.char_indices(),
        }
    }
    
    impl<'a> Iterator for Prefixes<'a>
    {
        type Item = &'a str;

        fn next( &mut self ) -> Option<&'a str> { self.iter.next().map( |( idx, ch )| &self.s[..idx + ch.len_utf8()] ) }
    }

    pub fn read_from_file( fname:&str ) -> io::Result<String>
    {
        let mut file = File::open( fname )?;

        let mut contents = String::new();
        let _ = file.read_to_string( &mut contents )?;

        Ok( contents )
    }

    //pub fn write_file_str( fname:&str, contents:&str ) -> io::Result<()>
    pub fn write_file_from( fname:&str, contents:&str ) -> io::Result<()>
    {
       
        let mut file = File::create( fname )?;

        file.write_all( contents.as_bytes() )?;

        Ok( () )
    }

    #[derive( Clone, Default )]
    pub struct SmallString<A: Array<Item = u8>> { data: SmallVec<A>, }

    impl<A: Array<Item = u8>> SmallString<A> {

        #[inline] pub fn new() -> SmallString<A> {
            SmallString {
                data: SmallVec::new(),
            }
        }
        #[inline] pub fn with_capacity( n: usize ) -> SmallString<A> {
            SmallString {
                data: SmallVec::with_capacity( n ),
            }
        }

        #[allow( clippy::should_implement_trait )]
        #[inline] pub fn from_str( s:&str ) -> SmallString<A> {
            SmallString {
                data: SmallVec::from_slice( s.as_bytes() ),
            }
        }

        #[inline] pub fn from_string( s: String ) -> SmallString<A> {
            SmallString {
                data: SmallVec::from_vec( s.into_bytes() ),
            }
        }

        #[inline] pub fn from_buf( buf: A ) -> Result<SmallString<A>, FromUtf8Error<A>>
        {
            let data = SmallVec::from_buf( buf );

            match str::from_utf8( &data ) {
                Ok( _ ) => Ok( SmallString { data } ),
                Err( error ) => {
                    let buf = data.into_inner().ok().unwrap();

                    Err( FromUtf8Error { buf, error } )
                }
            }
        }
        #[inline] pub unsafe fn from_buf_unchecked( buf: A ) -> SmallString<A> {
            SmallString {
                data: SmallVec::from_buf( buf ),
            }
        }

        #[inline] pub fn inline_size( &self ) -> usize { A::size() }

        #[inline] pub fn len( &self ) -> usize { self.data.len() }

        #[inline] pub fn is_empty( &self ) -> bool { self.data.is_empty() }

        #[inline] pub fn capacity( &self ) -> usize { self.data.capacity() }

        #[inline] pub fn spilled( &self ) -> bool { self.data.spilled() }

        pub fn drain( &mut self ) -> Drain<'_> {
            unsafe {
                let len = self.len();

                self.data.set_len( 0 );

                let ptr = self.as_ptr();

                let slice = slice::from_raw_parts( ptr, len );
                let s = str::from_utf8_unchecked( slice );

                Drain { iter: s.chars() }
            }
        }

        pub fn drain_range<R>( &mut self, range: R ) -> DrainRange<'_, A>
        where
            R: ops::RangeBounds<usize>,
        {
            DrainRange {
                drain: self.data.drain( range ),
            }
        }

        #[inline] pub fn push( &mut self, ch:char ) {
            match ch.len_utf8() {
                1 => self.data.push( ch as u8 ),
                _ => self.push_str( ch.encode_utf8( &mut [0; 4] ) ),
            }
        }

        #[inline] pub fn push_str( &mut self, s:&str ) {
            self.data.extend_from_slice( s.as_bytes() );
        }

        #[inline] pub fn pop( &mut self ) -> Option<char> 
        {
            match self.chars().next_back() {
                Some( ch ) => unsafe {
                    let new_len = self.len() - ch.len_utf8();
                    self.data.set_len( new_len );
                    Some( ch )
                },
                None => None,
            }
        }

        #[inline] pub fn grow( &mut self, new_cap: usize ) {
            self.data.grow( new_cap );
        }
        #[inline] pub fn reserve( &mut self, additional: usize ) {
            self.data.reserve( additional );
        }
        #[inline] pub fn reserve_exact( &mut self, additional: usize ) {
            self.data.reserve( additional );
        }

        #[inline] pub fn shrink_to_fit( &mut self ) {
            self.data.shrink_to_fit();
        }

        #[inline] pub fn truncate( &mut self, len: usize ) {
            assert!( self.is_char_boundary( len ) );
            self.data.truncate( len );
        }

        #[inline] pub fn as_str( &self ) -> &str { self }

        #[inline] pub fn as_mut_str( &mut self ) -> &mut str { self }

        #[inline] pub fn clear( &mut self ) {
            self.data.clear();
        }

        #[inline] pub fn remove( &mut self, idx: usize ) -> char {
            let ch = match self[idx..].chars().next() {
                Some( ch ) => ch,
                None => panic!( "cannot remove a char from the end of a string" ),
            };

            let ch_len = ch.len_utf8();
            let next = idx + ch_len;
            let len = self.len();

            unsafe {
                let ptr = self.as_mut_ptr();

                ptr::copy( ptr.add( next ), ptr.add( idx ), len - next );
                self.data.set_len( len - ch_len );
            }

            ch
        }

        #[inline] pub fn insert( &mut self, idx: usize, ch:char ) {
            assert!( self.is_char_boundary( idx ) );

            match ch.len_utf8() {
                1 => self.data.insert( idx, ch as u8 ),
                _ => self.insert_str( idx, ch.encode_utf8( &mut [0; 4] ) ),
            }
        }

        #[inline] pub fn insert_str( &mut self, idx: usize, s:&str ) {
            assert!( self.is_char_boundary( idx ) );

            let len = self.len();
            let amt = s.len();

            self.data.reserve( amt );

            let ptr = self.as_mut_ptr();

            unsafe {
                ptr::copy( ptr.add( idx ), ptr.add( idx + amt ), len - idx );
                ptr::copy_nonoverlapping( s.as_ptr(), ptr.add( idx ), amt );
                self.data.set_len( len + amt );
            }
        }

        #[inline] pub unsafe fn as_mut_vec( &mut self ) -> &mut SmallVec<A> { &mut self.data }
        #[inline] pub fn into_string( self ) -> String {
            unsafe { String::from_utf8_unchecked( self.data.into_vec() ) }
        }
        #[inline] pub fn into_boxed_str( self ) -> Box<str> { self.into_string().into_boxed_str() }

        #[inline] pub fn into_inner( self ) -> Result<A, Self> { self.data.into_inner().map_err( |data| SmallString { data } ) }

        #[inline] pub fn retain<F: FnMut( char ) -> bool>( &mut self, mut f: F ) {
            struct SetLenOnDrop<'a, A: Array<Item = u8>> {
                s:&'a mut SmallString<A>,
                idx: usize,
                del_bytes: usize,
            }

            impl<'a, A: Array<Item = u8>> Drop for SetLenOnDrop<'a, A> {
                fn drop( &mut self ) {
                    let new_len = self.idx - self.del_bytes;
                    debug_assert!( new_len <= self.s.len() );
                    unsafe { self.s.data.set_len( new_len ) };
                }
            }

            let len = self.len();
            let mut guard = SetLenOnDrop {
                s: self,
                idx: 0,
                del_bytes: 0,
            };

            while guard.idx < len {
                let ch = unsafe {
                    guard
                        .s
                        .get_unchecked( guard.idx..len )
                        .chars()
                        .next()
                        .unwrap()
                };
                let ch_len = ch.len_utf8();

                if !f( ch ) {
                    guard.del_bytes += ch_len;
                } else if guard.del_bytes > 0 {
                    let ptr = guard.s.as_mut_ptr();

                    unsafe {
                        ptr::copy( 
                            ptr.add( guard.idx ),
                            ptr.add( guard.idx - guard.del_bytes ),
                            ch_len,
                         );
                    }
                }
                
                guard.idx += ch_len;
            }

            drop( guard );
        }

        fn as_ptr( &mut self ) -> *const u8 { self.data.as_ptr() }
        fn as_mut_ptr( &mut self ) -> *mut u8 { self.data.as_mut_ptr() }
    }

    impl<A: Array<Item = u8>> ops::Deref for SmallString<A> {
        type Target = str;

        #[inline] fn deref( &self ) -> &str {
            let bytes:&[u8] = &self.data;
            unsafe { str::from_utf8_unchecked( bytes ) }
        }
    }

    impl<A: Array<Item = u8>> ops::DerefMut for SmallString<A> {
        #[inline] fn deref_mut( &mut self ) -> &mut str {
            let bytes:&mut [u8] = &mut self.data;
            unsafe { str::from_utf8_unchecked_mut( bytes ) }
        }
    }

    impl<A: Array<Item = u8>> AsRef<str> for SmallString<A> { #[inline] fn as_ref( &self ) -> &str { self } }

    impl<A: Array<Item = u8>> AsMut<str> for SmallString<A> { #[inline] fn as_mut( &mut self ) -> &mut str { self } }

    impl<A: Array<Item = u8>> Borrow<str> for SmallString<A> { #[inline] fn borrow( &self ) -> &str { self } }

    impl<A: Array<Item = u8>> BorrowMut<str> for SmallString<A> { #[inline] fn borrow_mut( &mut self ) -> &mut str { self } }

    impl<A: Array<Item = u8>> AsRef<[u8]> for SmallString<A> {
        #[inline] fn as_ref( &self ) -> &[u8] { self.data.as_ref() }
    }

    impl<A: Array<Item = u8>> fmt::Write for SmallString<A> {
        #[inline] fn write_str( &mut self, s:&str ) -> fmt::Result {
            self.push_str( s  );
            Ok( () )
        }

        #[inline] fn write_char( &mut self, ch:char ) -> fmt::Result {
            self.push( ch );
            Ok( () )
        }
    }

    impl<A: Array<Item = u8>> FromStr for SmallString<A> {
        type Err = Infallible;

        fn from_str( s:&str ) -> Result<Self, Self::Err> { Ok( SmallString::from( s ) ) }
    }
    
    impl<A: Array<Item = u8>> From<char> for SmallString<A> {
        #[inline] fn from( ch:char ) -> SmallString<A> { SmallString::from_str( ch.encode_utf8( &mut [0; 4] ) ) }
    }

    impl<A: Array<Item = u8>> From<&'_ str> for SmallString<A> {
        #[inline] fn from( s:&str ) -> SmallString<A> { SmallString::from_str( s ) }
    }

    impl<A: Array<Item = u8>> From<Box<str>> for SmallString<A> {
        #[inline] fn from( s: Box<str> ) -> SmallString<A> { SmallString::from_string( s.into() ) }
    }

    impl<A: Array<Item = u8>> From<String> for SmallString<A> {
        #[inline] fn from( s: String ) -> SmallString<A> { SmallString::from_string( s ) }
    }

    impl<'a, A: Array<Item = u8>> From<Cow<'a, str>> for SmallString<A> {
        fn from( value: Cow<'a, str> ) -> Self {
            match value {
                Cow::Borrowed( s ) => Self::from_str( s ),
                Cow::Owned( s ) => Self::from_string( s ),
            }
        }
    }

    macro_rules! impl_index_str {
        ( $index_type: ty ) => {
            impl<A: Array<Item = u8>> ops::Index<$index_type> for SmallString<A>
            {
                type Output = str;

                #[inline] fn index( &self, index: $index_type ) -> &str {
                    &self.as_str()[index]
                }
            }

            impl<A: Array<Item = u8>> ops::IndexMut<$index_type> for SmallString<A> {
                #[inline] fn index_mut( &mut self, index: $index_type ) -> &mut str {
                    &mut self.as_mut_str()[index]
                }
            }
        };
    }

    impl_index_str!( ops::Range<usize> );
    impl_index_str!( ops::RangeFrom<usize> );
    impl_index_str!( ops::RangeTo<usize> );
    impl_index_str!( ops::RangeFull );

    impl<A: Array<Item = u8>> FromIterator<char> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = char>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a char> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = &'a char>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter.into_iter().cloned() );
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<Cow<'a, str>> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = Cow<'a, str>>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<'a, A: Array<Item = u8>> FromIterator<&'a str> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = &'a str>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<A: Array<Item = u8>> FromIterator<String> for SmallString<A> {
        fn from_iter<I: IntoIterator<Item = String>>( iter: I ) -> SmallString<A>
        {
            let mut s = SmallString::new();
            s.extend( iter );
            s
        }
    }

    impl<A: Array<Item = u8>> Extend<char> for SmallString<A> {
        fn extend<I: IntoIterator<Item = char>>( &mut self, iter: I ) {
            let iter = iter.into_iter();
            let ( lo, _ ) = iter.size_hint();

            self.reserve( lo );

            for ch in iter {
                self.push( ch );
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a char> for SmallString<A> {
        fn extend<I: IntoIterator<Item = &'a char>>( &mut self, iter: I ) {
            self.extend( iter.into_iter().cloned() );
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<Cow<'a, str>> for SmallString<A> {
        fn extend<I: IntoIterator<Item = Cow<'a, str>>>( &mut self, iter: I ) {
            for s in iter {
                self.push_str( &s );
            }
        }
    }

    impl<'a, A: Array<Item = u8>> Extend<&'a str> for SmallString<A> {
        fn extend<I: IntoIterator<Item = &'a str>>( &mut self, iter: I ) {
            for s in iter {
                self.push_str( s  );
            }
        }
    }

    impl<A: Array<Item = u8>> Extend<String> for SmallString<A> {
        fn extend<I: IntoIterator<Item = String>>( &mut self, iter: I ) {
            for s in iter {
                self.push_str( &s );
            }
        }
    }

    impl<A: Array<Item = u8>> fmt::Debug for SmallString<A> {
        #[inline] fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            fmt::Debug::fmt( &**self, f )
        }
    }

    impl<A: Array<Item = u8>> fmt::Display for SmallString<A> {
        #[inline] fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            fmt::Display::fmt( &**self, f )
        }
    }

    eq_str!( str );
    eq_str!( &'a str );
    eq_str!( String );
    eq_str!( Cow<'a, str> );
    
    impl<A: Array<Item = u8>> PartialEq<OsStr> for SmallString<A> 
    {
        #[inline] fn eq( &self, rhs:&OsStr ) -> bool {
            &self[..] == rhs
        }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<&'a OsStr> for SmallString<A> 
    {
        #[inline] fn eq( &self, rhs:&&OsStr ) -> bool {
            &self[..] == *rhs
        }
    }
    
    impl<A: Array<Item = u8>> PartialEq<OsString> for SmallString<A> 
    {
        #[inline] fn eq( &self, rhs:&OsString ) -> bool {
            &self[..] == rhs
        }
    }
    
    impl<'a, A: Array<Item = u8>> PartialEq<Cow<'a, OsStr>> for SmallString<A> 
    {
        #[inline] fn eq( &self, rhs:&Cow<OsStr> ) -> bool {
            self[..] == **rhs
        }
    }

    impl<A, B> PartialEq<SmallString<B>> for SmallString<A> where
        A: Array<Item = u8>,
        B: Array<Item = u8>,
    {
        #[inline] fn eq( &self, rhs:&SmallString<B> ) -> bool {
            self[..] == rhs[..]
        }
    }

    impl<A: Array<Item = u8>> Eq for SmallString<A> {}

    impl<A: Array<Item = u8>> PartialOrd for SmallString<A> 
    {
        #[inline] fn partial_cmp( &self, rhs:&SmallString<A> ) -> Option<Ordering> { Some( self.cmp( rhs ) ) }
    }

    impl<A: Array<Item = u8>> Ord for SmallString<A> 
    {
        #[inline] fn cmp( &self, rhs:&SmallString<A> ) -> Ordering {
            self[..].cmp( &rhs[..] )
        }
    }

    impl<A: Array<Item = u8>> Hash for SmallString<A> 
    {
        #[inline] fn hash<H: Hasher>( &self, state:&mut H ) {
            self[..].hash( state )
        }
    }

    pub struct Drain<'a> { iter: Chars<'a>, }

    impl<'a> Iterator for Drain<'a> 
    {
        type Item = char;

        #[inline] fn next( &mut self ) -> Option<char> { self.iter.next() }

        #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) { self.iter.size_hint() }
    }

    impl<'a> DoubleEndedIterator for Drain<'a> 
    {
        #[inline] fn next_back( &mut self ) -> Option<char> { self.iter.next_back() }
    }

    pub struct DrainRange<'a, A: Array<Item = u8>> 
    {
        drain: smallvec::Drain<'a, A>,
    }

    impl<A: Array<Item = u8>> fmt::Debug for DrainRange<'_, A> 
    {
        fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
            self.drain.fmt( f )
        }
    }

    impl<A: Array<Item = u8>> Iterator for DrainRange<'_, A> 
    {
        type Item = char;

        fn next( &mut self ) -> Option<Self::Item>
        {
            let mut buf = [0; 4];

            buf[0] = self.drain.next()?;
            let utf8_len = 1.max( buf[0].leading_ones() as usize );

            for b in &mut buf[1..utf8_len] {
                *b = self.drain.next().unwrap();
            }

            unsafe { str::from_utf8_unchecked( &buf[..utf8_len] ) }
                .chars()
                .next()
        }

        fn size_hint( &self ) -> ( usize, Option<usize> ) {
            let len = self.drain.len();
            ( len.div_ceil( 4 ), Some( len ) )
        }
    }

    impl<A: Array<Item = u8>> DoubleEndedIterator for DrainRange<'_, A> 
    {
        fn next_back( &mut self ) -> Option<Self::Item>
        {
            let mut buf = [0; 4];
            let mut i = 3;

            buf[i] = self.drain.next_back()?;

            while buf[i].leading_ones() == 1 {
                i -= 1;
                buf[i] = self.drain.next_back().unwrap();
            }

            unsafe { str::from_utf8_unchecked( &buf[i..] ) }
                .chars()
                .next()
        }
    }
    impl<A: Array<Item = u8>> FusedIterator for DrainRange<'_, A> {}

    #[derive( Debug )]
    pub struct FromUtf8Error<A: Array<Item = u8>> 
    {
        buf: A,
        error: Utf8Error,
    }

    impl<A: Array<Item = u8>> FromUtf8Error<A> 
    {

        #[inline] pub fn as_bytes( &self ) -> &[u8] {
            let ptr = &self.buf as *const _ as *const u8;
            unsafe { slice::from_raw_parts( ptr, A::size() ) }
        }

        #[inline] pub fn into_buf( self ) -> A {
            self.buf
        }

        #[inline] pub fn utf8_error( &self ) -> Utf8Error { self.error }
    }

    impl<A: Array<Item = u8>> fmt::Display for FromUtf8Error<A>
    {
        #[inline] fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            fmt::Display::fmt( &self.error, f )
        }
    }
    
    pub fn filter_visible( s:&str ) -> Cow<str>
    {
        use ::system::reader::{START_INVISIBLE, END_INVISIBLE};

        if !s.contains( START_INVISIBLE ) { return Cow::Borrowed( s ); }

        let mut virt = String::new();
        let mut ignore = false;

        for ch in s.chars()
        {
            if ch == START_INVISIBLE { ignore = true; }
            
            else if ch == END_INVISIBLE { ignore = false; }

            else if !ignore { virt.push( ch  ); }
        }

        Cow::Owned( virt )
    }
}

pub mod string
{
    pub use std::string::{ * };
}

pub mod sync
{
    pub use std::sync::{ * };
}
/*
    linefeed v0.0.0
    mortal v0.0.0
    terminfo v0.0.0
*/
pub mod system
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    nix v0.0.0
    
    use nix::unistd::{read, write};
    */
    pub mod api
    {
        /*!
        */
        use ::
        {
            cell::{ Ref, RefCell },
            convert::{ TryFrom },
            ffi::{ c_void },
            hash::{ Hash, Hasher },
            iter::{ FromIterator, FusedIterator },
            ops::{ BitOr, Range },
            os::
            {
                fd::{ AsFd, AsRawFd, BorrowedFd, RawFd },
            },
            ptr::{ null_mut },
            *,
        };
        /*
        */
        
        pub type __fsword_t = i64;
        pub type clock_t = i64;
        
        pub type c_char = i8;
        pub type c_double = f64;
        pub type c_float = f32;
        pub type c_int = i32;
        cfg_if!
        {
            if #[cfg(all(target_pointer_width = "64", not(windows)))]
            {
                pub type c_long = i64;
                pub type c_ulong = u64;
            }
            
            else
            {
                pub type c_long = i32;
                pub type c_ulong = u32;
            }
        }
        pub type c_longlong = i64;
        pub type c_schar = i8;
        pub type c_short = i16;
        pub type c_uchar = u8;
        pub type c_uint = u32;
        pub type c_ulonglong = u64;
        pub type c_ushort = u16;        
        pub type cc_t = c_uchar;
        
        pub type Error = Errno;

        pub type gid_t = u32;

        pub type intptr_t = isize;

        pub type pid_t = i32;
        pub type ptrdiff_t = isize;

        pub type Result<Type> = ::result::Result<Type, Errno>;
        
        pub type SaFlags_t = c_int;
        pub type sighandler_t = size_t;
        pub type size_t = usize;
        pub type speed_t = c_uint;
        pub type ssize_t = isize;
        pub type suseconds_t = i64;
        
        pub type tcflag_t = c_uint;
        pub type time_t = i64;

        pub type uintptr_t = usize;
        
        pub type uid_t = u32;

        
        pub const EDEADLOCK: c_int = 35;
        pub const EISNAM: c_int = 120;
        pub const ENAVAIL: c_int = 119;
        pub const ENOTNAM: c_int = 118;
        pub const EREMOTEIO: c_int = 121;
        pub const EUCLEAN: c_int = 117;        

        pub const EPERM: c_int = 1;
        pub const ENOENT: c_int = 2;
        pub const ESRCH: c_int = 3;
        pub const EINTR: c_int = 4;
        pub const EIO: c_int = 5;
        pub const ENXIO: c_int = 6;
        pub const E2BIG: c_int = 7;
        pub const ENOEXEC: c_int = 8;
        pub const EBADF: c_int = 9;
        pub const ECHILD: c_int = 10;
        pub const EAGAIN: c_int = 11;
        pub const ENOMEM: c_int = 12;
        pub const EACCES: c_int = 13;
        pub const EFAULT: c_int = 14;
        pub const ENOTBLK: c_int = 15;
        pub const EBUSY: c_int = 16;
        pub const EEXIST: c_int = 17;
        pub const EXDEV: c_int = 18;
        pub const ENODEV: c_int = 19;
        pub const ENOTDIR: c_int = 20;
        pub const EISDIR: c_int = 21;
        pub const EINVAL: c_int = 22;
        pub const ENFILE: c_int = 23;
        pub const EMFILE: c_int = 24;
        pub const ENOTTY: c_int = 25;
        pub const ETXTBSY: c_int = 26;
        pub const EFBIG: c_int = 27;
        pub const ENOSPC: c_int = 28;
        pub const ESPIPE: c_int = 29;
        pub const EROFS: c_int = 30;
        pub const EMLINK: c_int = 31;
        pub const EPIPE: c_int = 32;
        pub const EDOM: c_int = 33;
        pub const ERANGE: c_int = 34;
        
        pub const FD_SETSIZE: c_int = 1024;
        
        pub const INT_MIN: c_int = -2147483648;
        pub const INT_MAX: c_int = 2147483647;

        pub const NANOS_PER_SEC: i64 = 1_000_000_000;
        pub const NCCS: usize = 32;

        pub const SECS_PER_MINUTE: i64 = 60;
        pub const SECS_PER_HOUR: i64 = 3600;
        pub const SIG_DFL: sighandler_t = 0 as sighandler_t;
        pub const SIG_IGN: sighandler_t = 1 as sighandler_t;
        pub const SIG_ERR: sighandler_t = !0 as sighandler_t;
        pub const SIG_HUP: c_int = 1;
        pub const SIG_INT: c_int = 2;
        pub const SIG_QUIT: c_int = 3;
        pub const SIG_ILL: c_int = 4;
        pub const SIG_ABRT: c_int = 6;
        pub const SIG_FPE: c_int = 8;
        pub const SIG_KILL: c_int = 9;
        pub const SIG_SEGV: c_int = 11;
        pub const SIG_PIPE: c_int = 13;
        pub const SIG_ALRM: c_int = 14;
        pub const SIG_TERM: c_int = 15;
        pub const SIG_TSTP: c_int = 20;

        pub const VDISCARD: usize = 13;
        pub const VMIN: usize = 6;
        pub const VREPRINT: usize = 12;
        pub const VSUSP: usize = 10;
        pub const VSTART: usize = 8;
        pub const VSTOP: usize = 9;        
        pub const VTIME: usize = 5;
        pub const VWERASE: usize = 14;
        extern "C"
        {
            pub fn fork() -> pid_t;
            pub fn getpgid( pid: pid_t ) -> pid_t;
            pub fn getpgrp() -> pid_t;
            pub fn getpid() -> pid_t;
            pub fn getppid() -> pid_t;
            pub fn getuid() -> uid_t;
            pub fn isatty( fd: c_int ) -> c_int;
            pub fn pipe( fds: *mut c_int ) -> c_int;
            pub fn select
            ( 
                nfds: c_int,
                readfds: *mut FDSet,
                writefds: *mut FDSet,
                errorfds: *mut FDSet,
                timeout: *mut TimeValue,
            ) -> c_int;
            pub fn sigaction( signum:c_int, act:*const SignalAction, oldact:*mut SignalAction ) -> c_int;
            pub fn signal( signum:c_int, handler:sighandler_t ) -> sighandler_t;
            pub fn sigaddset( set:*mut SignalSet, signum:c_int ) -> c_int;
            pub fn sigemptyset( set:*mut SignalSet ) -> c_int;
            pub fn sigismember( set:*const SignalSet, signum:c_int ) -> c_int;
            pub fn sigfillset( set: *mut SignalSet ) -> c_int;
            pub fn strlen( Cs: *const c_char ) -> size_t;
            pub fn strerror_r( errnum:c_int, buf: *mut c_char, buflen: size_t ) -> c_int;
            pub fn tcgetpgrp( fd:c_int ) -> pid_t;
            pub fn tcsetpgrp( fd:c_int, pgrp:pid_t ) -> c_int;
        }
        // Controls the behavior of a [`SigAction`]
        libc_bitflags!
        {
            pub struct SaFlags: SaFlags_t {
                SA_NOCLDSTOP;
                #[cfg( not( target_os = "hurd" ) )]
                SA_NOCLDWAIT;
                SA_NODEFER;
                SA_ONSTACK;
                SA_RESETHAND;
                SA_RESTART;

                SA_SIGINFO;
            }
        }
        
        pub use self::Signal::*;
        pub const SIGNALS: [Signal; 29] =
        [
            SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS, SIGFPE, SIGKILL,
            SIGUSR1, SIGSEGV, SIGUSR2, SIGPIPE, SIGALRM, SIGTERM, SIGCHLD, SIGCONT,
            SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM,
            SIGPROF, SIGWINCH, SIGIO, SIGSYS
        ];

        #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SignalIterator
        {
            next: usize,
        }

        impl Iterator for SignalIterator
        {
            type Item = Signal;
            fn next( &mut self ) -> Option<Signal>
            {
                if self.next < SIGNALS.len() {
                    let next_signal = SIGNALS[self.next];
                    self.next += 1;
                    Some( next_signal )
                } else {
                    None
                }
            }
        }

        impl Signal
        {

            pub const fn iterator() -> SignalIterator { SignalIterator{ next:0 } }
        }
        //sigset_t
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SignalSet
        {
            #[cfg( target_pointer_width = "32" )]
            pub __val: [u32; 32],
            #[cfg( target_pointer_width = "64" )]
            pub __val: [u64; 16],
        }

        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SigSet
        {
            sigset:SignalSet
        }

        impl SigSet
        {

            pub fn add( &mut self, signal: Signal ) { unsafe { sigaddset( &mut self.sigset, signal as c_int ) }; }

            pub fn all() -> SigSet
            {
                let mut sigset = mem::MaybeUninit::uninit();
                let _ = unsafe { sigfillset( sigset.as_mut_ptr() ) };

                unsafe{ SigSet { sigset: sigset.assume_init() } }
            }

            pub fn contains( &self, signal: Signal ) -> bool
            {
                let res = unsafe { sigismember( &self.sigset, signal as c_int ) };

                match res
                {
                    1 => true,
                    0 => false,
                    _ => unreachable!( "unexpected value from sigismember" ),
                }
            }

            pub fn empty() -> SigSet
            {
                let mut sigset = mem::MaybeUninit::uninit();
                let _ = unsafe { sigemptyset( sigset.as_mut_ptr() ) };
                unsafe{ SigSet { sigset: sigset.assume_init() } }
            }

            pub fn iter( &self ) -> SigSetIter<'_> { self.into_iter() }
        }

        impl From<Signal> for SigSet 
        {
            fn from( signal: Signal ) -> SigSet {
                let mut sigset = SigSet::empty();
                sigset.add( signal );
                sigset
            }
        }

        impl BitOr for Signal 
        {
            type Output = SigSet;
            fn bitor( self, rhs: Self ) -> Self::Output {
                let mut sigset = SigSet::empty();
                sigset.add( self );
                sigset.add( rhs );
                sigset
            }
        }

        impl BitOr<Signal> for SigSet 
        {
            type Output = SigSet;
            fn bitor( mut self, rhs: Signal ) -> Self::Output {
                self.add( rhs );
                self
            }
        }

        impl BitOr for SigSet 
        {
            type Output = Self;
            fn bitor( self, rhs: Self ) -> Self::Output {
                self.iter().chain( rhs.iter() ).collect()
            }
        }

        impl AsRef<SignalSet> for SigSet
        {
            fn as_ref( &self ) -> &SignalSet
            {
                &self.sigset
            }
        }
        
        impl Extend<Signal> for SigSet 
        {
            fn extend<T>( &mut self, iter: T )
             where T: IntoIterator<Item = Signal> {
                for signal in iter {
                    self.add( signal );
                }
            }
        }

        impl<'a> IntoIterator for &'a SigSet
        {
            type Item = Signal;
            type IntoIter = SigSetIter<'a>;
            fn into_iter( self ) -> Self::IntoIter
            {
                SigSetIter { sigset: self, inner: Signal::iterator() }
            }
        }

        impl FromIterator<Signal> for SigSet 
        {
            fn from_iter<T>( iter: T ) -> Self  where T: IntoIterator<Item = Signal>
            {
                let mut sigset = SigSet::empty();
                sigset.extend( iter );
                sigset
            }
        }

        #[derive( Clone, Debug )]
        pub struct SigSetIter<'a>
        {
            sigset:&'a SigSet,
            inner: SignalIterator,
        }

        impl Iterator for SigSetIter<'_>
        {
            type Item = Signal;
            fn next( &mut self ) -> Option<Signal>
            {
                loop
                {
                    match self.inner.next()
                    {
                        None => return None,
                        Some( signal ) if self.sigset.contains( signal ) => return Some( signal ),
                        Some( _signal ) => continue,
                    }
                }
            }
        }
        
        pub struct SignalInformation
        {
            pub si_signo: c_int,
            pub si_errno: c_int,
            pub si_code: c_int,
            #[doc(hidden )]
            #[deprecated(
                since = "0.2.54",
                note = "Please leave a comment on \
                    https://github.com/rust-lang/libc/pull/1316 if you're using \
                    this field"
            )]
            pub _pad: [c_int; 29],
            _align: [u64; 0],
        }

        #[derive( Clone, Copy, Debug, Hash )]
        pub enum SigHandler 
        {

            SigDfl,
            SigIgn,
            Handler( extern "C" fn ( c_int ) ),
            #[cfg( not( target_os = "redox" ) )]
            SigAction( extern "C" fn ( c_int, *mut SignalInformation, *mut c_void ) )
        }
        
        #[repr( C )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SignalAction
        {
            pub sa_sigaction: sighandler_t,
            pub sa_mask: SignalSet,
            #[cfg( target_arch = "sparc64" )]
            __reserved0: c_int,
            pub sa_flags: c_int,
            pub sa_restorer:Option<extern "C" fn ()>,
        }

        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct SigAction
        {
            sigaction:SignalAction
        }

        impl SigAction
        {

            pub fn new( handler:SigHandler, flags:SaFlags, mask:SigSet ) -> SigAction
            {
                unsafe fn install_sig( p: *mut SignalAction, handler: SigHandler ) 
                {
                    unsafe 
                    {
                        ( *p ).sa_sigaction = match handler 
                        {
                            SigHandler::SigDfl => libc::SIG_DFL,
                            SigHandler::SigIgn => libc::SIG_IGN,
                            SigHandler::Handler( f )   => f as *const extern "C" fn ( c_int ) as usize,
                            SigHandler::SigAction( f ) => f as *const extern "C" fn ( c_int, *mut SignalAction, *mut c_void ) as usize,
                        };
                    }
                }

                let mut s = mem::MaybeUninit::<SignalAction>::uninit();
                unsafe 
                {
                    let p = s.as_mut_ptr();
                    install_sig( p, handler );
                    ( *p ).sa_flags = match handler 
                    {
                        SigHandler::SigAction( _ ) => ( flags | SaFlags::SA_SIGINFO ).bits(),
                        _ => ( flags - SaFlags::SA_SIGINFO ).bits(),
                    };

                    ( *p ).sa_mask = mask.sigset;

                    SigAction { sigaction: s.assume_init() }
                }
            }
        }
        
        impl From<SigAction> for SignalAction
        {
            fn from( value: SigAction ) -> SignalAction {
                value.sigaction
            }
        }
        // Types of operating system signals
        libc_enum!
        {

            #[repr( i32 )] #[non_exhaustive]
            pub enum Signal {

                SIGHUP,
                SIGINT,
                SIGQUIT,
                SIGILL,
                SIGTRAP,
                SIGABRT,
                SIGBUS,
                SIGFPE,
                SIGKILL,
                SIGUSR1,
                SIGSEGV,
                SIGUSR2,
                SIGPIPE,
                SIGALRM,
                SIGTERM,
                SIGCHLD,
                SIGCONT,
                SIGSTOP,
                SIGTSTP,
                SIGTTIN,
                SIGTTOU,
                SIGURG,
                SIGXCPU,
                SIGXFSZ,
                SIGVTALRM,
                SIGPROF,
                SIGWINCH,
                #[cfg( not( target_os = "haiku" ) )]
                SIGIO,
                SIGSYS,
            }
            
            impl TryFrom<i32>
        }

        cfg_if!
        {
            if #[cfg( target_pointer_width = "32" )] {
                const ULONG_SIZE: usize = 32;
            } else if #[cfg( target_pointer_width = "64" )] {
                const ULONG_SIZE: usize = 64;
            } else {
                // Unknown target_pointer_width
            }
        }

        #[repr( C )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct FDSet
        {
            pub fds_bits: [c_ulong; FD_SETSIZE as usize / ULONG_SIZE],
        }

        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct FdSet<'fd> 
        {
            set:FDSet,
            _fd: ::marker::PhantomData<BorrowedFd<'fd>>,
        }

        impl <'fd> FdSet<'fd>
        {        

            pub fn new() -> FdSet<'fd>
            {
                let mut fdset = mem::MaybeUninit::uninit();
                unsafe
                {
                    FD_ZERO( fdset.as_mut_ptr() );
                    Self
                    {
                        set: fdset.assume_init(),
                        _fd: ::marker::PhantomData,
                    }
                }
            }

            pub fn insert( &mut self, fd:RawFd )
            {
                assert_fd_valid( fd  );
                unsafe { FD_SET( fd.into(), &mut self.set ) };
            }

            pub fn contains( &self, fd: BorrowedFd<'fd> ) -> bool
            {
                assert_fd_valid( fd.as_raw_fd() );
                FD_ISSET( fd.as_raw_fd(), &self.set )
            }

            pub fn highest( &self ) -> Option<BorrowedFd<'_>> { self.fds( None ).next_back() }

            #[inline] pub fn fds( &self, highest:Option<RawFd> ) -> Fds<'_, '_> {
                Fds {
                    set: self,
                    range: 0..highest.map( |h| h as usize + 1 ).unwrap_or( FD_SETSIZE ),
                }
            }
        }

        #[derive( Debug )]
        pub struct Fds<'a, 'fd> 
        {
            set:&'a FdSet<'fd>,
            range: Range<usize>,
        }
        
        impl<'fd> Iterator for Fds<'_, 'fd>
        {
            type Item = BorrowedFd<'fd>;
            fn next( &mut self ) -> Option<Self::Item> 
            {
                for i in &mut self.range {
                    let borrowed_i = unsafe { BorrowedFd::borrow_raw( i as RawFd ) };
                    if self.set.contains( borrowed_i ) {
                        return Some( borrowed_i );
                    }
                }
                None
            }

            #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) 
            {
                let ( _, upper ) = self.range.size_hint();
                ( 0, upper )
            }
        }

        impl<'fd> DoubleEndedIterator for Fds<'_, 'fd>
        {
            #[inline] fn next_back( &mut self ) -> Option<BorrowedFd<'fd>>
            {
                while let Some( i ) = self.range.next_back() {
                    let borrowed_i = unsafe { BorrowedFd::borrow_raw( i as RawFd ) };
                    if self.set.contains( borrowed_i ) {
                        return Some( borrowed_i );
                    }
                }
                None
            }
        }

        impl FusedIterator for Fds<'_, '_> {}

        pub struct timespec
        {
            pub tv_sec: time_t,
            #[cfg( all(gnu_time_bits64, target_endian = "big" ) )]
            __pad: i32,
            #[cfg( not( all( target_arch = "x86_64", target_pointer_width = "32" ) ) )]
            pub tv_nsec: c_long,
            #[cfg( all( target_arch = "x86_64", target_pointer_width = "32" ) )]
            pub tv_nsec: i64,
            #[cfg( all(gnu_time_bits64, target_endian = "little" ) )]
            __pad: i32,
        }

        #[repr( C )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct TimeValue
        {
            pub tv_sec: time_t,
            #[cfg( not( gnu_time_bits64 ) )]
            pub tv_usec: suseconds_t,
            #[cfg( gnu_time_bits64 )]
            pub tv_usec: __suseconds64_t,
        }

        pub trait TimeValLike:Sized
        {
            #[inline] fn zero() -> Self { Self::seconds( 0 ) }

            #[inline] fn hours( hours: i64 ) -> Self
            {
                let secs = hours
                .checked_mul( SECS_PER_HOUR )
                .expect( "TimeValLike::hours ouf of bounds" );
                Self::seconds( secs )
            }

            #[inline] fn minutes( minutes: i64 ) -> Self
            {
                let secs = minutes
                    .checked_mul( SECS_PER_MINUTE )
                    .expect( "TimeValLike::minutes out of bounds" );
                Self::seconds( secs )
            }

            fn seconds( seconds: i64 ) -> Self;
            fn milliseconds( milliseconds: i64 ) -> Self;
            fn microseconds( microseconds: i64 ) -> Self;
            fn nanoseconds( nanoseconds: i64 ) -> Self;

            #[inline] fn num_hours( &self ) -> i64 { self.num_seconds() / 3600 }

            #[inline] fn num_minutes( &self ) -> i64 { self.num_seconds() / 60 }

            fn num_seconds( &self ) -> i64;
            fn num_milliseconds( &self ) -> i64;
            fn num_microseconds( &self ) -> i64;
            fn num_nanoseconds( &self ) -> i64;
        }
        
        #[repr( transparent )] #[derive( Clone, Copy, Debug, Eq, Hash, PartialEq )]
        pub struct TimeVal( TimeValue  );
        impl TimeVal
        {

            #[inline] fn microseconds( microseconds: i64 ) -> TimeVal {
                let ( secs, micros ) = div_mod_floor_64( microseconds, MICROS_PER_SEC );
                assert!( 
                    ( TV_MIN_SECONDS..=TV_MAX_SECONDS ).contains( &secs ),
                    "TimeVal out of bounds"
                 );
                TimeVal( TimeValue {
                    tv_sec: secs as time_t,
                    tv_usec: micros as suseconds_t,
                } )
            }

            #[inline] pub fn milliseconds( milliseconds: i64 ) -> TimeVal {
                let microseconds = milliseconds
                    .checked_mul( 1_000 )
                    .expect( "TimeVal::milliseconds out of bounds" );

                TimeVal::microseconds( microseconds )
            }
        }

        pub fn selects<'a,'fd,N,R,W,E,T>( nfds:N, readfds:R, writefds:W, errorfds:E, timeout:T ) -> Result<c_int>
        where
        'fd: 'a,
        N: Into<Option<c_int>>,
        R: Into<Option<&'a mut FdSet<'fd>>>,
        W: Into<Option<&'a mut FdSet<'fd>>>,
        E: Into<Option<&'a mut FdSet<'fd>>>,
        T: Into<Option<&'a mut TimeVal>>
        {
            unsafe
            {
                
                let mut readfds = readfds.into();
                let mut writefds = writefds.into();
                let mut errorfds = errorfds.into();
                let timeout = timeout.into();

                let nfds = nfds.into().unwrap_or_else( || {
                    readfds
                        .iter_mut()
                        .chain( writefds.iter_mut() )
                        .chain( errorfds.iter_mut() )
                        .map( |set| {
                            set.highest()
                                .map( |borrowed_fd| borrowed_fd.as_raw_fd() )
                                .unwrap_or( -1 )
                        } )
                        .max()
                        .unwrap_or( -1 )
                        + 1
                } );

                let readfds = readfds
                    .map( |set| set as *mut _ as *mut FDSet )
                    .unwrap_or( null_mut() );
                let writefds = writefds
                    .map( |set| set as *mut _ as *mut FDSet )
                    .unwrap_or( null_mut() );
                let errorfds = errorfds
                    .map( |set| set as *mut _ as *mut FDSet )
                    .unwrap_or( null_mut() );
                let timeout = timeout
                    .map( |tv| tv as *mut _ as *mut TimeValue )
                    .unwrap_or( null_mut() );

                let res = select( nfds, readfds, writefds, errorfds, timeout  );

                Errno::result( res )
            }
            
        }
        
        libc_bitflags!
        {

            pub struct InputFlags: tcflag_t {
                IGNBRK;
                BRKINT;
                IGNPAR;
                PARMRK;
                INPCK;
                ISTRIP;
                INLCR;
                IGNCR;
                ICRNL;
                IXON;
                IXOFF;
                #[cfg( not( target_os = "redox" ) )]
                IXANY;
                #[cfg( not( any( target_os = "redox", target_os = "haiku" ) ) )]
                IMAXBEL;
                #[cfg( any( linux_android, apple_targets ) )]
                IUTF8;
            }
        }

        libc_bitflags! 
        {

            pub struct OutputFlags: tcflag_t {
                OPOST;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        target_os = "openbsd" ) )]
                OLCUC;
                ONLCR;
                OCRNL as tcflag_t;
                ONOCR as tcflag_t;
                ONLRET as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                OFDEL as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                NL0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                NL1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CR0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CR1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CR2 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CR3 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "freebsd",
                        target_os = "haiku",
                        apple_targets ) )]
                TAB0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                TAB1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                TAB2 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "freebsd",
                        target_os = "haiku",
                        apple_targets ) )]
                TAB3 as tcflag_t;
                #[cfg( linux_android )]
                XTABS;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                BS0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                BS1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                VT0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                VT1 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                FF0 as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                FF1 as tcflag_t;
                #[cfg( bsd )]
                OXTABS;
                #[cfg( bsd )]
                ONOEOT as tcflag_t;

                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                NLDLY as tcflag_t; // FIXME: Datatype needs to be corrected in libc for mac
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                CRDLY as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "freebsd",
                        target_os = "haiku",
                        apple_targets ) )]
                TABDLY as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                BSDLY as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                VTDLY as tcflag_t;
                #[cfg( any( linux_android,
                        target_os = "haiku",
                        apple_targets ) )]
                FFDLY as tcflag_t;
            }
        }

        libc_bitflags! 
        {

            pub struct ControlFlags: tcflag_t {
                #[cfg( bsd )]
                CIGNORE;
                CS5;
                CS6;
                CS7;
                CS8;
                CSTOPB;
                CREAD;
                PARENB;
                PARODD;
                HUPCL;
                CLOCAL;
                #[cfg( not( any( target_os = "redox", target_os = "aix" ) ) )]
                CRTSCTS;
                #[cfg( linux_android )]
                CBAUD;
                #[cfg( any( target_os = "android", all( target_os = "linux", not( target_arch = "mips" ) ) ) )]
                CMSPAR;
                #[cfg( any( target_os = "android",
                        all( target_os = "linux",
                            not( any( target_arch = "powerpc", target_arch = "powerpc64" ) ) ) ) )]
                CIBAUD;
                #[cfg( linux_android )]
                CBAUDEX;
                #[cfg( bsd )]
                MDMBUF;
                #[cfg( netbsdlike )]
                CHWFLOW;
                #[cfg( any( freebsdlike, netbsdlike ) )]
                CCTS_OFLOW;
                #[cfg( any( freebsdlike, netbsdlike ) )]
                CRTS_IFLOW;
                #[cfg( freebsdlike )]
                CDTR_IFLOW;
                #[cfg( freebsdlike )]
                CDSR_OFLOW;
                #[cfg( freebsdlike )]
                CCAR_OFLOW;
                CSIZE;
            }
        }

        libc_bitflags! 
        {

            pub struct LocalFlags: tcflag_t {
                #[cfg( not( target_os = "redox" ) )]
                ECHOKE;
                ECHOE;
                ECHOK;
                ECHO;
                ECHONL;
                #[cfg( not( any( target_os = "redox", target_os = "cygwin" ) ) )]
                ECHOPRT;
                #[cfg( not( target_os = "redox" ) )]
                ECHOCTL;
                ISIG;
                ICANON;
                #[cfg( bsd )]
                ALTWERASE;
                IEXTEN;
                #[cfg( not( any( target_os = "redox", target_os = "haiku", target_os = "aix", target_os = "cygwin" ) ) )]
                EXTPROC;
                TOSTOP;
                #[cfg( not( target_os = "redox" ) )]
                FLUSHO;
                #[cfg( bsd )]
                NOKERNINFO;
                #[cfg( not( any( target_os = "redox", target_os = "cygwin" ) ) )]
                PENDIN;
                NOFLSH;
            }
        }
        /**
        The termios functions describe a general terminal interface that
        is provided to control asynchronous communications ports. */
        #[repr( C )] #[derive( Clone, Debug, Eq, PartialEq )]
        pub struct AsynchronousTerminalInterface
        {
            pub c_iflag: tcflag_t,
            pub c_oflag: tcflag_t,
            pub c_cflag: tcflag_t,
            pub c_lflag: tcflag_t,
            pub c_line: cc_t,
            pub c_cc: [cc_t; NCCS],
            #[cfg( not( any( 
                target_arch = "sparc",
                target_arch = "sparc64",
                target_arch = "mips",
                target_arch = "mips32r6",
                target_arch = "mips64",
                target_arch = "mips64r6"
            ) ) )]
            pub c_ispeed:speed_t,
            #[cfg( not( any( 
                target_arch = "sparc",
                target_arch = "sparc64",
                target_arch = "mips",
                target_arch = "mips32r6",
                target_arch = "mips64",
                target_arch = "mips64r6"
            ) ) )]
            pub c_ospeed:speed_t,
        }

        #[derive( Clone, Debug, Eq, PartialEq )]
        pub struct Termios 
        {
            inner: RefCell<AsynchronousTerminalInterface>,
            pub input_flags: InputFlags,
            pub output_flags: OutputFlags,
            pub control_flags: ControlFlags,
            pub local_flags: LocalFlags,
            pub control_chars: [cc_t; NCCS],
        }

        impl Termios
        {
            pub fn create
            ( 
                ati:AsynchronousTerminalInterface,
                input_flags:InputFlags,
                output_flags:OutputFlags,
                control_flags:ControlFlags,
                local_flags:LocalFlags,
                control_chars: [cc_t; NCCS]
            ) -> Self
            {
                Self
                {
                    inner: RefCell::new( ati ),
                    input_flags,
                    output_flags,
                    control_flags,
                    local_flags,
                    control_chars,
                }
            }

            pub fn get_libc_termios( &self ) -> Ref<'_, AsynchronousTerminalInterface> 
            {
                {
                    let mut termios = self.inner.borrow_mut();
                    termios.c_iflag = self.input_flags.bits();
                    termios.c_oflag = self.output_flags.bits();
                    termios.c_cflag = self.control_flags.bits();
                    termios.c_lflag = self.local_flags.bits();
                    termios.c_cc = self.control_chars;
                    #[cfg( any( linux_android, target_os = "haiku" ) )]
                    {
                        termios.c_line = self.line_discipline;
                    }
                }
                self.inner.borrow()
            }

            pub unsafe fn get_libc_termios_mut( &mut self ) -> *mut AsynchronousTerminalInterface
            {
                {
                    let mut termios = self.inner.borrow_mut();
                    termios.c_iflag = self.input_flags.bits();
                    termios.c_oflag = self.output_flags.bits();
                    termios.c_cflag = self.control_flags.bits();
                    termios.c_lflag = self.local_flags.bits();
                    termios.c_cc = self.control_chars;
                    #[cfg( any( linux_android, target_os = "haiku" ) )]
                    {
                        termios.c_line = self.line_discipline;
                    }
                }
                self.inner.as_ptr()
            }
        }

        impl From<AsynchronousTerminalInterface> for Termios
        {
            fn from( ati:AsynchronousTerminalInterface ) -> Self
            {
                let a = ati.clone();
                let input_flags   = InputFlags::from_bits_truncate( a.c_iflag  );
                let output_flags  = OutputFlags::from_bits_truncate( a.c_oflag  );
                let control_flags = ControlFlags::from_bits_truncate( a.c_cflag  );
                let local_flags   = LocalFlags::from_bits_truncate( a.c_lflag  );
                let control_chars = a.c_cc.clone();
                Termios
                {
                    inner: RefCell::new( ati ),
                    input_flags,
                    output_flags,
                    control_flags,
                    local_flags,
                    control_chars,
                    /*
                    input_flags: InputFlags::from_bits_truncate( termios.c_iflag ),
                    output_flags: OutputFlags::from_bits_truncate( termios.c_oflag ),
                    control_flags: ControlFlags::from_bits_truncate( termios.c_cflag ),
                    local_flags: LocalFlags::from_bits_truncate( termios.c_lflag ),
                    control_chars: termios.c_cc,
                    #[cfg( any( linux_android, target_os = "haiku" ) )]
                    line_discipline: termios.c_line, */
                }
            }
        }

        impl From<Termios> for AsynchronousTerminalInterface
        {
            fn from( termios: Termios ) -> Self { termios.inner.into_inner() }
        }

        #[repr( usize )] #[non_exhaustive]
        #[derive( Clone, Copy, Debug, Eq, PartialEq )]
        pub enum SpecialCharacterIndices 
        {
            VDISCARD,
            VEOF,
            VEOL,
            VEOL2,
            VERASE,
            VINTR,
            VKILL,
            VLNEXT,
            VQUIT,
            VREPRINT,
            VSTART,
            VSTATUS,
            VSTOP,
            VSUSP,
            VSWTC,
            VWERASE,
        }
        // Specify when a port configuration change should occur.
        libc_enum! 
        {

            #[repr( i32 )]
            #[non_exhaustive]
            pub enum SetArg {

                TCSANOW,
                TCSADRAIN,
                TCSAFLUSH,
            }
        }

        pub const MICROS_PER_SEC: i64 = 1_000_000;
        
        #[cfg( target_pointer_width = "64" )]
        pub const TS_MAX_SECONDS: i64 = ( i64::MAX / NANOS_PER_SEC ) - 1;

        #[cfg( target_pointer_width = "32" )]
        pub const TS_MAX_SECONDS: i64 = isize::MAX as i64;

        pub const TS_MIN_SECONDS: i64 = -TS_MAX_SECONDS;
        
        #[cfg( target_pointer_width = "64" )]
        pub const TV_MAX_SECONDS: i64 = ( i64::MAX / MICROS_PER_SEC ) - 1;

        #[cfg( target_pointer_width = "32" )]
        pub const TV_MAX_SECONDS: i64 = isize::MAX as i64;

        pub const TV_MIN_SECONDS: i64 = -TV_MAX_SECONDS;
        
        #[cfg( all( target_arch = "x86_64", target_pointer_width = "32" ) )]
        type timespec_tv_nsec_t = i64;
        #[cfg( not( all( target_arch = "x86_64", target_pointer_width = "32" ) ) )]
        type timespec_tv_nsec_t = c_long;

        #[repr( C )] #[derive( Clone, Copy, Debug )]
        pub struct TimeSpecification
        {
            pub tv_sec: time_t,
            #[cfg( all( gnu_time_bits64, target_endian = "big" ) )]
            __pad: i32,
            #[cfg( not( all( target_arch = "x86_64", target_pointer_width = "32" ) ) )]
            pub tv_nsec: c_long,
            #[cfg( all( target_arch = "x86_64", target_pointer_width = "32" ) )]
            pub tv_nsec: i64,
            #[cfg( all( gnu_time_bits64, target_endian = "little" ) )]
            __pad: i32,
        }

        #[repr( C )] #[derive( Clone, Copy, Debug )]
        pub struct TimeSpec( TimeSpecification  );
        
        impl TimeSpec
        {
             

            pub fn nanoseconds( nanoseconds: i64 ) -> TimeSpec
            {
                let ( secs, nanos ) = div_mod_floor_64( nanoseconds, NANOS_PER_SEC );
                assert!
                ( 
                    ( TS_MIN_SECONDS..=TS_MAX_SECONDS ).contains( &secs ),
                    "TimeSpec out of bounds"
                 );
                let mut ts = zero_init_time_specification();
                ts.tv_sec = secs as time_t;
                ts.tv_nsec = nanos as timespec_tv_nsec_t;
                TimeSpec( ts )
            }
        }

        impl Eq for TimeSpec {}

        impl PartialEq for TimeSpec
        {
            fn eq( &self, other:&Self ) -> bool
            {
                self.0.tv_sec  == other.0.tv_sec &&
                self.0.tv_nsec == other.0.tv_nsec
            }
        }
        
        impl Hash for TimeSpec
        {
            fn hash<H: Hasher>( &self, state:&mut H )
            {
                self.0.tv_sec.hash( state )
            }
        }

        #[repr( i32 )] #[non_exhaustive] #[derive( Clone, Copy, Debug, Eq, PartialEq )]
        pub enum Errno
        {
            EUN = -1,
            EPERM = 1,
            ENOENT = 2,
            ESRCH = 3,
            EINTR = 4,
            EIO = 5,
            ENXIO = 6,
            E2BIG = 7,
            ENOEXEC = 8,
            EBADF = 9,
            ECHILD = 10,
            EAGAIN = 11,
            ENOMEM = 12,
            EACCES = 13,
            EFAULT = 14,
            ENOTBLK = 15,
            EBUSY = 16,
            EEXIST = 17,
            EXDEV = 18,
            ENODEV = 19,
            ENOTDIR = 20,
            EISDIR = 21,
            EINVAL = 22,
            ENFILE = 23,
            EMFILE = 24,
            ENOTTY = 25,
            ETXTBSY = 26,
            EFBIG = 27,
            ENOSPC = 28,
            ESPIPE = 29,
            EROFS = 30,
            EMLINK = 31,
            EPIPE = 32,
            EDOM = 33,
            ERANGE = 34,
            EDEADLK = 35,
            ENAMETOOLONG = 36,
            ENOLCK = 37,
            ENOSYS = 38,
            ENOTEMPTY = 39,
            ELOOP = 40,
            ENOMSG = 42,
            EIDRM = 43,
            ECHRNG = 44,
            EL2NSYNC = 45,
            EL3HLT = 46,
            EL3RST = 47,
            ELNRNG = 48,
            EUNATCH = 49,
            ENOCSI = 50,
            EL2HLT = 51,
            EBADE = 52,
            EBADR = 53,
            EXFULL = 54,
            ENOANO = 55,
            EBADRQC = 56,
            EBADSLT = 57,
            EBFONT = 59,
            ENOSTR = 60,
            ENODATA = 61,
            ETIME = 62,
            ENOSR = 63,
            ENONET = 64,
            ENOPKG = 65,
            EREMOTE = 66,
            ENOLINK = 67,
            EADV = 68,
            ESRMNT = 69,
            ECOMM = 70,
            EPROTO = 71,
            EMULTIHOP = 72,
            EDOTDOT = 73,
            EBADMSG = 74,
            EOVERFLOW = 75,
            ENOTUNIQ = 76,
            EBADFD = 77,
            EREMCHG = 78,
            ELIBACC = 79,
            ELIBBAD = 80,
            ELIBSCN = 81,
            ELIBMAX = 82,
            ELIBEXEC = 83,
            EILSEQ = 84,
            ERESTART = 85,
            ESTRPIPE = 86,
            EUSERS = 87,
            ENOTSOCK = 88,
            EDESTADDRREQ = 89,
            EMSGSIZE = 90,
            EPROTOTYPE = 91,
            ENOPROTOOPT = 92,
            EPROTONOSUPPORT = 93,
            ESOCKTNOSUPPORT = 94,
            EOPNOTSUPP = 95,
            EPFNOSUPPORT = 96,
            EAFNOSUPPORT = 97,
            EADDRINUSE = 98,
            EADDRNOTAVAIL = 99,
            ENETDOWN = 100,
            ENETUNREACH = 101,
            ENETRESET = 102,
            ECONNABORTED = 103,
            ECONNRESET = 104,
            ENOBUFS = 105,
            EISCONN = 106,
            ENOTCONN = 107,
            ESHUTDOWN = 108,
            ETOOMANYREFS = 109,
            ETIMEDOUT = 110,
            ECONNREFUSED = 111,
            EHOSTDOWN = 112,
            EHOSTUNREACH = 113,
            EALREADY = 114,
            EINPROGRESS = 115,
            ESTALE = 116,
            EUCLEAN = 117,
            ENOTNAM = 118,
            ENAVAIL = 119,
            EISNAM = 120,
            EREMOTEIO = 121,
            EDQUOT = 122,
            ENOMEDIUM = 123,
            EMEDIUMTYPE = 124,
            ECANCELED = 125,
            ENOKEY = 126,
            EKEYEXPIRED = 127,
            EKEYREVOKED = 128,
            EKEYREJECTED = 129,
            EOWNERDEAD = 130,
            ENOTRECOVERABLE = 131,
            ERFKILL = 132,
            EHWPOISON = 133,
        }

        impl Errno
        {
            pub const fn from_raw( err: i32 ) -> Errno { from_i32( err ) }

            pub fn last_raw() -> i32 { unsafe { *errno_location() } }

            pub fn last() -> Self { Self::from_raw( Self::last_raw() ) }

            #[inline] pub fn result<S: ErrnoSentinel + PartialEq<S>>( value: S ) -> Result<S>
            {
                if value == S::sentinel() { Err( Self::last() ) }
                else { Ok( value ) }
            }
        }

        pub trait ErrnoSentinel:Sized
        {
            fn sentinel() -> Self;
        }

        impl ErrnoSentinel for isize 
        {
            fn sentinel() -> Self {
                -1
            }
        }

        impl ErrnoSentinel for i32 {
            fn sentinel() -> Self {
                -1
            }
        }

        impl ErrnoSentinel for i64 {
            fn sentinel() -> Self {
                -1
            }
        }

        impl ErrnoSentinel for *mut c_void {
            fn sentinel() -> Self {
                -1isize as *mut c_void
            }
        }

        impl ErrnoSentinel for sighandler_t {
            fn sentinel() -> Self {
                libc::SIG_ERR
            }
        }

        #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash )]
        pub struct Pid( pid_t );

        #[derive( Clone, Copy, Debug)]
        pub enum ForkResult
        {

            Parent
            {

                child: Pid
            },
            Child,
        }

        

        fn assert_fd_valid( fd: RawFd )
        {
            assert!( 
                usize::try_from( fd ).map_or( false, |fd| fd < FD_SETSIZE ),
                "fd must be in the range 0..FD_SETSIZE",
             );
        }

        pub fn tcgetattraw( d:RawFd ) -> Result<Termios> 
        {
            unsafe
            {
                let mut t = ::mem::MaybeUninit::uninit();
                let r = libc::tcgetattr( d, t.as_mut_ptr()  );
                Errno::result( r )?;
                let a:AsynchronousTerminalInterface = ::mem::transmute( t.assume_init().clone()  );
                let b:AsynchronousTerminalInterface = a.clone();
                Ok
                ( 
                    Termios::create
                    ( 
                        a,
                        ::mem::transmute( b.c_iflag ),
                        ::mem::transmute( b.c_oflag ),
                        ::mem::transmute( b.c_cflag ),
                        ::mem::transmute( b.c_lflag ),
                        ::mem::transmute( b.c_cc ),
                    )
                )
                /*
                let mut t = ::mem::MaybeUninit::uninit();
                let r = libc::tcgetattr( d, t.as_mut_ptr()  );
                Errno::result( r )?;
                Ok( ::mem::transmute::<libc::termios, Termios>( t.assume_init() ) )*/
            }
        }

        pub fn tcsetattraw
        ( 
            fd: RawFd,
            actions: SetArg,
            termios:&Termios,
        ) -> Result<()> 
        {
            let inner_termios = termios.get_libc_termios();
            Errno::result( unsafe 
            {
                libc::tcsetattr
                ( 
                    fd,
                    actions as c_int,
                    ::mem::transmute( &*inner_termios ) //&*inner_termios,
                )
            } )
            .map( drop )
        }

        pub const fn from_i32( e: i32 ) -> Errno 
        {
            use self::Errno::*;

            match e 
            {
                libc::EPERM => EPERM,
                libc::ENOENT => ENOENT,
                libc::ESRCH => ESRCH,
                libc::EINTR => EINTR,
                libc::EIO => EIO,
                libc::ENXIO => ENXIO,
                libc::E2BIG => E2BIG,
                libc::ENOEXEC => ENOEXEC,
                libc::EBADF => EBADF,
                libc::ECHILD => ECHILD,
                libc::EAGAIN => EAGAIN,
                libc::ENOMEM => ENOMEM,
                libc::EACCES => EACCES,
                libc::EFAULT => EFAULT,
                libc::ENOTBLK => ENOTBLK,
                libc::EBUSY => EBUSY,
                libc::EEXIST => EEXIST,
                libc::EXDEV => EXDEV,
                libc::ENODEV => ENODEV,
                libc::ENOTDIR => ENOTDIR,
                libc::EISDIR => EISDIR,
                libc::EINVAL => EINVAL,
                libc::ENFILE => ENFILE,
                libc::EMFILE => EMFILE,
                libc::ENOTTY => ENOTTY,
                libc::ETXTBSY => ETXTBSY,
                libc::EFBIG => EFBIG,
                libc::ENOSPC => ENOSPC,
                libc::ESPIPE => ESPIPE,
                libc::EROFS => EROFS,
                libc::EMLINK => EMLINK,
                libc::EPIPE => EPIPE,
                libc::EDOM => EDOM,
                libc::ERANGE => ERANGE,
                libc::ENOMSG => ENOMSG,
                libc::EIDRM => EIDRM,
                libc::ECHRNG => ECHRNG,
                libc::EL2NSYNC => EL2NSYNC,
                libc::EL3HLT => EL3HLT,
                libc::EL3RST => EL3RST,
                libc::ELNRNG => ELNRNG,
                libc::EUNATCH => EUNATCH,
                libc::ENOCSI => ENOCSI,
                libc::EL2HLT => EL2HLT,
                libc::EDEADLK => EDEADLK,
                libc::ENOLCK => ENOLCK,
                libc::EBADE => EBADE,
                libc::EBADR => EBADR,
                libc::EXFULL => EXFULL,
                libc::ENOANO => ENOANO,
                libc::EBADRQC => EBADRQC,
                libc::EBADSLT => EBADSLT,
                //libc::EDEADLOCK => EDEADLOCK,
                libc::EBFONT => EBFONT,
                libc::ENOSTR => ENOSTR,
                libc::ENODATA => ENODATA,
                libc::ETIME => ETIME,
                libc::ENOSR => ENOSR,
                libc::ENONET => ENONET,
                libc::ENOPKG => ENOPKG,
                libc::EREMOTE => EREMOTE,
                libc::ENOLINK => ENOLINK,
                libc::EADV => EADV,
                libc::ESRMNT => ESRMNT,
                libc::ECOMM => ECOMM,
                libc::EPROTO => EPROTO,
                libc::EMULTIHOP => EMULTIHOP,
                libc::EDOTDOT => EDOTDOT,
                libc::EBADMSG => EBADMSG,
                libc::ENOTUNIQ => ENOTUNIQ,
                libc::EBADFD => EBADFD,
                libc::EREMCHG => EREMCHG,
                libc::ELIBACC => ELIBACC,
                libc::ELIBBAD => ELIBBAD,
                libc::ELIBSCN => ELIBSCN,
                libc::ELIBMAX => ELIBMAX,
                libc::ELIBEXEC => ELIBEXEC,
                libc::ENOSYS => ENOSYS,
                libc::ENOTEMPTY => ENOTEMPTY,
                libc::ENAMETOOLONG => ENAMETOOLONG,
                libc::ELOOP => ELOOP,
                libc::EOPNOTSUPP => EOPNOTSUPP,
                libc::EPFNOSUPPORT => EPFNOSUPPORT,
                libc::ECONNRESET => ECONNRESET,
                libc::ENOBUFS => ENOBUFS,
                libc::EAFNOSUPPORT => EAFNOSUPPORT,
                libc::EPROTOTYPE => EPROTOTYPE,
                libc::ENOTSOCK => ENOTSOCK,
                libc::ENOPROTOOPT => ENOPROTOOPT,
                libc::ESHUTDOWN => ESHUTDOWN,
                libc::ECONNREFUSED => ECONNREFUSED,
                libc::EADDRINUSE => EADDRINUSE,
                libc::ECONNABORTED => ECONNABORTED,
                libc::ENETUNREACH => ENETUNREACH,
                libc::ENETDOWN => ENETDOWN,
                libc::ETIMEDOUT => ETIMEDOUT,
                libc::EHOSTDOWN => EHOSTDOWN,
                libc::EHOSTUNREACH => EHOSTUNREACH,
                libc::EINPROGRESS => EINPROGRESS,
                libc::EALREADY => EALREADY,
                libc::EDESTADDRREQ => EDESTADDRREQ,
                libc::EMSGSIZE => EMSGSIZE,
                libc::EPROTONOSUPPORT => EPROTONOSUPPORT,
                libc::ESOCKTNOSUPPORT => ESOCKTNOSUPPORT,
                libc::EADDRNOTAVAIL => EADDRNOTAVAIL,
                libc::ENETRESET => ENETRESET,
                libc::EISCONN => EISCONN,
                libc::ENOTCONN => ENOTCONN,
                libc::ETOOMANYREFS => ETOOMANYREFS,
                libc::EUSERS => EUSERS,
                libc::EDQUOT => EDQUOT,
                libc::ESTALE => ESTALE,
                libc::ENOMEDIUM => ENOMEDIUM,
                libc::EILSEQ => EILSEQ,
                libc::EOVERFLOW => EOVERFLOW,
                libc::ECANCELED => ECANCELED,
                libc::ENOTRECOVERABLE => ENOTRECOVERABLE,
                libc::EOWNERDEAD => EOWNERDEAD,
                libc::ESTRPIPE => ESTRPIPE,
                _ => EUN,
            }
        }

        unsafe fn errno_location() -> *mut c_int { unsafe { libc::__errno_location() } }

        pub fn read( fd:RawFd, buf:&mut [u8] ) -> Result<usize> 
        {
            let res = unsafe {
                libc::read( 
                    fd,
                    buf.as_mut_ptr().cast(),
                    buf.len() as size_t,
                )
            };

            Errno::result( res ).map( |r| r as usize )
        }

        pub fn write( fd:RawFd, buf:&[u8] ) -> Result<usize> 
        {
            let res = unsafe {
                libc::write( 
                    fd,
                    buf.as_ptr().cast(),
                    buf.len() as size_t,
                )
            };

            Errno::result( res ).map( |r| r as usize )
        }

        #[inline] pub fn milliseconds( milliseconds: i64 ) -> TimeSpec
        {
            let nanoseconds = milliseconds
            .checked_mul( 1_000_000 )
            .expect( "TimeSpec::milliseconds out of bounds" );

            TimeSpec::nanoseconds( nanoseconds )
        }

        #[inline] pub fn div_rem_64( this: i64, other: i64 ) -> ( i64, i64 ) { ( this / other, this % other ) }
        
        #[inline] pub fn div_floor_64( this: i64, other: i64 ) -> i64
        {
            match div_rem_64( this, other )
            {
                ( d, r ) if ( r > 0 && other < 0 ) || ( r < 0 && other > 0 ) => d - 1,
                ( d, _ ) => d,
            }
        }
        
        #[inline] pub fn mod_floor_64( this: i64, other: i64 ) -> i64
        {
            match this % other 
            {
                r if ( r > 0 && other < 0 ) || ( r < 0 && other > 0 ) => r + other,
                r => r,
            }
        }

        #[inline] pub fn div_mod_floor_64( this: i64, other: i64 ) -> ( i64, i64 )
        {
            ( div_floor_64( this, other ), mod_floor_64( this, other ) )
        }

        #[inline] pub fn nanoseconds( nanoseconds: i64 ) -> TimeVal 
        {
            let microseconds = nanoseconds / 1000;
            let ( secs, micros ) = div_mod_floor_64( microseconds, MICROS_PER_SEC );
            assert!( 
                ( TV_MIN_SECONDS..=TV_MAX_SECONDS ).contains( &secs ),
                "TimeVal out of bounds"
             );
            TimeVal( TimeValue {
                tv_sec: secs as time_t,
                tv_usec: micros as suseconds_t,
            } )
        }
        
        pub const fn zero_init_time_specification() -> TimeSpecification
        {
            unsafe { ::mem::transmute( [0u8; ::mem::size_of::<TimeSpecification>()] ) }
        }
        
        pub fn FD_ISSET( fd:c_int, set:*const FDSet ) -> bool
        {
            unsafe
            {
                let fd = fd as usize;
                let size = size_of_val( &( *set ).fds_bits[0] ) * 8;
                return ( ( *set ).fds_bits[fd / size] & ( 1 << ( fd % size ) ) ) != 0;
            }
        }

        //pub unsafe fn sigaction( signal: Signal, sigaction:&SigAction ) -> Result<SigAction> 
        pub unsafe fn react( s: Signal, a:&SigAction ) -> Result<SigAction>
        {
            let mut oldact = mem::MaybeUninit::<SignalAction>::uninit();

            let res = unsafe { sigaction( s as c_int,
                                    &a.sigaction as *const SignalAction,
                                    oldact.as_mut_ptr() ) };

            Errno::result( res ).map( |_| SigAction { sigaction: unsafe { oldact.assume_init() } } )
        }

        pub fn FD_SET( fd:c_int, set:*mut FDSet ) -> ()
        {
            unsafe
            {
                let fd = fd as usize;
                let size = size_of_val( &( *set ).fds_bits[0] ) * 8;
                ( *set ).fds_bits[fd / size] |= 1 << ( fd % size );
                return;
            }
        }

        pub fn FD_ZERO( set:*mut FDSet ) -> ()
        {
            unsafe
            {
                for slot in &mut ( *set ).fds_bits
                {
                    *slot = 0;
                }
            }
        }
    }
    /*
    mortal v0.0.0 */
    pub mod common
    {
        /*!
        Platform-independent terminal interface */
        use ::
        {
            fs::{ File },
            io::{ BufWriter, Write },
            path::{ Path },
            *,
        };
        /*
        pub use crate::sequence::{FindResult, SequenceMap};
        */
        pub static mut BOOLEANS:String = String::new();
        pub const BOOLEAN:&[&str] = 
        &[
            "auto_left_margin","auto_right_margin","no_esc_ctlc","ceol_standout_glitch","eat_newline_glitch",
            "erase_overstrike","generic_type","hard_copy","has_meta_key","has_status_line","insert_null_glitch",
            "memory_above","memory_below","move_insert_mode","move_standout_mode","over_strike",
            "status_line_esc_ok","dest_tabs_magic_smso","tilde_glitch","transparent_underline","xon_xoff",
            "needs_xon_xoff","prtr_silent","hard_cursor","non_rev_rmcup","no_pad_char","non_dest_scroll_region",
            "can_change","back_color_erase","hue_lightness_saturation","col_addr_glitch","cr_cancels_micro_mode",
            "has_print_wheel","row_addr_glitch","semi_auto_right_margin","cpi_changes_res","lpi_changes_res",
            "backspaces_with_bs","crt_no_scrolling","no_correctly_working_cr","gnu_has_meta_key",
            "linefeed_is_newline","has_hardware_tabs","return_does_clr_eol"
        ];

        pub static mut NUMBERS:String = String::new();
        pub const NUMBER:&[&str] = 
        &[
            "columns","init_tabs","lines","lines_of_memory","magic_cookie_glitch","padding_baud_rate", 
            "virtual_terminal","width_status_line","num_labels","label_height","label_width","max_attributes",
            "maximum_windows","max_colors","max_pairs","no_color_video","buffer_capacity","dot_vert_spacing",
            "dot_horz_spacing","max_micro_address","max_micro_jump","micro_col_size","micro_line_size",
            "number_of_pins","output_res_char","output_res_line","output_res_horz_inch","output_res_vert_inch",
            "print_rate","wide_char_size","buttons","bit_image_entwining","bit_image_type",
            "magic_cookie_glitch_ul","carriage_return_delay","new_line_delay","backspace_delay",
            "horizontal_tab_delay","number_of_function_keys"
        ];
        
        pub static mut STRINGS:String = String::new();
        pub const STRING:&[&str] = 
        &[
            "back_tab","bell","carriage_return","change_scroll_region","clear_all_tabs","clear_screen",
            "clr_eol","clr_eos","column_address","command_character","cursor_address","cursor_down",
            "cursor_home","cursor_invisible","cursor_left","cursor_mem_address","cursor_normal","cursor_right",
            "cursor_to_ll","cursor_up","cursor_visible","delete_character","delete_line","dis_status_line",
            "down_half_line","enter_alt_charset_mode","enter_blink_mode","enter_bold_mode","enter_ca_mode",
            "enter_delete_mode","enter_dim_mode","enter_insert_mode","enter_secure_mode","enter_protected_mode",
            "enter_reverse_mode","enter_standout_mode","enter_underline_mode","erase_chars",
            "exit_alt_charset_mode","exit_attribute_mode","exit_ca_mode","exit_delete_mode","exit_insert_mode",
            "exit_standout_mode","exit_underline_mode","flash_screen","form_feed","from_status_line",
            "init_1string","init_2string","init_3string","init_file","insert_character","insert_line",
            "insert_padding","key_backspace","key_catab","key_clear","key_ctab","key_dc","key_dl","key_down",
            "key_eic","key_eol","key_eos","key_f0","key_f1","key_f10","key_f2","key_f3","key_f4","key_f5",
            "key_f6","key_f7","key_f8","key_f9","key_home","key_ic","key_il","key_left","key_ll",
            "key_npage","key_ppage","key_right","key_sf","key_sr","key_stab","key_up","keypad_local",
            "keypad_xmit","lab_f0","lab_f1","lab_f10","lab_f2","lab_f3","lab_f4","lab_f5","lab_f6","lab_f7",
            "lab_f8","lab_f9","meta_off","meta_on","newline","pad_char","parm_dch","parm_delete_line",
            "parm_down_cursor","parm_ich","parm_index","parm_insert_line","parm_left_cursor","parm_right_cursor",
            "parm_rindex","parm_up_cursor","pkey_key","pkey_local","pkey_xmit","print_screen","prtr_off",
            "prtr_on","repeat_char","reset_1string","reset_2string","reset_3string","reset_file",
            "restore_cursor","row_address","save_cursor","scroll_forward","scroll_reverse","set_attributes",
            "set_tab","set_window","tab","to_status_line","underline_char","up_half_line","init_prog","key_a1",
            "key_a3","key_b2","key_c1","key_c3","prtr_non","char_padding","acs_chars","plab_norm","key_btab",
            "enter_xon_mode","exit_xon_mode","enter_am_mode","exit_am_mode","xon_character","xoff_character",
            "ena_acs","label_on","label_off","key_beg","key_cancel","key_close","key_command","key_copy",
            "key_create","key_end","key_enter","key_exit","key_find","key_help","key_mark","key_message",
            "key_move","key_next","key_open","key_options","key_previous","key_print","key_redo",
            "key_reference","key_refresh","key_replace","key_restart","key_resume","key_save","key_suspend",
            "key_undo","key_sbeg","key_scancel","key_scommand","key_scopy","key_screate","key_sdc","key_sdl",
            "key_select","key_send","key_seol","key_sexit","key_sfind","key_shelp","key_shome","key_sic", 
            "key_sleft","key_smessage","key_smove","key_snext","key_soptions","key_sprevious","key_sprint",
            "key_sredo","key_sreplace","key_sright","key_srsume","key_ssave","key_ssuspend","key_sundo",
            "req_for_input","key_f11","key_f12","key_f13","key_f14","key_f15","key_f16","key_f17","key_f18",
            "key_f19","key_f20","key_f21","key_f22","key_f23","key_f24","key_f25","key_f26","key_f27",
            "key_f28","key_f29","key_f30","key_f31","key_f32","key_f33","key_f34","key_f35","key_f36",
            "key_f37","key_f38","key_f39","key_f40","key_f41","key_f42","key_f43","key_f44","key_f45",
            "key_f46","key_f47","key_f48","key_f49","key_f50","key_f51","key_f52","key_f53","key_f54",
            "key_f55","key_f56","key_f57","key_f58","key_f59","key_f60","key_f61","key_f62","key_f63",
            "clr_bol","clear_margins","set_left_margin","set_right_margin","label_format","set_clock",
            "display_clock","remove_clock","create_window","goto_window","hangup","dial_phone","quick_dial",
            "tone","pulse","flash_hook","fixed_pause","wait_tone","user0","user1","user2","user3","user4",
            "user5","user6","user7","user8","user9","orig_pair","orig_colors","initialize_color",
            "initialize_pair","set_color_pair","set_foreground","set_background","change_char_pitch",
            "change_line_pitch","change_res_horz","change_res_vert","define_char","enter_doublewide_mode",
            "enter_draft_quality","enter_italics_mode","enter_leftward_mode","enter_micro_mode",
            "enter_near_letter_quality","enter_normal_quality","enter_shadow_mode","enter_subscript_mode",
            "enter_superscript_mode","enter_upward_mode","exit_doublewide_mode","exit_italics_mode",
            "exit_leftward_mode","exit_micro_mode","exit_shadow_mode","exit_subscript_mode",
            "exit_superscript_mode","exit_upward_mode","micro_column_address","micro_down","micro_left",
            "micro_right","micro_row_address","micro_up","order_of_pins","parm_down_micro","parm_left_micro",
            "parm_right_micro","parm_up_micro","select_char_set","set_bottom_margin","set_bottom_margin_parm",
            "set_left_margin_parm","set_right_margin_parm","set_top_margin","set_top_margin_parm",
            "start_bit_image","start_char_set_def","stop_bit_image","stop_char_set_def","subscript_characters",
            "superscript_characters","these_cause_cr","zero_motion","char_set_names","key_mouse","mouse_info",
            "req_mouse_pos","get_mouse","set_a_foreground","set_a_background","pkey_plab","device_type",
            "code_set_init","set0_des_seq","set1_des_seq","set2_des_seq","set3_des_seq","set_lr_margin",
            "set_tb_margin","bit_image_repeat","bit_image_newline","bit_image_carriage_return","color_names",
            "define_bit_image_region","end_bit_image_region","set_color_band","set_page_length","display_pc_char",
            "enter_pc_charset_mode","exit_pc_charset_mode","enter_scancode_mode","exit_scancode_mode",
            "pc_term_options","scancode_escape","alt_scancode_esc","enter_horizontal_hl_mode",
            "enter_left_hl_mode","enter_low_hl_mode","enter_right_hl_mode","enter_top_hl_mode", 
            "enter_vertical_hl_mode","set_a_attributes","set_pglen_inch","termcap_init2","termcap_reset", 
            "linefeed_if_not_lf","backspace_if_not_bs","other_non_function_keys","arrow_key_map","acs_ulcorner",
            "acs_llcorner","acs_urcorner","acs_lrcorner","acs_ltee","acs_rtee","acs_btee","acs_ttee",
            "acs_hline","acs_vline","acs_plus","memory_lock","memory_unlock","box_chars_1"
        ];
        
        pub static mut INFORMATION:String = String::new();
        pub static mut ALIASES:String = String::new();
        pub const TERMINFO:&[( &str, &str )] = 
        &[
            // Boolean names.
            ( "auto_left_margin","bw" ), ( "auto_right_margin","am" ), ( "back_color_erase","bce" ),
            ( "can_change","ccc" ), ( "ceol_standout_glitch","xhp" ), ( "col_addr_glitch","xhpa" ), ( "cpi_changes_res","cpix" ),
            ( "cr_cancels_micro_mode","crxm" ),
            ( "dest_tabs_magic_smso","xt" ),
            ( "eat_newline_glitch","xenl" ),
            ( "erase_overstrike","eo" ),
            ( "generic_type","gn" ),
            ( "hard_copy","hc" ),
            ( "hard_cursor","chts" ),
            ( "has_meta_key","km" ),
            ( "has_print_wheel","daisy" ),
            ( "has_status_line","hs" ),
            ( "hue_lightness_saturation","hls" ),
            ( "insert_null_glitch","in" ),
            ( "lpi_changes_res","lpix" ),
            ( "memory_above","da" ),
            ( "memory_below","db" ),
            ( "move_insert_mode","mir" ),
            ( "move_standout_mode","msgr" ),
            ( "needs_xon_xoff","nxon" ),
            ( "no_esc_ctlc","xsb" ),
            ( "no_pad_char","npc" ),
            ( "non_dest_scroll_region","ndscr" ),
            ( "non_rev_rmcup","nrrmc" ),
            ( "over_strike","os" ),
            ( "prtr_silent","mc5i" ),
            ( "row_addr_glitch","xvpa" ),
            ( "semi_auto_right_margin","sam" ),
            ( "status_line_esc_ok","eslok" ),
            ( "tilde_glitch","hz" ),
            ( "transparent_underline","ul" ),
            ( "xon_xoff","xon" ),
            // Number names.
            ( "bit_image_entwining","bitwin" ),
            ( "bit_image_type","bitype" ),
            ( "buffer_capacity","bufsz" ),
            ( "buttons","btns" ),
            ( "columns","cols" ),
            ( "dot_horz_spacing","spinh" ),
            ( "dot_vert_spacing","spinv" ),
            ( "init_tabs","it" ),
            ( "label_height","lh" ),
            ( "label_width","lw" ),
            ( "lines","lines" ),
            ( "lines_of_memory","lm" ),
            ( "max_attributes","ma" ),
            ( "magic_cookie_glitch","xmc" ),
            ( "max_colors","colors" ),
            ( "max_micro_address","maddr" ),
            ( "max_micro_jump","mjump" ),
            ( "max_pairs","pairs" ),
            ( "maximum_windows","wnum" ),
            ( "micro_col_size","mcs" ),
            ( "micro_line_size","mls" ),
            ( "no_color_video","ncv" ),
            ( "num_labels","nlab" ),
            ( "number_of_pins","npins" ),
            ( "output_res_char","orc" ),
            ( "output_res_line","orl" ),
            ( "output_res_horz_inch","orhi" ),
            ( "output_res_vert_inch","orvi" ),
            ( "padding_baud_rate","pb" ),
            ( "print_rate","cps" ),
            ( "virtual_terminal","vt" ),
            ( "wide_char_size","widcs" ),
            ( "width_status_line","wsl" ),
            // String names.
            ( "acs_chars","acsc" ),
            ( "alt_scancode_esc","scesa" ),
            ( "back_tab","cbt" ),
            ( "bell","bel" ),
            ( "bit_image_carriage_return","bicr" ),
            ( "bit_image_newline","binel" ),
            ( "bit_image_repeat","birep" ),
            ( "carriage_return","cr" ),
            ( "change_char_pitch","cpi" ),
            ( "change_line_pitch","lpi" ),
            ( "change_res_horz","chr" ),
            ( "change_res_vert","cvr" ),
            ( "change_scroll_region","csr" ),
            ( "char_padding","rmp" ),
            ( "char_set_names","csnm" ),
            ( "clear_all_tabs","tbc" ),
            ( "clear_margins","mgc" ),
            ( "clear_screen","clear" ),
            ( "clr_bol","el1" ),
            ( "clr_eol","el" ),
            ( "clr_eos","ed" ),
            ( "code_set_init","csin" ),
            ( "color_names","colornm" ),
            ( "column_address","hpa" ),
            ( "command_character","cmdch" ),
            ( "create_window","cwin" ),
            ( "cursor_address","cup" ),
            ( "cursor_down","cud1" ),
            ( "cursor_home","home" ),
            ( "cursor_invisible","civis" ),
            ( "cursor_left","cub1" ),
            ( "cursor_mem_address","mrcup" ),
            ( "cursor_normal","cnorm" ),
            ( "cursor_right","cuf1" ),
            ( "cursor_to_ll","ll" ),
            ( "cursor_up","cuu1" ),
            ( "cursor_visible","cvvis" ),
            ( "define_bit_image_region","defbi" ),
            ( "define_char","defc" ),
            ( "delete_character","dch1" ),
            ( "delete_line","dl1" ),
            ( "device_type","devt" ),
            ( "dial_phone","dial" ),
            ( "dis_status_line","dsl" ),
            ( "display_clock","dclk" ),
            ( "display_pc_char","dispc" ),
            ( "down_half_line","hd" ),
            ( "ena_acs","enacs" ),
            ( "end_bit_image_region","endbi" ),
            ( "enter_alt_charset_mode","smacs" ),
            ( "enter_am_mode","smam" ),
            ( "enter_blink_mode","blink" ),
            ( "enter_bold_mode","bold" ),
            ( "enter_ca_mode","smcup" ),
            ( "enter_delete_mode","smdc" ),
            ( "enter_dim_mode","dim" ),
            ( "enter_doublewide_mode","swidm" ),
            ( "enter_draft_quality","sdrfq" ),
            ( "enter_horizontal_hl_mode","ehhlm" ),
            ( "enter_insert_mode","smir" ),
            ( "enter_italics_mode","sitm" ),
            ( "enter_left_hl_mode","elhlm" ),
            ( "enter_leftward_mode","slm" ),
            ( "enter_low_hl_mode","elohlm" ),
            ( "enter_micro_mode","smicm" ),
            ( "enter_near_letter_quality","snlq" ),
            ( "enter_normal_quality","snrmq" ),
            ( "enter_pc_charset_mode","smpch" ),
            ( "enter_protected_mode","prot" ),
            ( "enter_reverse_mode","rev" ),
            ( "enter_right_hl_mode","erhlm" ),
            ( "enter_scancode_mode","smsc" ),
            ( "enter_secure_mode","invis" ),
            ( "enter_shadow_mode","sshm" ),
            ( "enter_standout_mode","smso" ),
            ( "enter_subscript_mode","ssubm" ),
            ( "enter_superscript_mode","ssupm" ),
            ( "enter_top_hl_mode","ethlm" ),
            ( "enter_underline_mode","smul" ),
            ( "enter_upward_mode","sum" ),
            ( "enter_vertical_hl_mode","evhlm" ),
            ( "enter_xon_mode","smxon" ),
            ( "erase_chars","ech" ),
            ( "exit_alt_charset_mode","rmacs" ),
            ( "exit_am_mode","rmam" ),
            ( "exit_attribute_mode","sgr0" ),
            ( "exit_ca_mode","rmcup" ),
            ( "exit_delete_mode","rmdc" ),
            ( "exit_doublewide_mode","rwidm" ),
            ( "exit_insert_mode","rmir" ),
            ( "exit_italics_mode","ritm" ),
            ( "exit_leftward_mode","rlm" ),
            ( "exit_micro_mode","rmicm" ),
            ( "exit_pc_charset_mode","rmpch" ),
            ( "exit_scancode_mode","rmsc" ),
            ( "exit_shadow_mode","rshm" ),
            ( "exit_standout_mode","rmso" ),
            ( "exit_subscript_mode","rsubm" ),
            ( "exit_superscript_mode","rsupm" ),
            ( "exit_underline_mode","rmul" ),
            ( "exit_upward_mode","rum" ),
            ( "exit_xon_mode","rmxon" ),
            ( "fixed_pause","pause" ),
            ( "flash_hook","hook" ),
            ( "flash_screen","flash" ),
            ( "form_feed","ff" ),
            ( "from_status_line","fsl" ),
            ( "get_mouse","getm" ),
            ( "goto_window","wingo" ),
            ( "hangup","hup" ),
            ( "init_1string","is1" ),
            ( "init_2string","is2" ),
            ( "init_3string","is3" ),
            ( "init_file","if" ),
            ( "init_prog","iprog" ),
            ( "initialize_color","initc" ),
            ( "initialize_pair","initp" ),
            ( "insert_character","ich1" ),
            ( "insert_line","il1" ),
            ( "insert_padding","ip" ),
            ( "key_a1","ka1" ),
            ( "key_a3","ka3" ),
            ( "key_b2","kb2" ),
            ( "key_backspace","kbs" ),
            ( "key_beg","kbeg" ),
            ( "key_btab","kcbt" ),
            ( "key_c1","kc1" ),
            ( "key_c3","kc3" ),
            ( "key_cancel","kcan" ),
            ( "key_catab","ktbc" ),
            ( "key_clear","kclr" ),
            ( "key_close","kclo" ),
            ( "key_command","kcmd" ),
            ( "key_copy","kcpy" ),
            ( "key_create","kcrt" ),
            ( "key_ctab","kctab" ),
            ( "key_dc","kdch1" ),
            ( "key_dl","kdl1" ),
            ( "key_down","kcud1" ),
            ( "key_eic","krmir" ),
            ( "key_end","kend" ),
            ( "key_enter","kent" ),
            ( "key_eol","kel" ),
            ( "key_eos","ked" ),
            ( "key_exit","kext" ),
            ( "key_f0","kf0" ),
            ( "key_f1","kf1" ),
            ( "key_f62","kf62" ),
            ( "key_f63","kf63" ),
            ( "key_find","kfnd" ),
            ( "key_help","khlp" ),
            ( "key_home","khome" ),
            ( "key_ic","kich1" ),
            ( "key_il","kil1" ),
            ( "key_left","kcub1" ),
            ( "key_ll","kll" ),
            ( "key_mark","kmrk" ),
            ( "key_message","kmsg" ),
            ( "key_mouse","kmous" ),
            ( "key_move","kmov" ),
            ( "key_next","knxt" ),
            ( "key_npage","knp" ),
            ( "key_open","kopn" ),
            ( "key_options","kopt" ),
            ( "key_ppage","kpp" ),
            ( "key_previous","kprv" ),
            ( "key_print","kprt" ),
            ( "key_redo","krdo" ),
            ( "key_reference","kref" ),
            ( "key_refresh","krfr" ),
            ( "key_replace","krpl" ),
            ( "key_restart","krst" ),
            ( "key_resume","kres" ),
            ( "key_right","kcuf1" ),
            ( "key_save","ksav" ),
            ( "key_sbeg","kBEG" ),
            ( "key_scancel","kCAN" ),
            ( "key_scommand","kCMD" ),
            ( "key_scopy","kCPY" ),
            ( "key_screate","kCRT" ),
            ( "key_sdc","kDC" ),
            ( "key_sdl","kDL" ),
            ( "key_select","kslt" ),
            ( "key_send","kEND" ),
            ( "key_seol","kEOL" ),
            ( "key_sexit","kEXT" ),
            ( "key_sf","kind" ),
            ( "key_sfind","kFND" ),
            ( "key_shelp","kHLP" ),
            ( "key_shome","kHOM" ),
            ( "key_sic","kIC" ),
            ( "key_sleft","kLFT" ),
            ( "key_smessage","kMSG" ),
            ( "key_smove","kMOV" ),
            ( "key_snext","kNXT" ),
            ( "key_soptions","kOPT" ),
            ( "key_sprevious","kPRV" ),
            ( "key_sprint","kPRT" ),
            ( "key_sr","kri" ),
            ( "key_sredo","kRDO" ),
            ( "key_sreplace","kRPL" ),
            ( "key_sright","kRIT" ),
            ( "key_srsume","kRES" ),
            ( "key_ssave","kSAV" ),
            ( "key_ssuspend","kSPD" ),
            ( "key_stab","khts" ),
            ( "key_sundo","kUND" ),
            ( "key_suspend","kspd" ),
            ( "key_undo","kund" ),
            ( "key_up","kcuu1" ),
            ( "keypad_local","rmkx" ),
            ( "keypad_xmit","smkx" ),
            ( "lab_f0","lf0" ),
            ( "lab_f1","lf1" ),
            ( "lab_f2","lf2" ),
            ( "lab_f3","lf3" ),
            ( "lab_f4","lf4" ),
            ( "lab_f5","lf5" ),
            ( "lab_f6","lf6" ),
            ( "lab_f7","lf7" ),
            ( "lab_f8","lf8" ),
            ( "lab_f9","lf9" ),
            ( "lab_f10","lf10" ),
            ( "label_format","fln" ),
            ( "label_off","rmln" ),
            ( "label_on","smln" ),
            ( "meta_off","rmm" ),
            ( "meta_on","smm" ),
            ( "micro_column_address","mhpa" ),
            ( "micro_down","mcud1" ),
            ( "micro_left","mcub1" ),
            ( "micro_right","mcuf1" ),
            ( "micro_row_address","mvpa" ),
            ( "micro_up","mcuu1" ),
            ( "mouse_info","minfo" ),
            ( "newline","nel" ),
            ( "order_of_pins","porder" ),
            ( "orig_colors","oc" ),
            ( "orig_pair","op" ),
            ( "pad_char","pad" ),
            ( "parm_dch","dch" ),
            ( "parm_delete_line","dl" ),
            ( "parm_down_cursor","cud" ),
            ( "parm_down_micro","mcud" ),
            ( "parm_ich","ich" ),
            ( "parm_index","indn" ),
            ( "parm_insert_line","il" ),
            ( "parm_left_cursor","cub" ),
            ( "parm_left_micro","mcub" ),
            ( "parm_right_cursor","cuf" ),
            ( "parm_right_micro","mcuf" ),
            ( "parm_rindex","rin" ),
            ( "parm_up_cursor","cuu" ),
            ( "parm_up_micro","mcuu" ),
            ( "pc_term_options","pctrm" ),
            ( "pkey_key","pfkey" ),
            ( "pkey_local","pfloc" ),
            ( "pkey_plab","pfxl" ),
            ( "pkey_xmit","pfx" ),
            ( "plab_norm","pln" ),
            ( "print_screen","mc0" ),
            ( "prtr_non","mc5p" ),
            ( "prtr_off","mc4" ),
            ( "prtr_on","mc5" ),
            ( "pulse","pulse" ),
            ( "quick_dial","qdial" ),
            ( "remove_clock","rmclk" ),
            ( "repeat_char","rep" ),
            ( "req_for_input","rfi" ),
            ( "req_mouse_pos","reqmp" ),
            ( "reset_1string","rs1" ),
            ( "reset_2string","rs2" ),
            ( "reset_3string","rs3" ),
            ( "reset_file","rf" ),
            ( "restore_cursor","rc" ),
            ( "row_address","vpa" ),
            ( "save_cursor","sc" ),
            ( "scancode_escape","scesc" ),
            ( "scroll_forward","ind" ),
            ( "scroll_reverse","ri" ),
            ( "select_char_set","scs" ),
            ( "set0_des_seq","s0ds" ),
            ( "set1_des_seq","s1ds" ),
            ( "set2_des_seq","s2ds" ),
            ( "set3_des_seq","s3ds" ),
            ( "set_a_attributes","sgr1" ),
            ( "set_a_background","setab" ),
            ( "set_a_foreground","setaf" ),
            ( "set_attributes","sgr" ),
            ( "set_background","setb" ),
            ( "set_bottom_margin","smgb" ),
            ( "set_bottom_margin_parm","smgbp" ),
            ( "set_clock","sclk" ),
            ( "set_color_band","setcolor" ),
            ( "set_color_pair","scp" ),
            ( "set_foreground","setf" ),
            ( "set_left_margin","smgl" ),
            ( "set_left_margin_parm","smglp" ),
            ( "set_lr_margin","smglr" ),
            ( "set_page_length","slines" ),
            ( "set_pglen_inch","slength" ),
            ( "set_right_margin","smgr" ),
            ( "set_right_margin_parm","smgrp" ),
            ( "set_tab","hts" ),
            ( "set_tb_margin","smgtb" ),
            ( "set_top_margin","smgt" ),
            ( "set_top_margin_parm","smgtp" ),
            ( "set_window","wind" ),
            ( "start_bit_image","sbim" ),
            ( "start_char_set_def","scsd" ),
            ( "stop_bit_image","rbim" ),
            ( "stop_char_set_def","rcsd" ),
            ( "subscript_characters","subcs" ),
            ( "superscript_characters","supcs" ),
            ( "tab","ht" ),
            ( "these_cause_cr","docr" ),
            ( "to_status_line","tsl" ),
            ( "tone","tone" ),
            ( "user0","u0" ),
            ( "user1","u1" ),
            ( "user2","u2" ),
            ( "user3","u3" ),
            ( "user4","u4" ),
            ( "user5","u5" ),
            ( "user6","u6" ),
            ( "user7","u7" ),
            ( "user8","u8" ),
            ( "user9","u9" ),
            ( "underline_char","uc" ),
            ( "up_half_line","hu" ),
            ( "wait_tone","wait" ),
            ( "xoff_character","xoffc" ),
            ( "xon_character","xonc" ),
            ( "zero_motion","zerom" ), 
        ];

        pub const CanIdentTriplet:&[( &str, &str, &str, &str, &str, &str, &str, &str )] = 
        &[
            //define!( string SetTrueColorBackground => "8b"; r: u8, g: u8, b: u8 );
            ( 
                "SetTrueColorBackground","8b",
                "r","0",
                "g","0",
                "b","0",
            )
        ];

        pub const CanIdent:&[( &str, &str )] = 
        &[
            //define!( string ResetCursorColor => "Cr" );
            ( "ResetCursorColor","Cr" )
        ];

        pub const CanIdentKeyValue:&[( &str, &str, &str, &str )] = 
        &[
            //define!( string SetCursorColor => "Cs"; color: String );
            ( "SetCursorColor","Cs","color","white" )
        ];
        //string builder direct $ident:ident; $index:expr, $name:ident : $ty:ty

        pub static mut DATABASE:String = String::new();

        pub fn build() -> Result<(), error::parse::ParseError>
        {
            unsafe
            {
                /*
                Handle Booleans Table */
                BOOLEANS.push_str( r#"booleans:  {
                "#  );

                for ( index, name ) in BOOLEAN.iter().enumerate()
                {
                    // println!( r#"b{}:{}"#, index, name  );
                    BOOLEANS.push_str
                    ( 
                        format!( r#"   b{}: "{}"
                        "#, index, name ).as_str()
                     );
                }

                BOOLEANS.push_str( r#"}"#  );
                /*
                Handle Numbers Table */
                NUMBERS.push_str( r#"numbers:  {
                "#  );

                for ( index, name ) in NUMBER.iter().enumerate()
                {
                    // println!( r#"b{}:{}"#, index, name  );
                    NUMBERS.push_str
                    ( 
                        format!( r#"   n{}: "{}"
                    "#, index, name ).as_str()
                     );
                }

                NUMBERS.push_str( r#"}"#  );
                /*
                Handle Strings Table */
                STRINGS.push_str( r#"strings:  {
                "#  );

                for ( index, name ) in STRING.iter().enumerate()
                {
                    // println!( r#"b{}:{}"#, index, name  );
                    STRINGS.push_str
                    ( 
                        format!( r#"   s{}: "{}"
                    "#, index, name ).as_str()
                     );
                }

                STRINGS.push_str( r#"}"#  );
                /*
                Handle Information & Alias Table */
                INFORMATION.push_str( r#"information:  {
                "#  );
                ALIASES.push_str( r#"aliases:  {
                "#  );

                for ( index, pair ) in TERMINFO.iter().enumerate()
                {
                    // println!( r#"b{}:{}"#, index, name  );
                    INFORMATION.push_str
                    ( 
                        format!( r#"   i{}: ( "{}" "{}" )
                        "#, index, pair.0, pair.1 ).as_str()
                     );

                    ALIASES.push_str
                    ( 
                        format!( r#"   {}: "{}"
                        "#, pair.0, pair.1 ).as_str()
                     );
                }

                INFORMATION.push_str( r#"}"#  );

                ALIASES.push_str( r#"}"#  );

                DATABASE = format!( r#"
                {}
                {}
                {}
                {}
                {}
                "#, BOOLEANS, NUMBERS, STRINGS, INFORMATION, ALIASES  );
                Ok( () )
            }
        }
        
        pub mod buffer
        {
            /*!
            */
            use ::
            {
                mem::{ swap },
                ops::{ Range },
                str::{ SmallString },
                system::
                {
                    common::
                    {
                       terminal::{ Color, Cursor, Size, Style, Theme }, 
                    },
                },
                *,
            };
            /*
            use crate::terminal::{Color, Cursor, Size, Style, Theme};
            use crate::util::{char_width, is_combining_mark};
            */
            const TAB_STOP: usize = 8;

            pub struct ScreenBuffer 
            {
                buffer: Vec<Cell>,
                back_buffer: Vec<Cell>,
                size: Size,
                cursor: Cursor,
                fg:Option<Color>,
                bg:Option<Color>,
                style: Style,
            }

            impl ScreenBuffer 
            {
                pub fn new( size: Size ) -> ScreenBuffer 
                {
                    let area = size.area();

                    ScreenBuffer
                    {
                        buffer: vec![Cell::default(); area],
                        back_buffer: vec![Cell::default(); area],
                        size: size,
                        cursor: Cursor::default(),
                        fg: None,
                        bg: None,
                        style: Style::empty(),
                    }
                }

                pub fn cursor( &self ) -> Cursor { self.cursor }

                pub fn size( &self ) -> Size { self.size }

                pub fn resize( &mut self, new_size: Size )
                {
                    resize_buffer( &mut self.buffer, self.size, new_size );
                    new_buffer( &mut self.back_buffer, new_size );
                    self.size = new_size;
                }

                pub fn set_cursor( &mut self, pos: Cursor ) { self.cursor = pos; }

                pub fn next_line( &mut self, column: usize )
                {
                    self.cursor.line += 1;
                    self.cursor.column = column;
                }

                pub fn clear_attributes( &mut self )
                {
                    self.fg = None;
                    self.bg = None;
                    self.style = Style::empty();
                }

                pub fn add_style( &mut self, style: Style ) { self.style |= style; }

                pub fn remove_style( &mut self, style: Style ) { self.style -= style; }

                pub fn set_style( &mut self, style: Style ) { self.style = style; }

                pub fn set_fg( &mut self, fg:Option<Color> ) { self.fg = fg; }

                pub fn set_bg( &mut self, bg:Option<Color> ) { self.bg = bg; }

                pub fn set_theme( &mut self, theme: Theme )
                {
                    self.set_fg( theme.fg );
                    self.set_bg( theme.bg );
                    self.set_style( theme.style );
                }

                pub fn clear_screen( &mut self )
                {
                    for cell in &mut self.buffer
                    {
                        *cell = Cell::default();
                    }
                }

                pub fn indices( &self ) -> Range<usize> { 0..self.size.area() }
                
                pub fn next_cell( &mut self, indices:&mut Range<usize> ) -> Option<( Cursor, Cell )>
                {
                    while let Some( idx ) = indices.next() 
                    {
                        let first = self.buffer[idx].first_char();
                        let width = char::width( first ).unwrap_or( 0 );
                        
                        if width == 2 { let _ = indices.next(); }

                        if self.buffer[idx] != self.back_buffer[idx]
                        {
                            let cell = self.buffer[idx].clone();
                            let line = idx / self.size.columns;
                            let column = idx % self.size.columns;
                            self.back_buffer[idx] = cell.clone();
                            return Some( ( Cursor{line, column}, cell ) );
                        }
                    }

                    None
                }                

                fn cell_mut( &mut self, pos: Cursor ) -> &mut Cell 
                {
                    let size = self.size;
                    &mut self.buffer[pos.as_index( size )]
                }

                fn set_cell( &mut self, pos: Cursor, ch:char ) 
                {
                    let fg = self.fg;
                    let bg = self.bg;
                    let style = self.style;

                    let cell = self.cell_mut( pos );

                    cell.fg = fg;
                    cell.bg = bg;
                    cell.style = style;
                    cell.text = ch.into();
                }

                pub fn write_char( &mut self, ch:char ) -> Result<(), OutOfBounds> 
                {
                    if ch == '\t'
                    {
                        self.try_cursor()?;
                        let rem = self.size.columns - self.cursor.column;
                        let n = rem.min( TAB_STOP - ( self.cursor.column % TAB_STOP ) );

                        for _ in 0..n
                        {
                            self.write_char( ' ' )?;
                        }
                    }

                    else if ch == '\r' { self.cursor.column = 0; }
                    
                    else if ch == '\n'
                    {
                        self.cursor.line += 1;
                        self.cursor.column = 0;
                    }
                    
                    else if is::combining_mark( ch )
                    {
                        if let Some( prev ) = self.cursor.previous( self.size )
                        {
                            self.try_cursor_at( prev )?;
                            self.cell_mut( prev ).text.push( ch );
                        }
                    }
                    
                    else if is::visible( ch )
                    {
                        self.try_cursor()?;

                        if let Some( prev ) = self.cursor.previous( self.size )
                        {
                            let cell = self.cell_mut( prev );

                            if cell.is_wide() { *cell = Cell::default(); }
                        }

                        let rem = self.size.columns - self.cursor.column;
                        let width = char::width( ch ).unwrap_or( 0 );
                        
                        if rem < width 
                        {
                            self.try_cursor()?;
                            let mut pos = self.cursor;

                            for _ in 0..rem {
                                self.set_cell( pos, ch );
                                pos.column += 1;
                            }

                            self.cursor.column = 0;
                            self.cursor.line += 1;
                        }

                        self.try_cursor()?;

                        let mut pos = self.cursor;
                        self.set_cell( pos, ch );

                        for _ in 1..width 
                        {
                            pos.column += 1;
                            self.set_cell( pos, ' ' );
                        }

                        self.cursor.column += width;

                        if self.cursor.column >= self.size.columns 
                        {
                            self.cursor.line += 1;
                            self.cursor.column = 0;
                        }
                    }

                    Ok( () )
                }

                pub fn write_str( &mut self, s:&str ) -> Result<(), OutOfBounds>
                {
                    for ch in s.chars()
                    {
                        self.write_char( ch )?;
                    }

                    Ok( () )
                }

                pub fn write_at( &mut self, pos: Cursor, text:&str ) -> Result<(), OutOfBounds>
                {
                    self.try_cursor_at( pos )?;
                    self.cursor = pos;
                    self.write_str( text )
                }

                pub fn write_styled
                ( 
                    &mut self,
                    fg:Option<Color>,
                    bg:Option<Color>,
                    style: Style, text:&str
                ) -> Result<(), OutOfBounds>
                {
                    self.fg = fg;
                    self.bg = bg;
                    self.style = style;
                    self.write_str( text )?;
                    self.clear_attributes();
                    Ok( () )
                }

                pub fn write_styled_at
                ( 
                    &mut self,
                    pos: Cursor,
                    fg:Option<Color>,
                    bg:Option<Color>,
                    style: Style,
                    text:&str
                ) -> Result<(), OutOfBounds>
                {
                    self.try_cursor_at( pos )?;
                    self.cursor = pos;
                    self.write_styled( fg, bg, style, text )
                }

                fn try_cursor( &self ) -> Result<(), OutOfBounds> { self.try_cursor_at( self.cursor ) }

                fn try_cursor_at( &self, pos: Cursor ) -> Result<(), OutOfBounds>
                {
                    if pos.line >= self.size.lines || pos.column >= self.size.columns
                    { Err( OutOfBounds( () ) ) }
                    else { Ok( () ) }
                }
            }

            #[derive( Debug )]
            pub struct OutOfBounds( () );

            #[derive( Clone, Debug, Eq, PartialEq )]
            pub struct Cell 
            {
                fg:Option<Color>,
                bg:Option<Color>,
                style: Style,
                text: SmallString<[u8; 8]>,
            }

            impl Cell 
            {
                fn new( fg:Option<Color>, bg:Option<Color>, style: Style, chr:char ) -> Cell
                {
                    Cell
                    {
                        fg,
                        bg,
                        style,
                        text: chr.into(),
                    }
                }

                fn invalid() -> Cell 
                {
                    Cell
                    {
                        fg: None,
                        bg: None,
                        style: Style::empty(),
                        text: SmallString::new(),
                    }
                }

                pub fn attrs( &self ) -> ( Option<Color>, Option<Color>, Style )
                { ( self.fg, self.bg, self.style ) }

                pub fn text( &self ) -> &str { &self.text }

                fn first_char( &self ) -> char { self.text.chars().next().expect( "empty cell text" ) }

                fn is_wide( &self ) -> bool
                { self.text.chars().next().and_then( char::width ).unwrap_or( 0 ) == 2 }
            }

            impl Default for Cell 
            {
                fn default() -> Cell {
                    Cell::new( None, None, Style::empty(), ' ' )
                }
            }

            fn resize_buffer( buf:&mut Vec<Cell>, old: Size, new: Size ) 
            {
                if old != new
                {
                    let mut new_buf = vec![Cell::default(); new.area()];

                    if !buf.is_empty() 
                    {
                        let n_cols = old.columns.min( new.columns );

                        for ( old, new ) in buf
                        .chunks_mut( old.columns )
                        .zip( new_buf.chunks_mut( new.columns ) ) 
                        {
                            for i in 0..n_cols
                            {
                                swap( &mut new[i], &mut old[i] );
                            }
                        }
                    }

                    *buf = new_buf;
                }
            }

            fn new_buffer( buf:&mut Vec<Cell>, new_size: Size )
            {
                *buf = vec![Cell::invalid(); new_size.area()];
            }
        }

        pub mod screen
        {
            /*!
            Provides a drawable buffer on terminal devices */
            use ::
            {
                map::{ map_lock_result, map_try_lock_result },
                sync::{ LockResult, TryLockResult },
                system::
                {
                    common::
                    {
                        terminal::
                        {
                            Color, Cursor, CursorMode, Event, PrepareConfig, Size, Style, Theme, 
                            Terminal,
                        }
                    },
                },
                time::std::{ Duration },
                *,
            };

            use super::sys;
            /*
            */

            pub struct Screen( sys::Screen  );

            pub struct ScreenReadGuard<'a>( sys::ScreenReadGuard<'a>  );

            pub struct ScreenWriteGuard<'a>( sys::ScreenWriteGuard<'a>  );

            impl Screen
            
            {

                pub fn new( config: PrepareConfig ) -> io::Result<Screen>
                { sys::Screen::stdout( config ).map( Screen ) }

                pub fn stderr( config: PrepareConfig ) -> io::Result<Screen>
                { sys::Screen::stderr( config ).map( Screen ) }

                pub fn with_terminal( term: Terminal, config: PrepareConfig ) -> io::Result<Screen>
                { sys::Screen::new( term.0, config ).map( Screen ) }

                #[inline] pub fn name( &self ) -> &str { self.0.name() }

                #[inline] pub fn lock_read( &self ) -> LockResult<ScreenReadGuard>
                { map_lock_result( self.0.lock_read(), ScreenReadGuard ) }

                #[inline] pub fn lock_write( &self ) -> LockResult<ScreenWriteGuard>
                { map_lock_result( self.0.lock_write(), ScreenWriteGuard ) }

                #[inline] pub fn try_lock_read( &self ) -> TryLockResult<ScreenReadGuard>
                { map_try_lock_result( self.0.try_lock_read(), ScreenReadGuard ) }

                #[inline] pub fn try_lock_write( &self ) -> TryLockResult<ScreenWriteGuard>
                { map_try_lock_result( self.0.try_lock_write(), ScreenWriteGuard ) }

                pub fn wait_event( &self, timeout:Option<Duration> ) -> io::Result<bool> { self.0.wait_event( timeout ) }

                pub fn read_event( &self, timeout:Option<Duration> ) -> io::Result<Option<Event>>  {
                    self.0.read_event( timeout )
                }

                #[inline] pub fn size( &self ) -> Size { self.0.size() }

                #[inline] pub fn cursor( &self ) -> Cursor { self.0.cursor() }

                #[inline] pub fn set_cursor<C: Into<Cursor>>( &self, pos: C ) {
                    self.0.set_cursor( pos.into() );
                }

                #[inline] pub fn next_line( &self, column: usize ) {
                    self.0.next_line( column );
                }

                pub fn set_cursor_mode( &self, mode: CursorMode ) -> io::Result<()> { self.0.set_cursor_mode( mode ) }

                pub fn clear_screen( &self ) {
                    self.0.clear_screen();
                }

                #[inline] pub fn add_style( &self, style: Style ) {
                    self.0.add_style( style );
                }

                #[inline] pub fn remove_style( &self, style: Style ) {
                    self.0.remove_style( style );
                }

                #[inline] pub fn set_style<S: Into<Option<Style>>>( &self, style: S ) {
                    self.0.set_style( style.into().unwrap_or_default() );
                }

                #[inline] pub fn set_fg<C: Into<Option<Color>>>( &self, fg: C ) {
                    self.0.set_fg( fg.into() );
                }

                #[inline] pub fn set_bg<C: Into<Option<Color>>>( &self, bg: C ) {
                    self.0.set_bg( bg.into() );
                }

                #[inline] pub fn set_theme( &self, theme: Theme ) {
                    self.0.set_theme( theme )
                }

                #[inline] pub fn clear_attributes( &self ) {
                    self.0.clear_attributes();
                }

                #[inline] pub fn bold( &self ) {
                    self.add_style( Style::BOLD );
                }

                #[inline] pub fn italic( &self ) {
                    self.add_style( Style::ITALIC );
                }

                #[inline] pub fn underline( &self ) {
                    self.add_style( Style::UNDERLINE );
                }

                #[inline] pub fn reverse( &self ) {
                    self.add_style( Style::REVERSE );
                }

                pub fn refresh( &self ) -> io::Result<()> { self.0.refresh() }

                pub fn write_at<C>( &self, position: C, text:&str )
                         where C: Into<Cursor> { self.0.write_at( position.into(), text ); }

                pub fn write_styled<F, B, S>( &self, fg: F, bg: B, style: S, text:&str ) where
                        F: Into<Option<Color>>,
                        B: Into<Option<Color>>,
                        S: Into<Option<Style>>,
                        {
                    self.0.write_styled( fg.into(), bg.into(), style.into().unwrap_or_default(), text );
                }

                pub fn write_styled_at<C, F, B, S>( &self, position: C,
                        fg: F, bg: B, style: S, text:&str ) where
                        C: Into<Cursor>,
                        F: Into<Option<Color>>,
                        B: Into<Option<Color>>,
                        S: Into<Option<Style>>,
                        {
                    self.0.write_styled_at( position.into(),
                        fg.into(), bg.into(), style.into().unwrap_or_default(), text );
                }

                pub fn write_char( &self, ch:char ) {
                    self.0.write_char( ch );
                }

                pub fn write_str( &self, s:&str ) {
                    self.0.write_str( s  );
                }

                pub fn write_fmt( &self, args: fmt::Arguments ) {
                    let s = args.to_string();
                    self.write_str( &s )
                }

                #[doc( hidden )]
                pub fn borrow_term_write_guard( &self ) -> ScreenWriteGuard { self.lock_write().unwrap() }
            }

            impl<'a> ScreenReadGuard<'a>
            
            {

                pub fn wait_event( &mut self, timeout:Option<Duration> ) -> io::Result<bool>
                { self.0.wait_event( timeout ) }

                pub fn read_event( &mut self, timeout:Option<Duration> ) -> io::Result<Option<Event>>
                { self.0.read_event( timeout ) }
            }

            impl<'a> ScreenWriteGuard<'a>
            {

                #[inline] pub fn size( &self ) -> Size { self.0.size() }

                #[inline] pub fn cursor( &self ) -> Cursor { self.0.cursor() }

                #[inline] pub fn set_cursor<C: Into<Cursor>>( &mut self, pos: C ) 
                { self.0.set_cursor( pos.into() ); }

                #[inline] pub fn next_line( &mut self, column: usize ) { self.0.next_line( column ); }

                pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> 
                { self.0.set_cursor_mode( mode ) }

                pub fn clear_screen( &mut self ) { self.0.clear_screen();}
                
                #[inline] pub fn add_style( &mut self, style: Style ) { self.0.add_style( style ) }

                #[inline] pub fn remove_style( &mut self, style:Style ) { self.0.remove_style( style ) }

                #[inline] pub fn set_style<S: Into<Option<Style>>>( &mut self, style: S ) 
                { self.0.set_style( style.into().unwrap_or_default() ) }

                #[inline] pub fn set_fg<C: Into<Option<Color>>>( &mut self, fg: C ) 
                { self.0.set_fg( fg.into() ) }

                #[inline] pub fn set_bg<C: Into<Option<Color>>>( &mut self, bg: C ) 
                { self.0.set_bg( bg.into() ) }

                #[inline] pub fn set_theme( &mut self, theme: Theme ) { self.0.set_theme( theme ) }

                #[inline] pub fn clear_attributes( &mut self ) { self.0.clear_attributes() }

                #[inline] pub fn bold( &mut self ) { self.add_style( Style::BOLD ) }

                #[inline] pub fn italic( &mut self ) { self.add_style( Style::ITALIC ); }

                #[inline] pub fn underline( &mut self ) { self.add_style( Style::UNDERLINE ) }

                #[inline] pub fn reverse( &mut self ) { self.add_style( Style::REVERSE ) }

                pub fn refresh( &mut self ) -> io::Result<()> { self.0.refresh() }

                pub fn write_at<C>( &mut self, position: C, text:&str )  where 
                C: Into<Cursor>
                { self.0.write_at( position.into(), text ) }

                pub fn write_styled<F,B,S>( &mut self, fg: F, bg: B, style: S, text:&str ) where
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                {
                    self.0.write_styled( fg.into(), bg.into(), style.into().unwrap_or_default(), text )
                }

                pub fn write_styled_at<C,F,B,S>
                ( 
                    &mut self,
                    position:C,
                    fg:F,
                    bg:B,
                    style:S,
                    text:&str
                ) where
                C: Into<Cursor>,
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                {
                    self.0.write_styled_at
                    ( position.into(), fg.into(), bg.into(), style.into().unwrap_or_default(), text )
                }

                pub fn write_char( &mut self, ch:char ) { self.0.write_char( ch ) }

                pub fn write_str( &mut self, s:&str ) { self.0.write_str( s ) }

                pub fn write_fmt( &mut self, args: fmt::Arguments )
                {
                    let s = args.to_string();
                    self.write_str( &s )
                }
                
                pub fn borrow_term_write_guard( &mut self ) -> &mut Self { self }
            }

            #[cfg( unix )] impl sys::TerminalExt for Screen
            {
                fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) ->
                io::Result<Option<Event>>
                { self.0.read_raw( buf, timeout ) }
            }

            #[cfg( unix )] impl<'a> sys::TerminalExt for ScreenReadGuard<'a>
            {
                fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) ->
                io::Result<Option<Event>>
                { self.0.read_raw( buf, timeout ) }
            }
            /*
            #[cfg( windows )]
            impl crate::windows::TerminalExt for Screen {
                fn read_raw( &mut self, buf:&mut [u16], timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.0.read_raw( buf, timeout ) }

                fn read_raw_event( &mut self, events:&mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.0.read_raw_event( events, timeout ) }
            }

            #[cfg( windows )]
            impl<'a> crate::windows::TerminalExt for ScreenReadGuard<'a> {
                fn read_raw( &mut self, buf:&mut [u16], timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.0.read_raw( buf, timeout ) }

                fn read_raw_event( &mut self, events:&mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.0.read_raw_event( events, timeout ) }
            } */
        } pub use self::screen::{ Screen, ScreenReadGuard, ScreenWriteGuard };

        pub mod signal
        {
            /*!
            */
            use ::
            {
                iter::{ FromIterator },
                *,
            };
            /*
            */
            pub const NUM_SIGNALS: u8 = 6;
            
            macro_rules! impl_op
            {
                ( $tr:ident , $tr_meth:ident , $method:ident ) =>
                {
                    impl ops::$tr for SignalSet
                    {
                        type Output = SignalSet;
                        fn $tr_meth( self, rhs: SignalSet ) -> SignalSet { self.$method( rhs ) }
                    }
                }
            }

            macro_rules! impl_mut_op
            {
                ( $tr:ident , $tr_meth:ident , $method:ident ) =>
                {
                    impl ops::$tr for SignalSet
                    {
                        fn $tr_meth( &mut self, rhs: SignalSet ) { *self = self.$method( rhs ); }
                    }
                }
            }

            macro_rules! impl_unary_op
            {
                ( $tr:ident , $tr_meth:ident , $method:ident ) =>
                {
                    impl ops::$tr for SignalSet
                    {
                        type Output = SignalSet;
                        fn $tr_meth( self ) -> SignalSet { self.$method() }
                    }
                }
            }

            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum Signal
            {

                Break,
                Continue,
                Interrupt,
                Resize,
                Suspend,
                Quit,
            }
            
            impl Signal
            {
                fn as_bit( &self ) -> u8 { 1 << ( *self as u8 ) }
                fn all_bits() -> u8 { ( 1 << NUM_SIGNALS ) - 1 }
            }

            impl ops::BitOr for Signal
            {
                type Output = SignalSet;
                fn bitor( self, rhs: Signal ) -> SignalSet
                {
                    let mut set = SignalSet::new();
                    set.insert( self );
                    set.insert( rhs );
                    set
                }
            }

            impl ops::Not for Signal
            {
                type Output = SignalSet;
                fn not( self ) -> SignalSet { !SignalSet::from( self ) }
            }

            #[derive( Copy, Clone, Default, Eq, PartialEq )]
            pub struct SignalSet( u8  );

            impl SignalSet
            
            {

                pub fn new() -> SignalSet { SignalSet( 0 ) }

                pub fn all() -> SignalSet { SignalSet( Signal::all_bits() ) }

                pub fn contains( &self, sig: Signal ) -> bool { self.0 & sig.as_bit() != 0 }

                pub fn contains_all( &self, other: SignalSet ) -> bool { self.0 & other.0 == other.0 }

                pub fn intersects( &self, other: SignalSet ) -> bool { self.0 & other.0 != 0 }

                pub fn is_empty( &self ) -> bool { self.0 == 0 }

                pub fn insert( &mut self, sig: Signal ) { self.0 |= sig.as_bit(); }

                pub fn remove( &mut self, sig: Signal ) { self.0 &= !sig.as_bit(); }

                pub fn set( &mut self, sig: Signal, set: bool )
                {
                    if set { self.insert( sig ); }
                    else { self.remove( sig ); }
                }

                pub fn difference( &self, other: SignalSet ) -> SignalSet
                { SignalSet( self.0 & !other.0 ) }

                pub fn symmetric_difference( &self, other: SignalSet ) -> SignalSet
                { SignalSet( self.0 ^ other.0 ) }

                pub fn intersection( &self, other: SignalSet ) -> SignalSet
                { SignalSet( self.0 & other.0 ) }

                pub fn union( &self, other: SignalSet ) -> SignalSet { SignalSet( self.0 | other.0 ) }

                pub fn inverse( &self ) -> SignalSet { SignalSet( !self.0 & Signal::all_bits() ) }
            }

            impl fmt::Debug for SignalSet
           
            {
                fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
                {
                    const SIGNALS:&[Signal] = &
                    [
                        Signal::Break,
                        Signal::Continue,
                        Signal::Interrupt,
                        Signal::Resize,
                        Signal::Suspend,
                        Signal::Quit,
                    ];

                    let mut first = true;

                    f.write_str( "SignalSet( " )?;

                    for &sig in SIGNALS
                    {
                        if self.contains( sig )
                        {
                            if !first { f.write_str( " | " )?; }

                            write!( f, "{:?}", sig )?;
                            first = false;
                        }
                    }

                    f.write_str( " )" )
                }
            }

            impl From<Signal> for SignalSet
            {
                fn from( sig: Signal ) -> SignalSet
                {
                    let mut set = SignalSet::new();
                    set.insert( sig );
                    set
                }
            }

            impl Extend<Signal> for SignalSet
            {
                fn extend<I: IntoIterator<Item=Signal>>( &mut self, iter: I )
                {
                    for sig in iter
                    {
                        self.insert( sig );
                    }
                }
            }

            impl FromIterator<Signal> for SignalSet
            {
                fn from_iter<I: IntoIterator<Item=Signal>>( iter: I ) -> SignalSet
                {
                    let mut set = SignalSet::new();
                    set.extend( iter );
                    set
                }
            }

            impl_op!{ BitAnd, bitand, intersection }
            impl_op!{ BitOr, bitor, union }
            impl_op!{ BitXor, bitxor, symmetric_difference }
            impl_op!{ Sub, sub, difference }
            impl_unary_op!{ Not, not, inverse }
            impl_mut_op!{ BitAndAssign, bitand_assign, intersection }
            impl_mut_op!{ BitOrAssign, bitor_assign, union }
            impl_mut_op!{ BitXorAssign, bitxor_assign, symmetric_difference }
            impl_mut_op!{ SubAssign, sub_assign, difference }
        } pub use self::signal::{ Signal, SignalSet };

        pub mod terminal        
        {
            /*!
            Provides an interface to terminal devices. */
            use ::
            {
                map::{ map_lock_result, map_try_lock_result },
                sync::{ LockResult, TryLockResult },
                time::std::{ Duration },
                *,
            };
            use super::{ sys, Signal, SignalSet };
            /*
            */

            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum Color
            {

                Black,
                Blue,
                Cyan,
                Green,
                Magenta,
                Red,
                White,
                Yellow,
            }

            bitflags!
            {

                #[derive( Copy, Clone, Debug, Default, Eq, PartialEq, Hash )]
                pub struct Style: u8
                {

                    const BOLD      = 1 << 0;

                    const ITALIC    = 1 << 1;

                    const REVERSE   = 1 << 2;

                    const UNDERLINE = 1 << 3;
                }
            }

            #[derive( Copy, Clone, Debug, Default )]
            pub struct Theme
            {

                pub fg:Option<Color>,
                pub bg:Option<Color>,
                pub style: Style,
            }

            impl Theme
            
            {

                pub fn new<F,B,S>( fg: F, bg: B, style: S ) -> Theme where
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                {
                    Theme
                    {
                        fg: fg.into(),
                        bg: bg.into(),
                        style: style.into().unwrap_or_default(),
                    }
                }

                pub fn fg<F>( mut self, fg: F ) -> Theme where
                F: Into<Option<Color>>
                {
                    self.fg = fg.into();
                    self
                }

                pub fn bg<B>( mut self, bg: B ) -> Theme where
                B: Into<Option<Color>>
                {
                    self.bg = bg.into();
                    self
                }

                pub fn style<S>( mut self, style: S ) -> Theme where
                S:Into<Option<Style>>
                {
                    self.style = style.into().unwrap_or_default();
                    self
                }
            }

            #[derive( Copy, Clone, Debug, Default, Eq, PartialEq )]
            pub struct Cursor
            {

                pub line: usize,
                pub column: usize,
            }

            impl Cursor
            {

                #[inline] pub fn next( &self, size: Size ) -> Option<Cursor>
                {
                    let mut line = self.line;
                    let mut column = self.column + 1;

                    if column >= size.columns
                    {
                        column = 0;
                        line += 1;
                    }

                    if line >= size.lines { None }
                    else { Some( Cursor{line, column} ) }
                }

                #[inline] pub fn previous( &self, size: Size ) -> Option<Cursor>
                {
                    if self.column == 0
                    {
                        if self.line == 0 { None }
                        else { Some( Cursor{line: self.line - 1, column: size.columns - 1} ) }
                    }

                    else { Some( Cursor{line: self.line, column: self.column - 1} ) }
                }

                #[inline] pub fn first() -> Cursor
                {
                    Cursor
                    {
                        line: 0,
                        column: 0,
                    }
                }

                #[inline] pub fn last( size: Size ) -> Cursor
                {
                    Cursor
                    {
                        line: size.lines - 1,
                        column: size.columns - 1,
                    }
                }

                #[inline] pub fn is_out_of_bounds( &self, size: Size ) -> bool 
                {
                    self.line >= size.lines || self.column >= size.columns
                }

                pub fn as_index( &self, size: Size ) -> usize 
                { self.line * size.columns + self.column }
            }

            impl From<( usize, usize )> for Cursor
            {
                fn from( ( line, column ): ( usize, usize ) ) -> Cursor { Cursor{line, column} }
            }

            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum CursorMode
            {

                Normal,
                Invisible,
                Overwrite,
            }

            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum Event
            {

                Key( Key ),
                Mouse( MouseEvent ),
                Raw( usize ),
                Resize( Size ),
                Signal( Signal ),
                NoEvent,
            }

            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum Key
            {

                Backspace,
                Enter,
                Escape,
                Tab,
                Up,
                Down,
                Left,
                Right,
                Delete,
                Insert,
                Home,
                End,
                PageUp,
                PageDown,
                Char( char ),
                Ctrl( char ),
                F( u32 ),
            }

            impl From<char> for Key
            {
                fn from( ch:char ) -> Key
                {
                    use ::char::unctrl_lower;
                    match ch
                    {
                        '\x1b' => Key::Escape,
                        '\x7f' => Key::Backspace,
                        '\r' | '\n' => Key::Enter,
                        '\t' => Key::Tab,
                        _ if is::control( ch ) => Key::Ctrl( unctrl_lower( ch ) ),
                        _ => Key::Char( ch ),
                    }
                }
            }

            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub struct MouseEvent
            {

                pub position: Cursor,
                pub input: MouseInput,
                pub modifiers: ModifierState,
            }

            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum MouseInput
            {

                Motion,
                ButtonPressed( MouseButton ),
                ButtonReleased( MouseButton ),
                WheelUp,
                WheelDown,
            }

            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub enum MouseButton
            {

                Left,
                Right,
                Middle,
                Other( u32 ),
            }

            bitflags!
            {

                #[derive( Copy, Clone, Debug, Eq, PartialEq, Hash )]
                pub struct ModifierState: u8
                {

                    const ALT   = 1 << 0;

                    const CTRL  = 1 << 1;

                    const SHIFT = 1 << 2;
                }
            }

            #[derive( Copy, Clone, Debug )]
            pub struct PrepareConfig
            {

                pub block_signals: bool,
                pub enable_control_flow: bool,
                pub enable_keypad: bool,
                pub enable_mouse: bool,
                pub always_track_motion: bool,
                pub report_signals: SignalSet,
            }

            impl Default for PrepareConfig
            {
                fn default() -> PrepareConfig
                {
                    PrepareConfig
                    {
                        block_signals: true,
                        enable_control_flow: false,
                        enable_keypad: true,
                        enable_mouse: false,
                        always_track_motion: false,
                        report_signals: SignalSet::new(),
                    }
                }
            }

            #[must_use = "the result of `terminal.prepare()` should be passed to \
            `terminal.restore()` to restore terminal to its original state"]
            pub struct PrepareState( sys::PrepareState  );

            #[derive( Copy, Clone, Debug, Eq, PartialEq )]
            pub struct Size
            {

                pub lines: usize,
                pub columns: usize,
            }

            impl Size
            {

                #[inline] pub fn area( &self ) -> usize
                {
                    self.checked_area()
                        .unwrap_or_else( || panic!( "overflow in Size::area {:?}", self ) )
                }

                #[inline] pub fn checked_area( &self ) -> Option<usize>
                { self.lines.checked_mul( self.columns ) }
            }

            pub struct Terminal( pub sys::Terminus  );

            pub struct TerminalReadGuard<'a>( sys::TerminalReadGuard<'a>  );

            pub struct TerminalWriteGuard<'a>( sys::TerminalWriteGuard<'a>  );

            impl Terminal
            
            {

                pub fn new() -> io::Result<Terminal>{ Ok( Terminal( sys::Terminus::stdout()? ) ) }

                pub fn stderr() -> io::Result<Terminal> {Ok( Terminal( sys::Terminus::stderr()? ) )}

                #[inline] pub fn name( &self ) -> &str { self.0.name() }

                #[inline] pub fn lock_read( &self ) -> LockResult<TerminalReadGuard>
                { map_lock_result( self.0.lock_read(), TerminalReadGuard ) }

                #[inline] pub fn lock_write( &self ) -> LockResult<TerminalWriteGuard>
                { map_lock_result( self.0.lock_write(), TerminalWriteGuard ) }

                #[inline] pub fn try_lock_read( &self ) -> TryLockResult<TerminalReadGuard>
                { map_try_lock_result( self.0.try_lock_read(), TerminalReadGuard ) }

                #[inline] pub fn try_lock_write( &self ) -> TryLockResult<TerminalWriteGuard>
                { map_try_lock_result( self.0.try_lock_write(), TerminalWriteGuard ) }

                pub fn prepare( &self, config: PrepareConfig ) -> io::Result<PrepareState>
                { self.0.prepare( config ).map( PrepareState ) }

                pub fn restore( &self, state: PrepareState ) -> io::Result<()>
                { self.0.restore( state.0 ) }

                pub fn wait_event( &self, timeout:Option<Duration> ) -> io::Result<bool>
                { self.0.wait_event( timeout ) }

                pub fn read_event( &self, timeout:Option<Duration> ) -> io::Result<Option<Event>>
                { self.0.read_event( timeout ) }

                #[inline] pub fn size( &self ) -> io::Result<Size> { self.0.size() }

                pub fn clear_screen( &self ) -> io::Result<()> { self.0.clear_screen() }

                pub fn clear_to_line_end( &self ) -> io::Result<()> { self.0.clear_to_line_end() }

                pub fn clear_to_screen_end( &self ) -> io::Result<()> { self.0.clear_to_screen_end() }

                pub fn move_up( &self, n: usize ) -> io::Result<()> { self.0.move_up( n ) }

                pub fn move_down( &self, n: usize ) -> io::Result<()> { self.0.move_down( n ) }

                pub fn move_left( &self, n: usize ) -> io::Result<()> { self.0.move_left( n ) }

                pub fn move_right( &self, n: usize ) -> io::Result<()> { self.0.move_right( n ) }

                pub fn move_to_first_column( &self ) -> io::Result<()> { self.0.move_to_first_column() }

                pub fn set_cursor_mode( &self, mode: CursorMode ) -> io::Result<()>
                { self.0.set_cursor_mode( mode ) }

                pub fn add_style( &self, style: Style ) -> io::Result<()>
                { self.0.add_style( style ) }

                pub fn remove_style( &self, style: Style ) -> io::Result<()>
                { self.0.remove_style( style ) }

                pub fn set_style<S>( &self, style: S ) -> io::Result<()>  where 
                S:Into<Option<Style>>
                { self.0.set_style( style.into().unwrap_or_default() ) }

                pub fn set_theme( &self, theme: Theme ) -> io::Result<()> { self.0.set_theme( theme ) }

                pub fn set_fg<C: Into<Option<Color>>>( &self, fg: C ) -> io::Result<()>
                { self.0.set_fg( fg.into() ) }

                pub fn set_bg<C: Into<Option<Color>>>( &self, bg: C ) -> io::Result<()>
                { self.0.set_bg( bg.into() ) }

                pub fn clear_attributes( &self ) -> io::Result<()> { self.0.clear_attributes() }

                pub fn bold( &self ) -> io::Result<()> { self.add_style( Style::BOLD ) }

                pub fn italic( &self ) -> io::Result<()> { self.add_style( Style::ITALIC ) }

                pub fn underline( &self ) -> io::Result<()> { self.add_style( Style::UNDERLINE ) }

                pub fn reverse( &self ) -> io::Result<()> { self.add_style( Style::REVERSE ) }

                pub fn write_styled<F,B,S>( &self, fg:F, bg:B, style:S, s:&str ) -> io::Result<()>
                where
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                { self.0.write_styled( fg.into(), bg.into(), style.into().unwrap_or_default(), s ) }

                pub fn write_char( &self, ch:char ) -> io::Result<()> { self.0.write_char( ch ) }

                pub fn write_str( &self, s:&str ) -> io::Result<()> { self.0.write_str( s ) }

                pub fn write_fmt( &self, args: fmt::Arguments ) -> io::Result<()>
                {
                    let s = args.to_string();
                    self.write_str( &s )
                }
                
                pub fn borrow_term_write_guard( &self ) -> TerminalWriteGuard
                { self.lock_write().unwrap() }
            }

            impl<'a> TerminalReadGuard<'a> 
            
            {

                pub fn prepare( &mut self, config: PrepareConfig ) -> io::Result<PrepareState>
                { self.0.prepare( config ).map( PrepareState ) }

                pub fn prepare_with_lock
                ( 
                    &mut self,
                    writer:&mut TerminalWriteGuard,
                    config:PrepareConfig
                ) -> io::Result<PrepareState>
                { self.0.prepare_with_lock( &mut writer.0, config ).map( PrepareState ) }

                pub fn restore( &mut self, state: PrepareState ) -> io::Result<()>
                { self.0.restore( state.0 ) }

                pub fn restore_with_lock
                ( 
                    &mut self,
                    writer:&mut TerminalWriteGuard,
                    state:PrepareState
                ) -> io::Result<()>
                { self.0.restore_with_lock( &mut writer.0, state.0 ) }

                pub fn wait_event( &mut self, timeout:Option<Duration> ) -> io::Result<bool>
                { self.0.wait_event( timeout ) }

                pub fn read_event( &mut self, timeout:Option<Duration> ) -> io::Result<Option<Event>>
                { self.0.read_event( timeout ) }
            }

            impl<'a> TerminalWriteGuard<'a>
            
            {

                pub fn flush( &mut self ) -> io::Result<()> { self.0.flush() }

                #[inline] pub fn size( &self ) -> io::Result<Size> { self.0.size() }

                pub fn clear_screen( &mut self ) -> io::Result<()> { self.0.clear_screen() }

                pub fn clear_to_line_end( &mut self ) -> io::Result<()> { self.0.clear_to_line_end() }

                pub fn clear_to_screen_end( &mut self ) -> io::Result<()>
                { self.0.clear_to_screen_end() }

                pub fn move_up( &mut self, n: usize ) -> io::Result<()> { self.0.move_up( n ) }

                pub fn move_down( &mut self, n: usize ) -> io::Result<()> { self.0.move_down( n ) }

                pub fn move_left( &mut self, n: usize ) -> io::Result<()> { self.0.move_left( n ) }

                pub fn move_right( &mut self, n: usize ) -> io::Result<()> { self.0.move_right( n ) }

                pub fn move_to_first_column( &mut self ) -> io::Result<()>
                { self.0.move_to_first_column() }

                pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()>
                { self.0.set_cursor_mode( mode ) }

                pub fn add_style( &mut self, style: Style ) -> io::Result<()>
                { self.0.add_style( style ) }

                pub fn remove_style( &mut self, style: Style ) -> io::Result<()>
                { self.0.remove_style( style ) }

                pub fn set_style<S>( &mut self, style: S ) -> io::Result<()>  where 
                S:Into<Option<Style>>
                { self.0.set_style( style.into().unwrap_or_default() ) }

                pub fn set_theme( &mut self, theme: Theme ) -> io::Result<()> { self.0.set_theme( theme ) }

                pub fn set_fg<C: Into<Option<Color>>>( &mut self, fg: C ) -> io::Result<()>
                { self.0.set_fg( fg.into() ) }

                pub fn set_bg<C: Into<Option<Color>>>( &mut self, bg: C ) -> io::Result<()>
                { self.0.set_bg( bg.into() ) }

                pub fn clear_attributes( &mut self ) -> io::Result<()> { self.0.clear_attributes() }

                pub fn bold( &mut self ) -> io::Result<()> { self.add_style( Style::BOLD ) }

                pub fn italic( &mut self ) -> io::Result<()> { self.add_style( Style::ITALIC ) }

                pub fn underline( &mut self ) -> io::Result<()> { self.add_style( Style::UNDERLINE ) }

                pub fn reverse( &mut self ) -> io::Result<()> { self.add_style( Style::REVERSE ) }

                pub fn write_styled<F,B,S>( &mut self, fg:F, bg:B, style:S, s:&str ) -> io::Result<()>
                where
                F: Into<Option<Color>>,
                B: Into<Option<Color>>,
                S: Into<Option<Style>>
                { self.0.write_styled( fg.into(), bg.into(), style.into().unwrap_or_default(), s ) }

                pub fn write_char( &mut self, ch:char ) -> io::Result<()> { self.0.write_char( ch ) }

                pub fn write_str( &mut self, s:&str ) -> io::Result<()> { self.0.write_str( s ) }

                pub fn write_fmt( &mut self, args: fmt::Arguments ) -> io::Result<()>
                {
                    let s = args.to_string();
                    self.write_str( &s )
                }
                
                pub fn borrow_term_write_guard( &mut self ) -> &mut Self { self }
            }

            #[cfg( unix )]
            use ::path::Path;

            #[cfg( unix )]
            impl sys::OpenTerminalExt for Terminal
            {
                fn from_path<P: AsRef<Path>>( path: P ) -> io::Result<Self>
                { sys::Terminus::open( path ).map( Terminal ) }
            }

            #[cfg( unix )]
            impl sys::TerminalExt for Terminal
            {
                fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) 
                -> io::Result<Option<Event>>
                { self.0.read_raw( buf, timeout ) }
            }

            #[cfg( unix )]
            impl<'a> sys::TerminalExt for TerminalReadGuard<'a>
            {
                fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) 
                -> io::Result<Option<Event>>
                { self.0.read_raw( buf, timeout ) }
            }
            /*
            #[cfg( windows )]
            impl crate::windows::TerminalExt for Terminal {
                fn read_raw( &mut self, buf:&mut [u16], timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.0.read_raw( buf, timeout ) }

                fn read_raw_event( &mut self, events:&mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.0.read_raw_event( events, timeout ) }
            }

            #[cfg( windows )]
            impl<'a> crate::windows::TerminalExt for TerminalReadGuard<'a> {
                fn read_raw( &mut self, buf:&mut [u16], timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.0.read_raw( buf, timeout ) }

                fn read_raw_event( &mut self, events:&mut [::winapi::um::wincon::INPUT_RECORD],
                        timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.0.read_raw_event( events, timeout ) }
            } */
        } pub use self::terminal::
        {
            Color, Cursor, CursorMode, Size, Style, Theme, Event, Key, MouseEvent, MouseInput, 
            MouseButton, ModifierState, PrepareConfig, PrepareState, Terminal, TerminalReadGuard, 
            TerminalWriteGuard,
        };

        pub mod unix
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            mod ext
            {
                /*!
                */
                use ::
                {
                    path::{ Path },
                    system::common::{ Event },
                    time::std::{ Duration },
                    *,
                };
                /*
                */

                pub trait OpenTerminalExt:Sized
                {

                    fn from_path<P:AsRef<Path>>( path:P ) -> io::Result<Self>;
                }

                pub trait TerminalExt
                {

                    fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) -> io::Result<Option<Event>>;
                }
            } pub use self::ext::{ * };

            mod path
            {
                /*!
                */
                use ::
                {
                    path::{ PathBuf },
                    *,
                };
                /*
                */
                pub fn env_init_file() -> Option<PathBuf>
                {
                    // var_os( "INPUTRC" ).map( PathBuf::from )
                    None
                }

                pub fn system_init_file() -> Option<PathBuf> 
                {
                    // Some( PathBuf::from( "/etc/inputrc" ) )
                    None
                }

                pub fn user_init_file() -> Option<PathBuf>
                { 
                    // home_dir().map( |p| p.join( ".inputrc" ) )
                    None
                }
            } pub use self::path::{ * };

            mod screen
            {
                /*!
                */
                use ::
                {
                    map::{ map_lock_result, map_try_lock_result, map2_lock_result, map2_try_lock_result },
                    sync::{ LockResult, Mutex, MutexGuard, TryLockResult },
                    system::
                    {
                        common::
                        {
                            buffer::{ ScreenBuffer },
                            terminal::{ Color, Cursor, CursorMode, Event, Size, Style, PrepareConfig }
                        },
                    },
                    time::std::{ Duration },
                    *,
                };
                use super::{ Terminus, TerminalReadGuard, TerminalWriteGuard, PrepareState };
                /*
                use crate::buffer::ScreenBuffer;
                use crate::sys::{Terminal, TerminalReadGuard, TerminalWriteGuard, PrepareState};
                use crate::terminal::{Color, Cursor, CursorMode, Event, Size, Style, PrepareConfig};
                */
                pub struct Screen
                {
                    term: Terminus,
                    state:Option<PrepareState>,
                    writer: Mutex<Writer>,
                }

                pub struct ScreenReadGuard<'a> 
                {
                    screen:&'a Screen,
                    reader: TerminalReadGuard<'a>,
                }

                pub struct ScreenWriteGuard<'a> 
                {
                    writer: TerminalWriteGuard<'a>,
                    data: MutexGuard<'a, Writer>,
                }

                struct Writer 
                {
                    buffer: ScreenBuffer,
                    clear_screen: bool,
                    real_cursor: Cursor,
                }

                impl Screen                
                {
                    pub fn new( term: Terminus, config: PrepareConfig ) -> io::Result<Screen> 
                    {
                        let size = term.size()?;
                        let state = term.prepare( config )?;

                        let screen = Screen
                        {
                            term: term,
                            state: Some( state ),
                            writer: Mutex::new( Writer
                            {
                                buffer: ScreenBuffer::new( size ),
                                clear_screen: false,
                                real_cursor: Cursor::default(),
                            } ),
                        };

                        screen.term.enter_screen()?;
                        Ok( screen )
                    }

                    pub fn stdout( config: PrepareConfig ) -> io::Result<Screen>
                    { Screen::new( Terminus::stdout()?, config ) }

                    pub fn stderr( config: PrepareConfig ) -> io::Result<Screen>
                    { Screen::new( Terminus::stderr()?, config ) }

                    forward_screen_buffer_methods!{ |slf| slf.lock_write_data().buffer }

                    pub fn lock_read( &self ) -> LockResult<ScreenReadGuard>
                    {
                        map_lock_result( self.term.lock_read(),
                        |r| ScreenReadGuard::new( self, r ) )
                    }

                    pub fn try_lock_read( &self ) -> TryLockResult<ScreenReadGuard>
                    {
                        map_try_lock_result( self.term.try_lock_read(),
                        |r| ScreenReadGuard::new( self, r ) )
                    }

                    pub fn lock_write( &self ) -> LockResult<ScreenWriteGuard>
                    {
                        map2_lock_result( self.term.lock_write(), self.writer.lock(),
                        |a, b| ScreenWriteGuard::new( a, b ) )
                    }

                    pub fn try_lock_write( &self ) -> TryLockResult<ScreenWriteGuard>
                    {
                        map2_try_lock_result( self.term.try_lock_write(), self.writer.try_lock(),
                        |a, b| ScreenWriteGuard::new( a, b ) )
                    }
                    
                    pub fn name( &self ) -> &str { self.term.name() }
                    
                    pub fn set_cursor_mode( &self, mode: CursorMode ) -> io::Result<()> { self.term.set_cursor_mode( mode ) }
                    
                    pub fn wait_event( &self, timeout:Option<Duration> ) -> io::Result<bool> { self.lock_reader().wait_event( timeout ) }
                    
                    pub fn read_event( &self, timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.lock_reader().read_event( timeout ) }
                    
                    pub fn read_raw( &self, buf:&mut [u8], timeout:Option<Duration> ) -> io::Result<Option<Event>> { self.lock_reader().read_raw( buf, timeout ) }
                    
                    pub fn refresh( &self ) -> io::Result<()> { self.lock_writer().refresh() }

                    fn lock_reader( &self ) -> ScreenReadGuard { self.lock_read().expect( "Screen::lock_reader" ) }
                    fn lock_writer( &self ) -> ScreenWriteGuard { self.lock_write().expect( "Screen::lock_writer" ) }
                    fn lock_write_data( &self ) -> MutexGuard<Writer> { self.writer.lock().expect( "Screen::lock_write_data" ) }
                }

                impl Drop for Screen               
                {
                    fn drop( &mut self )
                    {
                        let res = if let Some( state ) = self.state.take() { self.term.restore( state ) }
                        else { Ok( () ) };

                        if let Err( e ) = res.and_then( |_| self.term.exit_screen() ) { eprintln!( "failed to restore terminal: {}", e ); }
                    }
                }

                impl<'a> ScreenReadGuard<'a>
                {
                    fn new( screen:&'a Screen, reader: TerminalReadGuard<'a> ) -> ScreenReadGuard<'a>
                    { ScreenReadGuard{screen, reader} }

                    pub fn wait_event( &mut self, timeout:Option<Duration> ) -> io::Result<bool>
                    { self.reader.wait_event( timeout ) }

                    pub fn read_event( &mut self, timeout:Option<Duration> ) -> io::Result<Option<Event>> 
                    {
                        let r = self.reader.read_event( timeout )?;

                        if let Some( Event::Resize( size ) ) = r { self.screen.lock_write_data().update_size( size ); }

                        Ok( r )
                    }

                    pub fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        let r = self.reader.read_raw( buf, timeout )?;

                        if let Some( Event::Resize( size ) ) = r { self.screen.lock_write_data().update_size( size ); }

                        Ok( r )
                    }
                }

                impl<'a> ScreenWriteGuard<'a>
                {
                    fn new( writer:TerminalWriteGuard<'a>, data:MutexGuard<'a, Writer> ) -> ScreenWriteGuard<'a>
                    { ScreenWriteGuard{writer, data} }

                    forward_screen_buffer_mut_methods!{ |slf| slf.data.buffer }

                    pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()>
                    { self.writer.set_cursor_mode( mode ) }

                    pub fn refresh( &mut self ) -> io::Result<()>
                    {
                        if self.data.clear_screen
                        {
                            self.writer.clear_screen()?;
                            self.data.clear_screen = false;
                        }

                        self.writer.clear_attributes()?;

                        let mut indices = self.data.buffer.indices();

                        while let Some( ( pos, cell ) ) = self.data.buffer.next_cell( &mut indices )
                        {
                            self.move_cursor( pos )?;
                            self.apply_attrs( cell.attrs() )?;
                            self.writer.write_str( cell.text() )?;
                            self.data.real_cursor.column += 1;
                        }

                        self.writer.clear_attributes()?;                        
                        let size = self.data.buffer.size();
                        let pos = self.data.buffer.cursor();

                        if pos.is_out_of_bounds( size ) { self.move_cursor( Cursor::last( size ) )?; }

                        else { self.move_cursor( pos )?; }

                        self.writer.flush()
                    }

                    fn move_cursor( &mut self, pos:Cursor ) -> io::Result<()>
                    {
                        if self.data.real_cursor != pos
                        {
                            self.writer.move_cursor( pos )?;
                            self.data.real_cursor = pos;
                        }

                        Ok( () )
                    }

                    fn apply_attrs( &mut self, ( fg, bg, style ):( Option<Color>, Option<Color>, Style ) )
                    -> io::Result<()>
                    { self.writer.set_attrs( fg, bg, style ) }
                }

                impl<'a> Drop for ScreenWriteGuard<'a>
                {
                    fn drop( &mut self )
                    {
                        if let Err( e ) = self.refresh() { eprintln!( "Failed to refresh screen: {}", e ); }
                    }
                }

                impl Writer
                {
                    fn update_size( &mut self, new_size:Size )
                    {
                        if self.real_cursor.is_out_of_bounds( new_size )
                        { self.real_cursor = ( !0, !0 ).into(); }

                        self.buffer.resize( new_size  );
                        self.clear_screen = true;
                    }
                }
            } pub use self::screen::{ * };

            mod terminal
            {
                /*!
                */
                use system::api::selects;
                use ::
                {
                    convert::{ TryFrom },
                    fs::{ File },
                    map::{ map_lock_result, map_try_lock_result },
                    mem::{ replace, zeroed },
                    libc::
                    { 
                        ioctl, c_int, c_ushort, termios, STDIN_FILENO, STDOUT_FILENO, 
                        STDERR_FILENO, TIOCGWINSZ
                    },                    
                    os::
                    { 
                        fd::{ AsFd, AsRawFd },
                        unix::io::{ FromRawFd, IntoRawFd, RawFd }
                    },
                    path::{ Path },
                    str::{ from_utf8, SmallString },
                    sync::{ atomic::{ AtomicUsize, Ordering }, LockResult, Mutex, MutexGuard, TryLockResult },
                    system::
                    {
                        api::
                        {
                            self, AsynchronousTerminalInterface, Errno, select, FdSet, react, sigaction, SaFlags, 
                            SigAction, SigHandler, Signal as NixSignal, SigSet, SetArg, InputFlags, LocalFlags,
                            tcsetattraw, Termios, TimeVal, TimeValLike, read, VMIN, VTIME, write
                        },
                        common::
                        {
                            signal::{ Signal, SignalSet },
                            terminal::
                            {
                                Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme,
                                MouseButton, MouseEvent, MouseInput, ModifierState
                            }
                        },
                        terminal::{ RawRead },
                    },
                    time::std::{ Duration },
                    *,
                };
                /*

                use mortal::{Event, TerminalReadGuard};
                use mortal::unix::TerminalExt;

                use crate::terminal::RawRead;
                use crate::sequence::{FindResult, SequenceMap};
                use crate::util::prefixes;
                
                use smallstr::SmallString;

                use terminfo::{self, capability as cap, Database};
                use terminfo::capability::Expansion;
                use terminfo::expand::Context;

                use crate::priv_util::{map_lock_result, map_try_lock_result};
                use crate::sequence::{FindResult, SequenceMap};
                use crate::signal::{Signal, SignalSet};
                use crate::terminal::{
                    Color, Cursor, CursorMode, Event, Key, PrepareConfig, Size, Style, Theme,
                    MouseButton, MouseEvent, MouseInput, ModifierState,
                };
                use crate::util::prefixes;
                */

                macro_rules! expand_opt
                {
                    ( $slf:expr , $cap:path ) => 
                    { {
                        if let Some( cap ) = $slf.term.info.get::<$cap>() {
                            $slf.expand( cap.expand() )
                        } else {
                            Ok( () )
                        }
                    } };

                    ( $slf:expr , $cap:path , |$ex:ident| $expansion:expr ) => 
                    { {
                        if let Some( cap ) = $slf.term.info.get::<$cap>() {
                            let $ex = cap.expand();
                            $slf.expand( $expansion )
                        } else {
                            Ok( () )
                        }
                    } }
                }

                macro_rules! expand_req 
                {
                    ( $slf:expr , $cap:path , $name:expr ) => 
                    { {
                        $slf.term.info.get::<$cap>()
                            .ok_or_else( || not_supported( $name ) )
                            .and_then( |cap| $slf.expand( cap.expand() ) )
                    } };

                    ( $slf:expr , $cap:path , $name:expr , |$ex:ident| $expansion:expr ) => { {
                        $slf.term.info.get::<$cap>()
                            .ok_or_else( || not_supported( $name ) )
                            .and_then( |cap| {
                                let $ex = cap.expand();
                                $slf.expand( $expansion )
                            } )
                    } }
                }
                
                const OUT_BUFFER_SIZE: usize = 8192;
                const XTERM_ENABLE_MOUSE:&str = "\x1b[?1006h\x1b[?1002h";
                const XTERM_DISABLE_MOUSE:&str = "\x1b[?1006l\x1b[?1002l";
                const XTERM_ENABLE_MOUSE_MOTION:&str = "\x1b[?1003h";
                const XTERM_DISABLE_MOUSE_MOTION:&str = "\x1b[?1003l";
                const XTERM_MOUSE_INTRO:&str = "\x1b[<";
                const XTERM_SHIFT_MASK: u32 = 0x04;
                const XTERM_META_MASK: u32  = 0x08;
                const XTERM_CTRL_MASK: u32  = 0x10;
                const XTERM_MODIFIER_MASK: u32 = XTERM_SHIFT_MASK | XTERM_META_MASK | XTERM_CTRL_MASK;

                pub fn terminal_read( term:&mut TerminalReadGuard, buf:&mut Vec<u8> ) -> io::Result<RawRead>
                {
                    let mut buffer = [0; 1024];

                    match term.read_raw( &mut buffer, Some( Duration::new( 0, 0 ) ) )?
                    {
                        None => Ok( RawRead::Bytes( 0 ) ),
                        Some( Event::Raw( n ) ) =>
                        {
                            buf.extend( &buffer[..n] );
                            Ok( RawRead::Bytes( n ) )
                        }
                        Some( Event::Resize( size ) ) => Ok( RawRead::Resize( size ) ),
                        Some( Event::Signal( sig ) ) => Ok( RawRead::Signal( sig ) ),
                        _ => unreachable!()
                    }
                }

                //type SeqMap = SequenceMap<SmallString<[u8; 8]>, SeqData>;

                #[derive( Copy, Clone )]
                enum SeqData 
                {
                    XTermMouse,
                    Key( Key ),
                }

                pub struct Terminus
                {
                    //info: Database,
                    out_fd: RawFd,
                    in_fd: RawFd,
                    owned_fd: bool,
                    // sequences: SeqMap,
                    reader: Mutex<Reader>,
                    writer: Mutex<Writer>,
                }

                pub struct TerminalReadGuard<'a> 
                {
                    term:&'a Terminus,
                    reader: MutexGuard<'a, Reader>,
                }

                pub struct TerminalWriteGuard<'a> 
                {
                    term:&'a Terminus,
                    writer: MutexGuard<'a, Writer>,
                }

                struct Reader
                {
                    in_buffer: Vec<u8>,
                    resume:Option<Resume>,
                    report_signals: SignalSet,
                }

                struct Writer
                {
                    //context: Context,
                    out_buffer: Vec<u8>,
                    fg:Option<Color>,
                    bg:Option<Color>,
                    cur_style: Style,
                }

                impl Terminus 
                {
                    fn new( in_fd: RawFd, out_fd: RawFd, owned_fd: bool ) -> io::Result<Terminus>
                    {
                        //let info = Database::from_env().map_err( ti_to_io )?;
                        //let sequences = sequences( &info );

                        Ok
                        ( 
                            Terminus
                            {
                                //info,
                                in_fd,
                                out_fd,
                                owned_fd,
                                //sequences,
                                reader: Mutex::new( Reader{
                                    in_buffer: Vec::new(),
                                    resume: None,
                                    report_signals: SignalSet::new(),
                                } ),
                                writer: Mutex::new( Writer::new() ),
                            }
                        )
                    }

                    pub fn open<P: AsRef<Path>>( path: P ) -> io::Result<Terminus> 
                    {
                        let fd = open_rw( path )?;
                        let r = Terminus::new( fd, fd, true );

                        if r.is_err() { unsafe { close_fd( fd ); } }

                        r
                    }

                    pub fn stdout() -> io::Result<Terminus> { Terminus::new( STDIN_FILENO, STDOUT_FILENO, false ) }

                    pub fn stderr() -> io::Result<Terminus> { Terminus::new( STDIN_FILENO, STDERR_FILENO, false ) }

                    pub fn name( &self ) -> &str 
                    { 
                        //self.info.name()
                        ""                        
                    }

                    fn is_xterm( &self ) -> bool { is::xterm( self.name() ) }

                    pub fn size( &self ) -> io::Result<Size> { self.lock_writer().size() }

                    pub fn wait_event( &self, timeout:Option<Duration> ) -> io::Result<bool>
                    { self.lock_reader().wait_event( timeout ) }

                    pub fn read_event( &self, timeout:Option<Duration> ) -> io::Result<Option<Event>>
                    { self.lock_reader().read_event( timeout ) }

                    pub fn read_raw( &self, buf:&mut [u8], timeout:Option<Duration> ) -> io::Result<Option<Event>>
                    { self.lock_reader().read_raw( buf, timeout ) }

                    pub fn enter_screen( &self ) -> io::Result<()>
                    { self.lock_writer().enter_screen() }

                    pub fn exit_screen( &self ) -> io::Result<()> { self.lock_writer().exit_screen() }

                    pub fn prepare( &self, config: PrepareConfig ) -> io::Result<PrepareState>
                    { self.lock_reader().prepare( config ) }

                    pub fn restore( &self, state: PrepareState ) -> io::Result<()>
                    { self.lock_reader().restore( state ) }

                    pub fn clear_screen( &self ) -> io::Result<()>
                    { self.lock_writer().clear_screen() }

                    pub fn clear_to_line_end( &self ) -> io::Result<()>
                    { self.lock_writer().clear_to_line_end() }

                    pub fn clear_to_screen_end( &self ) -> io::Result<()>
                    { self.lock_writer().clear_to_screen_end() }

                    pub fn move_up( &self, n: usize ) -> io::Result<()>
                    {
                        if n != 0 { self.lock_writer().move_up( n )?; }
                        Ok( () )
                    }

                    pub fn move_down( &self, n: usize ) -> io::Result<()>
                    {
                        if n != 0 { self.lock_writer().move_down( n )?; }
                        Ok( () )
                    }

                    pub fn move_left( &self, n: usize ) -> io::Result<()>
                    {
                        if n != 0 { self.lock_writer().move_left( n )?; }
                        Ok( () )
                    }

                    pub fn move_right( &self, n: usize ) -> io::Result<()>
                    {
                        if n != 0 { self.lock_writer().move_right( n )?; }
                        Ok( () )
                    }

                    pub fn move_to_first_column( &self ) -> io::Result<()>
                    { self.lock_writer().move_to_first_column() }

                    pub fn set_cursor_mode( &self, mode: CursorMode ) -> io::Result<()>
                    { self.lock_writer().set_cursor_mode( mode ) }

                    pub fn write_char( &self, ch:char ) -> io::Result<()>
                    { self.write_str( ch.encode_utf8( &mut [0; 4] ) ) }

                    pub fn write_str( &self, s:&str ) -> io::Result<()> { self.lock_writer().write_str( s ) }

                    pub fn write_styled( &self, fg:Option<Color>, bg:Option<Color>, style:Style, text:&str ) 
                    -> io::Result<()>
                    { self.lock_writer().write_styled( fg, bg, style, text ) }

                    pub fn clear_attributes( &self ) -> io::Result<()> { self.lock_writer().clear_attributes() }

                    pub fn set_fg( &self, fg:Option<Color> ) -> io::Result<()> { self.lock_writer().set_fg( fg ) }
                    
                    pub fn set_bg( &self, bg:Option<Color> ) -> io::Result<()> { self.lock_writer().set_bg( bg ) }
                    
                    pub fn add_style( &self, style: Style ) -> io::Result<()> { self.lock_writer().add_style( style ) }
                    
                    pub fn remove_style( &self, style: Style ) -> io::Result<()> { self.lock_writer().remove_style( style ) }
                    
                    pub fn set_style( &self, style: Style ) -> io::Result<()> { self.lock_writer().set_style( style ) }
                    
                    pub fn set_theme( &self, theme: Theme ) -> io::Result<()> { self.lock_writer().set_theme( theme ) }
                    
                    pub fn lock_read( &self ) -> LockResult<TerminalReadGuard>
                    {
                        map_lock_result( self.reader.lock(), |r| TerminalReadGuard::new( self, r ) )
                    }

                    pub fn lock_write( &self ) -> LockResult<TerminalWriteGuard>
                    {
                        map_lock_result( self.writer.lock(), |w| TerminalWriteGuard::new( self, w ) )
                    }

                    pub fn try_lock_read( &self ) -> TryLockResult<TerminalReadGuard>
                    {
                        map_try_lock_result( self.reader.try_lock(), |r| TerminalReadGuard::new( self, r ) )
                    }

                    pub fn try_lock_write( &self ) -> TryLockResult<TerminalWriteGuard>
                    {
                        map_try_lock_result( self.writer.try_lock(), |w| TerminalWriteGuard::new( self, w ) )
                    }

                    fn lock_reader( &self ) -> TerminalReadGuard { self.lock_read().expect( "Terminal::lock_reader" ) }

                    fn lock_writer( &self ) -> TerminalWriteGuard { self.lock_write().expect( "Terminal::lock_writer" ) }
                }

                impl Drop for Terminus
                {
                    fn drop( &mut self ) {
                        if let Err( e ) = self.set_cursor_mode( CursorMode::Normal ) {
                            eprintln!( "failed to restore terminus: {}", e );
                        }

                        if self.owned_fd {
                            unsafe { close_fd( self.out_fd ); }
                        }
                    }
                }

                impl<'a> TerminalReadGuard<'a>
                {
                    fn new( term:&'a Terminus, reader: MutexGuard<'a, Reader> ) -> TerminalReadGuard<'a>
                    { TerminalReadGuard{term, reader} }

                    pub fn prepare( &mut self, config: PrepareConfig ) -> io::Result<PrepareState>
                    {
                        let mut writer = self.term.lock_writer();
                        self.prepare_with_lock( &mut writer, config )
                    }

                    pub fn prepare_with_lock( &mut self, w:&mut TerminalWriteGuard, c:PrepareConfig )
                    -> io::Result<PrepareState>
                    {
                        unsafe
                        {
                            use ::system::api::SpecialCharacterIndices::{ * };

                            let tiold =  ::system::api::tcgetattraw( self.term.in_fd ).map_err( nix_to_io )?;
                            let mut tio = tiold.clone();
                            
                            let mut state = PrepareState
                            {
                                old_tio: Some
                                ( 
                                    ::mem::transmute::<AsynchronousTerminalInterface, termios>( tiold.into() )
                                ),
                                old_sigcont: None,
                                old_sigint: None,
                                old_sigtstp: None,
                                old_sigquit: None,
                                old_sigwinch: None,
                                restore_keypad: false,
                                restore_mouse: false,
                                prev_resume: self.reader.resume,
                            };

                            tio.input_flags.remove( InputFlags::INLCR  | InputFlags::ICRNL  );
                            tio.local_flags.remove( LocalFlags::ICANON | LocalFlags::ECHO   );
                        
                            if c.block_signals { tio.local_flags.remove( LocalFlags::ISIG  ); }
                            else { tio.local_flags.insert( LocalFlags::ISIG  ); }
                            
                            if c.enable_control_flow { tio.input_flags.insert( InputFlags::IXON  ); }
                            else { tio.input_flags.remove( InputFlags::IXON  ); }
                            
                            tio.control_chars[VMIN as usize] = 0;
                            tio.control_chars[VTIME as usize] = 0;

                            tcsetattraw( ::mem::transmute( self.term.in_fd ), SetArg::TCSANOW, &tio ).map_err( nix_to_io )?;

                            if c.enable_keypad { if w.enable_keypad()? { state.restore_keypad = true; } }

                            w.flush()?;

                            let action = SigAction::new( SigHandler::Handler( handle_signal ), SaFlags::empty(), SigSet::all()  );
                                
                            state.old_sigcont = Some( react( NixSignal::SIGCONT, &action ).map_err( nix_to_io )?  );
                            state.old_sigwinch = Some( react( NixSignal::SIGWINCH, &action ).map_err( nix_to_io )?  );

                            if c.report_signals.contains( Signal::Interrupt )
                            { state.old_sigint = Some( react( NixSignal::SIGINT, &action ).map_err( nix_to_io )?  ); }

                            if c.report_signals.contains( Signal::Suspend )
                            { state.old_sigtstp = Some( react( NixSignal::SIGTSTP, &action ).map_err( nix_to_io )?  ); }

                            if c.report_signals.contains( Signal::Quit )
                            { state.old_sigquit = Some( react( NixSignal::SIGQUIT, &action ).map_err( nix_to_io )?  ); }

                            self.reader.report_signals = c.report_signals;
                            self.reader.resume = Some( Resume{ config:c }  );
                            Ok( state )
                        }
                    }

                    pub fn restore( &mut self, state: PrepareState ) -> io::Result<()>
                    {
                        let mut writer = self.term.lock_writer();
                        self.restore_with_lock( &mut writer, state )
                    }

                    pub fn restore_with_lock( &mut self, w:&mut TerminalWriteGuard, s:PrepareState ) -> io::Result<()>
                    {
                        unsafe
                        {
                            self.reader.resume = s.prev_resume;

                            if s.restore_mouse { w.disable_mouse()?; }

                            if s.restore_keypad { w.disable_keypad()?; }

                            w.flush()?;

                            tcsetattraw
                            ( 
                                self.term.in_fd,
                                SetArg::TCSANOW,
                                ::mem::transmute::<&Option<termios>, &Termios>( &s.old_tio )
                            ).map_err( nix_to_io )?;
                            
                            if let Some( ref old ) = s.old_sigcont
                            { react( NixSignal::SIGCONT, old ).map_err( nix_to_io )?; }

                            if let Some( ref old ) = s.old_sigint
                            { react( NixSignal::SIGINT, old ).map_err( nix_to_io )?; }

                            if let Some( ref old ) = s.old_sigtstp
                            { react( NixSignal::SIGTSTP, old ).map_err( nix_to_io )?; }
                            
                            if let Some( ref old ) = s.old_sigquit
                            { react( NixSignal::SIGQUIT, old ).map_err( nix_to_io )?; }

                            if let Some( ref old ) = s.old_sigwinch
                            { react( NixSignal::SIGWINCH, old ).map_err( nix_to_io )?; }
                            
                            Ok( () )
                        }
                    }

                    pub fn wait_event( &mut self, t:Option<Duration> ) -> io::Result<bool>
                    {

                        if get_signal().is_some() { return Ok( true  ); }
                        let mut t = t.map( to_timeval  );
                        
                        let n = loop
                        {
                            let in_fd = self.term.in_fd;

                            let mut r_fds = FdSet::new();
                            r_fds.insert( in_fd );
                            
                            let mut e_fds = FdSet::new();
                            e_fds.insert( in_fd );

                            match selects( in_fd + 1, Some( &mut r_fds ), None, Some( &mut e_fds ), t.as_mut() )
                            {
                                Ok( n ) => break n,
                                Err( Errno::EINTR ) =>
                                {
                                    if get_signal().is_some() { return Ok( true ); }
                                }
                                Err( e ) => return Err( nix_to_io( e ) )
                            }
                        };

                        Ok( n != 0 )
                        /*
                        if get_signal().is_some() { return Ok( true ); }

                        if peek_event( &self.reader.in_buffer, &self.term.sequences )?.is_some() { return Ok( true ); }

                        let mut timeout = timeout.map( to_timeval );

                        let n = loop
                        {
                            let in_fd = self.term.in_fd;

                            let mut r_fds = FdSet::new();
                            r_fds.insert( in_fd );
                            
                            let mut e_fds = FdSet::new();
                            e_fds.insert( in_fd );

                            match selects( in_fd + 1,
                                    Some( &mut r_fds ), None, Some( &mut e_fds ), timeout.as_mut() ) {
                                Ok( n ) => break n,
                                Err( Errno::EINTR ) =>
                                    if get_signal().is_some() {
                                        return Ok( true );
                                    }
                                
                                Err( e ) => return Err( nix_to_io( e ) )
                            }
                        };

                        Ok( n != 0 ) */
                    }

                    pub fn read_event( &mut self, timeout:Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        if let Some( ev ) = self.try_read()? { return Ok( Some( ev ) ); }

                        match self.read_into_buffer( timeout )?
                        {
                            Some( Event::Raw( _ ) ) => self.try_read(),
                            Some( Event::Signal( sig ) ) =>
                            {
                                if let Some( ev ) = self.handle_signal( sig )? {
                                    Ok( Some( ev ) )
                                } else {
                                    Ok( None )
                                }
                            }
                            r => Ok( r )
                        }
                    }

                    pub fn read_raw( &mut self, buf:&mut [u8], timeout:Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        if !self.reader.in_buffer.is_empty()
                        {
                            let n = buf.len().min( self.reader.in_buffer.len() );
                            buf[..n].copy_from_slice( &self.reader.in_buffer[..n] );

                            let _ = self.reader.in_buffer.drain( ..n );

                            return Ok( Some( Event::Raw( n ) ) );
                        }

                        match self.read_input( buf, timeout )?
                        {
                            Some( Event::Signal( sig ) ) => {
                                if let Some( event ) = self.handle_signal( sig )? {
                                    Ok( Some( event ) )
                                } else {
                                    Ok( None )
                                }
                            }
                            r => Ok( r )
                        }
                    }

                    fn read_into_buffer( &mut self, timeout:Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        let mut buf = replace( &mut self.reader.in_buffer, Vec::new() );

                        buf.reserve( 128 );

                        let len = buf.len();
                        let cap = buf.capacity();
                        let r;

                        unsafe {
                            buf.set_len( cap );

                            r = self.read_input( &mut buf[len..], timeout );

                            match r {
                                Ok( Some( Event::Raw( n ) ) ) => buf.set_len( len + n ),
                                _ => buf.set_len( len )
                            }
                        }
                        
                        self.reader.in_buffer = buf;
                        r
                    }

                    fn read_input( &mut self, buf:&mut [u8], timeout:Option<Duration> ) -> io::Result<Option<Event>>
                    {
                        if let Some( sig ) = take_signal()
                        { return Ok( Some( Event::Signal( sig ) )  ); }

                        if !self.wait_event( timeout )? { return Ok( None  ); }
                        
                        if let Some( sig ) = take_signal() {
                            return Ok( Some( Event::Signal( sig ) ) );
                        }

                        loop {
                            match read( self.term.in_fd, buf ) {
                                Ok( n ) => break Ok( Some( Event::Raw( n ) ) ),
                                Err( Errno::EINTR ) => {
                                    if let Some( sig ) = take_signal() {
                                        return Ok( Some( Event::Signal( sig ) ) );
                                    }
                                }
                                Err( e ) => return Err( nix_to_io( e ) )
                            }
                        }
                    }

                    fn try_read( &mut self ) -> io::Result<Option<Event>>
                    {
                        Ok( None )
                        /*
                        let in_buffer = &mut self.reader.in_buffer;

                        if in_buffer.is_empty() {
                            Ok( None )
                        } else {
                            match peek_event( &in_buffer, &self.term.sequences ) {
                                Ok( Some( ( ev, n ) ) ) => {
                                    let _ = in_buffer.drain( ..n );
                                    Ok( Some( ev ) )
                                }
                                Ok( None ) => Ok( None ),
                                Err( e ) => Err( e )
                            }
                        } */
                    }

                    fn handle_signal( &mut self, sig: Signal ) -> io::Result<Option<Event>>
                    {
                        match sig {
                            Signal::Continue => { self.resume()?; }
                            Signal::Resize => {
                                let size = self.term.size()?;
                                return Ok( Some( Event::Resize( size ) ) );
                            }
                            _ => ()
                        }

                        if self.reader.report_signals.contains( sig ) {
                            Ok( Some( Event::Signal( sig ) ) )
                        } else {
                            Ok( None )
                        }
                    }

                    fn resume( &mut self ) -> io::Result<()>
                    {
                        if let Some( resume ) = self.reader.resume {
                            let _ = self.prepare( resume.config )?;
                        }
                        Ok( () )
                    }
                }

                impl<'a> TerminalWriteGuard<'a> 
               
                {
                    fn new( term:&'a Terminus, writer: MutexGuard<'a, Writer> ) -> TerminalWriteGuard<'a> 
                    {
                        TerminalWriteGuard{term, writer}
                    }

                    pub fn size( &self ) -> io::Result<Size> 
                    {
                        get_winsize( self.term.out_fd )
                    }

                    fn disable_keypad( &mut self ) -> io::Result<()> 
                    {
                        /*
                        if let Some( local ) = self.term.info.get::<cap::KeypadLocal>() {
                            self.expand( local.expand() )?;
                        } */
                        Ok( () )
                    }

                    fn enable_keypad( &mut self ) -> io::Result<bool> 
                    {
                        /*
                        if let Some( xmit ) = self.term.info.get::<cap::KeypadXmit>() {
                            self.expand( xmit.expand() )?;
                            Ok( true )
                        } else {
                            Ok( false )
                        } */
                        Ok( true )
                    }

                    fn disable_mouse( &mut self ) -> io::Result<()> 
                    {
                        self.write_bytes( XTERM_DISABLE_MOUSE.as_bytes() )?;
                        self.write_bytes( XTERM_DISABLE_MOUSE_MOTION.as_bytes() )
                    }

                    fn enable_mouse( &mut self, track_motion: bool ) -> io::Result<bool> 
                    {
                        if self.term.is_xterm() {
                            self.write_bytes( XTERM_ENABLE_MOUSE.as_bytes() )?;
                            if track_motion {
                                self.write_bytes( XTERM_ENABLE_MOUSE_MOTION.as_bytes() )?;
                            }
                            Ok( true )
                        } else {
                            Ok( false )
                        }
                    }

                    fn enter_screen( &mut self ) -> io::Result<()> 
                    {
                        /*
                        match ( self.term.info.get::<cap::EnterCaMode>(),
                                self.term.info.get::<cap::ChangeScrollRegion>(),
                                self.term.info.get::<cap::CursorHome>() ) {
                            ( enter, Some( scroll ), Some( home ) ) => {
                                let size = self.size()?;

                                if let Some( enter ) = enter {
                                    self.expand( enter.expand() )?;
                                }

                                self.expand( scroll.expand()
                                    .parameters( 0, to_u32( size.lines - 1 ) ) )?;
                                self.expand( home.expand() )?;
                            }
                            ( _, None, _ ) => return Err( not_supported( "change_scroll_region" ) ),
                            ( _, _, None ) => return Err( not_supported( "cursor_home" ) ),
                        }

                        self.clear_attributes()?;
                        self.clear_screen()?; */
                        Ok( () )
                    }

                    fn exit_screen( &mut self ) -> io::Result<()> 
                    {
                        /*
                        if let Some( exit ) = self.term.info.get::<cap::ExitCaMode>() {
                            self.expand( exit.expand() )?;
                            self.flush()?;
                        } */
                        Ok( () )
                    }

                    pub fn clear_attributes( &mut self ) -> io::Result<()> 
                    {
                        /*
                        if self.writer.fg.is_some() || self.writer.bg.is_some() ||
                                !self.writer.cur_style.is_empty() {
                            self.writer.fg = None;
                            self.writer.bg = None;
                            self.writer.cur_style = Style::empty();
                            expand_opt!( self, cap::ExitAttributeMode )?;
                        } */

                        Ok( () )
                    }

                    pub fn set_fg( &mut self, fg:Option<Color> ) -> io::Result<()> 
                    {
                        if self.writer.fg == fg {
                            Ok( () )
                        } else {
                            if let Some( fg ) = fg {
                                self.set_fg_color( fg )?;
                            } else {
                                self.clear_fg()?;
                            }

                            self.writer.fg = fg;
                            Ok( () )
                        }
                    }

                    pub fn set_bg( &mut self, bg:Option<Color> ) -> io::Result<()> 
                    {
                        if self.writer.bg == bg {
                            Ok( () )
                        } else {
                            if let Some( bg ) = bg {
                                self.set_bg_color( bg )?;
                            } else {
                                self.clear_bg()?;
                            }

                            self.writer.bg = bg;
                            Ok( () )
                        }
                    }

                    pub fn add_style( &mut self, style: Style ) -> io::Result<()> 
                    {
                        let add = style - self.writer.cur_style;
                        /*
                        let add = style - self.writer.cur_style;

                        if add.contains( Style::BOLD ) {
                            expand_opt!( self, cap::EnterBoldMode )?;
                        }
                        if add.contains( Style::ITALIC ) {
                            expand_opt!( self, cap::EnterItalicsMode )?;
                        }
                        if add.contains( Style::REVERSE ) {
                            expand_opt!( self, cap::EnterReverseMode )?;
                        }
                        if add.contains( Style::UNDERLINE ) {
                            expand_opt!( self, cap::EnterUnderlineMode )?;
                        }

                        self.writer.cur_style |= add; */

                        Ok( () )
                    }

                    pub fn remove_style( &mut self, style: Style ) -> io::Result<()> 
                    {
                        /*
                        let remove = style & self.writer.cur_style;

                        if remove.intersects( Style::BOLD | Style::REVERSE ) {
                            let new_style = self.writer.cur_style - remove;
                            let fg = self.writer.fg;
                            let bg = self.writer.bg;
                            self.clear_attributes()?;
                            self.add_style( new_style )?;
                            self.set_fg( fg )?;
                            self.set_bg( bg )?;
                        } else {
                            if remove.contains( Style::ITALIC ) {
                                expand_opt!( self, cap::ExitItalicsMode )?;
                            }
                            if remove.contains( Style::UNDERLINE ) {
                                expand_opt!( self, cap::ExitUnderlineMode )?;
                            }

                            self.writer.cur_style -= remove;
                        } */

                        Ok( () )
                    }

                    pub fn set_style( &mut self, style: Style ) -> io::Result<()> 
                    {
                        let add = style - self.writer.cur_style;
                        let remove = self.writer.cur_style - style;

                        if remove.intersects( Style::BOLD | Style::REVERSE ) {
                            let fg = self.writer.fg;
                            let bg = self.writer.bg;
                            self.clear_attributes()?;
                            self.set_fg( fg )?;
                            self.set_bg( bg )?;
                            self.add_style( style )?;
                        } else {
                            self.add_style( add )?;
                            self.remove_style( remove )?;
                        }

                        Ok( () )
                    }

                    pub fn set_theme( &mut self, theme: Theme ) -> io::Result<()> 
                    {
                        self.set_attrs( theme.fg, theme.bg, theme.style )
                    }

                    pub fn set_attrs( &mut self, fg:Option<Color>, bg:Option<Color>, style: Style ) -> io::Result<()>
                    {
                        if ( self.writer.fg.is_some() && fg.is_none() ) ||
                                ( self.writer.bg.is_some() && bg.is_none() ) {
                            self.clear_attributes()?;
                        }

                        self.set_style( style )?;
                        self.set_fg( fg )?;
                        self.set_bg( bg )?;

                        Ok( () )
                    }

                    fn clear_fg( &mut self ) -> io::Result<()> 
                    {
                        let bg = self.writer.bg;
                        let style = self.writer.cur_style;

                        self.clear_attributes()?;
                        self.set_bg( bg )?;
                        self.set_style( style )
                    }

                    fn clear_bg( &mut self ) -> io::Result<()> 
                    {
                        let fg = self.writer.fg;
                        let style = self.writer.cur_style;

                        self.clear_attributes()?;
                        self.set_fg( fg )?;
                        self.set_style( style )
                    }

                    fn set_fg_color( &mut self, fg: Color ) -> io::Result<()> 
                    {
                        //expand_opt!( self, cap::SetAForeground, |ex| ex.parameters( color_code( fg ) ) )
                        Ok( () )
                    }

                    fn set_bg_color( &mut self, bg: Color ) -> io::Result<()> 
                    {
                        //expand_opt!( self, cap::SetABackground, |ex| ex.parameters( color_code( bg ) ) )
                        Ok( () )
                    }

                    pub fn clear_screen( &mut self ) -> io::Result<()> 
                    {
                        //expand_req!( self, cap::ClearScreen, "clear_screen" )
                        Ok( () )
                    }

                    pub fn clear_to_line_end( &mut self ) -> io::Result<()> 
                    {
                        /*expand_req!( self, cap::ClrEol, "clr_eol" ) */
                        Ok( () )
                    }

                    pub fn clear_to_screen_end( &mut self ) -> io::Result<()> 
                    {
                        /* expand_req!( self, cap::ClrEos, "clr_eos" ) */
                        Ok( () )
                    }

                    pub fn move_up( &mut self, n: usize ) -> io::Result<()> 
                    {
                        /*
                        if n == 1 {
                            expand_req!( self, cap::CursorUp, "cursor_up" )?;
                        } else if n != 0 {
                            expand_req!( self, cap::ParmUpCursor, "parm_cursor_up",
                                |ex| ex.parameters( to_u32( n ) ) )?;
                        } */
                        Ok( () )
                    }

                    pub fn move_down( &mut self, n: usize ) -> io::Result<()> 
                    {
                        /*
                        if n != 0 {
                            expand_req!( self, cap::ParmDownCursor, "parm_cursor_down",
                                |ex| ex.parameters( to_u32( n ) ) )?;
                        } */

                        Ok( () )
                    }

                    pub fn move_left( &mut self, n: usize ) -> io::Result<()> 
                    {
                        /*
                        if n == 1 {
                            expand_req!( self, cap::CursorLeft, "cursor_left" )?;
                        } else if n != 0 {
                            expand_req!( self, cap::ParmLeftCursor, "parm_cursor_left",
                                |ex| ex.parameters( to_u32( n ) ) )?;
                        } */

                        Ok( () )
                    }

                    pub fn move_right( &mut self, n: usize ) -> io::Result<()> 
                    {
                        /*
                        if n == 1 {
                            expand_req!( self, cap::CursorRight, "cursor_right" )?;
                        } else if n != 0 {
                            expand_req!( self, cap::ParmRightCursor, "parm_cursor_right",
                                |ex| ex.parameters( to_u32( n ) ) )?;
                        } */
                        Ok( () )
                    }

                    pub fn move_to_first_column( &mut self ) -> io::Result<()> 
                    {
                        self.write_bytes( b"\r" )
                    }

                    pub fn move_cursor( &mut self, pos: Cursor ) -> io::Result<()> 
                    {
                        /*
                        match ( self.term.info.get::<cap::CursorAddress>(),
                                self.term.info.get::<cap::CursorHome>() ) {
                            ( _, Some( ref home ) ) if pos == Cursor::default() => { self.expand( home.expand() )?; }
                            ( Some( addr ), _ ) => {
                                self.expand( addr.expand()
                                    .parameters( to_u32( pos.line ), to_u32( pos.column ) ) )?;
                            }
                            ( None, _ ) => return Err( not_supported( "cursor_address" ) )
                        } */

                        Ok( () )
                    }

                    pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> 
                    {
                        /* match mode
                        {
                            CursorMode::Normal | CursorMode::Overwrite =>
                            { expand_opt!( self, cap::CursorNormal )?; }
                            
                            CursorMode::Invisible =>
                            { expand_opt!( self, cap::CursorInvisible )?; }
                        } v */
                        Ok( () )
                    }

                    pub fn write_char( &mut self, ch:char ) -> io::Result<()> 
                    {
                        self.write_str( ch.encode_utf8( &mut [0; 4] ) )
                    }

                    pub fn write_str( &mut self, s:&str ) -> io::Result<()> 
                    {
                        self.write_bytes( s.as_bytes() )
                    }

                    pub fn write_styled( &mut self,
                            fg:Option<Color>, bg:Option<Color>, style: Style, text:&str )
                            -> io::Result<()> {
                        self.set_attrs( fg, bg, style )?;

                        self.write_str( text )?;
                        self.clear_attributes()
                    }

                    fn write_bytes( &mut self, buf:&[u8] ) -> io::Result<()> 
                    {
                        if buf.len() + self.writer.out_buffer.len() > self.writer.out_buffer.capacity() {
                            self.flush()?;
                        }

                        if buf.len() > self.writer.out_buffer.capacity() {
                            self.write_data( buf ).1
                        } else {
                            self.writer.out_buffer.extend( buf );
                            Ok( () )
                        }
                    }

                    pub fn flush( &mut self ) -> io::Result<()> 
                    {
                        let ( n, res ) = self.write_data( &self.writer.out_buffer );
                        self.writer.out_buffer.drain( ..n );
                        res
                    }

                    fn write_data( &self, buf:&[u8] ) -> ( usize, io::Result<()> ) 
                    {
                        ( 0, Ok( () ) )
                        /*
                        let mut offset = 0;

                        let r = loop {
                            if offset == buf.len() {
                                break Ok( () );
                            }

                            match write( self.term.out_fd, buf ) 
                            {
                                Ok( 0 ) => break Err( io::Error::from( io::ErrorKind::WriteZero ) ),
                                Ok( n ) => offset += n,
                                Err( Errno::EINTR ) => continue,
                                Err( e ) => break Err( nix_to_io( e ) )
                            }
                        };

                        ( offset, r ) */
                    }
                    /*
                    fn expand<T: AsRef<[u8]>>( &mut self, exp: Expansion<T> ) -> io::Result<()>
                    {
                        let writer = &mut *self.writer;
                        exp
                            .with( &mut writer.context )
                            .to( &mut writer.out_buffer )
                            .map_err( ti_to_io )
                    } */
                }

                impl<'a> Drop for TerminalWriteGuard<'a> 
               
                {
                    fn drop( &mut self ) {
                        if let Err( e ) = self.flush() {
                            eprintln!( "failed to flush terminal: {}", e );
                        }
                    }
                }

                impl Writer 
                {
                    fn new() -> Writer 
                    {
                        Writer{
                            //context: Context::default(),
                            out_buffer: Vec::with_capacity( OUT_BUFFER_SIZE ),
                            fg: None,
                            bg: None,
                            cur_style: Style::empty(),
                        }
                    }
                }
                /*
                fn sequences( info:&Database ) -> SeqMap 
                {
                    let mut sequences = SequenceMap::new();

                    macro_rules! add {
                        ( $seq:ty , $key:expr ) => { {
                            if let Some( seq ) = info.get::<$seq>() {
                                if let Some( s ) = ascii_str( seq.as_ref() ) {
                                    sequences.insert( s.into(), SeqData::Key( $key ) );
                                }
                            }
                        } }
                    }

                    add!( cap::KeyUp,        Key::Up );
                    add!( cap::KeyDown,      Key::Down );
                    add!( cap::KeyLeft,      Key::Left );
                    add!( cap::KeyRight,     Key::Right );
                    add!( cap::KeyHome,      Key::Home );
                    add!( cap::KeyEnd,       Key::End );
                    add!( cap::KeyNPage,     Key::PageDown );
                    add!( cap::KeyPPage,     Key::PageUp );
                    add!( cap::KeyDc,        Key::Delete );
                    add!( cap::KeyIc,        Key::Insert );
                    add!( cap::KeyF1,        Key::F( 1 ) );
                    add!( cap::KeyF2,        Key::F( 2 ) );
                    add!( cap::KeyF3,        Key::F( 3 ) );
                    add!( cap::KeyF4,        Key::F( 4 ) );
                    add!( cap::KeyF5,        Key::F( 5 ) );
                    add!( cap::KeyF6,        Key::F( 6 ) );
                    add!( cap::KeyF7,        Key::F( 7 ) );
                    add!( cap::KeyF8,        Key::F( 8 ) );
                    add!( cap::KeyF9,        Key::F( 9 ) );
                    add!( cap::KeyF10,       Key::F( 10 ) );
                    add!( cap::KeyF11,       Key::F( 11 ) );
                    add!( cap::KeyF12,       Key::F( 12 ) );

                    if is_xterm( info.name() ) {
                        sequences.insert( XTERM_MOUSE_INTRO.into(), SeqData::XTermMouse );
                    }

                    sequences
                } */

                pub struct PrepareState 
                {
                    old_tio:Option<termios>,
                    old_sigcont:Option<SigAction>,
                    old_sigint:Option<SigAction>,
                    old_sigtstp:Option<SigAction>,
                    old_sigquit:Option<SigAction>,
                    old_sigwinch:Option<SigAction>,
                    restore_keypad: bool,
                    restore_mouse: bool,
                    prev_resume:Option<Resume>,
                }

                impl PrepareState
                {
                    pub const fn new() -> Self
                    {
                        Self
                        {
                            old_tio: None,
                            old_sigcont: None,
                            old_sigint: None,
                            old_sigtstp: None,
                            old_sigquit: None,
                            old_sigwinch: None,
                            restore_keypad: false,
                            restore_mouse: false,
                            prev_resume: None,
                        }
                    }
                }

                #[derive( Copy, Clone, Debug )]
                struct Resume 
                {
                    config: PrepareConfig,
                }

                unsafe fn close_fd( fd: RawFd ) 
                {
                    drop( File::from_raw_fd( fd ) );
                }

                fn open_rw<P: AsRef<Path>>( path: P ) -> io::Result<RawFd> 
                {
                    use ::fs::OpenOptions;

                    let file = OpenOptions::new()
                        .read( true )
                        .write( true )
                        .open( path )?;

                    Ok( file.into_raw_fd() )
                }

                #[repr( C )]
                struct Winsize 
                {
                    ws_row: c_ushort,
                    ws_col: c_ushort,
                    ws_xpixel: c_ushort,
                    ws_ypixel: c_ushort,
                }

                fn get_winsize( fd: c_int ) -> io::Result<Size> 
                {
                    let mut winsz: Winsize = unsafe { zeroed() };
                    let res = unsafe { ioctl( fd, TIOCGWINSZ.into(), &mut winsz ) };

                    if res == -1 {
                        Err( io::Error::last_os_error() )
                    } else {
                        let size = Size{
                            lines: winsz.ws_row as usize,
                            columns: winsz.ws_col as usize,
                        };

                        Ok( size )
                    }
                }

                fn nix_to_io( e:api::Error ) -> io::Error 
                {
                    io::Error::from_raw_os_error( e as i32 )
                }
                /*
                fn ti_to_io( e: terminfo::Error ) -> io::Error 
                {
                    match e {
                        terminfo::Error::Io( e ) => e,
                        terminfo::Error::NotFound => io::Error::new( 
                            io::ErrorKind::NotFound, "terminfo entry not found" ),
                        terminfo::Error::Parse => io::Error::new( 
                            io::ErrorKind::Other, "failed to parse terminfo entry" ),
                        terminfo::Error::Expand( _ ) => io::Error::new( 
                            io::ErrorKind::Other, "failed to expand terminfo entry" ),
                    }
                } */

                fn to_timeval( d: Duration ) -> TimeVal 
                {
                    const MAX_SECS: i64 = i64::max_value() / 1_000;

                    let secs = match d.as_secs() {
                        n if n > MAX_SECS as u64 => MAX_SECS,
                        n => n as i64,
                    };

                    let millis = d.subsec_millis() as i64;

                    TimeVal::milliseconds( secs * 1_000 + millis )
                }
                /*
                fn peek_event( buf:&[u8], sequences:&SeqMap )
                        -> io::Result<Option<( Event, usize )>> {
                    let ( res, n ) = {
                        let s = utf8_prefix( buf )?;

                        if s.is_empty() {
                            return Ok( None );
                        }

                        let mut last_match = None;

                        for pfx in prefixes( s ) {
                            match sequences.find( pfx ) {
                                FindResult::NotFound => break,
                                FindResult::Found( value ) => {
                                    last_match = Some( ( pfx, *value ) );
                                    break;
                                }
                                FindResult::Incomplete => (),
                                FindResult::Undecided( value ) => { last_match = Some( ( pfx, *value ) ); }
                            }
                        }

                        let res = last_match.and_then( |( seq, value )| {
                            match value {
                                SeqData::Key( key ) => Some( ( Event::Key( key ), seq.len() ) ),
                                SeqData::XTermMouse => {
                                    if let Some( ( data, len ) ) = parse_mouse_data( &buf[seq.len()..] ) {
                                        Some( ( Event::Mouse( data ), seq.len() + len ) )
                                    } else {
                                        None
                                    }
                                }
                            }
                        } );

                        if let Some( res ) = res {
                            res
                        } else {
                            let ch = s.chars().next().unwrap();
                            ( Event::Key( ch.into() ), ch.len_utf8() )
                        }
                    };

                    Ok( Some( ( res, n ) ) )
                } */

                fn parse_mouse_data( mut buf:&[u8] ) -> Option<( MouseEvent, usize )> {
                    let orig_len = buf.len();

                    let ( mut input, end ) = parse_integer( &mut buf )?;

                    if end != b';' {
                        return None;
                    }

                    let ( column, end ) = parse_integer( &mut buf )?;

                    if end != b';' {
                        return None;
                    }

                    let ( line, end ) = parse_integer( &mut buf )?;

                    let is_pressed = match end {
                        b'M' => true,
                        b'm' => false,
                        _ => return None
                    };

                    let mut mods = ModifierState::empty();

                    if ( input & XTERM_SHIFT_MASK ) != 0 {
                        mods |= ModifierState::SHIFT;
                    }
                    if ( input & XTERM_META_MASK ) != 0 {
                        mods |= ModifierState::ALT;
                    }
                    if ( input & XTERM_CTRL_MASK ) != 0 {
                        mods |= ModifierState::CTRL;
                    }

                    input &= !XTERM_MODIFIER_MASK;

                    let input = match input {
                        0 ..= 3 => mouse_button_event( input, is_pressed ),
                        64 => MouseInput::WheelUp,
                        65 => MouseInput::WheelDown,
                        _ => MouseInput::Motion,
                    };

                    let position = Cursor{
                        line: ( line - 1 ) as usize,
                        column: ( column - 1 ) as usize,
                    };

                    Some( ( MouseEvent{
                        position,
                        input,
                        modifiers: mods,
                    }, orig_len - buf.len() ) )
                }

                fn parse_integer( buf:&mut &[u8] ) -> Option<( u32, u8 )> {
                    let mut n = 0u32;
                    let mut iter = buf.iter();

                    while let Some( &b ) = iter.next() {
                        match b {
                            b'0' ..= b'9' => {
                                n = n.checked_mul( 10 )?
                                    .checked_add( ( b - b'0' ) as u32 )?;
                            }
                            _ => {
                                *buf = iter.as_slice();
                                return Some( ( n, b ) );
                            }
                        }
                    }

                    None
                }

                fn mouse_button_event( input: u32, is_pressed: bool ) -> MouseInput {
                    let button = match input {
                        0 => MouseButton::Left,
                        1 => MouseButton::Middle,
                        2 => MouseButton::Right,
                        _ => MouseButton::Other( input )
                    };

                    if is_pressed {
                        MouseInput::ButtonPressed( button )
                    } else {
                        MouseInput::ButtonReleased( button )
                    }
                }

                fn utf8_prefix( buf:&[u8] ) -> io::Result<&str> {
                    match from_utf8( buf ) {
                        Ok( s ) => Ok( s ),
                        Err( e ) => {
                            if e.valid_up_to() != 0 {
                                from_utf8( &buf[..e.valid_up_to()] )
                                    .map_err( |_| unreachable!() )
                            } else if e.error_len().is_some() {
                                Err( io::Error::new( io::ErrorKind::Other,
                                    "read invalid utf-8 data from terminal" ) )
                            } else {
                                Ok( "" )
                            }
                        }
                    }
                }

                static LAST_SIGNAL: AtomicUsize = AtomicUsize::new( 0 );

                extern "C" fn handle_signal( signum: c_int ) 
                {
                    LAST_SIGNAL.store( signum as usize, Ordering::Relaxed );
                }

                fn conv_signal( sig: c_int ) -> Option<Signal> 
                {
                    match NixSignal::try_from( sig ).ok() 
                    {
                        Some( NixSignal::SIGCONT )  => Some( Signal::Continue ),
                        Some( NixSignal::SIGINT )   => Some( Signal::Interrupt ),
                        Some( NixSignal::SIGQUIT )  => Some( Signal::Quit ),
                        Some( NixSignal::SIGTSTP )  => Some( Signal::Suspend ),
                        Some( NixSignal::SIGWINCH ) => Some( Signal::Resize ),
                        _ => None
                    }
                }

                fn get_signal() -> Option<Signal> 
                {
                    conv_signal( LAST_SIGNAL.load( Ordering::Relaxed ) as c_int )
                }

                fn take_signal() -> Option<Signal> { conv_signal( LAST_SIGNAL.swap( 0, Ordering::Relaxed ) as c_int ) }

                fn ascii_str( s:&[u8] ) -> Option<&str>
                {
                    use ::str::from_utf8_unchecked;

                    if s.is_ascii() { Some( unsafe { from_utf8_unchecked( s ) } ) }
                    
                    else { None }
                }

                fn color_code( color: Color ) -> u8
                {
                    match color
                    {
                        Color::Black =>     0,
                        Color::Red =>       1,
                        Color::Green =>     2,
                        Color::Yellow =>    3,
                        Color::Blue =>      4,
                        Color::Magenta =>   5,
                        Color::Cyan =>      6,
                        Color::White =>     7,
                    }
                }

                fn not_supported( op:&str ) -> io::Error
                { io::Error::new( io::ErrorKind::Other, format!( "operation not supported: {}", op ) ) }

                #[cfg( target_pointer_width = "64" )]
                fn to_u32( u: usize ) -> u32
                {
                    if u > u32::max_value() as usize { u32::max_value() }
                    else { u as u32 }
                }

                #[cfg( any( target_pointer_width = "16", target_pointer_width = "32" ) )]
                fn to_u32( u: usize ) -> u32 { u as u32 }
            } pub use self::terminal::{ * };
        }

        pub mod windows
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
        }
        #[cfg( unix   )] pub use self::unix as sys;
        #[cfg( windows )] pub use self::windows as sys;
    }
    /*
    linefeed v0.0.0 */
    pub mod command
    {
        /*!
        Defines the set of line editing commands. */
        use ::
        {
            borrow::Cow::{ self, Borrowed, Owned },
            *,
        };
        /*
        */
        macro_rules! define_commands
        {
            ( $($name:ident => $str:expr,)+ ) => 
            {

                #[derive( Clone, Debug, Eq, PartialEq )]
                pub enum Command {
                    $($name, )+

                    Custom( Cow<'static, str> ),
                    Macro( Cow<'static, str> ),
                }

                pub static COMMANDS:&[&str] = &[ $( $str ),+ ];

                impl fmt::Display for Command
                {
                    fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
                        match *self {
                            $( Command::$name => f.write_str( $str ) , )+
                            Command::Custom( ref s ) => f.write_str( s ),
                            Command::Macro( ref s ) => write!( f, "\"{}\"",
                                char::escape_sequence( s ) )
                        }
                    }
                }

                impl Command
                {
                    pub fn from_str( name:&'static str ) -> Command {
                        Command::opt_from_str( name )
                            .unwrap_or_else( || Command::Custom( Borrowed( name ) ) )
                    }

                    pub fn from_string<T>( name: T ) -> Command
                             where T: AsRef<str> + Into<String> {
                        Command::opt_from_str( name.as_ref() )
                            .unwrap_or_else( || Command::Custom( Owned( name.into() ) ) )
                    }

                    fn opt_from_str( s:&str ) -> Option<Command> {
                        match s {
                            $( $str => Some( Command::$name ), )+
                            _ => None
                        }
                    }
                }
            }
        }

        define_commands!
        {
            Abort => "abort",
            AcceptLine => "accept-line",
            Complete => "complete",
            InsertCompletions => "insert-completions",
            PossibleCompletions => "possible-completions",
            MenuComplete => "menu-complete",
            MenuCompleteBackward => "menu-complete-backward",
            DigitArgument => "digit-argument",
            SelfInsert => "self-insert",
            TabInsert => "tab-insert",
            OverwriteMode => "overwrite-mode",
            InsertComment => "insert-comment",
            BackwardChar => "backward-char",
            ForwardChar => "forward-char",
            CharacterSearch => "character-search",
            CharacterSearchBackward => "character-search-backward",
            BackwardWord => "backward-word",
            ForwardWord => "forward-word",
            BackwardKillLine => "backward-kill-line",
            KillLine => "kill-line",
            BackwardKillWord => "backward-kill-word",
            KillWord => "kill-word",
            UnixWordRubout => "unix-word-rubout",
            ClearScreen => "clear-screen",
            BeginningOfLine => "beginning-of-line",
            EndOfLine => "end-of-line",
            BackwardDeleteChar => "backward-delete-char",
            DeleteChar => "delete-char",
            TransposeChars => "transpose-chars",
            TransposeWords => "transpose-words",
            BeginningOfHistory => "beginning-of-history",
            EndOfHistory => "end-of-history",
            NextHistory => "next-history",
            PreviousHistory => "previous-history",
            ForwardSearchHistory => "forward-search-history",
            ReverseSearchHistory => "reverse-search-history",
            HistorySearchForward => "history-search-forward",
            HistorySearchBackward => "history-search-backward",
            QuotedInsert => "quoted-insert",
            Yank => "yank",
            YankPop => "yank-pop",
        }

        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum Category
        {

            Complete,
            Kill,
            Search,
            IncrementalSearch,
            Yank,
            Digit,
            Other,
        }

        impl Command
        {

            pub fn category( &self ) -> Category
            {
                use self::Command::*;

                match *self
                {
                    DigitArgument => Category::Digit, 
                    Complete | InsertCompletions | PossibleCompletions |
                    MenuComplete | MenuCompleteBackward => Category::Complete,
                    BackwardKillLine | KillLine | BackwardKillWord | KillWord | UnixWordRubout => Category::Kill,
                    ForwardSearchHistory | ReverseSearchHistory => Category::IncrementalSearch,
                    HistorySearchForward | HistorySearchBackward => Category::Search,
                    Yank | YankPop => Category::Yank,
                    _ => Category::Other
                }
            }
        }
    }

    pub mod complete
    {
        /*!
        Provides utilities for implementing word completion. */
        use ::
        {
            borrow::Cow::{ self, Borrowed, Owned },
            fs::{ read_dir },
            path::{ is_separator, MAIN_SEPARATOR },
            system::
            {
                prompter::{ Prompter },
                terminal::{ Terminal },
            },
            *,
        };
        /*
        use crate::prompter::Prompter;
        */

        #[derive( Clone, Debug )]
        pub struct Completion
        {

            pub completion: String,
            pub display:Option<String>,
            pub suffix: Suffix,
        }

        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum Suffix 
        {

            Default,
            None,
            Some( char ),
        }

        impl Completion
        {
            pub fn simple( s: String ) -> Completion 
            {
                Completion{
                    completion: s,
                    display: None,
                    suffix: Suffix::default(),
                }
            }
            pub fn completion( &self, def_suffix:Option<char> ) -> Cow<str> 
            {
                let mut s = Borrowed( &self.completion[..] );

                if let Some( suffix ) = self.suffix.with_default( def_suffix ) {
                    s.to_mut().push( suffix );
                }

                s
            }

            pub fn display( &self ) -> Cow<str> 
            {
                let mut s = Borrowed( self.display_str() );

                if let Suffix::Some( suffix ) = self.suffix {
                    s.to_mut().push( suffix );
                }

                s
            }

            pub fn display_chars( &self ) -> usize 
            {
                let n = self.display_str().chars().count();
                n + if self.suffix.is_some() { 1 } else { 0 }
            }

            fn display_str( &self ) -> &str 
            {
                match self.display {
                    Some( ref dis ) => dis,
                    None => &self.completion
                }
            }
        }

        impl Suffix 
        {

            pub fn is_default( &self ) -> bool 
            {
                match *self {
                    Suffix::Default => true,
                    _ => false
                }
            }

            pub fn is_some( &self ) -> bool 
            {
                match *self {
                    Suffix::Some( _ ) => true,
                    _ => false
                }
            }

            pub fn is_none( &self ) -> bool 
            {
                match *self {
                    Suffix::None => true,
                    _ => false
                }
            }

            pub fn with_default( self, default:Option<char> ) -> Option<char> 
            {
                match self 
                {
                    Suffix::None => None,
                    Suffix::Some( ch ) => Some( ch ),
                    Suffix::Default => default
                }
            }
        }

        impl Default for Suffix 
        {
            fn default() -> Suffix 
            {
                Suffix::Default
            }
        }

        pub trait Completer<Term: Terminal>: Send + Sync 
        {

            fn complete( &self, word:&str, prompter:&Prompter<Term>, start:usize, end:usize ) -> Option<Vec<Completion>>;
            fn word_start( &self, line:&str, end: usize, prompter:&Prompter<Term> ) -> usize
            {
                word_break_start( &line[..end], prompter.word_break_chars() )
            }

            fn quote<'a>( &self, word:&'a str ) -> Cow<'a, str> { Borrowed( word ) }

            fn unquote<'a>( &self, word:&'a str ) -> Cow<'a, str> { Borrowed( word ) }
        }

        pub struct DummyCompleter;

        impl<Term: Terminal> Completer<Term> for DummyCompleter
        {
            fn complete
            ( 
                &self,
                _word:&str,
                _reader:&Prompter<Term>,
                _start: usize,
                _end: usize
            ) -> Option<Vec<Completion>> { None }
        }

        pub struct PathCompleter;

        impl<Term: Terminal> Completer<Term> for PathCompleter 
        {
            fn complete( &self, word:&str, _reader:&Prompter<Term>, _start: usize, _end: usize )
                    -> Option<Vec<Completion>> { Some( complete_path( word ) ) }

            fn word_start( &self, line:&str, end: usize, _reader:&Prompter<Term> ) -> usize {
                escaped_word_start( &line[..end] )
            }

            fn quote<'a>( &self, word:&'a str ) -> Cow<'a, str> { escape( word ) }

            fn unquote<'a>( &self, word:&'a str ) -> Cow<'a, str> { unescape( word ) }
        }

        pub fn complete_path( path:&str ) -> Vec<Completion> 
        {
            let ( base_dir, fname ) = split_path( path );
            let mut res = Vec::new();

            let lookup_dir = base_dir.unwrap_or( "." );

            if let Ok( list ) = read_dir( lookup_dir ) {
                for ent in list {
                    if let Ok( ent ) = ent {
                        let ent_name = ent.file_name();

                        if let Ok( path ) = ent_name.into_string() {
                            if path.starts_with( fname ) {
                                let ( name, display ) = if let Some( dir ) = base_dir {
                                    ( format!( "{}{}{}", dir, MAIN_SEPARATOR, path ),
                                        Some( path ) )
                                } else {
                                    ( path, None )
                                };

                                let is_dir = ent.metadata().ok()
                                    .map_or( false, |m| m.is_dir() );

                                let suffix = if is_dir {
                                    Suffix::Some( MAIN_SEPARATOR )
                                } else {
                                    Suffix::Default
                                };

                                res.push( Completion{
                                    completion: name,
                                    display: display,
                                    suffix: suffix,
                                } );
                            }
                        }
                    }
                }
            }

            res.sort_by( |a, b| a.display_str().cmp( b.display_str() ) );
            res
        }

        pub fn word_break_start( s:&str, word_break:&str ) -> usize 
        {
            let mut start = s.len();

            for ( idx, ch ) in s.char_indices().rev() {
                if word_break.contains( ch ) {
                    break;
                }
                start = idx;
            }

            start
        }
        pub fn escaped_word_start( s:&str ) -> usize 
        {
            let mut chars = s.char_indices().rev();
            let mut start = s.len();

            while let Some( ( idx, ch ) ) = chars.next() {
                if needs_escape( ch ) {
                    let n = {
                        let mut n = 0;

                        loop {
                            let mut clone = chars.clone();

                            let ch = match clone.next() {
                                Some( ( _, ch ) ) => ch,
                                None => break
                            };

                            if ch == '\\' {
                                chars = clone;
                                n += 1;
                            } else {
                                break;
                            }
                        }

                        n
                    };

                    if n % 2 == 0 {
                        break;
                    }
                }

                start = idx;
            }

            start
        }

        pub fn escape( s:&str ) -> Cow<str> 
        {
            let n = s.chars().filter( |&ch| needs_escape( ch ) ).count();

            if n == 0 {
                Borrowed( s )
            } else {
                let mut res = String::with_capacity( s.len() + n );

                for ch in s.chars() {
                    if needs_escape( ch ) {
                        res.push( '\\' );
                    }
                    res.push( ch );
                }

                Owned( res )
            }
        }

        pub fn unescape( s:&str ) -> Cow<str> 
        {
            if s.contains( '\\' ) {
                let mut res = String::with_capacity( s.len() );
                let mut chars = s.chars();

                while let Some( ch ) = chars.next() {
                    if ch == '\\' {
                        if let Some( ch ) = chars.next() {
                            res.push( ch );
                        }
                    } else {
                        res.push( ch );
                    }
                }

                Owned( res )
            } else {
                Borrowed( s )
            }
        }

        fn needs_escape( ch:char ) -> bool 
        {
            match ch {
                ' ' | '\t' | '\n' | '\\' => true,
                _ => false
            }
        }

        fn split_path( path:&str ) -> ( Option<&str>, &str ) 
        {
            match path.rfind( is_separator ) {
                Some( pos ) => ( Some( &path[..pos] ), &path[pos + 1..] ),
                None => ( None, path )
            }
        }
    }

    pub mod function
    {
        /*!
        Provides the `Function` trait for implementing custom `Prompter` commands. */
        use ::
        {
            system::
            {
                command::Category,
                prompter::Prompter,
                terminal::Terminal,
            },
            *,
        };
        /*
        */

        pub trait Function<Term: Terminal>: Send + Sync
        {

            fn execute( &self, prompter:&mut Prompter<Term>, count: i32, ch:char ) -> io::Result<()>;
            fn category( &self ) -> Category { Category::Other }
        }

        impl<F, Term: Terminal> Function<Term> for F where
        F: Send + Sync,
        F: Fn( &mut Prompter<Term>, i32, char ) -> io::Result<()>
        {
            fn execute( &self, prompter:&mut Prompter<Term>, count: i32, ch:char ) -> io::Result<()>
            { self( prompter, count, ch ) }
        }
    }

    pub mod input
    {
        /*!
        Parses configuration files in the format of GNU Readline `inputrc` */
        use ::
        {
            char::{ from_u32, ctrl, meta, parse_char_name },
            fs::File,
            io::{stderr, Read, Write},
            path::Path,
            str::{Chars, Lines},
            system::command::Command,
            *,
        };
        /*
        */

        #[derive( Clone, Debug )]
        pub enum Directive 
        {

            Bind( String, Command ),
            Conditional{

                name:Option<String>,
                value: String,
                then_group: Vec<Directive>,
                else_group: Vec<Directive>,
            },
            SetVariable( String, String ),
        }

        pub fn parse_file<P: ?Sized>( filename:&P ) -> Option<Vec<Directive>> where
        P: AsRef<Path>
        {
            let filename = filename.as_ref();
            let mut f = match File::open( filename )
            {
                Ok( f ) => f,
                Err( e ) => {
                    let _ = writeln!( stderr(), "linefeed: {}: {}", filename.display(), e );
                    return None;
                }
            };

            let mut buf = String::new();

            if let Err( e ) = f.read_to_string( &mut buf ) 
            {
                let _ = writeln!( stderr(), "{}: {}", filename.display(), e );
                return None;
            }

            Some( parse_text( filename, &buf ) )
        }

        pub fn parse_text<P: ?Sized>( name:&P, line:&str ) -> Vec<Directive> where
        P: AsRef<Path>
        {
            let mut p = Parser::new( name.as_ref(), line );
            p.parse()
        }

        struct Parser<'a> 
        {
            lines: Lines<'a>,
            filename:&'a Path,
            line_num: usize,
        }

        enum Token<'a> 
        {

            Colon,
            Equal,
            SpecialWord( &'a str ),
            String( String ),
            Word( &'a str ),
            Invalid,
        }

        impl<'a> Parser<'a>
        {
            pub fn new( filename:&'a Path, text:&'a str ) -> Parser<'a> 
            {
                Parser{
                    lines: text.lines(),
                    filename: filename,
                    line_num: 0,
                }
            }

            fn next_line( &mut self ) -> Option<&'a str> 
            {
                self.lines.next().map( |line| {
                    self.line_num += 1;
                    line.trim()
                } )
            }

            fn parse( &mut self ) -> Vec<Directive> 
            {
                let mut dirs = Vec::new();

                while let Some( line ) = self.next_line() {
                    if line.starts_with( '#' ) {
                        continue;
                    }

                    let mut tokens = Tokens::new( line );

                    if let Some( Token::SpecialWord( "include" ) ) = tokens.next() {
                        let path = tokens.line;

                        if let Some( d ) = parse_file( Path::new( path ) ) {
                            dirs.extend( d );
                        }

                        continue;
                    }

                    if let Some( dir ) = self.parse_line( line ) {
                        dirs.push( dir );
                    }
                }

                dirs
            }

            fn parse_conditional( &mut self ) -> ( Vec<Directive>, Vec<Directive> ) 
            {
                let mut then_group = Vec::new();
                let mut else_group = Vec::new();
                let mut parse_else = false;

                loop {
                    let line = match self.next_line() {
                        Some( line ) => line,
                        None => {
                            self.error( "missing $endif directive" );
                            break;
                        }
                    };

                    if line.starts_with( '#' ) {
                        continue;
                    }

                    let mut tokens = Tokens::new( line );

                    let start = match tokens.next() {
                        Some( tok ) => tok,
                        None => continue
                    };

                    match start {
                        Token::SpecialWord( "else" ) => {
                            if parse_else {
                                self.error( "duplicate $else directive" );
                            } else {
                                parse_else = true;
                            }
                        }
                        Token::SpecialWord( "endif" ) => { break; }
                        _ => {
                            if let Some( dir ) = self.parse_line( line ) {
                                if parse_else {
                                    else_group.push( dir );
                                } else {
                                    then_group.push( dir );
                                }
                            }
                        }
                    }
                }

                ( then_group, else_group )
            }

            fn parse_line( &mut self, line:&str ) -> Option<Directive> 
            {
                let mut tokens = Tokens::new( line );

                let start = tokens.next()?;

                let dir = match start {
                    Token::SpecialWord( "if" ) =>
                    {
                        let name = match tokens.next() {
                            Some( Token::Word( w ) ) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let ( name, value ) = match tokens.next() {
                            Some( Token::Equal ) => {
                                let value = match tokens.next() {
                                    Some( Token::Word( w ) ) => w,
                                    None => "",
                                    _ => {
                                        self.invalid();
                                        return None;
                                    }
                                };

                                ( Some( name ), value )
                            }
                            None => ( None, name ),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let ( then_group, else_group ) = self.parse_conditional();

                        Directive::Conditional{
                            name: name.map( |s| s.to_owned() ),
                            value: value.to_owned(),
                            then_group: then_group,
                            else_group: else_group,
                        }
                    }
                    Token::SpecialWord( "else" ) => {
                        self.error( "$else without matching $if directive" );
                        return None;
                    }
                    Token::SpecialWord( "endif" ) => {
                        self.error( "$endif without matching $if directive" );
                        return None;
                    }
                    Token::String( seq ) => {
                        match tokens.next() {
                            Some( Token::Colon ) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        match tokens.next() {
                            Some( Token::Word( value ) ) =>
                                Directive::Bind( seq, Command::from_string( value ) ),
                            Some( Token::String( out ) ) =>
                                Directive::Bind( seq, Command::Macro( out.to_owned().into() ) ),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    Token::Word( "set" ) =>
                    {
                        let name = match tokens.next() {
                            Some( Token::Word( w ) ) => w,
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        let rest = tokens.line;

                        let value = match tokens.next() {
                            Some( Token::String( s ) ) => s,
                            Some( Token::Word( _ ) ) => rest.to_owned(),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        };

                        Directive::SetVariable( name.to_owned(), value )
                    }
                    Token::Word( name ) => {
                        match tokens.next() {
                            Some( Token::Colon ) => (),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }

                        let seq = match parse_char_name( name ) {
                            Some( seq ) => seq,
                            None => {
                                self.invalid();
                                return None;
                            }
                        };

                        match tokens.next() {
                            Some( Token::Word( value ) ) =>
                                Directive::Bind( seq, Command::from_string( value ) ),
                            Some( Token::String( macro_seq ) ) =>
                                Directive::Bind( seq, Command::Macro( macro_seq.to_owned().into() ) ),
                            _ => {
                                self.invalid();
                                return None;
                            }
                        }
                    }
                    _ => {
                        self.invalid();
                        return None;
                    }
                };

                Some( dir )
            }

            fn error( &self, msg:&str ) 
            {
                let _ = writeln!( stderr(),
                    "linefeed: {} line {}: {}", self.filename.display(), self.line_num, msg );
            }

            fn invalid( &self  ) { self.error( "invalid directive" ); }
        }

        struct Tokens<'a>
        {
            line:&'a str,
        }

        impl<'a> Tokens<'a>
        {
            fn new( line:&str ) -> Tokens
            {
                Tokens
                {
                    line: line,
                }
            }
        }

        impl<'a> Iterator for Tokens<'a> 
        {
            type Item = Token<'a>;
            fn next( &mut self ) -> Option<Token<'a>> 
            {
                let ch = self.line.chars().next()?;

                let tok = match ch
                {
                    ':' => {
                        self.line = self.line[1..].trim_start();
                        Token::Colon
                    }

                    '=' => {
                        self.line = self.line[1..].trim_start();
                        Token::Equal
                    }

                    '$' =>
                    {
                        let ( word, rest ) = parse_word( &self.line[1..] );
                        self.line = rest.trim_start();
                        Token::SpecialWord( word )
                    }

                    '"' =>
                    {
                        let ( tok, rest ) = parse_string( self.line );
                        self.line = rest.trim_start();
                        tok
                    }

                    _ =>
                    {
                        let ( word, rest ) = parse_word( self.line );
                        self.line = rest.trim_start();
                        Token::Word( word )
                    }
                };

                Some( tok )
            }
        }

        fn parse_escape( chars:&mut Chars ) -> Option<String> 
        {
            let ch = chars.next()?;

            let esc = match ch {
                'C'  => {
                    match chars.next() {
                        Some( '-' ) => (),
                        _ => return None
                    }
                    ctrl( chars.next()? )
                }
                'M'  => {
                    match chars.next() {
                        Some( '-' ) => (),
                        _ => return None
                    }
                    return Some( meta( chars.next()? ) );
                }
                'e'  => '\x1b',
                '\\' => '\\',
                '"'  => '"',
                '\'' => '\'',
                'a'  => '\x07',
                'b'  => '\x08',
                'd'  => '\x7f',
                'f'  => '\x0c',
                'n'  => '\n',
                'r'  => '\r',
                't'  => '\t',
                'u'  => {
                    match chars.next() {
                        Some( '{' ) => (),
                        _ => return None
                    }

                    let mut n = 0;

                    for _ in 0..6 {
                        match chars.clone().next().and_then( |ch| ch.to_digit( 16 ) ) {
                            Some( digit ) => {
                                chars.next();
                                n *= 16;
                                n += digit;
                            }
                            None => break
                        }
                    }

                    match chars.next() {
                        Some( '}' ) => (),
                        _ => return None
                    }

                    from_u32( n )?
                }
                'v'  => '\x0b',
                'x'  => {
                    let mut n = 0;

                    for _ in 0..2 {
                        let digit = chars.clone().next()?.to_digit( 16 )? as u8;
                        chars.next();

                        n <<= 4;
                        n |= digit;
                    }

                    n as char
                }
                '0' ..= '3' => {
                    let mut n = ch as u8 - b'0';

                    for _ in 0..2 {
                        let digit = chars.clone().next()?.to_digit( 8 )? as u8;
                        chars.next();

                        n <<= 3;
                        n |= digit;
                    }

                    n as char
                }
                _ => return None
            };

            Some( esc.to_string() )
        }

        fn parse_string( s:&str ) -> ( Token, &str ) 
        {
            let mut chars = s.chars();
            let mut res = String::new();
            chars.next();

            while let Some( ch ) = chars.next() {
                match ch {
                    '"' => return ( Token::String( res ), chars.as_str() ),
                    '\\' => {
                        match parse_escape( &mut chars ) {
                            Some( esc ) => { res.push_str( &esc ); }
                            None => break
                        }
                    }
                    ch => res.push( ch )
                }
            }

            ( Token::Invalid, "" )
        }

        fn parse_word( s:&str ) -> ( &str, &str ) 
        {
            let mut chars = s.char_indices();

            loop {
                let mut clone = chars.clone();

                match clone.next() {
                    Some( ( ind, ch ) ) if ch == ':' || ch == '"' || ch == '=' ||
                            ch.is_whitespace() => { return ( &s[..ind], &s[ind..] ); }
                    None => { return ( s, "" ); }
                    _ => ()
                }

                chars = clone;
            }
        }
    }

    pub mod interface
    {
        /*!
        Provides the main interface to interactive input reader */
        use ::
        {
            borrow::{ Cow },
            fs::{ File, OpenOptions },
            io::{ self, BufRead, BufReader, BufWriter, Read as _, Seek, SeekFrom, Write as _ },
            path::{ Path },
            sync::{ Arc, Mutex, MutexGuard },
            system::
            {
                command::{ Command },
                complete::{ Completer },
                function::{ Function },
                input::{ Directive },
                reader::{ Read, Reader, ReadLock, ReadResult },
                terminal::{ DefaultTerminal, Terminal },
                variables::{ Variable },
                writer::{ Write, Writer, WriteLock },
            },
            time::std::{ Duration },
            *,
        };
        /*
        */

        pub struct Interface<Term: Terminal> 
        {
            term: Term,
            write: Mutex<Write>,
            read: Mutex<Read<Term>>,
        }

        impl Interface<DefaultTerminal> 
        {

            pub fn new<T>( application: T ) -> io::Result<Interface<DefaultTerminal>> where
            T: Into<Cow<'static, str>>
            {
                let term = DefaultTerminal::new()?;
                Interface::with_term( application, term )
            }
        }

        impl<Term: Terminal> Interface<Term>
        {

            pub fn with_term<T>( application: T, term: Term ) -> io::Result<Interface<Term>> where
            T: Into<Cow<'static, str>>
            {
                let size = term.lock_write().size()?;
                let read = Read::new( &term, application.into() );

                Ok( Interface{
                    term: term,
                    write: Mutex::new( Write::new( size ) ),
                    read: Mutex::new( read ),
                } )
            }

            pub fn lock_reader( &self ) -> Reader<Term> 
            {
                Reader::new( self, self.lock_read() )
            }

            pub fn lock_writer_append( &self ) -> io::Result<Writer<Term>> 
            {
                Writer::with_lock( self.lock_write(), false )
            }

            pub fn lock_writer_erase( &self ) -> io::Result<Writer<Term>> 
            {
                Writer::with_lock( self.lock_write(), true )
            }

            fn lock_read( &self ) -> ReadLock<Term> 
            {
                ReadLock::new
                ( 
                    self.term.lock_read(),
                    self.read.lock().expect( "Interface::lock_read" )
                )
            }

            pub fn lock_write( &self ) -> WriteLock<Term>
            {
                WriteLock::new
                ( 
                    self.term.lock_write(),
                    self.write.lock().expect( "Interface::lock_write" )
                )
            }

            pub fn lock_write_data( &self ) -> MutexGuard<Write>
            { self.write.lock().expect( "Interface::lock_write_data" ) }

            pub fn read_line( &self ) -> io::Result<ReadResult> { self.lock_reader().read_line() }

            pub fn read_line_step( &self, timeout:Option<Duration> ) -> io::Result<Option<ReadResult>>
            { self.lock_reader().read_line_step( timeout ) }

            pub fn cancel_read_line( &self ) -> io::Result<()> { self.lock_reader().cancel_read_line() }

            pub fn completer( &self ) -> Arc<dyn Completer<Term>> { self.lock_reader().completer().clone() }

            pub fn set_completer( &self, completer: Arc<dyn Completer<Term>> ) -> Arc<dyn Completer<Term>>
            { self.lock_reader().set_completer( completer ) }

            pub fn get_variable( &self, name:&str ) -> Option<Variable> { self.lock_reader().get_variable( name ) }

            pub fn set_variable( &self, name:&str, value:&str ) -> Option<Variable>
            { self.lock_reader().set_variable( name, value ) }

            pub fn ignore_signal( &self, signal: system::terminal::Signal ) -> bool { self.lock_reader().ignore_signal( signal ) }

            pub fn set_ignore_signal( &self, signal: system::terminal::Signal, set: bool )
            { self.lock_reader().set_ignore_signal( signal, set ) }

            pub fn report_signal( &self, signal: system::terminal::Signal ) -> bool { self.lock_reader().report_signal( signal ) }

            pub fn set_report_signal( &self, signal: system::terminal::Signal, set: bool )
            { self.lock_reader().set_report_signal( signal, set ) }

            pub fn bind_sequence<T>( &self, seq: T, cmd: Command ) -> Option<Command> where
            T: Into<Cow<'static, str>>
            { self.lock_reader().bind_sequence( seq, cmd ) }

            pub fn bind_sequence_if_unbound<T>( &self, seq: T, cmd: Command ) -> bool where
            T: Into<Cow<'static, str>>
            { self.lock_reader().bind_sequence_if_unbound( seq, cmd ) }

            pub fn unbind_sequence( &self, seq:&str ) -> Option<Command> { self.lock_reader().unbind_sequence( seq ) }

            pub fn define_function<T>( &self, t:T, c:Arc<dyn Function<Term>> ) -> Option<Arc<dyn Function<Term>>> where
            T: Into<Cow<'static, str>>
            { self.lock_reader().define_function( t, c ) }

            pub fn remove_function( &self, name:&str ) -> Option<Arc<dyn Function<Term>>>
            { self.lock_reader().remove_function( name ) }

            pub fn evaluate_directives( &self, dirs: Vec<Directive> )
            { self.lock_reader().evaluate_directives( &self.term, dirs ) }

            pub fn evaluate_directive( &self, d:Directive  ) { self.lock_reader().evaluate_directive( &self.term, d ) }

            pub fn buffer( &self ) -> String { self.lock_write().buffer.to_owned() }

            pub fn history_len( &self ) -> usize { self.lock_write().history_len() }

            pub fn history_size( &self ) -> usize { self.lock_write().history_size() }

            pub fn save_history<P: AsRef<Path>>( &self, path: P ) -> io::Result<()>
            {
                let path = path.as_ref();
                let mut w = self.lock_write();

                if !path.exists() || w.history_size() == !0
                {
                    self.append_history( path, &w )?;
                }

                else
                {
                    self.rewrite_history( path, &w )?;
                }

                w.reset_new_history();
                Ok( () )
            }

            fn append_history<P: AsRef<Path>>( &self, path: P, w:&WriteLock<Term> ) -> io::Result<()>
            {
                let file = OpenOptions::new()
                .append( true )
                .create( true )
                .open( path.as_ref() )?;

                self.append_history_to( &file, w )
            }

            fn append_history_to( &self, file:&File, w:&WriteLock<Term> ) -> io::Result<()>
            {
                let mut wtr = BufWriter::new( file );

                for entry in w.new_history() {
                    wtr.write_all( entry.as_bytes() )?;
                    wtr.write_all( b"\n" )?;
                }

                wtr.flush()
            }

            fn rewrite_history<P: AsRef<Path>>( &self, path: P, w:&WriteLock<Term> ) -> io::Result<()>
            {
                fn nth_line( s:&str, n: usize ) -> Option<usize> {
                    let start = s.as_ptr() as usize;

                    s.lines().nth( n )
                        .map( |s| s.as_ptr() as usize - start )
                }

                let mut file = OpenOptions::new()
                    .create( true )
                    .read( true )
                    .write( true )
                    .open( path.as_ref() )?;

                let mut hist = String::new();

                file.read_to_string( &mut hist )?;

                let n_lines = hist.lines().count();
                let n = n_lines.saturating_sub( 
                    w.history_size() - w.new_history_entries() );

                if n != 0 {
                    if let Some( pos ) = nth_line( &hist, n ) {
                        file.seek( SeekFrom::Start( 0 ) )?;
                        file.write_all( hist[pos..].as_bytes() )?;

                        let n = file.seek( SeekFrom::Current( 0 ) )?;
                        file.set_len( n )?;
                    }
                }

                self.append_history_to( &file, w )
            }

            pub fn load_history<P: AsRef<Path>>( &self, path: P ) -> io::Result<()>
            {
                let mut writer = self.lock_write();

                let file = File::open( &path )?;
                let rdr = BufReader::new( file );

                for line in rdr.lines() {
                    writer.add_history( line? );
                }

                writer.reset_new_history();

                Ok( () )
            }

            pub fn write_fmt( &self, args: fmt::Arguments ) -> io::Result<()>
            {
                let s = args.to_string();
                self.write_str( &s )
            }

            fn write_str( &self, line:&str ) -> io::Result<()> { self.lock_writer_erase()?.write_str( line ) }

            pub fn set_prompt( &self, prompt:&str ) -> io::Result<()>
            { self.lock_reader().set_prompt( prompt ) }

            pub fn set_buffer( &self, buf:&str ) -> io::Result<()> { self.lock_reader().set_buffer( buf ) }

            pub fn set_cursor( &self, pos: usize ) -> io::Result<()> { self.lock_reader().set_cursor( pos ) }

            pub fn add_history( &self, line: String ) { self.lock_reader().add_history( line ); }

            pub fn add_history_unique( &self, line: String ) { self.lock_reader().add_history_unique( line ); }

            pub fn clear_history( &self  ) { self.lock_reader().clear_history(); }

            pub fn remove_history( &self, idx: usize ) { self.lock_reader().remove_history( idx ); }

            pub fn set_history_size( &self, n: usize ) { self.lock_reader().set_history_size( n ); }

            pub fn truncate_history( &self, n: usize ) { self.lock_reader().truncate_history( n ); }
        }
    }

    pub mod memory
    {
        /*!
        Implements an in-memory `Terminal` interface */
        use ::
        {
            cmp::{ min },
            iter::{ repeat },
            sync::{ Arc, Mutex, MutexGuard },
            system::
            {
                terminal::{ CursorMode, RawRead, SignalSet, Size, Terminal, TerminalReader, TerminalWriter },
            },
            time::std::{ Duration },
            *,
        };
        /*
        *//// Default size of a `MemoryTerminal` buffer
        pub const DEFAULT_SIZE: Size = Size
        {
            columns: 80,
            lines: 24,
        };

        #[derive( Clone, Debug )]
        pub struct MemoryTerminal 
        {
            write: Arc<Mutex<Writer>>,
            read: Arc<Mutex<Reader>>,
        }

        #[derive( Debug )]
        struct Writer 
        {
            memory: Vec<char>,
            input: Vec<u8>,
            col: usize,
            line: usize,
            cursor_mode: CursorMode,
            size: Size,
        }

        #[derive( Debug )]
        struct Reader 
        {
            input: Vec<u8>,
            resize:Option<Size>,
        }

        pub struct MemoryReadGuard<'a>( MutexGuard<'a, Reader> );

        pub struct MemoryWriteGuard<'a>( MutexGuard<'a, Writer> );

        impl MemoryTerminal
        {

            pub fn new() -> MemoryTerminal { MemoryTerminal::default() }

            pub fn with_size( size: Size ) -> MemoryTerminal
            {
                MemoryTerminal
                {
                    read: Arc::new( Mutex::new( Reader::new() ) ),
                    write: Arc::new( Mutex::new( Writer::new( size ) ) ),
                }
            }

            pub fn clear_all( &self  ) { self.lock_writer().clear_all(); }

            pub fn clear_to_end( &self  ) { self.lock_writer().clear_to_end(); }

            pub fn clear_input( &self  ) { self.lock_reader().clear_input(); }

            pub fn has_input( &self ) -> bool { self.lock_reader().has_input() }

            pub fn lines( &self ) -> Lines 
            {
                Lines
                {
                    writer: self.lock_writer(),
                    line: 0,
                }
            }

            pub fn move_up( &self, n: usize ) { self.lock_writer().move_up( n ); }

            pub fn move_down( &self, n: usize ) { self.lock_writer().move_down( n ); }

            pub fn move_left( &self, n: usize ) { self.lock_writer().move_left( n ); }

            pub fn move_right( &self, n: usize ) { self.lock_writer().move_right( n ); }

            pub fn move_to_first_column( &self  ) { self.lock_writer().move_to_first_column() }

            pub fn push_input( &self, s:&str ) { self.lock_reader().push_input( s.as_bytes() ); }

            pub fn read_input( &self, buf:&mut [u8] ) -> usize { self.lock_reader().read_input( buf ) }

            pub fn resize( &self, new_size: Size ) 
            {
                self.lock_writer().resize( new_size );
                self.lock_reader().resize( new_size );
            }

            pub fn scroll_up( &self, n: usize ) { self.lock_writer().scroll_up( n ); }

            pub fn cursor( &self ) -> ( usize, usize ) 
            {
                let r = self.lock_writer();
                ( r.line, r.col )
            }

            pub fn set_cursor_mode( &self, mode: CursorMode ) { self.lock_writer().set_cursor_mode( mode ); }

            pub fn cursor_mode( &self ) -> CursorMode { self.lock_writer().cursor_mode() }

            pub fn size( &self ) -> Size { self.lock_writer().size }

            pub fn write( &self, s:&str ) { self.lock_writer().write( s ); }

            fn lock_reader( &self ) -> MutexGuard<Reader> { self.read.lock().unwrap() }

            fn lock_writer( &self ) -> MutexGuard<Writer> { self.write.lock().unwrap() }
        }

        impl Default for MemoryTerminal
        {
            fn default() -> MemoryTerminal
            {
                MemoryTerminal::with_size( DEFAULT_SIZE )
            }
        }

        impl Reader
        {
            fn new() -> Reader
            {
                Reader
                {
                    input: Vec::new(),
                    resize: None,
                }
            }

            fn has_input( &mut self ) -> bool { self.resize.is_some() || !self.input.is_empty() }

            fn clear_input( &mut self ) { self.input.clear(); }

            fn push_input( &mut self, bytes:&[u8] ) { self.input.extend( bytes ); }

            fn read_input( &mut self, buf:&mut [u8] ) -> usize {
                let n = min( buf.len(), self.input.len() );

                buf[..n].copy_from_slice( &self.input[..n] );
                let _ = self.input.drain( ..n );
                n
            }

            fn resize( &mut self, size: Size ) { self.resize = Some( size ); }
        }

        impl Writer 
        {
            fn new( size: Size ) -> Writer {
                assert!( size.lines != 0 && size.columns != 0,
                    "zero-area terminal buffer: {:?}", size );

                let n_chars = size.lines * size.columns;

                Writer{
                    memory: vec![' '; n_chars],
                    input: Vec::new(),
                    col: 0,
                    line: 0,
                    cursor_mode: CursorMode::Normal,
                    size: size,
                }
            }

            fn clear_all( &mut self ) {
                for ch in &mut self.memory {
                    *ch = ' ';
                }
                self.col = 0;
                self.line = 0;
            }

            fn clear_to_end( &mut self ) {
                let idx = self.index();

                for ch in &mut self.memory[idx..] {
                    *ch = ' ';
                }
            }

            fn move_up( &mut self, n: usize ) {
                self.line = self.line.saturating_sub( n );
            }

            fn move_down( &mut self, n: usize ) {
                self.line = min( self.size.lines - 1, self.line + n );
            }

            fn move_left( &mut self, n: usize ) {
                self.col = self.col.saturating_sub( n );
            }

            fn move_right( &mut self, n: usize ) {
                self.col = min( self.size.columns - 1, self.col + n );
            }

            fn move_to_first_column( &mut self ) {
                self.col = 0;
            }

            fn resize( &mut self, new_size: Size ) {
                if self.size != new_size {
                    let n_chars = new_size.lines.checked_mul( new_size.columns )
                        .unwrap_or_else( || panic!( "terminal size too large: {:?}", new_size ) );

                    assert!( n_chars != 0, "zero-area terminal buffer: {:?}", new_size );

                    let mut new_buf = Vec::with_capacity( n_chars );

                    let ( n_copy, n_extra ) = if new_size.columns > self.size.columns {
                        ( self.size.columns, new_size.columns - self.size.columns )
                    } else {
                        ( new_size.columns, 0 )
                    };

                    for line in self.memory.chunks( self.size.columns ).take( new_size.lines ) {
                        new_buf.extend( &line[..n_copy] );
                        new_buf.extend( repeat( ' ' ).take( n_extra ) );
                    }

                    if new_size.lines > self.size.lines {
                        let n_lines = new_size.lines - self.size.lines;
                        new_buf.extend( repeat( ' ' ).take( n_lines * new_size.columns ) );
                    }

                    debug_assert_eq!( new_buf.len(), n_chars );

                    self.col = min( self.col, new_size.columns );
                    self.line = min( self.line, new_size.lines );
                    self.size = new_size;
                    self.memory = new_buf;
                }
            }

            fn scroll_up( &mut self, n: usize ) {
                let chars = min( self.memory.len(), self.size.columns * n );
                self.memory.drain( ..chars );
                self.memory.extend( repeat( ' ' ).take( chars ) );
                self.line = self.line.saturating_sub( n );
            }

            fn set_cursor_mode( &mut self, mode: CursorMode ) {
                self.cursor_mode = mode;
            }

            fn cursor_mode( &self ) -> CursorMode { self.cursor_mode }

            fn write( &mut self, s:&str ) {
                for ch in s.chars() {
                    if ch == '\n' {
                        self.advance_line();
                    } else if ch == '\r' {
                        self.col = 0;
                    } else {
                        self.write_char( ch );
                    }
                }
            }

            fn advance_line( &mut self ) {
                self.line += 1;
                self.col = 0;
                if self.line == self.size.lines {
                    self.scroll_up( 1 );
                }
            }

            fn write_char( &mut self, ch:char ) {
                if self.col >= self.size.columns {
                    self.advance_line();
                }

                let idx = self.index();
                self.memory[idx] = ch;
                self.col += 1;
            }

            fn index( &self ) -> usize { self.line * self.size.columns + self.col }
        }

        pub struct Lines<'a>
        {
            writer: MutexGuard<'a, Writer>,
            line: usize,
        }

        impl<'a> Lines<'a>
        {

            pub fn next( &mut self ) -> Option<&[char]> {
                if self.line >= self.writer.size.lines {
                    None
                } else {
                    let start = self.writer.size.columns * self.line;
                    self.line += 1;
                    let end = self.writer.size.columns * self.line;

                    Some( &self.writer.memory[start..end] )
                }
            }

            pub fn lines_remaining( &self ) -> usize { self.writer.size.lines - self.line }
        }

        impl Terminal for MemoryTerminal
        {
            type PrepareState = ();
            //type Reader = MemoryReadGuard;
            //type Writer = MemoryWriteGuard;
            fn name( &self ) -> &str { "memory-terminal" }

            fn lock_read<'a>( &'a self ) -> Box<dyn TerminalReader<Self> + 'a> 
            {
                Box::new( MemoryReadGuard( self.lock_reader() ) )
            }

            fn lock_write<'a>( &'a self ) -> Box<dyn TerminalWriter<Self> + 'a> 
            {
                Box::new( MemoryWriteGuard( self.lock_writer() ) )
            }
        }

        impl<'a> TerminalReader<MemoryTerminal> for MemoryReadGuard<'a>
        {
            fn wait_for_input( &mut self, _timeout:Option<Duration> ) -> io::Result<bool> { Ok( !self.0.input.is_empty() ) }

            fn prepare( &mut self, _block_signals: bool, _report_signals: SignalSet )
                    -> io::Result<()> { Ok( () ) }

            unsafe fn prepare_with_lock( &mut self,
                    _lock:&mut dyn TerminalWriter<MemoryTerminal>,
                    _block_signals: bool, _report_signals: SignalSet )
                    -> io::Result<()> { Ok( () ) }

            fn restore( &mut self, _state: () ) -> io::Result<()> { Ok( () ) }

            unsafe fn restore_with_lock( &mut self,
                    _lock:&mut dyn TerminalWriter<MemoryTerminal>, _state: () )
                    -> io::Result<()> { Ok( () ) }

            fn read( &mut self, buf:&mut Vec<u8> ) -> io::Result<Option<RawRead>>
            {
                Ok( None )
                /*
                if let Some( size ) = self.0.resize.take() {
                    return Ok( RawRead::Resize( size ) );
                }

                buf.reserve( 16 );

                let cap = buf.capacity();
                let len = buf.len();
                let n;

                unsafe {
                    buf.set_len( cap );
                    n = self.0.read_input( &mut buf[len..] );
                    buf.set_len( len + n );
                }

                Ok( RawRead::Bytes( n ) ) */
            }
        }

        impl<'a> TerminalWriter<MemoryTerminal> for MemoryWriteGuard<'a>
        {
            fn size( &self ) -> io::Result<Size> { Ok( self.0.size ) }

            fn clear_screen( &mut self ) -> io::Result<()> {
                self.0.clear_all();
                Ok( () )
            }

            fn clear_to_screen_end( &mut self ) -> io::Result<()> {
                self.0.clear_to_end();
                Ok( () )
            }

            fn move_up( &mut self, n: usize ) -> io::Result<()> {
                self.0.move_up( n );
                Ok( () )
            }

            fn move_down( &mut self, n: usize ) -> io::Result<()> {
                self.0.move_down( n );
                Ok( () )
            }

            fn move_left( &mut self, n: usize ) -> io::Result<()> {
                self.0.move_left( n );
                Ok( () )
            }

            fn move_right( &mut self, n: usize ) -> io::Result<()> {
                self.0.move_right( n );
                Ok( () )
            }

            fn move_to_first_column( &mut self ) -> io::Result<()> {
                self.0.move_to_first_column();
                Ok( () )
            }

            fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> {
                self.0.set_cursor_mode( mode );
                Ok( () )
            }

            fn write( &mut self, s:&str ) -> io::Result<()> {
                self.0.write( s );
                Ok( () )
            }

            fn flush( &mut self ) -> io::Result<()> { Ok( () ) }
        }
    }

    pub mod prompter
    {
        /*!
        Provides access to prompt input state. */
        use ::
        {
            char::{is_ctrl, is_printable, DELETE, EOF},
            mem::replace,
            ops::Range,
            sync::Arc,
            system::
            {
                command::{Category, Command},
                complete::{ Completion },
                function::{ Function },
                reader::{BindingIter, InputState, ReadLock, ReadResult},
                table::{format_columns, Line, Table},
                terminal::{CursorMode, Signal, Size, Terminal},
                variables::{ VariableIter },
                writer::
                {
                    BLINK_DURATION, display_str,
                    Digit, Display, HistoryIter, PromptType, Writer, WriteLock,
                },
            },
            time::Instant,
            *,
        };
        /*
        */

        pub struct Prompter<'a, 'b: 'a, Term: 'b + Terminal> {
            pub read:&'a mut ReadLock<'b, Term>,
            write: WriteLock<'b, Term>,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Prompter<'a, 'b, Term>
        {
            pub fn new( read:&'a mut ReadLock<'b, Term>, write: WriteLock<'b, Term> )
                    -> Prompter<'a, 'b, Term> { Prompter{read, write} }

            pub fn writer_append<'c>( &'c mut self ) -> io::Result<Writer<'c, 'b, Term>> { Writer::with_ref( &mut self.write, false ) }

            pub fn writer_erase<'c>( &'c mut self ) -> io::Result<Writer<'c, 'b, Term>> { Writer::with_ref( &mut self.write, true ) }

            fn reset_input( &mut self ) {
                self.read.reset_data();
                self.write.reset_data();
            }

            pub fn start_read_line( &mut self ) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.is_prompt_drawn = true;
                self.write.update_size()?;
                self.write.draw_prompt()
            }

            pub fn end_read_line( &mut self ) -> io::Result<()> {
                self.write.expire_blink()?;

                if self.read.overwrite_mode {
                    self.write.set_cursor_mode( CursorMode::Normal )?;
                }
                if self.write.is_prompt_drawn {
                    self.write.move_to_end()?;
                    self.write.write_str( "\n" )?;
                    self.write.is_prompt_drawn = false;
                }

                self.reset_input();
                self.read.state = InputState::Inactive;

                Ok( () )
            }

            pub fn handle_input( &mut self, ch:char ) -> io::Result<Option<ReadResult>> {
                self.write.expire_blink()?;

                match self.read.state {
                    InputState::Inactive => panic!( "input received in inactive state" ),
                    InputState::NewSequence => {
                        if ch == EOF && self.write.buffer.is_empty() {
                            self.write.write_str( "\n" )?;
                            self.write.is_prompt_drawn = false;
                            return Ok( Some( ReadResult::Eof ) );
                        } else {
                            self.read.sequence.push( ch );
                            self.execute_sequence()?;

                            if self.read.input_accepted {
                                let s = replace( &mut self.write.buffer, String::new() );
                                return Ok( Some( ReadResult::Input( s ) ) );
                            }
                        }
                    }
                    InputState::ContinueSequence{expiry: _} => {
                        self.read.sequence.push( ch );

                        self.execute_sequence()?;

                        if self.read.input_accepted {
                            let s = replace( &mut self.write.buffer, String::new() );
                            return Ok( Some( ReadResult::Input( s ) ) );
                        }
                    }
                    InputState::Number => {
                        if let Some( digit ) = ch.to_digit( 10 ) {
                            self.write.input_arg.input( digit as i32 );

                            if self.write.input_arg.is_out_of_bounds() {
                                self.read.state = InputState::NewSequence;
                                self.write.input_arg = Digit::None;
                                self.write.explicit_arg = false;
                                self.write.redraw_prompt( PromptType::Normal )?;
                            } else {
                                self.write.redraw_prompt( PromptType::Number )?;
                            }
                        } else {
                            self.read.state = InputState::NewSequence;
                            self.write.redraw_prompt( PromptType::Normal )?;
                            self.read.macro_buffer.insert( 0, ch );
                        }
                    }
                    InputState::CharSearch{n, backward} => {
                        if n != 0 {
                            if backward {
                                self.write.backward_search_char( n, ch )?;
                            } else {
                                self.write.forward_search_char( n, ch )?;
                            }
                        }
                        self.read.state = InputState::NewSequence;
                    }
                    InputState::TextSearch => {
                        if ch == DELETE {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.pop();
                                write.last_search.clone_from( &write.search_buffer );
                            }
                            self.write.search_history_update()?;
                        }
                        /*
                        else if self.is_abort( ch ) {
                            self.abort_search_history()?;
                        } */
                        
                        else if is::control( ch ) {
                            self.end_search_history()?;
                            self.read.macro_buffer.insert( 0, ch );
                        } else {
                            {
                                let write = &mut *self.write;
                                write.search_buffer.push( ch );
                                write.last_search.clone_from( &write.search_buffer );
                            }
                            self.write.search_history_update()?;
                        }
                    }
                    InputState::CompleteIntro => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.write_str( "\n" )?;
                                self.show_completions_page( 0 )?;
                            }
                            '\r' | '\n' => {
                                self.write.write_str( "\n" )?;
                                self.show_completions_line( 0 )?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.write_str( "\n" )?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::CompleteMore( offset ) => {
                        match ch {
                            'y' | 'Y' | ' ' => {
                                self.write.clear_prompt()?;
                                self.show_completions_page( offset )?;
                            }
                            '\r' | '\n' => {
                                self.write.clear_prompt()?;
                                self.show_completions_line( offset )?;
                            }
                            'q' | 'Q' |
                            'n' | 'N' | DELETE => {
                                self.write.clear_prompt()?;
                                self.end_page_completions()?;
                            }
                            _ => ()
                        }
                    }
                    InputState::QuotedInsert( n ) => {
                        if n != 0 {
                            self.insert( n, ch )?;
                        }
                        self.read.state = InputState::NewSequence;
                    }
                }

                Ok( None )
            }

            pub fn buffer( &self ) -> &str { &self.write.buffer }

            pub fn backup_buffer( &self ) -> &str { &self.write.backup_buffer }

            pub fn last_command_category( &self ) -> Category { self.read.last_cmd }

            pub fn word_break_chars( &self ) -> &str { &self.read.word_break }

            pub fn set_buffer( &mut self, buf:&str ) -> io::Result<()> { self.write.set_buffer( buf ) }

            pub fn cursor( &self ) -> usize { self.write.cursor }

            pub fn set_cursor( &mut self, pos: usize ) -> io::Result<()> { self.write.set_cursor( pos ) }

            pub fn set_prompt( &mut self, prompt:&str ) -> io::Result<()> { self.write.set_prompt( prompt ) }

            pub fn screen_size( &self ) -> Size { self.write.screen_size }

            pub fn explicit_arg( &self ) -> bool { self.write.explicit_arg }

            pub fn sequence( &self ) -> &str { &self.read.sequence }

            /*pub fn bindings( &self ) -> BindingIter { self.read.bindings() }*/

            pub fn variables( &self ) -> VariableIter { self.read.variables() }

            pub fn history( &self ) -> HistoryIter { self.write.history() }

            pub fn history_index( &self ) -> Option<usize> { self.write.history_index }

            pub fn history_len( &self ) -> usize { self.write.history.len() }

            fn next_history( &mut self, n: usize ) -> io::Result<()> { self.write.next_history( n ) }

            fn prev_history( &mut self, n: usize ) -> io::Result<()> { self.write.prev_history( n ) }

            pub fn select_history_entry( &mut self, new:Option<usize> ) -> io::Result<()> { self.write.select_history_entry( new ) }

            pub fn completions( &self ) -> Option<&[Completion]> { self.read.completions.as_ref().map( |v| &v[..] ) }

            pub fn set_completions( &mut self, completions:Option<Vec<Completion>> ) {
                self.read.completions = completions;
            }

            fn execute_sequence( &mut self ) -> io::Result<()>
            {
                /*
                match self.find_binding( &self.read.sequence ) {
                    FindResult::Found( cmd ) =>
                    {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.read.state = InputState::NewSequence;
                        self.execute_command( cmd, n, ch )?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => {
                        self.read.state = InputState::NewSequence;
                        self.insert_first_char()?;
                    }
                    FindResult::Incomplete =>
                    {
                        let expiry = None;
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                    FindResult::Undecided( _ ) =>
                    {
                        let expiry = self.keyseq_expiry();
                        self.read.state = InputState::ContinueSequence{expiry};
                    }
                } */

                Ok( () )
            }

            fn force_execute_sequence( &mut self ) -> io::Result<()>
            {
                /*
                self.read.state = InputState::NewSequence;

                match self.find_binding( &self.read.sequence ) {
                    FindResult::Found( cmd ) |
                    FindResult::Undecided( cmd ) =>
                    {
                        let ch = self.read.sequence.chars().last().unwrap();
                        let n = self.write.input_arg.to_i32();

                        self.execute_command( cmd, n, ch )?;
                        self.read.sequence.clear();
                    }
                    FindResult::NotFound => { self.insert_first_char()?; }
                    FindResult::Incomplete => unreachable!(),
                } */

                Ok( () )
            }

            fn insert_first_char( &mut self ) -> io::Result<()> {
                let ( first, rest ) = {
                    let mut chars = self.read.sequence.chars();

                    ( chars.next().unwrap(), chars.as_str().to_owned() )
                };

                self.read.sequence.clear();

                if is_printable( first ) {
                    let n = self.write.input_arg.to_i32();
                    self.execute_command( Command::SelfInsert, n, first )?;
                }

                if !rest.is_empty() {
                    self.read.queue_input( &rest );
                }

                Ok( () )
            }
            /*
            fn find_binding( &self, seq:&str ) -> FindResult<Command> { self.read.bindings.find( seq ).cloned() } */

            fn get_function( &self, name:&str ) -> Option<&Arc<dyn Function<Term>>> { self.read.functions.get( name ) }
            /*
            fn is_abort( &self, ch:char ) -> bool {
                let mut buf = [0; 4];
                let s = ch.encode_utf8( &mut buf );

                self.find_binding( &s ) == FindResult::Found( Command::Abort )
            } */
            fn execute_command( &mut self, cmd: Command, n: i32, ch:char ) -> io::Result<()> 
            {
                use system::command::Command::*;

                let mut category = cmd.category();

                if self.read.overwrite_mode {
                    match cmd {
                        DigitArgument | SelfInsert => (),
                        BackwardDeleteChar if n >= 0 => (),
                        _ => self.read.overwritten_chars.clear()
                    }
                }

                match cmd {
                    Abort => (),
                    AcceptLine => { self.accept_input()?; }
                    Complete => {
                        if !self.read.disable_completion {
                            self.complete_word()?;
                        } else if is_printable( ch ) {
                            self.execute_command( SelfInsert, n, ch )?;
                        }
                    }
                    InsertCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some( completions ) = self.read.completions.take() {
                            self.insert_completions( &completions )?;
                            self.read.completions = Some( completions );
                        }
                    }
                    PossibleCompletions => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if let Some( completions ) = self.read.completions.take() {
                            self.show_completions( &completions )?;
                            self.read.completions = Some( completions );
                        }
                    }
                    MenuComplete => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.next_completion( n as usize )?;
                        } else {
                            self.prev_completion( ( -n ) as usize )?;
                        }
                    }
                    MenuCompleteBackward => {
                        if self.read.completions.is_none() {
                            self.build_completions();
                        }

                        if n > 0 {
                            self.prev_completion( n as usize )?;
                        } else {
                            self.next_completion( ( -n ) as usize )?;
                        }
                    }
                    DigitArgument => {
                        self.read.state = InputState::Number;
                        self.write.set_digit_from_char( ch );
                        self.write.redraw_prompt( PromptType::Number )?;
                    }
                    SelfInsert => {
                        if n > 0 {
                            let n = n as usize;

                            if self.read.overwrite_mode {
                                self.overwrite( n, ch )?;
                            } else {
                                self.insert( n, ch )?;
                            }

                            if self.read.blink_matching_paren {
                                if let Some( open ) = get::open_parenthesis( ch ) {
                                    if let Some( pos ) = regex::find_matching_parenthesis( 
                                            &self.write.buffer[..self.write.cursor],
                                            &self.read.string_chars, open, ch ) {
                                        self.blink( pos )?;
                                    }
                                }
                            }
                        }
                    }
                    TabInsert => {
                        if n > 0 {
                            self.insert( n as usize, '\t' )?;
                        }
                    }
                    InsertComment => {
                        if self.explicit_arg() &&
                                self.write.buffer.starts_with( &self.read.comment_begin[..] ) {
                            self.write.move_to( 0 )?;
                            let n = self.read.comment_begin.len();

                            self.delete_range( ..n )?;
                            self.accept_input()?;
                        } else {
                            self.write.move_to( 0 )?;
                            let s = self.read.comment_begin.clone();
                            self.insert_str( &s )?;
                            self.accept_input()?;
                        }
                    }
                    BackwardChar => {
                        if n > 0 {
                            self.write.backward_char( n as usize )?;
                        } else if n < 0 {
                            self.write.forward_char( ( -n ) as usize )?;
                        }
                    }
                    ForwardChar => {
                        if n > 0 {
                            self.write.forward_char( n as usize )?;
                        } else if n < 0 {
                            self.write.backward_char( ( -n ) as usize )?;
                        }
                    }
                    CharacterSearch => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: false,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: ( -n ) as usize,
                                backward: true,
                            };
                        }
                    }
                    CharacterSearchBackward => {
                        if n >= 0 {
                            self.read.state = InputState::CharSearch{
                                n: n as usize,
                                backward: true,
                            }
                        } else {
                            self.read.state = InputState::CharSearch{
                                n: ( -n ) as usize,
                                backward: false,
                            };
                        }
                    }
                    BackwardWord => {
                        if n > 0 {
                            self.backward_word( n as usize )?;
                        } else if n < 0 {
                            self.forward_word( ( -n ) as usize )?;
                        }
                    }
                    ForwardWord => {
                        if n > 0 {
                            let pos = regex::forward_word( n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            self.write.move_to( pos )?;
                        } else if n < 0 {
                            let pos = regex::forward_word( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            self.write.move_to( pos )?;
                        }
                    }
                    BackwardKillLine =>
                    {
                        let r = ..self.write.cursor;
                        self.kill_range( r )?;
                    }
                    KillLine =>
                    {
                        let r = self.write.cursor..;
                        self.kill_range( r )?;
                    }
                    BackwardKillWord => {
                        if n > 0 {
                            let pos = regex::backward_word( n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = pos..self.write.cursor;
                            self.kill_range( r )?;
                        } else if n < 0 {
                            let pos = regex::forward_word( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = self.write.cursor..pos;
                            self.kill_range( r )?;
                        }
                    }
                    KillWord => {
                        if n > 0 {
                            let pos = regex::forward_word( n as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = self.write.cursor..pos;
                            self.kill_range( r )?;
                        } else if n < 0 {
                            let pos = regex::backward_word( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor, &self.read.word_break );
                            let r = pos..self.write.cursor;
                            self.kill_range( r )?;
                        }
                    }
                    UnixWordRubout => {
                        if n > 0 {
                            let pos = regex::backward_word( n as usize,
                                &self.write.buffer, self.write.cursor, " \t\n" );
                            let r = pos..self.write.cursor;
                            self.kill_range( r )?;
                        } else if n < 0 {
                            let pos = regex::forward_word( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor, " \t\n" );
                            let r = self.write.cursor..pos;
                            self.kill_range( r )?;
                        }
                    }
                    ClearScreen => { self.write.clear_screen()?; }
                    BeginningOfLine => self.write.move_to( 0 )?,
                    EndOfLine => self.write.move_to_end()?,
                    BackwardDeleteChar => {
                        if n > 0 {
                            if self.read.overwrite_mode {
                                self.overwrite_back( n as usize )?;
                            } else {
                                let pos = char::backward( n as usize,
                                    &self.write.buffer, self.write.cursor );
                                let r = pos..self.write.cursor;
                                self.delete_range( r )?;
                            }
                        } else if n < 0 {
                            let pos = char::forward( ( -n ) as usize,
                                &self.write.buffer, self.write.cursor );
                            let r = self.write.cursor..pos;
                            self.delete_range( r )?;
                        }
                    }
                    DeleteChar => {
                        if n > 0 {
                            let pos = char::forward( n as usize,
                                &self.write.buffer, self.write.cursor );
                            let r = self.write.cursor..pos;
                            self.delete_range( r )?;
                        } else if n < 0 {
                            let pos = char::backward( n as usize,
                                &self.write.buffer, self.write.cursor );
                            let r = pos..self.write.cursor;
                            self.delete_range( r )?;
                        }
                    }
                    TransposeChars => {
                        if n != 0 && self.write.cursor != 0 {
                            let ( src, dest );

                            if !self.explicit_arg() && self.write.cursor == self.write.buffer.len() {
                                let end = char::backward( 1, &self.write.buffer, self.write.cursor );
                                let start = char::backward( 1, &self.write.buffer, end );

                                src = start..end;
                                dest = end..self.write.cursor;
                            } else {
                                let start = char::backward( 1, &self.write.buffer, self.write.cursor );
                                let end = self.write.cursor;

                                src = start..end;

                                dest = if n < 0 {
                                    let back = char::backward( ( -n ) as usize, &self.write.buffer, start );
                                    back..start
                                } else {
                                    let fwd = char::forward( n as usize + 1, &self.write.buffer, start );
                                    end..fwd
                                };
                            }

                            self.transpose_range( src, dest )?;
                        }
                    }
                    TransposeWords => {
                        if n != 0 {
                            if let Some( first ) = regex::first_word( &self.write.buffer[..self.write.cursor], &self.read.word_break ) {
                                let start = regex::word_start( &self.write.buffer, self.write.cursor, &self.read.word_break );

                                if first != start {
                                    let ( src, dest );

                                    if !self.explicit_arg() && start == self.write.buffer.len() {
                                        let dest_start = regex::backward_word( 1, &self.write.buffer, start, &self.read.word_break );
                                        let dest_end = regex::word_end( &self.write.buffer, dest_start, &self.read.word_break );

                                        let src_start = regex::backward_word( 1, &self.write.buffer, dest_start, &self.read.word_break );
                                        let src_end = regex::word_end( &self.write.buffer, src_start, &self.read.word_break );

                                        src = src_start..src_end;
                                        dest = dest_start..dest_end;
                                    } else {
                                        let src_start = regex::backward_word( 1, &self.write.buffer, start, &self.read.word_break );
                                        let src_end = regex::word_end( &self.write.buffer, src_start, &self.read.word_break );

                                        src = src_start..src_end;

                                        dest = if n < 0 {
                                            regex::back_n_words( ( -n ) as usize, &self.write.buffer, src_start, &self.read.word_break )
                                        } else {
                                            regex::forward_n_words( n as usize, &self.write.buffer, src_start, &self.read.word_break )
                                        };
                                    }

                                    self.transpose_range( src, dest )?;
                                }
                            }
                        }
                    }
                    BeginningOfHistory => { self.select_history_entry( Some( 0 ) )?; }
                    EndOfHistory => { self.select_history_entry( None )?; }
                    NextHistory => {
                        if n > 0 {
                            self.next_history( n as usize )?;
                        } else if n < 0 {
                            self.prev_history( ( -n ) as usize )?;
                        }
                    }
                    PreviousHistory => {
                        if n > 0 {
                            self.prev_history( n as usize )?;
                        } else if n < 0 {
                            self.next_history( ( -n ) as usize )?;
                        }
                    }
                    ForwardSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history( false )?;
                        } else {
                            self.write.start_search_history( false )?;
                        }
                    }
                    ReverseSearchHistory => {
                        self.read.state = InputState::TextSearch;
                        if self.read.last_cmd == Category::IncrementalSearch {
                            self.write.continue_search_history( true )?;
                        } else {
                            self.write.start_search_history( true )?;
                        }
                    }
                    HistorySearchForward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search( false )?;
                        } else {
                            self.write.start_history_search( false )?;
                        }
                    }
                    HistorySearchBackward => {
                        if self.read.last_cmd == Category::Search {
                            self.write.continue_history_search( true )?;
                        } else {
                            self.write.start_history_search( true )?;
                        }
                    }
                    QuotedInsert => {
                        self.read.state = InputState::QuotedInsert( 
                            if n >= 0 { n as usize } else { 0 } );
                    }
                    OverwriteMode => {
                        self.read.overwrite_mode = !self.read.overwrite_mode;

                        if !self.read.overwrite_mode {
                            self.read.overwritten_append = 0;
                            self.read.overwritten_chars.clear();
                        }

                        let mode = if self.read.overwrite_mode {
                            CursorMode::Overwrite
                        } else {
                            CursorMode::Normal
                        };

                        self.write.set_cursor_mode( mode )?;
                    }
                    Yank => { self.yank()?; }
                    YankPop => { self.yank_pop()?; }
                    Custom( ref name ) => {
                        if let Some( fun ) = self.get_function( name ).cloned() {
                            fun.execute( self, n, ch )?;

                            category = fun.category();
                        }
                    }
                    Macro( ref seq ) => { self.read.queue_input( seq ); }
                }

                if category != Category::Digit {
                    self.write.input_arg = Digit::None;
                    self.write.explicit_arg = false;

                    self.read.last_cmd = category;

                    if category != Category::Complete {
                        self.read.completions = None;
                    }

                    if category != Category::Yank {
                        self.read.last_yank = None;
                    }
                }

                Ok( () )
            }

            pub fn accept_input( &mut self ) -> io::Result<()> {
                self.write.move_to_end()?;
                self.write.write_str( "\n" )?;
                self.read.input_accepted = true;
                self.write.is_prompt_drawn = false;
                Ok( () )
            }

            pub fn blink( &mut self, pos: usize ) -> io::Result<()> {
                self.write.blink( pos )?;

                self.read.max_wait_duration = Some( BLINK_DURATION );

                Ok( () )
            }

            fn check_expire_blink( &mut self, now: Instant ) -> io::Result<()>
            {
                /*if self.write.check_expire_blink( now )? {
                    self.read.max_wait_duration = None;
                }*/

                Ok( () )
            }

            fn check_expire_sequence( &mut self, now: Instant ) -> io::Result<()> {
                if let InputState::ContinueSequence{expiry: Some( expiry )} = self.read.state {
                    if now >= expiry {
                        self.read.max_wait_duration = None;
                        self.force_execute_sequence()?;
                    }
                }

                Ok( () )
            }

            fn keyseq_expiry( &mut self ) -> Option<Instant> {
                if let Some( t ) = self.read.keyseq_timeout {
                    self.read.max_wait_duration = Some( t );
                    Some( Instant::now() + t )
                } else {
                    None
                }
            }

            pub fn check_expire_timeout( &mut self ) -> io::Result<()> {
                let now = Instant::now();

                self.check_expire_blink( now )?;
                self.check_expire_sequence( now )
            }

            fn expire_blink( &mut self ) -> io::Result<()> {
                self.read.max_wait_duration = None;
                self.write.expire_blink()
            }

            fn build_completions( &mut self ) {
                let compl = self.read.completer.clone();
                let end = self.write.cursor;
                let start = compl.word_start( &self.write.buffer, end, self );

                if start > end {
                    panic!( "Completer::word_start returned invalid index; \
                        start > end ( {} > {} )", start, end );
                }

                let unquoted = compl.unquote( &self.write.buffer[start..end] ).into_owned();

                let completions = compl.complete( &unquoted, self, start, end );
                let n_completions = completions.as_ref().map_or( 0, |c| c.len() );

                self.read.completions = completions;
                self.read.completion_index = n_completions;
                self.read.completion_start = start;
                self.read.completion_prefix = end;
            }

            fn complete_word( &mut self ) -> io::Result<()> {
                if let Some( completions ) = self.read.completions.take() {
                    if completions.len() == 1 {
                        self.substitute_completion( &completions[0] )?;
                    } else {
                        self.show_completions( &completions )?;
                        self.read.completions = Some( completions );
                    }
                } else {
                    self.build_completions();
                    let completions = self.read.completions.take().unwrap_or_default();

                    if completions.len() == 1 {
                        self.substitute_completion( &completions[0] )?;
                    } else if !completions.is_empty() {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;

                        {
                            let pfx = regex::longest_common_prefix( completions.iter()
                                .map( |compl| &compl.completion[..] ) )
                                .unwrap_or_default();
                            self.replace_str_forward( start..end, &pfx )?;
                        }

                        self.read.completions = Some( completions );
                    }
                }

                Ok( () )
            }

            fn substitute_completion( &mut self, compl:&Completion ) -> io::Result<()> {
                let mut s = self.read.completer.quote( &compl.completion );

                if let Some( suffix ) = compl.suffix.with_default( self.read.completion_append_character ) {
                    s.to_mut().push( suffix );
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;
                self.replace_str_forward( start..end, &s )
            }

            fn insert_completions( &mut self, completions:&[Completion] ) -> io::Result<()> {
                let mut words = String::new();

                for compl in completions {
                    words.push_str( &self.read.completer.unquote( &compl.completion ) );
                    words.push( ' ' );
                }

                let start = self.read.completion_start;
                let end = self.write.cursor;

                self.replace_str_forward( start..end, &words )
            }

            fn show_completions( &mut self, completions:&[Completion] ) -> io::Result<()> {
                if completions.is_empty() {
                    return Ok( () );
                }

                let eff_width = self.write.screen_size.columns
                    .min( self.read.completion_display_width );

                let completions = completions.iter()
                    .map( |compl| display_str( &compl.display(), Display::default() ).into_owned() )
                    .collect::<Vec<_>>();

                let cols = format_columns( &completions, eff_width,
                    self.read.print_completions_horizontally );
                let table = Table::new( &completions, cols.as_ref().map( |c| &c[..] ),
                    self.read.print_completions_horizontally );

                self.write.write_str( "\n" )?;

                let n_completions = completions.len();

                if self.read.page_completions &&
                        n_completions >= self.read.completion_query_items {
                    self.start_page_completions( n_completions )
                } else {
                    self.show_list_completions( table )?;
                    self.write.draw_prompt()
                }
            }

            fn start_page_completions( &mut self, n_completions: usize ) -> io::Result<()> {
                self.read.state = InputState::CompleteIntro;
                self.write.redraw_prompt( PromptType::CompleteIntro( n_completions ) )
            }

            fn end_page_completions( &mut self ) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.prompt_type = PromptType::Normal;
                self.write.draw_prompt()
            }

            fn is_paging_completions( &self ) -> bool {
                match self.read.state {
                    InputState::CompleteMore( _ ) => true,
                    _ => false
                }
            }

            fn show_completions_page( &mut self, offset: usize ) -> io::Result<()> {
                if let Some( compl ) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min( self.read.completion_display_width );
                    let n_lines = self.write.screen_size.lines - 1;

                    let completions = compl.iter()
                        .map( |compl| display_str( &compl.display(), Display::default() ).into_owned() )
                        .collect::<Vec<_>>();

                    let cols = format_columns( &completions, width,
                        self.read.print_completions_horizontally );
                    let mut table = Table::new( &completions, cols.as_ref().map( |c| &c[..] ),
                        self.read.print_completions_horizontally );

                    for row in table.by_ref().skip( offset ).take( n_lines ) {
                        self.show_completion_line( row )?;
                    }

                    if table.has_more() {
                        self.read.completions = Some( compl );
                        self.read.state = InputState::CompleteMore( offset + n_lines );
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok( () )
            }

            fn show_completions_line( &mut self, offset: usize ) -> io::Result<()> {
                if let Some( compl ) = self.read.completions.take() {
                    let width = self.write.screen_size.columns
                        .min( self.read.completion_display_width );
                    let completions = compl.iter()
                        .map( |compl| display_str( &compl.display(), Display::default() ).into_owned() )
                        .collect::<Vec<_>>();

                    let cols = format_columns( &completions, width,
                        self.read.print_completions_horizontally );
                    let mut table = Table::new( &completions, cols.as_ref().map( |c| &c[..] ),
                        self.read.print_completions_horizontally );

                    if let Some( row ) = table.by_ref().skip( offset ).next() {
                        self.show_completion_line( row )?;
                    }

                    if table.has_more() {
                        self.read.completions = Some( compl );
                        self.read.state = InputState::CompleteMore( offset + 1 );
                        self.write.prompt_type = PromptType::CompleteMore;
                        self.write.draw_prompt()?;
                    } else {
                        self.end_page_completions()?;
                    }
                }

                Ok( () )
            }

            fn show_completion_line<S: AsRef<str>>( &mut self, line: Line<S> ) -> io::Result<()> {
                let mut space = 0;

                for ( width, name ) in line {
                    self.write.move_right( space )?;
                    self.write.write_str( name )?;
                    space = width - name.chars().count();
                }

                self.write.write_str( "\n" )
            }

            fn show_list_completions<S: AsRef<str>>( &mut self, table: Table<S> ) -> io::Result<()> {
                for line in table {
                    let mut space = 0;

                    for ( width, name ) in line {
                        self.write.move_right( space )?;
                        self.write.write_str( name )?;
                        space = width - name.chars().count();
                    }
                    self.write.write_str( "\n" )?;
                }

                Ok( () )
            }

            fn next_completion( &mut self, n: usize ) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or( 0, |c| c.len() );
                let max = len + 1;

                let old = self.read.completion_index;
                let new = ( old + n ) % max;

                if old != new {
                    self.set_completion( new )?;
                }

                Ok( () )
            }

            fn prev_completion( &mut self, n: usize ) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or( 0, |c| c.len() );
                let max = len + 1;

                let old = self.read.completion_index;
                let new = if n <= old {
                    max - old - n
                } else {
                    old - n
                };

                self.set_completion( new )
            }

            fn set_completion( &mut self, new: usize ) -> io::Result<()> {
                let len = self.read.completions.as_ref().map_or( 0, |c| c.len() );
                let old = self.read.completion_index;

                if old != new {
                    self.read.completion_index = new;

                    if new == len {
                        let start = self.read.completion_prefix;
                        let end = self.write.cursor;

                        self.delete_range( start..end )?;
                    } else {
                        let start = self.read.completion_start;
                        let end = self.write.cursor;
                        let s = self.read.completions.as_ref().unwrap()[new]
                            .completion( self.read.completion_append_character ).into_owned();

                        self.replace_str_forward( start..end, &s )?;
                    }
                }

                Ok( () )
            }

            fn abort_search_history( &mut self ) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.read.last_cmd = Category::Other;
                self.write.abort_search_history()
            }

            fn end_search_history( &mut self ) -> io::Result<()> {
                self.read.state = InputState::NewSequence;
                self.write.end_search_history()
            }

            pub fn handle_resize( &mut self, size: Size ) -> io::Result<()> {
                self.expire_blink()?;

                if self.is_paging_completions() {
                    self.end_page_completions()?;
                }

                self.write.screen_size = size;

                let p = self.write.prompt_type;
                self.write.redraw_prompt( p )
            }

            pub fn handle_signal( &mut self, signal: Signal ) -> io::Result<()> {
                self.expire_blink()?;

                match signal {
                    Signal::Continue => { self.write.draw_prompt()?; }
                    Signal::Interrupt => {
                        self.read.macro_buffer.clear();
                        self.write.move_to_end()?;

                        if self.read.echo_control_characters {
                            self.write.write_str( "^C" )?;
                        }

                        self.write.write_str( "\n" )?;
                        self.reset_input();
                        self.write.draw_prompt()?;
                    }
                    _ => ()
                }

                Ok( () )
            }

            fn backward_word( &mut self, n: usize ) -> io::Result<()> {
                let pos = regex::backward_word( n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break );
                self.write.move_to( pos )
            }

            fn forward_word( &mut self, n: usize ) -> io::Result<()> {
                let pos = regex::forward_word( n,
                    &self.write.buffer, self.write.cursor, &self.read.word_break );
                self.write.move_to( pos )
            }

            pub fn delete_range<R: ops::RangeArgument<usize>>( &mut self, range: R ) -> io::Result<()> { self.write.delete_range( range ) }
            pub fn kill_range<R: ops::RangeArgument<usize>>( &mut self, range: R ) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or( 0 );
                let end = range.end().cloned().unwrap_or_else( || self.write.buffer.len() );
                let len = end - start;

                if len != 0 {
                    let buf = self.write.buffer[start..end].to_owned();

                    if self.read.last_cmd != Category::Kill {
                        self.push_kill_ring( buf );
                    } else if end == self.write.cursor {
                        self.prepend_kill_ring( buf );
                    } else {
                        self.append_kill_ring( buf );
                    }

                    self.delete_range( start..end )?;
                }

                Ok( () )
            }

            fn push_kill_ring( &mut self, s: String ) {
                if self.read.kill_ring.len() == self.read.kill_ring.capacity() {
                    self.read.kill_ring.pop_back();
                }
                self.read.kill_ring.push_front( s );
            }

            fn rotate_kill_ring( &mut self ) {
                if let Some( kill ) = self.read.kill_ring.pop_front() {
                    self.read.kill_ring.push_back( kill );
                }
            }

            fn append_kill_ring( &mut self, s: String ) {
                if let Some( kill ) = self.read.kill_ring.front_mut() {
                    kill.push_str( &s );
                    return;
                }
                self.push_kill_ring( s );
            }

            fn prepend_kill_ring( &mut self, s: String ) {
                if let Some( kill ) = self.read.kill_ring.front_mut() {
                    kill.insert_str( 0, &s );
                    return;
                }
                self.push_kill_ring( s );
            }

            pub fn transpose_range( &mut self, src: Range<usize>, dest: Range<usize> )
                    -> io::Result<()> { self.write.transpose_range( src, dest ) }

            pub fn yank( &mut self ) -> io::Result<()> {
                if let Some( kill ) = self.read.kill_ring.front().cloned() {
                    let start = self.write.cursor;
                    self.read.last_yank = Some( ( start, start + kill.len() ) );

                    self.insert_str( &kill )?;
                }

                Ok( () )
            }

            pub fn yank_pop( &mut self ) -> io::Result<()> {
                if let Some( ( start, end ) ) = self.read.last_yank {
                    self.rotate_kill_ring();

                    if let Some( kill ) = self.read.kill_ring.front().cloned() {
                        self.read.last_yank = Some( ( start, start + kill.len() ) );

                        self.write.move_to( start )?;
                        self.replace_str_forward( start..end, &kill )?;
                    }
                }

                Ok( () )
            }

            fn overwrite( &mut self, n: usize, ch:char ) -> io::Result<()> {
                let start = self.write.cursor;
                let end = char::forward( n, &self.write.buffer, start );

                {
                    let over = &self.write.buffer[start..end];
                    let n_chars = over.chars().count();

                    if n > n_chars {
                        self.read.overwritten_append += n - n_chars;
                    }

                    if !over.is_empty() {
                        self.read.overwritten_chars.push_str( &over );
                    }
                }

                let s = char::repeat( ch, n );
                self.replace_str_forward( start..end, &s )
            }

            fn overwrite_back( &mut self, mut n: usize ) -> io::Result<()> {
                if self.read.overwritten_append != 0 {
                    let n_del = n.min( self.read.overwritten_append );

                    let pos = char::backward( n_del, &self.write.buffer, self.write.cursor );
                    let r = pos..self.write.cursor;
                    self.delete_range( r )?;

                    self.read.overwritten_append -= n_del;
                    n -= n_del;
                }

                if n != 0 && !self.read.overwritten_chars.is_empty() {
                    let n_repl = n.min( self.read.overwritten_chars.chars().count() );

                    let pos = char::backward( n_repl, &self.write.buffer, self.write.cursor );

                    let over_pos = char::backward( n_repl,
                        &self.read.overwritten_chars, self.read.overwritten_chars.len() );

                    let over = self.read.overwritten_chars.drain( over_pos.. ).collect::<String>();

                    let r = pos..self.write.cursor;
                    self.replace_str_backward( r, &over )?;

                    n -= n_repl;
                }

                if n != 0 {
                    self.write.backward_char( n )?;
                }

                Ok( () )
            }

            pub fn insert( &mut self, n: usize, ch:char ) -> io::Result<()> {
                if n != 0 {
                    let s = char::repeat( ch, n );
                    self.insert_str( &s )?;
                }

                Ok( () )
            }

            pub fn insert_str( &mut self, s:&str ) -> io::Result<()> { self.write.insert_str( s ) }

            pub fn replace_str_backward<R: ops::RangeArgument<usize>>( &mut self,
                    range: R, s:&str ) -> io::Result<()> {
                self.replace_str_impl( range, s )?;
                let len = self.write.buffer.len();
                self.write.move_from( len )
            }

            pub fn replace_str_forward<R: ops::RangeArgument<usize>>( &mut self,
                    range: R, s:&str ) -> io::Result<()> {
                self.replace_str_impl( range, s )?;
                self.write.cursor += s.len();
                let len = self.write.buffer.len();
                self.write.move_from( len )
            }

            fn replace_str_impl<R: ops::RangeArgument<usize>>( &mut self,
                    range: R, s:&str ) -> io::Result<()> {
                let start = range.start().cloned().unwrap_or( 0 );
                let end = range.end().cloned().unwrap_or_else( || self.write.buffer.len() );
                self.write.move_to( start )?;

                let _ = self.write.buffer.drain( start..end );
                let cursor = self.write.cursor;
                self.write.buffer.insert_str( cursor, s );

                self.write.draw_buffer( cursor )?;
                self.write.clear_to_screen_end()
            }
        }
    }

    pub mod reader
    {
        /*!
        */
        use ::
        {
            borrow::{ Cow },
            collections::{ HashMap, VecDeque },
            mem::{ replace },
            ops::{ Deref, DerefMut },
            path::{ Path, PathBuf },
            regex::{ match_name },
            sync::{ Arc, MutexGuard },
            system::
            {
                self,
                command::{ Category, Command },
                common::sys::{ user_init_file, env_init_file, system_init_file },
                complete::{ Completer, Completion, DummyCompleter },
                function::{ Function },
                input::{parse_file, Directive},
                interface::{ Interface },
                prompter::{ Prompter },
                terminal::
                {
                    RawRead, Terminal, TerminalReader,
                },
                variables::{ Variable, Variables, VariableIter },
            },
            time::std::{ Duration, Instant },
            *,
        };
        /*
            use mortal::SequenceMap;
            use crate::util::{first_char, match_name};
        */

        pub const STRING_CHARS:&str = "\"'";

        pub const WORD_BREAK_CHARS:&str = " \t\n\"\\'`@$><=;|&{( ";

        pub const START_INVISIBLE:char = '\x01';

        pub const END_INVISIBLE:char = '\x02';

        const MAX_KILLS: usize = 10;

        pub struct Reader<'a, Term: 'a + Terminal>
        {
            iface:&'a Interface<Term>,
            lock: ReadLock<'a, Term>,
        }

        pub struct Read<Term: Terminal> 
        {

            pub application: Cow<'static, str>,
            pub input_buffer: Vec<u8>,
            pub macro_buffer: String,
            //pub bindings:Option<SequenceMap<Cow<'static, str>, Command>>,
            pub functions: HashMap<Cow<'static, str>, Arc<dyn Function<Term>>>,
            pub sequence: String,
            pub input_accepted: bool,
            pub overwrite_mode: bool,
            pub overwritten_append: usize,
            pub overwritten_chars: String,
            pub completer: Arc<dyn Completer<Term>>,
            pub completion_append_character:Option<char>,
            pub completions:Option<Vec<Completion>>,
            pub completion_index: usize,
            pub completion_start: usize,
            pub completion_prefix: usize,
            pub string_chars: Cow<'static, str>,
            pub word_break: Cow<'static, str>,
            pub last_cmd: Category,
            pub last_yank:Option<( usize, usize )>,
            pub kill_ring: VecDeque<String>,
            pub catch_signals: bool,
            pub ignore_signals: system::terminal::SignalSet,
            pub report_signals: system::terminal::SignalSet,
            pub last_resize:Option<system::terminal::Size>,
            pub last_signal:Option<system::terminal::Signal>,
            variables: Variables,
            pub state: InputState,
            pub max_wait_duration:Option<Duration>,
        }

        pub struct ReadLock<'a, Term: 'a + Terminal>
        {
            term: Box<dyn TerminalReader<Term> + 'a>,
            data: MutexGuard<'a, Read<Term>>,
        }

        #[derive( Debug )]
        pub enum ReadResult
        {

            Eof,
            Input( String ),
            Signal( system::terminal::Signal ),
        }

        #[derive( Copy, Clone, Debug )]
        pub enum InputState {
            Inactive,
            NewSequence,
            ContinueSequence{
                expiry:Option<Instant>,
            },
            Number,
            CharSearch{
                n: usize,
                backward: bool,
            },
            TextSearch,
            CompleteIntro,
            CompleteMore( usize ),
            QuotedInsert( usize ),
        }

        impl<'a, Term: 'a + Terminal> Reader<'a, Term> {
            pub fn new( iface:&'a Interface<Term>, lock: ReadLock<'a, Term> )
                    -> Reader<'a, Term> { Reader{iface, lock} }

            pub fn read_line( &mut self ) -> io::Result<ReadResult> {
                loop {
                    if let Some( res ) = self.read_line_step( None )? {
                        return Ok( res );
                    }
                }
            }

            pub fn read_line_step( &mut self, timeout:Option<Duration> )
                    -> io::Result<Option<ReadResult>> {
                self.initialize_read_line()?;

                let state = self.prepare_term()?;
                let res = self.read_line_step_impl( timeout );
                self.lock.term.restore( state )?;

                res
            }

            pub fn cancel_read_line( &mut self ) -> io::Result<()> { self.end_read_line() }

            fn initialize_read_line( &mut self ) -> io::Result<()> {
                if !self.lock.is_active() {
                    self.prompter().start_read_line()?;
                }
                Ok( () )
            }

            fn read_line_step_impl( &mut self, timeout:Option<Duration> ) -> io::Result<Option<ReadResult>> 
            {
                let do_read = if self.lock.is_input_available()
                {
                    self.lock.term.wait_for_input( Some( Duration::from_secs( 0 ) ) )?
                } 
                
                else 
                {
                    let timeout = limit_duration( timeout, self.lock.max_wait_duration );
                    self.lock.term.wait_for_input( timeout )?
                };

                if do_read 
                {
                    self.lock.read_input()?;
                }

                if let Some( size ) = self.lock.take_resize() 
                {
                    self.handle_resize( size )?;
                }

                if let Some( sig ) = self.lock.take_signal() 
                {
                    if self.lock.report_signals.contains( sig ) {
                        return Ok( Some( ReadResult::Signal( sig ) ) );
                    }
                    if !self.lock.ignore_signals.contains( sig ) {
                        self.handle_signal( sig )?;
                    }
                }
                
                {
                    let mut prompter = self.prompter();

                    prompter.check_expire_timeout()?;
                    
                    let mut macro_len = prompter.read.data.macro_buffer.len();

                    while prompter.read.is_input_available() {
                        if let Some( ch ) = prompter.read.read_char()? {
                            if let Some( r ) = prompter.handle_input( ch )? {
                                prompter.end_read_line()?;
                                return Ok( Some( r ) );
                            }
                        }

                        let new_macro_len = prompter.read.data.macro_buffer.len();

                        if new_macro_len != 0 && new_macro_len >= macro_len {
                            break;
                        }

                        macro_len = new_macro_len;
                    }
                }

                Ok( None )
            }

            fn end_read_line( &mut self ) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().end_read_line()?;
                }
                Ok( () )
            }

            fn prepare_term( &mut self ) -> io::Result<Term::PrepareState> {
                if self.read_next_raw() {
                    self.lock.term.prepare( true, system::terminal::SignalSet::new() )
                } else {
                    let mut signals = self.lock.report_signals.union( self.lock.ignore_signals );

                    if self.lock.catch_signals {
                        signals.insert( system::terminal::Signal::Interrupt  );
                    }

                    let block_signals = !self.lock.catch_signals;

                    self.lock.term.prepare( block_signals, signals )
                }
            }

            fn read_next_raw( &self ) -> bool {
                match self.lock.state {
                    InputState::QuotedInsert( _ ) => true,
                    _ => false
                }
            }

            pub fn set_buffer( &mut self, buf:&str ) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_buffer( buf )
                } else {
                    self.iface.lock_write_data().set_buffer( buf );
                    Ok( () )
                }
            }

            pub fn set_cursor( &mut self, pos: usize ) -> io::Result<()> {
                if self.lock.is_active() {
                    self.prompter().set_cursor( pos )
                } else {
                    self.iface.lock_write_data().set_cursor( pos );
                    Ok( () )
                }
            }

            pub fn set_prompt( &mut self, prompt:&str ) -> io::Result<()> { self.prompter().set_prompt( prompt ) }

            pub fn add_history( &self, line: String ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history( line );
                }
            }

            pub fn add_history_unique( &self, line: String ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().add_history_unique( line );
                }
            }

            pub fn clear_history( &self ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().clear_history();
                }
            }

            pub fn remove_history( &self, idx: usize ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().remove_history( idx );
                }
            }

            pub fn set_history_size( &self, n: usize ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().set_history_size( n );
                }
            }

            pub fn truncate_history( &self, n: usize ) {
                if !self.lock.is_active() {
                    self.iface.lock_write().truncate_history( n );
                }
            }

            pub fn application( &self ) -> &str { &self.lock.application }

            pub fn set_application<T>( &mut self, application: T )
                     where T: Into<Cow<'static, str>> { self.lock.application = application.into(); }

            pub fn completer( &self ) -> &Arc<dyn Completer<Term>> { &self.lock.completer }

            pub fn set_completer( &mut self, completer: Arc<dyn Completer<Term>> )
                    -> Arc<dyn Completer<Term>> { replace( &mut self.lock.completer, completer ) }
            pub fn get_variable( &self, name:&str ) -> Option<Variable> { self.lock.get_variable( name ) }
            pub fn set_variable( &mut self, name:&str, value:&str ) -> Option<Variable> { self.lock.set_variable( name, value ) }

            pub fn variables( &self ) -> VariableIter { self.lock.variables.iter() }
            pub fn blink_matching_paren( &self ) -> bool { self.lock.blink_matching_paren }

            pub fn set_blink_matching_paren( &mut self, set: bool ) {
                self.lock.blink_matching_paren = set;
            }

            pub fn catch_signals( &self ) -> bool { self.lock.catch_signals }

            pub fn set_catch_signals( &mut self, enabled: bool ) {
                self.lock.catch_signals = enabled;
            }

            pub fn ignore_signal( &self, signal: system::terminal::Signal ) -> bool {
                self.lock.ignore_signals.contains( signal )
            }

            pub fn set_ignore_signal( &mut self, signal: system::terminal::Signal, set: bool ) {
                if set {
                    self.lock.ignore_signals.insert( signal );
                    self.lock.report_signals.remove( signal );
                } else {
                    self.lock.ignore_signals.remove( signal );
                }
            }

            pub fn report_signal( &self, signal: system::terminal::Signal ) -> bool {
                self.lock.report_signals.contains( signal )
            }

            pub fn set_report_signal( &mut self, signal: system::terminal::Signal, set: bool ) {
                if set {
                    self.lock.report_signals.insert( signal );
                    self.lock.ignore_signals.remove( signal );
                } else {
                    self.lock.report_signals.remove( signal );
                }
            }

            pub fn disable_completion( &self ) -> bool { self.lock.disable_completion }

            pub fn set_disable_completion( &mut self, disable: bool ) {
                self.lock.disable_completion = disable;
            }
            pub fn echo_control_characters( &self ) -> bool { self.lock.echo_control_characters }

            pub fn set_echo_control_characters( &mut self, echo: bool ) {
                self.lock.echo_control_characters = echo;
            }

            pub fn completion_append_character( &self ) -> Option<char> { self.lock.completion_append_character }

            pub fn set_completion_append_character( &mut self, ch:Option<char> ) {
                self.lock.completion_append_character = ch;
            }

            pub fn completion_display_width( &self ) -> usize { self.lock.completion_display_width }

            pub fn set_completion_display_width( &mut self, n: usize ) {
                self.lock.completion_display_width = n;
            }
            pub fn completion_query_items( &self ) -> usize { self.lock.completion_query_items }

            pub fn set_completion_query_items( &mut self, n: usize ) {
                self.lock.completion_query_items = n;
            }

            pub fn keyseq_timeout( &self ) -> Option<Duration> { self.lock.keyseq_timeout }

            pub fn set_keyseq_timeout( &mut self, timeout:Option<Duration> ) {
                self.lock.keyseq_timeout = timeout;
            }

            pub fn page_completions( &self ) -> bool { self.lock.page_completions }

            pub fn set_page_completions( &mut self, set: bool ) {
                self.lock.page_completions = set;
            }
            pub fn print_completions_horizontally( &self ) -> bool { self.lock.print_completions_horizontally }

            pub fn set_print_completions_horizontally( &mut self, set: bool ) {
                self.lock.print_completions_horizontally = set;
            }

            pub fn string_chars( &self ) -> &str { &self.lock.string_chars }

            pub fn set_string_chars<T>( &mut self, chars: T )
                     where T: Into<Cow<'static, str>> { self.lock.string_chars = chars.into(); }

            pub fn word_break_chars( &self ) -> &str { &self.lock.word_break }

            pub fn set_word_break_chars<T>( &mut self, chars: T )
                     where T: Into<Cow<'static, str>> { self.lock.word_break = chars.into(); }

            /* pub fn bindings( &self ) -> BindingIter { self.lock.bindings() } */

            pub fn bind_sequence<T>( &mut self, seq: T, cmd: Command ) -> Option<Command>
                     where T: Into<Cow<'static, str>> { self.lock.bind_sequence( seq, cmd ) }
            pub fn bind_sequence_if_unbound<T>( &mut self, seq: T, cmd: Command ) -> bool where
            T:Into<Cow<'static, str>>
            { self.lock.bind_sequence_if_unbound( seq, cmd ) }

            pub fn unbind_sequence( &mut self, seq:&str ) -> Option<Command> { self.lock.unbind_sequence( seq ) }

            pub fn define_function<T>( &mut self, name: T, cmd: Arc<dyn Function<Term>> )
                    -> Option<Arc<dyn Function<Term>>>  where T: Into<Cow<'static, str>> { self.lock.define_function( name, cmd ) }

            pub fn remove_function( &mut self, name:&str ) -> Option<Arc<dyn Function<Term>>> { self.lock.remove_function( name ) }

            pub fn evaluate_directives( &mut self, term:&Term, dirs: Vec<Directive> ) {
                self.lock.data.evaluate_directives( term, dirs )
            }

            pub fn evaluate_directive( &mut self, term:&Term, dir: Directive ) {
                self.lock.data.evaluate_directive( term, dir )
            }

            fn prompter<'b>( &'b mut self ) -> Prompter<'b, 'a, Term> {
                Prompter::new( 
                    &mut self.lock,
                    self.iface.lock_write() )
            }

            fn handle_resize( &mut self, size: system::terminal::Size ) -> io::Result<()> { self.prompter().handle_resize( size ) }

            fn handle_signal( &mut self, sig: system::terminal::Signal ) -> io::Result<()> { self.prompter().handle_signal( sig ) }
        }

        impl<'a, Term: 'a + Terminal> ReadLock<'a, Term> {
            pub fn new( term: Box<dyn TerminalReader<Term> + 'a>, data: MutexGuard<'a, Read<Term>> )
                    -> ReadLock<'a, Term> { ReadLock{term, data} }

            pub fn read_char( &mut self ) -> io::Result<Option<char>> {
                if let Some( ch ) = self.macro_pop() {
                    Ok( Some( ch ) )
                } else if let Some( ch ) = self.decode_input()? {
                    Ok( Some( ch ) )
                } else {
                    Ok( None )
                }
            }

            fn read_input( &mut self ) -> io::Result<()>
            {
                /*
                match self.term.read( &mut self.data.input_buffer )?
                {
                    RawRead::Bytes( _ ) => (),
                    RawRead::Resize( new_size ) => { self.last_resize = Some( new_size ); }
                    RawRead::Signal( sig ) => { self.last_signal = Some( sig ); }
                } */

                Ok( () )
            }

            fn is_input_available( &self ) -> bool {
                !self.data.macro_buffer.is_empty() || match self.peek_input() {
                    Ok( Some( _ ) ) | Err( _ ) => true,
                    Ok( None ) => false
                }
            }

            fn macro_pop( &mut self ) -> Option<char> {
                if self.data.macro_buffer.is_empty() {
                    None
                } else {
                    Some( self.data.macro_buffer.remove( 0 ) )
                }
            }

            fn decode_input( &mut self ) -> io::Result<Option<char>> {
                let res = self.peek_input();

                if let Ok( Some( ch ) ) = res {
                    self.data.input_buffer.drain( ..ch.len_utf8() );
                }

                res
            }

            fn peek_input( &self ) -> io::Result<Option<char>> {
                if self.data.input_buffer.is_empty() {
                    Ok( None )
                } else {
                    char::first( &self.data.input_buffer )
                }
            }

            pub fn reset_data( &mut self ) {
                self.data.reset_data();
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for ReadLock<'a, Term>
        {
            type Target = Read<Term>;
            fn deref( &self ) -> &Read<Term> { &self.data }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for ReadLock<'a, Term> 
        {
            fn deref_mut( &mut self ) -> &mut Read<Term> { &mut self.data }
        }

        impl<Term: Terminal> Deref for Read<Term>
        {
            type Target = Variables;
            fn deref( &self ) -> &Variables { &self.variables }
        }

        impl<Term: Terminal> DerefMut for Read<Term> 
        {
            fn deref_mut( &mut self ) -> &mut Variables { &mut self.variables }
        }

        impl<Term: Terminal> Read<Term>
        {
            pub fn new( term:&Term, application: Cow<'static, str> ) -> Read<Term>
            {
                let mut r = Read{
                    application,
                    //bindings: default_bindings(),
                    functions: HashMap::new(),
                    input_buffer: Vec::new(),
                    macro_buffer: String::new(),
                    sequence: String::new(),
                    input_accepted: false,
                    overwrite_mode: false,
                    overwritten_append: 0,
                    overwritten_chars: String::new(),
                    completer: Arc::new( DummyCompleter ),
                    completion_append_character: Some( ' ' ),
                    completions: None,
                    completion_index: 0,
                    completion_start: 0,
                    completion_prefix: 0,
                    string_chars: STRING_CHARS.into(),
                    word_break: WORD_BREAK_CHARS.into(),
                    last_cmd: Category::Other,
                    last_yank: None,
                    kill_ring: VecDeque::with_capacity( MAX_KILLS ),
                    catch_signals: true,
                    ignore_signals: system::terminal::SignalSet::new(),
                    report_signals: system::terminal::SignalSet::new(),
                    last_resize: None,
                    last_signal: None,
                    variables: Variables::default(),
                    state: InputState::Inactive,
                    max_wait_duration: None,
                };

                r.read_init( term );
                r
            }

            /* pub fn bindings( &self ) -> BindingIter { BindingIter( self.bindings.sequences().iter() ) } */

            pub fn variables( &self ) -> VariableIter { self.variables.iter() }

            fn take_resize( &mut self ) -> Option<system::terminal::Size> { self.last_resize.take() }

            fn take_signal( &mut self ) -> Option<system::terminal::Signal> { self.last_signal.take() }

            pub fn queue_input( &mut self, seq:&str ) { self.macro_buffer.insert_str( 0, seq ); }

            pub fn is_active( &self ) -> bool
            {
                match self.state {
                    InputState::Inactive => false,
                    _ => true
                }
            }

            pub fn reset_data( &mut self )
            {
                self.state = InputState::NewSequence;
                self.input_accepted = false;
                self.overwrite_mode = false;
                self.overwritten_append = 0;
                self.overwritten_chars.clear();
                self.sequence.clear();

                self.completions = None;

                self.last_cmd = Category::Other;
                self.last_yank = None;

                self.last_resize = None;
                self.last_signal = None;
            }

            pub fn bind_sequence<T>( &mut self, seq: T, cmd: Command ) -> Option<Command>
             where T: Into<Cow<'static, str>>
            { 
                None
                /*self.bindings.insert( seq.into(), cmd ) */
            }

            pub fn bind_sequence_if_unbound<T>( &mut self, seq: T, cmd: Command ) -> bool where
            T: Into<Cow<'static, str>>
            {
                false
                /*
                //use mortal::sequence::Entry;

                match self.bindings.entry( seq.into() ) {
                    Entry::Occupied( _ ) => false,
                    Entry::Vacant( ent ) => {
                        ent.insert( cmd );
                        true
                    }
                } */
            }

            pub fn unbind_sequence( &mut self, seq:&str ) -> Option<Command>
            {
                None
                /*self.bindings.remove( seq ).map( |( _, cmd )| cmd ) */
            }

            pub fn define_function<T>( &mut self, name: T, cmd: Arc<dyn Function<Term>> ) 
            -> Option<Arc<dyn Function<Term>>> 
             where 
            T: Into<Cow<'static, str>>
            { self.functions.insert( name.into(), cmd ) }

            pub fn remove_function( &mut self, name:&str ) -> Option<Arc<dyn Function<Term>>>
            { self.functions.remove( name ) }

            fn read_init( &mut self, term:&Term )
            {
                if let Some( path ) = env_init_file()
                {
                    self.read_init_file_if_exists( term, Some( path ) );
                } else {
                    if !self.read_init_file_if_exists( term, user_init_file() ) {
                        self.read_init_file_if_exists( term, system_init_file() );
                    }
                }
            }

            fn read_init_file_if_exists( &mut self, term:&Term, path:Option<PathBuf> ) -> bool
            {
                match path {
                    Some( ref path ) if path.exists() => {
                        self.read_init_file( term, path );
                        true
                    }
                    _ => false
                }
            }

            fn read_init_file( &mut self, term:&Term, path:&Path )
            {
                if let Some( dirs ) = parse_file( path ) {
                    self.evaluate_directives( term, dirs );
                }
            }

            pub fn evaluate_directives( &mut self, term:&Term, dirs: Vec<Directive> )
            {
                for dir in dirs {
                    self.evaluate_directive( term, dir );
                }
            }

            pub fn evaluate_directive( &mut self, term:&Term, dir: Directive )
            {
                match dir 
                {
                    Directive::Bind( seq, cmd ) => { self.bind_sequence( seq, cmd ); }
                    Directive::Conditional{name, value, then_group, else_group} =>
                    {
                        let name = name.as_ref().map( |s| &s[..] );

                        if self.eval_condition( term, name, &value ) {
                            self.evaluate_directives( term, then_group );
                        } else {
                            self.evaluate_directives( term, else_group );
                        }
                    }
                    Directive::SetVariable( name, value ) => { self.set_variable( &name, &value ); }
                }
            }

            fn eval_condition( &self, term:&Term, name:Option<&str>, value:&str ) -> bool
            {
                match name
                {
                    None => self.application == value,
                    Some( "lib" ) => value == "linefeed",
                    Some( "mode" ) => value == "emacs",
                    Some( "term" ) => self.term_matches( term, value ),
                    _ => false
                }
            }

            fn term_matches( &self, term:&Term, value:&str ) -> bool
            { match_name( term.name(), value ) }
        }

        pub struct BindingIter<'a>( slice::Iter<'a, ( Cow<'static, str>, Command )> );

        impl<'a> ExactSizeIterator for BindingIter<'a> {}

        impl<'a> Iterator for BindingIter<'a> 
        {
            type Item = ( &'a str, &'a Command );

            #[inline] fn next( &mut self ) -> Option<Self::Item> { self.0.next().map( |&( ref s, ref cmd )| ( &s[..], cmd ) ) }
            #[inline] fn nth( &mut self, n: usize ) -> Option<Self::Item> { self.0.nth( n ).map( |&( ref s, ref cmd )| ( &s[..], cmd ) ) }
            #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) { self.0.size_hint() }
        }

        impl<'a> DoubleEndedIterator for BindingIter<'a>
        {
            #[inline] fn next_back( &mut self ) -> Option<Self::Item>
            { self.0.next_back().map( |&( ref s, ref cmd )| ( &s[..], cmd ) ) }
        }
        /*
        fn default_bindings() -> Option<SequenceMap<Cow<'static, str>, Command>>
        {
            None
            /*
            use super::command::Command::*;
            SequenceMap::from( vec![
                // Carriage return and line feed
                ( "\r".into(), AcceptLine ),
                ( "\n".into(), AcceptLine ),
                // Possible sequences for arrow keys, Home, End
                ( "\x1b[A".into(), PreviousHistory ),
                ( "\x1b[B".into(), NextHistory ),
                ( "\x1b[C".into(), ForwardChar ),
                ( "\x1b[D".into(), BackwardChar ),
                ( "\x1b[H".into(), BeginningOfLine ),
                ( "\x1b[F".into(), EndOfLine ),
                // More possible sequences for arrow keys, Home, End
                ( "\x1bOA".into(), PreviousHistory ),
                ( "\x1bOB".into(), NextHistory ),
                ( "\x1bOC".into(), ForwardChar ),
                ( "\x1bOD".into(), BackwardChar ),
                ( "\x1bOH".into(), BeginningOfLine ),
                ( "\x1bOF".into(), EndOfLine ),
                // Possible sequences for Insert, Delete
                ( "\x1b[2~".into(), OverwriteMode ),
                ( "\x1b[3~".into(), DeleteChar ),
                // Basic commands
                ( "\x01"    .into(), BeginningOfLine ),           // Ctrl-A
                ( "\x02"    .into(), BackwardChar ),              // Ctrl-B
                ( "\x04"    .into(), DeleteChar ),                // Ctrl-D
                ( "\x05"    .into(), EndOfLine ),                 // Ctrl-E
                ( "\x06"    .into(), ForwardChar ),               // Ctrl-F
                ( "\x07"    .into(), Abort ),                     // Ctrl-G
                ( "\x08"    .into(), BackwardDeleteChar ),        // Ctrl-H
                ( "\x0b"    .into(), KillLine ),                  // Ctrl-K
                ( "\x0c"    .into(), ClearScreen ),               // Ctrl-L
                ( "\x0e"    .into(), NextHistory ),               // Ctrl-N
                ( "\x10"    .into(), PreviousHistory ),           // Ctrl-P
                ( "\x12"    .into(), ReverseSearchHistory ),      // Ctrl-R
                ( "\x14"    .into(), TransposeChars ),            // Ctrl-T
                ( "\x15"    .into(), BackwardKillLine ),          // Ctrl-U
                ( "\x16"    .into(), QuotedInsert ),              // Ctrl-V
                ( "\x17"    .into(), UnixWordRubout ),            // Ctrl-W
                ( "\x19"    .into(), Yank ),                      // Ctrl-Y
                ( "\x1d"    .into(), CharacterSearch ),           // Ctrl-]
                ( "\x7f"    .into(), BackwardDeleteChar ),        // Rubout
                ( "\x1b\x08".into(), BackwardKillWord ),          // Escape, Ctrl-H
                ( "\x1b\x1d".into(), CharacterSearchBackward ),   // Escape, Ctrl-]
                ( "\x1b\x7f".into(), BackwardKillWord ),          // Escape, Rubout
                ( "\x1bb"   .into(), BackwardWord ),              // Escape, b
                ( "\x1bd"   .into(), KillWord ),                  // Escape, d
                ( "\x1bf"   .into(), ForwardWord ),               // Escape, f
                ( "\x1bt"   .into(), TransposeWords ),            // Escape, t
                ( "\x1by"   .into(), YankPop ),                   // Escape, y
                ( "\x1b#"   .into(), InsertComment ),             // Escape, #
                ( "\x1b<"   .into(), BeginningOfHistory ),        // Escape, <
                ( "\x1b>"   .into(), EndOfHistory ),              // Escape, >

                // Completion commands
                ( "\t"   .into(), Complete ),             // Tab
                ( "\x1b?".into(), PossibleCompletions ),  // Escape, ?
                ( "\x1b*".into(), InsertCompletions ),    // Escape, *

                // Digit commands
                ( "\x1b-".into(), DigitArgument ),    // Escape, -
                ( "\x1b0".into(), DigitArgument ),    // Escape, 0
                ( "\x1b1".into(), DigitArgument ),    // Escape, 1
                ( "\x1b2".into(), DigitArgument ),    // Escape, 2
                ( "\x1b3".into(), DigitArgument ),    // Escape, 3
                ( "\x1b4".into(), DigitArgument ),    // Escape, 4
                ( "\x1b5".into(), DigitArgument ),    // Escape, 5
                ( "\x1b6".into(), DigitArgument ),    // Escape, 6
                ( "\x1b7".into(), DigitArgument ),    // Escape, 7
                ( "\x1b8".into(), DigitArgument ),    // Escape, 8
                ( "\x1b9".into(), DigitArgument ),    // Escape, 9
            ] ) */
        } */
        fn limit_duration( dur:Option<Duration>, max:Option<Duration> ) -> Option<Duration>
        {
            match ( dur, max )
            {
                ( dur, None ) | ( None, dur ) => dur,
                ( Some( dur ), Some( max ) ) => Some( dur.min( max ) ),
            }
        }
    }

    pub mod table
    {
        /*!
        Provides utilities for formatting strings in a table */
        use ::
        {
            *,
        };
        /*
        */
        const COL_SPACE: usize = 2;

        pub struct Table<'a, S: 'a> {
            strings:&'a [S],
            sizes:Option<&'a [usize]>,
            offset: usize,
            per_col: usize,
            rows: usize,
            horizontal: bool,
        }

        impl<'a, S: 'a + AsRef<str>> Table<'a, S> {

            pub fn new( strs:&'a [S], mut sizes:Option<&'a [usize]>,
                    horizontal: bool ) -> Table<'a, S> {
                if let Some( sz ) = sizes {
                    if sz.is_empty() {
                        sizes = None;
                    }
                }

                let n_strs = strs.len();
                let n_cols = sizes.map_or( 1, |sz| sz.len() );

                let rows = n_strs / n_cols + ( n_strs % n_cols != 0 ) as usize;

                Table{
                    strings: strs,
                    sizes: sizes,
                    offset: 0,
                    per_col: ( strs.len() + ( n_cols - 1 ) ) / n_cols,
                    rows: rows,
                    horizontal: horizontal,
                }
            }

            pub fn has_more( &self ) -> bool { self.offset < self.rows }

            fn num_cols( &self ) -> usize { self.sizes.map_or( 1, |sz| sz.len() ) }
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Table<'a, S>
        {
            type Item = Line<'a, S>;
            fn next( &mut self ) -> Option<Line<'a, S>> {
                if self.offset == self.rows {
                    return None;
                }

                let n = self.num_cols();

                let ( start, end, stride ) = if self.horizontal {
                    let start = self.offset * n;
                    let end = cmp::min( self.strings.len(), start + n );
                    ( start, end, 1 )
                } else {
                    let start = self.offset;
                    let end = cmp::min( self.strings.len(), start + self.per_col * n );
                    ( start, end, self.per_col )
                };

                self.offset += 1;

                Some( Line{
                    strings:&self.strings[start..end],
                    sizes: self.sizes,
                    stride: stride,
                    offset: 0,
                } )
            }
        }

        pub struct Line<'a, S: 'a> 
        {
            strings:&'a [S],
            sizes:Option<&'a [usize]>,
            stride: usize,
            offset: usize,
        }

        impl<'a, S: 'a + AsRef<str>> Iterator for Line<'a, S> 
        {
            type Item = ( usize, &'a str );
            fn next( &mut self ) -> Option<( usize, &'a str )> {
                let s = self.strings.get( self.offset * self.stride )?.as_ref();

                let width = self.sizes.and_then( |sz| sz.get( self.offset ).cloned() )
                    .unwrap_or_else( || s.chars().count() );

                self.offset += 1;

                Some( ( width, s ) )
            }
        }

        pub fn format_columns<S: AsRef<str>>( strs:&[S], screen_width: usize, horizontal: bool )
        -> Option<Vec<usize>>
        {
            if strs.is_empty() {
                return None;
            }

            let n_strs = strs.len();

            let ( mut min_len, mut max_len ) = min_max( strs.iter().map( |s| s.as_ref().chars().count() ) );

            if min_len == 0 { min_len = 1; }
            if max_len == 0 { max_len = 1; }

            let mut min_cols = cmp::min( n_strs, screen_width / max_len );
            let max_cols = cmp::min( n_strs, screen_width / min_len );

            if min_cols <= 1 {
                min_cols = 2;
            }

            if max_cols <= 1 {
                return None;
            }

            let mut col_sizes = if min_cols == max_cols {
                vec![vec![0; max_cols]]
            } else {
                ( min_cols..max_cols + 1 )
                    .map( |n| vec![0; n] ).collect::<Vec<_>>()
            };

            for ( i, s ) in strs.iter().enumerate() {
                let len = s.as_ref().chars().count();

                for cols in &mut col_sizes {
                    let n_cols = cols.len();

                    let col = if horizontal {
                        i % n_cols
                    } else {
                        let per_col = ( n_strs + ( n_cols - 1 ) ) / n_cols;
                        i / per_col
                    };

                    let real_len = if col == n_cols - 1 { len } else { len + COL_SPACE };

                    if real_len > cols[col] {
                        cols[col] = real_len;
                    }
                }
            }

            for cols in col_sizes.into_iter().rev() {
                if cols.iter().fold( 0, |a, b| a + b ) <= screen_width {
                    return Some( cols );
                }
            }

            None
        }

        fn min_max<I>( iter: I ) -> ( usize, usize )  where I: Iterator<Item=usize> {
            let mut min = usize::max_value();
            let mut max = 0;

            for n in iter {
                if n < min {
                    min = n;
                }
                if n + COL_SPACE > max {
                    max = n + COL_SPACE;
                }
            }

            ( min, max )
        }

    }

    pub mod terminal
    {
        /*!
        */
        use ::
        {
            mem::{ zeroed },
            system::
            {
                api::{ * },
                common::{ unix::terminal_read },
            },
            time::std::{ Duration },
            *,
        };
        pub use system::common::{ * };
        /*
        // via: https://github.com/clap-rs/term_size-rs/blob/644f28c3a8811e56edcf42036b5e754dbb24a0d7/src/platform/unix.rs
        use libc::{c_int, c_ulong, winsize, STDERR_FILENO, STDIN_FILENO, STDOUT_FILENO};
        use std::mem::zeroed;
        */

        pub struct DefaultTerminal( system::common::Terminal  );

        pub enum RawRead
        {

            Bytes( usize ),
            Resize( Size ),
            Signal( Signal ),
        }

        pub trait Terminal: Sized + Send + Sync
        {

            type PrepareState;
            /*

            type Reader: TerminalReader;

            type Writer: TerminalWriter;
            */

            fn name( &self ) -> &str;
            fn lock_read<'a>( &'a self ) -> Box<dyn TerminalReader<Self> + 'a>;
            fn lock_write<'a>( &'a self ) -> Box<dyn TerminalWriter<Self> + 'a>;
        }

        pub trait TerminalReader<Term: Terminal>
        {

            fn prepare( &mut self, block_signals: bool, report_signals: SignalSet ) -> io::Result<Term::PrepareState>;

            unsafe fn prepare_with_lock
            ( 
                &mut self,
                lock:&mut dyn TerminalWriter<Term>,
                block_signals: bool,
                report_signals: SignalSet
            ) -> io::Result<Term::PrepareState>;
            fn restore( &mut self, state: Term::PrepareState ) -> io::Result<()>;

            unsafe fn restore_with_lock( &mut self, lock:&mut dyn TerminalWriter<Term>, state: Term::PrepareState )
            -> io::Result<()>;
            fn read( &mut self, buf:&mut Vec<u8> ) -> io::Result<Option<RawRead>>;
            fn wait_for_input( &mut self, timeout:Option<Duration> ) -> io::Result<bool>;
        }

        pub trait TerminalWriter<Term: Terminal>
        {

            fn size( &self ) -> io::Result<Size>;
            fn clear_screen( &mut self ) -> io::Result<()>;
            fn clear_to_screen_end( &mut self ) -> io::Result<()>;
            fn move_up( &mut self, n: usize ) -> io::Result<()>;
            fn move_down( &mut self, n: usize ) -> io::Result<()>;
            fn move_left( &mut self, n: usize ) -> io::Result<()>;
            fn move_right( &mut self, n: usize ) -> io::Result<()>;
            fn move_to_first_column( &mut self ) -> io::Result<()>;
            fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()>;
            fn write( &mut self, s:&str ) -> io::Result<()>;
            fn flush( &mut self ) -> io::Result<()>;
        }

        impl DefaultTerminal
        {

            pub fn new() -> io::Result<DefaultTerminal> { system::common::Terminal::new().map( DefaultTerminal ) }

            pub fn stderr() -> io::Result<DefaultTerminal>
            {
                system::common::Terminal::stderr().map( DefaultTerminal )
            }

            unsafe fn cast_writer<'a>( writer:&'a mut dyn TerminalWriter<Self> ) -> &'a mut TerminalWriteGuard<'a>
            {
                &mut *( writer as *mut _ as *mut TerminalWriteGuard )
            }
        }

        impl Terminal for DefaultTerminal
        {
            type PrepareState = PrepareState;
            fn name( &self ) -> &str { self.0.name() }

            fn lock_read<'a>( &'a self ) -> Box<dyn TerminalReader<Self> + 'a>
            {
                Box::new( self.0.lock_read().unwrap() )
            }

            fn lock_write<'a>( &'a self ) -> Box<dyn TerminalWriter<Self> + 'a>
            {
                Box::new( self.0.lock_write().unwrap() )
            }
        }

        impl<'a> TerminalReader<DefaultTerminal> for TerminalReadGuard<'a>
        {
            fn prepare( &mut self, block_signals: bool, report_signals: SignalSet ) -> io::Result<PrepareState>
            {
                self.prepare( PrepareConfig{
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                } )
            }

            unsafe fn prepare_with_lock
            ( 
                &mut self,
                lock:&mut dyn TerminalWriter<DefaultTerminal>,
                block_signals: bool, report_signals: SignalSet
            ) -> io::Result<PrepareState>
            {
                let lock = DefaultTerminal::cast_writer( lock );

                self.prepare_with_lock( lock, PrepareConfig
                {
                    block_signals,
                    enable_control_flow: !block_signals,
                    enable_keypad: false,
                    report_signals,
                    .. PrepareConfig::default()
                } )
            }

            fn restore( &mut self, state: PrepareState ) -> io::Result<()> { self.restore( state ) }

            unsafe fn restore_with_lock
            ( 
                &mut self,
                lock:&mut dyn TerminalWriter<DefaultTerminal>,
                state: PrepareState
            ) -> io::Result<()>
            {
                let lock = DefaultTerminal::cast_writer( lock );
                self.restore_with_lock( lock, state )
            }

            fn read( &mut self, buf:&mut Vec<u8> ) -> io::Result<Option<RawRead>> 
            { 
                Ok( None )
                //terminal_read( self, buf )
            }

            fn wait_for_input( &mut self, timeout:Option<Duration> ) -> io::Result<bool> { self.wait_event( timeout ) }
        }

        impl<'a> TerminalWriter<DefaultTerminal> for TerminalWriteGuard<'a>
        {
            fn size( &self ) -> io::Result<Size> { self.size() }
            
            fn clear_screen( &mut self ) -> io::Result<()> { self.clear_screen() }
            
            fn clear_to_screen_end( &mut self ) -> io::Result<()> { self.clear_to_screen_end() }
            
            fn move_up( &mut self, n: usize ) -> io::Result<()> { self.move_up( n ) }
            
            fn move_down( &mut self, n: usize ) -> io::Result<()> { self.move_down( n ) }
            
            fn move_left( &mut self, n: usize ) -> io::Result<()> { self.move_left( n ) }
            
            fn move_right( &mut self, n: usize ) -> io::Result<()> { self.move_right( n ) }
            
            fn move_to_first_column( &mut self ) -> io::Result<()> { self.move_to_first_column() }
            
            fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> { self.set_cursor_mode( mode ) }
            
            fn write( &mut self, s:&str ) -> io::Result<()> { self.write_str( s ) }
            
            fn flush( &mut self ) -> io::Result<()> { self.flush() }
        }

        // Unfortunately the actual command is not standardised...
        #[cfg( any( target_os = "linux", target_os = "android" ) )]
        static TIOCGWINSZ: c_ulong = 0x5413;

        #[cfg( any(
            target_os = "macos",
            target_os = "ios",
            target_os = "dragonfly",
            target_os = "freebsd",
            target_os = "netbsd",
            target_os = "openbsd"
         ) )]
        static TIOCGWINSZ: c_ulong = 0x40087468;

        #[cfg( target_os = "solaris" )]
        static TIOCGWINSZ: c_ulong = 0x5468;

        extern "C"
        {
            fn ioctl( fd: c_int, request: c_ulong, ...) -> c_int;
        }

        pub unsafe fn get_dimensions_any() -> winsize
        {
            let mut window: winsize = zeroed();
            let mut result = ioctl(STDOUT_FILENO, TIOCGWINSZ, &mut window);

            if result == -1 {
                window = zeroed();
                result = ioctl(STDIN_FILENO, TIOCGWINSZ, &mut window);
                if result == -1 {
                    window = zeroed();
                    result = ioctl(STDERR_FILENO, TIOCGWINSZ, &mut window);
                    if result == -1 {
                        return zeroed();
                    }
                }
            }
            window
        }
        pub fn dimensions() -> Option<(usize, usize )> {
            let w = unsafe { get_dimensions_any() };

            if w.ws_col == 0 || w.ws_row == 0 {
                None
            } else {
                Some((w.ws_col as usize, w.ws_row as usize  ) )
            }
        }
        // pub unsafe fn give_terminal_to(gid: i32) -> bool
        pub unsafe fn give_to(gid: i32) -> bool
        {
            let mut mask:SignalSet = mem::zeroed();
            let mut old_mask:SignalSet = mem::zeroed();

            sigemptyset( &mut mask );
            sigaddset( &mut mask, SIGTSTP );
            sigaddset( &mut mask, SIGTTIN );
            sigaddset( &mut mask, SIGTTOU );
            sigaddset( &mut mask, SIGCHLD );

            let rcode = pthread_sigmask(libc::SIG_BLOCK, &mask, &mut old_mask);
            
            if rcode != 0
            {
                //log!("failed to call pthread_sigmask");
            }
            
            let rcode = tcsetpgrp(1, gid);
            let given;

            if rcode == -1
            {
                given = false;
                let e = error::no::errno();
                let code = e.0;
                //log!("error in give_terminal_to() {}: {}", code, e);
            }            
            else { given = true; }
            
            let rcode = pthread_sigmask(libc::SIG_SETMASK, &old_mask, &mut mask);
            
            if rcode != 0
            {
                //log!("failed to call pthread_sigmask");
            }

            given
        }
    }

    pub mod variables
    {
        /*!
        Contains types associated with user-configurable variables. */
        use ::
        {
            borrow::{  Cow },
            mem::{ replace },
            time::std::{ Duration },
            *,
        };
        /*
        */

        const KEYSEQ_TIMEOUT_MS: u64 = 500;

        #[derive( Clone )]
        pub struct VariableIter<'a> {
            vars:&'a Variables,
            n: usize,
        }

        #[derive( Clone, Debug )]
        pub enum Variable {

            Boolean( bool ),
            Integer( i32 ),
            String( Cow<'static, str> ),
        }

        impl From<bool> for Variable {
            fn from( b: bool ) -> Variable {
                Variable::Boolean( b )
            }
        }

        impl From<i32> for Variable {
            fn from( i: i32 ) -> Variable {
                Variable::Integer( i )
            }
        }

        impl From<&'static str> for Variable {
            fn from( s:&'static str ) -> Variable {
                Variable::String( s.into() )
            }
        }

        impl From<Cow<'static, str>> for Variable {
            fn from( s: Cow<'static, str> ) -> Variable {
                Variable::String( s )
            }
        }

        impl From<String> for Variable {
            fn from( s: String ) -> Variable {
                Variable::String( s.into() )
            }
        }

        impl fmt::Display for Variable {
            fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
                match *self {
                    Variable::Boolean( b ) => f.write_str( if b { "on" } else { "off" } ),
                    Variable::Integer( n ) => fmt::Display::fmt( &n, f ),
                    Variable::String( ref s ) => fmt::Display::fmt( &s[..], f ),
                }
            }
        }

        macro_rules! define_variables {
            ( $( $field:ident : $ty:ty => ( $name:expr , $conv:ident ,
                    |$gr:ident| $getter:expr , |$sr:ident, $v:ident| $setter:expr ) , )+ ) => {
                static VARIABLE_NAMES:&[&str] = &[ $( $name ),+ ];

                pub struct Variables {
                    $( pub $field : $ty ),*
                }

                impl Variables
                {
                    pub fn get_variable( &self, name:&str ) -> Option<Variable> {
                        match name {
                            $( $name => {
                                let $gr = self;
                                Some( Variable::from( $getter ) )
                            } )+
                            _ => None
                        }
                    }

                    pub fn set_variable( &mut self, name:&str, value:&str )
                            -> Option<Variable> {
                        match name {
                            $( $name => {
                                if let Some( $v ) = $conv( value ) {
                                    let $sr = self;
                                    Some( Variable::from( $setter ) )
                                } else {
                                    None
                                }
                            } )+
                            _ => None
                        }
                    }

                    pub fn iter( &self ) -> VariableIter { VariableIter{vars: self, n: 0} }
                }

                impl<'a> Iterator for VariableIter<'a> {
                    type Item = ( &'static str, Variable );

                    fn next( &mut self ) -> Option<Self::Item>
                    {
                        let res = match VARIABLE_NAMES.get( self.n ).cloned() {
                            $( Some( $name ) => ( $name, {
                                let $gr = self.vars;
                                Variable::from( $getter )
                            } ) , )+
                            _ => return None
                        };

                        self.n += 1;
                        Some( res )
                    }
                }
            }
        }

        define_variables!{
            blink_matching_paren: bool => ( "blink-matching-paren", parse_bool,
                |r| r.blink_matching_paren,
                |r, v| replace( &mut r.blink_matching_paren, v ) ),
            comment_begin: Cow<'static, str> => ( "comment-begin", parse_string,
                |r| r.comment_begin.clone(),
                |r, v| replace( &mut r.comment_begin, v.into() ) ),
            completion_display_width: usize => ( "completion-display-width", parse_usize,
                |r| usize_as_i32( r.completion_display_width ),
                |r, v| usize_as_i32( replace( &mut r.completion_display_width, v ) ) ),
            completion_query_items: usize => ( "completion-query-items", parse_usize,
                |r| usize_as_i32( r.completion_query_items ),
                |r, v| usize_as_i32( replace( &mut r.completion_query_items, v ) ) ),
            disable_completion: bool => ( "disable-completion", parse_bool,
                |r| r.disable_completion,
                |r, v| replace( &mut r.disable_completion, v ) ),
            echo_control_characters: bool => ( "echo-control-characters", parse_bool,
                |r| r.echo_control_characters,
                |r, v| replace( &mut r.echo_control_characters, v ) ),
            keyseq_timeout:Option<Duration> => ( "keyseq-timeout", parse_duration,
                |r| as_millis( r.keyseq_timeout ),
                |r, v| as_millis( replace( &mut r.keyseq_timeout, v ) ) ),
            page_completions: bool => ( "page-completions", parse_bool,
                |r| r.page_completions,
                |r, v| replace( &mut r.page_completions, v ) ),
            print_completions_horizontally: bool => ( "print-completions-horizontally", parse_bool,
                |r| r.print_completions_horizontally,
                |r, v| replace( &mut r.print_completions_horizontally, v ) ),
        }

        impl Default for Variables {
            fn default() -> Variables {
                Variables{
                    blink_matching_paren: false,
                    comment_begin: "#".into(),
                    completion_display_width: usize::max_value(),
                    completion_query_items: 100,
                    disable_completion: false,
                    echo_control_characters: true,
                    keyseq_timeout: Some( Duration::from_millis( KEYSEQ_TIMEOUT_MS ) ),
                    page_completions: true,
                    print_completions_horizontally: false,
                }
            }
        }

        fn parse_bool( s:&str ) -> Option<bool> {
            match s {
                "0" => Some( false ),
                "1" => Some( true ),
                s if s.eq_ignore_ascii_case( "off" ) => Some( false ),
                s if s.eq_ignore_ascii_case( "on" ) => Some( true ),
                _ => None
            }
        }

        fn parse_string( s:&str ) -> Option<String> { Some( s.to_owned() ) }

        fn as_millis( timeout:Option<Duration> ) -> i32 {
            match timeout {
                Some( t ) => {
                    let s = ( t.as_secs() * 1_000 ) as i32;
                    let ms = ( t.subsec_nanos() / 1_000_000 ) as i32;

                    s + ms
                }
                None => -1
            }
        }

        fn parse_duration( s:&str ) -> Option<Option<Duration>> {
            match s.parse::<i32>() {
                Ok( n ) if n <= 0 => Some( None ),
                Ok( n ) => Some( Some( Duration::from_millis( n as u64 ) ) ),
                Err( _ ) => Some( None )
            }
        }

        fn usize_as_i32( u: usize ) -> i32 {
            match u {
                u if u > i32::max_value() as usize => -1,
                u => u as i32
            }
        }

        fn parse_usize( s:&str ) -> Option<usize> {
            match s.parse::<i32>() {
                Ok( n ) if n < 0 => Some( usize::max_value() ),
                Ok( n ) => Some( n as usize ),
                Err( _ ) => None
            }
        }
    }

    pub mod writer
    {
        /*!
        Provides access to terminal write operations. */
        use ::
        {
            borrow::Cow::{ self, Borrowed, Owned },
            char::{ unctrl, ESCAPE, RUBOUT },
            collections::{ vec_deque, VecDeque },
            iter::{ repeat, Skip },
            mem::{ swap },
            ops::{ Deref, DerefMut, Range },
            sync::{ MutexGuard },
            system::
            {
                reader::{START_INVISIBLE, END_INVISIBLE},
                terminal::{CursorMode, Size, Terminal, TerminalWriter},
            },
            time::std::{ Duration, Instant },
            *,
        };
        /*
        */

        pub const BLINK_DURATION: Duration = Duration::from_millis( 500 );

        const COMPLETE_MORE:&'static str = "--More--";

        const MAX_HISTORY: usize = !0;

        const TAB_STOP: usize = 8;        
        const PROMPT_NUM_PREFIX: usize = 6;
        const PROMPT_NUM_SUFFIX: usize = 2;
        const PROMPT_SEARCH_PREFIX: usize = 11;
        const PROMPT_SEARCH_FAILED_PREFIX: usize = 7;
        const PROMPT_SEARCH_REVERSE_PREFIX: usize = 8;
        const PROMPT_SEARCH_SUFFIX: usize = 3;

        pub struct Writer<'a, 'b: 'a, Term: 'b + Terminal> 
        {
            write: WriterImpl<'a, 'b, Term>,
        }

        enum WriterImpl<'a, 'b: 'a, Term: 'b + Terminal> 
        {
            Mutex( WriteLock<'b, Term> ),
            MutRef( &'a mut WriteLock<'b, Term> ),
        }

        pub struct Write 
        {

            pub buffer: String,
            pub backup_buffer: String,
            pub cursor: usize,
            blink:Option<Blink>,

            pub history: VecDeque<String>,
            pub history_index:Option<usize>,
            history_size: usize,
            history_new_entries: usize,

            pub is_prompt_drawn: bool,

            pub prompt_prefix: String,
            prompt_prefix_len: usize,
            pub prompt_suffix: String,
            prompt_suffix_len: usize,

            pub prompt_type: PromptType,

            pub reverse_search: bool,
            pub search_failed: bool,
            pub search_buffer: String,
            pub last_search: String,
            pub prev_history:Option<usize>,
            pub prev_cursor: usize,

            pub input_arg: Digit,
            pub explicit_arg: bool,

            pub screen_size: Size,
        }

        pub struct WriteLock<'a, Term: 'a + Terminal> 
        {
            term: Box<dyn TerminalWriter<Term> + 'a>,
            data: MutexGuard<'a, Write>,
        }

        impl<'a, Term: Terminal> WriteLock<'a, Term> 
        {
            pub fn new( term: Box<dyn TerminalWriter<Term> + 'a>, data: MutexGuard<'a, Write> )
                    -> WriteLock<'a, Term> { WriteLock{term, data} }

            pub fn size( &self ) -> io::Result<Size> { self.term.size() }

            pub fn flush( &mut self ) -> io::Result<()> { self.term.flush() }

            pub fn update_size( &mut self ) -> io::Result<()> {
                let size = self.size()?;
                self.screen_size = size;
                Ok( () )
            }

            pub fn blink( &mut self, pos: usize ) -> io::Result<()> {
                self.expire_blink()?;

                let orig = self.cursor;
                self.move_to( pos )?;
                self.cursor = orig;

                let expiry = Instant::now() + BLINK_DURATION;

                self.blink = Some( Blink{
                    pos,
                    expiry,
                } );

                Ok( () )
            }

            pub fn check_expire_blink( &mut self, now: Instant ) -> io::Result<bool> {
                if let Some( blink ) = self.data.blink {
                    if now >= blink.expiry {
                        self.expire_blink()?;
                    }
                }

                Ok( self.blink.is_none() )
            }

            pub fn expire_blink( &mut self ) -> io::Result<()> {
                if let Some( blink ) = self.data.blink.take() {
                    self.move_from( blink.pos )?;
                }

                Ok( () )
            }

            pub fn set_prompt( &mut self, prompt:&str ) -> io::Result<()> {
                self.expire_blink()?;

                let redraw = self.is_prompt_drawn && self.prompt_type.is_normal();

                if redraw {
                    self.clear_full_prompt()?;
                }

                self.data.set_prompt( prompt );

                if redraw {
                    self.draw_prompt()?;
                }

                Ok( () )
            }

            pub fn draw_prompt( &mut self ) -> io::Result<()> {
                self.draw_prompt_prefix()?;
                self.draw_prompt_suffix()
            }

            pub fn draw_prompt_prefix( &mut self ) -> io::Result<()> {
                match self.prompt_type {
                    // Prefix is not drawn when completions are shown
                    PromptType::CompleteMore => Ok( () ),
                    _ =>
                    {
                        let pfx = self.prompt_prefix.clone();
                        self.draw_raw_prompt( &pfx )
                    }
                }
            }

            pub fn draw_prompt_suffix( &mut self ) -> io::Result<()> {
                match self.prompt_type {
                    PromptType::Normal =>
                    {
                        let sfx = self.prompt_suffix.clone();
                        self.draw_raw_prompt( &sfx )?;
                    }
                    PromptType::Number =>
                    {
                        let n = self.input_arg.to_i32();
                        let s = format!( "( arg: {} ) ", n );
                        self.draw_text( 0, &s )?;
                    }
                    PromptType::Search =>
                    {
                        let pre = match ( self.reverse_search, self.search_failed ) {
                            ( false, false ) => "( i-search )",
                            ( false, true )  => "( failed i-search )",
                            ( true,  false ) => "( reverse-i-search )",
                            ( true,  true )  => "( failed reverse-i-search )",
                        };

                        let ent = self.get_history( self.history_index ).to_owned();
                        let s = format!( "{}`{}': {}", pre, self.search_buffer, ent );

                        self.draw_text( 0, &s )?;
                        let pos = self.cursor;

                        let ( lines, cols ) = self.move_delta( ent.len(), pos, &ent );
                        return self.move_rel( lines, cols );
                    }
                    PromptType::CompleteIntro( n ) => { return self.term.write( &complete_intro( n ) ); }
                    PromptType::CompleteMore => { return self.term.write( COMPLETE_MORE ); }
                }

                self.draw_buffer( 0 )?;
                let len = self.buffer.len();
                self.move_from( len )
            }

            pub fn redraw_prompt( &mut self, new_prompt: PromptType ) -> io::Result<()> {
                self.clear_prompt()?;
                self.prompt_type = new_prompt;
                self.draw_prompt_suffix()
            }

            pub fn draw_buffer( &mut self, pos: usize ) -> io::Result<()> {
                let ( _, col ) = self.line_col( pos );

                let buf = self.buffer[pos..].to_owned();
                self.draw_text( col, &buf )?;
                Ok( () )
            }

            fn draw_text( &mut self, start_col: usize, text:&str ) -> io::Result<()> {
                self.draw_text_impl( start_col, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                }, false )
            }

            fn draw_raw_prompt( &mut self, text:&str ) -> io::Result<()> {
                self.draw_text_impl( 0, text, Display{
                    allow_tab: true,
                    allow_newline: true,
                    allow_escape: true,
                }, true )
            }

            fn draw_text_impl( &mut self, start_col: usize, text:&str, disp: Display,
                    handle_invisible: bool ) -> io::Result<()> {
                let width = self.screen_size.columns;
                let mut col = start_col;
                let mut out = String::with_capacity( text.len() );

                let mut clear = false;
                let mut hidden = false;

                for ch in text.chars() 
                {
                    if handle_invisible && ch == START_INVISIBLE { hidden = true; }
                    
                    else if handle_invisible && ch == END_INVISIBLE { hidden = false; }

                    else if hidden { out.push( ch ); }

                    else
                    {
                        for ch in display( ch, disp )
                        {
                            if ch == '\t'
                            {
                                let n = TAB_STOP - ( col % TAB_STOP );
                                
                                if col + n > width
                                {
                                    let pre = width - col;
                                    out.extend( repeat( ' ' ).take( pre ) );
                                    out.push_str( " \r" );
                                    out.extend( repeat( ' ' ).take( n - pre ) );
                                    col = n - pre;
                                }
                                
                                else
                                {
                                    out.extend( repeat( ' ' ).take( n ) );
                                    col += n;

                                    if col == width 
                                    {
                                        out.push_str( " \r" );
                                        col = 0;
                                    }
                                }
                            }
                            
                            else if ch == '\n' 
                            {
                                if !clear 
                                {
                                    self.term.write( &out )?;
                                    out.clear();
                                    self.term.clear_to_screen_end()?;
                                    clear = true;
                                }

                                out.push( '\n' );
                                col = 0;
                            }
                            
                            else if is::combining_mark( ch ) { out.push( ch ); }
                            
                            else if is::wide( ch ) 
                            {
                                if col == width - 1 
                                {
                                    out.push_str( "  \r" );
                                    out.push( ch );
                                    col = 2;
                                }

                                else 
                                {
                                    out.push( ch );
                                    col += 2;
                                }
                            }
                            
                            else 
                            {
                                out.push( ch );
                                col += 1;

                                if col == width 
                                {
                                    out.push_str( " \r" );
                                    col = 0;
                                }
                            }
                        }
                    }
                }

                if col == width {
                    out.push_str( " \r" );
                }

                self.term.write( &out )
            }

            pub fn set_buffer( &mut self, buf:&str ) -> io::Result<()> {
                self.expire_blink()?;

                self.move_to( 0 )?;
                self.buffer.clear();
                self.buffer.push_str( buf );
                self.new_buffer()
            }

            pub fn set_cursor( &mut self, pos: usize ) -> io::Result<()> {
                self.expire_blink()?;

                if !self.buffer.is_char_boundary( pos ) {
                    panic!( "invalid cursor position {} in buffer {:?}",
                        pos, self.buffer );
                }

                self.move_to( pos )
            }

            pub fn set_cursor_mode( &mut self, mode: CursorMode ) -> io::Result<()> { self.term.set_cursor_mode( mode ) }

            pub fn history_len( &self ) -> usize { self.history.len() }

            pub fn history_size( &self ) -> usize { self.history_size }

            pub fn set_history_size( &mut self, n: usize ) {
                self.history_size = n;
                self.truncate_history( n );
            }

            pub fn write_str( &mut self, s:&str ) -> io::Result<()> { self.term.write( s ) }

            pub fn start_history_search( &mut self, reverse: bool ) -> io::Result<()> {
                self.search_buffer = self.buffer[..self.cursor].to_owned();

                self.continue_history_search( reverse )
            }

            pub fn continue_history_search( &mut self, reverse: bool ) -> io::Result<()> {
                if let Some( idx ) = self.find_history_search( reverse ) {
                    self.set_history_entry( Some( idx ) );

                    let pos = self.cursor;
                    let end = self.buffer.len();

                    self.draw_buffer( pos )?;
                    self.clear_to_screen_end()?;
                    self.move_from( end )?;
                }

                Ok( () )
            }

            fn find_history_search( &self, reverse: bool ) -> Option<usize> {
                let len = self.history.len();
                let idx = self.history_index.unwrap_or( len );

                if reverse {
                    self.history.iter().rev().skip( len - idx )
                        .position( |ent| ent.starts_with( &self.search_buffer ) )
                        .map( |pos| idx - ( pos + 1 ) )
                } else {
                    self.history.iter().skip( idx + 1 )
                        .position( |ent| ent.starts_with( &self.search_buffer ) )
                        .map( |pos| idx + ( pos + 1 ) )
                }
            }

            pub fn start_search_history( &mut self, reverse: bool ) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;
                self.search_buffer.clear();
                self.prev_history = self.history_index;
                self.prev_cursor = self.cursor;

                self.redraw_prompt( PromptType::Search )
            }

            pub fn continue_search_history( &mut self, reverse: bool ) -> io::Result<()> {
                self.reverse_search = reverse;
                self.search_failed = false;

                {
                    let data = &mut *self.data;
                    data.search_buffer.clone_from( &data.last_search );
                }

                self.search_history_step()
            }

            pub fn end_search_history( &mut self ) -> io::Result<()> { self.redraw_prompt( PromptType::Normal ) }

            pub fn abort_search_history( &mut self ) -> io::Result<()> {
                self.clear_prompt()?;

                let ent = self.prev_history;
                self.set_history_entry( ent );
                self.cursor = self.prev_cursor;

                self.prompt_type = PromptType::Normal;
                self.draw_prompt_suffix()
            }

            fn show_search_match( &mut self, next_match:Option<( Option<usize>, usize )> )
                    -> io::Result<()> {
                self.clear_prompt()?;

                if let Some( ( idx, pos ) ) = next_match {
                    self.search_failed = false;
                    self.set_history_entry( idx );
                    self.cursor = pos;
                } else {
                    self.search_failed = true;
                }

                self.prompt_type = PromptType::Search;
                self.draw_prompt_suffix()
            }

            pub fn search_history_update( &mut self ) -> io::Result<()> {
                let next_match = if self.reverse_search {
                    self.search_history_backward( &self.search_buffer, true )
                } else {
                    self.search_history_forward( &self.search_buffer, true )
                };

                self.show_search_match( next_match )
            }

            fn search_history_step( &mut self ) -> io::Result<()> {
                if self.search_buffer.is_empty() {
                    return self.redraw_prompt( PromptType::Search );
                }
                
                let next_match = if self.reverse_search {
                    self.search_history_backward( &self.search_buffer, false )
                } else {
                    self.search_history_forward( &self.search_buffer, false )
                };

                self.show_search_match( next_match )
            }

            fn search_history_backward( &self, s:&str, include_cur: bool )
                    -> Option<( Option<usize>, usize )> {
                let mut idx = self.history_index;
                let mut pos = Some( self.cursor );

                if include_cur && !self.search_failed {
                    if let Some( p ) = pos {
                        if self.get_history( idx ).is_char_boundary( p + s.len() ) {
                            pos = Some( p + s.len() );
                        }
                    }
                }

                loop {
                    let line = self.get_history( idx );

                    match line[..pos.unwrap_or( line.len() )].rfind( s ) {
                        Some( found ) => {
                            pos = Some( found );
                            break;
                        }
                        None => {
                            match idx {
                                Some( 0 ) => return None,
                                Some( n ) => {
                                    idx = Some( n - 1 );
                                    pos = None;
                                }
                                None => {
                                    if self.history.is_empty() {
                                        return None;
                                    } else {
                                        idx = Some( self.history.len() - 1 );
                                        pos = None;
                                    }
                                }
                            }
                        }
                    }
                }

                pos.map( |pos| ( idx, pos ) )
            }

            fn search_history_forward( &self, s:&str, include_cur: bool )
                    -> Option<( Option<usize>, usize )> {
                let mut idx = self.history_index;
                let mut pos = Some( self.cursor );

                if !include_cur {
                    if let Some( p ) = pos {
                        pos = Some( char::forward( 1, self.get_history( idx ), p ) );
                    }
                }

                loop {
                    let line = self.get_history( idx );

                    match line[pos.unwrap_or( 0 )..].find( s ) {
                        Some( found ) => {
                            pos = pos.map( |n| n + found ).or( Some( found ) );
                            break;
                        }
                        None => {
                            if let Some( n ) = idx {
                                if n + 1 == self.history.len() {
                                    idx = None;
                                } else {
                                    idx = Some( n + 1 );
                                }
                                pos = None;
                            } else {
                                return None;
                            }
                        }
                    }
                }

                pos.map( |pos| ( idx, pos ) )
            }

            pub fn add_history( &mut self, line: String ) {
                if self.history.len() == self.history_size {
                    self.history.pop_front();
                }

                self.history.push_back( line );
                self.history_new_entries = self.history.len()
                    .min( self.history_new_entries + 1 );
            }

            pub fn add_history_unique( &mut self, line: String ) {
                let is_duplicate = self.history.back().map_or( false, |ent| *ent == line );

                if !is_duplicate {
                    self.add_history( line );
                }
            }

            pub fn clear_history( &mut self ) {
                self.truncate_history( 0 );
                self.history_new_entries = 0;
            }

            pub fn remove_history( &mut self, n: usize ) {
                if n < self.history.len() {
                    let first_new = self.history.len() - self.history_new_entries;

                    if n >= first_new {
                        self.history_new_entries -= 1;
                    }

                    self.history.remove( n );
                }
            }

            pub fn truncate_history( &mut self, n: usize ) {
                let len = self.history.len();

                if n < len {
                    let _ = self.history.drain( ..len - n );
                    self.history_new_entries = self.history_new_entries.max( n );
                }
            }

            pub fn next_history( &mut self, n: usize ) -> io::Result<()> {
                if let Some( old ) = self.history_index {
                    let new = old.saturating_add( n );

                    if new >= self.history.len() {
                        self.select_history_entry( None )?;
                    } else {
                        self.select_history_entry( Some( new ) )?;
                    }
                }

                Ok( () )
            }

            pub fn prev_history( &mut self, n: usize ) -> io::Result<()> {
                if !self.history.is_empty() && self.history_index != Some( 0 ) {
                    let new = if let Some( old ) = self.history_index {
                        old.saturating_sub( n )
                    } else {
                        self.history.len().saturating_sub( n )
                    };

                    self.select_history_entry( Some( new ) )?;
                }

                Ok( () )
            }

            pub fn select_history_entry( &mut self, new:Option<usize> ) -> io::Result<()> {
                if new != self.history_index {
                    self.move_to( 0 )?;
                    self.set_history_entry( new );
                    self.new_buffer()?;
                }

                Ok( () )
            }

            pub fn set_history_entry( &mut self, new:Option<usize> ) {
                let old = self.history_index;

                if old != new {
                    let data = &mut *self.data;
                    data.history_index = new;

                    if let Some( old ) = old {
                        data.history[old].clone_from( &data.buffer );
                    } else {
                        swap( &mut data.buffer, &mut data.backup_buffer );
                    }

                    if let Some( new ) = new {
                        data.buffer.clone_from( &data.history[new] );
                    } else {
                        data.buffer.clear();
                        swap( &mut data.buffer, &mut data.backup_buffer );
                    }
                }
            }

            fn get_history( &self, n:Option<usize> ) -> &str {
                if self.history_index == n {
                    &self.buffer
                } else if let Some( n ) = n {
                    &self.history[n]
                } else {
                    &self.backup_buffer
                }
            }

            pub fn backward_char( &mut self, n: usize ) -> io::Result<()> {
                let pos = char::backward( n, &self.buffer, self.cursor );
                self.move_to( pos )
            }

            pub fn forward_char( &mut self, n: usize ) -> io::Result<()> {
                let pos = char::forward( n, &self.buffer, self.cursor );
                self.move_to( pos )
            }

            pub fn backward_search_char( &mut self, n: usize, ch:char ) -> io::Result<()> {
                if let Some( pos ) = char::backward_search( n, &self.buffer, self.cursor, ch ) {
                    self.move_to( pos )?;
                }

                Ok( () )
            }

            pub fn forward_search_char( &mut self, n: usize, ch:char ) -> io::Result<()> {
                if let Some( pos ) = char::forward_search( n, &self.buffer, self.cursor, ch ) {
                    self.move_to( pos )?;
                }

                Ok( () )
            }

            pub fn delete_range<R:ops::RangeArgument<usize>>( &mut self, r: R ) -> io::Result<()>
            {
                let start = r.start().cloned().unwrap_or( 0 );
                let end = r.end().cloned().unwrap_or_else( || self.buffer.len() );

                self.move_to( start )?;

                let _ = self.buffer.drain( start..end );

                self.draw_buffer( start )?;
                self.term.clear_to_screen_end()?;
                let len = self.buffer.len();
                self.move_from( len )?;

                Ok( () )
            }

            pub fn insert_str( &mut self, s:&str ) -> io::Result<()> 
            {
                let moves_combining = match self.buffer[self.cursor..].chars().next() {
                    Some( ch ) if is::combining_mark( ch ) => true,
                    _ => false
                };

                let cursor = self.cursor;
                self.buffer.insert_str( cursor, s );

                if moves_combining && cursor != 0 {
                    let pos = char::backward( 1, &self.buffer, self.cursor );
                    let ( lines, cols ) = self.move_delta( cursor, pos, &self.buffer );
                    self.move_rel( lines, cols )?;
                    self.draw_buffer( pos )?;
                } else {
                    self.draw_buffer( cursor )?;
                }

                self.cursor += s.len();

                let len = self.buffer.len();
                self.move_from( len )
            }

            pub fn transpose_range( &mut self, src: Range<usize>, dest: Range<usize> )
            -> io::Result<()> 
            {
                assert!( src.end <= dest.start || src.start >= dest.end );
                
                let final_cur = if src.start < dest.start {
                    dest.end
                } else {
                    dest.start + ( src.end - src.start )
                };

                let ( left, right ) = if src.start < dest.start {
                    ( src, dest )
                } else {
                    ( dest, src )
                };

                self.move_to( left.start )?;

                let a = self.buffer[left.clone()].to_owned();
                let b = self.buffer[right.clone()].to_owned();

                let _ = self.buffer.drain( right.clone() );
                self.buffer.insert_str( right.start, &a );

                let _ = self.buffer.drain( left.clone() );
                self.buffer.insert_str( left.start, &b );

                let cursor = self.cursor;
                self.draw_buffer( cursor )?;
                self.term.clear_to_screen_end()?;

                self.cursor = final_cur;
                let len = self.buffer.len();
                self.move_from( len )
            }

            fn prompt_suffix_length( &self ) -> usize {
                match self.prompt_type {
                    PromptType::Normal => self.prompt_suffix_len,
                    PromptType::Number =>
                    {
                        let n = number_len( self.input_arg.to_i32() );
                        PROMPT_NUM_PREFIX + PROMPT_NUM_SUFFIX + n
                    }
                    PromptType::Search =>
                    {
                        let mut prefix = PROMPT_SEARCH_PREFIX;

                        if self.reverse_search {
                            prefix += PROMPT_SEARCH_REVERSE_PREFIX;
                        }
                        if self.search_failed {
                            prefix += PROMPT_SEARCH_FAILED_PREFIX;
                        }

                        let n = self.display_size( &self.search_buffer, prefix );
                        prefix + n + PROMPT_SEARCH_SUFFIX
                    }
                    PromptType::CompleteIntro( n ) => complete_intro( n ).len(),
                    PromptType::CompleteMore => COMPLETE_MORE.len(),
                }
            }

            fn line_col( &self, pos: usize ) -> ( usize, usize ) {
                let prompt_len = self.prompt_suffix_length();

                match self.prompt_type {
                    PromptType::CompleteIntro( _ ) |
                    PromptType::CompleteMore =>
                    {
                        let width = self.screen_size.columns;
                        ( prompt_len / width, prompt_len % width )
                    }
                    _ => self.line_col_with( pos, &self.buffer, prompt_len )
                }
            }

            fn line_col_with( &self, pos: usize, buf:&str, start_col: usize ) -> ( usize, usize ) {
                let width = self.screen_size.columns;
                if width == 0 {
                    return ( 0, 0 );
                }

                let n = start_col + self.display_size( &buf[..pos], start_col );

                ( n / width, n % width )
            }

            pub fn clear_screen( &mut self ) -> io::Result<()> {
                self.term.clear_screen()?;
                self.draw_prompt()?;

                Ok( () )
            }

            pub fn clear_to_screen_end( &mut self ) -> io::Result<()> { self.term.clear_to_screen_end() }

            pub fn new_buffer( &mut self ) -> io::Result<()> {
                self.draw_buffer( 0 )?;
                self.cursor = self.buffer.len();

                self.term.clear_to_screen_end()?;

                Ok( () )
            }

            pub fn clear_full_prompt( &mut self ) -> io::Result<()> {
                let prefix_lines = self.prompt_prefix_len / self.screen_size.columns;
                let ( line, _ ) = self.line_col( self.cursor );
                self.term.move_up( prefix_lines + line )?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }

            pub fn clear_prompt( &mut self ) -> io::Result<()> {
                let ( line, _ ) = self.line_col( self.cursor );

                self.term.move_up( line )?;
                self.term.move_to_first_column()?;
                self.term.clear_to_screen_end()
            }

            pub fn move_from( &mut self, pos: usize ) -> io::Result<()> {
                let ( lines, cols ) = self.move_delta( pos, self.cursor, &self.buffer );
                self.move_rel( lines, cols )
            }

            pub fn move_to( &mut self, pos: usize ) -> io::Result<()> {
                if pos != self.cursor {
                    let ( lines, cols ) = self.move_delta( self.cursor, pos, &self.buffer );
                    self.move_rel( lines, cols )?;
                    self.cursor = pos;
                }

                Ok( () )
            }

            pub fn move_to_end( &mut self ) -> io::Result<()> {
                let pos = self.buffer.len();
                self.move_to( pos )
            }

            pub fn move_right( &mut self, n: usize ) -> io::Result<()> { self.term.move_right( n ) }
            
            fn move_delta( &self, old: usize, new: usize, buf:&str ) -> ( isize, isize ) {
                let prompt_len = self.prompt_suffix_length();
                let ( old_line, old_col ) = self.line_col_with( old, buf, prompt_len );
                let ( new_line, new_col ) = self.line_col_with( new, buf, prompt_len );

                ( new_line as isize - old_line as isize,
                new_col as isize - old_col as isize )
            }

            fn move_rel( &mut self, lines: isize, cols: isize ) -> io::Result<()> {
                if lines > 0 {
                    self.term.move_down( lines as usize )?;
                } else if lines < 0 {
                    self.term.move_up( ( -lines ) as usize )?;
                }

                if cols > 0 {
                    self.term.move_right( cols as usize )?;
                } else if cols < 0 {
                    self.term.move_left( ( -cols ) as usize )?;
                }

                Ok( () )
            }

            pub fn reset_data( &mut self ) { self.data.reset_data(); }

            pub fn set_digit_from_char( &mut self, ch:char ) {
                let digit = match ch {
                    '-' => Digit::NegNone,
                    '0' ..= '9' => Digit::from( ch ),
                    _ => Digit::None
                };

                self.input_arg = digit;
                self.explicit_arg = true;
            }
        }

        #[derive( Copy, Clone )]
        struct Blink 
        {
            pos: usize,
            expiry: Instant,
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Writer<'a, 'b, Term> 
        {
            fn new( mut write: WriterImpl<'a, 'b, Term>, clear: bool ) -> io::Result<Self> {
                write.expire_blink()?;

                if write.is_prompt_drawn {
                    if clear {
                        write.clear_full_prompt()?;
                    } else {
                        write.move_to_end()?;
                        write.write_str( "\n" )?;
                    }
                }

                Ok( Writer{write} )
            }

            pub fn with_lock( write: WriteLock<'b, Term>, clear: bool ) -> io::Result<Self> { Writer::new( WriterImpl::Mutex( write ), clear ) }

            pub fn with_ref( write:&'a mut WriteLock<'b, Term>, clear: bool ) -> io::Result<Self> { Writer::new( WriterImpl::MutRef( write ), clear ) }

            pub fn history( &self ) -> HistoryIter { self.write.history() }

            pub fn write_str( &mut self, s:&str ) -> io::Result<()> { self.write.write_str( s ) }

            pub fn write_fmt( &mut self, args: fmt::Arguments ) -> io::Result<()> {
                let s = args.to_string();
                self.write_str( &s )
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> Drop for Writer<'a, 'b, Term> 
        {
            fn drop( &mut self ) {
                if self.write.is_prompt_drawn {
                    let _ = self.write.draw_prompt();
                }
            }
        }

        impl<'a, Term: 'a + Terminal> Deref for WriteLock<'a, Term> 
        {
            type Target = Write;
            fn deref( &self ) -> &Write { &self.data }
        }

        impl<'a, Term: 'a + Terminal> DerefMut for WriteLock<'a, Term> 
        {
            fn deref_mut( &mut self ) -> &mut Write {
                &mut self.data
            }
        }

        impl Write 
        {
            pub fn new( screen_size: Size ) -> Write {
                Write{
                    buffer: String::new(),
                    backup_buffer: String::new(),
                    cursor: 0,
                    blink: None,
                    history: VecDeque::new(),
                    history_index: None,
                    history_size: MAX_HISTORY,
                    history_new_entries: 0,
                    is_prompt_drawn: false,
                    prompt_prefix: String::new(),
                    prompt_prefix_len: 0,
                    prompt_suffix: String::new(),
                    prompt_suffix_len: 0,
                    prompt_type: PromptType::Normal,
                    reverse_search: false,
                    search_failed: false,
                    search_buffer: String::new(),
                    last_search: String::new(),
                    prev_history: None,
                    prev_cursor: !0,
                    input_arg: Digit::None,
                    explicit_arg: false,
                    screen_size,
                }
            }

            pub fn history( &self ) -> HistoryIter { HistoryIter( self.history.iter() ) }

            pub fn new_history( &self ) -> Skip<HistoryIter> {
                let first_new = self.history.len() - self.history_new_entries;
                self.history().skip( first_new )
            }

            pub fn new_history_entries( &self ) -> usize { self.history_new_entries }

            pub fn reset_data( &mut self ) {
                self.buffer.clear();
                self.backup_buffer.clear();
                self.cursor = 0;
                self.history_index = None;

                self.prompt_type = PromptType::Normal;

                self.input_arg = Digit::None;
                self.explicit_arg = false;
            }

            pub fn reset_new_history( &mut self ) { self.history_new_entries = 0; }

            pub fn set_buffer( &mut self, buf:&str ) {
                self.buffer.clear();
                self.buffer.push_str( buf );
                self.cursor = buf.len();
            }

            pub fn set_cursor( &mut self, pos: usize ) {
                if !self.buffer.is_char_boundary( pos ) {
                    panic!( "invalid cursor position {} in buffer {:?}",
                        pos, self.buffer );
                }

                self.cursor = pos;
            }

            pub fn set_prompt( &mut self, prompt:&str ) {
                let ( pre, suf ) = match prompt.rfind( '\n' ) {
                    Some( pos ) => ( &prompt[..pos + 1], &prompt[pos + 1..] ),
                    None => ( &prompt[..0], prompt )
                };

                self.prompt_prefix = pre.to_owned();
                self.prompt_suffix = suf.to_owned();

                let pre_virt = str::filter_visible( pre );
                self.prompt_prefix_len = self.display_size( &pre_virt, 0 );

                let suf_virt = str::filter_visible( suf );
                self.prompt_suffix_len = self.display_size( &suf_virt, 0 );
            }

            pub fn display_size( &self, s:&str, start_col: usize ) -> usize 
            {
                let width = self.screen_size.columns;
                let mut col = start_col;

                let disp = Display{
                    allow_tab: true,
                    allow_newline: true,
                    .. Display::default()
                };

                for ch in s.chars().flat_map( |ch| display( ch, disp ) ) 
                {
                    let n = match ch {
                        '\n' => width - ( col % width ),
                        '\t' => TAB_STOP - ( col % TAB_STOP ),
                        ch if is::combining_mark( ch ) => 0,
                        ch if is::wide( ch ) => {
                            if col % width == width - 1 {
                                3
                            } else {
                                2
                            }
                        }
                        _ => 1
                    };

                    col += n;
                }

                col - start_col
            }
        }

        const NUMBER_MAX: i32 = 1_000_000;

        #[derive( Copy, Clone, Debug )]
        pub enum Digit 
        {
            None,
            NegNone,
            Num( i32 ),
            NegNum( i32 ),
        }

        impl Digit 
        {
            pub fn input( &mut self, n: i32 ) {
                match *self {
                    Digit::None => *self = Digit::Num( n ),
                    Digit::NegNone => *self = Digit::NegNum( n ),
                    Digit::Num( ref mut m ) | Digit::NegNum( ref mut m ) => {
                        *m *= 10;
                        *m += n;
                    }
                }
            }

            pub fn is_out_of_bounds( &self ) -> bool {
                match *self {
                    Digit::Num( n ) | Digit::NegNum( n ) if n > NUMBER_MAX => true,
                    _ => false
                }
            }

            pub fn to_i32( &self ) -> i32 {
                match *self {
                    Digit::None => 1,
                    Digit::NegNone => -1,
                    Digit::Num( n ) => n,
                    Digit::NegNum( n ) => -n,
                }
            }
        }

        impl From<char> for Digit 
        {

            fn from( ch:char ) -> Digit {
                let n = ( ch as u8 ) - b'0';
                Digit::Num( n as i32 )
            }
        }

        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum PromptType 
        {
            Normal,
            Number,
            Search,
            CompleteIntro( usize ),
            CompleteMore,
        }

        impl PromptType 
        {
            pub fn is_normal( &self ) -> bool { *self == PromptType::Normal }
        }

        impl<'a, 'b, Term: 'b + Terminal> Deref for WriterImpl<'a, 'b, Term> 
        {
            type Target = WriteLock<'b, Term>;
            fn deref( &self ) -> &WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex( ref m ) => m,
                    WriterImpl::MutRef( ref m ) => m,
                }
            }
        }

        impl<'a, 'b: 'a, Term: 'b + Terminal> DerefMut for WriterImpl<'a, 'b, Term> 
        {
            fn deref_mut( &mut self ) -> &mut WriteLock<'b, Term> {
                match *self {
                    WriterImpl::Mutex( ref mut m ) => m,
                    WriterImpl::MutRef( ref mut m ) => m,
                }
            }
        }

        pub struct HistoryIter<'a>( vec_deque::Iter<'a, String> );

        impl<'a> ExactSizeIterator for HistoryIter<'a> {}

        impl<'a> Iterator for HistoryIter<'a> 
        {
            type Item = &'a str;

            #[inline] fn next( &mut self ) -> Option<&'a str> { self.0.next().map( |s| &s[..] ) }

            #[inline] fn nth( &mut self, n: usize ) -> Option<&'a str> 
            { self.0.nth( n ).map( |s| &s[..] ) }

            #[inline] fn size_hint( &self ) -> ( usize, Option<usize> ) { self.0.size_hint() }
        }

        impl<'a> DoubleEndedIterator for HistoryIter<'a> 
        {
            #[inline] fn next_back( &mut self ) -> Option<&'a str>
            { self.0.next_back().map( |s| &s[..] ) }
        }

        #[derive( Copy, Clone, Debug, Eq, PartialEq )]
        pub enum DisplaySequence 
        {
            Char( char ),
            Escape( char ),
            End,
        }

        impl Iterator for DisplaySequence 
        {
            type Item = char;
            fn next( &mut self ) -> Option<char> {
                use self::DisplaySequence::*;

                let ( res, next ) = match *self {
                    Char( ch ) => ( ch, End ),
                    Escape( ch ) => ( '^', Char( ch ) ),
                    End => return None
                };

                *self = next;
                Some( res )
            }

            fn size_hint( &self ) -> ( usize, Option<usize> ) 
            {
                use self::DisplaySequence::*;

                let n = match *self {
                    Char( _ ) => 1,
                    Escape( _ ) => 2,
                    End => 0,
                };

                ( n, Some( n ) )
            }
        }

        #[derive( Copy, Clone, Debug, Default )]
        pub struct Display 
        {
            allow_tab: bool,
            allow_newline: bool,
            allow_escape: bool,
        }

        pub fn display( ch:char, style: Display ) -> DisplaySequence 
        {
            match ch 
            {
                '\t' if style.allow_tab => DisplaySequence::Char( ch ),
                '\n' if style.allow_newline => DisplaySequence::Char( ch ),
                ESCAPE if style.allow_escape => DisplaySequence::Char( ch ),
                '\0' => DisplaySequence::Escape( '@' ),
                RUBOUT => DisplaySequence::Escape( '?' ),
                ch if is::control( ch ) => DisplaySequence::Escape( unctrl( ch ) ),
                ch => DisplaySequence::Char( ch )
            }
        }

        pub fn display_str<'a>( s:&'a str, style: Display ) -> Cow<'a, str> 
        {
            if s.chars().all( |ch| display( ch, style ) == DisplaySequence::Char( ch ) ) {
                Borrowed( s )
            } else {
                Owned( s.chars().flat_map( |ch| display( ch, style ) ).collect() )
            }
        }

        fn complete_intro( n: usize ) -> String { format!( "Display all {} possibilities? ( y/n )", n ) }

        fn number_len( n: i32 ) -> usize
        {
            match n
            {
                -1_000_000              => 8,
                -  999_999 ..= -100_000 => 7,
                -   99_999 ..= - 10_000 => 6,
                -    9_999 ..= -  1_000 => 5,
                -      999 ..= -    100 => 4,
                -       99 ..= -     10 => 3,
                -        9 ..= -      1 => 2,
                        0 ..=        9 => 1,
                        10 ..=       99 => 2,
                    100 ..=      999 => 3,
                    1_000 ..=    9_999 => 4,
                    10_000 ..=   99_999 => 5,
                100_000 ..=  999_999 => 6,
                1_000_000              => 7,
                _ => unreachable!()
            }
        }
    }
}

pub mod thread
{
    pub use std::thread::{ * };
}

pub mod time
{
    pub use temporal::{ * };
    pub mod std
    {
        pub use std::time::{ * };
    }
}

pub mod tuples
{
    /*!
    Tuple | A container which can hold elements of different types.*/
    use ::
    {
        error::{ OverError },
        fmt::{ Format },
        result::{ OverResult },
        slice::{ Iter },
        sync::{ Arc },
        types::{ Type },
        values::{ Value },
        *,
    };
    /*
    use crate::{OverError, OverResult, INDENT_STEP};
    */
    #[derive( Clone, Debug )]
    struct TupInner 
    {
        vec: Vec<Value>,
        inner_tvec: Vec<Type>,
    }

    #[derive( Clone, Debug )]
    pub struct Tup 
    {
        inner: Arc<TupInner>,
    }

    impl Tup 
    {
        pub fn from_vec( values: Vec<Value> ) -> Tup {
            let tvec: Vec<Type> = values.iter().map( |val| val.get_type() ).collect();

            Tup {
                inner: Arc::new( TupInner {
                    vec: values,
                    inner_tvec: tvec,
                } ),
            }
        }

        pub fn vec_ref( &self ) -> &Vec<Value> { &self.inner.vec }

        pub fn with_each<F>( &self, mut f: F ) where
            F: FnMut( &Value ),
        {
            for value in &self.inner.vec {
                f( value )
            }
        }
        pub fn get( &self, index: usize ) -> OverResult<Value> {
            if index >= self.inner.vec.len() {
                Err( OverError::TupOutOfBounds( index ) )
            } else {
                Ok( self.inner.vec[index].clone() )
            }
        }

        pub fn inner_type_vec( &self ) -> Vec<Type> { self.inner.inner_tvec.clone() }

        pub fn len( &self ) -> usize { self.inner.vec.len() }

        pub fn is_empty( &self ) -> bool { self.inner.vec.is_empty() }

        pub fn ptr_eq( &self, other:&Self ) -> bool {
            Arc::ptr_eq( &self.inner, &other.inner )
        }

        pub fn iter( &self ) -> Iter<Value> { self.vec_ref().iter() }
    }

    impl Default for Tup
    {
        fn default() -> Self { Self::from_vec( Vec::new() ) }
    }

    impl fmt::Display for Tup 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result {
            write!( f, "{}", self.format( true, INDENT_STEP ) )
        }
    }

    impl From<Vec<Value>> for Tup 
    {
        fn from( vec: Vec<Value> ) -> Self {
            Self::from_vec( vec )
        }
    }

    impl PartialEq for Tup 
    {
        fn eq( &self, other:&Self ) -> bool {
           
            if self.inner.inner_tvec != other.inner.inner_tvec {
                return false;
            }
            self.inner.vec == other.inner.vec
        }
    }
}

pub mod types
{
    /*!
    */
    use ::
    {
        collections::{ HashMap, HashSet },
        *,
    };
    /*
    use regex::Regex;
    use crate::parsers;
    use crate::parsers::parser_line::tokens_to_redirections;
    */
    pub type Token = (String, String);
    pub type Tokens = Vec<Token>;
    pub type Redirection = (String, String, String);

    #[derive( Clone, Debug )]
    pub enum Type 
    {

        Any,
        Null,

        Bool,
        Int,
        Integer,
        Frac,
        Char,
        Str,
        Strand,
        Arr( Box<Type> ),
        Tup( Vec<Type> ),
        Obj,
    }

    impl Type 
    {
        pub fn is( &self, other:&Type ) -> bool 
        {
            use self::Type::*;

            match *self
            {
                Any => {
                    if let Any = *other {
                        true
                    } else {
                        false
                    }
                }
                Null => {
                    if let Null = *other {
                        true
                    } else {
                        false
                    }
                }
                Bool => {
                    if let Bool = *other {
                        true
                    } else {
                        false
                    }
                }
                Int => {
                    if let Int = *other {
                        true
                    } else {
                        false
                    }
                }
                Integer => {
                    if let Integer = *other {
                        true
                    } else {
                        false
                    }
                }
                Frac => {
                    if let Frac = *other {
                        true
                    } else {
                        false
                    }
                }
                Char => {
                    if let Char = *other {
                        true
                    } else {
                        false
                    }
                }
                Str => {
                    if let Str = *other {
                        true
                    } else {
                        false
                    }
                }
                Strand => {
                    if let Strand = *other {
                        true
                    } else {
                        false
                    }
                }
                Obj => {
                    if let Obj = *other {
                        true
                    } else {
                        false
                    }
                }
                Arr( ref t1 ) => {
                    if let Arr( ref t2 ) = *other {
                        t1.is( t2 )
                    } else {
                        false
                    }
                }
                Tup( ref tvec1 ) => {
                    if let Tup( ref tvec2 ) = *other {
                        if tvec1.len() != tvec2.len() {
                            return false;
                        }
                        tvec1.iter().zip( tvec2.iter() ).all( |( t1, t2 )| t1.is( t2 ) )
                    } else {
                        false
                    }
                }
            }
        }

        pub fn has_any( &self ) -> bool 
        {
            match *self
            {
                Type::Any => true,
                Type::Arr( ref t ) => Self::has_any( t ),
                Type::Tup( ref tvec ) => tvec.iter().any( |t| Self::has_any( t ) ),
                _ => false,
            }
        }

        pub fn most_specific( type1:&Type, type2:&Type ) -> Option<( Type, bool )> 
        {
            use self::Type::*;

            if let Any = *type2 {
                return Some( ( type1.clone(), type1.has_any() ) );
            }
            match *type1 {
                Any => Some( ( type2.clone(), type2.has_any() ) ),
                Arr( ref t1 ) => {
                    if let Arr( ref t2 ) = *type2 {
                        Self::most_specific( t1, t2 ).map( |( t, any )| ( Arr( Box::new( t ) ), any ) )
                    } else {
                        None
                    }
                }
                Tup( ref tvec1 ) => {
                    if let Tup( ref tvec2 ) = *type2 {
                        if tvec1.len() == tvec2.len() {
                            let mut has_any = false;

                            let tvec:Option<Vec<Type>> = tvec1
                                .iter()
                                .zip( tvec2.iter() )
                                .map( |( t1, t2 )| {
                                    Self::most_specific( t1, t2 ).map( |( t, any )| {
                                        if !has_any && any {
                                            has_any = any;
                                        }
                                        t
                                    } )
                                } )
                                .collect();

                            tvec.map( |tvec| ( Tup( tvec ), has_any ) )
                        } else {
                            None
                        }
                    } else {
                        None
                    }
                }
                ref t => {
                    if t == type2 {
                        Some( ( t.clone(), false ) )
                    } else {
                        None
                    }
                }
            }
        }
    }

    impl PartialEq for Type 
    {
        fn eq( &self, other:&Self ) -> bool
        {
            use self::Type::*;
            
            if let Any = *other { return true; }

            match *self
            {
                Any => true,
                Arr( ref box1 ) =>
                {
                    if let Arr( ref box2 ) = *other { box1 == box2 }
                    else { false }
                }
                
                Tup( ref tvec1 ) =>
                {
                    if let Tup( ref tvec2 ) = *other { tvec1 == tvec2 }
                    else { false }
                }

                _ => self.is( other ),
            }
        }
    }

    impl Eq for Type {}

    impl fmt::Display for Type 
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            use self::Type::*;

            match *self 
            {
                Any => write!( f, "Any" ),
                Null => write!( f, "Null" ),
                Bool => write!( f, "Bool" ),
                Int => write!( f, "Int" ),
                Integer => write!( f, "Integer" ),
                Frac => write!( f, "Frac" ),
                Char => write!( f, "Char" ),
                Str => write!( f, "Str" ),
                Strand => write!( f, "Strand" ),
                Arr( ref boxxy ) => write!( f, "Arr( {} )", boxxy ),
                Tup( ref tvec ) => write!( 
                    f,
                    "Tup( {} )",
                    match tvec.get( 0 ) {
                        Some( t1 ) => tvec
                            .iter()
                            .skip( 1 )
                            .fold( format!( "{}", t1 ), |s, t| format!( "{}, {}", s, t ) ),
                        None => String::from( "" ),
                    }
                ),
                Obj => write!( f, "Obj" ),
            }
        }
    }

    #[derive( Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash )]
    pub struct WaitStatus( i32, i32, i32 );

    impl WaitStatus 
    {
        pub fn from_exited( pid: i32, status: i32) -> Self 
        {
            WaitStatus( pid, 0, status )
        }

        pub fn from_signaled( pid: i32, sig: i32) -> Self 
        {
            WaitStatus( pid, 1, sig)
        }

        pub fn from_stopped( pid: i32, sig: i32) -> Self 
        {
            WaitStatus( pid, 2, sig)
        }

        pub fn from_continuted( pid: i32) -> Self 
        {
            WaitStatus( pid, 3, 0)
        }

        pub fn from_others() -> Self 
        {
            WaitStatus(0, 9, 9)
        }

        pub fn from_error(errno: i32) -> Self 
        {
            WaitStatus(0, 255, errno)
        }

        pub fn empty() -> Self 
        {
            WaitStatus(0, 0, 0)
        }

        pub fn is_error( &self ) -> bool 
        {
            self.1 == 255
        }

        pub fn is_others( &self ) -> bool 
        {
            self.1 == 9
        }

        pub fn is_signaled( &self ) -> bool 
        {
            self.1 == 1
        }

        pub fn get_errno( &self ) -> nix::Error 
        {
            nix::Error::from_raw( self.2)
        }

        pub fn is_exited( &self ) -> bool 
        {
            self.0 != 0 && self.1 == 0
        }

        pub fn is_stopped( &self ) -> bool 
        {
            self.1 == 2
        }

        pub fn is_continued( &self ) -> bool 
        {
            self.1 == 3
        }

        pub fn get_pid( &self ) -> i32 
        {
            self.0
        }

        fn _get_signaled_status( &self ) -> i32 
        {
            self.2 + 128
        }

        pub fn get_signal( &self ) -> i32 
        {
            self.2
        }

        pub fn get_name( &self ) -> String 
        {
            if self.is_exited() {
                "Exited".to_string()
            } else if self.is_stopped() {
                "Stopped".to_string()
            } else if self.is_continued() {
                "Continued".to_string()
            } else if self.is_signaled() {
                "Signaled".to_string()
            } else if self.is_others() {
                "Others".to_string()
            } else if self.is_error() {
                "Error".to_string()
            } else {
                format!( "unknown: {}", self.2)
            }
        }

        pub fn get_status( &self ) -> i32 
        {
            if self.is_exited() {
                self.2
            } else {
                self._get_signaled_status()
            }
        }
    }

    impl fmt::Debug for WaitStatus
    {
        fn fmt( &self, f: &mut fmt::Formatter<'_>) -> fmt::Result
        {
            let mut formatter = f.debug_struct( "WaitStatus" );
            formatter.field( "pid", &self.0);
            let name = self.get_name();
            formatter.field( "name", &name );
            formatter.field( "ext", &self.2);
            formatter.finish()
        }
    }
    
    #[derive( Debug )]
    pub struct LineInfo
    {
        pub tokens: Tokens,
        pub is_complete: bool,
    }

    impl LineInfo
    {
        pub fn new( tokens: Tokens ) -> Self
        {
            LineInfo
            {
                tokens,
                is_complete: true,
            }
        }
    }
    
    #[derive( Debug )]
    pub struct Command
    {
        pub tokens: Tokens,
        pub redirects_to: Vec<Redirection>,
        pub redirect_from:Option<Token>,
    }

    #[derive( Debug )]
    pub struct CommandLine
    {
        pub line: String,
        pub commands: Vec<Command>,
        pub envs: HashMap<String, String>,
        pub background: bool,
    }

    impl Command
    {
        pub fn from_tokens( tokens: Tokens ) -> Result<Command, String>
        {
            let mut tokens_new = tokens.clone();
            let mut redirects_from_type = String::new();
            let mut redirects_from_value = String::new();
            let mut has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<" );

            let mut len = tokens_new.len();
            while has_redirect_from {
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<" ) {
                    redirects_from_type = "<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }
                if let Some(idx) = tokens_new.iter().position(|x| x.1 == "<<<" ) {
                    redirects_from_type = "<<<".to_string();
                    tokens_new.remove(idx);
                    len -= 1;
                    if len > idx {
                        redirects_from_value = tokens_new.remove(idx).1;
                        len -= 1;
                    }
                }

                has_redirect_from = tokens_new.iter().any(|x| x.1 == "<" || x.1 == "<<<" );
            }

            let tokens_final;
            let redirects_to;
            match tokens_to_redirections( &tokens_new) {
                Ok((_tokens, _redirects_to ) ) => {
                    tokens_final = _tokens;
                    redirects_to = _redirects_to;
                }
                Err( e ) => { return Err( e ); }
            }

            let redirect_from = if redirects_from_type.is_empty() {
                None
            } else {
                Some(( redirects_from_type, redirects_from_value  ) )
            };

            Ok( Command {
                tokens: tokens_final,
                redirects_to,
                redirect_from,
            })
        }

        pub fn has_redirect_from( &self ) -> bool
        { self.redirect_from.is_some() && self.redirect_from.clone().unwrap().0 == "<" }

        pub fn has_here_string( &self ) -> bool
        { self.redirect_from.is_some() && self.redirect_from.clone().unwrap().0 == "<<<" }

        pub fn is_builtin( &self ) -> bool
        {
            is::builtin( &self.tokens[0].1)
        }
    }

    #[derive( Clone, Debug, Default )]
    pub struct Job
    {
        pub cmd: String,
        pub id: i32,
        pub gid: i32,
        pub pids: Vec<i32>,
        pub pids_stopped: HashSet<i32>,
        pub status: String,
        pub is_bg: bool,
    }

    impl Job 
    {
        pub fn all_members_stopped( &self ) -> bool 
        {
            for pid in &self.pids
            {
                if !self.pids_stopped.contains( pid ) { return false; }
            }

            true
        }

        pub fn all_members_running( &self ) -> bool 
        {
            self.pids_stopped.is_empty()
        }
    }

    #[allow(dead_code )]
    #[derive( Clone, Debug, Default )]
    pub struct CommandResult 
    {
        pub gid: i32,
        pub status: i32,
        pub stdout: String,
        pub stderr: String,
    }

    impl CommandResult 
    {
        pub fn new() -> CommandResult 
        {
            CommandResult 
            {
                gid: 0,
                status: 0,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn from_status(gid: i32, status: i32) -> CommandResult 
        {
            CommandResult 
            {
                gid,
                status,
                stdout: String::new(),
                stderr: String::new(),
            }
        }

        pub fn error() -> CommandResult 
        {
            CommandResult 
            {
                gid: 0,
                status: 1,
                stdout: String::new(),
                stderr: String::new(),
            }
        }
    }

    #[allow(dead_code )]
    #[derive( Clone, Debug, Default )]
    pub struct CommandOptions
    {
        pub background: bool,
        pub isatty: bool,
        pub capture_output: bool,
        pub envs: HashMap<String, String>,
    }

    pub fn split_tokens_by_pipes( tokens:&[Token] ) -> Vec<Tokens> 
    {
        let mut cmd = Vec::new();
        let mut cmds = Vec::new();

        for token in tokens
        {
            let sep = &token.0;
            let value = &token.1;
            
            if sep.is_empty() && value == "|"
            {
                if cmd.is_empty() { return Vec::new(); }

                cmds.push( Cmd.clone() );
                cmd = Vec::new();
            }

            else { cmd.push( token.clone() ); }
        }
        
        if cmd.is_empty() { return Vec::new(); }

        cmds.push( Cmd.clone() );
        cmds
    }

    pub fn drain_env_tokens( tokens: &mut Tokens ) -> HashMap<String, String> 
    {
        let mut envs: HashMap<String, String> = HashMap::new();
        let mut n = 0;
        let re = Regex::new( r"^([a-zA-Z0-9_]+)=(.*)$" ).unwrap();

        for ( sep, text ) in tokens.iter() {
            if !sep.is_empty() || !::regex::contains( text, r"^([a-zA-Z0-9_]+)=(.*)$" ) {
                break;
            }

            for cap in re.captures_iter( text ) {
                let name = cap[1].to_string();
                let value = parsers::parser_line::unquote( &cap[2]);
                envs.insert( name, value );
            }

            n += 1;
        }
        
        if n > 0 { tokens.drain(0..n ); }

        envs
    }

    impl CommandLine
    {
        pub fn from_line(line: &str, sh: &mut shell::Shell) -> Result<CommandLine, String>
        {
            let linfo = parsers::parser_line::parse_line(line );
            let mut tokens = linfo.tokens;
            shell::do_expansion( sh, &mut tokens );
            let envs = drain_env_tokens( &mut tokens );

            let mut background = false;
            let len = tokens.len();
            
            if len > 1 && tokens[len - 1].1 == "&"
            {
                background = true;
                tokens.pop();
            }

            let mut commands = Vec::new();

            for sub_tokens in split_tokens_by_pipes( &tokens )
            {
                match Command::from_tokens( sub_tokens ) {
                    Ok( c ) => { commands.push( c ); }
                    Err( e ) => { return Err( e ); }
                }
            }

            Ok
            (
                CommandLine
                {
                    line: line.to_string(),
                    commands,
                    envs,
                    background,
                }
            )
        }

        pub fn is_empty( &self ) -> bool { self.commands.is_empty() }

        pub fn with_pipeline( &self ) -> bool { self.commands.len() > 1 }

        pub fn is_single_and_builtin( &self ) -> bool { self.commands.len() == 1 && self.commands[0].is_builtin() }
    }
}

pub mod u8
{
    pub use std::u8::{ * };
}

pub mod u16
{
    pub use std::u16::{ * };
}

pub mod u32
{
    pub use std::u32::{ * };
}

pub mod u64
{
    pub use std::u64::{ * };
}

pub mod u128
{
    pub use std::u128::{ * };
}

pub mod unicode
{
    /*!
    */
    use ::
    {
        string::{ String, ToString },
        vec::{ Vec },
        *,
    };
    /*
    */
    pub mod tables
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        pub mod __
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
        }
        */
        pub mod age
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] =  &[ ("V10_0",V10_0),("V11_0",V11_0),("V12_0",V12_0),("V12_1",V12_1),("V13_0",V13_0),("V14_0",V14_0),("V15_0",V15_0),("V15_1",V15_1),("V16_0",V16_0),("V1_1",V1_1),("V2_0",V2_0),("V2_1",V2_1),("V3_0",V3_0),("V3_1",V3_1),("V3_2",V3_2),("V4_0",V4_0),("V4_1",V4_1),("V5_0",V5_0),("V5_1",V5_1),("V5_2",V5_2),("V6_0",V6_0),("V6_1",V6_1),("V6_2",V6_2),("V6_3",V6_3),("V7_0",V7_0),("V8_0",V8_0),("V9_0",V9_0) ];
            pub const V10_0:&'static [(char,char)] = &[ ('',''),('',''),('\u{afa}','\u{aff}'),('\u{d00}','\u{d00}'),('\u{d3b}','\u{d3c}'),('',''),('\u{1df6}','\u{1df9}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{11a47}'),('',''),('',''),('',''),('',''),('',''),('','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d47}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V11_0:&'static [(char,char)] =  &[ ('',''),('',''),('',''),('\u{7fd}',''),('\u{8d3}','\u{8d3}'),('\u{9fe}','\u{9fe}'),('',''),('\u{c04}','\u{c04}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{a8ff}'),('',''),('',''),('','\u{10d27}'),('',''),('',''),('',''),('\u{110cd}','\u{110cd}'),('',''),('\u{1133b}','\u{1133b}'),('\u{1145e}','\u{1145e}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{11d90}','\u{11d91}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V12_0:&'static [(char,char)] =  &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{eba}','\u{eba}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{119d7}'),('\u{119da}',''),('',''),('',''),('',''),('\u{13430}','\u{13438}'),('',''),('\u{16f4f}','\u{16f4f}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1e130}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V12_1:&'static [(char,char)] = &[('','')];
            pub const V13_0:&'static [(char,char)] =  &[ ('',''),('\u{b55}','\u{b55}'),('',''),('\u{d81}','\u{d81}'),('\u{1abf}','\u{1ac0}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a82c}','\u{a82c}'),('',''),('',''),('',''),('\u{10eab}',''),('',''),('',''),('',''),('','\u{111cf}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1193b}',''),('',''),('',''),('\u{16fe4}','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V14_0:&'static [(char,char)] =  &[ ('',''),('',''),('\u{890}','\u{891}'),('\u{898}','\u{89f}'),('',''),('','\u{8d2}'),('\u{c3c}','\u{c3c}'),('',''),('',''),('',''),('\u{1715}','\u{1715}'),('',''),('\u{180f}','\u{180f}'),('\u{1ac1}','\u{1ace}'),('',''),('',''),('\u{1dfa}','\u{1dfa}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{11070}',''),('\u{110c2}','\u{110c2}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('',''),('',''),('',''),('','\u{1e2ae}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V15_0:&'static [(char,char)] =  &[ ('',''),('\u{ece}','\u{ece}'),('\u{10efd}','\u{10eff}'),('','\u{11241}'),('',''),('\u{11f00}',''),('','\u{11f3a}'),('',''),('',''),('\u{13439}','\u{13455}'),('',''),('',''),('',''),('',''),('',''),('\u{1e08f}','\u{1e08f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V15_1:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const V16_0:&'static [(char,char)] =  &[ ('\u{897}','\u{897}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{10d69}',''),('',''),('',''),('\u{10efc}','\u{10efc}'),('',''),('',''),('',''),('',''),('','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('',''),('',''),('\u{113e1}','\u{113e2}'),('',''),('',''),('',''),('\u{11f5a}','\u{11f5a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V1_1:&'static [(char,char)] =  &[ ('\0',''),('',''),('',''),('',''),('',''),('\u{300}','\u{345}'),('\u{360}','\u{361}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{486}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{5b0}','\u{5b9}'),('\u{5bb}',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{652}'),('',''),('\u{670}',''),('',''),('',''),('','\u{6ed}'),('',''),('\u{901}',''),('',''),('\u{93c}','\u{94d}'),('','\u{954}'),('',''),('\u{981}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{9bc}','\u{9bc}'),('\u{9be}','\u{9c4}'),('',''),('','\u{9cd}'),('\u{9d7}','\u{9d7}'),('',''),('','\u{9e3}'),('',''),('\u{a02}','\u{a02}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('',''),('',''),('',''),('\u{a81}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{abc}','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('',''),('',''),('',''),('\u{b01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{b3c}','\u{b43}'),('',''),('','\u{b4d}'),('\u{b56}','\u{b57}'),('',''),('',''),('',''),('\u{b82}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{bbe}',''),('',''),('','\u{bcd}'),('\u{bd7}','\u{bd7}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{c3e}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{d3e}','\u{d43}'),('',''),('','\u{d4d}'),('\u{d57}','\u{d57}'),('',''),('',''),('','\u{e3a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{eb9}'),('\u{ebb}',''),('',''),('',''),('\u{ec8}','\u{ecd}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2000}','\u{202e}'),('',''),('\u{206a}',''),('',''),('',''),('\u{20d0}','\u{20e1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{3000}',''),('',''),('',''),('\u{3099}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{e000}',''),('',''),('',''),('\u{fb1e}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{fe20}','\u{fe23}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{feff}','\u{feff}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{ffff}') ];
            pub const V2_0:&'static [(char,char)] =  &[ ('\u{591}','\u{5a1}'),('\u{5a3}','\u{5af}'),('\u{5c4}','\u{5c4}'),('',''),('',''),('\u{f71}',''),('\u{f90}','\u{f95}'),('\u{f97}','\u{f97}'),('\u{f99}','\u{fad}'),('\u{fb1}','\u{fb7}'),('\u{fb9}','\u{fb9}'),('',''),('',''),('',''),('\u{1fffe}','\u{1ffff}'),('\u{2fffe}','\u{2ffff}'),('\u{3fffe}','\u{3ffff}'),('\u{4fffe}','\u{4ffff}'),('\u{5fffe}','\u{5ffff}'),('\u{6fffe}','\u{6ffff}'),('\u{7fffe}','\u{7ffff}'),('\u{8fffe}','\u{8ffff}'),('\u{9fffe}','\u{9ffff}'),('\u{afffe}','\u{affff}'),('\u{bfffe}','\u{bffff}'),('\u{cfffe}','\u{cffff}'),('\u{dfffe}','\u{dffff}'),('\u{efffe}','\u{10ffff}') ];
            pub const V2_1:&'static [(char,char)] = &[('',''),('','')];
            pub const V3_0:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('\u{346}','\u{34e}'),('\u{362}','\u{362}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{488}','\u{489}'),('',''),('',''),('',''),('\u{653}','\u{655}'),('',''),('',''),('',''),('',''),('',''),('\u{70f}',''),('\u{730}','\u{74a}'),('','\u{7b0}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('',''),('\u{f96}','\u{f96}'),('\u{fae}','\u{fb0}'),('\u{fb8}','\u{fb8}'),('\u{fba}','\u{fbc}'),('',''),('',''),('',''),('',''),('',''),('','\u{1032}'),('\u{1036}','\u{1039}'),('','\u{1059}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1680}',''),('',''),('',''),('',''),('','\u{180e}'),('',''),('',''),('','\u{18a9}'),('\u{202f}','\u{202f}'),('',''),('',''),('\u{20e2}','\u{20e3}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{fff9}','\u{fffb}') ];
            pub const V3_1:&'static [(char,char)] = &[ ('',''),('\u{fdd0}','\u{fdef}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{e0001}','\u{e0001}'),('\u{e0020}','\u{e007f}') ];
            pub const V3_2:&'static [(char,char)] = &[ ('',''),('\u{34f}','\u{34f}'),('\u{363}','\u{36f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1714}'),('',''),('','\u{1753}'),('',''),('',''),('\u{1772}','\u{1773}'),('',''),('',''),('',''),('\u{205f}','\u{2063}'),('',''),('',''),('\u{20e4}','\u{20ea}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{fe00}','\u{fe0f}'),('',''),('',''),('','') ];
            pub const V4_0:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('\u{350}','\u{357}'),('\u{35d}','\u{35f}'),('',''),('\u{600}','\u{603}'),('','\u{615}'),('\u{656}','\u{658}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a01}','\u{a01}'),('',''),('',''),('','\u{ae3}'),('',''),('',''),('',''),('',''),('\u{cbc}',''),('\u{17dd}','\u{17dd}'),('',''),('',''),('\u{1920}',''),('','\u{193b}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{e0100}','\u{e01ef}') ];
            pub const V4_1:&'static [(char,char)] = &[ ('',''),('\u{358}','\u{35c}'),('',''),('',''),('\u{5a2}','\u{5a2}'),('\u{5c5}','\u{5c7}'),('',''),('',''),('\u{659}','\u{65e}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{135f}',''),('',''),('',''),('',''),('',''),('',''),('','\u{1a1b}'),('',''),('','\u{1dc3}'),('',''),('',''),('',''),('',''),('\u{20eb}','\u{20eb}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}',''),('',''),('',''),('\u{10a38}','\u{10a3a}'),('\u{10a3f}',''),('',''),('',''),('','') ];
            pub const V5_0:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('\u{5ba}','\u{5ba}'),('',''),('',''),('',''),('\u{ce2}','\u{ce3}'),('',''),('\u{1b00}',''),('',''),('\u{1dc4}','\u{1dca}'),('\u{1dfe}','\u{1dff}'),('\u{20ec}','\u{20ef}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V5_1:&'static [(char,char)] = &[ ('',''),('',''),('',''),('\u{487}','\u{487}'),('',''),('',''),('\u{616}','\u{61a}'),('',''),('',''),('',''),('\u{a51}','\u{a51}'),('\u{a75}','\u{a75}'),('\u{b44}','\u{b44}'),('\u{b62}','\u{b63}'),('',''),('',''),('',''),('\u{c62}','\u{c63}'),('',''),('',''),('\u{d44}','\u{d44}'),('\u{d62}','\u{d63}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1033}','\u{1035}'),('\u{103a}',''),('',''),('',''),('',''),('\u{1b80}','\u{1baa}'),('',''),('','\u{1c37}'),('',''),('',''),('\u{1dcb}','\u{1de6}'),('',''),('',''),('\u{2064}','\u{2064}'),('\u{20f0}','\u{20f0}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2de0}','\u{2dff}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a67c}',''),('',''),('',''),('',''),('','\u{a8c4}'),('',''),('','\u{a953}'),('',''),('','\u{aa36}'),('',''),('',''),('',''),('\u{fe24}','\u{fe26}'),('',''),('','\u{101fd}'),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V5_2:&'static [(char,char)] = &[ ('',''),('','\u{82d}'),('',''),('\u{900}','\u{900}'),('',''),('\u{955}','\u{955}'),('',''),('',''),('',''),('','\u{109d}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1a5e}'),('\u{1a60}','\u{1a7c}'),('\u{1a7f}',''),('',''),('',''),('\u{1cd0}',''),('\u{1dfd}','\u{1dfd}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{2cf1}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a8e0}',''),('',''),('\u{a980}',''),('',''),('',''),('',''),('',''),('',''),('','\u{abed}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{11080}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V6_0:&'static [(char,char)] = &[ ('',''),('',''),('\u{65f}','\u{65f}'),('','\u{85b}'),('',''),('\u{93a}',''),('',''),('\u{956}','\u{957}'),('',''),('',''),('',''),('',''),('',''),('','\u{f8f}'),('',''),('\u{135d}','\u{135e}'),('','\u{1bf3}'),('',''),('\u{1dfc}','\u{1dfc}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2d7f}','\u{2d7f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V6_1:&'static [(char,char)] = &[ ('',''),('\u{604}','\u{604}'),('',''),('',''),('\u{8e4}','\u{8fe}'),('',''),('',''),('',''),('',''),('',''),('\u{1bab}','\u{1bad}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a674}','\u{a67b}'),('\u{a69f}','\u{a69f}'),('',''),('',''),('',''),('','\u{aaf6}'),('',''),('',''),('',''),('',''),('',''),('\u{11100}','\u{11134}'),('',''),('\u{11180}',''),('',''),('','\u{116b7}'),('',''),('',''),('',''),('\u{16f8f}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V6_2:&'static [(char,char)] = &[('','')];
            pub const V6_3:&'static [(char,char)] = &[('\u{61c}','\u{61c}'),('\u{2066}','\u{2069}')];
            pub const V7_0:&'static [(char,char)] = &[ ('',''),('',''),('',''),('\u{605}','\u{605}'),('',''),('',''),('\u{8ff}','\u{8ff}'),('',''),('',''),('\u{c00}','\u{c00}'),('',''),('\u{c81}','\u{c81}'),('\u{d01}','\u{d01}'),('',''),('',''),('',''),('\u{1ab0}','\u{1abe}'),('\u{1cf8}','\u{1cf9}'),('\u{1de7}','\u{1df5}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{aa7c}',''),('',''),('',''),('\u{fe27}','\u{fe2d}'),('',''),('',''),('\u{102e0}',''),('',''),('','\u{1037a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10ae6}'),('',''),('',''),('',''),('',''),('\u{1107f}','\u{1107f}'),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{112ea}'),('',''),('\u{11301}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1133c}',''),('',''),('','\u{1134d}'),('\u{11357}','\u{11357}'),('',''),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('',''),('',''),('','\u{115b5}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16af0}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1bca3}'),('',''),('','\u{1e8d6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V8_0:&'static [(char,char)] = &[ ('',''),('\u{8e3}','\u{8e3}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a69e}','\u{a69e}'),('',''),('',''),('',''),('',''),('',''),('\u{fe2e}','\u{fe2f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{111c9}','\u{111cc}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{11300}','\u{11300}'),('',''),('','\u{115dd}'),('',''),('\u{1171d}','\u{1172b}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const V9_0:&'static [(char,char)] = &[ ('',''),('\u{8d4}','\u{8e2}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1dfb}','\u{1dfb}'),('',''),('',''),('',''),('\u{a8c5}','\u{a8c5}'),('',''),('',''),('',''),('\u{1123e}','\u{1123e}'),('',''),('',''),('',''),('',''),('',''),('','\u{11c36}'),('\u{11c38}',''),('',''),('',''),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),('',''),('',''),('',''),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('','\u{1e94a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
        }
        
        pub mod cases
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub const CASE_FOLDING_SIMPLE:&'static [(char, &'static [char])] = &[('A',&['a']),('B',&['b']),('C',&['c']),('D',&['d']),('E',&['e']),('F',&['f']),('G',&['g']),('H',&['h']),('I',&['i']),('J',&['j']),('K',&['k','']),('L',&['l']),('M',&['m']),('N',&['n']),('O',&['o']),('P',&['p']),('Q',&['q']),('R',&['r']),('S',&['s','']),('T',&['t']),('U',&['u']),('V',&['v']),('W',&['w']),('X',&['x']),('Y',&['y']),('Z',&['z']),('a',&['A']),('b',&['B']),('c',&['C']),('d',&['D']),('e',&['E']),('f',&['F']),('g',&['G']),('h',&['H']),('i',&['I']),('j',&['J']),('k',&['K','']),('l',&['L']),('m',&['M']),('n',&['N']),('o',&['O']),('p',&['P']),('q',&['Q']),('r',&['R']),('s',&['S','']),('t',&['T']),('u',&['U']),('v',&['V']),('w',&['W']),('x',&['X']),('y',&['Y']),('z',&['Z']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['S','s']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','']),('',&['','']),('',&['','']),('',&['','']),('',&['','']),('',&['','']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('\u{345}',&['','','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['','','']),('',&['\u{345}','','']),('',&['','']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['','','']),('',&['\u{345}','','']),('',&['','']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','','']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['','','']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['','']),('',&['','','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['','']),('',&['','','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','']),('',&['','']),('',&['','']),('',&['','','']),('',&['','','']),('',&['','']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['\u{345}','','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['K','k']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['','']),('',&['','']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']),('',&['']) ];
        }
        
        pub mod categories 
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] = &[ ("Cased_Letter", CASED_LETTER),("Close_Punctuation", CLOSE_PUNCTUATION),("Connector_Punctuation", CONNECTOR_PUNCTUATION),("Control", CONTROL),("Currency_Symbol", CURRENCY_SYMBOL),("Dash_Punctuation", DASH_PUNCTUATION),("Decimal_Number", DECIMAL_NUMBER),("Enclosing_Mark", ENCLOSING_MARK),("Final_Punctuation", FINAL_PUNCTUATION),("Format", FORMAT),("Initial_Punctuation", INITIAL_PUNCTUATION),("Letter", LETTER),("Letter_Number", LETTER_NUMBER),("Line_Separator", LINE_SEPARATOR),("Lowercase_Letter", LOWERCASE_LETTER),("Mark", MARK),("Math_Symbol", MATH_SYMBOL),("Modifier_Letter", MODIFIER_LETTER),("Modifier_Symbol", MODIFIER_SYMBOL),("Nonspacing_Mark", NONSPACING_MARK),("Number", NUMBER),("Open_Punctuation", OPEN_PUNCTUATION),("Other", OTHER),("Other_Letter", OTHER_LETTER),("Other_Number", OTHER_NUMBER),("Other_Punctuation", OTHER_PUNCTUATION),("Other_Symbol", OTHER_SYMBOL),("Paragraph_Separator", PARAGRAPH_SEPARATOR),("Private_Use", PRIVATE_USE),("Punctuation", PUNCTUATION),("Separator", SEPARATOR),("Space_Separator", SPACE_SEPARATOR),("Spacing_Mark", SPACING_MARK),("Symbol", SYMBOL),("Titlecase_Letter", TITLECASE_LETTER),("Unassigned", UNASSIGNED),("Uppercase_Letter", UPPERCASE_LETTER) ];
            pub const CASED_LETTER:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const CLOSE_PUNCTUATION:&'static [(char,char)] = &[ (')',')'),(']',']'),('}','}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const CONNECTOR_PUNCTUATION:&'static [(char,char)] = &[ ('_','_'),('',''),('',''),('',''),('',''),('','') ];
            pub const CONTROL:&'static [(char,char)] = &[('\0','\u{1f}'),('\u{7f}','\u{9f}')];
            pub const CURRENCY_SYMBOL:&'static [(char,char)] = &[ ('$','$'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const DASH_PUNCTUATION:&'static [(char,char)] = &[ ('-','-'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const DECIMAL_NUMBER:&'static [(char,char)] = &[ ('0','9'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const ENCLOSING_MARK:&'static [(char,char)] = &[ ('\u{488}','\u{489}'),('\u{1abe}','\u{1abe}'),('\u{20dd}','\u{20e0}'),('\u{20e2}','\u{20e4}'),('\u{a670}','\u{a672}') ];
            pub const FINAL_PUNCTUATION:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const FORMAT:&'static [(char,char)] = &[ ('\u{ad}','\u{ad}'),('\u{600}','\u{605}'),('\u{61c}','\u{61c}'),('\u{6dd}','\u{6dd}'),('\u{70f}','\u{70f}'),('\u{890}','\u{891}'),('\u{8e2}','\u{8e2}'),('\u{180e}','\u{180e}'),('\u{200b}','\u{200f}'),('\u{202a}','\u{202e}'),('\u{2060}','\u{2064}'),('\u{2066}','\u{206f}'),('\u{feff}','\u{feff}'),('\u{fff9}','\u{fffb}'),('\u{110bd}','\u{110bd}'),('\u{110cd}','\u{110cd}'),('\u{13430}','\u{1343f}'),('\u{1bca0}','\u{1bca3}'),('\u{1d173}','\u{1d17a}'),('\u{e0001}','\u{e0001}'),('\u{e0020}','\u{e007f}') ];
            pub const INITIAL_PUNCTUATION:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const LETTER:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const LETTER_NUMBER:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const LINE_SEPARATOR:&'static [(char,char)] = &[('\u{2028}','\u{2028}')];
            pub const LOWERCASE_LETTER:&'static [(char,char)] = &[ ('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const MARK:&'static [(char,char)] = &[ ('\u{300}','\u{36f}'),('\u{483}','\u{489}'),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('\u{610}','\u{61a}'),('\u{64b}','\u{65f}'),('\u{670}','\u{670}'),('\u{6d6}','\u{6dc}'),('\u{6df}','\u{6e4}'),('\u{6e7}','\u{6e8}'),('\u{6ea}','\u{6ed}'),('\u{711}','\u{711}'),('\u{730}','\u{74a}'),('\u{7a6}','\u{7b0}'),('\u{7eb}','\u{7f3}'),('\u{7fd}','\u{7fd}'),('\u{816}','\u{819}'),('\u{81b}','\u{823}'),('\u{825}','\u{827}'),('\u{829}','\u{82d}'),('\u{859}','\u{85b}'),('\u{897}','\u{89f}'),('\u{8ca}','\u{8e1}'),('\u{8e3}',''),('\u{93a}','\u{93c}'),('',''),('\u{951}','\u{957}'),('\u{962}','\u{963}'),('\u{981}',''),('\u{9bc}','\u{9bc}'),('\u{9be}','\u{9c4}'),('',''),('','\u{9cd}'),('\u{9d7}','\u{9d7}'),('\u{9e2}','\u{9e3}'),('\u{9fe}','\u{9fe}'),('\u{a01}',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('\u{a70}','\u{a71}'),('\u{a75}','\u{a75}'),('\u{a81}',''),('\u{abc}','\u{abc}'),('','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('\u{ae2}','\u{ae3}'),('\u{afa}','\u{aff}'),('\u{b01}',''),('\u{b3c}','\u{b3c}'),('\u{b3e}','\u{b44}'),('',''),('','\u{b4d}'),('\u{b55}','\u{b57}'),('\u{b62}','\u{b63}'),('\u{b82}','\u{b82}'),('\u{bbe}',''),('',''),('','\u{bcd}'),('\u{bd7}','\u{bd7}'),('\u{c00}','\u{c04}'),('\u{c3c}','\u{c3c}'),('\u{c3e}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('\u{c62}','\u{c63}'),('\u{c81}',''),('\u{cbc}','\u{cbc}'),('',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('\u{ce2}','\u{ce3}'),('',''),('\u{d00}',''),('\u{d3b}','\u{d3c}'),('\u{d3e}','\u{d44}'),('',''),('','\u{d4d}'),('\u{d57}','\u{d57}'),('\u{d62}','\u{d63}'),('\u{d81}',''),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('\u{e31}','\u{e31}'),('\u{e34}','\u{e3a}'),('\u{e47}','\u{e4e}'),('\u{eb1}','\u{eb1}'),('\u{eb4}','\u{ebc}'),('\u{ec8}','\u{ece}'),('\u{f18}','\u{f19}'),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('',''),('\u{f71}','\u{f84}'),('\u{f86}','\u{f87}'),('\u{f8d}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('','\u{103e}'),('','\u{1059}'),('\u{105e}','\u{1060}'),('',''),('',''),('\u{1071}','\u{1074}'),('\u{1082}','\u{108d}'),('',''),('','\u{109d}'),('\u{135d}','\u{135f}'),('\u{1712}','\u{1715}'),('\u{1732}','\u{1734}'),('\u{1752}','\u{1753}'),('\u{1772}','\u{1773}'),('\u{17b4}','\u{17d3}'),('\u{17dd}','\u{17dd}'),('\u{180b}','\u{180d}'),('\u{180f}','\u{180f}'),('\u{1885}','\u{1886}'),('\u{18a9}','\u{18a9}'),('\u{1920}',''),('','\u{193b}'),('\u{1a17}','\u{1a1b}'),('','\u{1a5e}'),('\u{1a60}','\u{1a7c}'),('\u{1a7f}','\u{1a7f}'),('\u{1ab0}','\u{1ace}'),('\u{1b00}',''),('\u{1b34}','\u{1b44}'),('\u{1b6b}','\u{1b73}'),('\u{1b80}',''),('','\u{1bad}'),('\u{1be6}','\u{1bf3}'),('','\u{1c37}'),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('','\u{1cf9}'),('\u{1dc0}','\u{1dff}'),('\u{20d0}','\u{20f0}'),('\u{2cef}','\u{2cf1}'),('\u{2d7f}','\u{2d7f}'),('\u{2de0}','\u{2dff}'),('\u{302a}','\u{302f}'),('\u{3099}','\u{309a}'),('\u{a66f}','\u{a672}'),('\u{a674}','\u{a67d}'),('\u{a69e}','\u{a69f}'),('\u{a6f0}','\u{a6f1}'),('\u{a802}','\u{a802}'),('\u{a806}','\u{a806}'),('\u{a80b}','\u{a80b}'),('',''),('\u{a82c}','\u{a82c}'),('',''),('','\u{a8c5}'),('\u{a8e0}','\u{a8f1}'),('\u{a8ff}','\u{a8ff}'),('\u{a926}','\u{a92d}'),('\u{a947}','\u{a953}'),('\u{a980}',''),('\u{a9b3}','\u{a9c0}'),('\u{a9e5}','\u{a9e5}'),('\u{aa29}','\u{aa36}'),('\u{aa43}','\u{aa43}'),('\u{aa4c}',''),('',''),('\u{aab0}','\u{aab0}'),('\u{aab2}','\u{aab4}'),('\u{aab7}','\u{aab8}'),('\u{aabe}','\u{aabf}'),('\u{aac1}','\u{aac1}'),('',''),('','\u{aaf6}'),('',''),('','\u{abed}'),('\u{fb1e}','\u{fb1e}'),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('\u{101fd}','\u{101fd}'),('\u{102e0}','\u{102e0}'),('\u{10376}','\u{1037a}'),('\u{10a01}','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}','\u{10a0f}'),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('\u{10ae5}','\u{10ae6}'),('\u{10d24}','\u{10d27}'),('\u{10d69}','\u{10d6d}'),('\u{10eab}','\u{10eac}'),('\u{10efc}','\u{10eff}'),('\u{10f46}','\u{10f50}'),('\u{10f82}','\u{10f85}'),('',''),('\u{11038}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{11073}','\u{11074}'),('\u{1107f}',''),('','\u{110ba}'),('\u{110c2}','\u{110c2}'),('\u{11100}','\u{11102}'),('\u{11127}','\u{11134}'),('',''),('\u{11173}','\u{11173}'),('\u{11180}',''),('','\u{111c0}'),('\u{111c9}','\u{111cc}'),('','\u{111cf}'),('','\u{11237}'),('\u{1123e}','\u{1123e}'),('\u{11241}','\u{11241}'),('\u{112df}','\u{112ea}'),('\u{11300}',''),('\u{1133b}','\u{1133c}'),('\u{1133e}',''),('',''),('','\u{1134d}'),('\u{11357}','\u{11357}'),('',''),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('\u{113b8}','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('','\u{113d0}'),('\u{113d2}','\u{113d2}'),('\u{113e1}','\u{113e2}'),('','\u{11446}'),('\u{1145e}','\u{1145e}'),('\u{114b0}','\u{114c3}'),('\u{115af}','\u{115b5}'),('','\u{115c0}'),('\u{115dc}','\u{115dd}'),('','\u{11640}'),('\u{116ab}','\u{116b7}'),('\u{1171d}','\u{1172b}'),('','\u{1183a}'),('\u{11930}',''),('',''),('\u{1193b}','\u{1193e}'),('',''),('','\u{11943}'),('','\u{119d7}'),('\u{119da}','\u{119e0}'),('',''),('\u{11a01}','\u{11a0a}'),('\u{11a33}',''),('\u{11a3b}','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('\u{11a51}','\u{11a5b}'),('\u{11a8a}','\u{11a99}'),('','\u{11c36}'),('\u{11c38}','\u{11c3f}'),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),('\u{11d31}','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d45}'),('\u{11d47}','\u{11d47}'),('',''),('\u{11d90}','\u{11d91}'),('','\u{11d97}'),('\u{11ef3}',''),('\u{11f00}','\u{11f01}'),('',''),('','\u{11f3a}'),('','\u{11f42}'),('\u{11f5a}','\u{11f5a}'),('\u{13440}','\u{13440}'),('\u{13447}','\u{13455}'),('\u{1611e}','\u{1612f}'),('\u{16af0}','\u{16af4}'),('\u{16b30}','\u{16b36}'),('\u{16f4f}','\u{16f4f}'),('',''),('\u{16f8f}','\u{16f92}'),('\u{16fe4}','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('\u{1bc9d}','\u{1bc9e}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d165}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('\u{1e08f}','\u{1e08f}'),('\u{1e130}','\u{1e136}'),('\u{1e2ae}','\u{1e2ae}'),('\u{1e2ec}','\u{1e2ef}'),('\u{1e4ec}','\u{1e4ef}'),('\u{1e5ee}','\u{1e5ef}'),('\u{1e8d0}','\u{1e8d6}'),('\u{1e944}','\u{1e94a}'),('\u{e0100}','\u{e01ef}') ];
            pub const MATH_SYMBOL:&'static [(char,char)] = &[ ('+','+'),('<','>'),('|','|'),('~','~'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const MODIFIER_LETTER:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{ff9e}','\u{ff9f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const MODIFIER_SYMBOL:&'static [(char,char)] = &[ ('^','^'),('`','`'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const NONSPACING_MARK:&'static [(char,char)] = &[ ('\u{300}','\u{36f}'),('\u{483}','\u{487}'),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('\u{610}','\u{61a}'),('\u{64b}','\u{65f}'),('\u{670}','\u{670}'),('\u{6d6}','\u{6dc}'),('\u{6df}','\u{6e4}'),('\u{6e7}','\u{6e8}'),('\u{6ea}','\u{6ed}'),('\u{711}','\u{711}'),('\u{730}','\u{74a}'),('\u{7a6}','\u{7b0}'),('\u{7eb}','\u{7f3}'),('\u{7fd}','\u{7fd}'),('\u{816}','\u{819}'),('\u{81b}','\u{823}'),('\u{825}','\u{827}'),('\u{829}','\u{82d}'),('\u{859}','\u{85b}'),('\u{897}','\u{89f}'),('\u{8ca}','\u{8e1}'),('\u{8e3}','\u{902}'),('\u{93a}','\u{93a}'),('\u{93c}','\u{93c}'),('\u{941}','\u{948}'),('\u{94d}','\u{94d}'),('\u{951}','\u{957}'),('\u{962}','\u{963}'),('\u{981}','\u{981}'),('\u{9bc}','\u{9bc}'),('\u{9c1}','\u{9c4}'),('\u{9cd}','\u{9cd}'),('\u{9e2}','\u{9e3}'),('\u{9fe}','\u{9fe}'),('\u{a01}','\u{a02}'),('\u{a3c}','\u{a3c}'),('\u{a41}','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('\u{a70}','\u{a71}'),('\u{a75}','\u{a75}'),('\u{a81}','\u{a82}'),('\u{abc}','\u{abc}'),('\u{ac1}','\u{ac5}'),('\u{ac7}','\u{ac8}'),('\u{acd}','\u{acd}'),('\u{ae2}','\u{ae3}'),('\u{afa}','\u{aff}'),('\u{b01}','\u{b01}'),('\u{b3c}','\u{b3c}'),('\u{b3f}','\u{b3f}'),('\u{b41}','\u{b44}'),('\u{b4d}','\u{b4d}'),('\u{b55}','\u{b56}'),('\u{b62}','\u{b63}'),('\u{b82}','\u{b82}'),('\u{bc0}','\u{bc0}'),('\u{bcd}','\u{bcd}'),('\u{c00}','\u{c00}'),('\u{c04}','\u{c04}'),('\u{c3c}','\u{c3c}'),('\u{c3e}','\u{c40}'),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('\u{c62}','\u{c63}'),('\u{c81}','\u{c81}'),('\u{cbc}','\u{cbc}'),('\u{cbf}','\u{cbf}'),('\u{cc6}','\u{cc6}'),('\u{ccc}','\u{ccd}'),('\u{ce2}','\u{ce3}'),('\u{d00}','\u{d01}'),('\u{d3b}','\u{d3c}'),('\u{d41}','\u{d44}'),('\u{d4d}','\u{d4d}'),('\u{d62}','\u{d63}'),('\u{d81}','\u{d81}'),('\u{dca}','\u{dca}'),('\u{dd2}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('\u{e31}','\u{e31}'),('\u{e34}','\u{e3a}'),('\u{e47}','\u{e4e}'),('\u{eb1}','\u{eb1}'),('\u{eb4}','\u{ebc}'),('\u{ec8}','\u{ece}'),('\u{f18}','\u{f19}'),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('\u{f71}','\u{f7e}'),('\u{f80}','\u{f84}'),('\u{f86}','\u{f87}'),('\u{f8d}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('\u{102d}','\u{1030}'),('\u{1032}','\u{1037}'),('\u{1039}','\u{103a}'),('\u{103d}','\u{103e}'),('\u{1058}','\u{1059}'),('\u{105e}','\u{1060}'),('\u{1071}','\u{1074}'),('\u{1082}','\u{1082}'),('\u{1085}','\u{1086}'),('\u{108d}','\u{108d}'),('\u{109d}','\u{109d}'),('\u{135d}','\u{135f}'),('\u{1712}','\u{1714}'),('\u{1732}','\u{1733}'),('\u{1752}','\u{1753}'),('\u{1772}','\u{1773}'),('\u{17b4}','\u{17b5}'),('\u{17b7}','\u{17bd}'),('\u{17c6}','\u{17c6}'),('\u{17c9}','\u{17d3}'),('\u{17dd}','\u{17dd}'),('\u{180b}','\u{180d}'),('\u{180f}','\u{180f}'),('\u{1885}','\u{1886}'),('\u{18a9}','\u{18a9}'),('\u{1920}','\u{1922}'),('\u{1927}','\u{1928}'),('\u{1932}','\u{1932}'),('\u{1939}','\u{193b}'),('\u{1a17}','\u{1a18}'),('\u{1a1b}','\u{1a1b}'),('\u{1a56}','\u{1a56}'),('\u{1a58}','\u{1a5e}'),('\u{1a60}','\u{1a60}'),('\u{1a62}','\u{1a62}'),('\u{1a65}','\u{1a6c}'),('\u{1a73}','\u{1a7c}'),('\u{1a7f}','\u{1a7f}'),('\u{1ab0}','\u{1abd}'),('\u{1abf}','\u{1ace}'),('\u{1b00}','\u{1b03}'),('\u{1b34}','\u{1b34}'),('\u{1b36}','\u{1b3a}'),('\u{1b3c}','\u{1b3c}'),('\u{1b42}','\u{1b42}'),('\u{1b6b}','\u{1b73}'),('\u{1b80}','\u{1b81}'),('\u{1ba2}','\u{1ba5}'),('\u{1ba8}','\u{1ba9}'),('\u{1bab}','\u{1bad}'),('\u{1be6}','\u{1be6}'),('\u{1be8}','\u{1be9}'),('\u{1bed}','\u{1bed}'),('\u{1bef}','\u{1bf1}'),('\u{1c2c}','\u{1c33}'),('\u{1c36}','\u{1c37}'),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}','\u{1ce0}'),('\u{1ce2}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('\u{1cf8}','\u{1cf9}'),('\u{1dc0}','\u{1dff}'),('\u{20d0}','\u{20dc}'),('\u{20e1}','\u{20e1}'),('\u{20e5}','\u{20f0}'),('\u{2cef}','\u{2cf1}'),('\u{2d7f}','\u{2d7f}'),('\u{2de0}','\u{2dff}'),('\u{302a}','\u{302d}'),('\u{3099}','\u{309a}'),('\u{a66f}','\u{a66f}'),('\u{a674}','\u{a67d}'),('\u{a69e}','\u{a69f}'),('\u{a6f0}','\u{a6f1}'),('\u{a802}','\u{a802}'),('\u{a806}','\u{a806}'),('\u{a80b}','\u{a80b}'),('\u{a825}','\u{a826}'),('\u{a82c}','\u{a82c}'),('\u{a8c4}','\u{a8c5}'),('\u{a8e0}','\u{a8f1}'),('\u{a8ff}','\u{a8ff}'),('\u{a926}','\u{a92d}'),('\u{a947}','\u{a951}'),('\u{a980}','\u{a982}'),('\u{a9b3}','\u{a9b3}'),('\u{a9b6}','\u{a9b9}'),('\u{a9bc}','\u{a9bd}'),('\u{a9e5}','\u{a9e5}'),('\u{aa29}','\u{aa2e}'),('\u{aa31}','\u{aa32}'),('\u{aa35}','\u{aa36}'),('\u{aa43}','\u{aa43}'),('\u{aa4c}','\u{aa4c}'),('\u{aa7c}','\u{aa7c}'),('\u{aab0}','\u{aab0}'),('\u{aab2}','\u{aab4}'),('\u{aab7}','\u{aab8}'),('\u{aabe}','\u{aabf}'),('\u{aac1}','\u{aac1}'),('\u{aaec}','\u{aaed}'),('\u{aaf6}','\u{aaf6}'),('\u{abe5}','\u{abe5}'),('\u{abe8}','\u{abe8}'),('\u{abed}','\u{abed}'),('\u{fb1e}','\u{fb1e}'),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('\u{101fd}','\u{101fd}'),('\u{102e0}','\u{102e0}'),('\u{10376}','\u{1037a}'),('\u{10a01}','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}','\u{10a0f}'),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('\u{10ae5}','\u{10ae6}'),('\u{10d24}','\u{10d27}'),('\u{10d69}','\u{10d6d}'),('\u{10eab}','\u{10eac}'),('\u{10efc}','\u{10eff}'),('\u{10f46}','\u{10f50}'),('\u{10f82}','\u{10f85}'),('\u{11001}','\u{11001}'),('\u{11038}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{11073}','\u{11074}'),('\u{1107f}','\u{11081}'),('\u{110b3}','\u{110b6}'),('\u{110b9}','\u{110ba}'),('\u{110c2}','\u{110c2}'),('\u{11100}','\u{11102}'),('\u{11127}','\u{1112b}'),('\u{1112d}','\u{11134}'),('\u{11173}','\u{11173}'),('\u{11180}','\u{11181}'),('\u{111b6}','\u{111be}'),('\u{111c9}','\u{111cc}'),('\u{111cf}','\u{111cf}'),('\u{1122f}','\u{11231}'),('\u{11234}','\u{11234}'),('\u{11236}','\u{11237}'),('\u{1123e}','\u{1123e}'),('\u{11241}','\u{11241}'),('\u{112df}','\u{112df}'),('\u{112e3}','\u{112ea}'),('\u{11300}','\u{11301}'),('\u{1133b}','\u{1133c}'),('\u{11340}','\u{11340}'),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('\u{113bb}','\u{113c0}'),('\u{113ce}','\u{113ce}'),('\u{113d0}','\u{113d0}'),('\u{113d2}','\u{113d2}'),('\u{113e1}','\u{113e2}'),('\u{11438}','\u{1143f}'),('\u{11442}','\u{11444}'),('\u{11446}','\u{11446}'),('\u{1145e}','\u{1145e}'),('\u{114b3}','\u{114b8}'),('\u{114ba}','\u{114ba}'),('\u{114bf}','\u{114c0}'),('\u{114c2}','\u{114c3}'),('\u{115b2}','\u{115b5}'),('\u{115bc}','\u{115bd}'),('\u{115bf}','\u{115c0}'),('\u{115dc}','\u{115dd}'),('\u{11633}','\u{1163a}'),('\u{1163d}','\u{1163d}'),('\u{1163f}','\u{11640}'),('\u{116ab}','\u{116ab}'),('\u{116ad}','\u{116ad}'),('\u{116b0}','\u{116b5}'),('\u{116b7}','\u{116b7}'),('\u{1171d}','\u{1171d}'),('\u{1171f}','\u{1171f}'),('\u{11722}','\u{11725}'),('\u{11727}','\u{1172b}'),('\u{1182f}','\u{11837}'),('\u{11839}','\u{1183a}'),('\u{1193b}','\u{1193c}'),('\u{1193e}','\u{1193e}'),('\u{11943}','\u{11943}'),('\u{119d4}','\u{119d7}'),('\u{119da}','\u{119db}'),('\u{119e0}','\u{119e0}'),('\u{11a01}','\u{11a0a}'),('\u{11a33}','\u{11a38}'),('\u{11a3b}','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('\u{11a51}','\u{11a56}'),('\u{11a59}','\u{11a5b}'),('\u{11a8a}','\u{11a96}'),('\u{11a98}','\u{11a99}'),('\u{11c30}','\u{11c36}'),('\u{11c38}','\u{11c3d}'),('\u{11c3f}','\u{11c3f}'),('\u{11c92}','\u{11ca7}'),('\u{11caa}','\u{11cb0}'),('\u{11cb2}','\u{11cb3}'),('\u{11cb5}','\u{11cb6}'),('\u{11d31}','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d45}'),('\u{11d47}','\u{11d47}'),('\u{11d90}','\u{11d91}'),('\u{11d95}','\u{11d95}'),('\u{11d97}','\u{11d97}'),('\u{11ef3}','\u{11ef4}'),('\u{11f00}','\u{11f01}'),('\u{11f36}','\u{11f3a}'),('\u{11f40}','\u{11f40}'),('\u{11f42}','\u{11f42}'),('\u{11f5a}','\u{11f5a}'),('\u{13440}','\u{13440}'),('\u{13447}','\u{13455}'),('\u{1611e}','\u{16129}'),('\u{1612d}','\u{1612f}'),('\u{16af0}','\u{16af4}'),('\u{16b30}','\u{16b36}'),('\u{16f4f}','\u{16f4f}'),('\u{16f8f}','\u{16f92}'),('\u{16fe4}','\u{16fe4}'),('\u{1bc9d}','\u{1bc9e}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d167}','\u{1d169}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('\u{1e08f}','\u{1e08f}'),('\u{1e130}','\u{1e136}'),('\u{1e2ae}','\u{1e2ae}'),('\u{1e2ec}','\u{1e2ef}'),('\u{1e4ec}','\u{1e4ef}'),('\u{1e5ee}','\u{1e5ef}'),('\u{1e8d0}','\u{1e8d6}'),('\u{1e944}','\u{1e94a}'),('\u{e0100}','\u{e01ef}') ];
            pub const NUMBER:&'static [(char,char)] = &[ ('0','9'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const OPEN_PUNCTUATION:&'static [(char,char)] = &[ ('(','('),('[','['),('{','{'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const OTHER:&'static [(char,char)] = &[ ('\0','\u{1f}'),('\u{7f}','\u{9f}'),('\u{ad}','\u{ad}'),('\u{378}','\u{379}'),('\u{380}','\u{383}'),('\u{38b}','\u{38b}'),('\u{38d}','\u{38d}'),('\u{3a2}','\u{3a2}'),('\u{530}','\u{530}'),('\u{557}','\u{558}'),('\u{58b}','\u{58c}'),('\u{590}','\u{590}'),('\u{5c8}','\u{5cf}'),('\u{5eb}','\u{5ee}'),('\u{5f5}','\u{605}'),('\u{61c}','\u{61c}'),('\u{6dd}','\u{6dd}'),('\u{70e}','\u{70f}'),('\u{74b}','\u{74c}'),('\u{7b2}','\u{7bf}'),('\u{7fb}','\u{7fc}'),('\u{82e}','\u{82f}'),('\u{83f}','\u{83f}'),('\u{85c}','\u{85d}'),('\u{85f}','\u{85f}'),('\u{86b}','\u{86f}'),('\u{88f}','\u{896}'),('\u{8e2}','\u{8e2}'),('\u{984}','\u{984}'),('\u{98d}','\u{98e}'),('\u{991}','\u{992}'),('\u{9a9}','\u{9a9}'),('\u{9b1}','\u{9b1}'),('\u{9b3}','\u{9b5}'),('\u{9ba}','\u{9bb}'),('\u{9c5}','\u{9c6}'),('\u{9c9}','\u{9ca}'),('\u{9cf}','\u{9d6}'),('\u{9d8}','\u{9db}'),('\u{9de}','\u{9de}'),('\u{9e4}','\u{9e5}'),('\u{9ff}','\u{a00}'),('\u{a04}','\u{a04}'),('\u{a0b}','\u{a0e}'),('\u{a11}','\u{a12}'),('\u{a29}','\u{a29}'),('\u{a31}','\u{a31}'),('\u{a34}','\u{a34}'),('\u{a37}','\u{a37}'),('\u{a3a}','\u{a3b}'),('\u{a3d}','\u{a3d}'),('\u{a43}','\u{a46}'),('\u{a49}','\u{a4a}'),('\u{a4e}','\u{a50}'),('\u{a52}','\u{a58}'),('\u{a5d}','\u{a5d}'),('\u{a5f}','\u{a65}'),('\u{a77}','\u{a80}'),('\u{a84}','\u{a84}'),('\u{a8e}','\u{a8e}'),('\u{a92}','\u{a92}'),('\u{aa9}','\u{aa9}'),('\u{ab1}','\u{ab1}'),('\u{ab4}','\u{ab4}'),('\u{aba}','\u{abb}'),('\u{ac6}','\u{ac6}'),('\u{aca}','\u{aca}'),('\u{ace}','\u{acf}'),('\u{ad1}','\u{adf}'),('\u{ae4}','\u{ae5}'),('\u{af2}','\u{af8}'),('\u{b00}','\u{b00}'),('\u{b04}','\u{b04}'),('\u{b0d}','\u{b0e}'),('\u{b11}','\u{b12}'),('\u{b29}','\u{b29}'),('\u{b31}','\u{b31}'),('\u{b34}','\u{b34}'),('\u{b3a}','\u{b3b}'),('\u{b45}','\u{b46}'),('\u{b49}','\u{b4a}'),('\u{b4e}','\u{b54}'),('\u{b58}','\u{b5b}'),('\u{b5e}','\u{b5e}'),('\u{b64}','\u{b65}'),('\u{b78}','\u{b81}'),('\u{b84}','\u{b84}'),('\u{b8b}','\u{b8d}'),('\u{b91}','\u{b91}'),('\u{b96}','\u{b98}'),('\u{b9b}','\u{b9b}'),('\u{b9d}','\u{b9d}'),('\u{ba0}','\u{ba2}'),('\u{ba5}','\u{ba7}'),('\u{bab}','\u{bad}'),('\u{bba}','\u{bbd}'),('\u{bc3}','\u{bc5}'),('\u{bc9}','\u{bc9}'),('\u{bce}','\u{bcf}'),('\u{bd1}','\u{bd6}'),('\u{bd8}','\u{be5}'),('\u{bfb}','\u{bff}'),('\u{c0d}','\u{c0d}'),('\u{c11}','\u{c11}'),('\u{c29}','\u{c29}'),('\u{c3a}','\u{c3b}'),('\u{c45}','\u{c45}'),('\u{c49}','\u{c49}'),('\u{c4e}','\u{c54}'),('\u{c57}','\u{c57}'),('\u{c5b}','\u{c5c}'),('\u{c5e}','\u{c5f}'),('\u{c64}','\u{c65}'),('\u{c70}','\u{c76}'),('\u{c8d}','\u{c8d}'),('\u{c91}','\u{c91}'),('\u{ca9}','\u{ca9}'),('\u{cb4}','\u{cb4}'),('\u{cba}','\u{cbb}'),('\u{cc5}','\u{cc5}'),('\u{cc9}','\u{cc9}'),('\u{cce}','\u{cd4}'),('\u{cd7}','\u{cdc}'),('\u{cdf}','\u{cdf}'),('\u{ce4}','\u{ce5}'),('\u{cf0}','\u{cf0}'),('\u{cf4}','\u{cff}'),('\u{d0d}','\u{d0d}'),('\u{d11}','\u{d11}'),('\u{d45}','\u{d45}'),('\u{d49}','\u{d49}'),('\u{d50}','\u{d53}'),('\u{d64}','\u{d65}'),('\u{d80}','\u{d80}'),('\u{d84}','\u{d84}'),('\u{d97}','\u{d99}'),('\u{db2}','\u{db2}'),('\u{dbc}','\u{dbc}'),('\u{dbe}','\u{dbf}'),('\u{dc7}','\u{dc9}'),('\u{dcb}','\u{dce}'),('\u{dd5}','\u{dd5}'),('\u{dd7}','\u{dd7}'),('\u{de0}','\u{de5}'),('\u{df0}','\u{df1}'),('\u{df5}','\u{e00}'),('\u{e3b}','\u{e3e}'),('\u{e5c}','\u{e80}'),('\u{e83}','\u{e83}'),('\u{e85}','\u{e85}'),('\u{e8b}','\u{e8b}'),('\u{ea4}','\u{ea4}'),('\u{ea6}','\u{ea6}'),('\u{ebe}','\u{ebf}'),('\u{ec5}','\u{ec5}'),('\u{ec7}','\u{ec7}'),('\u{ecf}','\u{ecf}'),('\u{eda}','\u{edb}'),('\u{ee0}','\u{eff}'),('\u{f48}','\u{f48}'),('\u{f6d}','\u{f70}'),('\u{f98}','\u{f98}'),('\u{fbd}','\u{fbd}'),('\u{fcd}','\u{fcd}'),('\u{fdb}','\u{fff}'),('\u{10c6}','\u{10c6}'),('\u{10c8}','\u{10cc}'),('\u{10ce}','\u{10cf}'),('\u{1249}','\u{1249}'),('\u{124e}','\u{124f}'),('\u{1257}','\u{1257}'),('\u{1259}','\u{1259}'),('\u{125e}','\u{125f}'),('\u{1289}','\u{1289}'),('\u{128e}','\u{128f}'),('\u{12b1}','\u{12b1}'),('\u{12b6}','\u{12b7}'),('\u{12bf}','\u{12bf}'),('\u{12c1}','\u{12c1}'),('\u{12c6}','\u{12c7}'),('\u{12d7}','\u{12d7}'),('\u{1311}','\u{1311}'),('\u{1316}','\u{1317}'),('\u{135b}','\u{135c}'),('\u{137d}','\u{137f}'),('\u{139a}','\u{139f}'),('\u{13f6}','\u{13f7}'),('\u{13fe}','\u{13ff}'),('\u{169d}','\u{169f}'),('\u{16f9}','\u{16ff}'),('\u{1716}','\u{171e}'),('\u{1737}','\u{173f}'),('\u{1754}','\u{175f}'),('\u{176d}','\u{176d}'),('\u{1771}','\u{1771}'),('\u{1774}','\u{177f}'),('\u{17de}','\u{17df}'),('\u{17ea}','\u{17ef}'),('\u{17fa}','\u{17ff}'),('\u{180e}','\u{180e}'),('\u{181a}','\u{181f}'),('\u{1879}','\u{187f}'),('\u{18ab}','\u{18af}'),('\u{18f6}','\u{18ff}'),('\u{191f}','\u{191f}'),('\u{192c}','\u{192f}'),('\u{193c}','\u{193f}'),('\u{1941}','\u{1943}'),('\u{196e}','\u{196f}'),('\u{1975}','\u{197f}'),('\u{19ac}','\u{19af}'),('\u{19ca}','\u{19cf}'),('\u{19db}','\u{19dd}'),('\u{1a1c}','\u{1a1d}'),('\u{1a5f}','\u{1a5f}'),('\u{1a7d}','\u{1a7e}'),('\u{1a8a}','\u{1a8f}'),('\u{1a9a}','\u{1a9f}'),('\u{1aae}','\u{1aaf}'),('\u{1acf}','\u{1aff}'),('\u{1b4d}','\u{1b4d}'),('\u{1bf4}','\u{1bfb}'),('\u{1c38}','\u{1c3a}'),('\u{1c4a}','\u{1c4c}'),('\u{1c8b}','\u{1c8f}'),('\u{1cbb}','\u{1cbc}'),('\u{1cc8}','\u{1ccf}'),('\u{1cfb}','\u{1cff}'),('\u{1f16}','\u{1f17}'),('\u{1f1e}','\u{1f1f}'),('\u{1f46}','\u{1f47}'),('\u{1f4e}','\u{1f4f}'),('\u{1f58}','\u{1f58}'),('\u{1f5a}','\u{1f5a}'),('\u{1f5c}','\u{1f5c}'),('\u{1f5e}','\u{1f5e}'),('\u{1f7e}','\u{1f7f}'),('\u{1fb5}','\u{1fb5}'),('\u{1fc5}','\u{1fc5}'),('\u{1fd4}','\u{1fd5}'),('\u{1fdc}','\u{1fdc}'),('\u{1ff0}','\u{1ff1}'),('\u{1ff5}','\u{1ff5}'),('\u{1fff}','\u{1fff}'),('\u{200b}','\u{200f}'),('\u{202a}','\u{202e}'),('\u{2060}','\u{206f}'),('\u{2072}','\u{2073}'),('\u{208f}','\u{208f}'),('\u{209d}','\u{209f}'),('\u{20c1}','\u{20cf}'),('\u{20f1}','\u{20ff}'),('\u{218c}','\u{218f}'),('\u{242a}','\u{243f}'),('\u{244b}','\u{245f}'),('\u{2b74}','\u{2b75}'),('\u{2b96}','\u{2b96}'),('\u{2cf4}','\u{2cf8}'),('\u{2d26}','\u{2d26}'),('\u{2d28}','\u{2d2c}'),('\u{2d2e}','\u{2d2f}'),('\u{2d68}','\u{2d6e}'),('\u{2d71}','\u{2d7e}'),('\u{2d97}','\u{2d9f}'),('\u{2da7}','\u{2da7}'),('\u{2daf}','\u{2daf}'),('\u{2db7}','\u{2db7}'),('\u{2dbf}','\u{2dbf}'),('\u{2dc7}','\u{2dc7}'),('\u{2dcf}','\u{2dcf}'),('\u{2dd7}','\u{2dd7}'),('\u{2ddf}','\u{2ddf}'),('\u{2e5e}','\u{2e7f}'),('\u{2e9a}','\u{2e9a}'),('\u{2ef4}','\u{2eff}'),('\u{2fd6}','\u{2fef}'),('\u{3040}','\u{3040}'),('\u{3097}','\u{3098}'),('\u{3100}','\u{3104}'),('\u{3130}','\u{3130}'),('\u{318f}','\u{318f}'),('\u{31e6}','\u{31ee}'),('\u{321f}','\u{321f}'),('\u{a48d}','\u{a48f}'),('\u{a4c7}','\u{a4cf}'),('\u{a62c}','\u{a63f}'),('\u{a6f8}','\u{a6ff}'),('\u{a7ce}','\u{a7cf}'),('\u{a7d2}','\u{a7d2}'),('\u{a7d4}','\u{a7d4}'),('\u{a7dd}','\u{a7f1}'),('\u{a82d}','\u{a82f}'),('\u{a83a}','\u{a83f}'),('\u{a878}','\u{a87f}'),('\u{a8c6}','\u{a8cd}'),('\u{a8da}','\u{a8df}'),('\u{a954}','\u{a95e}'),('\u{a97d}','\u{a97f}'),('\u{a9ce}','\u{a9ce}'),('\u{a9da}','\u{a9dd}'),('\u{a9ff}','\u{a9ff}'),('\u{aa37}','\u{aa3f}'),('\u{aa4e}','\u{aa4f}'),('\u{aa5a}','\u{aa5b}'),('\u{aac3}','\u{aada}'),('\u{aaf7}','\u{ab00}'),('\u{ab07}','\u{ab08}'),('\u{ab0f}','\u{ab10}'),('\u{ab17}','\u{ab1f}'),('\u{ab27}','\u{ab27}'),('\u{ab2f}','\u{ab2f}'),('\u{ab6c}','\u{ab6f}'),('\u{abee}','\u{abef}'),('\u{abfa}','\u{abff}'),('\u{d7a4}','\u{d7af}'),('\u{d7c7}','\u{d7ca}'),('\u{d7fc}','\u{f8ff}'),('\u{fa6e}','\u{fa6f}'),('\u{fada}','\u{faff}'),('\u{fb07}','\u{fb12}'),('\u{fb18}','\u{fb1c}'),('\u{fb37}','\u{fb37}'),('\u{fb3d}','\u{fb3d}'),('\u{fb3f}','\u{fb3f}'),('\u{fb42}','\u{fb42}'),('\u{fb45}','\u{fb45}'),('\u{fbc3}','\u{fbd2}'),('\u{fd90}','\u{fd91}'),('\u{fdc8}','\u{fdce}'),('\u{fdd0}','\u{fdef}'),('\u{fe1a}','\u{fe1f}'),('\u{fe53}','\u{fe53}'),('\u{fe67}','\u{fe67}'),('\u{fe6c}','\u{fe6f}'),('\u{fe75}','\u{fe75}'),('\u{fefd}','\u{ff00}'),('\u{ffbf}','\u{ffc1}'),('\u{ffc8}','\u{ffc9}'),('\u{ffd0}','\u{ffd1}'),('\u{ffd8}','\u{ffd9}'),('\u{ffdd}','\u{ffdf}'),('\u{ffe7}','\u{ffe7}'),('\u{ffef}','\u{fffb}'),('\u{fffe}','\u{ffff}'),('\u{1000c}','\u{1000c}'),('\u{10027}','\u{10027}'),('\u{1003b}','\u{1003b}'),('\u{1003e}','\u{1003e}'),('\u{1004e}','\u{1004f}'),('\u{1005e}','\u{1007f}'),('\u{100fb}','\u{100ff}'),('\u{10103}','\u{10106}'),('\u{10134}','\u{10136}'),('\u{1018f}','\u{1018f}'),('\u{1019d}','\u{1019f}'),('\u{101a1}','\u{101cf}'),('\u{101fe}','\u{1027f}'),('\u{1029d}','\u{1029f}'),('\u{102d1}','\u{102df}'),('\u{102fc}','\u{102ff}'),('\u{10324}','\u{1032c}'),('\u{1034b}','\u{1034f}'),('\u{1037b}','\u{1037f}'),('\u{1039e}','\u{1039e}'),('\u{103c4}','\u{103c7}'),('\u{103d6}','\u{103ff}'),('\u{1049e}','\u{1049f}'),('\u{104aa}','\u{104af}'),('\u{104d4}','\u{104d7}'),('\u{104fc}','\u{104ff}'),('\u{10528}','\u{1052f}'),('\u{10564}','\u{1056e}'),('\u{1057b}','\u{1057b}'),('\u{1058b}','\u{1058b}'),('\u{10593}','\u{10593}'),('\u{10596}','\u{10596}'),('\u{105a2}','\u{105a2}'),('\u{105b2}','\u{105b2}'),('\u{105ba}','\u{105ba}'),('\u{105bd}','\u{105bf}'),('\u{105f4}','\u{105ff}'),('\u{10737}','\u{1073f}'),('\u{10756}','\u{1075f}'),('\u{10768}','\u{1077f}'),('\u{10786}','\u{10786}'),('\u{107b1}','\u{107b1}'),('\u{107bb}','\u{107ff}'),('\u{10806}','\u{10807}'),('\u{10809}','\u{10809}'),('\u{10836}','\u{10836}'),('\u{10839}','\u{1083b}'),('\u{1083d}','\u{1083e}'),('\u{10856}','\u{10856}'),('\u{1089f}','\u{108a6}'),('\u{108b0}','\u{108df}'),('\u{108f3}','\u{108f3}'),('\u{108f6}','\u{108fa}'),('\u{1091c}','\u{1091e}'),('\u{1093a}','\u{1093e}'),('\u{10940}','\u{1097f}'),('\u{109b8}','\u{109bb}'),('\u{109d0}','\u{109d1}'),('\u{10a04}','\u{10a04}'),('\u{10a07}','\u{10a0b}'),('\u{10a14}','\u{10a14}'),('\u{10a18}','\u{10a18}'),('\u{10a36}','\u{10a37}'),('\u{10a3b}','\u{10a3e}'),('\u{10a49}','\u{10a4f}'),('\u{10a59}','\u{10a5f}'),('\u{10aa0}','\u{10abf}'),('\u{10ae7}','\u{10aea}'),('\u{10af7}','\u{10aff}'),('\u{10b36}','\u{10b38}'),('\u{10b56}','\u{10b57}'),('\u{10b73}','\u{10b77}'),('\u{10b92}','\u{10b98}'),('\u{10b9d}','\u{10ba8}'),('\u{10bb0}','\u{10bff}'),('\u{10c49}','\u{10c7f}'),('\u{10cb3}','\u{10cbf}'),('\u{10cf3}','\u{10cf9}'),('\u{10d28}','\u{10d2f}'),('\u{10d3a}','\u{10d3f}'),('\u{10d66}','\u{10d68}'),('\u{10d86}','\u{10d8d}'),('\u{10d90}','\u{10e5f}'),('\u{10e7f}','\u{10e7f}'),('\u{10eaa}','\u{10eaa}'),('\u{10eae}','\u{10eaf}'),('\u{10eb2}','\u{10ec1}'),('\u{10ec5}','\u{10efb}'),('\u{10f28}','\u{10f2f}'),('\u{10f5a}','\u{10f6f}'),('\u{10f8a}','\u{10faf}'),('\u{10fcc}','\u{10fdf}'),('\u{10ff7}','\u{10fff}'),('\u{1104e}','\u{11051}'),('\u{11076}','\u{1107e}'),('\u{110bd}','\u{110bd}'),('\u{110c3}','\u{110cf}'),('\u{110e9}','\u{110ef}'),('\u{110fa}','\u{110ff}'),('\u{11135}','\u{11135}'),('\u{11148}','\u{1114f}'),('\u{11177}','\u{1117f}'),('\u{111e0}','\u{111e0}'),('\u{111f5}','\u{111ff}'),('\u{11212}','\u{11212}'),('\u{11242}','\u{1127f}'),('\u{11287}','\u{11287}'),('\u{11289}','\u{11289}'),('\u{1128e}','\u{1128e}'),('\u{1129e}','\u{1129e}'),('\u{112aa}','\u{112af}'),('\u{112eb}','\u{112ef}'),('\u{112fa}','\u{112ff}'),('\u{11304}','\u{11304}'),('\u{1130d}','\u{1130e}'),('\u{11311}','\u{11312}'),('\u{11329}','\u{11329}'),('\u{11331}','\u{11331}'),('\u{11334}','\u{11334}'),('\u{1133a}','\u{1133a}'),('\u{11345}','\u{11346}'),('\u{11349}','\u{1134a}'),('\u{1134e}','\u{1134f}'),('\u{11351}','\u{11356}'),('\u{11358}','\u{1135c}'),('\u{11364}','\u{11365}'),('\u{1136d}','\u{1136f}'),('\u{11375}','\u{1137f}'),('\u{1138a}','\u{1138a}'),('\u{1138c}','\u{1138d}'),('\u{1138f}','\u{1138f}'),('\u{113b6}','\u{113b6}'),('\u{113c1}','\u{113c1}'),('\u{113c3}','\u{113c4}'),('\u{113c6}','\u{113c6}'),('\u{113cb}','\u{113cb}'),('\u{113d6}','\u{113d6}'),('\u{113d9}','\u{113e0}'),('\u{113e3}','\u{113ff}'),('\u{1145c}','\u{1145c}'),('\u{11462}','\u{1147f}'),('\u{114c8}','\u{114cf}'),('\u{114da}','\u{1157f}'),('\u{115b6}','\u{115b7}'),('\u{115de}','\u{115ff}'),('\u{11645}','\u{1164f}'),('\u{1165a}','\u{1165f}'),('\u{1166d}','\u{1167f}'),('\u{116ba}','\u{116bf}'),('\u{116ca}','\u{116cf}'),('\u{116e4}','\u{116ff}'),('\u{1171b}','\u{1171c}'),('\u{1172c}','\u{1172f}'),('\u{11747}','\u{117ff}'),('\u{1183c}','\u{1189f}'),('\u{118f3}','\u{118fe}'),('\u{11907}','\u{11908}'),('\u{1190a}','\u{1190b}'),('\u{11914}','\u{11914}'),('\u{11917}','\u{11917}'),('\u{11936}','\u{11936}'),('\u{11939}','\u{1193a}'),('\u{11947}','\u{1194f}'),('\u{1195a}','\u{1199f}'),('\u{119a8}','\u{119a9}'),('\u{119d8}','\u{119d9}'),('\u{119e5}','\u{119ff}'),('\u{11a48}','\u{11a4f}'),('\u{11aa3}','\u{11aaf}'),('\u{11af9}','\u{11aff}'),('\u{11b0a}','\u{11bbf}'),('\u{11be2}','\u{11bef}'),('\u{11bfa}','\u{11bff}'),('\u{11c09}','\u{11c09}'),('\u{11c37}','\u{11c37}'),('\u{11c46}','\u{11c4f}'),('\u{11c6d}','\u{11c6f}'),('\u{11c90}','\u{11c91}'),('\u{11ca8}','\u{11ca8}'),('\u{11cb7}','\u{11cff}'),('\u{11d07}','\u{11d07}'),('\u{11d0a}','\u{11d0a}'),('\u{11d37}','\u{11d39}'),('\u{11d3b}','\u{11d3b}'),('\u{11d3e}','\u{11d3e}'),('\u{11d48}','\u{11d4f}'),('\u{11d5a}','\u{11d5f}'),('\u{11d66}','\u{11d66}'),('\u{11d69}','\u{11d69}'),('\u{11d8f}','\u{11d8f}'),('\u{11d92}','\u{11d92}'),('\u{11d99}','\u{11d9f}'),('\u{11daa}','\u{11edf}'),('\u{11ef9}','\u{11eff}'),('\u{11f11}','\u{11f11}'),('\u{11f3b}','\u{11f3d}'),('\u{11f5b}','\u{11faf}'),('\u{11fb1}','\u{11fbf}'),('\u{11ff2}','\u{11ffe}'),('\u{1239a}','\u{123ff}'),('\u{1246f}','\u{1246f}'),('\u{12475}','\u{1247f}'),('\u{12544}','\u{12f8f}'),('\u{12ff3}','\u{12fff}'),('\u{13430}','\u{1343f}'),('\u{13456}','\u{1345f}'),('\u{143fb}','\u{143ff}'),('\u{14647}','\u{160ff}'),('\u{1613a}','\u{167ff}'),('\u{16a39}','\u{16a3f}'),('\u{16a5f}','\u{16a5f}'),('\u{16a6a}','\u{16a6d}'),('\u{16abf}','\u{16abf}'),('\u{16aca}','\u{16acf}'),('\u{16aee}','\u{16aef}'),('\u{16af6}','\u{16aff}'),('\u{16b46}','\u{16b4f}'),('\u{16b5a}','\u{16b5a}'),('\u{16b62}','\u{16b62}'),('\u{16b78}','\u{16b7c}'),('\u{16b90}','\u{16d3f}'),('\u{16d7a}','\u{16e3f}'),('\u{16e9b}','\u{16eff}'),('\u{16f4b}','\u{16f4e}'),('\u{16f88}','\u{16f8e}'),('\u{16fa0}','\u{16fdf}'),('\u{16fe5}','\u{16fef}'),('\u{16ff2}','\u{16fff}'),('\u{187f8}','\u{187ff}'),('\u{18cd6}','\u{18cfe}'),('\u{18d09}','\u{1afef}'),('\u{1aff4}','\u{1aff4}'),('\u{1affc}','\u{1affc}'),('\u{1afff}','\u{1afff}'),('\u{1b123}','\u{1b131}'),('\u{1b133}','\u{1b14f}'),('\u{1b153}','\u{1b154}'),('\u{1b156}','\u{1b163}'),('\u{1b168}','\u{1b16f}'),('\u{1b2fc}','\u{1bbff}'),('\u{1bc6b}','\u{1bc6f}'),('\u{1bc7d}','\u{1bc7f}'),('\u{1bc89}','\u{1bc8f}'),('\u{1bc9a}','\u{1bc9b}'),('\u{1bca0}','\u{1cbff}'),('\u{1ccfa}','\u{1ccff}'),('\u{1ceb4}','\u{1ceff}'),('\u{1cf2e}','\u{1cf2f}'),('\u{1cf47}','\u{1cf4f}'),('\u{1cfc4}','\u{1cfff}'),('\u{1d0f6}','\u{1d0ff}'),('\u{1d127}','\u{1d128}'),('\u{1d173}','\u{1d17a}'),('\u{1d1eb}','\u{1d1ff}'),('\u{1d246}','\u{1d2bf}'),('\u{1d2d4}','\u{1d2df}'),('\u{1d2f4}','\u{1d2ff}'),('\u{1d357}','\u{1d35f}'),('\u{1d379}','\u{1d3ff}'),('\u{1d455}','\u{1d455}'),('\u{1d49d}','\u{1d49d}'),('\u{1d4a0}','\u{1d4a1}'),('\u{1d4a3}','\u{1d4a4}'),('\u{1d4a7}','\u{1d4a8}'),('\u{1d4ad}','\u{1d4ad}'),('\u{1d4ba}','\u{1d4ba}'),('\u{1d4bc}','\u{1d4bc}'),('\u{1d4c4}','\u{1d4c4}'),('\u{1d506}','\u{1d506}'),('\u{1d50b}','\u{1d50c}'),('\u{1d515}','\u{1d515}'),('\u{1d51d}','\u{1d51d}'),('\u{1d53a}','\u{1d53a}'),('\u{1d53f}','\u{1d53f}'),('\u{1d545}','\u{1d545}'),('\u{1d547}','\u{1d549}'),('\u{1d551}','\u{1d551}'),('\u{1d6a6}','\u{1d6a7}'),('\u{1d7cc}','\u{1d7cd}'),('\u{1da8c}','\u{1da9a}'),('\u{1daa0}','\u{1daa0}'),('\u{1dab0}','\u{1deff}'),('\u{1df1f}','\u{1df24}'),('\u{1df2b}','\u{1dfff}'),('\u{1e007}','\u{1e007}'),('\u{1e019}','\u{1e01a}'),('\u{1e022}','\u{1e022}'),('\u{1e025}','\u{1e025}'),('\u{1e02b}','\u{1e02f}'),('\u{1e06e}','\u{1e08e}'),('\u{1e090}','\u{1e0ff}'),('\u{1e12d}','\u{1e12f}'),('\u{1e13e}','\u{1e13f}'),('\u{1e14a}','\u{1e14d}'),('\u{1e150}','\u{1e28f}'),('\u{1e2af}','\u{1e2bf}'),('\u{1e2fa}','\u{1e2fe}'),('\u{1e300}','\u{1e4cf}'),('\u{1e4fa}','\u{1e5cf}'),('\u{1e5fb}','\u{1e5fe}'),('\u{1e600}','\u{1e7df}'),('\u{1e7e7}','\u{1e7e7}'),('\u{1e7ec}','\u{1e7ec}'),('\u{1e7ef}','\u{1e7ef}'),('\u{1e7ff}','\u{1e7ff}'),('\u{1e8c5}','\u{1e8c6}'),('\u{1e8d7}','\u{1e8ff}'),('\u{1e94c}','\u{1e94f}'),('\u{1e95a}','\u{1e95d}'),('\u{1e960}','\u{1ec70}'),('\u{1ecb5}','\u{1ed00}'),('\u{1ed3e}','\u{1edff}'),('\u{1ee04}','\u{1ee04}'),('\u{1ee20}','\u{1ee20}'),('\u{1ee23}','\u{1ee23}'),('\u{1ee25}','\u{1ee26}'),('\u{1ee28}','\u{1ee28}'),('\u{1ee33}','\u{1ee33}'),('\u{1ee38}','\u{1ee38}'),('\u{1ee3a}','\u{1ee3a}'),('\u{1ee3c}','\u{1ee41}'),('\u{1ee43}','\u{1ee46}'),('\u{1ee48}','\u{1ee48}'),('\u{1ee4a}','\u{1ee4a}'),('\u{1ee4c}','\u{1ee4c}'),('\u{1ee50}','\u{1ee50}'),('\u{1ee53}','\u{1ee53}'),('\u{1ee55}','\u{1ee56}'),('\u{1ee58}','\u{1ee58}'),('\u{1ee5a}','\u{1ee5a}'),('\u{1ee5c}','\u{1ee5c}'),('\u{1ee5e}','\u{1ee5e}'),('\u{1ee60}','\u{1ee60}'),('\u{1ee63}','\u{1ee63}'),('\u{1ee65}','\u{1ee66}'),('\u{1ee6b}','\u{1ee6b}'),('\u{1ee73}','\u{1ee73}'),('\u{1ee78}','\u{1ee78}'),('\u{1ee7d}','\u{1ee7d}'),('\u{1ee7f}','\u{1ee7f}'),('\u{1ee8a}','\u{1ee8a}'),('\u{1ee9c}','\u{1eea0}'),('\u{1eea4}','\u{1eea4}'),('\u{1eeaa}','\u{1eeaa}'),('\u{1eebc}','\u{1eeef}'),('\u{1eef2}','\u{1efff}'),('\u{1f02c}','\u{1f02f}'),('\u{1f094}','\u{1f09f}'),('\u{1f0af}','\u{1f0b0}'),('\u{1f0c0}','\u{1f0c0}'),('\u{1f0d0}','\u{1f0d0}'),('\u{1f0f6}','\u{1f0ff}'),('\u{1f1ae}','\u{1f1e5}'),('\u{1f203}','\u{1f20f}'),('\u{1f23c}','\u{1f23f}'),('\u{1f249}','\u{1f24f}'),('\u{1f252}','\u{1f25f}'),('\u{1f266}','\u{1f2ff}'),('\u{1f6d8}','\u{1f6db}'),('\u{1f6ed}','\u{1f6ef}'),('\u{1f6fd}','\u{1f6ff}'),('\u{1f777}','\u{1f77a}'),('\u{1f7da}','\u{1f7df}'),('\u{1f7ec}','\u{1f7ef}'),('\u{1f7f1}','\u{1f7ff}'),('\u{1f80c}','\u{1f80f}'),('\u{1f848}','\u{1f84f}'),('\u{1f85a}','\u{1f85f}'),('\u{1f888}','\u{1f88f}'),('\u{1f8ae}','\u{1f8af}'),('\u{1f8bc}','\u{1f8bf}'),('\u{1f8c2}','\u{1f8ff}'),('\u{1fa54}','\u{1fa5f}'),('\u{1fa6e}','\u{1fa6f}'),('\u{1fa7d}','\u{1fa7f}'),('\u{1fa8a}','\u{1fa8e}'),('\u{1fac7}','\u{1facd}'),('\u{1fadd}','\u{1fade}'),('\u{1faea}','\u{1faef}'),('\u{1faf9}','\u{1faff}'),('\u{1fb93}','\u{1fb93}'),('\u{1fbfa}','\u{1ffff}'),('\u{2a6e0}','\u{2a6ff}'),('\u{2b73a}','\u{2b73f}'),('\u{2b81e}','\u{2b81f}'),('\u{2cea2}','\u{2ceaf}'),('\u{2ebe1}','\u{2ebef}'),('\u{2ee5e}','\u{2f7ff}'),('\u{2fa1e}','\u{2ffff}'),('\u{3134b}','\u{3134f}'),('\u{323b0}','\u{e00ff}'),('\u{e01f0}','\u{10ffff}') ];
            pub const OTHER_LETTER:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const OTHER_NUMBER:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const OTHER_PUNCTUATION:&'static [(char,char)] = &[ ('!','#'),('%','\''),('*','*'),(',',','),('.','/'),(':',';'),('?','@'),('\\','\\'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const OTHER_SYMBOL:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const PARAGRAPH_SEPARATOR:&'static [(char,char)] = &[('\u{2029}','\u{2029}')];
            pub const PRIVATE_USE:&'static [(char,char)] = &[ ('\u{e000}','\u{f8ff}'),('\u{f0000}','\u{ffffd}'),('\u{100000}','\u{10fffd}') ];
            pub const PUNCTUATION:&'static [(char,char)] = &[ ('!','#'),('%','*'),(',','/'),(':',';'),('?','@'),('[',']'),('_','_'),('{','{'),('}','}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const SEPARATOR:&'static [(char,char)] = &[ (' ',' '),('\u{a0}','\u{a0}'),('\u{1680}','\u{1680}'),('\u{2000}','\u{200a}'),('\u{2028}','\u{2029}'),('\u{202f}','\u{202f}'),('\u{205f}','\u{205f}'),('\u{3000}','\u{3000}') ];
            pub const SPACE_SEPARATOR:&'static [(char,char)] = &[ (' ',' '),('\u{a0}','\u{a0}'),('\u{1680}','\u{1680}'),('\u{2000}','\u{200a}'),('\u{202f}','\u{202f}'),('\u{205f}','\u{205f}'),('\u{3000}','\u{3000}') ];
            pub const SPACING_MARK:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('\u{9be}',''),('',''),('',''),('\u{9d7}','\u{9d7}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{b3e}','\u{b3e}'),('',''),('',''),('',''),('\u{b57}','\u{b57}'),('\u{bbe}',''),('',''),('',''),('',''),('\u{bd7}','\u{bd7}'),('',''),('',''),('',''),('',''),('\u{cc0}',''),('\u{cc7}','\u{cc8}'),('\u{cca}','\u{ccb}'),('\u{cd5}','\u{cd6}'),('',''),('',''),('\u{d3e}',''),('',''),('',''),('\u{d57}','\u{d57}'),('',''),('\u{dcf}',''),('','\u{ddf}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1715}','\u{1715}'),('\u{1734}','\u{1734}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1b35}','\u{1b35}'),('\u{1b3b}','\u{1b3b}'),('\u{1b3d}',''),('\u{1b43}','\u{1b44}'),('',''),('',''),('',''),('\u{1baa}','\u{1baa}'),('',''),('',''),('',''),('\u{1bf2}','\u{1bf3}'),('',''),('',''),('',''),('',''),('\u{302e}','\u{302f}'),('',''),('',''),('',''),('',''),('','\u{a953}'),('',''),('',''),('',''),('','\u{a9c0}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{111c0}'),('',''),('',''),('',''),('\u{11235}','\u{11235}'),('',''),('',''),('\u{1133e}',''),('',''),('',''),('','\u{1134d}'),('\u{11357}','\u{11357}'),('',''),('\u{113b8}',''),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('',''),('\u{113cf}','\u{113cf}'),('',''),('',''),('',''),('\u{114b0}',''),('',''),('',''),('',''),('\u{115af}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{116b6}','\u{116b6}'),('',''),('',''),('',''),('',''),('',''),('\u{11930}',''),('',''),('\u{1193d}','\u{1193d}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{11f41}','\u{11f41}'),('',''),('',''),('\u{16ff0}','\u{16ff1}'),('\u{1d165}','\u{1d166}'),('\u{1d16d}','\u{1d172}') ];
            pub const SYMBOL:&'static [(char,char)] = &[ ('$','$'),('+','+'),('<','>'),('^','^'),('`','`'),('|','|'),('~','~'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const TITLECASE_LETTER:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const UNASSIGNED:&'static [(char,char)] = &[ ('\u{378}','\u{379}'),('\u{380}','\u{383}'),('\u{38b}','\u{38b}'),('\u{38d}','\u{38d}'),('\u{3a2}','\u{3a2}'),('\u{530}','\u{530}'),('\u{557}','\u{558}'),('\u{58b}','\u{58c}'),('\u{590}','\u{590}'),('\u{5c8}','\u{5cf}'),('\u{5eb}','\u{5ee}'),('\u{5f5}','\u{5ff}'),('\u{70e}','\u{70e}'),('\u{74b}','\u{74c}'),('\u{7b2}','\u{7bf}'),('\u{7fb}','\u{7fc}'),('\u{82e}','\u{82f}'),('\u{83f}','\u{83f}'),('\u{85c}','\u{85d}'),('\u{85f}','\u{85f}'),('\u{86b}','\u{86f}'),('\u{88f}','\u{88f}'),('\u{892}','\u{896}'),('\u{984}','\u{984}'),('\u{98d}','\u{98e}'),('\u{991}','\u{992}'),('\u{9a9}','\u{9a9}'),('\u{9b1}','\u{9b1}'),('\u{9b3}','\u{9b5}'),('\u{9ba}','\u{9bb}'),('\u{9c5}','\u{9c6}'),('\u{9c9}','\u{9ca}'),('\u{9cf}','\u{9d6}'),('\u{9d8}','\u{9db}'),('\u{9de}','\u{9de}'),('\u{9e4}','\u{9e5}'),('\u{9ff}','\u{a00}'),('\u{a04}','\u{a04}'),('\u{a0b}','\u{a0e}'),('\u{a11}','\u{a12}'),('\u{a29}','\u{a29}'),('\u{a31}','\u{a31}'),('\u{a34}','\u{a34}'),('\u{a37}','\u{a37}'),('\u{a3a}','\u{a3b}'),('\u{a3d}','\u{a3d}'),('\u{a43}','\u{a46}'),('\u{a49}','\u{a4a}'),('\u{a4e}','\u{a50}'),('\u{a52}','\u{a58}'),('\u{a5d}','\u{a5d}'),('\u{a5f}','\u{a65}'),('\u{a77}','\u{a80}'),('\u{a84}','\u{a84}'),('\u{a8e}','\u{a8e}'),('\u{a92}','\u{a92}'),('\u{aa9}','\u{aa9}'),('\u{ab1}','\u{ab1}'),('\u{ab4}','\u{ab4}'),('\u{aba}','\u{abb}'),('\u{ac6}','\u{ac6}'),('\u{aca}','\u{aca}'),('\u{ace}','\u{acf}'),('\u{ad1}','\u{adf}'),('\u{ae4}','\u{ae5}'),('\u{af2}','\u{af8}'),('\u{b00}','\u{b00}'),('\u{b04}','\u{b04}'),('\u{b0d}','\u{b0e}'),('\u{b11}','\u{b12}'),('\u{b29}','\u{b29}'),('\u{b31}','\u{b31}'),('\u{b34}','\u{b34}'),('\u{b3a}','\u{b3b}'),('\u{b45}','\u{b46}'),('\u{b49}','\u{b4a}'),('\u{b4e}','\u{b54}'),('\u{b58}','\u{b5b}'),('\u{b5e}','\u{b5e}'),('\u{b64}','\u{b65}'),('\u{b78}','\u{b81}'),('\u{b84}','\u{b84}'),('\u{b8b}','\u{b8d}'),('\u{b91}','\u{b91}'),('\u{b96}','\u{b98}'),('\u{b9b}','\u{b9b}'),('\u{b9d}','\u{b9d}'),('\u{ba0}','\u{ba2}'),('\u{ba5}','\u{ba7}'),('\u{bab}','\u{bad}'),('\u{bba}','\u{bbd}'),('\u{bc3}','\u{bc5}'),('\u{bc9}','\u{bc9}'),('\u{bce}','\u{bcf}'),('\u{bd1}','\u{bd6}'),('\u{bd8}','\u{be5}'),('\u{bfb}','\u{bff}'),('\u{c0d}','\u{c0d}'),('\u{c11}','\u{c11}'),('\u{c29}','\u{c29}'),('\u{c3a}','\u{c3b}'),('\u{c45}','\u{c45}'),('\u{c49}','\u{c49}'),('\u{c4e}','\u{c54}'),('\u{c57}','\u{c57}'),('\u{c5b}','\u{c5c}'),('\u{c5e}','\u{c5f}'),('\u{c64}','\u{c65}'),('\u{c70}','\u{c76}'),('\u{c8d}','\u{c8d}'),('\u{c91}','\u{c91}'),('\u{ca9}','\u{ca9}'),('\u{cb4}','\u{cb4}'),('\u{cba}','\u{cbb}'),('\u{cc5}','\u{cc5}'),('\u{cc9}','\u{cc9}'),('\u{cce}','\u{cd4}'),('\u{cd7}','\u{cdc}'),('\u{cdf}','\u{cdf}'),('\u{ce4}','\u{ce5}'),('\u{cf0}','\u{cf0}'),('\u{cf4}','\u{cff}'),('\u{d0d}','\u{d0d}'),('\u{d11}','\u{d11}'),('\u{d45}','\u{d45}'),('\u{d49}','\u{d49}'),('\u{d50}','\u{d53}'),('\u{d64}','\u{d65}'),('\u{d80}','\u{d80}'),('\u{d84}','\u{d84}'),('\u{d97}','\u{d99}'),('\u{db2}','\u{db2}'),('\u{dbc}','\u{dbc}'),('\u{dbe}','\u{dbf}'),('\u{dc7}','\u{dc9}'),('\u{dcb}','\u{dce}'),('\u{dd5}','\u{dd5}'),('\u{dd7}','\u{dd7}'),('\u{de0}','\u{de5}'),('\u{df0}','\u{df1}'),('\u{df5}','\u{e00}'),('\u{e3b}','\u{e3e}'),('\u{e5c}','\u{e80}'),('\u{e83}','\u{e83}'),('\u{e85}','\u{e85}'),('\u{e8b}','\u{e8b}'),('\u{ea4}','\u{ea4}'),('\u{ea6}','\u{ea6}'),('\u{ebe}','\u{ebf}'),('\u{ec5}','\u{ec5}'),('\u{ec7}','\u{ec7}'),('\u{ecf}','\u{ecf}'),('\u{eda}','\u{edb}'),('\u{ee0}','\u{eff}'),('\u{f48}','\u{f48}'),('\u{f6d}','\u{f70}'),('\u{f98}','\u{f98}'),('\u{fbd}','\u{fbd}'),('\u{fcd}','\u{fcd}'),('\u{fdb}','\u{fff}'),('\u{10c6}','\u{10c6}'),('\u{10c8}','\u{10cc}'),('\u{10ce}','\u{10cf}'),('\u{1249}','\u{1249}'),('\u{124e}','\u{124f}'),('\u{1257}','\u{1257}'),('\u{1259}','\u{1259}'),('\u{125e}','\u{125f}'),('\u{1289}','\u{1289}'),('\u{128e}','\u{128f}'),('\u{12b1}','\u{12b1}'),('\u{12b6}','\u{12b7}'),('\u{12bf}','\u{12bf}'),('\u{12c1}','\u{12c1}'),('\u{12c6}','\u{12c7}'),('\u{12d7}','\u{12d7}'),('\u{1311}','\u{1311}'),('\u{1316}','\u{1317}'),('\u{135b}','\u{135c}'),('\u{137d}','\u{137f}'),('\u{139a}','\u{139f}'),('\u{13f6}','\u{13f7}'),('\u{13fe}','\u{13ff}'),('\u{169d}','\u{169f}'),('\u{16f9}','\u{16ff}'),('\u{1716}','\u{171e}'),('\u{1737}','\u{173f}'),('\u{1754}','\u{175f}'),('\u{176d}','\u{176d}'),('\u{1771}','\u{1771}'),('\u{1774}','\u{177f}'),('\u{17de}','\u{17df}'),('\u{17ea}','\u{17ef}'),('\u{17fa}','\u{17ff}'),('\u{181a}','\u{181f}'),('\u{1879}','\u{187f}'),('\u{18ab}','\u{18af}'),('\u{18f6}','\u{18ff}'),('\u{191f}','\u{191f}'),('\u{192c}','\u{192f}'),('\u{193c}','\u{193f}'),('\u{1941}','\u{1943}'),('\u{196e}','\u{196f}'),('\u{1975}','\u{197f}'),('\u{19ac}','\u{19af}'),('\u{19ca}','\u{19cf}'),('\u{19db}','\u{19dd}'),('\u{1a1c}','\u{1a1d}'),('\u{1a5f}','\u{1a5f}'),('\u{1a7d}','\u{1a7e}'),('\u{1a8a}','\u{1a8f}'),('\u{1a9a}','\u{1a9f}'),('\u{1aae}','\u{1aaf}'),('\u{1acf}','\u{1aff}'),('\u{1b4d}','\u{1b4d}'),('\u{1bf4}','\u{1bfb}'),('\u{1c38}','\u{1c3a}'),('\u{1c4a}','\u{1c4c}'),('\u{1c8b}','\u{1c8f}'),('\u{1cbb}','\u{1cbc}'),('\u{1cc8}','\u{1ccf}'),('\u{1cfb}','\u{1cff}'),('\u{1f16}','\u{1f17}'),('\u{1f1e}','\u{1f1f}'),('\u{1f46}','\u{1f47}'),('\u{1f4e}','\u{1f4f}'),('\u{1f58}','\u{1f58}'),('\u{1f5a}','\u{1f5a}'),('\u{1f5c}','\u{1f5c}'),('\u{1f5e}','\u{1f5e}'),('\u{1f7e}','\u{1f7f}'),('\u{1fb5}','\u{1fb5}'),('\u{1fc5}','\u{1fc5}'),('\u{1fd4}','\u{1fd5}'),('\u{1fdc}','\u{1fdc}'),('\u{1ff0}','\u{1ff1}'),('\u{1ff5}','\u{1ff5}'),('\u{1fff}','\u{1fff}'),('\u{2065}','\u{2065}'),('\u{2072}','\u{2073}'),('\u{208f}','\u{208f}'),('\u{209d}','\u{209f}'),('\u{20c1}','\u{20cf}'),('\u{20f1}','\u{20ff}'),('\u{218c}','\u{218f}'),('\u{242a}','\u{243f}'),('\u{244b}','\u{245f}'),('\u{2b74}','\u{2b75}'),('\u{2b96}','\u{2b96}'),('\u{2cf4}','\u{2cf8}'),('\u{2d26}','\u{2d26}'),('\u{2d28}','\u{2d2c}'),('\u{2d2e}','\u{2d2f}'),('\u{2d68}','\u{2d6e}'),('\u{2d71}','\u{2d7e}'),('\u{2d97}','\u{2d9f}'),('\u{2da7}','\u{2da7}'),('\u{2daf}','\u{2daf}'),('\u{2db7}','\u{2db7}'),('\u{2dbf}','\u{2dbf}'),('\u{2dc7}','\u{2dc7}'),('\u{2dcf}','\u{2dcf}'),('\u{2dd7}','\u{2dd7}'),('\u{2ddf}','\u{2ddf}'),('\u{2e5e}','\u{2e7f}'),('\u{2e9a}','\u{2e9a}'),('\u{2ef4}','\u{2eff}'),('\u{2fd6}','\u{2fef}'),('\u{3040}','\u{3040}'),('\u{3097}','\u{3098}'),('\u{3100}','\u{3104}'),('\u{3130}','\u{3130}'),('\u{318f}','\u{318f}'),('\u{31e6}','\u{31ee}'),('\u{321f}','\u{321f}'),('\u{a48d}','\u{a48f}'),('\u{a4c7}','\u{a4cf}'),('\u{a62c}','\u{a63f}'),('\u{a6f8}','\u{a6ff}'),('\u{a7ce}','\u{a7cf}'),('\u{a7d2}','\u{a7d2}'),('\u{a7d4}','\u{a7d4}'),('\u{a7dd}','\u{a7f1}'),('\u{a82d}','\u{a82f}'),('\u{a83a}','\u{a83f}'),('\u{a878}','\u{a87f}'),('\u{a8c6}','\u{a8cd}'),('\u{a8da}','\u{a8df}'),('\u{a954}','\u{a95e}'),('\u{a97d}','\u{a97f}'),('\u{a9ce}','\u{a9ce}'),('\u{a9da}','\u{a9dd}'),('\u{a9ff}','\u{a9ff}'),('\u{aa37}','\u{aa3f}'),('\u{aa4e}','\u{aa4f}'),('\u{aa5a}','\u{aa5b}'),('\u{aac3}','\u{aada}'),('\u{aaf7}','\u{ab00}'),('\u{ab07}','\u{ab08}'),('\u{ab0f}','\u{ab10}'),('\u{ab17}','\u{ab1f}'),('\u{ab27}','\u{ab27}'),('\u{ab2f}','\u{ab2f}'),('\u{ab6c}','\u{ab6f}'),('\u{abee}','\u{abef}'),('\u{abfa}','\u{abff}'),('\u{d7a4}','\u{d7af}'),('\u{d7c7}','\u{d7ca}'),('\u{d7fc}','\u{d7ff}'),('\u{fa6e}','\u{fa6f}'),('\u{fada}','\u{faff}'),('\u{fb07}','\u{fb12}'),('\u{fb18}','\u{fb1c}'),('\u{fb37}','\u{fb37}'),('\u{fb3d}','\u{fb3d}'),('\u{fb3f}','\u{fb3f}'),('\u{fb42}','\u{fb42}'),('\u{fb45}','\u{fb45}'),('\u{fbc3}','\u{fbd2}'),('\u{fd90}','\u{fd91}'),('\u{fdc8}','\u{fdce}'),('\u{fdd0}','\u{fdef}'),('\u{fe1a}','\u{fe1f}'),('\u{fe53}','\u{fe53}'),('\u{fe67}','\u{fe67}'),('\u{fe6c}','\u{fe6f}'),('\u{fe75}','\u{fe75}'),('\u{fefd}','\u{fefe}'),('\u{ff00}','\u{ff00}'),('\u{ffbf}','\u{ffc1}'),('\u{ffc8}','\u{ffc9}'),('\u{ffd0}','\u{ffd1}'),('\u{ffd8}','\u{ffd9}'),('\u{ffdd}','\u{ffdf}'),('\u{ffe7}','\u{ffe7}'),('\u{ffef}','\u{fff8}'),('\u{fffe}','\u{ffff}'),('\u{1000c}','\u{1000c}'),('\u{10027}','\u{10027}'),('\u{1003b}','\u{1003b}'),('\u{1003e}','\u{1003e}'),('\u{1004e}','\u{1004f}'),('\u{1005e}','\u{1007f}'),('\u{100fb}','\u{100ff}'),('\u{10103}','\u{10106}'),('\u{10134}','\u{10136}'),('\u{1018f}','\u{1018f}'),('\u{1019d}','\u{1019f}'),('\u{101a1}','\u{101cf}'),('\u{101fe}','\u{1027f}'),('\u{1029d}','\u{1029f}'),('\u{102d1}','\u{102df}'),('\u{102fc}','\u{102ff}'),('\u{10324}','\u{1032c}'),('\u{1034b}','\u{1034f}'),('\u{1037b}','\u{1037f}'),('\u{1039e}','\u{1039e}'),('\u{103c4}','\u{103c7}'),('\u{103d6}','\u{103ff}'),('\u{1049e}','\u{1049f}'),('\u{104aa}','\u{104af}'),('\u{104d4}','\u{104d7}'),('\u{104fc}','\u{104ff}'),('\u{10528}','\u{1052f}'),('\u{10564}','\u{1056e}'),('\u{1057b}','\u{1057b}'),('\u{1058b}','\u{1058b}'),('\u{10593}','\u{10593}'),('\u{10596}','\u{10596}'),('\u{105a2}','\u{105a2}'),('\u{105b2}','\u{105b2}'),('\u{105ba}','\u{105ba}'),('\u{105bd}','\u{105bf}'),('\u{105f4}','\u{105ff}'),('\u{10737}','\u{1073f}'),('\u{10756}','\u{1075f}'),('\u{10768}','\u{1077f}'),('\u{10786}','\u{10786}'),('\u{107b1}','\u{107b1}'),('\u{107bb}','\u{107ff}'),('\u{10806}','\u{10807}'),('\u{10809}','\u{10809}'),('\u{10836}','\u{10836}'),('\u{10839}','\u{1083b}'),('\u{1083d}','\u{1083e}'),('\u{10856}','\u{10856}'),('\u{1089f}','\u{108a6}'),('\u{108b0}','\u{108df}'),('\u{108f3}','\u{108f3}'),('\u{108f6}','\u{108fa}'),('\u{1091c}','\u{1091e}'),('\u{1093a}','\u{1093e}'),('\u{10940}','\u{1097f}'),('\u{109b8}','\u{109bb}'),('\u{109d0}','\u{109d1}'),('\u{10a04}','\u{10a04}'),('\u{10a07}','\u{10a0b}'),('\u{10a14}','\u{10a14}'),('\u{10a18}','\u{10a18}'),('\u{10a36}','\u{10a37}'),('\u{10a3b}','\u{10a3e}'),('\u{10a49}','\u{10a4f}'),('\u{10a59}','\u{10a5f}'),('\u{10aa0}','\u{10abf}'),('\u{10ae7}','\u{10aea}'),('\u{10af7}','\u{10aff}'),('\u{10b36}','\u{10b38}'),('\u{10b56}','\u{10b57}'),('\u{10b73}','\u{10b77}'),('\u{10b92}','\u{10b98}'),('\u{10b9d}','\u{10ba8}'),('\u{10bb0}','\u{10bff}'),('\u{10c49}','\u{10c7f}'),('\u{10cb3}','\u{10cbf}'),('\u{10cf3}','\u{10cf9}'),('\u{10d28}','\u{10d2f}'),('\u{10d3a}','\u{10d3f}'),('\u{10d66}','\u{10d68}'),('\u{10d86}','\u{10d8d}'),('\u{10d90}','\u{10e5f}'),('\u{10e7f}','\u{10e7f}'),('\u{10eaa}','\u{10eaa}'),('\u{10eae}','\u{10eaf}'),('\u{10eb2}','\u{10ec1}'),('\u{10ec5}','\u{10efb}'),('\u{10f28}','\u{10f2f}'),('\u{10f5a}','\u{10f6f}'),('\u{10f8a}','\u{10faf}'),('\u{10fcc}','\u{10fdf}'),('\u{10ff7}','\u{10fff}'),('\u{1104e}','\u{11051}'),('\u{11076}','\u{1107e}'),('\u{110c3}','\u{110cc}'),('\u{110ce}','\u{110cf}'),('\u{110e9}','\u{110ef}'),('\u{110fa}','\u{110ff}'),('\u{11135}','\u{11135}'),('\u{11148}','\u{1114f}'),('\u{11177}','\u{1117f}'),('\u{111e0}','\u{111e0}'),('\u{111f5}','\u{111ff}'),('\u{11212}','\u{11212}'),('\u{11242}','\u{1127f}'),('\u{11287}','\u{11287}'),('\u{11289}','\u{11289}'),('\u{1128e}','\u{1128e}'),('\u{1129e}','\u{1129e}'),('\u{112aa}','\u{112af}'),('\u{112eb}','\u{112ef}'),('\u{112fa}','\u{112ff}'),('\u{11304}','\u{11304}'),('\u{1130d}','\u{1130e}'),('\u{11311}','\u{11312}'),('\u{11329}','\u{11329}'),('\u{11331}','\u{11331}'),('\u{11334}','\u{11334}'),('\u{1133a}','\u{1133a}'),('\u{11345}','\u{11346}'),('\u{11349}','\u{1134a}'),('\u{1134e}','\u{1134f}'),('\u{11351}','\u{11356}'),('\u{11358}','\u{1135c}'),('\u{11364}','\u{11365}'),('\u{1136d}','\u{1136f}'),('\u{11375}','\u{1137f}'),('\u{1138a}','\u{1138a}'),('\u{1138c}','\u{1138d}'),('\u{1138f}','\u{1138f}'),('\u{113b6}','\u{113b6}'),('\u{113c1}','\u{113c1}'),('\u{113c3}','\u{113c4}'),('\u{113c6}','\u{113c6}'),('\u{113cb}','\u{113cb}'),('\u{113d6}','\u{113d6}'),('\u{113d9}','\u{113e0}'),('\u{113e3}','\u{113ff}'),('\u{1145c}','\u{1145c}'),('\u{11462}','\u{1147f}'),('\u{114c8}','\u{114cf}'),('\u{114da}','\u{1157f}'),('\u{115b6}','\u{115b7}'),('\u{115de}','\u{115ff}'),('\u{11645}','\u{1164f}'),('\u{1165a}','\u{1165f}'),('\u{1166d}','\u{1167f}'),('\u{116ba}','\u{116bf}'),('\u{116ca}','\u{116cf}'),('\u{116e4}','\u{116ff}'),('\u{1171b}','\u{1171c}'),('\u{1172c}','\u{1172f}'),('\u{11747}','\u{117ff}'),('\u{1183c}','\u{1189f}'),('\u{118f3}','\u{118fe}'),('\u{11907}','\u{11908}'),('\u{1190a}','\u{1190b}'),('\u{11914}','\u{11914}'),('\u{11917}','\u{11917}'),('\u{11936}','\u{11936}'),('\u{11939}','\u{1193a}'),('\u{11947}','\u{1194f}'),('\u{1195a}','\u{1199f}'),('\u{119a8}','\u{119a9}'),('\u{119d8}','\u{119d9}'),('\u{119e5}','\u{119ff}'),('\u{11a48}','\u{11a4f}'),('\u{11aa3}','\u{11aaf}'),('\u{11af9}','\u{11aff}'),('\u{11b0a}','\u{11bbf}'),('\u{11be2}','\u{11bef}'),('\u{11bfa}','\u{11bff}'),('\u{11c09}','\u{11c09}'),('\u{11c37}','\u{11c37}'),('\u{11c46}','\u{11c4f}'),('\u{11c6d}','\u{11c6f}'),('\u{11c90}','\u{11c91}'),('\u{11ca8}','\u{11ca8}'),('\u{11cb7}','\u{11cff}'),('\u{11d07}','\u{11d07}'),('\u{11d0a}','\u{11d0a}'),('\u{11d37}','\u{11d39}'),('\u{11d3b}','\u{11d3b}'),('\u{11d3e}','\u{11d3e}'),('\u{11d48}','\u{11d4f}'),('\u{11d5a}','\u{11d5f}'),('\u{11d66}','\u{11d66}'),('\u{11d69}','\u{11d69}'),('\u{11d8f}','\u{11d8f}'),('\u{11d92}','\u{11d92}'),('\u{11d99}','\u{11d9f}'),('\u{11daa}','\u{11edf}'),('\u{11ef9}','\u{11eff}'),('\u{11f11}','\u{11f11}'),('\u{11f3b}','\u{11f3d}'),('\u{11f5b}','\u{11faf}'),('\u{11fb1}','\u{11fbf}'),('\u{11ff2}','\u{11ffe}'),('\u{1239a}','\u{123ff}'),('\u{1246f}','\u{1246f}'),('\u{12475}','\u{1247f}'),('\u{12544}','\u{12f8f}'),('\u{12ff3}','\u{12fff}'),('\u{13456}','\u{1345f}'),('\u{143fb}','\u{143ff}'),('\u{14647}','\u{160ff}'),('\u{1613a}','\u{167ff}'),('\u{16a39}','\u{16a3f}'),('\u{16a5f}','\u{16a5f}'),('\u{16a6a}','\u{16a6d}'),('\u{16abf}','\u{16abf}'),('\u{16aca}','\u{16acf}'),('\u{16aee}','\u{16aef}'),('\u{16af6}','\u{16aff}'),('\u{16b46}','\u{16b4f}'),('\u{16b5a}','\u{16b5a}'),('\u{16b62}','\u{16b62}'),('\u{16b78}','\u{16b7c}'),('\u{16b90}','\u{16d3f}'),('\u{16d7a}','\u{16e3f}'),('\u{16e9b}','\u{16eff}'),('\u{16f4b}','\u{16f4e}'),('\u{16f88}','\u{16f8e}'),('\u{16fa0}','\u{16fdf}'),('\u{16fe5}','\u{16fef}'),('\u{16ff2}','\u{16fff}'),('\u{187f8}','\u{187ff}'),('\u{18cd6}','\u{18cfe}'),('\u{18d09}','\u{1afef}'),('\u{1aff4}','\u{1aff4}'),('\u{1affc}','\u{1affc}'),('\u{1afff}','\u{1afff}'),('\u{1b123}','\u{1b131}'),('\u{1b133}','\u{1b14f}'),('\u{1b153}','\u{1b154}'),('\u{1b156}','\u{1b163}'),('\u{1b168}','\u{1b16f}'),('\u{1b2fc}','\u{1bbff}'),('\u{1bc6b}','\u{1bc6f}'),('\u{1bc7d}','\u{1bc7f}'),('\u{1bc89}','\u{1bc8f}'),('\u{1bc9a}','\u{1bc9b}'),('\u{1bca4}','\u{1cbff}'),('\u{1ccfa}','\u{1ccff}'),('\u{1ceb4}','\u{1ceff}'),('\u{1cf2e}','\u{1cf2f}'),('\u{1cf47}','\u{1cf4f}'),('\u{1cfc4}','\u{1cfff}'),('\u{1d0f6}','\u{1d0ff}'),('\u{1d127}','\u{1d128}'),('\u{1d1eb}','\u{1d1ff}'),('\u{1d246}','\u{1d2bf}'),('\u{1d2d4}','\u{1d2df}'),('\u{1d2f4}','\u{1d2ff}'),('\u{1d357}','\u{1d35f}'),('\u{1d379}','\u{1d3ff}'),('\u{1d455}','\u{1d455}'),('\u{1d49d}','\u{1d49d}'),('\u{1d4a0}','\u{1d4a1}'),('\u{1d4a3}','\u{1d4a4}'),('\u{1d4a7}','\u{1d4a8}'),('\u{1d4ad}','\u{1d4ad}'),('\u{1d4ba}','\u{1d4ba}'),('\u{1d4bc}','\u{1d4bc}'),('\u{1d4c4}','\u{1d4c4}'),('\u{1d506}','\u{1d506}'),('\u{1d50b}','\u{1d50c}'),('\u{1d515}','\u{1d515}'),('\u{1d51d}','\u{1d51d}'),('\u{1d53a}','\u{1d53a}'),('\u{1d53f}','\u{1d53f}'),('\u{1d545}','\u{1d545}'),('\u{1d547}','\u{1d549}'),('\u{1d551}','\u{1d551}'),('\u{1d6a6}','\u{1d6a7}'),('\u{1d7cc}','\u{1d7cd}'),('\u{1da8c}','\u{1da9a}'),('\u{1daa0}','\u{1daa0}'),('\u{1dab0}','\u{1deff}'),('\u{1df1f}','\u{1df24}'),('\u{1df2b}','\u{1dfff}'),('\u{1e007}','\u{1e007}'),('\u{1e019}','\u{1e01a}'),('\u{1e022}','\u{1e022}'),('\u{1e025}','\u{1e025}'),('\u{1e02b}','\u{1e02f}'),('\u{1e06e}','\u{1e08e}'),('\u{1e090}','\u{1e0ff}'),('\u{1e12d}','\u{1e12f}'),('\u{1e13e}','\u{1e13f}'),('\u{1e14a}','\u{1e14d}'),('\u{1e150}','\u{1e28f}'),('\u{1e2af}','\u{1e2bf}'),('\u{1e2fa}','\u{1e2fe}'),('\u{1e300}','\u{1e4cf}'),('\u{1e4fa}','\u{1e5cf}'),('\u{1e5fb}','\u{1e5fe}'),('\u{1e600}','\u{1e7df}'),('\u{1e7e7}','\u{1e7e7}'),('\u{1e7ec}','\u{1e7ec}'),('\u{1e7ef}','\u{1e7ef}'),('\u{1e7ff}','\u{1e7ff}'),('\u{1e8c5}','\u{1e8c6}'),('\u{1e8d7}','\u{1e8ff}'),('\u{1e94c}','\u{1e94f}'),('\u{1e95a}','\u{1e95d}'),('\u{1e960}','\u{1ec70}'),('\u{1ecb5}','\u{1ed00}'),('\u{1ed3e}','\u{1edff}'),('\u{1ee04}','\u{1ee04}'),('\u{1ee20}','\u{1ee20}'),('\u{1ee23}','\u{1ee23}'),('\u{1ee25}','\u{1ee26}'),('\u{1ee28}','\u{1ee28}'),('\u{1ee33}','\u{1ee33}'),('\u{1ee38}','\u{1ee38}'),('\u{1ee3a}','\u{1ee3a}'),('\u{1ee3c}','\u{1ee41}'),('\u{1ee43}','\u{1ee46}'),('\u{1ee48}','\u{1ee48}'),('\u{1ee4a}','\u{1ee4a}'),('\u{1ee4c}','\u{1ee4c}'),('\u{1ee50}','\u{1ee50}'),('\u{1ee53}','\u{1ee53}'),('\u{1ee55}','\u{1ee56}'),('\u{1ee58}','\u{1ee58}'),('\u{1ee5a}','\u{1ee5a}'),('\u{1ee5c}','\u{1ee5c}'),('\u{1ee5e}','\u{1ee5e}'),('\u{1ee60}','\u{1ee60}'),('\u{1ee63}','\u{1ee63}'),('\u{1ee65}','\u{1ee66}'),('\u{1ee6b}','\u{1ee6b}'),('\u{1ee73}','\u{1ee73}'),('\u{1ee78}','\u{1ee78}'),('\u{1ee7d}','\u{1ee7d}'),('\u{1ee7f}','\u{1ee7f}'),('\u{1ee8a}','\u{1ee8a}'),('\u{1ee9c}','\u{1eea0}'),('\u{1eea4}','\u{1eea4}'),('\u{1eeaa}','\u{1eeaa}'),('\u{1eebc}','\u{1eeef}'),('\u{1eef2}','\u{1efff}'),('\u{1f02c}','\u{1f02f}'),('\u{1f094}','\u{1f09f}'),('\u{1f0af}','\u{1f0b0}'),('\u{1f0c0}','\u{1f0c0}'),('\u{1f0d0}','\u{1f0d0}'),('\u{1f0f6}','\u{1f0ff}'),('\u{1f1ae}','\u{1f1e5}'),('\u{1f203}','\u{1f20f}'),('\u{1f23c}','\u{1f23f}'),('\u{1f249}','\u{1f24f}'),('\u{1f252}','\u{1f25f}'),('\u{1f266}','\u{1f2ff}'),('\u{1f6d8}','\u{1f6db}'),('\u{1f6ed}','\u{1f6ef}'),('\u{1f6fd}','\u{1f6ff}'),('\u{1f777}','\u{1f77a}'),('\u{1f7da}','\u{1f7df}'),('\u{1f7ec}','\u{1f7ef}'),('\u{1f7f1}','\u{1f7ff}'),('\u{1f80c}','\u{1f80f}'),('\u{1f848}','\u{1f84f}'),('\u{1f85a}','\u{1f85f}'),('\u{1f888}','\u{1f88f}'),('\u{1f8ae}','\u{1f8af}'),('\u{1f8bc}','\u{1f8bf}'),('\u{1f8c2}','\u{1f8ff}'),('\u{1fa54}','\u{1fa5f}'),('\u{1fa6e}','\u{1fa6f}'),('\u{1fa7d}','\u{1fa7f}'),('\u{1fa8a}','\u{1fa8e}'),('\u{1fac7}','\u{1facd}'),('\u{1fadd}','\u{1fade}'),('\u{1faea}','\u{1faef}'),('\u{1faf9}','\u{1faff}'),('\u{1fb93}','\u{1fb93}'),('\u{1fbfa}','\u{1ffff}'),('\u{2a6e0}','\u{2a6ff}'),('\u{2b73a}','\u{2b73f}'),('\u{2b81e}','\u{2b81f}'),('\u{2cea2}','\u{2ceaf}'),('\u{2ebe1}','\u{2ebef}'),('\u{2ee5e}','\u{2f7ff}'),('\u{2fa1e}','\u{2ffff}'),('\u{3134b}','\u{3134f}'),('\u{323b0}','\u{e0000}'),('\u{e0002}','\u{e001f}'),('\u{e0080}','\u{e00ff}'),('\u{e01f0}','\u{effff}'),('\u{ffffe}','\u{fffff}'),('\u{10fffe}','\u{10ffff}') ];
            pub const UPPERCASE_LETTER:&'static [(char,char)] = &[ ('A','Z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
        }

        pub mod graphemes
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] = &[ ("CR", CR),("Control", CONTROL),("Extend", EXTEND),("L", L),("LF", LF),("LV", LV),("LVT", LVT),("Prepend", PREPEND),("Regional_Indicator", REGIONAL_INDICATOR),("SpacingMark", SPACINGMARK),("T", T),("V", V),("ZWJ", ZWJ) ];
            pub const CR:&'static [(char,char)] = &[('\r','\r')];
            pub const CONTROL:&'static [(char,char)] = &[ ('\0','\t'),('\u{b}','\u{c}'),('\u{e}','\u{1f}'),('\u{7f}','\u{9f}'),('\u{ad}','\u{ad}'),('\u{61c}','\u{61c}'),('\u{180e}','\u{180e}'),('\u{200b}','\u{200b}'),('\u{200e}','\u{200f}'),('\u{2028}','\u{202e}'),('\u{2060}','\u{206f}'),('\u{feff}','\u{feff}'),('\u{fff0}','\u{fffb}'),('\u{13430}','\u{1343f}'),('\u{1bca0}','\u{1bca3}'),('\u{1d173}','\u{1d17a}'),('\u{e0000}','\u{e001f}'),('\u{e0080}','\u{e00ff}'),('\u{e01f0}','\u{e0fff}') ];
            pub const EXTEND:&'static [(char,char)] = &[ ('\u{300}','\u{36f}'),('\u{483}','\u{489}'),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('\u{610}','\u{61a}'),('\u{64b}','\u{65f}'),('\u{670}','\u{670}'),('\u{6d6}','\u{6dc}'),('\u{6df}','\u{6e4}'),('\u{6e7}','\u{6e8}'),('\u{6ea}','\u{6ed}'),('\u{711}','\u{711}'),('\u{730}','\u{74a}'),('\u{7a6}','\u{7b0}'),('\u{7eb}','\u{7f3}'),('\u{7fd}','\u{7fd}'),('\u{816}','\u{819}'),('\u{81b}','\u{823}'),('\u{825}','\u{827}'),('\u{829}','\u{82d}'),('\u{859}','\u{85b}'),('\u{897}','\u{89f}'),('\u{8ca}','\u{8e1}'),('\u{8e3}','\u{902}'),('\u{93a}','\u{93a}'),('\u{93c}','\u{93c}'),('\u{941}','\u{948}'),('\u{94d}','\u{94d}'),('\u{951}','\u{957}'),('\u{962}','\u{963}'),('\u{981}','\u{981}'),('\u{9bc}','\u{9bc}'),('\u{9be}','\u{9be}'),('\u{9c1}','\u{9c4}'),('\u{9cd}','\u{9cd}'),('\u{9d7}','\u{9d7}'),('\u{9e2}','\u{9e3}'),('\u{9fe}','\u{9fe}'),('\u{a01}','\u{a02}'),('\u{a3c}','\u{a3c}'),('\u{a41}','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('\u{a70}','\u{a71}'),('\u{a75}','\u{a75}'),('\u{a81}','\u{a82}'),('\u{abc}','\u{abc}'),('\u{ac1}','\u{ac5}'),('\u{ac7}','\u{ac8}'),('\u{acd}','\u{acd}'),('\u{ae2}','\u{ae3}'),('\u{afa}','\u{aff}'),('\u{b01}','\u{b01}'),('\u{b3c}','\u{b3c}'),('\u{b3e}','\u{b3f}'),('\u{b41}','\u{b44}'),('\u{b4d}','\u{b4d}'),('\u{b55}','\u{b57}'),('\u{b62}','\u{b63}'),('\u{b82}','\u{b82}'),('\u{bbe}','\u{bbe}'),('\u{bc0}','\u{bc0}'),('\u{bcd}','\u{bcd}'),('\u{bd7}','\u{bd7}'),('\u{c00}','\u{c00}'),('\u{c04}','\u{c04}'),('\u{c3c}','\u{c3c}'),('\u{c3e}','\u{c40}'),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('\u{c62}','\u{c63}'),('\u{c81}','\u{c81}'),('\u{cbc}','\u{cbc}'),('\u{cbf}','\u{cc0}'),('\u{cc2}','\u{cc2}'),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('\u{ce2}','\u{ce3}'),('\u{d00}','\u{d01}'),('\u{d3b}','\u{d3c}'),('\u{d3e}','\u{d3e}'),('\u{d41}','\u{d44}'),('\u{d4d}','\u{d4d}'),('\u{d57}','\u{d57}'),('\u{d62}','\u{d63}'),('\u{d81}','\u{d81}'),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dcf}'),('\u{dd2}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('\u{ddf}','\u{ddf}'),('\u{e31}','\u{e31}'),('\u{e34}','\u{e3a}'),('\u{e47}','\u{e4e}'),('\u{eb1}','\u{eb1}'),('\u{eb4}','\u{ebc}'),('\u{ec8}','\u{ece}'),('\u{f18}','\u{f19}'),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('\u{f71}','\u{f7e}'),('\u{f80}','\u{f84}'),('\u{f86}','\u{f87}'),('\u{f8d}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('\u{102d}','\u{1030}'),('\u{1032}','\u{1037}'),('\u{1039}','\u{103a}'),('\u{103d}','\u{103e}'),('\u{1058}','\u{1059}'),('\u{105e}','\u{1060}'),('\u{1071}','\u{1074}'),('\u{1082}','\u{1082}'),('\u{1085}','\u{1086}'),('\u{108d}','\u{108d}'),('\u{109d}','\u{109d}'),('\u{135d}','\u{135f}'),('\u{1712}','\u{1715}'),('\u{1732}','\u{1734}'),('\u{1752}','\u{1753}'),('\u{1772}','\u{1773}'),('\u{17b4}','\u{17b5}'),('\u{17b7}','\u{17bd}'),('\u{17c6}','\u{17c6}'),('\u{17c9}','\u{17d3}'),('\u{17dd}','\u{17dd}'),('\u{180b}','\u{180d}'),('\u{180f}','\u{180f}'),('\u{1885}','\u{1886}'),('\u{18a9}','\u{18a9}'),('\u{1920}','\u{1922}'),('\u{1927}','\u{1928}'),('\u{1932}','\u{1932}'),('\u{1939}','\u{193b}'),('\u{1a17}','\u{1a18}'),('\u{1a1b}','\u{1a1b}'),('\u{1a56}','\u{1a56}'),('\u{1a58}','\u{1a5e}'),('\u{1a60}','\u{1a60}'),('\u{1a62}','\u{1a62}'),('\u{1a65}','\u{1a6c}'),('\u{1a73}','\u{1a7c}'),('\u{1a7f}','\u{1a7f}'),('\u{1ab0}','\u{1ace}'),('\u{1b00}','\u{1b03}'),('\u{1b34}','\u{1b3d}'),('\u{1b42}','\u{1b44}'),('\u{1b6b}','\u{1b73}'),('\u{1b80}','\u{1b81}'),('\u{1ba2}','\u{1ba5}'),('\u{1ba8}','\u{1bad}'),('\u{1be6}','\u{1be6}'),('\u{1be8}','\u{1be9}'),('\u{1bed}','\u{1bed}'),('\u{1bef}','\u{1bf3}'),('\u{1c2c}','\u{1c33}'),('\u{1c36}','\u{1c37}'),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}','\u{1ce0}'),('\u{1ce2}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('\u{1cf8}','\u{1cf9}'),('\u{1dc0}','\u{1dff}'),('\u{200c}','\u{200c}'),('\u{20d0}','\u{20f0}'),('\u{2cef}','\u{2cf1}'),('\u{2d7f}','\u{2d7f}'),('\u{2de0}','\u{2dff}'),('\u{302a}','\u{302f}'),('\u{3099}','\u{309a}'),('\u{a66f}','\u{a672}'),('\u{a674}','\u{a67d}'),('\u{a69e}','\u{a69f}'),('\u{a6f0}','\u{a6f1}'),('\u{a802}','\u{a802}'),('\u{a806}','\u{a806}'),('\u{a80b}','\u{a80b}'),('\u{a825}','\u{a826}'),('\u{a82c}','\u{a82c}'),('\u{a8c4}','\u{a8c5}'),('\u{a8e0}','\u{a8f1}'),('\u{a8ff}','\u{a8ff}'),('\u{a926}','\u{a92d}'),('\u{a947}','\u{a951}'),('\u{a953}','\u{a953}'),('\u{a980}','\u{a982}'),('\u{a9b3}','\u{a9b3}'),('\u{a9b6}','\u{a9b9}'),('\u{a9bc}','\u{a9bd}'),('\u{a9c0}','\u{a9c0}'),('\u{a9e5}','\u{a9e5}'),('\u{aa29}','\u{aa2e}'),('\u{aa31}','\u{aa32}'),('\u{aa35}','\u{aa36}'),('\u{aa43}','\u{aa43}'),('\u{aa4c}','\u{aa4c}'),('\u{aa7c}','\u{aa7c}'),('\u{aab0}','\u{aab0}'),('\u{aab2}','\u{aab4}'),('\u{aab7}','\u{aab8}'),('\u{aabe}','\u{aabf}'),('\u{aac1}','\u{aac1}'),('\u{aaec}','\u{aaed}'),('\u{aaf6}','\u{aaf6}'),('\u{abe5}','\u{abe5}'),('\u{abe8}','\u{abe8}'),('\u{abed}','\u{abed}'),('\u{fb1e}','\u{fb1e}'),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('\u{ff9e}','\u{ff9f}'),('\u{101fd}','\u{101fd}'),('\u{102e0}','\u{102e0}'),('\u{10376}','\u{1037a}'),('\u{10a01}','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}','\u{10a0f}'),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('\u{10ae5}','\u{10ae6}'),('\u{10d24}','\u{10d27}'),('\u{10d69}','\u{10d6d}'),('\u{10eab}','\u{10eac}'),('\u{10efc}','\u{10eff}'),('\u{10f46}','\u{10f50}'),('\u{10f82}','\u{10f85}'),('\u{11001}','\u{11001}'),('\u{11038}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{11073}','\u{11074}'),('\u{1107f}','\u{11081}'),('\u{110b3}','\u{110b6}'),('\u{110b9}','\u{110ba}'),('\u{110c2}','\u{110c2}'),('\u{11100}','\u{11102}'),('\u{11127}','\u{1112b}'),('\u{1112d}','\u{11134}'),('\u{11173}','\u{11173}'),('\u{11180}','\u{11181}'),('\u{111b6}','\u{111be}'),('\u{111c0}','\u{111c0}'),('\u{111c9}','\u{111cc}'),('\u{111cf}','\u{111cf}'),('\u{1122f}','\u{11231}'),('\u{11234}','\u{11237}'),('\u{1123e}','\u{1123e}'),('\u{11241}','\u{11241}'),('\u{112df}','\u{112df}'),('\u{112e3}','\u{112ea}'),('\u{11300}','\u{11301}'),('\u{1133b}','\u{1133c}'),('\u{1133e}','\u{1133e}'),('\u{11340}','\u{11340}'),('\u{1134d}','\u{1134d}'),('\u{11357}','\u{11357}'),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('\u{113b8}','\u{113b8}'),('\u{113bb}','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}','\u{113c9}'),('\u{113ce}','\u{113d0}'),('\u{113d2}','\u{113d2}'),('\u{113e1}','\u{113e2}'),('\u{11438}','\u{1143f}'),('\u{11442}','\u{11444}'),('\u{11446}','\u{11446}'),('\u{1145e}','\u{1145e}'),('\u{114b0}','\u{114b0}'),('\u{114b3}','\u{114b8}'),('\u{114ba}','\u{114ba}'),('\u{114bd}','\u{114bd}'),('\u{114bf}','\u{114c0}'),('\u{114c2}','\u{114c3}'),('\u{115af}','\u{115af}'),('\u{115b2}','\u{115b5}'),('\u{115bc}','\u{115bd}'),('\u{115bf}','\u{115c0}'),('\u{115dc}','\u{115dd}'),('\u{11633}','\u{1163a}'),('\u{1163d}','\u{1163d}'),('\u{1163f}','\u{11640}'),('\u{116ab}','\u{116ab}'),('\u{116ad}','\u{116ad}'),('\u{116b0}','\u{116b7}'),('\u{1171d}','\u{1171d}'),('\u{1171f}','\u{1171f}'),('\u{11722}','\u{11725}'),('\u{11727}','\u{1172b}'),('\u{1182f}','\u{11837}'),('\u{11839}','\u{1183a}'),('\u{11930}','\u{11930}'),('\u{1193b}','\u{1193e}'),('\u{11943}','\u{11943}'),('\u{119d4}','\u{119d7}'),('\u{119da}','\u{119db}'),('\u{119e0}','\u{119e0}'),('\u{11a01}','\u{11a0a}'),('\u{11a33}','\u{11a38}'),('\u{11a3b}','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('\u{11a51}','\u{11a56}'),('\u{11a59}','\u{11a5b}'),('\u{11a8a}','\u{11a96}'),('\u{11a98}','\u{11a99}'),('\u{11c30}','\u{11c36}'),('\u{11c38}','\u{11c3d}'),('\u{11c3f}','\u{11c3f}'),('\u{11c92}','\u{11ca7}'),('\u{11caa}','\u{11cb0}'),('\u{11cb2}','\u{11cb3}'),('\u{11cb5}','\u{11cb6}'),('\u{11d31}','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d45}'),('\u{11d47}','\u{11d47}'),('\u{11d90}','\u{11d91}'),('\u{11d95}','\u{11d95}'),('\u{11d97}','\u{11d97}'),('\u{11ef3}','\u{11ef4}'),('\u{11f00}','\u{11f01}'),('\u{11f36}','\u{11f3a}'),('\u{11f40}','\u{11f42}'),('\u{11f5a}','\u{11f5a}'),('\u{13440}','\u{13440}'),('\u{13447}','\u{13455}'),('\u{1611e}','\u{16129}'),('\u{1612d}','\u{1612f}'),('\u{16af0}','\u{16af4}'),('\u{16b30}','\u{16b36}'),('\u{16f4f}','\u{16f4f}'),('\u{16f8f}','\u{16f92}'),('\u{16fe4}','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('\u{1bc9d}','\u{1bc9e}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d165}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('\u{1e08f}','\u{1e08f}'),('\u{1e130}','\u{1e136}'),('\u{1e2ae}','\u{1e2ae}'),('\u{1e2ec}','\u{1e2ef}'),('\u{1e4ec}','\u{1e4ef}'),('\u{1e5ee}','\u{1e5ef}'),('\u{1e8d0}','\u{1e8d6}'),('\u{1e944}','\u{1e94a}'),('',''),('\u{e0020}','\u{e007f}'),('\u{e0100}','\u{e01ef}') ];
            pub const L:&'static [(char,char)] = &[('',''),('','')];
            pub const LF:&'static [(char,char)] = &[('\n','\n')];
            pub const LV:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const LVT:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const PREPEND:&'static [(char,char)] = &[ ('\u{600}','\u{605}'),('\u{6dd}','\u{6dd}'),('\u{70f}','\u{70f}'),('\u{890}','\u{891}'),('\u{8e2}','\u{8e2}'),('',''),('\u{110bd}','\u{110bd}'),('\u{110cd}','\u{110cd}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const REGIONAL_INDICATOR:&'static [(char,char)] = &[('','')];
            pub const SPACINGMARK:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const T:&'static [(char,char)] = &[('',''),('','')];
            pub const V:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
            pub const ZWJ:&'static [(char,char)] = &[('\u{200d}','\u{200d}')];
        }

        pub mod perl
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub mod decimal
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] = &[("Decimal_Number", DECIMAL_NUMBER)];
                pub const DECIMAL_NUMBER:&'static [(char,char)] = &[ ('0','9'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            }

            pub mod space
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] = &[("White_Space", WHITE_SPACE)];
                pub const WHITE_SPACE:&'static [(char,char)] = &[ ('\t','\r'),(' ',' '),('\u{85}','\u{85}'),('\u{a0}','\u{a0}'),('\u{1680}','\u{1680}'),('\u{2000}','\u{200a}'),('\u{2028}','\u{2029}'),('\u{202f}','\u{202f}'),('\u{205f}','\u{205f}'),('\u{3000}','\u{3000}') ];
            }

            pub mod word
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                pub const PERL_WORD:&'static [(char,char)] = &[ ('0','9'),('A','Z'),('_','_'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{300}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{483}',''),('',''),('',''),('',''),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('',''),('',''),('\u{610}','\u{61a}'),('',''),('',''),('','\u{6dc}'),('\u{6df}','\u{6e8}'),('\u{6ea}',''),('',''),('','\u{74a}'),('',''),('',''),('',''),('\u{7fd}','\u{7fd}'),('','\u{82d}'),('','\u{85b}'),('',''),('',''),('',''),('\u{897}','\u{8e1}'),('\u{8e3}','\u{963}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{9bc}','\u{9c4}'),('',''),('',''),('\u{9d7}','\u{9d7}'),('',''),('','\u{9e3}'),('',''),('',''),('\u{9fe}','\u{9fe}'),('\u{a01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('',''),('',''),('','\u{a75}'),('\u{a81}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{abc}','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('',''),('','\u{ae3}'),('',''),('','\u{aff}'),('\u{b01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{b3c}','\u{b44}'),('',''),('','\u{b4d}'),('\u{b55}','\u{b57}'),('',''),('','\u{b63}'),('',''),('',''),('\u{b82}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{bbe}',''),('',''),('','\u{bcd}'),('',''),('\u{bd7}','\u{bd7}'),('',''),('\u{c00}',''),('',''),('',''),('',''),('\u{c3c}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('',''),('',''),('','\u{c63}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{cbc}',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('',''),('','\u{ce3}'),('',''),('',''),('\u{d00}',''),('',''),('','\u{d44}'),('',''),('',''),('','\u{d57}'),('','\u{d63}'),('',''),('',''),('\u{d81}',''),('',''),('',''),('',''),('',''),('',''),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('',''),('','\u{e3a}'),('','\u{e4e}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{ec8}','\u{ece}'),('',''),('',''),('',''),('\u{f18}','\u{f19}'),('',''),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('',''),('',''),('\u{f71}','\u{f84}'),('\u{f86}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('',''),('','\u{109d}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{135d}','\u{135f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1715}'),('','\u{1734}'),('','\u{1753}'),('',''),('',''),('\u{1772}','\u{1773}'),('','\u{17d3}'),('',''),('','\u{17dd}'),('',''),('\u{180b}','\u{180d}'),('\u{180f}',''),('',''),('',''),('',''),('',''),('\u{1920}',''),('','\u{193b}'),('',''),('',''),('',''),('',''),('',''),('','\u{1a1b}'),('','\u{1a5e}'),('\u{1a60}','\u{1a7c}'),('\u{1a7f}',''),('',''),('',''),('\u{1ab0}','\u{1ace}'),('\u{1b00}',''),('',''),('\u{1b6b}','\u{1b73}'),('\u{1b80}','\u{1bf3}'),('','\u{1c37}'),('',''),('',''),('',''),('',''),('',''),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{200c}','\u{200d}'),('',''),('',''),('',''),('',''),('',''),('\u{20d0}','\u{20f0}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2d7f}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2de0}','\u{2dff}'),('',''),('',''),('','\u{302f}'),('',''),('',''),('',''),('\u{3099}','\u{309a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{a672}'),('\u{a674}','\u{a67d}'),('','\u{a6f1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a82c}','\u{a82c}'),('',''),('','\u{a8c5}'),('',''),('\u{a8e0}',''),('',''),('','\u{a92d}'),('','\u{a953}'),('',''),('\u{a980}','\u{a9c0}'),('',''),('',''),('','\u{aa36}'),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{aaf6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{abed}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{101fd}','\u{101fd}'),('',''),('',''),('\u{102e0}','\u{102e0}'),('',''),('',''),('','\u{1037a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}',''),('',''),('',''),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('',''),('',''),('',''),('','\u{10ae6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10d27}'),('',''),('',''),('\u{10d69}','\u{10d6d}'),('',''),('',''),('\u{10eab}','\u{10eac}'),('',''),('',''),('\u{10efc}',''),('',''),('','\u{10f50}'),('','\u{10f85}'),('',''),('',''),('','\u{11046}'),('',''),('\u{1107f}','\u{110ba}'),('\u{110c2}','\u{110c2}'),('',''),('',''),('\u{11100}','\u{11134}'),('',''),('',''),('','\u{11173}'),('',''),('\u{11180}',''),('\u{111c9}','\u{111cc}'),('',''),('',''),('',''),('','\u{11237}'),('\u{1123e}','\u{11241}'),('',''),('',''),('',''),('',''),('',''),('','\u{112ea}'),('',''),('\u{11300}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1133b}',''),('',''),('','\u{1134d}'),('',''),('\u{11357}','\u{11357}'),('',''),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('',''),('',''),('',''),('',''),('','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('',''),('\u{113e1}','\u{113e2}'),('',''),('',''),('\u{1145e}',''),('',''),('',''),('',''),('','\u{115b5}'),('','\u{115c0}'),('','\u{115dd}'),('','\u{11640}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1171d}','\u{1172b}'),('',''),('',''),('','\u{1183a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1193b}','\u{11943}'),('',''),('',''),('','\u{119d7}'),('\u{119da}',''),('',''),('','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('','\u{11a99}'),('',''),('',''),('',''),('',''),('',''),('','\u{11c36}'),('\u{11c38}',''),('',''),('',''),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),('',''),('',''),('','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d47}'),('',''),('',''),('',''),('',''),('\u{11d90}','\u{11d91}'),('',''),('',''),('',''),('\u{11f00}',''),('','\u{11f3a}'),('','\u{11f42}'),('','\u{11f5a}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{13440}','\u{13455}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16af0}','\u{16af4}'),('','\u{16b36}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16f4f}',''),('\u{16f8f}',''),('',''),('','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1bc9d}','\u{1bc9e}'),('',''),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d165}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('',''),('',''),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('',''),('\u{1e08f}','\u{1e08f}'),('',''),('\u{1e130}',''),('',''),('',''),('','\u{1e2ae}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1e8d0}','\u{1e8d6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{e0100}','\u{e01ef}') ];
            }
        }

        pub mod property
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub mod booleans
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] = &[ ("ASCII_Hex_Digit", ASCII_HEX_DIGIT),("Alphabetic", ALPHABETIC),("Bidi_Control", BIDI_CONTROL),("Bidi_Mirrored", BIDI_MIRRORED),("Case_Ignorable", CASE_IGNORABLE),("Cased", CASED),("Changes_When_Casefolded", CHANGES_WHEN_CASEFOLDED),("Changes_When_Casemapped", CHANGES_WHEN_CASEMAPPED),("Changes_When_Lowercased", CHANGES_WHEN_LOWERCASED),("Changes_When_Titlecased", CHANGES_WHEN_TITLECASED),("Changes_When_Uppercased", CHANGES_WHEN_UPPERCASED),("Dash", DASH),("Default_Ignorable_Code_Point", DEFAULT_IGNORABLE_CODE_POINT),("Deprecated", DEPRECATED),("Diacritic", DIACRITIC),("Emoji", EMOJI),("Emoji_Component", EMOJI_COMPONENT),("Emoji_Modifier", EMOJI_MODIFIER),("Emoji_Modifier_Base", EMOJI_MODIFIER_BASE),("Emoji_Presentation", EMOJI_PRESENTATION),("Extended_Pictographic", EXTENDED_PICTOGRAPHIC),("Extender", EXTENDER),("Grapheme_Base", GRAPHEME_BASE),("Grapheme_Extend", GRAPHEME_EXTEND),("Grapheme_Link", GRAPHEME_LINK),("Hex_Digit", HEX_DIGIT),("Hyphen", HYPHEN),("IDS_Binary_Operator", IDS_BINARY_OPERATOR),("IDS_Trinary_Operator", IDS_TRINARY_OPERATOR),("IDS_Unary_Operator", IDS_UNARY_OPERATOR),("ID_Compat_Math_Continue", ID_COMPAT_MATH_CONTINUE),("ID_Compat_Math_Start", ID_COMPAT_MATH_START),("ID_Continue", ID_CONTINUE),("ID_Start", ID_START),("Ideographic", IDEOGRAPHIC),("InCB", INCB),("Join_Control", JOIN_CONTROL),("Logical_Order_Exception", LOGICAL_ORDER_EXCEPTION),("Lowercase", LOWERCASE),("Math", MATH),("Modifier_Combining_Mark", MODIFIER_COMBINING_MARK),("Noncharacter_Code_Point", NONCHARACTER_CODE_POINT),("Other_Alphabetic", OTHER_ALPHABETIC),("Other_Default_Ignorable_Code_Point", OTHER_DEFAULT_IGNORABLE_CODE_POINT),("Other_Grapheme_Extend", OTHER_GRAPHEME_EXTEND),("Other_ID_Continue", OTHER_ID_CONTINUE),("Other_ID_Start", OTHER_ID_START),("Other_Lowercase", OTHER_LOWERCASE),("Other_Math", OTHER_MATH),("Other_Uppercase", OTHER_UPPERCASE),("Pattern_Syntax", PATTERN_SYNTAX),("Pattern_White_Space", PATTERN_WHITE_SPACE),("Prepended_Concatenation_Mark", PREPENDED_CONCATENATION_MARK),("Quotation_Mark", QUOTATION_MARK),("Radical", RADICAL),("Regional_Indicator", REGIONAL_INDICATOR),("Sentence_Terminal", SENTENCE_TERMINAL),("Soft_Dotted", SOFT_DOTTED),("Terminal_Punctuation", TERMINAL_PUNCTUATION),("Unified_Ideograph", UNIFIED_IDEOGRAPH),("Uppercase", UPPERCASE),("Variation_Selector", VARIATION_SELECTOR),("White_Space", WHITE_SPACE),("XID_Continue", XID_CONTINUE),("XID_Start", XID_START) ];
                pub const ASCII_HEX_DIGIT:&'static [(char,char)] = &[('0','9'),('A','F'),('a','f')];
                pub const ALPHABETIC:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{345}','\u{345}'),('\u{363}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{5b0}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('',''),('',''),('\u{610}','\u{61a}'),('','\u{657}'),('\u{659}','\u{65f}'),('',''),('','\u{6dc}'),('\u{6e1}','\u{6e8}'),('\u{6ed}',''),('',''),('',''),('','\u{73f}'),('',''),('',''),('',''),('',''),('','\u{817}'),('','\u{82c}'),('',''),('',''),('',''),('',''),('\u{897}','\u{897}'),('',''),('\u{8d4}','\u{8df}'),('\u{8e3}','\u{8e9}'),('\u{8f0}',''),('',''),('',''),('\u{955}','\u{963}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{9c4}'),('',''),('',''),('',''),('\u{9d7}','\u{9d7}'),('',''),('','\u{9e3}'),('',''),('',''),('\u{a01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4c}'),('\u{a51}','\u{a51}'),('',''),('',''),('\u{a70}','\u{a75}'),('\u{a81}',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{ac5}'),('\u{ac7}',''),('',''),('',''),('','\u{ae3}'),('','\u{afc}'),('\u{b01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{b44}'),('',''),('',''),('\u{b56}','\u{b57}'),('',''),('','\u{b63}'),('',''),('\u{b82}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{bbe}',''),('',''),('',''),('',''),('\u{bd7}','\u{bd7}'),('\u{c00}',''),('',''),('',''),('',''),('',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4c}'),('\u{c55}','\u{c56}'),('',''),('',''),('','\u{c63}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccc}'),('\u{cd5}','\u{cd6}'),('',''),('','\u{ce3}'),('',''),('\u{d00}',''),('',''),('',''),('','\u{d44}'),('',''),('',''),('',''),('','\u{d57}'),('','\u{d63}'),('',''),('\u{d81}',''),('',''),('',''),('',''),('',''),('',''),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('','\u{e3a}'),('',''),('\u{e4d}','\u{e4d}'),('',''),('',''),('',''),('',''),('',''),('','\u{eb9}'),('\u{ebb}',''),('',''),('',''),('\u{ecd}','\u{ecd}'),('',''),('',''),('',''),('',''),('\u{f71}','\u{f83}'),('','\u{f97}'),('\u{f99}','\u{fbc}'),('','\u{1036}'),('',''),('',''),('',''),('','\u{109d}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1713}'),('','\u{1733}'),('','\u{1753}'),('',''),('',''),('\u{1772}','\u{1773}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1920}',''),('',''),('',''),('',''),('',''),('',''),('','\u{1a1b}'),('','\u{1a5e}'),('','\u{1a74}'),('',''),('\u{1abf}','\u{1ac0}'),('\u{1acc}','\u{1ace}'),('\u{1b00}',''),('\u{1b35}','\u{1b43}'),('',''),('\u{1b80}','\u{1ba9}'),('\u{1bac}',''),('',''),('','\u{1bf1}'),('','\u{1c36}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1dd3}','\u{1df4}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2de0}','\u{2dff}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a674}','\u{a67b}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a8c5}','\u{a8c5}'),('',''),('',''),('','\u{a8ff}'),('','\u{a92a}'),('',''),('',''),('\u{a980}',''),('',''),('',''),('',''),('',''),('','\u{aa36}'),('',''),('',''),('','\u{aabe}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1037a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10d27}'),('',''),('\u{10d69}','\u{10d69}'),('',''),('',''),('\u{10eab}','\u{10eac}'),('',''),('',''),('\u{10efc}','\u{10efc}'),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{11045}'),('',''),('\u{11080}',''),('\u{110c2}','\u{110c2}'),('',''),('\u{11100}','\u{11132}'),('',''),('',''),('',''),('\u{11180}',''),('',''),('','\u{111cf}'),('',''),('',''),('',''),('','\u{11234}'),('\u{11237}','\u{11237}'),('\u{1123e}','\u{11241}'),('',''),('',''),('',''),('',''),('',''),('','\u{112e8}'),('\u{11300}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{11357}','\u{11357}'),('',''),('',''),('',''),('',''),('',''),('','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('',''),('',''),('',''),('',''),('\u{11443}',''),('',''),('',''),('',''),('',''),('',''),('','\u{115b5}'),('',''),('','\u{115dd}'),('',''),('\u{11640}','\u{11640}'),('',''),('','\u{116b5}'),('',''),('',''),('\u{1171d}','\u{1172a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1193b}','\u{1193c}'),('',''),('',''),('','\u{119d7}'),('\u{119da}',''),('',''),('',''),('',''),('\u{11a35}','\u{11a3e}'),('',''),('',''),('',''),('',''),('',''),('','\u{11c36}'),('\u{11c38}',''),('',''),('',''),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),('',''),('',''),('','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d41}'),('\u{11d43}','\u{11d43}'),('','\u{11d47}'),('',''),('',''),('',''),('\u{11d90}','\u{11d91}'),('',''),('',''),('',''),('\u{11f00}',''),('','\u{11f3a}'),('','\u{11f40}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1612e}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16f4f}',''),('\u{16f8f}',''),('',''),('',''),('\u{16ff0}','\u{16ff1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1bc9e}','\u{1bc9e}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('',''),('\u{1e08f}','\u{1e08f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1e947}','\u{1e947}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const BIDI_CONTROL:&'static [(char,char)] = &[ ('\u{61c}','\u{61c}'),('\u{200e}','\u{200f}'),('\u{202a}','\u{202e}'),('\u{2066}','\u{2069}') ];
                pub const BIDI_MIRRORED:&'static [(char,char)] = &[ ('(',')'),('<','<'),('>','>'),('[','['),(']',']'),('{','{'),('}','}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const CASE_IGNORABLE:&'static [(char,char)] = &[ ('\'','\''),('.','.'),(':',':'),('^','^'),('`','`'),('',''),('\u{ad}','\u{ad}'),('',''),('',''),('',''),('','\u{36f}'),('',''),('',''),('',''),('',''),('\u{483}','\u{489}'),('',''),('',''),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('',''),('\u{600}','\u{605}'),('\u{610}','\u{61a}'),('\u{61c}','\u{61c}'),('',''),('\u{64b}','\u{65f}'),('\u{670}','\u{670}'),('\u{6d6}','\u{6dd}'),('\u{6df}','\u{6e8}'),('\u{6ea}','\u{6ed}'),('\u{70f}','\u{70f}'),('\u{711}','\u{711}'),('\u{730}','\u{74a}'),('\u{7a6}','\u{7b0}'),('\u{7eb}',''),('',''),('\u{7fd}','\u{7fd}'),('\u{816}','\u{82d}'),('\u{859}','\u{85b}'),('',''),('\u{890}','\u{891}'),('\u{897}','\u{89f}'),('','\u{902}'),('\u{93a}','\u{93a}'),('\u{93c}','\u{93c}'),('\u{941}','\u{948}'),('\u{94d}','\u{94d}'),('\u{951}','\u{957}'),('\u{962}','\u{963}'),('',''),('\u{981}','\u{981}'),('\u{9bc}','\u{9bc}'),('\u{9c1}','\u{9c4}'),('\u{9cd}','\u{9cd}'),('\u{9e2}','\u{9e3}'),('\u{9fe}','\u{9fe}'),('\u{a01}','\u{a02}'),('\u{a3c}','\u{a3c}'),('\u{a41}','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('\u{a70}','\u{a71}'),('\u{a75}','\u{a75}'),('\u{a81}','\u{a82}'),('\u{abc}','\u{abc}'),('\u{ac1}','\u{ac5}'),('\u{ac7}','\u{ac8}'),('\u{acd}','\u{acd}'),('\u{ae2}','\u{ae3}'),('\u{afa}','\u{aff}'),('\u{b01}','\u{b01}'),('\u{b3c}','\u{b3c}'),('\u{b3f}','\u{b3f}'),('\u{b41}','\u{b44}'),('\u{b4d}','\u{b4d}'),('\u{b55}','\u{b56}'),('\u{b62}','\u{b63}'),('\u{b82}','\u{b82}'),('\u{bc0}','\u{bc0}'),('\u{bcd}','\u{bcd}'),('\u{c00}','\u{c00}'),('\u{c04}','\u{c04}'),('\u{c3c}','\u{c3c}'),('\u{c3e}','\u{c40}'),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('\u{c62}','\u{c63}'),('\u{c81}','\u{c81}'),('\u{cbc}','\u{cbc}'),('\u{cbf}','\u{cbf}'),('\u{cc6}','\u{cc6}'),('\u{ccc}','\u{ccd}'),('\u{ce2}','\u{ce3}'),('\u{d00}','\u{d01}'),('\u{d3b}','\u{d3c}'),('\u{d41}','\u{d44}'),('\u{d4d}','\u{d4d}'),('\u{d62}','\u{d63}'),('\u{d81}','\u{d81}'),('\u{dca}','\u{dca}'),('\u{dd2}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('\u{e31}','\u{e31}'),('\u{e34}','\u{e3a}'),('','\u{e4e}'),('\u{eb1}','\u{eb1}'),('\u{eb4}','\u{ebc}'),('',''),('\u{ec8}','\u{ece}'),('\u{f18}','\u{f19}'),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('\u{f71}','\u{f7e}'),('\u{f80}','\u{f84}'),('\u{f86}','\u{f87}'),('\u{f8d}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('\u{102d}','\u{1030}'),('\u{1032}','\u{1037}'),('\u{1039}','\u{103a}'),('\u{103d}','\u{103e}'),('\u{1058}','\u{1059}'),('\u{105e}','\u{1060}'),('\u{1071}','\u{1074}'),('\u{1082}','\u{1082}'),('\u{1085}','\u{1086}'),('\u{108d}','\u{108d}'),('\u{109d}','\u{109d}'),('',''),('\u{135d}','\u{135f}'),('\u{1712}','\u{1714}'),('\u{1732}','\u{1733}'),('\u{1752}','\u{1753}'),('\u{1772}','\u{1773}'),('\u{17b4}','\u{17b5}'),('\u{17b7}','\u{17bd}'),('\u{17c6}','\u{17c6}'),('\u{17c9}','\u{17d3}'),('',''),('\u{17dd}','\u{17dd}'),('\u{180b}','\u{180f}'),('',''),('\u{1885}','\u{1886}'),('\u{18a9}','\u{18a9}'),('\u{1920}','\u{1922}'),('\u{1927}','\u{1928}'),('\u{1932}','\u{1932}'),('\u{1939}','\u{193b}'),('\u{1a17}','\u{1a18}'),('\u{1a1b}','\u{1a1b}'),('\u{1a56}','\u{1a56}'),('\u{1a58}','\u{1a5e}'),('\u{1a60}','\u{1a60}'),('\u{1a62}','\u{1a62}'),('\u{1a65}','\u{1a6c}'),('\u{1a73}','\u{1a7c}'),('\u{1a7f}','\u{1a7f}'),('',''),('\u{1ab0}','\u{1ace}'),('\u{1b00}','\u{1b03}'),('\u{1b34}','\u{1b34}'),('\u{1b36}','\u{1b3a}'),('\u{1b3c}','\u{1b3c}'),('\u{1b42}','\u{1b42}'),('\u{1b6b}','\u{1b73}'),('\u{1b80}','\u{1b81}'),('\u{1ba2}','\u{1ba5}'),('\u{1ba8}','\u{1ba9}'),('\u{1bab}','\u{1bad}'),('\u{1be6}','\u{1be6}'),('\u{1be8}','\u{1be9}'),('\u{1bed}','\u{1bed}'),('\u{1bef}','\u{1bf1}'),('\u{1c2c}','\u{1c33}'),('\u{1c36}','\u{1c37}'),('',''),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}','\u{1ce0}'),('\u{1ce2}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('\u{1cf8}','\u{1cf9}'),('',''),('',''),('','\u{1dff}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{200b}','\u{200f}'),('',''),('',''),('',''),('\u{202a}','\u{202e}'),('\u{2060}','\u{2064}'),('\u{2066}','\u{206f}'),('',''),('',''),('',''),('\u{20d0}','\u{20f0}'),('',''),('\u{2cef}','\u{2cf1}'),('',''),('\u{2d7f}','\u{2d7f}'),('\u{2de0}','\u{2dff}'),('',''),('',''),('\u{302a}','\u{302d}'),('',''),('',''),('\u{3099}',''),('',''),('',''),('',''),('',''),('\u{a66f}','\u{a672}'),('\u{a674}','\u{a67d}'),('',''),('','\u{a69f}'),('\u{a6f0}','\u{a6f1}'),('',''),('',''),('',''),('',''),('',''),('\u{a802}','\u{a802}'),('\u{a806}','\u{a806}'),('\u{a80b}','\u{a80b}'),('\u{a825}','\u{a826}'),('\u{a82c}','\u{a82c}'),('\u{a8c4}','\u{a8c5}'),('\u{a8e0}','\u{a8f1}'),('\u{a8ff}','\u{a8ff}'),('\u{a926}','\u{a92d}'),('\u{a947}','\u{a951}'),('\u{a980}','\u{a982}'),('\u{a9b3}','\u{a9b3}'),('\u{a9b6}','\u{a9b9}'),('\u{a9bc}','\u{a9bd}'),('',''),('\u{a9e5}',''),('\u{aa29}','\u{aa2e}'),('\u{aa31}','\u{aa32}'),('\u{aa35}','\u{aa36}'),('\u{aa43}','\u{aa43}'),('\u{aa4c}','\u{aa4c}'),('',''),('\u{aa7c}','\u{aa7c}'),('\u{aab0}','\u{aab0}'),('\u{aab2}','\u{aab4}'),('\u{aab7}','\u{aab8}'),('\u{aabe}','\u{aabf}'),('\u{aac1}','\u{aac1}'),('',''),('\u{aaec}','\u{aaed}'),('',''),('\u{aaf6}','\u{aaf6}'),('',''),('',''),('\u{abe5}','\u{abe5}'),('\u{abe8}','\u{abe8}'),('\u{abed}','\u{abed}'),('\u{fb1e}','\u{fb1e}'),('',''),('\u{fe00}','\u{fe0f}'),('',''),('\u{fe20}','\u{fe2f}'),('',''),('',''),('\u{feff}','\u{feff}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{ff9e}','\u{ff9f}'),('',''),('\u{fff9}','\u{fffb}'),('\u{101fd}','\u{101fd}'),('\u{102e0}','\u{102e0}'),('\u{10376}','\u{1037a}'),('',''),('',''),('',''),('\u{10a01}','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}','\u{10a0f}'),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('\u{10ae5}','\u{10ae6}'),('\u{10d24}','\u{10d27}'),('',''),('\u{10d69}','\u{10d6d}'),('',''),('\u{10eab}','\u{10eac}'),('\u{10efc}','\u{10eff}'),('\u{10f46}','\u{10f50}'),('\u{10f82}','\u{10f85}'),('\u{11001}','\u{11001}'),('\u{11038}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{11073}','\u{11074}'),('\u{1107f}','\u{11081}'),('\u{110b3}','\u{110b6}'),('\u{110b9}','\u{110ba}'),('\u{110bd}','\u{110bd}'),('\u{110c2}','\u{110c2}'),('\u{110cd}','\u{110cd}'),('\u{11100}','\u{11102}'),('\u{11127}','\u{1112b}'),('\u{1112d}','\u{11134}'),('\u{11173}','\u{11173}'),('\u{11180}','\u{11181}'),('\u{111b6}','\u{111be}'),('\u{111c9}','\u{111cc}'),('\u{111cf}','\u{111cf}'),('\u{1122f}','\u{11231}'),('\u{11234}','\u{11234}'),('\u{11236}','\u{11237}'),('\u{1123e}','\u{1123e}'),('\u{11241}','\u{11241}'),('\u{112df}','\u{112df}'),('\u{112e3}','\u{112ea}'),('\u{11300}','\u{11301}'),('\u{1133b}','\u{1133c}'),('\u{11340}','\u{11340}'),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('\u{113bb}','\u{113c0}'),('\u{113ce}','\u{113ce}'),('\u{113d0}','\u{113d0}'),('\u{113d2}','\u{113d2}'),('\u{113e1}','\u{113e2}'),('\u{11438}','\u{1143f}'),('\u{11442}','\u{11444}'),('\u{11446}','\u{11446}'),('\u{1145e}','\u{1145e}'),('\u{114b3}','\u{114b8}'),('\u{114ba}','\u{114ba}'),('\u{114bf}','\u{114c0}'),('\u{114c2}','\u{114c3}'),('\u{115b2}','\u{115b5}'),('\u{115bc}','\u{115bd}'),('\u{115bf}','\u{115c0}'),('\u{115dc}','\u{115dd}'),('\u{11633}','\u{1163a}'),('\u{1163d}','\u{1163d}'),('\u{1163f}','\u{11640}'),('\u{116ab}','\u{116ab}'),('\u{116ad}','\u{116ad}'),('\u{116b0}','\u{116b5}'),('\u{116b7}','\u{116b7}'),('\u{1171d}','\u{1171d}'),('\u{1171f}','\u{1171f}'),('\u{11722}','\u{11725}'),('\u{11727}','\u{1172b}'),('\u{1182f}','\u{11837}'),('\u{11839}','\u{1183a}'),('\u{1193b}','\u{1193c}'),('\u{1193e}','\u{1193e}'),('\u{11943}','\u{11943}'),('\u{119d4}','\u{119d7}'),('\u{119da}','\u{119db}'),('\u{119e0}','\u{119e0}'),('\u{11a01}','\u{11a0a}'),('\u{11a33}','\u{11a38}'),('\u{11a3b}','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('\u{11a51}','\u{11a56}'),('\u{11a59}','\u{11a5b}'),('\u{11a8a}','\u{11a96}'),('\u{11a98}','\u{11a99}'),('\u{11c30}','\u{11c36}'),('\u{11c38}','\u{11c3d}'),('\u{11c3f}','\u{11c3f}'),('\u{11c92}','\u{11ca7}'),('\u{11caa}','\u{11cb0}'),('\u{11cb2}','\u{11cb3}'),('\u{11cb5}','\u{11cb6}'),('\u{11d31}','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d45}'),('\u{11d47}','\u{11d47}'),('\u{11d90}','\u{11d91}'),('\u{11d95}','\u{11d95}'),('\u{11d97}','\u{11d97}'),('\u{11ef3}','\u{11ef4}'),('\u{11f00}','\u{11f01}'),('\u{11f36}','\u{11f3a}'),('\u{11f40}','\u{11f40}'),('\u{11f42}','\u{11f42}'),('\u{11f5a}','\u{11f5a}'),('\u{13430}','\u{13440}'),('\u{13447}','\u{13455}'),('\u{1611e}','\u{16129}'),('\u{1612d}','\u{1612f}'),('\u{16af0}','\u{16af4}'),('\u{16b30}','\u{16b36}'),('',''),('',''),('',''),('\u{16f4f}','\u{16f4f}'),('\u{16f8f}',''),('',''),('','\u{16fe4}'),('',''),('',''),('',''),('\u{1bc9d}','\u{1bc9e}'),('\u{1bca0}','\u{1bca3}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d167}','\u{1d169}'),('\u{1d173}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('',''),('\u{1e08f}','\u{1e08f}'),('\u{1e130}',''),('\u{1e2ae}','\u{1e2ae}'),('\u{1e2ec}','\u{1e2ef}'),('','\u{1e4ef}'),('\u{1e5ee}','\u{1e5ef}'),('\u{1e8d0}','\u{1e8d6}'),('\u{1e944}',''),('',''),('\u{e0001}','\u{e0001}'),('\u{e0020}','\u{e007f}'),('\u{e0100}','\u{e01ef}') ];
                pub const CASED:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{345}','\u{345}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const CHANGES_WHEN_CASEFOLDED:&'static [(char,char)] = &[ ('A','Z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{345}','\u{345}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const CHANGES_WHEN_CASEMAPPED:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{345}','\u{345}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const CHANGES_WHEN_LOWERCASED:&'static [(char,char)] = &[ ('A','Z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const CHANGES_WHEN_TITLECASED:&'static [(char,char)] = &[ ('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{345}','\u{345}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const CHANGES_WHEN_UPPERCASED:&'static [(char,char)] = &[ ('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{345}','\u{345}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const DASH:&'static [(char,char)] = &[ ('-','-'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const DEFAULT_IGNORABLE_CODE_POINT:&'static [(char,char)] = &[ ('\u{ad}','\u{ad}'),('\u{34f}','\u{34f}'),('\u{61c}','\u{61c}'),('',''),('\u{17b4}','\u{17b5}'),('\u{180b}','\u{180f}'),('\u{200b}','\u{200f}'),('\u{202a}','\u{202e}'),('\u{2060}','\u{206f}'),('',''),('\u{fe00}','\u{fe0f}'),('\u{feff}','\u{feff}'),('',''),('\u{fff0}','\u{fff8}'),('\u{1bca0}','\u{1bca3}'),('\u{1d173}','\u{1d17a}'),('\u{e0000}','\u{e0fff}') ];
                pub const DEPRECATED:&'static [(char,char)] = &[ ('',''),('',''),('\u{f77}','\u{f77}'),('\u{f79}','\u{f79}'),('',''),('\u{206a}','\u{206f}'),('',''),('\u{e0001}','\u{e0001}') ];
                pub const DIACRITIC:&'static [(char,char)] = &[ ('^','^'),('`','`'),('',''),('',''),('',''),('',''),('','\u{34e}'),('\u{350}','\u{357}'),('\u{35d}','\u{362}'),('',''),('',''),('',''),('\u{483}','\u{487}'),('',''),('\u{591}','\u{5a1}'),('\u{5a3}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c4}'),('\u{64b}','\u{652}'),('\u{657}','\u{658}'),('\u{6df}','\u{6e0}'),('',''),('\u{6ea}','\u{6ec}'),('\u{730}','\u{74a}'),('\u{7a6}','\u{7b0}'),('\u{7eb}',''),('\u{818}','\u{819}'),('\u{898}','\u{89f}'),('','\u{8d2}'),('\u{8e3}','\u{8fe}'),('\u{93c}','\u{93c}'),('\u{94d}','\u{94d}'),('\u{951}','\u{954}'),('',''),('\u{9bc}','\u{9bc}'),('\u{9cd}','\u{9cd}'),('\u{a3c}','\u{a3c}'),('\u{a4d}','\u{a4d}'),('\u{abc}','\u{abc}'),('\u{acd}','\u{acd}'),('\u{afd}','\u{aff}'),('\u{b3c}','\u{b3c}'),('\u{b4d}','\u{b4d}'),('\u{b55}','\u{b55}'),('\u{bcd}','\u{bcd}'),('\u{c3c}','\u{c3c}'),('\u{c4d}','\u{c4d}'),('\u{cbc}','\u{cbc}'),('\u{ccd}','\u{ccd}'),('\u{d3b}','\u{d3c}'),('\u{d4d}','\u{d4d}'),('\u{dca}','\u{dca}'),('\u{e3a}','\u{e3a}'),('\u{e47}','\u{e4c}'),('\u{e4e}','\u{e4e}'),('\u{eba}','\u{eba}'),('\u{ec8}','\u{ecc}'),('\u{f18}','\u{f19}'),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('',''),('\u{f82}','\u{f84}'),('\u{f86}','\u{f87}'),('\u{fc6}','\u{fc6}'),('\u{1037}','\u{1037}'),('\u{1039}','\u{103a}'),('',''),('',''),('','\u{108d}'),('',''),('',''),('\u{135d}','\u{135f}'),('\u{1714}','\u{1715}'),('\u{1734}','\u{1734}'),('\u{17c9}','\u{17d3}'),('\u{17dd}','\u{17dd}'),('\u{1939}','\u{193b}'),('\u{1a60}','\u{1a60}'),('\u{1a75}','\u{1a7c}'),('\u{1a7f}','\u{1a7f}'),('\u{1ab0}','\u{1abe}'),('\u{1ac1}','\u{1acb}'),('\u{1b34}','\u{1b34}'),('\u{1b44}','\u{1b44}'),('\u{1b6b}','\u{1b73}'),('\u{1baa}','\u{1bab}'),('\u{1be6}','\u{1be6}'),('\u{1bf2}','\u{1bf3}'),('\u{1c36}','\u{1c37}'),('',''),('\u{1cd0}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('','\u{1cf9}'),('',''),('\u{1dc4}','\u{1dcf}'),('\u{1df5}','\u{1dff}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2cef}','\u{2cf1}'),('',''),('\u{302a}','\u{302f}'),('\u{3099}',''),('',''),('\u{a66f}','\u{a66f}'),('\u{a67c}','\u{a67d}'),('',''),('',''),('\u{a6f0}','\u{a6f1}'),('',''),('',''),('',''),('\u{a806}','\u{a806}'),('\u{a82c}','\u{a82c}'),('\u{a8c4}','\u{a8c4}'),('\u{a8e0}','\u{a8f1}'),('\u{a92b}',''),('\u{a953}','\u{a953}'),('\u{a9b3}','\u{a9b3}'),('\u{a9c0}','\u{a9c0}'),('\u{a9e5}','\u{a9e5}'),('',''),('\u{aabf}',''),('\u{aaf6}','\u{aaf6}'),('',''),('',''),('','\u{abed}'),('\u{fb1e}','\u{fb1e}'),('\u{fe20}','\u{fe2f}'),('',''),('',''),('',''),('\u{ff9e}','\u{ff9f}'),('',''),('\u{102e0}','\u{102e0}'),('',''),('',''),('',''),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('\u{10ae5}','\u{10ae6}'),('','\u{10d27}'),('',''),('\u{10d69}','\u{10d6d}'),('\u{10efd}','\u{10eff}'),('\u{10f46}','\u{10f50}'),('\u{10f82}','\u{10f85}'),('\u{11046}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{110b9}','\u{110ba}'),('\u{11133}','\u{11134}'),('\u{11173}','\u{11173}'),('\u{111c0}','\u{111c0}'),('\u{111ca}','\u{111cc}'),('\u{11235}','\u{11236}'),('\u{112e9}','\u{112ea}'),('\u{1133b}','\u{1133c}'),('\u{1134d}','\u{1134d}'),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('\u{113ce}','\u{113d0}'),('\u{113d2}',''),('\u{113e1}','\u{113e2}'),('\u{11442}','\u{11442}'),('\u{11446}','\u{11446}'),('\u{114c2}','\u{114c3}'),('\u{115bf}','\u{115c0}'),('\u{1163f}','\u{1163f}'),('\u{116b6}','\u{116b7}'),('\u{1172b}','\u{1172b}'),('\u{11839}','\u{1183a}'),('\u{1193d}','\u{1193e}'),('\u{11943}','\u{11943}'),('\u{119e0}','\u{119e0}'),('\u{11a34}','\u{11a34}'),('\u{11a47}','\u{11a47}'),('\u{11a99}','\u{11a99}'),('\u{11c3f}','\u{11c3f}'),('\u{11d42}','\u{11d42}'),('\u{11d44}','\u{11d45}'),('\u{11d97}','\u{11d97}'),('\u{11f41}','\u{11f42}'),('\u{11f5a}','\u{11f5a}'),('\u{13447}','\u{13455}'),('\u{1612f}','\u{1612f}'),('\u{16af0}','\u{16af4}'),('\u{16b30}','\u{16b36}'),('',''),('\u{16f8f}',''),('\u{16ff0}','\u{16ff1}'),('',''),('',''),('',''),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d167}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('',''),('\u{1e130}','\u{1e136}'),('\u{1e2ae}','\u{1e2ae}'),('\u{1e2ec}','\u{1e2ef}'),('\u{1e5ee}','\u{1e5ef}'),('\u{1e8d0}','\u{1e8d6}'),('\u{1e944}','\u{1e946}'),('\u{1e948}','\u{1e94a}') ];
                pub const EMOJI:&'static [(char,char)] = &[ ('#','#'),('*','*'),('0','9'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const EMOJI_COMPONENT:&'static [(char,char)] = &[ ('#','#'),('*','*'),('0','9'),('\u{200d}','\u{200d}'),('\u{20e3}','\u{20e3}'),('\u{fe0f}','\u{fe0f}'),('',''),('',''),('',''),('\u{e0020}','\u{e007f}') ];
                pub const EMOJI_MODIFIER:&'static [(char,char)] = &[('','')];
                pub const EMOJI_MODIFIER_BASE:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const EMOJI_PRESENTATION:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const EXTENDED_PICTOGRAPHIC:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1f0ff}'),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1f1e5}'),('','\u{1f20f}'),('',''),('',''),('',''),('\u{1f23c}','\u{1f23f}'),('\u{1f249}',''),('',''),('',''),('','\u{1f6ff}'),('',''),('','\u{1f7ff}'),('\u{1f80c}','\u{1f80f}'),('\u{1f848}','\u{1f84f}'),('\u{1f85a}','\u{1f85f}'),('\u{1f888}','\u{1f88f}'),('\u{1f8ae}','\u{1f8ff}'),('',''),('',''),('','\u{1faff}'),('\u{1fc00}','\u{1fffd}') ];
                pub const EXTENDER:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('\u{a71}','\u{a71}'),('\u{afb}','\u{afb}'),('\u{b55}','\u{b55}'),('',''),('',''),('',''),('',''),('',''),('\u{1c36}','\u{1c36}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{10d6a}','\u{10d6a}'),('',''),('\u{11237}','\u{11237}'),('',''),('\u{113d2}',''),('',''),('\u{11a98}','\u{11a98}'),('',''),('',''),('',''),('',''),('\u{1e5ef}','\u{1e5ef}'),('\u{1e944}','\u{1e946}') ];
                pub const GRAPHEME_BASE:&'static [(char,char)] = &[ (' ','~'),('\u{a0}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2000}','\u{200a}'),('',''),('\u{202f}','\u{205f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const GRAPHEME_EXTEND:&'static [(char,char)] = &[ ('\u{300}','\u{36f}'),('\u{483}','\u{489}'),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('\u{610}','\u{61a}'),('\u{64b}','\u{65f}'),('\u{670}','\u{670}'),('\u{6d6}','\u{6dc}'),('\u{6df}','\u{6e4}'),('\u{6e7}','\u{6e8}'),('\u{6ea}','\u{6ed}'),('\u{711}','\u{711}'),('\u{730}','\u{74a}'),('\u{7a6}','\u{7b0}'),('\u{7eb}','\u{7f3}'),('\u{7fd}','\u{7fd}'),('\u{816}','\u{819}'),('\u{81b}','\u{823}'),('\u{825}','\u{827}'),('\u{829}','\u{82d}'),('\u{859}','\u{85b}'),('\u{897}','\u{89f}'),('\u{8ca}','\u{8e1}'),('\u{8e3}','\u{902}'),('\u{93a}','\u{93a}'),('\u{93c}','\u{93c}'),('\u{941}','\u{948}'),('\u{94d}','\u{94d}'),('\u{951}','\u{957}'),('\u{962}','\u{963}'),('\u{981}','\u{981}'),('\u{9bc}','\u{9bc}'),('\u{9be}','\u{9be}'),('\u{9c1}','\u{9c4}'),('\u{9cd}','\u{9cd}'),('\u{9d7}','\u{9d7}'),('\u{9e2}','\u{9e3}'),('\u{9fe}','\u{9fe}'),('\u{a01}','\u{a02}'),('\u{a3c}','\u{a3c}'),('\u{a41}','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('\u{a70}','\u{a71}'),('\u{a75}','\u{a75}'),('\u{a81}','\u{a82}'),('\u{abc}','\u{abc}'),('\u{ac1}','\u{ac5}'),('\u{ac7}','\u{ac8}'),('\u{acd}','\u{acd}'),('\u{ae2}','\u{ae3}'),('\u{afa}','\u{aff}'),('\u{b01}','\u{b01}'),('\u{b3c}','\u{b3c}'),('\u{b3e}','\u{b3f}'),('\u{b41}','\u{b44}'),('\u{b4d}','\u{b4d}'),('\u{b55}','\u{b57}'),('\u{b62}','\u{b63}'),('\u{b82}','\u{b82}'),('\u{bbe}','\u{bbe}'),('\u{bc0}','\u{bc0}'),('\u{bcd}','\u{bcd}'),('\u{bd7}','\u{bd7}'),('\u{c00}','\u{c00}'),('\u{c04}','\u{c04}'),('\u{c3c}','\u{c3c}'),('\u{c3e}','\u{c40}'),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('\u{c62}','\u{c63}'),('\u{c81}','\u{c81}'),('\u{cbc}','\u{cbc}'),('\u{cbf}','\u{cc0}'),('\u{cc2}','\u{cc2}'),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('\u{ce2}','\u{ce3}'),('\u{d00}','\u{d01}'),('\u{d3b}','\u{d3c}'),('\u{d3e}','\u{d3e}'),('\u{d41}','\u{d44}'),('\u{d4d}','\u{d4d}'),('\u{d57}','\u{d57}'),('\u{d62}','\u{d63}'),('\u{d81}','\u{d81}'),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dcf}'),('\u{dd2}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('\u{ddf}','\u{ddf}'),('\u{e31}','\u{e31}'),('\u{e34}','\u{e3a}'),('\u{e47}','\u{e4e}'),('\u{eb1}','\u{eb1}'),('\u{eb4}','\u{ebc}'),('\u{ec8}','\u{ece}'),('\u{f18}','\u{f19}'),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('\u{f71}','\u{f7e}'),('\u{f80}','\u{f84}'),('\u{f86}','\u{f87}'),('\u{f8d}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('\u{102d}','\u{1030}'),('\u{1032}','\u{1037}'),('\u{1039}','\u{103a}'),('\u{103d}','\u{103e}'),('\u{1058}','\u{1059}'),('\u{105e}','\u{1060}'),('\u{1071}','\u{1074}'),('\u{1082}','\u{1082}'),('\u{1085}','\u{1086}'),('\u{108d}','\u{108d}'),('\u{109d}','\u{109d}'),('\u{135d}','\u{135f}'),('\u{1712}','\u{1715}'),('\u{1732}','\u{1734}'),('\u{1752}','\u{1753}'),('\u{1772}','\u{1773}'),('\u{17b4}','\u{17b5}'),('\u{17b7}','\u{17bd}'),('\u{17c6}','\u{17c6}'),('\u{17c9}','\u{17d3}'),('\u{17dd}','\u{17dd}'),('\u{180b}','\u{180d}'),('\u{180f}','\u{180f}'),('\u{1885}','\u{1886}'),('\u{18a9}','\u{18a9}'),('\u{1920}','\u{1922}'),('\u{1927}','\u{1928}'),('\u{1932}','\u{1932}'),('\u{1939}','\u{193b}'),('\u{1a17}','\u{1a18}'),('\u{1a1b}','\u{1a1b}'),('\u{1a56}','\u{1a56}'),('\u{1a58}','\u{1a5e}'),('\u{1a60}','\u{1a60}'),('\u{1a62}','\u{1a62}'),('\u{1a65}','\u{1a6c}'),('\u{1a73}','\u{1a7c}'),('\u{1a7f}','\u{1a7f}'),('\u{1ab0}','\u{1ace}'),('\u{1b00}','\u{1b03}'),('\u{1b34}','\u{1b3d}'),('\u{1b42}','\u{1b44}'),('\u{1b6b}','\u{1b73}'),('\u{1b80}','\u{1b81}'),('\u{1ba2}','\u{1ba5}'),('\u{1ba8}','\u{1bad}'),('\u{1be6}','\u{1be6}'),('\u{1be8}','\u{1be9}'),('\u{1bed}','\u{1bed}'),('\u{1bef}','\u{1bf3}'),('\u{1c2c}','\u{1c33}'),('\u{1c36}','\u{1c37}'),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}','\u{1ce0}'),('\u{1ce2}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('\u{1cf8}','\u{1cf9}'),('\u{1dc0}','\u{1dff}'),('\u{200c}','\u{200c}'),('\u{20d0}','\u{20f0}'),('\u{2cef}','\u{2cf1}'),('\u{2d7f}','\u{2d7f}'),('\u{2de0}','\u{2dff}'),('\u{302a}','\u{302f}'),('\u{3099}','\u{309a}'),('\u{a66f}','\u{a672}'),('\u{a674}','\u{a67d}'),('\u{a69e}','\u{a69f}'),('\u{a6f0}','\u{a6f1}'),('\u{a802}','\u{a802}'),('\u{a806}','\u{a806}'),('\u{a80b}','\u{a80b}'),('\u{a825}','\u{a826}'),('\u{a82c}','\u{a82c}'),('\u{a8c4}','\u{a8c5}'),('\u{a8e0}','\u{a8f1}'),('\u{a8ff}','\u{a8ff}'),('\u{a926}','\u{a92d}'),('\u{a947}','\u{a951}'),('\u{a953}','\u{a953}'),('\u{a980}','\u{a982}'),('\u{a9b3}','\u{a9b3}'),('\u{a9b6}','\u{a9b9}'),('\u{a9bc}','\u{a9bd}'),('\u{a9c0}','\u{a9c0}'),('\u{a9e5}','\u{a9e5}'),('\u{aa29}','\u{aa2e}'),('\u{aa31}','\u{aa32}'),('\u{aa35}','\u{aa36}'),('\u{aa43}','\u{aa43}'),('\u{aa4c}','\u{aa4c}'),('\u{aa7c}','\u{aa7c}'),('\u{aab0}','\u{aab0}'),('\u{aab2}','\u{aab4}'),('\u{aab7}','\u{aab8}'),('\u{aabe}','\u{aabf}'),('\u{aac1}','\u{aac1}'),('\u{aaec}','\u{aaed}'),('\u{aaf6}','\u{aaf6}'),('\u{abe5}','\u{abe5}'),('\u{abe8}','\u{abe8}'),('\u{abed}','\u{abed}'),('\u{fb1e}','\u{fb1e}'),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('\u{ff9e}','\u{ff9f}'),('\u{101fd}','\u{101fd}'),('\u{102e0}','\u{102e0}'),('\u{10376}','\u{1037a}'),('\u{10a01}','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}','\u{10a0f}'),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('\u{10ae5}','\u{10ae6}'),('\u{10d24}','\u{10d27}'),('\u{10d69}','\u{10d6d}'),('\u{10eab}','\u{10eac}'),('\u{10efc}','\u{10eff}'),('\u{10f46}','\u{10f50}'),('\u{10f82}','\u{10f85}'),('\u{11001}','\u{11001}'),('\u{11038}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{11073}','\u{11074}'),('\u{1107f}','\u{11081}'),('\u{110b3}','\u{110b6}'),('\u{110b9}','\u{110ba}'),('\u{110c2}','\u{110c2}'),('\u{11100}','\u{11102}'),('\u{11127}','\u{1112b}'),('\u{1112d}','\u{11134}'),('\u{11173}','\u{11173}'),('\u{11180}','\u{11181}'),('\u{111b6}','\u{111be}'),('\u{111c0}','\u{111c0}'),('\u{111c9}','\u{111cc}'),('\u{111cf}','\u{111cf}'),('\u{1122f}','\u{11231}'),('\u{11234}','\u{11237}'),('\u{1123e}','\u{1123e}'),('\u{11241}','\u{11241}'),('\u{112df}','\u{112df}'),('\u{112e3}','\u{112ea}'),('\u{11300}','\u{11301}'),('\u{1133b}','\u{1133c}'),('\u{1133e}','\u{1133e}'),('\u{11340}','\u{11340}'),('\u{1134d}','\u{1134d}'),('\u{11357}','\u{11357}'),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('\u{113b8}','\u{113b8}'),('\u{113bb}','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}','\u{113c9}'),('\u{113ce}','\u{113d0}'),('\u{113d2}','\u{113d2}'),('\u{113e1}','\u{113e2}'),('\u{11438}','\u{1143f}'),('\u{11442}','\u{11444}'),('\u{11446}','\u{11446}'),('\u{1145e}','\u{1145e}'),('\u{114b0}','\u{114b0}'),('\u{114b3}','\u{114b8}'),('\u{114ba}','\u{114ba}'),('\u{114bd}','\u{114bd}'),('\u{114bf}','\u{114c0}'),('\u{114c2}','\u{114c3}'),('\u{115af}','\u{115af}'),('\u{115b2}','\u{115b5}'),('\u{115bc}','\u{115bd}'),('\u{115bf}','\u{115c0}'),('\u{115dc}','\u{115dd}'),('\u{11633}','\u{1163a}'),('\u{1163d}','\u{1163d}'),('\u{1163f}','\u{11640}'),('\u{116ab}','\u{116ab}'),('\u{116ad}','\u{116ad}'),('\u{116b0}','\u{116b7}'),('\u{1171d}','\u{1171d}'),('\u{1171f}','\u{1171f}'),('\u{11722}','\u{11725}'),('\u{11727}','\u{1172b}'),('\u{1182f}','\u{11837}'),('\u{11839}','\u{1183a}'),('\u{11930}','\u{11930}'),('\u{1193b}','\u{1193e}'),('\u{11943}','\u{11943}'),('\u{119d4}','\u{119d7}'),('\u{119da}','\u{119db}'),('\u{119e0}','\u{119e0}'),('\u{11a01}','\u{11a0a}'),('\u{11a33}','\u{11a38}'),('\u{11a3b}','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('\u{11a51}','\u{11a56}'),('\u{11a59}','\u{11a5b}'),('\u{11a8a}','\u{11a96}'),('\u{11a98}','\u{11a99}'),('\u{11c30}','\u{11c36}'),('\u{11c38}','\u{11c3d}'),('\u{11c3f}','\u{11c3f}'),('\u{11c92}','\u{11ca7}'),('\u{11caa}','\u{11cb0}'),('\u{11cb2}','\u{11cb3}'),('\u{11cb5}','\u{11cb6}'),('\u{11d31}','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d45}'),('\u{11d47}','\u{11d47}'),('\u{11d90}','\u{11d91}'),('\u{11d95}','\u{11d95}'),('\u{11d97}','\u{11d97}'),('\u{11ef3}','\u{11ef4}'),('\u{11f00}','\u{11f01}'),('\u{11f36}','\u{11f3a}'),('\u{11f40}','\u{11f42}'),('\u{11f5a}','\u{11f5a}'),('\u{13440}','\u{13440}'),('\u{13447}','\u{13455}'),('\u{1611e}','\u{16129}'),('\u{1612d}','\u{1612f}'),('\u{16af0}','\u{16af4}'),('\u{16b30}','\u{16b36}'),('\u{16f4f}','\u{16f4f}'),('\u{16f8f}','\u{16f92}'),('\u{16fe4}','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('\u{1bc9d}','\u{1bc9e}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d165}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('\u{1e08f}','\u{1e08f}'),('\u{1e130}','\u{1e136}'),('\u{1e2ae}','\u{1e2ae}'),('\u{1e2ec}','\u{1e2ef}'),('\u{1e4ec}','\u{1e4ef}'),('\u{1e5ee}','\u{1e5ef}'),('\u{1e8d0}','\u{1e8d6}'),('\u{1e944}','\u{1e94a}'),('\u{e0020}','\u{e007f}'),('\u{e0100}','\u{e01ef}') ];
                pub const GRAPHEME_LINK:&'static [(char,char)] = &[ ('\u{94d}','\u{94d}'),('\u{9cd}','\u{9cd}'),('\u{a4d}','\u{a4d}'),('\u{acd}','\u{acd}'),('\u{b4d}','\u{b4d}'),('\u{bcd}','\u{bcd}'),('\u{c4d}','\u{c4d}'),('\u{ccd}','\u{ccd}'),('\u{d3b}','\u{d3c}'),('\u{d4d}','\u{d4d}'),('\u{dca}','\u{dca}'),('\u{e3a}','\u{e3a}'),('\u{eba}','\u{eba}'),('\u{f84}','\u{f84}'),('\u{1039}','\u{103a}'),('\u{1714}','\u{1715}'),('\u{1734}','\u{1734}'),('\u{17d2}','\u{17d2}'),('\u{1a60}','\u{1a60}'),('\u{1b44}','\u{1b44}'),('\u{1baa}','\u{1bab}'),('\u{1bf2}','\u{1bf3}'),('\u{2d7f}','\u{2d7f}'),('\u{a806}','\u{a806}'),('\u{a82c}','\u{a82c}'),('\u{a8c4}','\u{a8c4}'),('\u{a953}','\u{a953}'),('\u{a9c0}','\u{a9c0}'),('\u{aaf6}','\u{aaf6}'),('\u{abed}','\u{abed}'),('\u{10a3f}','\u{10a3f}'),('\u{11046}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{1107f}','\u{1107f}'),('\u{110b9}','\u{110b9}'),('\u{11133}','\u{11134}'),('\u{111c0}','\u{111c0}'),('\u{11235}','\u{11235}'),('\u{112ea}','\u{112ea}'),('\u{1134d}','\u{1134d}'),('\u{113ce}','\u{113d0}'),('\u{11442}','\u{11442}'),('\u{114c2}','\u{114c2}'),('\u{115bf}','\u{115bf}'),('\u{1163f}','\u{1163f}'),('\u{116b6}','\u{116b6}'),('\u{1172b}','\u{1172b}'),('\u{11839}','\u{11839}'),('\u{1193d}','\u{1193e}'),('\u{119e0}','\u{119e0}'),('\u{11a34}','\u{11a34}'),('\u{11a47}','\u{11a47}'),('\u{11a99}','\u{11a99}'),('\u{11c3f}','\u{11c3f}'),('\u{11d44}','\u{11d45}'),('\u{11d97}','\u{11d97}'),('\u{11f41}','\u{11f42}'),('\u{1612f}','\u{1612f}') ];
                pub const HEX_DIGIT:&'static [(char,char)] = &[ ('0','9'),('A','F'),('a','f'),('',''),('',''),('','') ];
                pub const HYPHEN:&'static [(char,char)] = &[ ('-','-'),('\u{ad}','\u{ad}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const IDS_BINARY_OPERATOR:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const IDS_TRINARY_OPERATOR:&'static [(char,char)] = &[('','')];
                pub const IDS_UNARY_OPERATOR:&'static [(char,char)] = &[('','')];
                pub const ID_COMPAT_MATH_CONTINUE:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const ID_COMPAT_MATH_START:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const ID_CONTINUE:&'static [(char,char)] = &[ ('0','9'),('A','Z'),('_','_'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{300}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{483}','\u{487}'),('',''),('',''),('',''),('',''),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('',''),('',''),('\u{610}','\u{61a}'),('',''),('',''),('','\u{6dc}'),('\u{6df}','\u{6e8}'),('\u{6ea}',''),('',''),('','\u{74a}'),('',''),('',''),('',''),('\u{7fd}','\u{7fd}'),('','\u{82d}'),('','\u{85b}'),('',''),('',''),('',''),('\u{897}','\u{8e1}'),('\u{8e3}','\u{963}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{9bc}','\u{9c4}'),('',''),('',''),('\u{9d7}','\u{9d7}'),('',''),('','\u{9e3}'),('',''),('',''),('\u{9fe}','\u{9fe}'),('\u{a01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('',''),('',''),('','\u{a75}'),('\u{a81}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{abc}','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('',''),('','\u{ae3}'),('',''),('','\u{aff}'),('\u{b01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{b3c}','\u{b44}'),('',''),('','\u{b4d}'),('\u{b55}','\u{b57}'),('',''),('','\u{b63}'),('',''),('',''),('\u{b82}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{bbe}',''),('',''),('','\u{bcd}'),('',''),('\u{bd7}','\u{bd7}'),('',''),('\u{c00}',''),('',''),('',''),('',''),('\u{c3c}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('',''),('',''),('','\u{c63}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{cbc}',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('',''),('','\u{ce3}'),('',''),('',''),('\u{d00}',''),('',''),('','\u{d44}'),('',''),('',''),('','\u{d57}'),('','\u{d63}'),('',''),('',''),('\u{d81}',''),('',''),('',''),('',''),('',''),('',''),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('',''),('','\u{e3a}'),('','\u{e4e}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{ec8}','\u{ece}'),('',''),('',''),('',''),('\u{f18}','\u{f19}'),('',''),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('',''),('',''),('\u{f71}','\u{f84}'),('\u{f86}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('',''),('','\u{109d}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{135d}','\u{135f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1715}'),('','\u{1734}'),('','\u{1753}'),('',''),('',''),('\u{1772}','\u{1773}'),('','\u{17d3}'),('',''),('','\u{17dd}'),('',''),('\u{180b}','\u{180d}'),('\u{180f}',''),('',''),('',''),('',''),('',''),('\u{1920}',''),('','\u{193b}'),('',''),('',''),('',''),('',''),('',''),('','\u{1a1b}'),('','\u{1a5e}'),('\u{1a60}','\u{1a7c}'),('\u{1a7f}',''),('',''),('',''),('\u{1ab0}','\u{1abd}'),('\u{1abf}','\u{1ace}'),('\u{1b00}',''),('',''),('\u{1b6b}','\u{1b73}'),('\u{1b80}','\u{1bf3}'),('','\u{1c37}'),('',''),('',''),('',''),('',''),('',''),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{200c}','\u{200d}'),('',''),('',''),('',''),('',''),('',''),('\u{20d0}','\u{20dc}'),('\u{20e1}','\u{20e1}'),('\u{20e5}','\u{20f0}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2d7f}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2de0}','\u{2dff}'),('',''),('','\u{302f}'),('',''),('',''),('',''),('\u{3099}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{a66f}'),('\u{a674}','\u{a67d}'),('','\u{a6f1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a82c}','\u{a82c}'),('',''),('','\u{a8c5}'),('',''),('\u{a8e0}',''),('',''),('','\u{a92d}'),('','\u{a953}'),('',''),('\u{a980}','\u{a9c0}'),('',''),('',''),('','\u{aa36}'),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{aaf6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{abed}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{101fd}','\u{101fd}'),('',''),('',''),('\u{102e0}','\u{102e0}'),('',''),('',''),('','\u{1037a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}',''),('',''),('',''),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('',''),('',''),('',''),('','\u{10ae6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10d27}'),('',''),('',''),('\u{10d69}','\u{10d6d}'),('',''),('',''),('\u{10eab}','\u{10eac}'),('',''),('',''),('\u{10efc}',''),('',''),('','\u{10f50}'),('','\u{10f85}'),('',''),('',''),('','\u{11046}'),('',''),('\u{1107f}','\u{110ba}'),('\u{110c2}','\u{110c2}'),('',''),('',''),('\u{11100}','\u{11134}'),('',''),('',''),('','\u{11173}'),('',''),('\u{11180}',''),('\u{111c9}','\u{111cc}'),('',''),('',''),('',''),('','\u{11237}'),('\u{1123e}','\u{11241}'),('',''),('',''),('',''),('',''),('',''),('','\u{112ea}'),('',''),('\u{11300}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1133b}',''),('',''),('','\u{1134d}'),('',''),('\u{11357}','\u{11357}'),('',''),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('',''),('',''),('',''),('',''),('','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('',''),('\u{113e1}','\u{113e2}'),('',''),('',''),('\u{1145e}',''),('',''),('',''),('',''),('','\u{115b5}'),('','\u{115c0}'),('','\u{115dd}'),('','\u{11640}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1171d}','\u{1172b}'),('',''),('',''),('','\u{1183a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1193b}','\u{11943}'),('',''),('',''),('','\u{119d7}'),('\u{119da}',''),('',''),('','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('','\u{11a99}'),('',''),('',''),('',''),('',''),('',''),('','\u{11c36}'),('\u{11c38}',''),('',''),('',''),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),('',''),('',''),('','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d47}'),('',''),('',''),('',''),('',''),('\u{11d90}','\u{11d91}'),('',''),('',''),('',''),('\u{11f00}',''),('','\u{11f3a}'),('','\u{11f42}'),('','\u{11f5a}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{13440}','\u{13455}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16af0}','\u{16af4}'),('','\u{16b36}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16f4f}',''),('\u{16f8f}',''),('',''),('','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1bc9d}','\u{1bc9e}'),('',''),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d165}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('',''),('',''),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('',''),('\u{1e08f}','\u{1e08f}'),('',''),('\u{1e130}',''),('',''),('',''),('','\u{1e2ae}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1e8d0}','\u{1e8d6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{e0100}','\u{e01ef}') ];
                pub const ID_START:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const IDEOGRAPHIC:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16fe4}','\u{16fe4}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const INCB:&'static [(char,char)] = &[ ('\u{300}','\u{36f}'),('\u{483}','\u{489}'),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('\u{610}','\u{61a}'),('\u{64b}','\u{65f}'),('\u{670}','\u{670}'),('\u{6d6}','\u{6dc}'),('\u{6df}','\u{6e4}'),('\u{6e7}','\u{6e8}'),('\u{6ea}','\u{6ed}'),('\u{711}','\u{711}'),('\u{730}','\u{74a}'),('\u{7a6}','\u{7b0}'),('\u{7eb}','\u{7f3}'),('\u{7fd}','\u{7fd}'),('\u{816}','\u{819}'),('\u{81b}','\u{823}'),('\u{825}','\u{827}'),('\u{829}','\u{82d}'),('\u{859}','\u{85b}'),('\u{897}','\u{89f}'),('\u{8ca}','\u{8e1}'),('\u{8e3}','\u{902}'),('','\u{93a}'),('\u{93c}','\u{93c}'),('\u{941}','\u{948}'),('\u{94d}','\u{94d}'),('\u{951}',''),('\u{962}','\u{963}'),('',''),('\u{981}','\u{981}'),('',''),('',''),('',''),('',''),('\u{9bc}','\u{9bc}'),('\u{9be}','\u{9be}'),('\u{9c1}','\u{9c4}'),('\u{9cd}','\u{9cd}'),('\u{9d7}','\u{9d7}'),('',''),('',''),('\u{9e2}','\u{9e3}'),('',''),('\u{9fe}','\u{9fe}'),('\u{a01}','\u{a02}'),('\u{a3c}','\u{a3c}'),('\u{a41}','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('\u{a70}','\u{a71}'),('\u{a75}','\u{a75}'),('\u{a81}','\u{a82}'),('',''),('',''),('',''),('',''),('\u{abc}','\u{abc}'),('\u{ac1}','\u{ac5}'),('\u{ac7}','\u{ac8}'),('\u{acd}','\u{acd}'),('\u{ae2}','\u{ae3}'),('','\u{aff}'),('\u{b01}','\u{b01}'),('',''),('',''),('',''),('',''),('\u{b3c}','\u{b3c}'),('\u{b3e}','\u{b3f}'),('\u{b41}','\u{b44}'),('\u{b4d}','\u{b4d}'),('\u{b55}','\u{b57}'),('',''),('',''),('\u{b62}','\u{b63}'),('',''),('\u{b82}','\u{b82}'),('\u{bbe}','\u{bbe}'),('\u{bc0}','\u{bc0}'),('\u{bcd}','\u{bcd}'),('\u{bd7}','\u{bd7}'),('\u{c00}','\u{c00}'),('\u{c04}','\u{c04}'),('',''),('',''),('\u{c3c}','\u{c3c}'),('\u{c3e}','\u{c40}'),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('',''),('\u{c62}','\u{c63}'),('\u{c81}','\u{c81}'),('\u{cbc}','\u{cbc}'),('\u{cbf}','\u{cc0}'),('\u{cc2}','\u{cc2}'),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('\u{ce2}','\u{ce3}'),('\u{d00}','\u{d01}'),('','\u{d3c}'),('\u{d3e}','\u{d3e}'),('\u{d41}','\u{d44}'),('\u{d4d}','\u{d4d}'),('\u{d57}','\u{d57}'),('\u{d62}','\u{d63}'),('\u{d81}','\u{d81}'),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dcf}'),('\u{dd2}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('\u{ddf}','\u{ddf}'),('\u{e31}','\u{e31}'),('\u{e34}','\u{e3a}'),('\u{e47}','\u{e4e}'),('\u{eb1}','\u{eb1}'),('\u{eb4}','\u{ebc}'),('\u{ec8}','\u{ece}'),('\u{f18}','\u{f19}'),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('\u{f71}','\u{f7e}'),('\u{f80}','\u{f84}'),('\u{f86}','\u{f87}'),('\u{f8d}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('\u{102d}','\u{1030}'),('\u{1032}','\u{1037}'),('\u{1039}','\u{103a}'),('\u{103d}','\u{103e}'),('\u{1058}','\u{1059}'),('\u{105e}','\u{1060}'),('\u{1071}','\u{1074}'),('\u{1082}','\u{1082}'),('\u{1085}','\u{1086}'),('\u{108d}','\u{108d}'),('\u{109d}','\u{109d}'),('\u{135d}','\u{135f}'),('\u{1712}','\u{1715}'),('\u{1732}','\u{1734}'),('\u{1752}','\u{1753}'),('\u{1772}','\u{1773}'),('\u{17b4}','\u{17b5}'),('\u{17b7}','\u{17bd}'),('\u{17c6}','\u{17c6}'),('\u{17c9}','\u{17d3}'),('\u{17dd}','\u{17dd}'),('\u{180b}','\u{180d}'),('\u{180f}','\u{180f}'),('\u{1885}','\u{1886}'),('\u{18a9}','\u{18a9}'),('\u{1920}','\u{1922}'),('\u{1927}','\u{1928}'),('\u{1932}','\u{1932}'),('\u{1939}','\u{193b}'),('\u{1a17}','\u{1a18}'),('\u{1a1b}','\u{1a1b}'),('\u{1a56}','\u{1a56}'),('\u{1a58}','\u{1a5e}'),('\u{1a60}','\u{1a60}'),('\u{1a62}','\u{1a62}'),('\u{1a65}','\u{1a6c}'),('\u{1a73}','\u{1a7c}'),('\u{1a7f}','\u{1a7f}'),('\u{1ab0}','\u{1ace}'),('\u{1b00}','\u{1b03}'),('\u{1b34}','\u{1b3d}'),('\u{1b42}','\u{1b44}'),('\u{1b6b}','\u{1b73}'),('\u{1b80}','\u{1b81}'),('\u{1ba2}','\u{1ba5}'),('\u{1ba8}','\u{1bad}'),('\u{1be6}','\u{1be6}'),('\u{1be8}','\u{1be9}'),('\u{1bed}','\u{1bed}'),('\u{1bef}','\u{1bf3}'),('\u{1c2c}','\u{1c33}'),('\u{1c36}','\u{1c37}'),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}','\u{1ce0}'),('\u{1ce2}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('\u{1cf8}','\u{1cf9}'),('\u{1dc0}','\u{1dff}'),('\u{200d}','\u{200d}'),('\u{20d0}','\u{20f0}'),('\u{2cef}','\u{2cf1}'),('\u{2d7f}','\u{2d7f}'),('\u{2de0}','\u{2dff}'),('\u{302a}','\u{302f}'),('\u{3099}','\u{309a}'),('\u{a66f}','\u{a672}'),('\u{a674}','\u{a67d}'),('\u{a69e}','\u{a69f}'),('\u{a6f0}','\u{a6f1}'),('\u{a802}','\u{a802}'),('\u{a806}','\u{a806}'),('\u{a80b}','\u{a80b}'),('\u{a825}','\u{a826}'),('\u{a82c}','\u{a82c}'),('\u{a8c4}','\u{a8c5}'),('\u{a8e0}','\u{a8f1}'),('\u{a8ff}','\u{a8ff}'),('\u{a926}','\u{a92d}'),('\u{a947}','\u{a951}'),('\u{a953}','\u{a953}'),('\u{a980}','\u{a982}'),('\u{a9b3}','\u{a9b3}'),('\u{a9b6}','\u{a9b9}'),('\u{a9bc}','\u{a9bd}'),('\u{a9c0}','\u{a9c0}'),('\u{a9e5}','\u{a9e5}'),('\u{aa29}','\u{aa2e}'),('\u{aa31}','\u{aa32}'),('\u{aa35}','\u{aa36}'),('\u{aa43}','\u{aa43}'),('\u{aa4c}','\u{aa4c}'),('\u{aa7c}','\u{aa7c}'),('\u{aab0}','\u{aab0}'),('\u{aab2}','\u{aab4}'),('\u{aab7}','\u{aab8}'),('\u{aabe}','\u{aabf}'),('\u{aac1}','\u{aac1}'),('\u{aaec}','\u{aaed}'),('\u{aaf6}','\u{aaf6}'),('\u{abe5}','\u{abe5}'),('\u{abe8}','\u{abe8}'),('\u{abed}','\u{abed}'),('\u{fb1e}','\u{fb1e}'),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('\u{ff9e}','\u{ff9f}'),('\u{101fd}','\u{101fd}'),('\u{102e0}','\u{102e0}'),('\u{10376}','\u{1037a}'),('\u{10a01}','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}','\u{10a0f}'),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('\u{10ae5}','\u{10ae6}'),('\u{10d24}','\u{10d27}'),('\u{10d69}','\u{10d6d}'),('\u{10eab}','\u{10eac}'),('\u{10efc}','\u{10eff}'),('\u{10f46}','\u{10f50}'),('\u{10f82}','\u{10f85}'),('\u{11001}','\u{11001}'),('\u{11038}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{11073}','\u{11074}'),('\u{1107f}','\u{11081}'),('\u{110b3}','\u{110b6}'),('\u{110b9}','\u{110ba}'),('\u{110c2}','\u{110c2}'),('\u{11100}','\u{11102}'),('\u{11127}','\u{1112b}'),('\u{1112d}','\u{11134}'),('\u{11173}','\u{11173}'),('\u{11180}','\u{11181}'),('\u{111b6}','\u{111be}'),('\u{111c0}','\u{111c0}'),('\u{111c9}','\u{111cc}'),('\u{111cf}','\u{111cf}'),('\u{1122f}','\u{11231}'),('\u{11234}','\u{11237}'),('\u{1123e}','\u{1123e}'),('\u{11241}','\u{11241}'),('\u{112df}','\u{112df}'),('\u{112e3}','\u{112ea}'),('\u{11300}','\u{11301}'),('\u{1133b}','\u{1133c}'),('\u{1133e}','\u{1133e}'),('\u{11340}','\u{11340}'),('\u{1134d}','\u{1134d}'),('\u{11357}','\u{11357}'),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('\u{113b8}','\u{113b8}'),('\u{113bb}','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}','\u{113c9}'),('\u{113ce}','\u{113d0}'),('\u{113d2}','\u{113d2}'),('\u{113e1}','\u{113e2}'),('\u{11438}','\u{1143f}'),('\u{11442}','\u{11444}'),('\u{11446}','\u{11446}'),('\u{1145e}','\u{1145e}'),('\u{114b0}','\u{114b0}'),('\u{114b3}','\u{114b8}'),('\u{114ba}','\u{114ba}'),('\u{114bd}','\u{114bd}'),('\u{114bf}','\u{114c0}'),('\u{114c2}','\u{114c3}'),('\u{115af}','\u{115af}'),('\u{115b2}','\u{115b5}'),('\u{115bc}','\u{115bd}'),('\u{115bf}','\u{115c0}'),('\u{115dc}','\u{115dd}'),('\u{11633}','\u{1163a}'),('\u{1163d}','\u{1163d}'),('\u{1163f}','\u{11640}'),('\u{116ab}','\u{116ab}'),('\u{116ad}','\u{116ad}'),('\u{116b0}','\u{116b7}'),('\u{1171d}','\u{1171d}'),('\u{1171f}','\u{1171f}'),('\u{11722}','\u{11725}'),('\u{11727}','\u{1172b}'),('\u{1182f}','\u{11837}'),('\u{11839}','\u{1183a}'),('\u{11930}','\u{11930}'),('\u{1193b}','\u{1193e}'),('\u{11943}','\u{11943}'),('\u{119d4}','\u{119d7}'),('\u{119da}','\u{119db}'),('\u{119e0}','\u{119e0}'),('\u{11a01}','\u{11a0a}'),('\u{11a33}','\u{11a38}'),('\u{11a3b}','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('\u{11a51}','\u{11a56}'),('\u{11a59}','\u{11a5b}'),('\u{11a8a}','\u{11a96}'),('\u{11a98}','\u{11a99}'),('\u{11c30}','\u{11c36}'),('\u{11c38}','\u{11c3d}'),('\u{11c3f}','\u{11c3f}'),('\u{11c92}','\u{11ca7}'),('\u{11caa}','\u{11cb0}'),('\u{11cb2}','\u{11cb3}'),('\u{11cb5}','\u{11cb6}'),('\u{11d31}','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d45}'),('\u{11d47}','\u{11d47}'),('\u{11d90}','\u{11d91}'),('\u{11d95}','\u{11d95}'),('\u{11d97}','\u{11d97}'),('\u{11ef3}','\u{11ef4}'),('\u{11f00}','\u{11f01}'),('\u{11f36}','\u{11f3a}'),('\u{11f40}','\u{11f42}'),('\u{11f5a}','\u{11f5a}'),('\u{13440}','\u{13440}'),('\u{13447}','\u{13455}'),('\u{1611e}','\u{16129}'),('\u{1612d}','\u{1612f}'),('\u{16af0}','\u{16af4}'),('\u{16b30}','\u{16b36}'),('\u{16f4f}','\u{16f4f}'),('\u{16f8f}','\u{16f92}'),('\u{16fe4}','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('\u{1bc9d}','\u{1bc9e}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d165}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('\u{1e08f}','\u{1e08f}'),('\u{1e130}','\u{1e136}'),('\u{1e2ae}','\u{1e2ae}'),('\u{1e2ec}','\u{1e2ef}'),('\u{1e4ec}','\u{1e4ef}'),('\u{1e5ee}','\u{1e5ef}'),('\u{1e8d0}','\u{1e8d6}'),('\u{1e944}','\u{1e94a}'),('',''),('\u{e0020}','\u{e007f}'),('\u{e0100}','\u{e01ef}') ];
                pub const JOIN_CONTROL:&'static [(char,char)] = &[('\u{200c}','\u{200d}')];
                pub const LOGICAL_ORDER_EXCEPTION:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const LOWERCASE:&'static [(char,char)] = &[ ('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{345}','\u{345}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const MATH:&'static [(char,char)] = &[ ('+','+'),('<','>'),('^','^'),('|','|'),('~','~'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2061}','\u{2064}'),('',''),('',''),('\u{20d0}','\u{20dc}'),('\u{20e1}','\u{20e1}'),('\u{20e5}','\u{20e6}'),('\u{20eb}','\u{20ef}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const MODIFIER_COMBINING_MARK:&'static [(char,char)] = &[ ('\u{654}','\u{655}'),('\u{658}','\u{658}'),('\u{6dc}','\u{6dc}'),('\u{6e3}','\u{6e3}'),('\u{6e7}','\u{6e8}'),('\u{8ca}','\u{8cb}'),('\u{8cd}','\u{8cf}'),('\u{8d3}','\u{8d3}'),('\u{8f3}','\u{8f3}') ];
                pub const NONCHARACTER_CODE_POINT:&'static [(char,char)] = &[ ('\u{fdd0}','\u{fdef}'),('\u{fffe}','\u{ffff}'),('\u{1fffe}','\u{1ffff}'),('\u{2fffe}','\u{2ffff}'),('\u{3fffe}','\u{3ffff}'),('\u{4fffe}','\u{4ffff}'),('\u{5fffe}','\u{5ffff}'),('\u{6fffe}','\u{6ffff}'),('\u{7fffe}','\u{7ffff}'),('\u{8fffe}','\u{8ffff}'),('\u{9fffe}','\u{9ffff}'),('\u{afffe}','\u{affff}'),('\u{bfffe}','\u{bffff}'),('\u{cfffe}','\u{cffff}'),('\u{dfffe}','\u{dffff}'),('\u{efffe}','\u{effff}'),('\u{ffffe}','\u{fffff}'),('\u{10fffe}','\u{10ffff}') ];
                pub const OTHER_ALPHABETIC:&'static [(char,char)] = &[ ('\u{345}','\u{345}'),('\u{363}','\u{36f}'),('\u{5b0}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('\u{610}','\u{61a}'),('\u{64b}','\u{657}'),('\u{659}','\u{65f}'),('\u{670}','\u{670}'),('\u{6d6}','\u{6dc}'),('\u{6e1}','\u{6e4}'),('\u{6e7}','\u{6e8}'),('\u{6ed}','\u{6ed}'),('\u{711}','\u{711}'),('\u{730}','\u{73f}'),('\u{7a6}','\u{7b0}'),('\u{816}','\u{817}'),('\u{81b}','\u{823}'),('\u{825}','\u{827}'),('\u{829}','\u{82c}'),('\u{897}','\u{897}'),('\u{8d4}','\u{8df}'),('\u{8e3}','\u{8e9}'),('\u{8f0}',''),('\u{93a}',''),('',''),('',''),('\u{955}','\u{957}'),('\u{962}','\u{963}'),('\u{981}',''),('\u{9be}','\u{9c4}'),('',''),('',''),('\u{9d7}','\u{9d7}'),('\u{9e2}','\u{9e3}'),('\u{a01}',''),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4c}'),('\u{a51}','\u{a51}'),('\u{a70}','\u{a71}'),('\u{a75}','\u{a75}'),('\u{a81}',''),('','\u{ac5}'),('\u{ac7}',''),('',''),('\u{ae2}','\u{ae3}'),('\u{afa}','\u{afc}'),('\u{b01}',''),('\u{b3e}','\u{b44}'),('',''),('',''),('\u{b56}','\u{b57}'),('\u{b62}','\u{b63}'),('\u{b82}','\u{b82}'),('\u{bbe}',''),('',''),('',''),('\u{bd7}','\u{bd7}'),('\u{c00}','\u{c04}'),('\u{c3e}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4c}'),('\u{c55}','\u{c56}'),('\u{c62}','\u{c63}'),('\u{c81}',''),('',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccc}'),('\u{cd5}','\u{cd6}'),('\u{ce2}','\u{ce3}'),('',''),('\u{d00}',''),('\u{d3e}','\u{d44}'),('',''),('',''),('\u{d57}','\u{d57}'),('\u{d62}','\u{d63}'),('\u{d81}',''),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('\u{e31}','\u{e31}'),('\u{e34}','\u{e3a}'),('\u{e4d}','\u{e4d}'),('\u{eb1}','\u{eb1}'),('\u{eb4}','\u{eb9}'),('\u{ebb}','\u{ebc}'),('\u{ecd}','\u{ecd}'),('\u{f71}','\u{f83}'),('\u{f8d}','\u{f97}'),('\u{f99}','\u{fbc}'),('','\u{1036}'),('',''),('','\u{103e}'),('','\u{1059}'),('\u{105e}','\u{1060}'),('',''),('',''),('\u{1071}','\u{1074}'),('\u{1082}','\u{108d}'),('',''),('','\u{109d}'),('\u{1712}','\u{1713}'),('\u{1732}','\u{1733}'),('\u{1752}','\u{1753}'),('\u{1772}','\u{1773}'),('',''),('\u{1885}','\u{1886}'),('\u{18a9}','\u{18a9}'),('\u{1920}',''),('',''),('\u{1a17}','\u{1a1b}'),('','\u{1a5e}'),('','\u{1a74}'),('\u{1abf}','\u{1ac0}'),('\u{1acc}','\u{1ace}'),('\u{1b00}',''),('\u{1b35}','\u{1b43}'),('\u{1b80}',''),('','\u{1ba9}'),('\u{1bac}','\u{1bad}'),('','\u{1bf1}'),('','\u{1c36}'),('\u{1dd3}','\u{1df4}'),('',''),('\u{2de0}','\u{2dff}'),('\u{a674}','\u{a67b}'),('\u{a69e}','\u{a69f}'),('\u{a802}','\u{a802}'),('\u{a80b}','\u{a80b}'),('',''),('',''),('',''),('\u{a8c5}','\u{a8c5}'),('\u{a8ff}','\u{a8ff}'),('\u{a926}','\u{a92a}'),('\u{a947}',''),('\u{a980}',''),('',''),('\u{a9e5}','\u{a9e5}'),('\u{aa29}','\u{aa36}'),('\u{aa43}','\u{aa43}'),('\u{aa4c}',''),('',''),('\u{aab0}','\u{aab0}'),('\u{aab2}','\u{aab4}'),('\u{aab7}','\u{aab8}'),('\u{aabe}','\u{aabe}'),('',''),('',''),('',''),('\u{fb1e}','\u{fb1e}'),('\u{10376}','\u{1037a}'),('\u{10a01}','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}','\u{10a0f}'),('\u{10d24}','\u{10d27}'),('\u{10d69}','\u{10d69}'),('\u{10eab}','\u{10eac}'),('\u{10efc}','\u{10efc}'),('',''),('\u{11038}','\u{11045}'),('\u{11073}','\u{11074}'),('\u{11080}',''),('',''),('\u{110c2}','\u{110c2}'),('\u{11100}','\u{11102}'),('\u{11127}','\u{11132}'),('',''),('\u{11180}',''),('',''),('','\u{111cf}'),('','\u{11234}'),('\u{11237}','\u{11237}'),('\u{1123e}','\u{1123e}'),('\u{11241}','\u{11241}'),('\u{112df}','\u{112e8}'),('\u{11300}',''),('\u{1133e}',''),('',''),('',''),('\u{11357}','\u{11357}'),('',''),('\u{113b8}','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('',''),('',''),('\u{11443}',''),('\u{114b0}',''),('\u{115af}','\u{115b5}'),('',''),('\u{115dc}','\u{115dd}'),('',''),('\u{11640}','\u{11640}'),('\u{116ab}','\u{116b5}'),('\u{1171d}','\u{1172a}'),('',''),('\u{11930}',''),('',''),('\u{1193b}','\u{1193c}'),('',''),('',''),('','\u{119d7}'),('\u{119da}',''),('',''),('\u{11a01}','\u{11a0a}'),('\u{11a35}',''),('\u{11a3b}','\u{11a3e}'),('\u{11a51}','\u{11a5b}'),('\u{11a8a}',''),('','\u{11c36}'),('\u{11c38}',''),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),('\u{11d31}','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d41}'),('\u{11d43}','\u{11d43}'),('\u{11d47}','\u{11d47}'),('',''),('\u{11d90}','\u{11d91}'),('',''),('\u{11ef3}',''),('\u{11f00}','\u{11f01}'),('',''),('','\u{11f3a}'),('','\u{11f40}'),('\u{1611e}','\u{1612e}'),('\u{16f4f}','\u{16f4f}'),('',''),('\u{16f8f}','\u{16f92}'),('\u{16ff0}','\u{16ff1}'),('\u{1bc9e}','\u{1bc9e}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('\u{1e08f}','\u{1e08f}'),('\u{1e947}','\u{1e947}'),('',''),('',''),('','') ];
                pub const OTHER_DEFAULT_IGNORABLE_CODE_POINT:&'static [(char,char)] = &[ ('\u{34f}','\u{34f}'),('',''),('\u{17b4}','\u{17b5}'),('\u{2065}','\u{2065}'),('',''),('',''),('\u{fff0}','\u{fff8}'),('\u{e0000}','\u{e0000}'),('\u{e0002}','\u{e001f}'),('\u{e0080}','\u{e00ff}'),('\u{e01f0}','\u{e0fff}') ];
                pub const OTHER_GRAPHEME_EXTEND:&'static [(char,char)] = &[ ('\u{9be}','\u{9be}'),('\u{9d7}','\u{9d7}'),('\u{b3e}','\u{b3e}'),('\u{b57}','\u{b57}'),('\u{bbe}','\u{bbe}'),('\u{bd7}','\u{bd7}'),('\u{cc0}','\u{cc0}'),('\u{cc2}','\u{cc2}'),('\u{cc7}','\u{cc8}'),('\u{cca}','\u{ccb}'),('\u{cd5}','\u{cd6}'),('\u{d3e}','\u{d3e}'),('\u{d57}','\u{d57}'),('\u{dcf}','\u{dcf}'),('\u{ddf}','\u{ddf}'),('\u{1715}','\u{1715}'),('\u{1734}','\u{1734}'),('\u{1b35}','\u{1b35}'),('\u{1b3b}','\u{1b3b}'),('\u{1b3d}','\u{1b3d}'),('\u{1b43}','\u{1b44}'),('\u{1baa}','\u{1baa}'),('\u{1bf2}','\u{1bf3}'),('\u{200c}','\u{200c}'),('\u{302e}','\u{302f}'),('\u{a953}','\u{a953}'),('\u{a9c0}','\u{a9c0}'),('\u{ff9e}','\u{ff9f}'),('\u{111c0}','\u{111c0}'),('\u{11235}','\u{11235}'),('\u{1133e}','\u{1133e}'),('\u{1134d}','\u{1134d}'),('\u{11357}','\u{11357}'),('\u{113b8}','\u{113b8}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}','\u{113c9}'),('\u{113cf}','\u{113cf}'),('\u{114b0}','\u{114b0}'),('\u{114bd}','\u{114bd}'),('\u{115af}','\u{115af}'),('\u{116b6}','\u{116b6}'),('\u{11930}','\u{11930}'),('\u{1193d}','\u{1193d}'),('\u{11f41}','\u{11f41}'),('\u{16ff0}','\u{16ff1}'),('\u{1d165}','\u{1d166}'),('\u{1d16d}','\u{1d172}'),('\u{e0020}','\u{e007f}') ];
                pub const OTHER_ID_CONTINUE:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('\u{200c}','\u{200d}'),('',''),('','') ];
                pub const OTHER_ID_START:&'static [(char,char)] = &[('\u{1885}','\u{1886}'),('',''),('',''),('','')];
                pub const OTHER_LOWERCASE:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('\u{345}','\u{345}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const OTHER_MATH:&'static [(char,char)] = &[ ('^','^'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2061}','\u{2064}'),('',''),('',''),('\u{20d0}','\u{20dc}'),('\u{20e1}','\u{20e1}'),('\u{20e5}','\u{20e6}'),('\u{20eb}','\u{20ef}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const OTHER_UPPERCASE:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('','')];
                pub const PATTERN_SYNTAX:&'static [(char,char)] = &[ ('!','/'),(':','@'),('[','^'),('`','`'),('{','~'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{245f}'),('',''),('',''),('','\u{2e7f}'),('',''),('',''),('',''),('',''),('','') ];
                pub const PATTERN_WHITE_SPACE:&'static [(char,char)] = &[ ('\t','\r'),(' ',' '),('\u{85}','\u{85}'),('\u{200e}','\u{200f}'),('\u{2028}','\u{2029}') ];
                pub const PREPENDED_CONCATENATION_MARK:&'static [(char,char)] = &[ ('\u{600}','\u{605}'),('\u{6dd}','\u{6dd}'),('\u{70f}','\u{70f}'),('\u{890}','\u{891}'),('\u{8e2}','\u{8e2}'),('\u{110bd}','\u{110bd}'),('\u{110cd}','\u{110cd}') ];
                pub const QUOTATION_MARK:&'static [(char,char)] = &[ ('"','"'),('\'','\''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const RADICAL:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const REGIONAL_INDICATOR:&'static [(char,char)] = &[('','')];
                pub const SENTENCE_TERMINAL:&'static [(char,char)] = &[ ('!','!'),('.','.'),('?','?'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const SOFT_DOTTED:&'static [(char,char)] = &[ ('i','j'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const TERMINAL_PUNCTUATION:&'static [(char,char)] = &[ ('!','!'),(',',','),('.','.'),(':',';'),('?','?'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const UNIFIED_IDEOGRAPH:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const UPPERCASE:&'static [(char,char)] = &[ ('A','Z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const VARIATION_SELECTOR:&'static [(char,char)] = &[ ('\u{180b}','\u{180d}'),('\u{180f}','\u{180f}'),('\u{fe00}','\u{fe0f}'),('\u{e0100}','\u{e01ef}') ];
                pub const WHITE_SPACE:&'static [(char,char)] = &[ ('\t','\r'),(' ',' '),('\u{85}','\u{85}'),('\u{a0}','\u{a0}'),('\u{1680}','\u{1680}'),('\u{2000}','\u{200a}'),('\u{2028}','\u{2029}'),('\u{202f}','\u{202f}'),('\u{205f}','\u{205f}'),('\u{3000}','\u{3000}') ];
                pub const XID_CONTINUE:&'static [(char,char)] = &[ ('0','9'),('A','Z'),('_','_'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{300}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{483}','\u{487}'),('',''),('',''),('',''),('',''),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('',''),('',''),('\u{610}','\u{61a}'),('',''),('',''),('','\u{6dc}'),('\u{6df}','\u{6e8}'),('\u{6ea}',''),('',''),('','\u{74a}'),('',''),('',''),('',''),('\u{7fd}','\u{7fd}'),('','\u{82d}'),('','\u{85b}'),('',''),('',''),('',''),('\u{897}','\u{8e1}'),('\u{8e3}','\u{963}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{9bc}','\u{9c4}'),('',''),('',''),('\u{9d7}','\u{9d7}'),('',''),('','\u{9e3}'),('',''),('',''),('\u{9fe}','\u{9fe}'),('\u{a01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('',''),('',''),('','\u{a75}'),('\u{a81}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{abc}','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('',''),('','\u{ae3}'),('',''),('','\u{aff}'),('\u{b01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{b3c}','\u{b44}'),('',''),('','\u{b4d}'),('\u{b55}','\u{b57}'),('',''),('','\u{b63}'),('',''),('',''),('\u{b82}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{bbe}',''),('',''),('','\u{bcd}'),('',''),('\u{bd7}','\u{bd7}'),('',''),('\u{c00}',''),('',''),('',''),('',''),('\u{c3c}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('',''),('',''),('','\u{c63}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{cbc}',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('',''),('','\u{ce3}'),('',''),('',''),('\u{d00}',''),('',''),('','\u{d44}'),('',''),('',''),('','\u{d57}'),('','\u{d63}'),('',''),('',''),('\u{d81}',''),('',''),('',''),('',''),('',''),('',''),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('',''),('','\u{e3a}'),('','\u{e4e}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{ec8}','\u{ece}'),('',''),('',''),('',''),('\u{f18}','\u{f19}'),('',''),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('',''),('',''),('\u{f71}','\u{f84}'),('\u{f86}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('',''),('','\u{109d}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{135d}','\u{135f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1715}'),('','\u{1734}'),('','\u{1753}'),('',''),('',''),('\u{1772}','\u{1773}'),('','\u{17d3}'),('',''),('','\u{17dd}'),('',''),('\u{180b}','\u{180d}'),('\u{180f}',''),('',''),('',''),('',''),('',''),('\u{1920}',''),('','\u{193b}'),('',''),('',''),('',''),('',''),('',''),('','\u{1a1b}'),('','\u{1a5e}'),('\u{1a60}','\u{1a7c}'),('\u{1a7f}',''),('',''),('',''),('\u{1ab0}','\u{1abd}'),('\u{1abf}','\u{1ace}'),('\u{1b00}',''),('',''),('\u{1b6b}','\u{1b73}'),('\u{1b80}','\u{1bf3}'),('','\u{1c37}'),('',''),('',''),('',''),('',''),('',''),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{200c}','\u{200d}'),('',''),('',''),('',''),('',''),('',''),('\u{20d0}','\u{20dc}'),('\u{20e1}','\u{20e1}'),('\u{20e5}','\u{20f0}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2d7f}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2de0}','\u{2dff}'),('',''),('','\u{302f}'),('',''),('',''),('',''),('\u{3099}','\u{309a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{a66f}'),('\u{a674}','\u{a67d}'),('','\u{a6f1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a82c}','\u{a82c}'),('',''),('','\u{a8c5}'),('',''),('\u{a8e0}',''),('',''),('','\u{a92d}'),('','\u{a953}'),('',''),('\u{a980}','\u{a9c0}'),('',''),('',''),('','\u{aa36}'),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{aaf6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{abed}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{101fd}','\u{101fd}'),('',''),('',''),('\u{102e0}','\u{102e0}'),('',''),('',''),('','\u{1037a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}',''),('',''),('',''),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('',''),('',''),('',''),('','\u{10ae6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{10d27}'),('',''),('',''),('\u{10d69}','\u{10d6d}'),('',''),('',''),('\u{10eab}','\u{10eac}'),('',''),('',''),('\u{10efc}',''),('',''),('','\u{10f50}'),('','\u{10f85}'),('',''),('',''),('','\u{11046}'),('',''),('\u{1107f}','\u{110ba}'),('\u{110c2}','\u{110c2}'),('',''),('',''),('\u{11100}','\u{11134}'),('',''),('',''),('','\u{11173}'),('',''),('\u{11180}',''),('\u{111c9}','\u{111cc}'),('',''),('',''),('',''),('','\u{11237}'),('\u{1123e}','\u{11241}'),('',''),('',''),('',''),('',''),('',''),('','\u{112ea}'),('',''),('\u{11300}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1133b}',''),('',''),('','\u{1134d}'),('',''),('\u{11357}','\u{11357}'),('',''),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('',''),('',''),('',''),('',''),('','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('',''),('\u{113e1}','\u{113e2}'),('',''),('',''),('\u{1145e}',''),('',''),('',''),('',''),('','\u{115b5}'),('','\u{115c0}'),('','\u{115dd}'),('','\u{11640}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1171d}','\u{1172b}'),('',''),('',''),('','\u{1183a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1193b}','\u{11943}'),('',''),('',''),('','\u{119d7}'),('\u{119da}',''),('',''),('','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('','\u{11a99}'),('',''),('',''),('',''),('',''),('',''),('','\u{11c36}'),('\u{11c38}',''),('',''),('',''),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),('',''),('',''),('','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d47}'),('',''),('',''),('',''),('',''),('\u{11d90}','\u{11d91}'),('',''),('',''),('',''),('\u{11f00}',''),('','\u{11f3a}'),('','\u{11f42}'),('','\u{11f5a}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{13440}','\u{13455}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16af0}','\u{16af4}'),('','\u{16b36}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16f4f}',''),('\u{16f8f}',''),('',''),('','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1bc9d}','\u{1bc9e}'),('',''),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d165}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('',''),('',''),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('',''),('\u{1e08f}','\u{1e08f}'),('',''),('\u{1e130}',''),('',''),('',''),('','\u{1e2ae}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1e8d0}','\u{1e8d6}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{e0100}','\u{e01ef}') ];
                pub const XID_START:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            }

            pub mod names
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                pub const PROPERTY_NAMES:&'static [(&'static str, &'static str)] = &[ ("age","Age"),("ahex","ASCII_Hex_Digit"),("alpha","Alphabetic"),("alphabetic","Alphabetic"),("asciihexdigit","ASCII_Hex_Digit"),("bc","Bidi_Class"),("bidic","Bidi_Control"),("bidiclass","Bidi_Class"),("bidicontrol","Bidi_Control"),("bidim","Bidi_Mirrored"),("bidimirrored","Bidi_Mirrored"),("bidimirroringglyph","Bidi_Mirroring_Glyph"),("bidipairedbracket","Bidi_Paired_Bracket"),("bidipairedbrackettype","Bidi_Paired_Bracket_Type"),("blk","Block"),("block","Block"),("bmg","Bidi_Mirroring_Glyph"),("bpb","Bidi_Paired_Bracket"),("bpt","Bidi_Paired_Bracket_Type"),("canonicalcombiningclass","Canonical_Combining_Class"),("cased","Cased"),("casefolding","Case_Folding"),("caseignorable","Case_Ignorable"),("ccc","Canonical_Combining_Class"),("ce","Composition_Exclusion"),("cf","Case_Folding"),("changeswhencasefolded","Changes_When_Casefolded"),("changeswhencasemapped","Changes_When_Casemapped"),("changeswhenlowercased","Changes_When_Lowercased"),("changeswhennfkccasefolded","Changes_When_NFKC_Casefolded"),("changeswhentitlecased","Changes_When_Titlecased"),("changeswhenuppercased","Changes_When_Uppercased"),("ci","Case_Ignorable"),("cjkaccountingnumeric","kAccountingNumeric"),("cjkcompatibilityvariant","kCompatibilityVariant"),("cjkiicore","kIICore"),("cjkirggsource","kIRG_GSource"),("cjkirghsource","kIRG_HSource"),("cjkirgjsource","kIRG_JSource"),("cjkirgkpsource","kIRG_KPSource"),("cjkirgksource","kIRG_KSource"),("cjkirgmsource","kIRG_MSource"),("cjkirgssource","kIRG_SSource"),("cjkirgtsource","kIRG_TSource"),("cjkirguksource","kIRG_UKSource"),("cjkirgusource","kIRG_USource"),("cjkirgvsource","kIRG_VSource"),("cjkothernumeric","kOtherNumeric"),("cjkprimarynumeric","kPrimaryNumeric"),("cjkrsunicode","kRSUnicode"),("compex","Full_Composition_Exclusion"),("compositionexclusion","Composition_Exclusion"),("cwcf","Changes_When_Casefolded"),("cwcm","Changes_When_Casemapped"),("cwkcf","Changes_When_NFKC_Casefolded"),("cwl","Changes_When_Lowercased"),("cwt","Changes_When_Titlecased"),("cwu","Changes_When_Uppercased"),("dash","Dash"),("decompositionmapping","Decomposition_Mapping"),("decompositiontype","Decomposition_Type"),("defaultignorablecodepoint","Default_Ignorable_Code_Point"),("dep","Deprecated"),("deprecated","Deprecated"),("di","Default_Ignorable_Code_Point"),("dia","Diacritic"),("diacritic","Diacritic"),("dm","Decomposition_Mapping"),("dt","Decomposition_Type"),("ea","East_Asian_Width"),("eastasianwidth","East_Asian_Width"),("ebase","Emoji_Modifier_Base"),("ecomp","Emoji_Component"),("emod","Emoji_Modifier"),("emoji","Emoji"),("emojicomponent","Emoji_Component"),("emojimodifier","Emoji_Modifier"),("emojimodifierbase","Emoji_Modifier_Base"),("emojipresentation","Emoji_Presentation"),("epres","Emoji_Presentation"),("equideo","Equivalent_Unified_Ideograph"),("equivalentunifiedideograph","Equivalent_Unified_Ideograph"),("expandsonnfc","Expands_On_NFC"),("expandsonnfd","Expands_On_NFD"),("expandsonnfkc","Expands_On_NFKC"),("expandsonnfkd","Expands_On_NFKD"),("ext","Extender"),("extendedpictographic","Extended_Pictographic"),("extender","Extender"),("extpict","Extended_Pictographic"),("fcnfkc","FC_NFKC_Closure"),("fcnfkcclosure","FC_NFKC_Closure"),("fullcompositionexclusion","Full_Composition_Exclusion"),("gc","General_Category"),("gcb","Grapheme_Cluster_Break"),("generalcategory","General_Category"),("graphemebase","Grapheme_Base"),("graphemeclusterbreak","Grapheme_Cluster_Break"),("graphemeextend","Grapheme_Extend"),("graphemelink","Grapheme_Link"),("grbase","Grapheme_Base"),("grext","Grapheme_Extend"),("grlink","Grapheme_Link"),("hangulsyllabletype","Hangul_Syllable_Type"),("hex","Hex_Digit"),("hexdigit","Hex_Digit"),("hst","Hangul_Syllable_Type"),("hyphen","Hyphen"),("idc","ID_Continue"),("idcompatmathcontinue","ID_Compat_Math_Continue"),("idcompatmathstart","ID_Compat_Math_Start"),("idcontinue","ID_Continue"),("ideo","Ideographic"),("ideographic","Ideographic"),("ids","ID_Start"),("idsb","IDS_Binary_Operator"),("idsbinaryoperator","IDS_Binary_Operator"),("idst","IDS_Trinary_Operator"),("idstart","ID_Start"),("idstrinaryoperator","IDS_Trinary_Operator"),("idsu","IDS_Unary_Operator"),("idsunaryoperator","IDS_Unary_Operator"),("incb","Indic_Conjunct_Break"),("indicconjunctbreak","Indic_Conjunct_Break"),("indicpositionalcategory","Indic_Positional_Category"),("indicsyllabiccategory","Indic_Syllabic_Category"),("inpc","Indic_Positional_Category"),("insc","Indic_Syllabic_Category"),("isc","ISO_Comment"),("jamoshortname","Jamo_Short_Name"),("jg","Joining_Group"),("joinc","Join_Control"),("joincontrol","Join_Control"),("joininggroup","Joining_Group"),("joiningtype","Joining_Type"),("jsn","Jamo_Short_Name"),("jt","Joining_Type"),("kaccountingnumeric","kAccountingNumeric"),("kcompatibilityvariant","kCompatibilityVariant"),("kehcat","kEH_Cat"),("kehdesc","kEH_Desc"),("kehhg","kEH_HG"),("kehifao","kEH_IFAO"),("kehjsesh","kEH_JSesh"),("kehnomirror","kEH_NoMirror"),("kehnorotate","kEH_NoRotate"),("kiicore","kIICore"),("kirggsource","kIRG_GSource"),("kirghsource","kIRG_HSource"),("kirgjsource","kIRG_JSource"),("kirgkpsource","kIRG_KPSource"),("kirgksource","kIRG_KSource"),("kirgmsource","kIRG_MSource"),("kirgssource","kIRG_SSource"),("kirgtsource","kIRG_TSource"),("kirguksource","kIRG_UKSource"),("kirgusource","kIRG_USource"),("kirgvsource","kIRG_VSource"),("kothernumeric","kOtherNumeric"),("kprimarynumeric","kPrimaryNumeric"),("krsunicode","kRSUnicode"),("lb","Line_Break"),("lc","Lowercase_Mapping"),("linebreak","Line_Break"),("loe","Logical_Order_Exception"),("logicalorderexception","Logical_Order_Exception"),("lower","Lowercase"),("lowercase","Lowercase"),("lowercasemapping","Lowercase_Mapping"),("math","Math"),("mcm","Modifier_Combining_Mark"),("modifiercombiningmark","Modifier_Combining_Mark"),("na","Name"),("na1","Unicode_1_Name"),("name","Name"),("namealias","Name_Alias"),("nchar","Noncharacter_Code_Point"),("nfcqc","NFC_Quick_Check"),("nfcquickcheck","NFC_Quick_Check"),("nfdqc","NFD_Quick_Check"),("nfdquickcheck","NFD_Quick_Check"),("nfkccasefold","NFKC_Casefold"),("nfkccf","NFKC_Casefold"),("nfkcqc","NFKC_Quick_Check"),("nfkcquickcheck","NFKC_Quick_Check"),("nfkcscf","NFKC_Simple_Casefold"),("nfkcsimplecasefold","NFKC_Simple_Casefold"),("nfkdqc","NFKD_Quick_Check"),("nfkdquickcheck","NFKD_Quick_Check"),("noncharactercodepoint","Noncharacter_Code_Point"),("nt","Numeric_Type"),("numerictype","Numeric_Type"),("numericvalue","Numeric_Value"),("nv","Numeric_Value"),("oalpha","Other_Alphabetic"),("ocomment","ISO_Comment"),("odi","Other_Default_Ignorable_Code_Point"),("ogrext","Other_Grapheme_Extend"),("oidc","Other_ID_Continue"),("oids","Other_ID_Start"),("olower","Other_Lowercase"),("omath","Other_Math"),("otheralphabetic","Other_Alphabetic"),("otherdefaultignorablecodepoint","Other_Default_Ignorable_Code_Point"),("othergraphemeextend","Other_Grapheme_Extend"),("otheridcontinue","Other_ID_Continue"),("otheridstart","Other_ID_Start"),("otherlowercase","Other_Lowercase"),("othermath","Other_Math"),("otheruppercase","Other_Uppercase"),("oupper","Other_Uppercase"),("patsyn","Pattern_Syntax"),("patternsyntax","Pattern_Syntax"),("patternwhitespace","Pattern_White_Space"),("patws","Pattern_White_Space"),("pcm","Prepended_Concatenation_Mark"),("prependedconcatenationmark","Prepended_Concatenation_Mark"),("qmark","Quotation_Mark"),("quotationmark","Quotation_Mark"),("radical","Radical"),("regionalindicator","Regional_Indicator"),("ri","Regional_Indicator"),("sb","Sentence_Break"),("sc","Script"),("scf","Simple_Case_Folding"),("script","Script"),("scriptextensions","Script_Extensions"),("scx","Script_Extensions"),("sd","Soft_Dotted"),("sentencebreak","Sentence_Break"),("sentenceterminal","Sentence_Terminal"),("sfc","Simple_Case_Folding"),("simplecasefolding","Simple_Case_Folding"),("simplelowercasemapping","Simple_Lowercase_Mapping"),("simpletitlecasemapping","Simple_Titlecase_Mapping"),("simpleuppercasemapping","Simple_Uppercase_Mapping"),("slc","Simple_Lowercase_Mapping"),("softdotted","Soft_Dotted"),("space","White_Space"),("stc","Simple_Titlecase_Mapping"),("sterm","Sentence_Terminal"),("suc","Simple_Uppercase_Mapping"),("tc","Titlecase_Mapping"),("term","Terminal_Punctuation"),("terminalpunctuation","Terminal_Punctuation"),("titlecasemapping","Titlecase_Mapping"),("uc","Uppercase_Mapping"),("uideo","Unified_Ideograph"),("unicode1name","Unicode_1_Name"),("unicoderadicalstroke","kRSUnicode"),("unifiedideograph","Unified_Ideograph"),("upper","Uppercase"),("uppercase","Uppercase"),("uppercasemapping","Uppercase_Mapping"),("urs","kRSUnicode"),("variationselector","Variation_Selector"),("verticalorientation","Vertical_Orientation"),("vo","Vertical_Orientation"),("vs","Variation_Selector"),("wb","Word_Break"),("whitespace","White_Space"),("wordbreak","Word_Break"),("wspace","White_Space"),("xidc","XID_Continue"),("xidcontinue","XID_Continue"),("xids","XID_Start"),("xidstart","XID_Start"),("xonfc","Expands_On_NFC"),("xonfd","Expands_On_NFD"),("xonfkc","Expands_On_NFKC"),("xonfkd","Expands_On_NFKD") ];
            }

            pub mod values
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                pub const PROPERTY_VALUES:&'static [( &'static str, &'static [(&'static str, &'static str)] )] =  &[ ("Age",&[ ("1.1","V1_1"),("10.0","V10_0"),("11.0","V11_0"),("12.0","V12_0"),("12.1","V12_1"),("13.0","V13_0"),("14.0","V14_0"),("15.0","V15_0"),("15.1","V15_1"),("16.0","V16_0"),("2.0","V2_0"),("2.1","V2_1"),("3.0","V3_0"),("3.1","V3_1"),("3.2","V3_2"),("4.0","V4_0"),("4.1","V4_1"),("5.0","V5_0"),("5.1","V5_1"),("5.2","V5_2"),("6.0","V6_0"),("6.1","V6_1"),("6.2","V6_2"),("6.3","V6_3"),("7.0","V7_0"),("8.0","V8_0"),("9.0","V9_0"),("na","Unassigned"),("unassigned","Unassigned"),("v100","V10_0"),("v11","V1_1"),("v110","V11_0"),("v120","V12_0"),("v121","V12_1"),("v130","V13_0"),("v140","V14_0"),("v150","V15_0"),("v151","V15_1"),("v160","V16_0"),("v20","V2_0"),("v21","V2_1"),("v30","V3_0"),("v31","V3_1"),("v32","V3_2"),("v40","V4_0"),("v41","V4_1"),("v50","V5_0"),("v51","V5_1"),("v52","V5_2"),("v60","V6_0"),("v61","V6_1"),("v62","V6_2"),("v63","V6_3"),("v70","V7_0"),("v80","V8_0"),("v90","V9_0") ] ),("General_Category",&[ ("c","Other"),("casedletter","Cased_Letter"),("cc","Control"),("cf","Format"),("closepunctuation","Close_Punctuation"),("cn","Unassigned"),("cntrl","Control"),("co","Private_Use"),("combiningmark","Mark"),("connectorpunctuation","Connector_Punctuation"),("control","Control"),("cs","Surrogate"),("currencysymbol","Currency_Symbol"),("dashpunctuation","Dash_Punctuation"),("decimalnumber","Decimal_Number"),("digit","Decimal_Number"),("enclosingmark","Enclosing_Mark"),("finalpunctuation","Final_Punctuation"),("format","Format"),("initialpunctuation","Initial_Punctuation"),("l","Letter"),("lc","Cased_Letter"),("letter","Letter"),("letternumber","Letter_Number"),("lineseparator","Line_Separator"),("ll","Lowercase_Letter"),("lm","Modifier_Letter"),("lo","Other_Letter"),("lowercaseletter","Lowercase_Letter"),("lt","Titlecase_Letter"),("lu","Uppercase_Letter"),("m","Mark"),("mark","Mark"),("mathsymbol","Math_Symbol"),("mc","Spacing_Mark"),("me","Enclosing_Mark"),("mn","Nonspacing_Mark"),("modifierletter","Modifier_Letter"),("modifiersymbol","Modifier_Symbol"),("n","Number"),("nd","Decimal_Number"),("nl","Letter_Number"),("no","Other_Number"),("nonspacingmark","Nonspacing_Mark"),("number","Number"),("openpunctuation","Open_Punctuation"),("other","Other"),("otherletter","Other_Letter"),("othernumber","Other_Number"),("otherpunctuation","Other_Punctuation"),("othersymbol","Other_Symbol"),("p","Punctuation"),("paragraphseparator","Paragraph_Separator"),("pc","Connector_Punctuation"),("pd","Dash_Punctuation"),("pe","Close_Punctuation"),("pf","Final_Punctuation"),("pi","Initial_Punctuation"),("po","Other_Punctuation"),("privateuse","Private_Use"),("ps","Open_Punctuation"),("punct","Punctuation"),("punctuation","Punctuation"),("s","Symbol"),("sc","Currency_Symbol"),("separator","Separator"),("sk","Modifier_Symbol"),("sm","Math_Symbol"),("so","Other_Symbol"),("spaceseparator","Space_Separator"),("spacingmark","Spacing_Mark"),("surrogate","Surrogate"),("symbol","Symbol"),("titlecaseletter","Titlecase_Letter"),("unassigned","Unassigned"),("uppercaseletter","Uppercase_Letter"),("z","Separator"),("zl","Line_Separator"),("zp","Paragraph_Separator"),("zs","Space_Separator") ] ),("Grapheme_Cluster_Break",&[ ("cn","Control"),("control","Control"),("cr","CR"),("eb","E_Base"),("ebase","E_Base"),("ebasegaz","E_Base_GAZ"),("ebg","E_Base_GAZ"),("em","E_Modifier"),("emodifier","E_Modifier"),("ex","Extend"),("extend","Extend"),("gaz","Glue_After_Zwj"),("glueafterzwj","Glue_After_Zwj"),("l","L"),("lf","LF"),("lv","LV"),("lvt","LVT"),("other","Other"),("pp","Prepend"),("prepend","Prepend"),("regionalindicator","Regional_Indicator"),("ri","Regional_Indicator"),("sm","SpacingMark"),("spacingmark","SpacingMark"),("t","T"),("v","V"),("xx","Other"),("zwj","ZWJ") ] ),("Script",&[ ("adlam","Adlam"),("adlm","Adlam"),("aghb","Caucasian_Albanian"),("ahom","Ahom"),("anatolianhieroglyphs","Anatolian_Hieroglyphs"),("arab","Arabic"),("arabic","Arabic"),("armenian","Armenian"),("armi","Imperial_Aramaic"),("armn","Armenian"),("avestan","Avestan"),("avst","Avestan"),("bali","Balinese"),("balinese","Balinese"),("bamu","Bamum"),("bamum","Bamum"),("bass","Bassa_Vah"),("bassavah","Bassa_Vah"),("batak","Batak"),("batk","Batak"),("beng","Bengali"),("bengali","Bengali"),("bhaiksuki","Bhaiksuki"),("bhks","Bhaiksuki"),("bopo","Bopomofo"),("bopomofo","Bopomofo"),("brah","Brahmi"),("brahmi","Brahmi"),("brai","Braille"),("braille","Braille"),("bugi","Buginese"),("buginese","Buginese"),("buhd","Buhid"),("buhid","Buhid"),("cakm","Chakma"),("canadianaboriginal","Canadian_Aboriginal"),("cans","Canadian_Aboriginal"),("cari","Carian"),("carian","Carian"),("caucasianalbanian","Caucasian_Albanian"),("chakma","Chakma"),("cham","Cham"),("cher","Cherokee"),("cherokee","Cherokee"),("chorasmian","Chorasmian"),("chrs","Chorasmian"),("common","Common"),("copt","Coptic"),("coptic","Coptic"),("cpmn","Cypro_Minoan"),("cprt","Cypriot"),("cuneiform","Cuneiform"),("cypriot","Cypriot"),("cyprominoan","Cypro_Minoan"),("cyrillic","Cyrillic"),("cyrl","Cyrillic"),("deseret","Deseret"),("deva","Devanagari"),("devanagari","Devanagari"),("diak","Dives_Akuru"),("divesakuru","Dives_Akuru"),("dogr","Dogra"),("dogra","Dogra"),("dsrt","Deseret"),("dupl","Duployan"),("duployan","Duployan"),("egyp","Egyptian_Hieroglyphs"),("egyptianhieroglyphs","Egyptian_Hieroglyphs"),("elba","Elbasan"),("elbasan","Elbasan"),("elym","Elymaic"),("elymaic","Elymaic"),("ethi","Ethiopic"),("ethiopic","Ethiopic"),("gara","Garay"),("garay","Garay"),("geor","Georgian"),("georgian","Georgian"),("glag","Glagolitic"),("glagolitic","Glagolitic"),("gong","Gunjala_Gondi"),("gonm","Masaram_Gondi"),("goth","Gothic"),("gothic","Gothic"),("gran","Grantha"),("grantha","Grantha"),("greek","Greek"),("grek","Greek"),("gujarati","Gujarati"),("gujr","Gujarati"),("gukh","Gurung_Khema"),("gunjalagondi","Gunjala_Gondi"),("gurmukhi","Gurmukhi"),("guru","Gurmukhi"),("gurungkhema","Gurung_Khema"),("han","Han"),("hang","Hangul"),("hangul","Hangul"),("hani","Han"),("hanifirohingya","Hanifi_Rohingya"),("hano","Hanunoo"),("hanunoo","Hanunoo"),("hatr","Hatran"),("hatran","Hatran"),("hebr","Hebrew"),("hebrew","Hebrew"),("hira","Hiragana"),("hiragana","Hiragana"),("hluw","Anatolian_Hieroglyphs"),("hmng","Pahawh_Hmong"),("hmnp","Nyiakeng_Puachue_Hmong"),("hrkt","Katakana_Or_Hiragana"),("hung","Old_Hungarian"),("imperialaramaic","Imperial_Aramaic"),("inherited","Inherited"),("inscriptionalpahlavi","Inscriptional_Pahlavi"),("inscriptionalparthian","Inscriptional_Parthian"),("ital","Old_Italic"),("java","Javanese"),("javanese","Javanese"),("kaithi","Kaithi"),("kali","Kayah_Li"),("kana","Katakana"),("kannada","Kannada"),("katakana","Katakana"),("katakanaorhiragana","Katakana_Or_Hiragana"),("kawi","Kawi"),("kayahli","Kayah_Li"),("khar","Kharoshthi"),("kharoshthi","Kharoshthi"),("khitansmallscript","Khitan_Small_Script"),("khmer","Khmer"),("khmr","Khmer"),("khoj","Khojki"),("khojki","Khojki"),("khudawadi","Khudawadi"),("kiratrai","Kirat_Rai"),("kits","Khitan_Small_Script"),("knda","Kannada"),("krai","Kirat_Rai"),("kthi","Kaithi"),("lana","Tai_Tham"),("lao","Lao"),("laoo","Lao"),("latin","Latin"),("latn","Latin"),("lepc","Lepcha"),("lepcha","Lepcha"),("limb","Limbu"),("limbu","Limbu"),("lina","Linear_A"),("linb","Linear_B"),("lineara","Linear_A"),("linearb","Linear_B"),("lisu","Lisu"),("lyci","Lycian"),("lycian","Lycian"),("lydi","Lydian"),("lydian","Lydian"),("mahajani","Mahajani"),("mahj","Mahajani"),("maka","Makasar"),("makasar","Makasar"),("malayalam","Malayalam"),("mand","Mandaic"),("mandaic","Mandaic"),("mani","Manichaean"),("manichaean","Manichaean"),("marc","Marchen"),("marchen","Marchen"),("masaramgondi","Masaram_Gondi"),("medefaidrin","Medefaidrin"),("medf","Medefaidrin"),("meeteimayek","Meetei_Mayek"),("mend","Mende_Kikakui"),("mendekikakui","Mende_Kikakui"),("merc","Meroitic_Cursive"),("mero","Meroitic_Hieroglyphs"),("meroiticcursive","Meroitic_Cursive"),("meroitichieroglyphs","Meroitic_Hieroglyphs"),("miao","Miao"),("mlym","Malayalam"),("modi","Modi"),("mong","Mongolian"),("mongolian","Mongolian"),("mro","Mro"),("mroo","Mro"),("mtei","Meetei_Mayek"),("mult","Multani"),("multani","Multani"),("myanmar","Myanmar"),("mymr","Myanmar"),("nabataean","Nabataean"),("nagm","Nag_Mundari"),("nagmundari","Nag_Mundari"),("nand","Nandinagari"),("nandinagari","Nandinagari"),("narb","Old_North_Arabian"),("nbat","Nabataean"),("newa","Newa"),("newtailue","New_Tai_Lue"),("nko","Nko"),("nkoo","Nko"),("nshu","Nushu"),("nushu","Nushu"),("nyiakengpuachuehmong","Nyiakeng_Puachue_Hmong"),("ogam","Ogham"),("ogham","Ogham"),("olchiki","Ol_Chiki"),("olck","Ol_Chiki"),("oldhungarian","Old_Hungarian"),("olditalic","Old_Italic"),("oldnortharabian","Old_North_Arabian"),("oldpermic","Old_Permic"),("oldpersian","Old_Persian"),("oldsogdian","Old_Sogdian"),("oldsoutharabian","Old_South_Arabian"),("oldturkic","Old_Turkic"),("olduyghur","Old_Uyghur"),("olonal","Ol_Onal"),("onao","Ol_Onal"),("oriya","Oriya"),("orkh","Old_Turkic"),("orya","Oriya"),("osage","Osage"),("osge","Osage"),("osma","Osmanya"),("osmanya","Osmanya"),("ougr","Old_Uyghur"),("pahawhhmong","Pahawh_Hmong"),("palm","Palmyrene"),("palmyrene","Palmyrene"),("pauc","Pau_Cin_Hau"),("paucinhau","Pau_Cin_Hau"),("perm","Old_Permic"),("phag","Phags_Pa"),("phagspa","Phags_Pa"),("phli","Inscriptional_Pahlavi"),("phlp","Psalter_Pahlavi"),("phnx","Phoenician"),("phoenician","Phoenician"),("plrd","Miao"),("prti","Inscriptional_Parthian"),("psalterpahlavi","Psalter_Pahlavi"),("qaac","Coptic"),("qaai","Inherited"),("rejang","Rejang"),("rjng","Rejang"),("rohg","Hanifi_Rohingya"),("runic","Runic"),("runr","Runic"),("samaritan","Samaritan"),("samr","Samaritan"),("sarb","Old_South_Arabian"),("saur","Saurashtra"),("saurashtra","Saurashtra"),("sgnw","SignWriting"),("sharada","Sharada"),("shavian","Shavian"),("shaw","Shavian"),("shrd","Sharada"),("sidd","Siddham"),("siddham","Siddham"),("signwriting","SignWriting"),("sind","Khudawadi"),("sinh","Sinhala"),("sinhala","Sinhala"),("sogd","Sogdian"),("sogdian","Sogdian"),("sogo","Old_Sogdian"),("sora","Sora_Sompeng"),("sorasompeng","Sora_Sompeng"),("soyo","Soyombo"),("soyombo","Soyombo"),("sund","Sundanese"),("sundanese","Sundanese"),("sunu","Sunuwar"),("sunuwar","Sunuwar"),("sylo","Syloti_Nagri"),("sylotinagri","Syloti_Nagri"),("syrc","Syriac"),("syriac","Syriac"),("tagalog","Tagalog"),("tagb","Tagbanwa"),("tagbanwa","Tagbanwa"),("taile","Tai_Le"),("taitham","Tai_Tham"),("taiviet","Tai_Viet"),("takr","Takri"),("takri","Takri"),("tale","Tai_Le"),("talu","New_Tai_Lue"),("tamil","Tamil"),("taml","Tamil"),("tang","Tangut"),("tangsa","Tangsa"),("tangut","Tangut"),("tavt","Tai_Viet"),("telu","Telugu"),("telugu","Telugu"),("tfng","Tifinagh"),("tglg","Tagalog"),("thaa","Thaana"),("thaana","Thaana"),("thai","Thai"),("tibetan","Tibetan"),("tibt","Tibetan"),("tifinagh","Tifinagh"),("tirh","Tirhuta"),("tirhuta","Tirhuta"),("tnsa","Tangsa"),("todhri","Todhri"),("todr","Todhri"),("toto","Toto"),("tulutigalari","Tulu_Tigalari"),("tutg","Tulu_Tigalari"),("ugar","Ugaritic"),("ugaritic","Ugaritic"),("unknown","Unknown"),("vai","Vai"),("vaii","Vai"),("vith","Vithkuqi"),("vithkuqi","Vithkuqi"),("wancho","Wancho"),("wara","Warang_Citi"),("warangciti","Warang_Citi"),("wcho","Wancho"),("xpeo","Old_Persian"),("xsux","Cuneiform"),("yezi","Yezidi"),("yezidi","Yezidi"),("yi","Yi"),("yiii","Yi"),("zanabazarsquare","Zanabazar_Square"),("zanb","Zanabazar_Square"),("zinh","Inherited"),("zyyy","Common"),("zzzz","Unknown") ] ),("Script_Extensions",&[ ("adlam","Adlam"),("adlm","Adlam"),("aghb","Caucasian_Albanian"),("ahom","Ahom"),("anatolianhieroglyphs","Anatolian_Hieroglyphs"),("arab","Arabic"),("arabic","Arabic"),("armenian","Armenian"),("armi","Imperial_Aramaic"),("armn","Armenian"),("avestan","Avestan"),("avst","Avestan"),("bali","Balinese"),("balinese","Balinese"),("bamu","Bamum"),("bamum","Bamum"),("bass","Bassa_Vah"),("bassavah","Bassa_Vah"),("batak","Batak"),("batk","Batak"),("beng","Bengali"),("bengali","Bengali"),("bhaiksuki","Bhaiksuki"),("bhks","Bhaiksuki"),("bopo","Bopomofo"),("bopomofo","Bopomofo"),("brah","Brahmi"),("brahmi","Brahmi"),("brai","Braille"),("braille","Braille"),("bugi","Buginese"),("buginese","Buginese"),("buhd","Buhid"),("buhid","Buhid"),("cakm","Chakma"),("canadianaboriginal","Canadian_Aboriginal"),("cans","Canadian_Aboriginal"),("cari","Carian"),("carian","Carian"),("caucasianalbanian","Caucasian_Albanian"),("chakma","Chakma"),("cham","Cham"),("cher","Cherokee"),("cherokee","Cherokee"),("chorasmian","Chorasmian"),("chrs","Chorasmian"),("common","Common"),("copt","Coptic"),("coptic","Coptic"),("cpmn","Cypro_Minoan"),("cprt","Cypriot"),("cuneiform","Cuneiform"),("cypriot","Cypriot"),("cyprominoan","Cypro_Minoan"),("cyrillic","Cyrillic"),("cyrl","Cyrillic"),("deseret","Deseret"),("deva","Devanagari"),("devanagari","Devanagari"),("diak","Dives_Akuru"),("divesakuru","Dives_Akuru"),("dogr","Dogra"),("dogra","Dogra"),("dsrt","Deseret"),("dupl","Duployan"),("duployan","Duployan"),("egyp","Egyptian_Hieroglyphs"),("egyptianhieroglyphs","Egyptian_Hieroglyphs"),("elba","Elbasan"),("elbasan","Elbasan"),("elym","Elymaic"),("elymaic","Elymaic"),("ethi","Ethiopic"),("ethiopic","Ethiopic"),("gara","Garay"),("garay","Garay"),("geor","Georgian"),("georgian","Georgian"),("glag","Glagolitic"),("glagolitic","Glagolitic"),("gong","Gunjala_Gondi"),("gonm","Masaram_Gondi"),("goth","Gothic"),("gothic","Gothic"),("gran","Grantha"),("grantha","Grantha"),("greek","Greek"),("grek","Greek"),("gujarati","Gujarati"),("gujr","Gujarati"),("gukh","Gurung_Khema"),("gunjalagondi","Gunjala_Gondi"),("gurmukhi","Gurmukhi"),("guru","Gurmukhi"),("gurungkhema","Gurung_Khema"),("han","Han"),("hang","Hangul"),("hangul","Hangul"),("hani","Han"),("hanifirohingya","Hanifi_Rohingya"),("hano","Hanunoo"),("hanunoo","Hanunoo"),("hatr","Hatran"),("hatran","Hatran"),("hebr","Hebrew"),("hebrew","Hebrew"),("hira","Hiragana"),("hiragana","Hiragana"),("hluw","Anatolian_Hieroglyphs"),("hmng","Pahawh_Hmong"),("hmnp","Nyiakeng_Puachue_Hmong"),("hrkt","Katakana_Or_Hiragana"),("hung","Old_Hungarian"),("imperialaramaic","Imperial_Aramaic"),("inherited","Inherited"),("inscriptionalpahlavi","Inscriptional_Pahlavi"),("inscriptionalparthian","Inscriptional_Parthian"),("ital","Old_Italic"),("java","Javanese"),("javanese","Javanese"),("kaithi","Kaithi"),("kali","Kayah_Li"),("kana","Katakana"),("kannada","Kannada"),("katakana","Katakana"),("katakanaorhiragana","Katakana_Or_Hiragana"),("kawi","Kawi"),("kayahli","Kayah_Li"),("khar","Kharoshthi"),("kharoshthi","Kharoshthi"),("khitansmallscript","Khitan_Small_Script"),("khmer","Khmer"),("khmr","Khmer"),("khoj","Khojki"),("khojki","Khojki"),("khudawadi","Khudawadi"),("kiratrai","Kirat_Rai"),("kits","Khitan_Small_Script"),("knda","Kannada"),("krai","Kirat_Rai"),("kthi","Kaithi"),("lana","Tai_Tham"),("lao","Lao"),("laoo","Lao"),("latin","Latin"),("latn","Latin"),("lepc","Lepcha"),("lepcha","Lepcha"),("limb","Limbu"),("limbu","Limbu"),("lina","Linear_A"),("linb","Linear_B"),("lineara","Linear_A"),("linearb","Linear_B"),("lisu","Lisu"),("lyci","Lycian"),("lycian","Lycian"),("lydi","Lydian"),("lydian","Lydian"),("mahajani","Mahajani"),("mahj","Mahajani"),("maka","Makasar"),("makasar","Makasar"),("malayalam","Malayalam"),("mand","Mandaic"),("mandaic","Mandaic"),("mani","Manichaean"),("manichaean","Manichaean"),("marc","Marchen"),("marchen","Marchen"),("masaramgondi","Masaram_Gondi"),("medefaidrin","Medefaidrin"),("medf","Medefaidrin"),("meeteimayek","Meetei_Mayek"),("mend","Mende_Kikakui"),("mendekikakui","Mende_Kikakui"),("merc","Meroitic_Cursive"),("mero","Meroitic_Hieroglyphs"),("meroiticcursive","Meroitic_Cursive"),("meroitichieroglyphs","Meroitic_Hieroglyphs"),("miao","Miao"),("mlym","Malayalam"),("modi","Modi"),("mong","Mongolian"),("mongolian","Mongolian"),("mro","Mro"),("mroo","Mro"),("mtei","Meetei_Mayek"),("mult","Multani"),("multani","Multani"),("myanmar","Myanmar"),("mymr","Myanmar"),("nabataean","Nabataean"),("nagm","Nag_Mundari"),("nagmundari","Nag_Mundari"),("nand","Nandinagari"),("nandinagari","Nandinagari"),("narb","Old_North_Arabian"),("nbat","Nabataean"),("newa","Newa"),("newtailue","New_Tai_Lue"),("nko","Nko"),("nkoo","Nko"),("nshu","Nushu"),("nushu","Nushu"),("nyiakengpuachuehmong","Nyiakeng_Puachue_Hmong"),("ogam","Ogham"),("ogham","Ogham"),("olchiki","Ol_Chiki"),("olck","Ol_Chiki"),("oldhungarian","Old_Hungarian"),("olditalic","Old_Italic"),("oldnortharabian","Old_North_Arabian"),("oldpermic","Old_Permic"),("oldpersian","Old_Persian"),("oldsogdian","Old_Sogdian"),("oldsoutharabian","Old_South_Arabian"),("oldturkic","Old_Turkic"),("olduyghur","Old_Uyghur"),("olonal","Ol_Onal"),("onao","Ol_Onal"),("oriya","Oriya"),("orkh","Old_Turkic"),("orya","Oriya"),("osage","Osage"),("osge","Osage"),("osma","Osmanya"),("osmanya","Osmanya"),("ougr","Old_Uyghur"),("pahawhhmong","Pahawh_Hmong"),("palm","Palmyrene"),("palmyrene","Palmyrene"),("pauc","Pau_Cin_Hau"),("paucinhau","Pau_Cin_Hau"),("perm","Old_Permic"),("phag","Phags_Pa"),("phagspa","Phags_Pa"),("phli","Inscriptional_Pahlavi"),("phlp","Psalter_Pahlavi"),("phnx","Phoenician"),("phoenician","Phoenician"),("plrd","Miao"),("prti","Inscriptional_Parthian"),("psalterpahlavi","Psalter_Pahlavi"),("qaac","Coptic"),("qaai","Inherited"),("rejang","Rejang"),("rjng","Rejang"),("rohg","Hanifi_Rohingya"),("runic","Runic"),("runr","Runic"),("samaritan","Samaritan"),("samr","Samaritan"),("sarb","Old_South_Arabian"),("saur","Saurashtra"),("saurashtra","Saurashtra"),("sgnw","SignWriting"),("sharada","Sharada"),("shavian","Shavian"),("shaw","Shavian"),("shrd","Sharada"),("sidd","Siddham"),("siddham","Siddham"),("signwriting","SignWriting"),("sind","Khudawadi"),("sinh","Sinhala"),("sinhala","Sinhala"),("sogd","Sogdian"),("sogdian","Sogdian"),("sogo","Old_Sogdian"),("sora","Sora_Sompeng"),("sorasompeng","Sora_Sompeng"),("soyo","Soyombo"),("soyombo","Soyombo"),("sund","Sundanese"),("sundanese","Sundanese"),("sunu","Sunuwar"),("sunuwar","Sunuwar"),("sylo","Syloti_Nagri"),("sylotinagri","Syloti_Nagri"),("syrc","Syriac"),("syriac","Syriac"),("tagalog","Tagalog"),("tagb","Tagbanwa"),("tagbanwa","Tagbanwa"),("taile","Tai_Le"),("taitham","Tai_Tham"),("taiviet","Tai_Viet"),("takr","Takri"),("takri","Takri"),("tale","Tai_Le"),("talu","New_Tai_Lue"),("tamil","Tamil"),("taml","Tamil"),("tang","Tangut"),("tangsa","Tangsa"),("tangut","Tangut"),("tavt","Tai_Viet"),("telu","Telugu"),("telugu","Telugu"),("tfng","Tifinagh"),("tglg","Tagalog"),("thaa","Thaana"),("thaana","Thaana"),("thai","Thai"),("tibetan","Tibetan"),("tibt","Tibetan"),("tifinagh","Tifinagh"),("tirh","Tirhuta"),("tirhuta","Tirhuta"),("tnsa","Tangsa"),("todhri","Todhri"),("todr","Todhri"),("toto","Toto"),("tulutigalari","Tulu_Tigalari"),("tutg","Tulu_Tigalari"),("ugar","Ugaritic"),("ugaritic","Ugaritic"),("unknown","Unknown"),("vai","Vai"),("vaii","Vai"),("vith","Vithkuqi"),("vithkuqi","Vithkuqi"),("wancho","Wancho"),("wara","Warang_Citi"),("warangciti","Warang_Citi"),("wcho","Wancho"),("xpeo","Old_Persian"),("xsux","Cuneiform"),("yezi","Yezidi"),("yezidi","Yezidi"),("yi","Yi"),("yiii","Yi"),("zanabazarsquare","Zanabazar_Square"),("zanb","Zanabazar_Square"),("zinh","Inherited"),("zyyy","Common"),("zzzz","Unknown") ] ),("Sentence_Break",&[ ("at","ATerm"),("aterm","ATerm"),("cl","Close"),("close","Close"),("cr","CR"),("ex","Extend"),("extend","Extend"),("fo","Format"),("format","Format"),("le","OLetter"),("lf","LF"),("lo","Lower"),("lower","Lower"),("nu","Numeric"),("numeric","Numeric"),("oletter","OLetter"),("other","Other"),("sc","SContinue"),("scontinue","SContinue"),("se","Sep"),("sep","Sep"),("sp","Sp"),("st","STerm"),("sterm","STerm"),("up","Upper"),("upper","Upper"),("xx","Other") ] ),( "Word_Break",&[ ("aletter","ALetter"),("cr","CR"),("doublequote","Double_Quote"),("dq","Double_Quote"),("eb","E_Base"),("ebase","E_Base"),("ebasegaz","E_Base_GAZ"),("ebg","E_Base_GAZ"),("em","E_Modifier"),("emodifier","E_Modifier"),("ex","ExtendNumLet"),("extend","Extend"),("extendnumlet","ExtendNumLet"),("fo","Format"),("format","Format"),("gaz","Glue_After_Zwj"),("glueafterzwj","Glue_After_Zwj"),("hebrewletter","Hebrew_Letter"),("hl","Hebrew_Letter"),("ka","Katakana"),("katakana","Katakana"),("le","ALetter"),("lf","LF"),("mb","MidNumLet"),("midletter","MidLetter"),("midnum","MidNum"),("midnumlet","MidNumLet"),("ml","MidLetter"),("mn","MidNum"),("newline","Newline"),("nl","Newline"),("nu","Numeric"),("numeric","Numeric"),("other","Other"),("regionalindicator","Regional_Indicator"),("ri","Regional_Indicator"),("singlequote","Single_Quote"),("sq","Single_Quote"),("wsegspace","WSegSpace"),("xx","Other"),("zwj","ZWJ") ] ) ];
            }
        }

        pub mod script
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub mod extension
            {
                /*!
                */
                use ::
                {
                    *,
                };
                /*
                */
                pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] = &[("Adlam", ADLAM),("Ahom", AHOM),("Anatolian_Hieroglyphs", ANATOLIAN_HIEROGLYPHS),("Arabic", ARABIC),("Armenian", ARMENIAN),("Avestan", AVESTAN),("Balinese", BALINESE),("Bamum", BAMUM),("Bassa_Vah", BASSA_VAH),("Batak", BATAK),("Bengali", BENGALI),("Bhaiksuki", BHAIKSUKI),("Bopomofo", BOPOMOFO),("Brahmi", BRAHMI),("Braille", BRAILLE),("Buginese", BUGINESE),("Buhid", BUHID),("Canadian_Aboriginal", CANADIAN_ABORIGINAL),("Carian", CARIAN),("Caucasian_Albanian", CAUCASIAN_ALBANIAN),("Chakma", CHAKMA),("Cham", CHAM),("Cherokee", CHEROKEE),("Chorasmian", CHORASMIAN),("Common", COMMON),("Coptic", COPTIC),("Cuneiform", CUNEIFORM),("Cypriot", CYPRIOT),("Cypro_Minoan", CYPRO_MINOAN),("Cyrillic", CYRILLIC),("Deseret", DESERET),("Devanagari", DEVANAGARI),("Dives_Akuru", DIVES_AKURU),("Dogra", DOGRA),("Duployan", DUPLOYAN),("Egyptian_Hieroglyphs", EGYPTIAN_HIEROGLYPHS),("Elbasan", ELBASAN),("Elymaic", ELYMAIC),("Ethiopic", ETHIOPIC),("Garay", GARAY),("Georgian", GEORGIAN),("Glagolitic", GLAGOLITIC),("Gothic", GOTHIC),("Grantha", GRANTHA),("Greek", GREEK),("Gujarati", GUJARATI),("Gunjala_Gondi", GUNJALA_GONDI),("Gurmukhi", GURMUKHI),("Gurung_Khema", GURUNG_KHEMA),("Han", HAN),("Hangul", HANGUL),("Hanifi_Rohingya", HANIFI_ROHINGYA),("Hanunoo", HANUNOO),("Hatran", HATRAN),("Hebrew", HEBREW),("Hiragana", HIRAGANA),("Imperial_Aramaic", IMPERIAL_ARAMAIC),("Inherited", INHERITED),("Inscriptional_Pahlavi", INSCRIPTIONAL_PAHLAVI),("Inscriptional_Parthian", INSCRIPTIONAL_PARTHIAN),("Javanese", JAVANESE),("Kaithi", KAITHI),("Kannada", KANNADA),("Katakana", KATAKANA),("Kawi", KAWI),("Kayah_Li", KAYAH_LI),("Kharoshthi", KHAROSHTHI),("Khitan_Small_Script", KHITAN_SMALL_SCRIPT),("Khmer", KHMER),("Khojki", KHOJKI),("Khudawadi", KHUDAWADI),("Kirat_Rai", KIRAT_RAI),("Lao", LAO),("Latin", LATIN),("Lepcha", LEPCHA),("Limbu", LIMBU),("Linear_A", LINEAR_A),("Linear_B", LINEAR_B),("Lisu", LISU),("Lycian", LYCIAN),("Lydian", LYDIAN),("Mahajani", MAHAJANI),("Makasar", MAKASAR),("Malayalam", MALAYALAM),("Mandaic", MANDAIC),("Manichaean", MANICHAEAN),("Marchen", MARCHEN),("Masaram_Gondi", MASARAM_GONDI),("Medefaidrin", MEDEFAIDRIN),("Meetei_Mayek", MEETEI_MAYEK),("Mende_Kikakui", MENDE_KIKAKUI),("Meroitic_Cursive", MEROITIC_CURSIVE),("Meroitic_Hieroglyphs", MEROITIC_HIEROGLYPHS),("Miao", MIAO),("Modi", MODI),("Mongolian", MONGOLIAN),("Mro", MRO),("Multani", MULTANI),("Myanmar", MYANMAR),("Nabataean", NABATAEAN),("Nag_Mundari", NAG_MUNDARI),("Nandinagari", NANDINAGARI),("New_Tai_Lue", NEW_TAI_LUE),("Newa", NEWA),("Nko", NKO),("Nushu", NUSHU),("Nyiakeng_Puachue_Hmong", NYIAKENG_PUACHUE_HMONG),("Ogham", OGHAM),("Ol_Chiki", OL_CHIKI),("Ol_Onal", OL_ONAL),("Old_Hungarian", OLD_HUNGARIAN),("Old_Italic", OLD_ITALIC),("Old_North_Arabian", OLD_NORTH_ARABIAN),("Old_Permic", OLD_PERMIC),("Old_Persian", OLD_PERSIAN),("Old_Sogdian", OLD_SOGDIAN),("Old_South_Arabian", OLD_SOUTH_ARABIAN),("Old_Turkic", OLD_TURKIC),("Old_Uyghur", OLD_UYGHUR),("Oriya", ORIYA),("Osage", OSAGE),("Osmanya", OSMANYA),("Pahawh_Hmong", PAHAWH_HMONG),("Palmyrene", PALMYRENE),("Pau_Cin_Hau", PAU_CIN_HAU),("Phags_Pa", PHAGS_PA),("Phoenician", PHOENICIAN),("Psalter_Pahlavi", PSALTER_PAHLAVI),("Rejang", REJANG),("Runic", RUNIC),("Samaritan", SAMARITAN),("Saurashtra", SAURASHTRA),("Sharada", SHARADA),("Shavian", SHAVIAN),("Siddham", SIDDHAM),("SignWriting", SIGNWRITING),("Sinhala", SINHALA),("Sogdian", SOGDIAN),("Sora_Sompeng", SORA_SOMPENG),("Soyombo", SOYOMBO),("Sundanese", SUNDANESE),("Sunuwar", SUNUWAR),("Syloti_Nagri", SYLOTI_NAGRI),("Syriac", SYRIAC),("Tagalog", TAGALOG),("Tagbanwa", TAGBANWA),("Tai_Le", TAI_LE),("Tai_Tham", TAI_THAM),("Tai_Viet", TAI_VIET),("Takri", TAKRI),("Tamil", TAMIL),("Tangsa", TANGSA),("Tangut", TANGUT),("Telugu", TELUGU),("Thaana", THAANA),("Thai", THAI),("Tibetan", TIBETAN),("Tifinagh", TIFINAGH),("Tirhuta", TIRHUTA),("Todhri", TODHRI),("Toto", TOTO),("Tulu_Tigalari", TULU_TIGALARI),("Ugaritic", UGARITIC),("Vai", VAI),("Vithkuqi", VITHKUQI),("Wancho", WANCHO),("Warang_Citi", WARANG_CITI),("Yezidi", YEZIDI),("Yi", YI),("Zanabazar_Square", ZANABAZAR_SQUARE) ];
                pub const ADLAM:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const AHOM:&'static [(char,char)] = &[('',''),('\u{1171d}','\u{1172b}'),('','')];
                pub const ANATOLIAN_HIEROGLYPHS:&'static [(char,char)] = &[('','')];
                pub const ARABIC:&'static [(char,char)] = &[ ('\u{600}','\u{604}'),('','\u{6dc}'),('',''),('',''),('',''),('\u{890}','\u{891}'),('\u{897}','\u{8e1}'),('\u{8e3}','\u{8ff}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{102e0}',''),('',''),('',''),('\u{10efc}','\u{10eff}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const ARMENIAN:&'static [(char,char)] = &[('\u{308}','\u{308}'),('',''),('',''),('',''),('','')];
                pub const AVESTAN:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
                pub const BALINESE:&'static [(char,char)] = &[('\u{1b00}',''),('','')];
                pub const BAMUM:&'static [(char,char)] = &[('',''),('','')];
                pub const BASSA_VAH:&'static [(char,char)] = &[('',''),('\u{16af0}','')];
                pub const BATAK:&'static [(char,char)] = &[('','\u{1bf3}'),('','')];
                pub const BENGALI:&'static [(char,char)] = &[ ('',''),('\u{951}','\u{952}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{9bc}','\u{9c4}'),('',''),('',''),('\u{9d7}','\u{9d7}'),('',''),('','\u{9e3}'),('','\u{9fe}'),('\u{1cd0}','\u{1cd0}'),('\u{1cd2}','\u{1cd2}'),('\u{1cd5}','\u{1cd6}'),('\u{1cd8}','\u{1cd8}'),('',''),('',''),('\u{1ced}','\u{1ced}'),('',''),('',''),('\u{a8f1}','\u{a8f1}') ];
                pub const BHAIKSUKI:&'static [(char,char)] = &[('',''),('','\u{11c36}'),('\u{11c38}',''),('','')];
                pub const BOPOMOFO:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{302a}','\u{302d}'),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const BRAHMI:&'static [(char,char)] = &[('',''),('',''),('\u{1107f}','\u{1107f}')];
                pub const BRAILLE:&'static [(char,char)] = &[('','')];
                pub const BUGINESE:&'static [(char,char)] = &[('','\u{1a1b}'),('',''),('','')];
                pub const BUHID:&'static [(char,char)] = &[('',''),('','\u{1753}')];
                pub const CANADIAN_ABORIGINAL:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const CARIAN:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('','')];
                pub const CAUCASIAN_ALBANIAN:&'static [(char,char)] = &[ ('\u{304}','\u{304}'),('\u{331}','\u{331}'),('\u{35e}','\u{35e}'),('',''),('','') ];
                pub const CHAKMA:&'static [(char,char)] = &[('',''),('',''),('\u{11100}','\u{11134}'),('','')];
                pub const CHAM:&'static [(char,char)] = &[('','\u{aa36}'),('',''),('',''),('','')];
                pub const CHEROKEE:&'static [(char,char)] = &[ ('\u{300}','\u{302}'),('\u{304}','\u{304}'),('\u{30b}','\u{30c}'),('\u{323}','\u{324}'),('\u{330}','\u{331}'),('',''),('',''),('','') ];
                pub const CHORASMIAN:&'static [(char,char)] = &[('','')];
                pub const COMMON:&'static [(char,char)] = &[ ('\0','@'),('[','`'),('{',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{605}','\u{605}'),('\u{6dd}','\u{6dd}'),('\u{8e2}','\u{8e2}'),('',''),('',''),('\u{2000}','\u{200b}'),('\u{200e}','\u{202e}'),('',''),('',''),('',''),('','\u{2064}'),('\u{2066}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{3000}','\u{3000}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{feff}','\u{feff}'),('',''),('',''),('',''),('',''),('',''),('\u{fff9}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1d166}'),('','\u{1d17a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{e0001}','\u{e0001}'),('\u{e0020}','\u{e007f}') ];
                pub const COPTIC:&'static [(char,char)] = &[ ('',''),('\u{300}','\u{300}'),('\u{304}','\u{305}'),('\u{307}','\u{307}'),('',''),('',''),('',''),('',''),('',''),('\u{102e0}','') ];
                pub const CUNEIFORM:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
                pub const CYPRIOT:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const CYPRO_MINOAN:&'static [(char,char)] = &[('',''),('','')];
                pub const CYRILLIC:&'static [(char,char)] = &[ ('',''),('\u{300}','\u{302}'),('\u{304}','\u{304}'),('\u{306}','\u{306}'),('\u{308}','\u{308}'),('\u{30b}','\u{30b}'),('\u{311}','\u{311}'),('',''),('',''),('',''),('',''),('\u{1df8}','\u{1df8}'),('\u{2de0}','\u{2dff}'),('',''),('','\u{a69f}'),('\u{fe2e}','\u{fe2f}'),('',''),('\u{1e08f}','\u{1e08f}') ];
                pub const DESERET:&'static [(char,char)] = &[('','')];
                pub const DEVANAGARI:&'static [(char,char)] = &[ ('',''),('\u{900}','\u{952}'),('\u{955}',''),('\u{1cd0}',''),('\u{1cf8}','\u{1cf9}'),('\u{20f0}','\u{20f0}'),('',''),('\u{a8e0}','\u{a8ff}'),('','') ];
                pub const DIVES_AKURU:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('\u{1193b}',''),('','') ];
                pub const DOGRA:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const DUPLOYAN:&'static [(char,char)] = &[ ('',''),('\u{307}','\u{308}'),('\u{30a}','\u{30a}'),('\u{323}','\u{324}'),('',''),('',''),('',''),('',''),('',''),('','\u{1bca3}') ];
                pub const EGYPTIAN_HIEROGLYPHS:&'static [(char,char)] = &[('','\u{13455}'),('','')];
                pub const ELBASAN:&'static [(char,char)] = &[('',''),('\u{305}','\u{305}'),('','')];
                pub const ELYMAIC:&'static [(char,char)] = &[('','')];
                pub const ETHIOPIC:&'static [(char,char)] = &[ ('\u{30e}','\u{30e}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{135d}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const GARAY:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('\u{10d69}',''),('','') ];
                pub const GEORGIAN:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const GLAGOLITIC:&'static [(char,char)] = &[ ('',''),('\u{303}','\u{303}'),('\u{305}','\u{305}'),('\u{484}','\u{484}'),('\u{487}','\u{487}'),('',''),('',''),('',''),('',''),('',''),('\u{a66f}','\u{a66f}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}') ];
                pub const GOTHIC:&'static [(char,char)] = &[ ('',''),('\u{304}','\u{305}'),('\u{308}','\u{308}'),('\u{331}','\u{331}'),('','') ];
                pub const GRANTHA:&'static [(char,char)] = &[ ('\u{951}','\u{952}'),('',''),('',''),('\u{1cd0}','\u{1cd0}'),('\u{1cd2}',''),('','\u{1cf4}'),('\u{1cf8}','\u{1cf9}'),('\u{20f0}','\u{20f0}'),('\u{11300}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1133b}',''),('',''),('','\u{1134d}'),('',''),('\u{11357}','\u{11357}'),('',''),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('',''),('','') ];
                pub const GREEK:&'static [(char,char)] = &[ ('',''),('\u{300}','\u{301}'),('\u{304}','\u{304}'),('\u{306}','\u{306}'),('\u{308}','\u{308}'),('\u{313}','\u{313}'),('\u{342}','\u{342}'),('\u{345}','\u{345}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{1dc1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const GUJARATI:&'static [(char,char)] = &[ ('\u{951}','\u{952}'),('',''),('\u{a81}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{abc}','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('',''),('','\u{ae3}'),('',''),('','\u{aff}'),('','') ];
                pub const GUNJALA_GONDI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('\u{11d90}','\u{11d91}'),('',''),('','') ];
                pub const GURMUKHI:&'static [(char,char)] = &[ ('\u{951}','\u{952}'),('',''),('\u{a01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('',''),('',''),('',''),('','') ];
                pub const GURUNG_KHEMA:&'static [(char,char)] = &[('',''),('','')];
                pub const HAN:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{302d}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16ff0}','\u{16ff1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const HANGUL:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('\u{302e}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const HANIFI_ROHINGYA:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('','\u{10d27}'),('','') ];
                pub const HANUNOO:&'static [(char,char)] = &[('','')];
                pub const HATRAN:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const HEBREW:&'static [(char,char)] = &[ ('\u{307}','\u{308}'),('\u{591}','\u{5c7}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const HIRAGANA:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{3099}',''),('',''),('',''),('',''),('',''),('\u{ff9e}','\u{ff9f}'),('',''),('',''),('',''),('','') ];
                pub const IMPERIAL_ARAMAIC:&'static [(char,char)] = &[('',''),('','')];
                pub const INHERITED:&'static [(char,char)] = &[ ('\u{30f}','\u{30f}'),('\u{312}','\u{312}'),('\u{314}','\u{31f}'),('\u{321}','\u{322}'),('\u{326}','\u{32c}'),('\u{32f}','\u{32f}'),('\u{332}','\u{341}'),('\u{343}','\u{344}'),('\u{346}','\u{357}'),('\u{359}','\u{35d}'),('\u{35f}','\u{362}'),('\u{953}','\u{954}'),('\u{1ab0}','\u{1ace}'),('\u{1dc2}','\u{1df7}'),('\u{1df9}','\u{1df9}'),('\u{1dfb}','\u{1dff}'),('\u{200c}','\u{200d}'),('\u{20d0}','\u{20ef}'),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2d}'),('\u{101fd}','\u{101fd}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d167}','\u{1d169}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{e0100}','\u{e01ef}') ];
                pub const INSCRIPTIONAL_PAHLAVI:&'static [(char,char)] = &[('',''),('','')];
                pub const INSCRIPTIONAL_PARTHIAN:&'static [(char,char)] = &[('',''),('','')];
                pub const JAVANESE:&'static [(char,char)] = &[('\u{a980}',''),('',''),('','')];
                pub const KAITHI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('\u{11080}','\u{110c2}'),('\u{110cd}','\u{110cd}') ];
                pub const KANNADA:&'static [(char,char)] = &[ ('\u{951}','\u{952}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{cbc}',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('',''),('','\u{ce3}'),('',''),('',''),('\u{1cd0}','\u{1cd0}'),('\u{1cd2}',''),('\u{1cda}','\u{1cda}'),('',''),('\u{1cf4}','\u{1cf4}'),('','') ];
                pub const KATAKANA:&'static [(char,char)] = &[ ('\u{305}','\u{305}'),('\u{323}','\u{323}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{3099}',''),('',''),('',''),('',''),('',''),('',''),('','\u{ff9f}'),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const KAWI:&'static [(char,char)] = &[('\u{11f00}',''),('','\u{11f3a}'),('','\u{11f5a}')];
                pub const KAYAH_LI:&'static [(char,char)] = &[('','')];
                pub const KHAROSHTHI:&'static [(char,char)] = &[ ('','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}',''),('',''),('',''),('\u{10a38}','\u{10a3a}'),('\u{10a3f}',''),('','') ];
                pub const KHITAN_SMALL_SCRIPT:&'static [(char,char)] = &[('\u{16fe4}','\u{16fe4}'),('',''),('','')];
                pub const KHMER:&'static [(char,char)] = &[('','\u{17dd}'),('',''),('',''),('','')];
                pub const KHOJKI:&'static [(char,char)] = &[('',''),('',''),('',''),('','\u{11241}')];
                pub const KHUDAWADI:&'static [(char,char)] = &[('',''),('',''),('','\u{112ea}'),('','')];
                pub const KIRAT_RAI:&'static [(char,char)] = &[('','')];
                pub const LAO:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{ec8}','\u{ece}'),('',''),('','') ];
                pub const LATIN:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{300}','\u{30e}'),('\u{310}','\u{311}'),('\u{313}','\u{313}'),('\u{320}','\u{320}'),('\u{323}','\u{325}'),('\u{32d}','\u{32e}'),('\u{330}','\u{331}'),('\u{358}','\u{358}'),('\u{35e}','\u{35e}'),('\u{363}','\u{36f}'),('\u{485}','\u{486}'),('\u{951}','\u{952}'),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1df8}','\u{1df8}'),('',''),('\u{202f}','\u{202f}'),('',''),('',''),('',''),('\u{20f0}','\u{20f0}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const LEPCHA:&'static [(char,char)] = &[('','\u{1c37}'),('',''),('','')];
                pub const LIMBU:&'static [(char,char)] = &[ ('',''),('',''),('\u{1920}',''),('','\u{193b}'),('',''),('','') ];
                pub const LINEAR_A:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
                pub const LINEAR_B:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const LISU:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('','')];
                pub const LYCIAN:&'static [(char,char)] = &[('',''),('','')];
                pub const LYDIAN:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
                pub const MAHAJANI:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
                pub const MAKASAR:&'static [(char,char)] = &[('','')];
                pub const MALAYALAM:&'static [(char,char)] = &[ ('\u{951}','\u{952}'),('',''),('\u{d00}',''),('',''),('','\u{d44}'),('',''),('',''),('','\u{d63}'),('',''),('\u{1cda}','\u{1cda}'),('',''),('','') ];
                pub const MANDAIC:&'static [(char,char)] = &[('',''),('','\u{85b}'),('','')];
                pub const MANICHAEAN:&'static [(char,char)] = &[('',''),('','\u{10ae6}'),('','')];
                pub const MARCHEN:&'static [(char,char)] = &[('',''),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}')];
                pub const MASARAM_GONDI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d47}'),('','') ];
                pub const MEDEFAIDRIN:&'static [(char,char)] = &[('','')];
                pub const MEETEI_MAYEK:&'static [(char,char)] = &[('','\u{aaf6}'),('','\u{abed}'),('','')];
                pub const MENDE_KIKAKUI:&'static [(char,char)] = &[('',''),('','\u{1e8d6}')];
                pub const MEROITIC_CURSIVE:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const MEROITIC_HIEROGLYPHS:&'static [(char,char)] = &[('',''),('','')];
                pub const MIAO:&'static [(char,char)] = &[('',''),('\u{16f4f}',''),('\u{16f8f}','')];
                pub const MODI:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const MONGOLIAN:&'static [(char,char)] = &[ ('',''),('',''),('',''),('\u{202f}','\u{202f}'),('',''),('',''),('','') ];
                pub const MRO:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const MULTANI:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('',''),('','')];
                pub const MYANMAR:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('','')];
                pub const NABATAEAN:&'static [(char,char)] = &[('',''),('','')];
                pub const NAG_MUNDARI:&'static [(char,char)] = &[('','')];
                pub const NANDINAGARI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','\u{119d7}'),('\u{119da}','') ];
                pub const NEW_TAI_LUE:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
                pub const NEWA:&'static [(char,char)] = &[('',''),('','')];
                pub const NKO:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('\u{7fd}',''),('','') ];
                pub const NUSHU:&'static [(char,char)] = &[('',''),('','')];
                pub const NYIAKENG_PUACHUE_HMONG:&'static [(char,char)] = &[('',''),('\u{1e130}',''),('',''),('','')];
                pub const OGHAM:&'static [(char,char)] = &[('\u{1680}','')];
                pub const OL_CHIKI:&'static [(char,char)] = &[('','')];
                pub const OL_ONAL:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const OLD_HUNGARIAN:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const OLD_ITALIC:&'static [(char,char)] = &[('',''),('','')];
                pub const OLD_NORTH_ARABIAN:&'static [(char,char)] = &[('','')];
                pub const OLD_PERMIC:&'static [(char,char)] = &[ ('',''),('\u{300}','\u{300}'),('\u{306}','\u{308}'),('\u{313}','\u{313}'),('\u{483}','\u{483}'),('','\u{1037a}') ];
                pub const OLD_PERSIAN:&'static [(char,char)] = &[('',''),('','')];
                pub const OLD_SOGDIAN:&'static [(char,char)] = &[('','')];
                pub const OLD_SOUTH_ARABIAN:&'static [(char,char)] = &[('','')];
                pub const OLD_TURKIC:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const OLD_UYGHUR:&'static [(char,char)] = &[('',''),('',''),('','')];
                pub const ORIYA:&'static [(char,char)] = &[ ('\u{951}','\u{952}'),('',''),('\u{b01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{b3c}','\u{b44}'),('',''),('','\u{b4d}'),('\u{b55}','\u{b57}'),('',''),('','\u{b63}'),('',''),('\u{1cda}','\u{1cda}'),('','') ];
                pub const OSAGE:&'static [(char,char)] = &[ ('\u{301}','\u{301}'),('\u{304}','\u{304}'),('\u{30b}','\u{30b}'),('\u{358}','\u{358}'),('',''),('','') ];
                pub const OSMANYA:&'static [(char,char)] = &[('',''),('','')];
                pub const PAHAWH_HMONG:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('','')];
                pub const PALMYRENE:&'static [(char,char)] = &[('','')];
                pub const PAU_CIN_HAU:&'static [(char,char)] = &[('','')];
                pub const PHAGS_PA:&'static [(char,char)] = &[ ('',''),('',''),('\u{202f}','\u{202f}'),('',''),('','') ];
                pub const PHOENICIAN:&'static [(char,char)] = &[('',''),('','')];
                pub const PSALTER_PAHLAVI:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
                pub const REJANG:&'static [(char,char)] = &[('','\u{a953}'),('','')];
                pub const RUNIC:&'static [(char,char)] = &[('','')];
                pub const SAMARITAN:&'static [(char,char)] = &[('','\u{82d}'),('',''),('','')];
                pub const SAURASHTRA:&'static [(char,char)] = &[('','\u{a8c5}'),('','')];
                pub const SHARADA:&'static [(char,char)] = &[ ('\u{951}','\u{951}'),('\u{1cd7}','\u{1cd7}'),('\u{1cd9}','\u{1cd9}'),('\u{1cdc}','\u{1cdd}'),('\u{1ce0}','\u{1ce0}'),('',''),('',''),('\u{11180}','') ];
                pub const SHAVIAN:&'static [(char,char)] = &[('',''),('','')];
                pub const SIDDHAM:&'static [(char,char)] = &[('','\u{115b5}'),('','\u{115dd}')];
                pub const SIGNWRITING:&'static [(char,char)] = &[('',''),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}')];
                pub const SINHALA:&'static [(char,char)] = &[ ('',''),('\u{d81}',''),('',''),('',''),('',''),('',''),('',''),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('',''),('',''),('','') ];
                pub const SOGDIAN:&'static [(char,char)] = &[('',''),('','')];
                pub const SORA_SOMPENG:&'static [(char,char)] = &[('',''),('','')];
                pub const SOYOMBO:&'static [(char,char)] = &[('','')];
                pub const SUNDANESE:&'static [(char,char)] = &[('\u{1b80}',''),('','')];
                pub const SUNUWAR:&'static [(char,char)] = &[ ('\u{300}','\u{301}'),('\u{303}','\u{303}'),('\u{30d}','\u{30d}'),('\u{310}','\u{310}'),('\u{32d}','\u{32d}'),('\u{331}','\u{331}'),('',''),('','') ];
                pub const SYLOTI_NAGRI:&'static [(char,char)] = &[('',''),('',''),('','\u{a82c}')];
                pub const SYRIAC:&'static [(char,char)] = &[ ('\u{303}','\u{304}'),('\u{307}','\u{308}'),('\u{30a}','\u{30a}'),('\u{320}','\u{320}'),('\u{323}','\u{325}'),('\u{32d}','\u{32e}'),('\u{330}','\u{330}'),('',''),('','\u{61c}'),('',''),('',''),('\u{64b}','\u{655}'),('\u{670}','\u{670}'),('',''),('\u{70f}','\u{74a}'),('',''),('',''),('\u{1df8}','\u{1df8}'),('\u{1dfa}','\u{1dfa}') ];
                pub const TAGALOG:&'static [(char,char)] = &[('','\u{1715}'),('',''),('','')];
                pub const TAGBANWA:&'static [(char,char)] = &[('',''),('',''),('',''),('\u{1772}','\u{1773}')];
                pub const TAI_LE:&'static [(char,char)] = &[ ('\u{300}','\u{301}'),('\u{307}','\u{308}'),('\u{30c}','\u{30c}'),('',''),('',''),('','') ];
                pub const TAI_THAM:&'static [(char,char)] = &[ ('','\u{1a5e}'),('\u{1a60}','\u{1a7c}'),('\u{1a7f}',''),('',''),('','') ];
                pub const TAI_VIET:&'static [(char,char)] = &[('',''),('','')];
                pub const TAKRI:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
                pub const TAMIL:&'static [(char,char)] = &[ ('\u{951}','\u{952}'),('',''),('\u{b82}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{bbe}',''),('',''),('','\u{bcd}'),('',''),('\u{bd7}','\u{bd7}'),('',''),('\u{1cda}','\u{1cda}'),('',''),('\u{11301}','\u{11301}'),('',''),('\u{1133b}','\u{1133c}'),('',''),('','') ];
                pub const TANGSA:&'static [(char,char)] = &[('',''),('','')];
                pub const TANGUT:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const TELUGU:&'static [(char,char)] = &[ ('\u{951}','\u{952}'),('',''),('\u{c00}',''),('',''),('',''),('',''),('\u{c3c}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('',''),('',''),('','\u{c63}'),('',''),('',''),('\u{1cda}','\u{1cda}'),('','') ];
                pub const THAANA:&'static [(char,char)] = &[ ('',''),('','\u{61c}'),('',''),('',''),('',''),('',''),('','') ];
                pub const THAI:&'static [(char,char)] = &[ ('',''),('',''),('\u{303}','\u{303}'),('\u{331}','\u{331}'),('','\u{e3a}'),('','') ];
                pub const TIBETAN:&'static [(char,char)] = &[ ('',''),('',''),('\u{f71}','\u{f97}'),('\u{f99}','\u{fbc}'),('',''),('',''),('',''),('','') ];
                pub const TIFINAGH:&'static [(char,char)] = &[ ('\u{302}','\u{302}'),('\u{304}','\u{304}'),('\u{307}','\u{307}'),('\u{309}','\u{309}'),('',''),('',''),('\u{2d7f}','\u{2d7f}') ];
                pub const TIRHUTA:&'static [(char,char)] = &[ ('\u{951}','\u{952}'),('',''),('',''),('',''),('',''),('','') ];
                pub const TODHRI:&'static [(char,char)] = &[ ('\u{301}','\u{301}'),('\u{304}','\u{304}'),('\u{307}','\u{307}'),('\u{311}','\u{311}'),('\u{313}','\u{313}'),('\u{35e}','\u{35e}'),('','') ];
                pub const TOTO:&'static [(char,char)] = &[('',''),('','\u{1e2ae}')];
                pub const TULU_TIGALARI:&'static [(char,char)] = &[ ('',''),('',''),('\u{1cf4}','\u{1cf4}'),('',''),('\u{a8f1}','\u{a8f1}'),('',''),('',''),('',''),('',''),('','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('',''),('',''),('\u{113e1}','\u{113e2}') ];
                pub const UGARITIC:&'static [(char,char)] = &[('',''),('','')];
                pub const VAI:&'static [(char,char)] = &[('','')];
                pub const VITHKUQI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const WANCHO:&'static [(char,char)] = &[('',''),('','')];
                pub const WARANG_CITI:&'static [(char,char)] = &[('',''),('','')];
                pub const YEZIDI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('\u{10eab}',''),('','') ];
                pub const YI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
                pub const ZANABAZAR_SQUARE:&'static [(char,char)] = &[('','\u{11a47}')];
            }
            
            pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] = &[ ("Adlam", ADLAM),("Ahom", AHOM),("Anatolian_Hieroglyphs", ANATOLIAN_HIEROGLYPHS),("Arabic", ARABIC),("Armenian", ARMENIAN),("Avestan", AVESTAN),("Balinese", BALINESE),("Bamum", BAMUM),("Bassa_Vah", BASSA_VAH),("Batak", BATAK),("Bengali", BENGALI),("Bhaiksuki", BHAIKSUKI),("Bopomofo", BOPOMOFO),("Brahmi", BRAHMI),("Braille", BRAILLE),("Buginese", BUGINESE),("Buhid", BUHID),("Canadian_Aboriginal", CANADIAN_ABORIGINAL),("Carian", CARIAN),("Caucasian_Albanian", CAUCASIAN_ALBANIAN),("Chakma", CHAKMA),("Cham", CHAM),("Cherokee", CHEROKEE),("Chorasmian", CHORASMIAN),("Common", COMMON),("Coptic", COPTIC),("Cuneiform", CUNEIFORM),("Cypriot", CYPRIOT),("Cypro_Minoan", CYPRO_MINOAN),("Cyrillic", CYRILLIC),("Deseret", DESERET),("Devanagari", DEVANAGARI),("Dives_Akuru", DIVES_AKURU),("Dogra", DOGRA),("Duployan", DUPLOYAN),("Egyptian_Hieroglyphs", EGYPTIAN_HIEROGLYPHS),("Elbasan", ELBASAN),("Elymaic", ELYMAIC),("Ethiopic", ETHIOPIC),("Garay", GARAY),("Georgian", GEORGIAN),("Glagolitic", GLAGOLITIC),("Gothic", GOTHIC),("Grantha", GRANTHA),("Greek", GREEK),("Gujarati", GUJARATI),("Gunjala_Gondi", GUNJALA_GONDI),("Gurmukhi", GURMUKHI),("Gurung_Khema", GURUNG_KHEMA),("Han", HAN),("Hangul", HANGUL),("Hanifi_Rohingya", HANIFI_ROHINGYA),("Hanunoo", HANUNOO),("Hatran", HATRAN),("Hebrew", HEBREW),("Hiragana", HIRAGANA),("Imperial_Aramaic", IMPERIAL_ARAMAIC),("Inherited", INHERITED),("Inscriptional_Pahlavi", INSCRIPTIONAL_PAHLAVI),("Inscriptional_Parthian", INSCRIPTIONAL_PARTHIAN),("Javanese", JAVANESE),("Kaithi", KAITHI),("Kannada", KANNADA),("Katakana", KATAKANA),("Kawi", KAWI),("Kayah_Li", KAYAH_LI),("Kharoshthi", KHAROSHTHI),("Khitan_Small_Script", KHITAN_SMALL_SCRIPT),("Khmer", KHMER),("Khojki", KHOJKI),("Khudawadi", KHUDAWADI),("Kirat_Rai", KIRAT_RAI),("Lao", LAO),("Latin", LATIN),("Lepcha", LEPCHA),("Limbu", LIMBU),("Linear_A", LINEAR_A),("Linear_B", LINEAR_B),("Lisu", LISU),("Lycian", LYCIAN),("Lydian", LYDIAN),("Mahajani", MAHAJANI),("Makasar", MAKASAR),("Malayalam", MALAYALAM),("Mandaic", MANDAIC),("Manichaean", MANICHAEAN),("Marchen", MARCHEN),("Masaram_Gondi", MASARAM_GONDI),("Medefaidrin", MEDEFAIDRIN),("Meetei_Mayek", MEETEI_MAYEK),("Mende_Kikakui", MENDE_KIKAKUI),("Meroitic_Cursive", MEROITIC_CURSIVE),("Meroitic_Hieroglyphs", MEROITIC_HIEROGLYPHS),("Miao", MIAO),("Modi", MODI),("Mongolian", MONGOLIAN),("Mro", MRO),("Multani", MULTANI),("Myanmar", MYANMAR),("Nabataean", NABATAEAN),("Nag_Mundari", NAG_MUNDARI),("Nandinagari", NANDINAGARI),("New_Tai_Lue", NEW_TAI_LUE),("Newa", NEWA),("Nko", NKO),("Nushu", NUSHU),("Nyiakeng_Puachue_Hmong", NYIAKENG_PUACHUE_HMONG),("Ogham", OGHAM),("Ol_Chiki", OL_CHIKI),("Ol_Onal", OL_ONAL),("Old_Hungarian", OLD_HUNGARIAN),("Old_Italic", OLD_ITALIC),("Old_North_Arabian", OLD_NORTH_ARABIAN),("Old_Permic", OLD_PERMIC),("Old_Persian", OLD_PERSIAN),("Old_Sogdian", OLD_SOGDIAN),("Old_South_Arabian", OLD_SOUTH_ARABIAN),("Old_Turkic", OLD_TURKIC),("Old_Uyghur", OLD_UYGHUR),("Oriya", ORIYA),("Osage", OSAGE),("Osmanya", OSMANYA),("Pahawh_Hmong", PAHAWH_HMONG),("Palmyrene", PALMYRENE),("Pau_Cin_Hau", PAU_CIN_HAU),("Phags_Pa", PHAGS_PA),("Phoenician", PHOENICIAN),("Psalter_Pahlavi", PSALTER_PAHLAVI),("Rejang", REJANG),("Runic", RUNIC),("Samaritan", SAMARITAN),("Saurashtra", SAURASHTRA),("Sharada", SHARADA),("Shavian", SHAVIAN),("Siddham", SIDDHAM),("SignWriting", SIGNWRITING),("Sinhala", SINHALA),("Sogdian", SOGDIAN),("Sora_Sompeng", SORA_SOMPENG),("Soyombo", SOYOMBO),("Sundanese", SUNDANESE),("Sunuwar", SUNUWAR),("Syloti_Nagri", SYLOTI_NAGRI),("Syriac", SYRIAC),("Tagalog", TAGALOG),("Tagbanwa", TAGBANWA),("Tai_Le", TAI_LE),("Tai_Tham", TAI_THAM),("Tai_Viet", TAI_VIET),("Takri", TAKRI),("Tamil", TAMIL),("Tangsa", TANGSA),("Tangut", TANGUT),("Telugu", TELUGU),("Thaana", THAANA),("Thai", THAI),("Tibetan", TIBETAN),("Tifinagh", TIFINAGH),("Tirhuta", TIRHUTA),("Todhri", TODHRI),("Toto", TOTO),("Tulu_Tigalari", TULU_TIGALARI),("Ugaritic", UGARITIC),("Vai", VAI),("Vithkuqi", VITHKUQI),("Wancho", WANCHO),("Warang_Citi", WARANG_CITI),("Yezidi", YEZIDI),("Yi", YI),("Zanabazar_Square", ZANABAZAR_SQUARE) ];
            pub const ADLAM:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const AHOM:&'static [(char,char)] = &[('',''),('\u{1171d}','\u{1172b}'),('','')];
            pub const ANATOLIAN_HIEROGLYPHS:&'static [(char,char)] = &[('','')];
            pub const ARABIC:&'static [(char,char)] = &[ ('\u{600}','\u{604}'),('',''),('','\u{61a}'),('\u{61c}',''),('',''),('',''),('\u{656}',''),('','\u{6dc}'),('',''),('',''),('',''),('\u{890}','\u{891}'),('\u{897}','\u{8e1}'),('\u{8e3}','\u{8ff}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{10efc}','\u{10eff}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const ARMENIAN:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
            pub const AVESTAN:&'static [(char,char)] = &[('',''),('','')];
            pub const BALINESE:&'static [(char,char)] = &[('\u{1b00}',''),('','')];
            pub const BAMUM:&'static [(char,char)] = &[('',''),('','')];
            pub const BASSA_VAH:&'static [(char,char)] = &[('',''),('\u{16af0}','')];
            pub const BATAK:&'static [(char,char)] = &[('','\u{1bf3}'),('','')];
            pub const BENGALI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{9bc}','\u{9c4}'),('',''),('',''),('\u{9d7}','\u{9d7}'),('',''),('','\u{9e3}'),('','\u{9fe}') ];
            pub const BHAIKSUKI:&'static [(char,char)] = &[('',''),('','\u{11c36}'),('\u{11c38}',''),('','')];
            pub const BOPOMOFO:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const BRAHMI:&'static [(char,char)] = &[('',''),('',''),('\u{1107f}','\u{1107f}')];
            pub const BRAILLE:&'static [(char,char)] = &[('','')];
            pub const BUGINESE:&'static [(char,char)] = &[('','\u{1a1b}'),('','')];
            pub const BUHID:&'static [(char,char)] = &[('','\u{1753}')];
            pub const CANADIAN_ABORIGINAL:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const CARIAN:&'static [(char,char)] = &[('','')];
            pub const CAUCASIAN_ALBANIAN:&'static [(char,char)] = &[('',''),('','')];
            pub const CHAKMA:&'static [(char,char)] = &[('\u{11100}','\u{11134}'),('','')];
            pub const CHAM:&'static [(char,char)] = &[('','\u{aa36}'),('',''),('',''),('','')];
            pub const CHEROKEE:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const CHORASMIAN:&'static [(char,char)] = &[('','')];
            pub const COMMON:&'static [(char,char)] = &[ ('\0','@'),('[','`'),('{',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{605}','\u{605}'),('',''),('',''),('',''),('',''),('\u{6dd}','\u{6dd}'),('\u{8e2}','\u{8e2}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{2000}','\u{200b}'),('\u{200e}','\u{2064}'),('\u{2066}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{feff}','\u{feff}'),('',''),('',''),('',''),('',''),('\u{ff9e}','\u{ff9f}'),('',''),('',''),('\u{fff9}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1bca0}','\u{1bca3}'),('',''),('',''),('',''),('',''),('',''),('','\u{1d166}'),('','\u{1d17a}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{e0001}','\u{e0001}'),('\u{e0020}','\u{e007f}') ];
            pub const COPTIC:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const CUNEIFORM:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
            pub const CYPRIOT:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('',''),('','')];
            pub const CYPRO_MINOAN:&'static [(char,char)] = &[('','')];
            pub const CYRILLIC:&'static [(char,char)] = &[ ('','\u{484}'),('\u{487}',''),('',''),('',''),('',''),('\u{2de0}','\u{2dff}'),('','\u{a69f}'),('\u{fe2e}','\u{fe2f}'),('',''),('\u{1e08f}','\u{1e08f}') ];
            pub const DESERET:&'static [(char,char)] = &[('','')];
            pub const DEVANAGARI:&'static [(char,char)] = &[ ('\u{900}',''),('\u{955}','\u{963}'),('',''),('\u{a8e0}','\u{a8ff}'),('','') ];
            pub const DIVES_AKURU:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('\u{1193b}',''),('','') ];
            pub const DOGRA:&'static [(char,char)] = &[('','')];
            pub const DUPLOYAN:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('','')];
            pub const EGYPTIAN_HIEROGLYPHS:&'static [(char,char)] = &[('','\u{13455}'),('','')];
            pub const ELBASAN:&'static [(char,char)] = &[('','')];
            pub const ELYMAIC:&'static [(char,char)] = &[('','')];
            pub const ETHIOPIC:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{135d}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const GARAY:&'static [(char,char)] = &[('',''),('\u{10d69}',''),('','')];
            pub const GEORGIAN:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const GLAGOLITIC:&'static [(char,char)] = &[ ('',''),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}') ];
            pub const GOTHIC:&'static [(char,char)] = &[('','')];
            pub const GRANTHA:&'static [(char,char)] = &[ ('\u{11300}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{1133c}',''),('',''),('','\u{1134d}'),('',''),('\u{11357}','\u{11357}'),('',''),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}') ];
            pub const GREEK:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const GUJARATI:&'static [(char,char)] = &[ ('\u{a81}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{abc}','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('',''),('','\u{ae3}'),('',''),('','\u{aff}') ];
            pub const GUNJALA_GONDI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('\u{11d90}','\u{11d91}'),('',''),('','') ];
            pub const GURMUKHI:&'static [(char,char)] = &[ ('\u{a01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('',''),('',''),('','') ];
            pub const GURUNG_KHEMA:&'static [(char,char)] = &[('','')];
            pub const HAN:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{16ff0}','\u{16ff1}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const HANGUL:&'static [(char,char)] = &[ ('',''),('\u{302e}','\u{302f}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const HANIFI_ROHINGYA:&'static [(char,char)] = &[('','\u{10d27}'),('','')];
            pub const HANUNOO:&'static [(char,char)] = &[('','\u{1734}')];
            pub const HATRAN:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const HEBREW:&'static [(char,char)] = &[ ('\u{591}','\u{5c7}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const HIRAGANA:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const IMPERIAL_ARAMAIC:&'static [(char,char)] = &[('',''),('','')];
            pub const INHERITED:&'static [(char,char)] = &[ ('\u{300}','\u{36f}'),('\u{485}','\u{486}'),('\u{64b}','\u{655}'),('\u{670}','\u{670}'),('\u{951}','\u{954}'),('\u{1ab0}','\u{1ace}'),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}','\u{1ce0}'),('\u{1ce2}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('\u{1cf8}','\u{1cf9}'),('\u{1dc0}','\u{1dff}'),('\u{200c}','\u{200d}'),('\u{20d0}','\u{20f0}'),('\u{302a}','\u{302d}'),('\u{3099}','\u{309a}'),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2d}'),('\u{101fd}','\u{101fd}'),('\u{102e0}','\u{102e0}'),('\u{1133b}','\u{1133b}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d167}','\u{1d169}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{e0100}','\u{e01ef}') ];
            pub const INSCRIPTIONAL_PAHLAVI:&'static [(char,char)] = &[('',''),('','')];
            pub const INSCRIPTIONAL_PARTHIAN:&'static [(char,char)] = &[('',''),('','')];
            pub const JAVANESE:&'static [(char,char)] = &[('\u{a980}',''),('',''),('','')];
            pub const KAITHI:&'static [(char,char)] = &[('\u{11080}','\u{110c2}'),('\u{110cd}','\u{110cd}')];
            pub const KANNADA:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('\u{cbc}',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('',''),('','\u{ce3}'),('',''),('','') ];
            pub const KATAKANA:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const KAWI:&'static [(char,char)] = &[('\u{11f00}',''),('','\u{11f3a}'),('','\u{11f5a}')];
            pub const KAYAH_LI:&'static [(char,char)] = &[('','\u{a92d}'),('','')];
            pub const KHAROSHTHI:&'static [(char,char)] = &[ ('','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}',''),('',''),('',''),('\u{10a38}','\u{10a3a}'),('\u{10a3f}',''),('','') ];
            pub const KHITAN_SMALL_SCRIPT:&'static [(char,char)] = &[('\u{16fe4}','\u{16fe4}'),('',''),('','')];
            pub const KHMER:&'static [(char,char)] = &[('','\u{17dd}'),('',''),('',''),('','')];
            pub const KHOJKI:&'static [(char,char)] = &[('',''),('','\u{11241}')];
            pub const KHUDAWADI:&'static [(char,char)] = &[('','\u{112ea}'),('','')];
            pub const KIRAT_RAI:&'static [(char,char)] = &[('','')];
            pub const LAO:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{ec8}','\u{ece}'),('',''),('','') ];
            pub const LATIN:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const LEPCHA:&'static [(char,char)] = &[('','\u{1c37}'),('',''),('','')];
            pub const LIMBU:&'static [(char,char)] = &[ ('',''),('\u{1920}',''),('','\u{193b}'),('',''),('','') ];
            pub const LINEAR_A:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const LINEAR_B:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const LISU:&'static [(char,char)] = &[('',''),('','')];
            pub const LYCIAN:&'static [(char,char)] = &[('','')];
            pub const LYDIAN:&'static [(char,char)] = &[('',''),('','')];
            pub const MAHAJANI:&'static [(char,char)] = &[('','')];
            pub const MAKASAR:&'static [(char,char)] = &[('','')];
            pub const MALAYALAM:&'static [(char,char)] = &[ ('\u{d00}',''),('',''),('','\u{d44}'),('',''),('',''),('','\u{d63}'),('','') ];
            pub const MANDAIC:&'static [(char,char)] = &[('','\u{85b}'),('','')];
            pub const MANICHAEAN:&'static [(char,char)] = &[('','\u{10ae6}'),('','')];
            pub const MARCHEN:&'static [(char,char)] = &[('',''),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}')];
            pub const MASARAM_GONDI:&'static [(char,char)] = &[ ('',''),('',''),('','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d47}'),('','') ];
            pub const MEDEFAIDRIN:&'static [(char,char)] = &[('','')];
            pub const MEETEI_MAYEK:&'static [(char,char)] = &[('','\u{aaf6}'),('','\u{abed}'),('','')];
            pub const MENDE_KIKAKUI:&'static [(char,char)] = &[('',''),('','\u{1e8d6}')];
            pub const MEROITIC_CURSIVE:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const MEROITIC_HIEROGLYPHS:&'static [(char,char)] = &[('','')];
            pub const MIAO:&'static [(char,char)] = &[('',''),('\u{16f4f}',''),('\u{16f8f}','')];
            pub const MODI:&'static [(char,char)] = &[('',''),('','')];
            pub const MONGOLIAN:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('',''),('','')];
            pub const MRO:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const MULTANI:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('','')];
            pub const MYANMAR:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
            pub const NABATAEAN:&'static [(char,char)] = &[('',''),('','')];
            pub const NAG_MUNDARI:&'static [(char,char)] = &[('','')];
            pub const NANDINAGARI:&'static [(char,char)] = &[('',''),('','\u{119d7}'),('\u{119da}','')];
            pub const NEW_TAI_LUE:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
            pub const NEWA:&'static [(char,char)] = &[('',''),('','')];
            pub const NKO:&'static [(char,char)] = &[('',''),('\u{7fd}','')];
            pub const NUSHU:&'static [(char,char)] = &[('',''),('','')];
            pub const NYIAKENG_PUACHUE_HMONG:&'static [(char,char)] = &[('',''),('\u{1e130}',''),('',''),('','')];
            pub const OGHAM:&'static [(char,char)] = &[('\u{1680}','')];
            pub const OL_CHIKI:&'static [(char,char)] = &[('','')];
            pub const OL_ONAL:&'static [(char,char)] = &[('',''),('','')];
            pub const OLD_HUNGARIAN:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const OLD_ITALIC:&'static [(char,char)] = &[('',''),('','')];
            pub const OLD_NORTH_ARABIAN:&'static [(char,char)] = &[('','')];
            pub const OLD_PERMIC:&'static [(char,char)] = &[('','\u{1037a}')];
            pub const OLD_PERSIAN:&'static [(char,char)] = &[('',''),('','')];
            pub const OLD_SOGDIAN:&'static [(char,char)] = &[('','')];
            pub const OLD_SOUTH_ARABIAN:&'static [(char,char)] = &[('','')];
            pub const OLD_TURKIC:&'static [(char,char)] = &[('','')];
            pub const OLD_UYGHUR:&'static [(char,char)] = &[('','')];
            pub const ORIYA:&'static [(char,char)] = &[ ('\u{b01}',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{b3c}','\u{b44}'),('',''),('','\u{b4d}'),('\u{b55}','\u{b57}'),('',''),('','\u{b63}'),('','') ];
            pub const OSAGE:&'static [(char,char)] = &[('',''),('','')];
            pub const OSMANYA:&'static [(char,char)] = &[('',''),('','')];
            pub const PAHAWH_HMONG:&'static [(char,char)] = &[('',''),('',''),('',''),('',''),('','')];
            pub const PALMYRENE:&'static [(char,char)] = &[('','')];
            pub const PAU_CIN_HAU:&'static [(char,char)] = &[('','')];
            pub const PHAGS_PA:&'static [(char,char)] = &[('','')];
            pub const PHOENICIAN:&'static [(char,char)] = &[('',''),('','')];
            pub const PSALTER_PAHLAVI:&'static [(char,char)] = &[('',''),('',''),('','')];
            pub const REJANG:&'static [(char,char)] = &[('','\u{a953}'),('','')];
            pub const RUNIC:&'static [(char,char)] = &[('',''),('','')];
            pub const SAMARITAN:&'static [(char,char)] = &[('','\u{82d}'),('','')];
            pub const SAURASHTRA:&'static [(char,char)] = &[('','\u{a8c5}'),('','')];
            pub const SHARADA:&'static [(char,char)] = &[('\u{11180}','')];
            pub const SHAVIAN:&'static [(char,char)] = &[('','')];
            pub const SIDDHAM:&'static [(char,char)] = &[('','\u{115b5}'),('','\u{115dd}')];
            pub const SIGNWRITING:&'static [(char,char)] = &[('',''),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}')];
            pub const SINHALA:&'static [(char,char)] = &[ ('\u{d81}',''),('',''),('',''),('',''),('',''),('',''),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('',''),('','') ];
            pub const SOGDIAN:&'static [(char,char)] = &[('','')];
            pub const SORA_SOMPENG:&'static [(char,char)] = &[('',''),('','')];
            pub const SOYOMBO:&'static [(char,char)] = &[('','')];
            pub const SUNDANESE:&'static [(char,char)] = &[('\u{1b80}',''),('','')];
            pub const SUNUWAR:&'static [(char,char)] = &[('',''),('','')];
            pub const SYLOTI_NAGRI:&'static [(char,char)] = &[('','\u{a82c}')];
            pub const SYRIAC:&'static [(char,char)] = &[('',''),('\u{70f}','\u{74a}'),('',''),('','')];
            pub const TAGALOG:&'static [(char,char)] = &[('','\u{1715}'),('','')];
            pub const TAGBANWA:&'static [(char,char)] = &[('',''),('',''),('\u{1772}','\u{1773}')];
            pub const TAI_LE:&'static [(char,char)] = &[('',''),('','')];
            pub const TAI_THAM:&'static [(char,char)] = &[ ('','\u{1a5e}'),('\u{1a60}','\u{1a7c}'),('\u{1a7f}',''),('',''),('','') ];
            pub const TAI_VIET:&'static [(char,char)] = &[('',''),('','')];
            pub const TAKRI:&'static [(char,char)] = &[('',''),('','')];
            pub const TAMIL:&'static [(char,char)] = &[ ('\u{b82}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{bbe}',''),('',''),('','\u{bcd}'),('',''),('\u{bd7}','\u{bd7}'),('',''),('',''),('','') ];
            pub const TANGSA:&'static [(char,char)] = &[('',''),('','')];
            pub const TANGUT:&'static [(char,char)] = &[('',''),('',''),('',''),('','')];
            pub const TELUGU:&'static [(char,char)] = &[ ('\u{c00}',''),('',''),('',''),('',''),('\u{c3c}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('',''),('',''),('','\u{c63}'),('',''),('','') ];
            pub const THAANA:&'static [(char,char)] = &[('','')];
            pub const THAI:&'static [(char,char)] = &[('','\u{e3a}'),('','')];
            pub const TIBETAN:&'static [(char,char)] = &[ ('',''),('',''),('\u{f71}','\u{f97}'),('\u{f99}','\u{fbc}'),('',''),('',''),('','') ];
            pub const TIFINAGH:&'static [(char,char)] = &[('',''),('',''),('\u{2d7f}','\u{2d7f}')];
            pub const TIRHUTA:&'static [(char,char)] = &[('',''),('','')];
            pub const TODHRI:&'static [(char,char)] = &[('','')];
            pub const TOTO:&'static [(char,char)] = &[('','\u{1e2ae}')];
            pub const TULU_TIGALARI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('',''),('',''),('\u{113e1}','\u{113e2}') ];
            pub const UGARITIC:&'static [(char,char)] = &[('',''),('','')];
            pub const VAI:&'static [(char,char)] = &[('','')];
            pub const VITHKUQI:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('','') ];
            pub const WANCHO:&'static [(char,char)] = &[('',''),('','')];
            pub const WARANG_CITI:&'static [(char,char)] = &[('',''),('','')];
            pub const YEZIDI:&'static [(char,char)] = &[('',''),('\u{10eab}',''),('','')];
            pub const YI:&'static [(char,char)] = &[('',''),('','')];
            pub const ZANABAZAR_SQUARE:&'static [(char,char)] = &[('','\u{11a47}')];
        }

        pub mod sentence
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] = &[ ("ATerm", ATERM), ("CR", CR), ("Close", CLOSE), ("Extend", EXTEND), ("Format", FORMAT), ("LF", LF), ("Lower", LOWER), ("Numeric", NUMERIC), ("OLetter", OLETTER), ("SContinue", SCONTINUE), ("STerm", STERM), ("Sep", SEP), ("Sp", SP), ("Upper", UPPER) ];
            pub const ATERM:&'static [(char,char)] = &[('.','.'),('',''),('',''),('','')];
            pub const CR:&'static [(char,char)] = &[('\r','\r')];
            pub const CLOSE:&'static [(char,char)] = &[ ('"','"'),('\'',')'),('[','['),(']',']'),('{','{'),('}','}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const EXTEND:&'static [(char,char)] = &[ ('\u{300}','\u{36f}'),('\u{483}','\u{489}'),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('\u{610}','\u{61a}'),('\u{64b}','\u{65f}'),('\u{670}','\u{670}'),('\u{6d6}','\u{6dc}'),('\u{6df}','\u{6e4}'),('\u{6e7}','\u{6e8}'),('\u{6ea}','\u{6ed}'),('\u{711}','\u{711}'),('\u{730}','\u{74a}'),('\u{7a6}','\u{7b0}'),('\u{7eb}','\u{7f3}'),('\u{7fd}','\u{7fd}'),('\u{816}','\u{819}'),('\u{81b}','\u{823}'),('\u{825}','\u{827}'),('\u{829}','\u{82d}'),('\u{859}','\u{85b}'),('\u{897}','\u{89f}'),('\u{8ca}','\u{8e1}'),('\u{8e3}',''),('\u{93a}','\u{93c}'),('',''),('\u{951}','\u{957}'),('\u{962}','\u{963}'),('\u{981}',''),('\u{9bc}','\u{9bc}'),('\u{9be}','\u{9c4}'),('',''),('','\u{9cd}'),('\u{9d7}','\u{9d7}'),('\u{9e2}','\u{9e3}'),('\u{9fe}','\u{9fe}'),('\u{a01}',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('\u{a70}','\u{a71}'),('\u{a75}','\u{a75}'),('\u{a81}',''),('\u{abc}','\u{abc}'),('','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('\u{ae2}','\u{ae3}'),('\u{afa}','\u{aff}'),('\u{b01}',''),('\u{b3c}','\u{b3c}'),('\u{b3e}','\u{b44}'),('',''),('','\u{b4d}'),('\u{b55}','\u{b57}'),('\u{b62}','\u{b63}'),('\u{b82}','\u{b82}'),('\u{bbe}',''),('',''),('','\u{bcd}'),('\u{bd7}','\u{bd7}'),('\u{c00}','\u{c04}'),('\u{c3c}','\u{c3c}'),('\u{c3e}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('\u{c62}','\u{c63}'),('\u{c81}',''),('\u{cbc}','\u{cbc}'),('',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('\u{ce2}','\u{ce3}'),('',''),('\u{d00}',''),('\u{d3b}','\u{d3c}'),('\u{d3e}','\u{d44}'),('',''),('','\u{d4d}'),('\u{d57}','\u{d57}'),('\u{d62}','\u{d63}'),('\u{d81}',''),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('\u{e31}','\u{e31}'),('\u{e34}','\u{e3a}'),('\u{e47}','\u{e4e}'),('\u{eb1}','\u{eb1}'),('\u{eb4}','\u{ebc}'),('\u{ec8}','\u{ece}'),('\u{f18}','\u{f19}'),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('',''),('\u{f71}','\u{f84}'),('\u{f86}','\u{f87}'),('\u{f8d}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('','\u{103e}'),('','\u{1059}'),('\u{105e}','\u{1060}'),('',''),('',''),('\u{1071}','\u{1074}'),('\u{1082}','\u{108d}'),('',''),('','\u{109d}'),('\u{135d}','\u{135f}'),('\u{1712}','\u{1715}'),('\u{1732}','\u{1734}'),('\u{1752}','\u{1753}'),('\u{1772}','\u{1773}'),('\u{17b4}','\u{17d3}'),('\u{17dd}','\u{17dd}'),('\u{180b}','\u{180d}'),('\u{180f}','\u{180f}'),('\u{1885}','\u{1886}'),('\u{18a9}','\u{18a9}'),('\u{1920}',''),('','\u{193b}'),('\u{1a17}','\u{1a1b}'),('','\u{1a5e}'),('\u{1a60}','\u{1a7c}'),('\u{1a7f}','\u{1a7f}'),('\u{1ab0}','\u{1ace}'),('\u{1b00}',''),('\u{1b34}','\u{1b44}'),('\u{1b6b}','\u{1b73}'),('\u{1b80}',''),('','\u{1bad}'),('\u{1be6}','\u{1bf3}'),('','\u{1c37}'),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('','\u{1cf9}'),('\u{1dc0}','\u{1dff}'),('\u{200c}','\u{200d}'),('\u{20d0}','\u{20f0}'),('\u{2cef}','\u{2cf1}'),('\u{2d7f}','\u{2d7f}'),('\u{2de0}','\u{2dff}'),('\u{302a}','\u{302f}'),('\u{3099}','\u{309a}'),('\u{a66f}','\u{a672}'),('\u{a674}','\u{a67d}'),('\u{a69e}','\u{a69f}'),('\u{a6f0}','\u{a6f1}'),('\u{a802}','\u{a802}'),('\u{a806}','\u{a806}'),('\u{a80b}','\u{a80b}'),('',''),('\u{a82c}','\u{a82c}'),('',''),('','\u{a8c5}'),('\u{a8e0}','\u{a8f1}'),('\u{a8ff}','\u{a8ff}'),('\u{a926}','\u{a92d}'),('\u{a947}','\u{a953}'),('\u{a980}',''),('\u{a9b3}','\u{a9c0}'),('\u{a9e5}','\u{a9e5}'),('\u{aa29}','\u{aa36}'),('\u{aa43}','\u{aa43}'),('\u{aa4c}',''),('',''),('\u{aab0}','\u{aab0}'),('\u{aab2}','\u{aab4}'),('\u{aab7}','\u{aab8}'),('\u{aabe}','\u{aabf}'),('\u{aac1}','\u{aac1}'),('',''),('','\u{aaf6}'),('',''),('','\u{abed}'),('\u{fb1e}','\u{fb1e}'),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('\u{ff9e}','\u{ff9f}'),('\u{101fd}','\u{101fd}'),('\u{102e0}','\u{102e0}'),('\u{10376}','\u{1037a}'),('\u{10a01}','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}','\u{10a0f}'),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('\u{10ae5}','\u{10ae6}'),('\u{10d24}','\u{10d27}'),('\u{10d69}','\u{10d6d}'),('\u{10eab}','\u{10eac}'),('\u{10efc}','\u{10eff}'),('\u{10f46}','\u{10f50}'),('\u{10f82}','\u{10f85}'),('',''),('\u{11038}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{11073}','\u{11074}'),('\u{1107f}',''),('','\u{110ba}'),('\u{110c2}','\u{110c2}'),('\u{11100}','\u{11102}'),('\u{11127}','\u{11134}'),('',''),('\u{11173}','\u{11173}'),('\u{11180}',''),('','\u{111c0}'),('\u{111c9}','\u{111cc}'),('','\u{111cf}'),('','\u{11237}'),('\u{1123e}','\u{1123e}'),('\u{11241}','\u{11241}'),('\u{112df}','\u{112ea}'),('\u{11300}',''),('\u{1133b}','\u{1133c}'),('\u{1133e}',''),('',''),('','\u{1134d}'),('\u{11357}','\u{11357}'),('',''),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('\u{113b8}','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('','\u{113d0}'),('\u{113d2}','\u{113d2}'),('\u{113e1}','\u{113e2}'),('','\u{11446}'),('\u{1145e}','\u{1145e}'),('\u{114b0}','\u{114c3}'),('\u{115af}','\u{115b5}'),('','\u{115c0}'),('\u{115dc}','\u{115dd}'),('','\u{11640}'),('\u{116ab}','\u{116b7}'),('\u{1171d}','\u{1172b}'),('','\u{1183a}'),('\u{11930}',''),('',''),('\u{1193b}','\u{1193e}'),('',''),('','\u{11943}'),('','\u{119d7}'),('\u{119da}','\u{119e0}'),('',''),('\u{11a01}','\u{11a0a}'),('\u{11a33}',''),('\u{11a3b}','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('\u{11a51}','\u{11a5b}'),('\u{11a8a}','\u{11a99}'),('','\u{11c36}'),('\u{11c38}','\u{11c3f}'),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),('\u{11d31}','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d45}'),('\u{11d47}','\u{11d47}'),('',''),('\u{11d90}','\u{11d91}'),('','\u{11d97}'),('\u{11ef3}',''),('\u{11f00}','\u{11f01}'),('',''),('','\u{11f3a}'),('','\u{11f42}'),('\u{11f5a}','\u{11f5a}'),('\u{13440}','\u{13440}'),('\u{13447}','\u{13455}'),('\u{1611e}','\u{1612f}'),('\u{16af0}','\u{16af4}'),('\u{16b30}','\u{16b36}'),('\u{16f4f}','\u{16f4f}'),('',''),('\u{16f8f}','\u{16f92}'),('\u{16fe4}','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('\u{1bc9d}','\u{1bc9e}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d165}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('\u{1e08f}','\u{1e08f}'),('\u{1e130}','\u{1e136}'),('\u{1e2ae}','\u{1e2ae}'),('\u{1e2ec}','\u{1e2ef}'),('\u{1e4ec}','\u{1e4ef}'),('\u{1e5ee}','\u{1e5ef}'),('\u{1e8d0}','\u{1e8d6}'),('\u{1e944}','\u{1e94a}'),('\u{e0020}','\u{e007f}'),('\u{e0100}','\u{e01ef}'), ];
            pub const FORMAT:&'static [(char,char)] = &[ ('\u{ad}','\u{ad}'),('\u{61c}','\u{61c}'),('\u{70f}','\u{70f}'),('\u{180e}','\u{180e}'),('\u{200b}','\u{200b}'),('\u{200e}','\u{200f}'),('\u{202a}','\u{202e}'),('\u{2060}','\u{2064}'),('\u{2066}','\u{206f}'),('\u{feff}','\u{feff}'),('\u{fff9}','\u{fffb}'),('\u{13430}','\u{1343f}'),('\u{1bca0}','\u{1bca3}'),('\u{1d173}','\u{1d17a}'),('\u{e0001}','\u{e0001}'), ];
            pub const LF:&'static [(char,char)] = &[('\n','\n')];
            pub const LOWER:&'static [(char,char)] = &[ ('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const NUMERIC:&'static [(char,char)] = &[ ('0','9'),('\u{600}','\u{605}'),('',''),('',''),('\u{6dd}','\u{6dd}'),('',''),('',''),('\u{890}','\u{891}'),('\u{8e2}','\u{8e2}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{110bd}','\u{110bd}'),('\u{110cd}','\u{110cd}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const OLETTER:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const SCONTINUE:&'static [(char,char)] = &[ (',','-'),(':',';'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const STERM:&'static [(char,char)] = &[ ('!','!'),('?','?'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const SEP:&'static [(char,char)] = &[('\u{85}','\u{85}'),('\u{2028}','\u{2029}')];
            pub const SP:&'static [(char,char)] = &[ ('\t','\t'),('\u{b}','\u{c}'),(' ',' '),('\u{a0}','\u{a0}'),('\u{1680}','\u{1680}'),('\u{2000}','\u{200a}'),('\u{202f}','\u{202f}'),('\u{205f}','\u{205f}'),('\u{3000}','\u{3000}'), ];
            pub const UPPER:&'static [(char,char)] = &[ ('A','Z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
        }

        pub mod word
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub const BY_NAME:&'static [(&'static str, &'static [(char,char)])] = &[ ("ALetter", ALETTER), ("CR", CR), ("Double_Quote", DOUBLE_QUOTE), ("Extend", EXTEND), ("ExtendNumLet", EXTENDNUMLET), ("Format", FORMAT), ("Hebrew_Letter", HEBREW_LETTER), ("Katakana", KATAKANA), ("LF", LF), ("MidLetter", MIDLETTER), ("MidNum", MIDNUM), ("MidNumLet", MIDNUMLET), ("Newline", NEWLINE), ("Numeric", NUMERIC), ("Regional_Indicator", REGIONAL_INDICATOR), ("Single_Quote", SINGLE_QUOTE), ("WSegSpace", WSEGSPACE), ("ZWJ", ZWJ) ];
            pub const ALETTER:&'static [(char,char)] = &[ ('A','Z'),('a','z'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{70f}',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const CR:&'static [(char,char)] = &[('\r','\r')];
            pub const DOUBLE_QUOTE:&'static [(char,char)] = &[('"','"')];
            pub const EXTEND:&'static [(char,char)] = &[ ('\u{300}','\u{36f}'),('\u{483}','\u{489}'),('\u{591}','\u{5bd}'),('\u{5bf}','\u{5bf}'),('\u{5c1}','\u{5c2}'),('\u{5c4}','\u{5c5}'),('\u{5c7}','\u{5c7}'),('\u{610}','\u{61a}'),('\u{64b}','\u{65f}'),('\u{670}','\u{670}'),('\u{6d6}','\u{6dc}'),('\u{6df}','\u{6e4}'),('\u{6e7}','\u{6e8}'),('\u{6ea}','\u{6ed}'),('\u{711}','\u{711}'),('\u{730}','\u{74a}'),('\u{7a6}','\u{7b0}'),('\u{7eb}','\u{7f3}'),('\u{7fd}','\u{7fd}'),('\u{816}','\u{819}'),('\u{81b}','\u{823}'),('\u{825}','\u{827}'),('\u{829}','\u{82d}'),('\u{859}','\u{85b}'),('\u{897}','\u{89f}'),('\u{8ca}','\u{8e1}'),('\u{8e3}',''),('\u{93a}','\u{93c}'),('',''),('\u{951}','\u{957}'),('\u{962}','\u{963}'),('\u{981}',''),('\u{9bc}','\u{9bc}'),('\u{9be}','\u{9c4}'),('',''),('','\u{9cd}'),('\u{9d7}','\u{9d7}'),('\u{9e2}','\u{9e3}'),('\u{9fe}','\u{9fe}'),('\u{a01}',''),('\u{a3c}','\u{a3c}'),('','\u{a42}'),('\u{a47}','\u{a48}'),('\u{a4b}','\u{a4d}'),('\u{a51}','\u{a51}'),('\u{a70}','\u{a71}'),('\u{a75}','\u{a75}'),('\u{a81}',''),('\u{abc}','\u{abc}'),('','\u{ac5}'),('\u{ac7}',''),('','\u{acd}'),('\u{ae2}','\u{ae3}'),('\u{afa}','\u{aff}'),('\u{b01}',''),('\u{b3c}','\u{b3c}'),('\u{b3e}','\u{b44}'),('',''),('','\u{b4d}'),('\u{b55}','\u{b57}'),('\u{b62}','\u{b63}'),('\u{b82}','\u{b82}'),('\u{bbe}',''),('',''),('','\u{bcd}'),('\u{bd7}','\u{bd7}'),('\u{c00}','\u{c04}'),('\u{c3c}','\u{c3c}'),('\u{c3e}',''),('\u{c46}','\u{c48}'),('\u{c4a}','\u{c4d}'),('\u{c55}','\u{c56}'),('\u{c62}','\u{c63}'),('\u{c81}',''),('\u{cbc}','\u{cbc}'),('',''),('\u{cc6}','\u{cc8}'),('\u{cca}','\u{ccd}'),('\u{cd5}','\u{cd6}'),('\u{ce2}','\u{ce3}'),('',''),('\u{d00}',''),('\u{d3b}','\u{d3c}'),('\u{d3e}','\u{d44}'),('',''),('','\u{d4d}'),('\u{d57}','\u{d57}'),('\u{d62}','\u{d63}'),('\u{d81}',''),('\u{dca}','\u{dca}'),('\u{dcf}','\u{dd4}'),('\u{dd6}','\u{dd6}'),('','\u{ddf}'),('',''),('\u{e31}','\u{e31}'),('\u{e34}','\u{e3a}'),('\u{e47}','\u{e4e}'),('\u{eb1}','\u{eb1}'),('\u{eb4}','\u{ebc}'),('\u{ec8}','\u{ece}'),('\u{f18}','\u{f19}'),('\u{f35}','\u{f35}'),('\u{f37}','\u{f37}'),('\u{f39}','\u{f39}'),('',''),('\u{f71}','\u{f84}'),('\u{f86}','\u{f87}'),('\u{f8d}','\u{f97}'),('\u{f99}','\u{fbc}'),('\u{fc6}','\u{fc6}'),('','\u{103e}'),('','\u{1059}'),('\u{105e}','\u{1060}'),('',''),('',''),('\u{1071}','\u{1074}'),('\u{1082}','\u{108d}'),('',''),('','\u{109d}'),('\u{135d}','\u{135f}'),('\u{1712}','\u{1715}'),('\u{1732}','\u{1734}'),('\u{1752}','\u{1753}'),('\u{1772}','\u{1773}'),('\u{17b4}','\u{17d3}'),('\u{17dd}','\u{17dd}'),('\u{180b}','\u{180d}'),('\u{180f}','\u{180f}'),('\u{1885}','\u{1886}'),('\u{18a9}','\u{18a9}'),('\u{1920}',''),('','\u{193b}'),('\u{1a17}','\u{1a1b}'),('','\u{1a5e}'),('\u{1a60}','\u{1a7c}'),('\u{1a7f}','\u{1a7f}'),('\u{1ab0}','\u{1ace}'),('\u{1b00}',''),('\u{1b34}','\u{1b44}'),('\u{1b6b}','\u{1b73}'),('\u{1b80}',''),('','\u{1bad}'),('\u{1be6}','\u{1bf3}'),('','\u{1c37}'),('\u{1cd0}','\u{1cd2}'),('\u{1cd4}','\u{1ce8}'),('\u{1ced}','\u{1ced}'),('\u{1cf4}','\u{1cf4}'),('','\u{1cf9}'),('\u{1dc0}','\u{1dff}'),('\u{200c}','\u{200c}'),('\u{20d0}','\u{20f0}'),('\u{2cef}','\u{2cf1}'),('\u{2d7f}','\u{2d7f}'),('\u{2de0}','\u{2dff}'),('\u{302a}','\u{302f}'),('\u{3099}','\u{309a}'),('\u{a66f}','\u{a672}'),('\u{a674}','\u{a67d}'),('\u{a69e}','\u{a69f}'),('\u{a6f0}','\u{a6f1}'),('\u{a802}','\u{a802}'),('\u{a806}','\u{a806}'),('\u{a80b}','\u{a80b}'),('',''),('\u{a82c}','\u{a82c}'),('',''),('','\u{a8c5}'),('\u{a8e0}','\u{a8f1}'),('\u{a8ff}','\u{a8ff}'),('\u{a926}','\u{a92d}'),('\u{a947}','\u{a953}'),('\u{a980}',''),('\u{a9b3}','\u{a9c0}'),('\u{a9e5}','\u{a9e5}'),('\u{aa29}','\u{aa36}'),('\u{aa43}','\u{aa43}'),('\u{aa4c}',''),('',''),('\u{aab0}','\u{aab0}'),('\u{aab2}','\u{aab4}'),('\u{aab7}','\u{aab8}'),('\u{aabe}','\u{aabf}'),('\u{aac1}','\u{aac1}'),('',''),('','\u{aaf6}'),('',''),('','\u{abed}'),('\u{fb1e}','\u{fb1e}'),('\u{fe00}','\u{fe0f}'),('\u{fe20}','\u{fe2f}'),('\u{ff9e}','\u{ff9f}'),('\u{101fd}','\u{101fd}'),('\u{102e0}','\u{102e0}'),('\u{10376}','\u{1037a}'),('\u{10a01}','\u{10a03}'),('\u{10a05}','\u{10a06}'),('\u{10a0c}','\u{10a0f}'),('\u{10a38}','\u{10a3a}'),('\u{10a3f}','\u{10a3f}'),('\u{10ae5}','\u{10ae6}'),('\u{10d24}','\u{10d27}'),('\u{10d69}','\u{10d6d}'),('\u{10eab}','\u{10eac}'),('\u{10efc}','\u{10eff}'),('\u{10f46}','\u{10f50}'),('\u{10f82}','\u{10f85}'),('',''),('\u{11038}','\u{11046}'),('\u{11070}','\u{11070}'),('\u{11073}','\u{11074}'),('\u{1107f}',''),('','\u{110ba}'),('\u{110c2}','\u{110c2}'),('\u{11100}','\u{11102}'),('\u{11127}','\u{11134}'),('',''),('\u{11173}','\u{11173}'),('\u{11180}',''),('','\u{111c0}'),('\u{111c9}','\u{111cc}'),('','\u{111cf}'),('','\u{11237}'),('\u{1123e}','\u{1123e}'),('\u{11241}','\u{11241}'),('\u{112df}','\u{112ea}'),('\u{11300}',''),('\u{1133b}','\u{1133c}'),('\u{1133e}',''),('',''),('','\u{1134d}'),('\u{11357}','\u{11357}'),('',''),('\u{11366}','\u{1136c}'),('\u{11370}','\u{11374}'),('\u{113b8}','\u{113c0}'),('\u{113c2}','\u{113c2}'),('\u{113c5}','\u{113c5}'),('\u{113c7}',''),('','\u{113d0}'),('\u{113d2}','\u{113d2}'),('\u{113e1}','\u{113e2}'),('','\u{11446}'),('\u{1145e}','\u{1145e}'),('\u{114b0}','\u{114c3}'),('\u{115af}','\u{115b5}'),('','\u{115c0}'),('\u{115dc}','\u{115dd}'),('','\u{11640}'),('\u{116ab}','\u{116b7}'),('\u{1171d}','\u{1172b}'),('','\u{1183a}'),('\u{11930}',''),('',''),('\u{1193b}','\u{1193e}'),('',''),('','\u{11943}'),('','\u{119d7}'),('\u{119da}','\u{119e0}'),('',''),('\u{11a01}','\u{11a0a}'),('\u{11a33}',''),('\u{11a3b}','\u{11a3e}'),('\u{11a47}','\u{11a47}'),('\u{11a51}','\u{11a5b}'),('\u{11a8a}','\u{11a99}'),('','\u{11c36}'),('\u{11c38}','\u{11c3f}'),('\u{11c92}','\u{11ca7}'),('','\u{11cb6}'),('\u{11d31}','\u{11d36}'),('\u{11d3a}','\u{11d3a}'),('\u{11d3c}','\u{11d3d}'),('\u{11d3f}','\u{11d45}'),('\u{11d47}','\u{11d47}'),('',''),('\u{11d90}','\u{11d91}'),('','\u{11d97}'),('\u{11ef3}',''),('\u{11f00}','\u{11f01}'),('',''),('','\u{11f3a}'),('','\u{11f42}'),('\u{11f5a}','\u{11f5a}'),('\u{13440}','\u{13440}'),('\u{13447}','\u{13455}'),('\u{1611e}','\u{1612f}'),('\u{16af0}','\u{16af4}'),('\u{16b30}','\u{16b36}'),('\u{16f4f}','\u{16f4f}'),('',''),('\u{16f8f}','\u{16f92}'),('\u{16fe4}','\u{16fe4}'),('\u{16ff0}','\u{16ff1}'),('\u{1bc9d}','\u{1bc9e}'),('\u{1cf00}','\u{1cf2d}'),('\u{1cf30}','\u{1cf46}'),('\u{1d165}','\u{1d169}'),('\u{1d16d}','\u{1d172}'),('\u{1d17b}','\u{1d182}'),('\u{1d185}','\u{1d18b}'),('\u{1d1aa}','\u{1d1ad}'),('\u{1d242}','\u{1d244}'),('\u{1da00}','\u{1da36}'),('\u{1da3b}','\u{1da6c}'),('\u{1da75}','\u{1da75}'),('\u{1da84}','\u{1da84}'),('\u{1da9b}','\u{1da9f}'),('\u{1daa1}','\u{1daaf}'),('\u{1e000}','\u{1e006}'),('\u{1e008}','\u{1e018}'),('\u{1e01b}','\u{1e021}'),('\u{1e023}','\u{1e024}'),('\u{1e026}','\u{1e02a}'),('\u{1e08f}','\u{1e08f}'),('\u{1e130}','\u{1e136}'),('\u{1e2ae}','\u{1e2ae}'),('\u{1e2ec}','\u{1e2ef}'),('\u{1e4ec}','\u{1e4ef}'),('\u{1e5ee}','\u{1e5ef}'),('\u{1e8d0}','\u{1e8d6}'),('\u{1e944}','\u{1e94a}'),('',''),('\u{e0020}','\u{e007f}'),('\u{e0100}','\u{e01ef}'), ];
            pub const EXTENDNUMLET:&'static [(char,char)] = &[ ('_','_'),('\u{202f}','\u{202f}'),('',''),('',''),('',''),('',''),('',''), ];
            pub const FORMAT:&'static [(char,char)] = &[ ('\u{ad}','\u{ad}'),('\u{61c}','\u{61c}'),('\u{180e}','\u{180e}'),('\u{200e}','\u{200f}'),('\u{202a}','\u{202e}'),('\u{2060}','\u{2064}'),('\u{2066}','\u{206f}'),('\u{feff}','\u{feff}'),('\u{fff9}','\u{fffb}'),('\u{13430}','\u{1343f}'),('\u{1bca0}','\u{1bca3}'),('\u{1d173}','\u{1d17a}'),('\u{e0001}','\u{e0001}'), ];
            pub const HEBREW_LETTER:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const KATAKANA:&'static [(char,char)] = &[ ('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const LF:&'static [(char,char)] = &[('\n','\n')];
            pub const MIDLETTER:&'static [(char,char)] = &[ (':',':'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const MIDNUM:&'static [(char,char)] = &[ (',',','),(';',';'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const MIDNUMLET:&'static [(char,char)] = &[ ('.','.'),('',''),('',''),('',''),('',''),('',''), ];
            pub const NEWLINE:&'static [(char,char)] = &[('\u{b}','\u{c}'),('\u{85}','\u{85}'),('\u{2028}','\u{2029}')];
            pub const NUMERIC:&'static [(char,char)] = &[ ('0','9'),('\u{600}','\u{605}'),('',''),('',''),('\u{6dd}','\u{6dd}'),('',''),('',''),('\u{890}','\u{891}'),('\u{8e2}','\u{8e2}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('\u{110bd}','\u{110bd}'),('\u{110cd}','\u{110cd}'),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''),('',''), ];
            pub const REGIONAL_INDICATOR:&'static [(char,char)] = &[('','')];
            pub const SINGLE_QUOTE:&'static [(char,char)] = &[('\'','\'')];
            pub const WSEGSPACE:&'static [(char,char)] = &[ (' ',' '),('\u{1680}','\u{1680}'),('\u{2000}','\u{2006}'),('\u{2008}','\u{200a}'),('\u{205f}','\u{205f}'),('\u{3000}','\u{3000}'), ];
            pub const ZWJ:&'static [(char,char)] = &[('\u{200d}','\u{200d}')];
        }
    }

    type Range = &'static [(char,char)];

    #[derive( Debug )]
    pub enum Error
    {
        PropertyNotFound,
        PropertyValueNotFound,
        PerlClassNotFound,
    }

    #[derive( Debug )]
    pub struct CaseFoldError( () );
    
    impl ::error::Error for CaseFoldError {}

    impl ::fmt::Display for CaseFoldError
    {
        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
        {
            write!
            (
                f,
                "Unicode-aware case folding is not available (probably because the unicode-case feature is not enabled)"
            )
        }
    }

    #[derive( Debug )]
    pub struct UnicodeWordError( () );
    
    impl ::error::Error for UnicodeWordError {}

    impl ::fmt::Display for UnicodeWordError
    {
        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result
        {
            write!
            (
                f,
                "Unicode-aware \\w class is not available (probably because the unicode-perl feature is not enabled)"
            )
        }
    }

    #[derive( Debug )]
    pub struct SimpleCaseFolder
    {
        table:&'static [(char, &'static [char])],
        last:Option<char>,
        next: usize,
    }

    impl SimpleCaseFolder
    {
        pub fn new() -> Result<SimpleCaseFolder, CaseFoldError>
        {
            Ok(SimpleCaseFolder
            {
                table: tables::cases::CASE_FOLDING_SIMPLE,
                last: None,
                next: 0,
            })
        }

        pub fn mapping( &mut self, c: char) -> &'static [char]
        {
            if let Some(last) = self.last {
                assert!(
                    last < c,
                    "got codepoint U+{:X} which occurs before \
                    last codepoint U+{:X}",
                    u32::from(c),
                    u32::from(last),
                );
            }
            self.last = Some(c);
            if self.next >= self.table.len() {
                return &[];
            }
            let (k, v) = self.table[self.next];
            if k == c {
                self.next += 1;
                return v;
            }
            match self.get(c) {
                Err(i) => {
                    self.next = i;
                    &[]
                }
                Ok(i) =>
                {
                    assert!(i > self.next);
                    self.next = i + 1;
                    self.table[i].1
                }
            }
        }
        pub fn overlaps(&self, start: char, end: char) -> bool
        {
            use ::cmp::Ordering;

            assert!(start <= end);
            self.table
                .binary_search_by(|&(c, _)| {
                    if start <= c && c <= end {
                        Ordering::Equal
                    } else if c > end {
                        Ordering::Greater
                    } else {
                        Ordering::Less
                    }
                })
                .is_ok()
        }

        fn get(&self, c: char) -> Result<usize, usize> { self.table.binary_search_by_key(&c, |&(c1, _)| c1) }
    }

    #[derive( Debug )]
    pub enum ClassQuery<'a>
    {
        OneLetter(char),
        Binary(&'a str),
        ByValue
        {
            property_name: &'a str,
            property_value: &'a str,
        },
    }

    impl<'a> ClassQuery<'a> 
    {
        fn canonicalize( &self ) -> Result<CanonicalClassQuery, Error> 
        {
            match *self 
            {
                ClassQuery::OneLetter(c) => self.canonical_binary(&c.to_string()),
                ClassQuery::Binary(name) => self.canonical_binary(name),
                ClassQuery::ByValue { property_name, property_value } => {
                    let property_name = symbolic_name_normalize(property_name);
                    let property_value = symbolic_name_normalize(property_value);

                    let canon_name = match canonical_prop(&property_name)? {
                        None => return Err(Error::PropertyNotFound),
                        Some(canon_name) => canon_name,
                    };
                    Ok(match canon_name {
                        "General_Category" => {
                            let canon = match canonical_gencat(&property_value)? {
                                None => return Err(Error::PropertyValueNotFound),
                                Some(canon) => canon,
                            };
                            CanonicalClassQuery::GeneralCategory(canon)
                        }
                        "Script" => {
                            let canon = match canonical_script(&property_value)? {
                                None => return Err(Error::PropertyValueNotFound),
                                Some(canon) => canon,
                            };
                            CanonicalClassQuery::Script(canon)
                        }
                        _ => {
                            let vals = match property_values(canon_name)? {
                                None => return Err(Error::PropertyValueNotFound),
                                Some(vals) => vals,
                            };
                            let canon_val =
                                match canonical_value(vals, &property_value) {
                                    None => { return Err(Error::PropertyValueNotFound) }
                                    Some(canon_val) => canon_val,
                                };
                            CanonicalClassQuery::ByValue {
                                property_name: canon_name,
                                property_value: canon_val,
                            }
                        }
                    })
                }
            }
        }

        fn canonical_binary
        (
            &self,
            name: &str,
        ) -> Result<CanonicalClassQuery, Error>
        {
            let norm = symbolic_name_normalize(name);
            
            if norm != "cf" && norm != "sc" && norm != "lc" {
                if let Some(canon) = canonical_prop(&norm)? {
                    return Ok(CanonicalClassQuery::Binary(canon));
                }
            }
            if let Some(canon) = canonical_gencat(&norm)? {
                return Ok(CanonicalClassQuery::GeneralCategory(canon));
            }
            if let Some(canon) = canonical_script(&norm)? {
                return Ok(CanonicalClassQuery::Script(canon));
            }
            Err(Error::PropertyNotFound)
        }
    }

    #[derive( Debug, Eq, PartialEq )]
    enum CanonicalClassQuery 
    {

        Binary(&'static str),
        GeneralCategory(&'static str),
        Script(&'static str),
        ByValue
        {

            property_name:&'static str,
            property_value:&'static str,
        },
    }

    pub fn class(query: ClassQuery<'_>) -> Result<hir::ClassUnicode, Error>
    {
        use self::CanonicalClassQuery::*;

        match query.canonicalize()? {
            Binary(name) => bool_property(name),
            GeneralCategory(name) => gencat(name),
            Script(name) => script(name),
            ByValue { property_name: "Age", property_value } => {
                let mut class = hir::ClassUnicode::empty();
                for set in ages(property_value)? {
                    class.union(&hir_class(set));
                }
                Ok(class)
            }
            ByValue { property_name: "Script_Extensions", property_value } => { script_extension(property_value) }
            ByValue {
                property_name: "Grapheme_Cluster_Break",
                property_value,
            } => gcb(property_value),
            ByValue { property_name: "Sentence_Break", property_value } => { sb(property_value) }
            ByValue { property_name: "Word_Break", property_value } => { wb(property_value) }
            _ => {
                // What else should we support?
                Err(Error::PropertyNotFound)
            }
        }
    }

    pub fn perl_word() -> Result<hir::ClassUnicode, Error> 
    {
        use tables::perl::word::PERL_WORD;
        Ok(hir_class(PERL_WORD))
    }

    pub fn perl_space() -> Result<hir::ClassUnicode, Error> 
    {
        use tables::property::booleans::WHITE_SPACE;
        Ok(hir_class(WHITE_SPACE))
    }

    pub fn perl_digit() -> Result<hir::ClassUnicode, Error> 
    {
        use tables::categories::DECIMAL_NUMBER;
        Ok(hir_class(DECIMAL_NUMBER))
    }

    pub fn hir_class(ranges: &[(char,char)]) -> hir::ClassUnicode 
    {
        let hir_ranges: Vec<hir::ClassUnicodeRange> = ranges
            .iter()
            .map(|&(s, e)| hir::ClassUnicodeRange::new(s, e))
            .collect();
        hir::ClassUnicode::new(hir_ranges)
    }

    pub fn is_word_character(c: char) -> Result<bool, UnicodeWordError>
    {
        if u8::try_from(c).map_or(false, is::word_byte) { return Ok(true); }

        Ok(PERL_WORD
        .binary_search_by(|&(start, end)| 
        {
            use cmp::Ordering;

            if start <= c && c <= end {
                Ordering::Equal
            } else if start > c {
                Ordering::Greater
            } else {
                Ordering::Less
            }
        })
        .is_ok())
    }

    type PropertyValues = &'static [(&'static str, &'static str)];

    fn canonical_gencat( normalized_value: &str ) -> Result<Option<&'static str>, Error>
    {
        Ok(match normalized_value 
        {
            "any" => Some("Any"),
            "assigned" => Some("Assigned"),
            "ascii" => Some("ASCII"),
            _ => {
                let gencats = property_values("General_Category")?.unwrap();
                canonical_value(gencats, normalized_value)
            }
        })
    }

    fn canonical_script( normalized_value: &str ) -> Result<Option<&'static str>, Error> 
    {
        let scripts = property_values("Script")?.unwrap();
        Ok(canonical_value(scripts, normalized_value))
    }

    fn canonical_prop( normalized_name: &str ) -> Result<Option<&'static str>, Error>
    {
        use tables::property::names::PROPERTY_NAMES;
        Ok
        (
            PROPERTY_NAMES
            .binary_search_by_key(&normalized_name, |&(n, _)| n)
            .ok()
            .map(|i| PROPERTY_NAMES[i].1)
        )
    }

    fn canonical_value( vals: PropertyValues, normalized_value: &str ) -> Option<&'static str>
    {
        vals.binary_search_by_key(&normalized_value, |&(n, _)| n)
        .ok()
        .map(|i| vals[i].1)
    }

    fn property_values( canonical_property_name:&'static str ) -> Result<Option<PropertyValues>, Error>
    {
        use tables::property::values::PROPERTY_VALUES;
        Ok
        (
            PROPERTY_VALUES
            .binary_search_by_key(&canonical_property_name, |&(n, _)| n)
            .ok()
            .map(|i| PROPERTY_VALUES[i].1)
        )
    }
    
    fn property_set( name_map:&'static [(&'static str, Range)], canonical:&'static str ) -> Option<Range>
    {
        name_map
        .binary_search_by_key(&canonical, |x| x.0)
        .ok()
        .map(|i| name_map[i].1)
    }

    fn ages(canonical_age: &str) -> Result<impl Iterator<Item = Range>, Error>
    {   
        use tables::age;

        const AGES: &[(&str, Range)] = 
        &[
            ("V1_1", age::V1_1),
            ("V2_0", age::V2_0),
            ("V2_1", age::V2_1),
            ("V3_0", age::V3_0),
            ("V3_1", age::V3_1),
            ("V3_2", age::V3_2),
            ("V4_0", age::V4_0),
            ("V4_1", age::V4_1),
            ("V5_0", age::V5_0),
            ("V5_1", age::V5_1),
            ("V5_2", age::V5_2),
            ("V6_0", age::V6_0),
            ("V6_1", age::V6_1),
            ("V6_2", age::V6_2),
            ("V6_3", age::V6_3),
            ("V7_0", age::V7_0),
            ("V8_0", age::V8_0),
            ("V9_0", age::V9_0),
            ("V10_0", age::V10_0),
            ("V11_0", age::V11_0),
            ("V12_0", age::V12_0),
            ("V12_1", age::V12_1),
            ("V13_0", age::V13_0),
            ("V14_0", age::V14_0),
            ("V15_0", age::V15_0),
            ("V15_1", age::V15_1),
            ("V16_0", age::V16_0),
        ];
        assert_eq!(AGES.len(), age::BY_NAME.len(), "ages are out of sync");

        let pos = AGES.iter().position(|&(age, _)| canonical_age == age);
        match pos {
            None => Err(Error::PropertyValueNotFound),
            Some(i) => Ok(AGES[..=i].iter().map(|&(_, classes)| classes)),
        }   
    }

    fn gencat(canonical_name:&'static str) -> Result<hir::ClassUnicode, Error>
    {
        match canonical_name 
        {
            "Decimal_Number" => perl_digit(),
            name => 
            {
                use tables::categories::BY_NAME;
                match name {
                    "ASCII" => Ok(hir_class(&[('\0','\x7F')])),
                    "Any" => Ok(hir_class(&[('\0','\u{10FFFF}')])),
                    "Assigned" =>
                    {
                        let mut cls = gencat("Unassigned")?;
                        cls.negate();
                        Ok(cls)
                    }
                    name => property_set(BY_NAME, name)
                    .map(hir_class)
                    .ok_or(Error::PropertyValueNotFound),
                }
            }
        }
    }

    fn script(canonical_name:&'static str) -> Result<hir::ClassUnicode, Error>
    {
        use tables::script::BY_NAME;
        property_set(BY_NAME, canonical_name)
        .map(hir_class)
        .ok_or(Error::PropertyValueNotFound)   
    }

    fn script_extension( canonical_name:&'static str ) -> Result<hir::ClassUnicode, Error>
    {
        use tables::script::extension::BY_NAME;
        property_set(BY_NAME, canonical_name)
        .map(hir_class)
        .ok_or(Error::PropertyValueNotFound)
    }

    fn bool_property( canonical_name:&'static str ) -> Result<hir::ClassUnicode, Error>
    {
        match canonical_name
        {
            "Decimal_Number" => perl_digit(),
            "White_Space" => perl_space(),
            name =>
            {
                use tables::property::booleans::BY_NAME;
                property_set(BY_NAME, name)
                .map(hir_class)
                .ok_or(Error::PropertyNotFound)
            }
        }
    }

    fn gcb(canonical_name:&'static str) -> Result<hir::ClassUnicode, Error>
    {
        use tables::graphemes::BY_NAME;
        property_set(BY_NAME, canonical_name)
        .map(hir_class)
        .ok_or(Error::PropertyValueNotFound)
    }

    fn wb(canonical_name:&'static str) -> Result<hir::ClassUnicode, Error>
    {
        use tables::word::BY_NAME;
        property_set(BY_NAME, canonical_name)
        .map(hir_class)
        .ok_or(Error::PropertyValueNotFound)
    }

    fn sb(canonical_name:&'static str) -> Result<hir::ClassUnicode, Error>
    {
        use tables::sentence::BY_NAME;
        property_set(BY_NAME, canonical_name)
        .map(hir_class)
        .ok_or(Error::PropertyValueNotFound)
    }

    fn symbolic_name_normalize(x: &str) -> String
    {
        let mut tmp = x.as_bytes().to_vec();
        let len = symbolic_name_normalize_bytes(&mut tmp).len();
        tmp.truncate(len);
        String::from_utf8(tmp).unwrap()
    }

    fn symbolic_name_normalize_bytes(s: &mut [u8]) -> &mut [u8] 
    {
        let mut start = 0;
        let mut starts_with_is = false;

        if s.len() >= 2 
        {
            starts_with_is = s[0..2] == b"is"[..]
            || s[0..2] == b"IS"[..]
            || s[0..2] == b"iS"[..]
            || s[0..2] == b"Is"[..];

            if starts_with_is { start = 2; }
        }

        let mut next_write = 0;
        for i in start..s.len() 
        {
            let b = s[i];
            if b == b' ' || b == b'_' || b == b'-' {
                continue;
            } else if b'A' <= b && b <= b'Z' {
                s[next_write] = b + (b'a' - b'A');
                next_write += 1;
            } else if b <= 0x7F {
                s[next_write] = b;
                next_write += 1;
            }
        }
        
        if starts_with_is && next_write == 1 && s[0] == b'c' 
        {
            s[0] = b'i';
            s[1] = b's';
            s[2] = b'c';
            next_write = 3;
        }

        &mut s[..next_write]
    }

    pub mod normalization
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */
        pub mod normalize
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
        }

        pub mod lookups
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */ 
            /// Return whether the given character is a combining mark (`General_Category=Mark`)
            pub fn is_combining_mark(c:char) -> bool { mph_lookup(c.into(),COMBINING_MARK_SALT,COMBINING_MARK_KV,bool_lookup_fk,bool_lookup_fv,false) }
        }

        pub mod char
        {
            /*!
            */
            use ::
            {
                *,
            };
            /*
            */
            pub use super::normalize::{
                compose, decompose_canonical, decompose_cjk_compat_variants, decompose_compatible,
            };

            pub use super::lookups::{canonical_combining_class, is_combining_mark};

            /// Return whether the given character is assigned (`General_Category` != `Unassigned`)
            /// and not Private-Use (`General_Category` != `Private_Use`), in the supported version
            /// of Unicode.
            pub use ::unicode::tables::is_public_assigned;
        }
    }
    
    pub mod width
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */
        pub trait UnicodeWidthChar
        {
            fn width(self) -> Option<usize>;        
            fn width_cjk(self) -> Option<usize>;
        }
    }

}

pub mod usize
{
    pub use std::usize::{ * };
}

pub mod utf8
{
    /*!
    */
    use ::
    {
        *,
    };
    /*
    */

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct Error 
    {

        kind: ErrorKind,
        pattern: String,
        span: Span,
    }

    impl Error 
    {
        pub fn kind( &self ) -> &ErrorKind { &self.kind }

        pub fn pattern( &self ) -> &str { &self.pattern }

        pub fn span( &self ) -> &Span { &self.span }

        pub fn auxiliary_span( &self ) -> Option<&Span> {
            use self::ErrorKind::*;
            match self.kind {
                FlagDuplicate { ref original } => Some(original),
                FlagRepeatedNegation { ref original, .. } => Some(original),
                GroupNameDuplicate { ref original, .. } => Some(original),
                _ => None,
            }
        }
    }

    #[non_exhaustive] #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum ErrorKind 
    {

        CaptureLimitExceeded,
        ClassEscapeInvalid,
        ClassRangeInvalid,
        ClassRangeLiteral,
        ClassUnclosed,
        DecimalEmpty,
        DecimalInvalid,
        EscapeHexEmpty,
        EscapeHexInvalid,
        EscapeHexInvalidDigit,
        EscapeUnexpectedEof,
        EscapeUnrecognized,
        FlagDanglingNegation,
        FlagDuplicate {

            original: Span,
        },
        FlagRepeatedNegation {

            original: Span,
        },
        FlagUnexpectedEof,
        FlagUnrecognized,
        GroupNameDuplicate {

            original: Span,
        },
        GroupNameEmpty,
        GroupNameInvalid,
        GroupNameUnexpectedEof,
        GroupUnclosed,
        GroupUnopened,
        NestLimitExceeded(u32),
        RepetitionCountInvalid,
        RepetitionCountDecimalEmpty,
        RepetitionCountUnclosed,
        RepetitionMissing,
        SpecialWordBoundaryUnclosed,
        SpecialWordBoundaryUnrecognized,
        SpecialWordOrRepetitionUnexpectedEof,
        UnicodeClassInvalid,
        UnsupportedBackreference,
        UnsupportedLookAround,
    }

        impl ::error::Error for Error {}

    impl ::fmt::Display for Error {
        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
            crate::error::Formatter::from(self).fmt(f)
        }
    }

    impl ::fmt::Display for ErrorKind {
        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
            use self::ErrorKind::*;
            match *self {
                CaptureLimitExceeded => write!(
                    f,
                    "exceeded the maximum number of \
                    capturing groups ({})",
                    u32::MAX
                ),
                ClassEscapeInvalid => { write!(f, "invalid escape sequence found in character class") }
                ClassRangeInvalid => write!(
                    f,
                    "invalid character class range, \
                    the start must be <= the end"
                ),
                ClassRangeLiteral => { write!(f, "invalid range boundary, must be a literal") }
                ClassUnclosed => write!(f, "unclosed character class"),
                DecimalEmpty => write!(f, "decimal literal empty"),
                DecimalInvalid => write!(f, "decimal literal invalid"),
                EscapeHexEmpty => write!(f, "hexadecimal literal empty"),
                EscapeHexInvalid => { write!(f, "hexadecimal literal is not a Unicode scalar value") }
                EscapeHexInvalidDigit => write!(f, "invalid hexadecimal digit"),
                EscapeUnexpectedEof => write!(
                    f,
                    "incomplete escape sequence, \
                    reached end of pattern prematurely"
                ),
                EscapeUnrecognized => write!(f, "unrecognized escape sequence"),
                FlagDanglingNegation => { write!(f, "dangling flag negation operator") }
                FlagDuplicate { .. } => write!(f, "duplicate flag"),
                FlagRepeatedNegation { .. } => { write!(f, "flag negation operator repeated") }
                FlagUnexpectedEof => { write!(f, "expected flag but got end of regex") }
                FlagUnrecognized => write!(f, "unrecognized flag"),
                GroupNameDuplicate { .. } => { write!(f, "duplicate capture group name") }
                GroupNameEmpty => write!(f, "empty capture group name"),
                GroupNameInvalid => write!(f, "invalid capture group character"),
                GroupNameUnexpectedEof => write!(f, "unclosed capture group name"),
                GroupUnclosed => write!(f, "unclosed group"),
                GroupUnopened => write!(f, "unopened group"),
                NestLimitExceeded(limit) => write!(
                    f,
                    "exceed the maximum number of \
                    nested parentheses/brackets ({})",
                    limit
                ),
                RepetitionCountInvalid => write!(
                    f,
                    "invalid repetition count range, \
                    the start must be <= the end"
                ),
                RepetitionCountDecimalEmpty => { write!(f, "repetition quantifier expects a valid decimal") }
                RepetitionCountUnclosed => { write!(f, "unclosed counted repetition") }
                RepetitionMissing => { write!(f, "repetition operator missing expression") }
                SpecialWordBoundaryUnclosed => {
                    write!(
                        f,
                        "special word boundary assertion is either \
                        unclosed or contains an invalid character",
                    )
                }
                SpecialWordBoundaryUnrecognized => {
                    write!(
                        f,
                        "unrecognized special word boundary assertion, \
                        valid choices are: start, end, start-half \
                        or end-half",
                    )
                }
                SpecialWordOrRepetitionUnexpectedEof => {
                    write!(
                        f,
                        "found either the beginning of a special word \
                        boundary or a bounded repetition on a \\b with \
                        an opening brace, but no closing brace",
                    )
                }
                UnicodeClassInvalid => { write!(f, "invalid Unicode character class") }
                UnsupportedBackreference => { write!(f, "backreferences are not supported") }
                UnsupportedLookAround => write!(
                    f,
                    "look-around, including look-ahead and look-behind, \
                    is not supported"
                ),
            }
        }
    }

    #[derive(Clone, Copy, Eq, PartialEq)]
    pub struct Span 
    {

        pub start: Position,
        pub end: Position,
    }

    impl ::fmt::Debug for Span {
        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
            write!(f, "Span({:?}, {:?})", self.start, self.end)
        }
    }

    impl Ord for Span {
        fn cmp(&self, other: &Span) -> Ordering {
            (&self.start, &self.end).cmp(&(&other.start, &other.end))
        }
    }

    impl PartialOrd for Span {
        fn partial_cmp(&self, other: &Span) -> Option<Ordering> { Some( self.cmp(other)) }
    }

    #[derive(Clone, Copy, Eq, PartialEq)]
    pub struct Position {
        pub offset: usize,
        pub line: usize,
        pub column: usize,
    }

    impl ::fmt::Debug for Position {
        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
            write!(
                f,
                "Position(o: {:?}, l: {:?}, c: {:?})",
                self.offset, self.line, self.column
            )
        }
    }

    impl Ord for Position {
        fn cmp(&self, other: &Position) -> Ordering {
            self.offset.cmp(&other.offset)
        }
    }

    impl PartialOrd for Position {
        fn partial_cmp(&self, other: &Position) -> Option<Ordering> { Some( self.cmp(other)) }
    }

    impl Span {

        pub fn new(start: Position, end: Position) -> Span {
            Span { start, end }
        }

        pub fn splat(pos: Position) -> Span {
            Span::new(pos, pos)
        }
        pub fn with_start(self, pos: Position) -> Span {
            Span { start: pos, ..self }
        }
        pub fn with_end(self, pos: Position) -> Span {
            Span { end: pos, ..self }
        }

        pub fn is_one_line( &self ) -> bool { self.start.line == self.end.line }
        pub fn is_empty( &self ) -> bool { self.start.offset == self.end.offset }
    }

    impl Position {

        ///

        ///

        pub fn new(offset: usize, line: usize, column: usize) -> Position {
            Position { offset, line, column }
        }
    }
    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct WithComments {

        pub ast: Ast,
        pub comments: Vec<Comment>,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct Comment {

        pub span: Span,
        pub comment: String,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum Ast {

        Empty(Box<Span>),
        Flags(Box<SetFlags>),
        Literal(Box<Literal>),
        Dot(Box<Span>),
        Assertion(Box<Assertion>),
        ClassUnicode(Box<ClassUnicode>),
        ClassPerl(Box<ClassPerl>),
        ClassBracketed(Box<ClassBracketed>),
        Repetition(Box<Repetition>),
        Group(Box<Group>),
        Alternation(Box<Alternation>),
        Concat(Box<Concat>),
    }

    impl Ast {

        pub fn empty(span: Span) -> Ast {
            Ast::Empty(Box::new(span))
        }

        pub fn flags(e: SetFlags) -> Ast {
            Ast::Flags(Box::new(e))
        }

        pub fn literal(e: Literal) -> Ast {
            Ast::Literal(Box::new(e))
        }

        pub fn dot(span: Span) -> Ast {
            Ast::Dot(Box::new(span))
        }

        pub fn assertion(e: Assertion) -> Ast {
            Ast::Assertion(Box::new(e))
        }

        pub fn class_unicode(e: ClassUnicode) -> Ast {
            Ast::ClassUnicode(Box::new(e))
        }

        pub fn class_perl(e: ClassPerl) -> Ast {
            Ast::ClassPerl(Box::new(e))
        }

        pub fn class_bracketed(e: ClassBracketed) -> Ast {
            Ast::ClassBracketed(Box::new(e))
        }

        pub fn repetition(e: Repetition) -> Ast {
            Ast::Repetition(Box::new(e))
        }

        pub fn group(e: Group) -> Ast {
            Ast::Group(Box::new(e))
        }

        pub fn alternation(e: Alternation) -> Ast {
            Ast::Alternation(Box::new(e))
        }

        pub fn concat(e: Concat) -> Ast {
            Ast::Concat(Box::new(e))
        }

        pub fn span( &self ) -> &Span {
            match *self {
                Ast::Empty(ref span) => span,
                Ast::Flags(ref x) => &x.span,
                Ast::Literal(ref x) => &x.span,
                Ast::Dot(ref span) => span,
                Ast::Assertion(ref x) => &x.span,
                Ast::ClassUnicode(ref x) => &x.span,
                Ast::ClassPerl(ref x) => &x.span,
                Ast::ClassBracketed(ref x) => &x.span,
                Ast::Repetition(ref x) => &x.span,
                Ast::Group(ref x) => &x.span,
                Ast::Alternation(ref x) => &x.span,
                Ast::Concat(ref x) => &x.span,
            }
        }

        pub fn is_empty( &self ) -> bool {
            match *self {
                Ast::Empty(_) => true,
                _ => false,
            }
        }
        fn has_subexprs( &self ) -> bool {
            match *self {
                Ast::Empty(_)
                | Ast::Flags(_)
                | Ast::Literal(_)
                | Ast::Dot(_)
                | Ast::Assertion(_)
                | Ast::ClassUnicode(_)
                | Ast::ClassPerl(_) => false,
                Ast::ClassBracketed(_)
                | Ast::Repetition(_)
                | Ast::Group(_)
                | Ast::Alternation(_)
                | Ast::Concat(_) => true,
            }
        }
    }

    impl ::fmt::Display for Ast {
        fn fmt(&self, f: &mut ::fmt::Formatter<'_>) -> ::fmt::Result {
            use crate::ast::print::Printer;
            Printer::new().print(self, f)
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct Alternation {

        pub span: Span,
        pub asts: Vec<Ast>,
    }

    impl Alternation {
        pub fn into_ast(mut self) -> Ast 
        {
            match self.asts.len() {
                0 => Ast::empty( self.span),
                1 => self.asts.pop().unwrap(),
                _ => Ast::alternation(self),
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct Concat {

        pub span: Span,
        pub asts: Vec<Ast>,
    }

    impl Concat {

        pub fn into_ast(mut self) -> Ast 
        {
            match self.asts.len() {
                0 => Ast::empty( self.span),
                1 => self.asts.pop().unwrap(),
                _ => Ast::concat(self),
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct Literal {

        pub span: Span,
        pub kind: LiteralKind,
        pub c: char,
    }

    impl Literal {
        pub fn byte( &self ) -> Option<u8> 
        {
            match self.kind {
                LiteralKind::HexFixed(HexLiteralKind::X) => { u8::try_from( self.c).ok() }
                _ => None,
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum LiteralKind {

        Verbatim,
        Meta,
        Superfluous,
        Octal,
        HexFixed(HexLiteralKind),
        HexBrace(HexLiteralKind),
        Special(SpecialLiteralKind),
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum SpecialLiteralKind {

        Bell,
        FormFeed,
        Tab,
        LineFeed,
        CarriageReturn,
        VerticalTab,
        Space,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum HexLiteralKind {
        X,
        UnicodeShort,
        UnicodeLong,
    }

    impl HexLiteralKind {
        pub fn digits( &self ) -> u32 {
            match *self {
                HexLiteralKind::X => 2,
                HexLiteralKind::UnicodeShort => 4,
                HexLiteralKind::UnicodeLong => 8,
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct ClassPerl {

        pub span: Span,
        pub kind: ClassPerlKind,
        pub negated: bool,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum ClassPerlKind {

        Digit,
        Space,
        Word,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct ClassAscii {

        pub span: Span,
        pub kind: ClassAsciiKind,
        pub negated: bool,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum ClassAsciiKind {

        Alnum,
        Alpha,
        Ascii,
        Blank,
        Cntrl,
        Digit,
        Graph,
        Lower,
        Print,
        Punct,
        Space,
        Upper,
        Word,
        Xdigit,
    }

    impl ClassAsciiKind {

        pub fn from_name(name: &str) -> Option<ClassAsciiKind> {
            use self::ClassAsciiKind::*;
            match name {
                "alnum" => Some(Alnum),
                "alpha" => Some(Alpha),
                "ascii" => Some(Ascii),
                "blank" => Some(Blank),
                "cntrl" => Some(Cntrl),
                "digit" => Some(Digit),
                "graph" => Some(Graph),
                "lower" => Some(Lower),
                "print" => Some(Print),
                "punct" => Some(Punct),
                "space" => Some(Space),
                "upper" => Some(Upper),
                "word" => Some(Word),
                "xdigit" => Some(Xdigit),
                _ => None,
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct ClassUnicode {

        pub span: Span,
        pub negated: bool,
        pub kind: ClassUnicodeKind,
    }

    impl ClassUnicode {

        pub fn is_negated( &self ) -> bool 
        {
            match self.kind {
                ClassUnicodeKind::NamedValue {
                    op: ClassUnicodeOpKind::NotEqual,
                    ..
                } => !self.negated,
                _ => self.negated,
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum ClassUnicodeKind {

        OneLetter(char),
        Named(String),
        NamedValue {

            op: ClassUnicodeOpKind,
            name: String,
            value: String,
        },
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum ClassUnicodeOpKind {

        Equal,
        Colon,
        NotEqual,
    }

    impl ClassUnicodeOpKind {

        pub fn is_equal( &self ) -> bool {
            match *self {
                ClassUnicodeOpKind::Equal | ClassUnicodeOpKind::Colon => true,
                _ => false,
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct ClassBracketed {

        pub span: Span,
        pub negated: bool,
        pub kind: ClassSet,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum ClassSet {
        Item(ClassSetItem),
        BinaryOp(ClassSetBinaryOp),
    }

    impl ClassSet {

        pub fn union(ast: ClassSetUnion) -> ClassSet {
            ClassSet::Item(ClassSetItem::Union(ast))
        }

        pub fn span( &self ) -> &Span {
            match *self {
                ClassSet::Item(ref x) => x.span(),
                ClassSet::BinaryOp(ref x) => &x.span,
            }
        }

        fn is_empty( &self ) -> bool {
            match *self {
                ClassSet::Item(ClassSetItem::Empty(_)) => true,
                _ => false,
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum ClassSetItem {
        Empty(Span),
        Literal(Literal),
        Range(ClassSetRange),
        Ascii(ClassAscii),
        Unicode(ClassUnicode),
        Perl(ClassPerl),
        Bracketed(Box<ClassBracketed>),
        Union(ClassSetUnion),
    }

    impl ClassSetItem {

        pub fn span( &self ) -> &Span {
            match *self {
                ClassSetItem::Empty(ref span) => span,
                ClassSetItem::Literal(ref x) => &x.span,
                ClassSetItem::Range(ref x) => &x.span,
                ClassSetItem::Ascii(ref x) => &x.span,
                ClassSetItem::Perl(ref x) => &x.span,
                ClassSetItem::Unicode(ref x) => &x.span,
                ClassSetItem::Bracketed(ref x) => &x.span,
                ClassSetItem::Union(ref x) => &x.span,
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct ClassSetRange {

        pub span: Span,
        pub start: Literal,
        pub end: Literal,
    }

    impl ClassSetRange {

        pub fn is_valid( &self ) -> bool { self.start.c <= self.end.c }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct ClassSetUnion {
        pub span: Span,
        pub items: Vec<ClassSetItem>,
    }

    impl ClassSetUnion {
        pub fn push( &mut self, item: ClassSetItem) {
            if self.items.is_empty() {
                self.span.start = item.span().start;
            }
            self.span.end = item.span().end;
            self.items.push(item);
        }

        pub fn into_item(mut self) -> ClassSetItem 
        {
            match self.items.len() {
                0 => ClassSetItem::Empty( self.span),
                1 => self.items.pop().unwrap(),
                _ => ClassSetItem::Union(self),
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct ClassSetBinaryOp {

        pub span: Span,
        pub kind: ClassSetBinaryOpKind,
        pub lhs: Box<ClassSet>,
        pub rhs: Box<ClassSet>,
    }
    #[derive(Clone, Copy, Debug, Eq, PartialEq )]
    pub enum ClassSetBinaryOpKind {

        Intersection,
        Difference,
        SymmetricDifference,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct Assertion {

        pub span: Span,
        pub kind: AssertionKind,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum AssertionKind {

        StartLine,
        EndLine,
        StartText,
        EndText,
        WordBoundary,
        NotWordBoundary,
        WordBoundaryStart,
        WordBoundaryEnd,
        WordBoundaryStartAngle,
        WordBoundaryEndAngle,
        WordBoundaryStartHalf,
        WordBoundaryEndHalf,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct Repetition {

        pub span: Span,
        pub op: RepetitionOp,
        pub greedy: bool,
        pub ast: Box<Ast>,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct RepetitionOp {
        pub span: Span,
        pub kind: RepetitionKind,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum RepetitionKind {

        ZeroOrOne,
        ZeroOrMore,
        OneOrMore,
        Range(RepetitionRange),
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum RepetitionRange {

        Exactly(u32),
        AtLeast(u32),
        Bounded(u32, u32),
    }

    impl RepetitionRange {

        pub fn is_valid( &self ) -> bool {
            match *self {
                RepetitionRange::Bounded(s, e) if s > e => false,
                _ => true,
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct Group {

        pub span: Span,
        pub kind: GroupKind,
        pub ast: Box<Ast>,
    }

    impl Group {
        pub fn flags( &self ) -> Option<&Flags> 
        {
            match self.kind {
                GroupKind::NonCapturing(ref flags) => Some(flags),
                _ => None,
            }
        }

        pub fn is_capturing( &self ) -> bool 
        {
            match self.kind {
                GroupKind::CaptureIndex(_) | GroupKind::CaptureName { .. } => true,
                GroupKind::NonCapturing(_) => false,
            }
        }
        
        pub fn capture_index( &self ) -> Option<u32> 
        {
            match self.kind {
                GroupKind::CaptureIndex(i) => Some(i),
                GroupKind::CaptureName { ref name, .. } => Some(name.index),
                GroupKind::NonCapturing(_) => None,
            }
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum GroupKind {

        CaptureIndex(u32),
        CaptureName {

            starts_with_p: bool,
            name: CaptureName,
        },
        NonCapturing(Flags),
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct CaptureName {

        pub span: Span,
        pub name: String,
        pub index: u32,
    }
    
    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct SetFlags {

        pub span: Span,
        pub flags: Flags,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct Flags {

        pub span: Span,
        pub items: Vec<FlagsItem>,
    }

    impl Flags {
        pub fn add_item( &mut self, item: FlagsItem) -> Option<usize> {
            for (i, x) in self.items.iter().enumerate() {
                if x.kind == item.kind {
                    return Some(i);
                }
            }
            self.items.push(item);
            None
        }
        
        pub fn flag_state(&self, flag: Flag) -> Option<bool> {
            let mut negated = false;
            for x in &self.items {
                match x.kind {
                    FlagsItemKind::Negation => { negated = true; }
                    FlagsItemKind::Flag(ref xflag) if xflag == &flag => { return Some(!negated); }
                    _ => {}
                }
            }
            None
        }
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub struct FlagsItem {

        pub span: Span,
        pub kind: FlagsItemKind,
    }

    #[derive( Clone, Debug, Eq, PartialEq )]
    pub enum FlagsItemKind {
        Negation,
        Flag(Flag),
    }

    impl FlagsItemKind {

        pub fn is_negation( &self ) -> bool {
            match *self {
                FlagsItemKind::Negation => true,
                _ => false,
            }
        }
    }

    #[derive(Clone, Copy, Debug, Eq, PartialEq )]
    pub enum Flag {

        CaseInsensitive,
        MultiLine,
        DotMatchesNewLine,
        SwapGreed,
        Unicode,
        CRLF,
        IgnoreWhitespace,
    }
    
    impl Drop for Ast {
        fn drop(&mut self) {
            use ::mem;

            match *self {
                Ast::Empty(_)
                | Ast::Flags(_)
                | Ast::Literal(_)
                | Ast::Dot(_)
                | Ast::Assertion(_)
                | Ast::ClassUnicode(_)
                | Ast::ClassPerl(_)
                | Ast::ClassBracketed(_) => return,
                Ast::Repetition(ref x) if !x.ast.has_subexprs() => return,
                Ast::Group(ref x) if !x.ast.has_subexprs() => return,
                Ast::Alternation(ref x) if x.asts.is_empty() => return,
                Ast::Concat(ref x) if x.asts.is_empty() => return,
                _ => {}
            }

            let empty_span = || Span::splat(Position::new(0, 0, 0));
            let empty_ast = || Ast::empty(empty_span());
            let mut stack = vec![mem::replace(self, empty_ast())];
            while let Some(mut ast) = stack.pop() {
                match ast {
                    Ast::Empty(_)
                    | Ast::Flags(_)
                    | Ast::Literal(_)
                    | Ast::Dot(_)
                    | Ast::Assertion(_)
                    | Ast::ClassUnicode(_)
                    | Ast::ClassPerl(_)
                    | Ast::ClassBracketed(_) => {}
                    Ast::Repetition(ref mut x) => { stack.push(mem::replace(&mut x.ast, empty_ast())); }
                    Ast::Group(ref mut x) => { stack.push(mem::replace(&mut x.ast, empty_ast())); }
                    Ast::Alternation(ref mut x) => { stack.extend(x.asts.drain(..)); }
                    Ast::Concat(ref mut x) => { stack.extend(x.asts.drain(..)); }
                }
            }
        }
    }
    
    impl Drop for ClassSet {
        fn drop(&mut self) {
            use ::mem;

            match *self {
                ClassSet::Item(ref item) => match *item {
                    ClassSetItem::Empty(_)
                    | ClassSetItem::Literal(_)
                    | ClassSetItem::Range(_)
                    | ClassSetItem::Ascii(_)
                    | ClassSetItem::Unicode(_)
                    | ClassSetItem::Perl(_) => return,
                    ClassSetItem::Bracketed(ref x) => {
                        if x.kind.is_empty() { return; }
                    }
                    ClassSetItem::Union(ref x) => {
                        if x.items.is_empty() { return; }
                    }
                },
                ClassSet::BinaryOp(ref op) => {
                    if op.lhs.is_empty() && op.rhs.is_empty() {
                        return;
                    }
                }
            }

            let empty_span = || Span::splat(Position::new(0, 0, 0));
            let empty_set = || ClassSet::Item(ClassSetItem::Empty(empty_span()));
            let mut stack = vec![mem::replace(self, empty_set())];
            while let Some(mut set) = stack.pop() {
                match set {
                    ClassSet::Item(ref mut item) => match *item {
                        ClassSetItem::Empty(_)
                        | ClassSetItem::Literal(_)
                        | ClassSetItem::Range(_)
                        | ClassSetItem::Ascii(_)
                        | ClassSetItem::Unicode(_)
                        | ClassSetItem::Perl(_) => {}
                        ClassSetItem::Bracketed(ref mut x) => { stack.push(mem::replace(&mut x.kind, empty_set())); }
                        ClassSetItem::Union(ref mut x) => { stack.extend(x.items.drain(..).map(ClassSet::Item)); }
                    },
                    ClassSet::BinaryOp(ref mut op) => {
                        stack.push(mem::replace(&mut op.lhs, empty_set()));
                        stack.push(mem::replace(&mut op.rhs, empty_set()));
                    }
                }
            }
        }
    }
}

pub mod uuid
{
    /*!
    Generate and parse universally unique identifiers ( UUIDs ). */
    use ::
    {
        hash::{ Hash, Hasher },
        *,
    };

    pub mod builder
    {
        /*!
        A Builder type for [`Uuid`]s. */
        use ::
        {
            *,
        };
        /*
        use crate::{error::*, timestamp, Bytes, Uuid, Variant, Version};
        */

        #[derive( Debug )]
        pub struct Builder( Uuid  );

        impl Uuid
        {

            pub const fn nil() -> Self { Uuid::from_bytes( [0; 16] ) }

            pub const fn max() -> Self { Uuid::from_bytes( [0xFF; 16] ) }

            pub const fn from_fields( d1: u32, d2: u16, d3: u16, d4:&[u8; 8] ) -> Uuid
            {
                Uuid::from_bytes
                ([
                    ( d1 >> 24 ) as u8, ( d1 >> 16 ) as u8, ( d1 >> 8 ) as u8, d1 as u8, ( d2 >> 8 ) as u8,
                    d2 as u8, ( d3 >> 8 ) as u8, d3 as u8, d4[0], d4[1], d4[2], d4[3], d4[4], d4[5], d4[6], d4[7],
                ] )
            }

            pub const fn from_fields_le( d1: u32, d2: u16, d3: u16, d4:&[u8; 8] ) -> Uuid
            {
                Uuid::from_bytes
                ([
                    d1 as u8, ( d1 >> 8 ) as u8, ( d1 >> 16 ) as u8, ( d1 >> 24 ) as u8, ( d2 ) as u8, 
                    ( d2 >> 8 ) as u8, d3 as u8, ( d3 >> 8 ) as u8, d4[0], d4[1], d4[2], d4[3], d4[4],
                    d4[5], d4[6], d4[7],
                ] )
            }

            pub const fn from_u128( v: u128 ) -> Self { Uuid::from_bytes( v.to_be_bytes() ) }

            pub const fn from_u128_le( v: u128 ) -> Self { Uuid::from_bytes( v.to_le_bytes() ) }

            pub const fn from_u64_pair( high_bits: u64, low_bits: u64 ) -> Self
            { Uuid::from_u128( ( ( high_bits as u128 ) << 64 ) | low_bits as u128 ) }

            pub fn from_slice( b:&[u8] ) -> Result<Uuid, Error>
            {
                if b.len() != 16 { return Err( Error( ErrorKind::ParseByteLength { len: b.len() } ) ); }

                let mut bytes: Bytes = [0; 16];
                bytes.copy_from_slice( b );
                Ok( Uuid::from_bytes( bytes ) )
            }

            pub fn from_slice_le( b:&[u8] ) -> Result<Uuid, Error>
            {
                if b.len() != 16 { return Err( Error( ErrorKind::ParseByteLength { len: b.len() } ) ); }

                let mut bytes: Bytes = [0; 16];
                bytes.copy_from_slice( b );
                Ok( Uuid::from_bytes_le( bytes ) )
            }

            #[inline] pub const fn from_bytes( bytes: Bytes ) -> Uuid { Uuid( bytes ) }

            pub const fn from_bytes_le( b: Bytes ) -> Uuid
            {
                Uuid
                ([
                    b[3],b[2],b[1],b[0],b[5], b[4], b[7], b[6], b[8], b[9], b[10], b[11], b[12], b[13], b[14], b[15],
                ] )
            }

            #[inline] pub fn from_bytes_ref( bytes:&Bytes ) -> &Uuid { unsafe_transmute_ref!( bytes ) }
        }

        impl Builder
        {

            pub const fn from_bytes( b: Bytes ) -> Self { Builder( Uuid::from_bytes( b ) ) }

            pub const fn from_bytes_le( b: Bytes ) -> Self { Builder( Uuid::from_bytes_le( b ) ) }

            pub const fn from_gregorian_timestamp( ticks: u64, counter: u16, node_id:&[u8; 6] ) -> Self
            { Builder( timestamp::encode_gregorian_timestamp( ticks, counter, node_id ) ) }

            pub const fn from_md5_bytes( md5_bytes: Bytes ) -> Self
            {
                Builder( Uuid::from_bytes( md5_bytes ) )
                .with_variant( Variant::RFC4122 )
                .with_version( Version::Md5 )
            }

            pub const fn from_random_bytes( random_bytes: Bytes ) -> Self
            {
                Builder( Uuid::from_bytes( random_bytes ) )
                .with_variant( Variant::RFC4122 )
                .with_version( Version::Random )
            }

            pub const fn from_sha1_bytes( sha1_bytes: Bytes ) -> Self
            {
                Builder( Uuid::from_bytes( sha1_bytes ) )
                .with_variant( Variant::RFC4122 )
                .with_version( Version::Sha1 )
            }

            pub const fn from_sorted_gregorian_timestamp
            ( 
                ticks: u64,
                counter: u16,
                node_id:&[u8; 6],
            ) -> Self
            {
                Builder( timestamp::encode_sorted_gregorian_timestamp
                ( 
                    ticks, counter, node_id,
                ) )
            }

            pub const fn from_unix_timestamp_millis( millis: u64, counter_random_bytes:&[u8; 10] ) -> Self
            {
                Builder( timestamp::encode_unix_timestamp_millis
                ( 
                    millis,
                    counter_random_bytes,
                ) )
            }

            pub const fn from_custom_bytes( custom_bytes: Bytes ) -> Self
            {
                Builder::from_bytes( custom_bytes )
                .with_variant( Variant::RFC4122 )
                .with_version( Version::Custom )
            }

            pub fn from_slice( b:&[u8] ) -> Result<Self, Error>
            { Ok( Builder( Uuid::from_slice( b )? ) ) }

            pub fn from_slice_le( b:&[u8] ) -> Result<Self, Error>
            { Ok( Builder( Uuid::from_slice_le( b )? ) ) }

            pub const fn from_fields( d1: u32, d2: u16, d3: u16, d4:&[u8; 8] ) -> Self
            { Builder( Uuid::from_fields( d1, d2, d3, d4 ) ) }

            pub const fn from_fields_le( d1: u32, d2: u16, d3: u16, d4:&[u8; 8] ) -> Self 
            { Builder( Uuid::from_fields_le( d1, d2, d3, d4 ) ) }

            pub const fn from_u128( v: u128 ) -> Self 
            {
                Builder( Uuid::from_u128( v ) )
            }

            pub const fn from_u128_le( v: u128 ) -> Self 
            {
                Builder( Uuid::from_u128_le( v ) )
            }

            pub const fn nil() -> Self { Builder( Uuid::nil() ) }

            pub fn set_variant( &mut self, v: Variant ) -> &mut Self
            {
                *self = Builder( self.0 ).with_variant( v );
                self
            }

            pub const fn with_variant( mut self, v: Variant ) -> Self
            {
                let byte = ( self.0 ).0[8];

                ( self.0 ).0[8] = match v
                {
                    Variant::NCS => byte & 0x7f,
                    Variant::RFC4122 => ( byte & 0x3f ) | 0x80,
                    Variant::Microsoft => ( byte & 0x1f ) | 0xc0,
                    Variant::Future => byte | 0xe0,
                };

                self
            }

            pub fn set_version( &mut self, v: Version ) -> &mut Self
            {
                *self = Builder( self.0 ).with_version( v );
                self
            }

            pub const fn with_version( mut self, v: Version ) -> Self
            {
                ( self.0 ).0[6] = (( self.0 ).0[6] & 0x0f ) | ( ( v as u8 ) << 4 );
                self
            }

            pub const fn as_uuid( &self ) -> &Uuid { &self.0 }

            pub const fn into_uuid( self ) -> Uuid { self.0 }
        
            #[deprecated( 
                since = "1.10.0",
                note = "use `Builder::from_gregorian_timestamp( ticks, counter, node_id )`"
            )]
            pub const fn from_rfc4122_timestamp( ticks: u64, counter: u16, node_id:&[u8; 6] ) -> Self
            { Builder::from_gregorian_timestamp( ticks, counter, node_id ) }

            #[deprecated( 
                since = "1.10.0",
                note = "use `Builder::from_sorted_gregorian_timestamp( ticks, counter, node_id )`"
            )]
            pub const fn from_sorted_rfc4122_timestamp( ticks: u64, counter: u16, node_id:&[u8; 6], ) -> Self
            { Builder::from_sorted_gregorian_timestamp( ticks, counter, node_id ) }
        }
    }

    pub mod error
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */

        #[derive( Clone, Debug, Eq, Hash, PartialEq )]
        pub struct Error( pub ErrorKind );

        #[derive( Clone, Debug, Eq, Hash, PartialEq )]
        pub enum ErrorKind 
        {

            ParseChar { character:char, index: usize },
            ParseSimpleLength { len: usize },
            ParseByteLength { len: usize },
            ParseGroupCount { count: usize },
            ParseGroupLength
            {
                group: usize,
                len: usize,
                index: usize,
            },
            ParseInvalidUTF8,
            ParseOther,
            Nil,
            InvalidSystemTime( &'static str ),
        }

        #[derive( Clone, Debug, Eq, Hash, PartialEq )]
        pub struct InvalidUuid<'a>( pub &'a [u8] );

        impl<'a> InvalidUuid<'a>
        {

            pub fn into_err( self ) -> Error
            {
                let input_str = match ::str::from_utf8( self.0 )
                {
                    Ok( s ) => s,
                    Err( _ ) => return Error( ErrorKind::ParseInvalidUTF8 ),
                };

                let ( uuid_str, offset, simple ) = match input_str.as_bytes()
                {
                    [b'{', s @ .., b'}'] => ( s, 1, false ),
                    [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] =>
                    { ( s, "urn:uuid:".len(), false ) }
                    s => ( s, 0, true ),
                };

                let mut hyphen_count = 0;
                let mut group_bounds = [0; 4];
                
                let uuid_str = unsafe { ::str::from_utf8_unchecked( uuid_str ) };

                for ( index, character ) in uuid_str.char_indices()
                {
                    let byte = character as u8;
                    if character as u32 - byte as u32 > 0
                    {
                        return Error( ErrorKind::ParseChar
                        {
                            character,
                            index: index + offset + 1,
                        } );
                    }
                    
                    else if byte == b'-'
                    {
                        if hyphen_count < 4 { group_bounds[hyphen_count] = index; }
                        hyphen_count += 1;
                    }
                    
                    else if !byte.is_ascii_hexdigit()
                    {
                        return Error
                        ( 
                            ErrorKind::ParseChar
                            {
                                character: byte as char,
                                index: index + offset + 1,
                            }
                         );
                    }
                }

                if hyphen_count == 0 && simple
                {
                    Error( ErrorKind::ParseSimpleLength
                    {
                        len: input_str.len(),
                    } )
                }
                
                else if hyphen_count != 4
                {
                    Error( ErrorKind::ParseGroupCount
                    {
                        count: hyphen_count + 1,
                    } )
                }
                
                else
                {
                    const BLOCK_STARTS: [usize; 5] = [0, 9, 14, 19, 24];
                    for i in 0..4
                    {
                        if group_bounds[i] != BLOCK_STARTS[i + 1] - 1
                        {
                            return Error( ErrorKind::ParseGroupLength
                            {
                                group: i,
                                len: group_bounds[i] - BLOCK_STARTS[i],
                                index: offset + BLOCK_STARTS[i] + 1,
                            } );
                        }
                    }
                    
                    Error( ErrorKind::ParseGroupLength
                    {
                        group: 4,
                        len: input_str.len() - BLOCK_STARTS[4],
                        index: offset + BLOCK_STARTS[4] + 1,
                    } )
                }
            }
        }
        
        impl fmt::Display for Error
        {
            fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
            {
                match self.0
                {
                    ErrorKind::ParseChar
                    {
                        character, index, ..
                    } =>
                    {
                        write!
                        ( 
                            f,
                            r#"invalid character:
                            expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `{}` at {}"#, 
                            character,
                            index
                        )
                    }

                    ErrorKind::ParseSimpleLength { len } =>
                    {
                        write!( 
                            f,
                            "invalid length: expected length 32 for simple format, found {}",
                            len
                        )
                    }

                    ErrorKind::ParseByteLength { len } =>
                    {
                        write!( f, "invalid length: expected 16 bytes, found {}", len )
                    }

                    ErrorKind::ParseGroupCount { count } =>
                    {
                        write!( f, "invalid group count: expected 5, found {}", count )
                    }

                    ErrorKind::ParseGroupLength { group, len, .. } => 
                    {
                        let expected = [8, 4, 4, 4, 12][group];
                        write!( 
                            f,
                            "invalid group length in group {}: expected {}, found {}",
                            group, expected, len
                        )
                    }

                    ErrorKind::ParseInvalidUTF8 => write!( f, "non-UTF8 input" ),
                    ErrorKind::Nil => write!( f, "the UUID is nil" ),
                    ErrorKind::ParseOther => write!( f, "failed to parse a UUID" ),
                    ErrorKind::InvalidSystemTime( ref e ) => write!( f, "the system timestamp is invalid: {e}" ),
                }
            }
        }
    }

    pub mod fmt
    {
        /*!
        Adapters for alternative string formats. */
        use ::
        {
            borrow::{ Borrow },
            convert::{ TryInto as _, },
            str::{ FromStr },
            string::{ String, ToString },
            uuid::{ Uuid, Variant },
            *,
        };
        /*
        */
        impl ::fmt::Debug for Uuid
        {
            #[inline] fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::LowerHex::fmt( self, f ) }
        }

        impl fmt::Display for Uuid
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::LowerHex::fmt( self, f ) }
        }
        
        impl From<Uuid> for String
        {
            fn from( uuid: Uuid ) -> Self { uuid.to_string() }
        }

        impl fmt::Display for Variant
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
            {
                match *self
                {
                    Variant::NCS => write!( f, "NCS" ),
                    Variant::RFC4122 => write!( f, "RFC4122" ),
                    Variant::Microsoft => write!( f, "Microsoft" ),
                    Variant::Future => write!( f, "Future" ),
                }
            }
        }

        impl fmt::LowerHex for Uuid
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::LowerHex::fmt( self.as_hyphenated(), f ) }
        }

        impl fmt::UpperHex for Uuid
        {
            #[inline] fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result
            { fmt::UpperHex::fmt( self.as_hyphenated(), f ) }
        }

        #[repr( transparent )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
        pub struct Hyphenated( Uuid );

        #[repr( transparent )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
        pub struct Simple( Uuid );

        #[repr( transparent )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
        pub struct Urn( Uuid );

        #[repr( transparent )] #[derive( Clone, Copy, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd )]
        pub struct Braced( Uuid );

        impl Uuid
        {

            #[inline] pub const fn hyphenated( self ) -> Hyphenated { Hyphenated( self ) }

            #[inline] pub fn as_hyphenated( &self ) -> &Hyphenated { unsafe_transmute_ref!( self ) }

            #[inline] pub const fn simple( self ) -> Simple { Simple( self ) }

            #[inline] pub fn as_simple( &self ) -> &Simple { unsafe_transmute_ref!( self ) }

            #[inline] pub const fn urn( self ) -> Urn { Urn( self ) }

            #[inline] pub fn as_urn( &self ) -> &Urn { unsafe_transmute_ref!( self ) }

            #[inline] pub const fn braced( self ) -> Braced { Braced( self ) }

            #[inline] pub fn as_braced( &self ) -> &Braced { unsafe_transmute_ref!( self ) }
        }

        const UPPER: [u8; 16] =
        [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9', b'A', b'B', b'C', b'D', b'E', b'F' ];
        
        const LOWER: [u8; 16] =
        [ b'0', b'1', b'2', b'3', b'4', b'5', b'6', b'7', b'8', b'9', b'a', b'b', b'c', b'd', b'e', b'f' ];

        #[inline] const fn format_simple( src:&[u8; 16], upper: bool ) -> [u8; 32]
        {
            let lut = if upper { &UPPER } else { &LOWER };
            let mut dst = [0; 32];
            let mut i = 0;

            while i < 16
            {
                let x = src[i];
                dst[i * 2] = lut[( x >> 4 ) as usize];
                dst[i * 2 + 1] = lut[( x & 0x0f ) as usize];
                i += 1;
            }
            dst
        }

        #[inline] const fn format_hyphenated( src:&[u8; 16], upper: bool ) -> [u8; 36] 
        {
            let lut = if upper { &UPPER } else { &LOWER };
            let groups = [( 0, 8 ), ( 9, 13 ), ( 14, 18 ), ( 19, 23 ), ( 24, 36 )];
            let mut dst = [0; 36];

            let mut group_idx = 0;
            let mut i = 0;

            while group_idx < 5
            {
                let ( start, end ) = groups[group_idx];
                let mut j = start;

                while j < end
                {
                    let x = src[i];
                    i += 1;

                    dst[j] = lut[( x >> 4 ) as usize];
                    dst[j + 1] = lut[( x & 0x0f ) as usize];
                    j += 2;
                }

                if group_idx < 4
                {
                    dst[end] = b'-';
                }

                group_idx += 1;
            }

            dst
        }

        #[inline] fn encode_simple<'b>( src:&[u8; 16], buffer:&'b mut [u8], upper: bool ) -> &'b mut str 
        {
            let buf = &mut buffer[..Simple::LENGTH];
            let buf:&mut [u8; Simple::LENGTH] = buf.try_into().unwrap();
            *buf = format_simple( src, upper );
            
            unsafe { str::from_utf8_unchecked_mut( buf ) }
        }

        #[inline] fn encode_hyphenated<'b>( src:&[u8; 16], buffer:&'b mut [u8], upper: bool ) -> &'b mut str 
        {
            let a = &mut buffer[..Hyphenated::LENGTH];
            let a:&mut [u8; Hyphenated::LENGTH] = a.try_into().unwrap();
            *a = format_hyphenated( src, upper );
            unsafe { str::from_utf8_unchecked_mut( a ) }
        }

        #[inline] fn encode_braced<'b>( src:&[u8; 16], buffer:&'b mut [u8], upper: bool ) -> &'b mut str 
        {
            let buf = &mut buffer[..Hyphenated::LENGTH + 2];
            let buf:&mut [u8; Hyphenated::LENGTH + 2] = buf.try_into().unwrap();
            
            #[repr( C )]
            struct Braced {
                open_curly: u8,
                hyphenated: [u8; Hyphenated::LENGTH],
                close_curly: u8,
            }

            let braced = Braced {
                open_curly: b'{',
                hyphenated: format_hyphenated( src, upper ),
                close_curly: b'}',
            };

            *buf = unsafe_transmute!( braced );
            
            unsafe { str::from_utf8_unchecked_mut( buf ) }
        }

        #[inline] fn encode_urn<'b>( src:&[u8; 16], buffer:&'b mut [u8], upper: bool ) -> &'b mut str 
        {
            let buf = &mut buffer[..Urn::LENGTH];
            buf[..9].copy_from_slice( b"urn:uuid:" );

            let dst = &mut buf[9..( 9 + Hyphenated::LENGTH )];
            let dst:&mut [u8; Hyphenated::LENGTH] = dst.try_into().unwrap();
            *dst = format_hyphenated( src, upper );
            
            unsafe { str::from_utf8_unchecked_mut( buf ) }
        }

        impl Hyphenated 
        {

            pub const LENGTH: usize = 36;

            pub const fn from_uuid( uuid: Uuid ) -> Self 
            {
                Hyphenated( uuid )
            }
            #[inline] pub fn encode_lower<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_hyphenated( self.0.as_bytes(), buffer, false )
            }
            #[inline] pub fn encode_upper<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_hyphenated( self.0.as_bytes(), buffer, true )
            }

            pub const fn as_uuid( &self ) -> &Uuid 
            {
                &self.0
            }

            pub const fn into_uuid( self ) -> Uuid 
            {
                self.0
            }
        }

        impl Braced 
        {

            pub const LENGTH: usize = 38;

            pub const fn from_uuid( uuid: Uuid ) -> Self 
            {
                Braced( uuid )
            }
            #[inline] pub fn encode_lower<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_braced( self.0.as_bytes(), buffer, false )
            }
            #[inline] pub fn encode_upper<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_braced( self.0.as_bytes(), buffer, true )
            }

            pub const fn as_uuid( &self ) -> &Uuid 
            {
                &self.0
            }

            pub const fn into_uuid( self ) -> Uuid 
            {
                self.0
            }
        }

        impl Simple 
        {

            pub const LENGTH: usize = 32;

            pub const fn from_uuid( uuid: Uuid ) -> Self 
            {
                Simple( uuid )
            }
            #[inline] pub fn encode_lower<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_simple( self.0.as_bytes(), buffer, false )
            }
            #[inline] pub fn encode_upper<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_simple( self.0.as_bytes(), buffer, true )
            }

            pub const fn as_uuid( &self ) -> &Uuid 
            {
                &self.0
            }

            pub const fn into_uuid( self ) -> Uuid 
            {
                self.0
            }
        }

        impl Urn 
        {

            pub const LENGTH: usize = 45;

            pub const fn from_uuid( uuid: Uuid ) -> Self 
            {
                Urn( uuid )
            }
            #[inline] pub fn encode_lower<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_urn( self.0.as_bytes(), buffer, false )
            }
            #[inline] pub fn encode_upper<'buf>( &self, buffer:&'buf mut [u8] ) -> &'buf mut str 
            {
                encode_urn( self.0.as_bytes(), buffer, true )
            }

            pub const fn as_uuid( &self ) -> &Uuid 
            {
                &self.0
            }

            pub const fn into_uuid( self ) -> Uuid 
            {
                self.0
            }
        }

        impl FromStr for Hyphenated 
        {
            type Err = super::error::Error;
            fn from_str( s:&str ) -> Result<Self, Self::Err>
            {
                super::parser::parse_hyphenated( s.as_bytes() )
                .map( |b| Hyphenated( Uuid( b ) ) )
                .map_err( |invalid| invalid.into_err() )
            }
        }

        impl FromStr for Simple 
        {
            type Err = super::error::Error;
            fn from_str( s:&str ) -> Result<Self, Self::Err>
            {
                super::parser::parse_simple( s.as_bytes() )
                    .map( |b| Simple( Uuid( b ) ) )
                    .map_err( |invalid| invalid.into_err() )
            }
        }

        impl FromStr for Urn 
        {
            type Err = super::error::Error;
            fn from_str( s:&str ) -> Result<Self, Self::Err>
            {
                super::parser::parse_urn( s.as_bytes() )
                    .map( |b| Urn( Uuid( b ) ) )
                    .map_err( |invalid| invalid.into_err() )
            }
        }

        impl FromStr for Braced 
        {
            type Err = super::error::Error;
            fn from_str( s:&str ) -> Result<Self, Self::Err>
            {
                super::parser::parse_braced( s.as_bytes() )
                    .map( |b| Braced( Uuid( b ) ) )
                    .map_err( |invalid| invalid.into_err() )
            }
        }

        macro_rules! impl_fmt_traits 
        {
            ( $( $T:ident<$( $a:lifetime ),*> ),+ ) =>
            {$( 
                impl<$( $a ),*> fmt::Display for $T<$( $a ),*> 
                {
                    #[inline] fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                        fmt::LowerHex::fmt( self, f )
                    }
                }

                impl<$( $a ),*> fmt::LowerHex for $T<$( $a ),*> 
               
                {
                    fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                        f.write_str( self.encode_lower( &mut [0; Self::LENGTH] ) )
                    }
                }

                impl<$( $a ),*> fmt::UpperHex for $T<$( $a ),*> 
               
                {
                    fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result {
                        f.write_str( self.encode_upper( &mut [0; Self::LENGTH] ) )
                    }
                }

                impl_fmt_from!( $T<$( $a ),*> );
            )+}
        }

        macro_rules! impl_fmt_from 
        {
            ( $T:ident<> ) =>
            {
                impl From<Uuid> for $T {
                    #[inline] fn from( f: Uuid ) -> Self {
                        $T( f )
                    }
                }

                impl From<$T> for Uuid {
                    #[inline] fn from( f: $T ) -> Self {
                        f.into_uuid()
                    }
                }

                impl AsRef<Uuid> for $T {
                    #[inline] fn as_ref( &self ) -> &Uuid { &self.0 }
                }

                impl Borrow<Uuid> for $T {
                    #[inline] fn borrow( &self ) -> &Uuid { &self.0 }
                }
            };

            ( $T:ident<$a:lifetime> ) =>
            {
                impl<$a> From<&$a Uuid> for $T<$a> 
                {
                    #[inline] fn from( f:&$a Uuid ) -> Self {
                        $T::from_uuid_ref( f )
                    }
                }

                impl<$a> From<$T<$a>> for &$a Uuid 
                {
                    #[inline] fn from( f: $T<$a> ) -> &$a Uuid {
                        f.0
                    }
                }

                impl<$a> AsRef<Uuid> for $T<$a> 
                {
                    #[inline] fn as_ref( &self ) -> &Uuid { self.0 }
                }

                impl<$a> Borrow<Uuid> for $T<$a> 
                {
                    #[inline] fn borrow( &self ) -> &Uuid { self.0 }
                }
            };
        }

        impl_fmt_traits! 
        {
            Hyphenated<>,
            Simple<>,
            Urn<>,
            Braced<>
        }
    }

    pub mod non_nil
    {
        /*!
        A wrapper type for nil UUIDs that provides a more memory-efficient `Option<NonNilUuid>` representation.*/
        use ::
        {
            convert::{ TryFrom },
            num::{ NonZeroU128 },
            uuid::
            {
                error::{ Error, ErrorKind },
                Uuid
            },
            *,
        };
        /*
        */

        #[repr( transparent )] #[derive( Copy, Clone, PartialEq, Eq, Hash )]
        pub struct NonNilUuid( NonZeroU128 );

        impl fmt::Debug for NonNilUuid 
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::Debug::fmt( &Uuid::from( *self ), f ) }
        }

        impl fmt::Display for NonNilUuid 
        {
            fn fmt( &self, f:&mut fmt::Formatter<'_> ) -> fmt::Result { fmt::Display::fmt( &Uuid::from( *self ), f ) }
        }

        impl PartialEq<Uuid> for NonNilUuid 
        {
            fn eq( &self, other:&Uuid ) -> bool { self.get() == *other }
        }

        impl PartialEq<NonNilUuid> for Uuid 
        {
            fn eq( &self, other:&NonNilUuid ) -> bool { *self == other.get() }
        }

        impl NonNilUuid 
        {

            pub const fn new( uuid: Uuid ) -> Option<Self> 
            {
                match NonZeroU128::new( uuid.as_u128() )
                {
                    Some( non_nil ) => Some( NonNilUuid( non_nil ) ),
                    None => None,
                }
            }

            pub const unsafe fn new_unchecked( uuid: Uuid ) -> Self 
            {
                NonNilUuid( unsafe { NonZeroU128::new_unchecked( uuid.as_u128() ) } )
            }

            #[inline] pub const fn get( self ) -> Uuid { Uuid::from_u128( self.0.get() ) }
        }

        impl From<NonNilUuid> for Uuid 
        {

            fn from( non_nil: NonNilUuid ) -> Self { Uuid::from_u128( non_nil.0.get() ) }
        }

        impl TryFrom<Uuid> for NonNilUuid 
        {
            type Error = Error;
            fn try_from( uuid: Uuid ) -> Result<Self, Self::Error> 
            {
                NonZeroU128::new( uuid.as_u128() )
                .map( self )
                .ok_or( Error( ErrorKind::Nil ) )
            }
        }
    }

    pub mod parser
    {
        /*!
        [`Uuid`] parsing constructs and utilities. */
        use ::
        {
            convert::{ TryFrom },
            string::{ String },
            uuid::
            {
                error::{ * },
                Uuid,
            },
            *,
        };
        /*
        */
        impl str::FromStr for Uuid
        {
            type Err = Error;
            fn from_str( uuid_str:&str ) -> Result<Self, Self::Err>
            {
                Uuid::parse_str( uuid_str )
            }
        }

        impl TryFrom<&'_ str> for Uuid 
        {
            type Error = Error;
            fn try_from( uuid_str:&'_ str ) -> Result<Self, Self::Error> { Uuid::parse_str( uuid_str ) }
        }
        
        impl TryFrom<String> for Uuid 
        {
            type Error = Error;
            fn try_from( uuid_str: String ) -> Result<Self, Self::Error> { Uuid::try_from( uuid_str.as_ref() ) }
        }

        impl Uuid 
        {

            pub fn parse_str( input:&str ) -> Result<Uuid, Error>
            {
                try_parse( input.as_bytes() )
                .map( Uuid::from_bytes )
                .map_err( InvalidUuid::into_err )
            }

            pub const fn try_parse( input:&str ) -> Result<Uuid, Error> { Self::try_parse_ascii( input.as_bytes() ) }

            pub const fn try_parse_ascii( input:&[u8] ) -> Result<Uuid, Error>
            {
                match try_parse( input )
                {
                    Ok( bytes ) => Ok( Uuid::from_bytes( bytes ) ),
                    Err( _ ) => Err( Error( ErrorKind::ParseOther ) ),
                }
            }
        }

        const fn try_parse( input:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            match ( input.len(), input )
            {
                ( 32, s ) => parse_simple( s ),
                ( 36, s )
                | ( 38, [b'{', s @ .., b'}'] )
                | ( 45, [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] ) =>
                {
                    parse_hyphenated( s )
                }
                _ => Err( InvalidUuid( input ) ),
            }
        }

        #[inline] #[allow( dead_code )] 
        pub const fn parse_braced( input:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            if let ( 38, [b'{', s @ .., b'}'] ) = ( input.len(), input ) { parse_hyphenated( s ) }
            else { Err( InvalidUuid( input ) ) }
        }

        #[inline] #[allow( dead_code )] 
        pub const fn parse_urn( input:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            if let ( 45, [b'u', b'r', b'n', b':', b'u', b'u', b'i', b'd', b':', s @ ..] ) = 
            ( input.len(), input ) { parse_hyphenated( s ) }

            else { Err( InvalidUuid( input ) ) }
        }

        #[inline] pub const fn parse_simple( s:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            if s.len() != 32 { return Err( InvalidUuid( s ) ); }

            let mut buf: [u8; 16] = [0; 16];
            let mut i = 0;

            while i < 16
            {
                let h1 = HEX_TABLE[s[i * 2] as usize];
                let h2 = HEX_TABLE[s[i * 2 + 1] as usize];
                
                if h1 | h2 == 0xff { return Err( InvalidUuid( s ) ); }
                
                buf[i] = SHL4_TABLE[h1 as usize] | h2;
                i += 1;
            }

            Ok( buf )
        }

        #[inline] pub const fn parse_hyphenated( s:&'_ [u8] ) -> Result<[u8; 16], InvalidUuid<'_>> 
        {
            if s.len() != 36 { return Err( InvalidUuid( s ) ); }
            
            match [s[8], s[13], s[18], s[23]]
            {
                [b'-', b'-', b'-', b'-'] => {}
                _ => return Err( InvalidUuid( s ) ),
            }

            let positions: [u8; 8] = [0, 4, 9, 14, 19, 24, 28, 32];
            let mut buf: [u8; 16] = [0; 16];
            let mut j = 0;

            while j < 8
            {
                let i = positions[j];
                let h1 = HEX_TABLE[s[i as usize] as usize];
                let h2 = HEX_TABLE[s[( i + 1 ) as usize] as usize];
                let h3 = HEX_TABLE[s[( i + 2 ) as usize] as usize];
                let h4 = HEX_TABLE[s[( i + 3 ) as usize] as usize];

                if h1 | h2 | h3 | h4 == 0xff { return Err( InvalidUuid( s ) ); }

                buf[j * 2] = SHL4_TABLE[h1 as usize] | h2;
                buf[j * 2 + 1] = SHL4_TABLE[h3 as usize] | h4;
                j += 1;
            }

            Ok( buf )
        }

        const HEX_TABLE:&[u8; 256] = &
        {
            let mut buf = [0; 256];
            let mut i: u8 = 0;

            loop
            {
                buf[i as usize] = match i
                {
                    b'0'..=b'9' => i - b'0',
                    b'a'..=b'f' => i - b'a' + 10,
                    b'A'..=b'F' => i - b'A' + 10,
                    _ => 0xff,
                };

                if i == 255 { break buf; }

                i += 1
            }
        };

        const SHL4_TABLE:&[u8; 256] = &
        {
            let mut buf = [0; 256];
            let mut i: u8 = 0;

            loop
            {
                buf[i as usize] = i.wrapping_shl( 4 );

                if i == 255 {
                    break buf;
                }

                i += 1;
            }
        };
    }
    
    pub mod rng
    {
        /*!
        */
        use ::
        {
            *,
        };
        /*
        */
        trait Rng
        {
            fn u128() -> u128;
            fn u64() -> u64;
            fn u16() -> u16;
        }

        pub fn u128() -> u128 { imp::RngImp::u128() }

        pub fn u64() -> u64 { imp::RngImp::u64() }

        pub fn u16() -> u16 { imp::RngImp::u16() }
        
        mod imp 
        {
            /*
            Random support for non `wasm32-unknown-unknown` platforms. */
            use super::*;

            pub struct RngImp;
            
            impl Rng for RngImp
            {
                fn u128() -> u128 { rand::random() }
                fn u64() -> u64 { rand::random() }
                fn u16() -> u16 { rand::random() }
            }
        }
    }

    pub mod timestamp
    {
        /*!
        Generating UUIDs from timestamps. */
        use ::
        {
            uuid::{ Uuid },
            *,
        };
        /*
        */
        pub const UUID_TICKS_BETWEEN_EPOCHS: u64 = 0x01B2_1DD2_1381_4000;

        #[derive( Debug, Clone, Copy, PartialEq, Eq, Hash )]
        pub struct Timestamp
        {
            seconds: u64,
            subsec_nanos: u32,
            counter: u128,
            usable_counter_bits: u8,
        }

        impl Timestamp
        {

            pub fn now( context:impl ClockSequence<Output = impl Into<u128>> ) -> Self
            {
                let ( seconds, subsec_nanos ) = now();
                let ( c, s, n ) = context.generate_timestamp_sequence( seconds, subsec_nanos );
                let c = c.into();
                let usable_counter_bits = context.usable_bits() as u8;
                Timestamp
                {
                    seconds:s,
                    subsec_nanos:n,
                    counter:c,
                    usable_counter_bits,
                }
            }
            pub const fn from_gregorian( ticks: u64, counter: u16 ) -> Self
            {
                let ( seconds, subsec_nanos ) = Self::gregorian_to_unix( ticks );

                Timestamp 
                {
                    seconds,
                    subsec_nanos,
                    counter: counter as u128,
                    usable_counter_bits: 14,
                }
            }

            pub const fn from_unix_time( seconds:u64, subsec_nanos:u32, counter:u128, usable_counter_bits:u8 ) -> Self
            {
                Timestamp
                {
                    seconds,
                    subsec_nanos,
                    counter,
                    usable_counter_bits,
                }
            }

            pub fn from_unix
            ( 
                context: impl ClockSequence<Output = impl Into<u128>>,
                seconds: u64,
                subsec_nanos: u32,
            ) -> Self
            {
                let ( counter, seconds, subsec_nanos ) = context.generate_timestamp_sequence( seconds, subsec_nanos );
                let counter = counter.into();
                let usable_counter_bits = context.usable_bits() as u8;

                Timestamp
                {
                    seconds,
                    subsec_nanos,
                    counter,
                    usable_counter_bits,
                }
            }
            pub const fn to_gregorian( &self ) -> ( u64, u16 )
            {
                ( 
                    Self::unix_to_gregorian_ticks( self.seconds, self.subsec_nanos ),
                    ( self.counter as u16 ) & 0x3FFF,
                )
            }

            pub const fn to_unix( &self ) -> ( u64, u32 ) { ( self.seconds, self.subsec_nanos ) }

            const fn unix_to_gregorian_ticks( seconds: u64, nanos: u32 ) -> u64
            {
                UUID_TICKS_BETWEEN_EPOCHS
                .wrapping_add( seconds.wrapping_mul( 10_000_000 ) )
                .wrapping_add( nanos as u64 / 100 )
            }

            const fn gregorian_to_unix( ticks: u64 ) -> ( u64, u32 )
            {
                ( 
                    ticks.wrapping_sub( UUID_TICKS_BETWEEN_EPOCHS ) / 10_000_000,
                    ( ticks.wrapping_sub( UUID_TICKS_BETWEEN_EPOCHS ) % 10_000_000 ) as u32 * 100,
                )
            }
        }

        #[doc( hidden )]
        impl Timestamp
        {
            #[deprecated( 
                since = "1.10.0",
                note = "use `Timestamp::from_gregorian( ticks, counter )`"
            )]
            pub const fn from_rfc4122( t:u64, c:u16 ) -> Self { Timestamp::from_gregorian( t, c ) }

            #[deprecated( since = "1.10.0", note = "use `Timestamp::to_gregorian()`" )]
            pub const fn to_rfc4122( &self ) -> ( u64, u16 ) { self.to_gregorian() }

            #[deprecated( 
                since = "1.2.0",
                note = "`Timestamp::to_unix_nanos()` is deprecated: use `Timestamp::to_unix()`"
            )]
            pub const fn to_unix_nanos( &self ) -> u32
            {
                panic!( "`Timestamp::to_unix_nanos()` is deprecated: use `Timestamp::to_unix()`" )
            }
        }
        
        impl ::convert::TryFrom<std::time::SystemTime> for Timestamp
        {
            type Error = super::Error;
            fn try_from( st: ::time::std::SystemTime ) -> Result<Self, Self::Error>
            {
                let dur = st.duration_since( ::time::std::UNIX_EPOCH )
                .map_err( |_| super::Error( super::error::ErrorKind::InvalidSystemTime( "unable to convert the system tie into a Unix timestamp" ) ) )?;

                Ok( Self::from_unix_time
                ( 
                    dur.as_secs(),
                    dur.subsec_nanos(),
                    0,
                    0,
                ) )
            }
        }
        
        impl From<Timestamp> for ::time::std::SystemTime
        {
            fn from( ts: Timestamp ) -> Self
            {
                let ( seconds, subsec_nanos ) = ts.to_unix();
                Self::UNIX_EPOCH + std::time::Duration::new( seconds, subsec_nanos )
            }
        }

        pub const fn encode_gregorian_timestamp
        ( 
            ticks: u64,
            counter: u16,
            node_id:&[u8; 6],
        ) -> Uuid
        {
            let time_low = ( ticks & 0xFFFF_FFFF ) as u32;
            let time_mid = (( ticks >> 32 ) & 0xFFFF ) as u16;
            let time_high_and_version = (( ( ticks >> 48 ) & 0x0FFF ) as u16 ) | ( 1 << 12 );
            let mut d4 = [0; 8];

            d4[0] = (( ( counter & 0x3F00 ) >> 8 ) as u8 ) | 0x80;
            d4[1] = ( counter & 0xFF ) as u8;
            d4[2] = node_id[0];
            d4[3] = node_id[1];
            d4[4] = node_id[2];
            d4[5] = node_id[3];
            d4[6] = node_id[4];
            d4[7] = node_id[5];

            Uuid::from_fields( time_low, time_mid, time_high_and_version, &d4 )
        }

        pub const fn decode_gregorian_timestamp( uuid:&Uuid ) -> ( u64, u16 )
        {
            let bytes = uuid.as_bytes();

            let ticks: u64 = (( bytes[6] & 0x0F ) as u64 ) << 56
            | ( bytes[7] as u64 ) << 48
            | ( bytes[4] as u64 ) << 40
            | ( bytes[5] as u64 ) << 32
            | ( bytes[0] as u64 ) << 24
            | ( bytes[1] as u64 ) << 16
            | ( bytes[2] as u64 ) << 8
            | ( bytes[3] as u64 );

            let counter: u16 = (( bytes[8] & 0x3F ) as u16 ) << 8 | ( bytes[9] as u16 );

            ( ticks, counter )
        }

        pub const fn encode_sorted_gregorian_timestamp( ticks: u64, counter: u16, node_id:&[u8; 6] ) -> Uuid
        {
            let time_high = (( ticks >> 28 ) & 0xFFFF_FFFF ) as u32;
            let time_mid = (( ticks >> 12 ) & 0xFFFF ) as u16;
            let time_low_and_version = (( ticks & 0x0FFF ) as u16 ) | ( 0x6 << 12 );

            let mut d4 = [0; 8];

            d4[0] = (( ( counter & 0x3F00 ) >> 8 ) as u8 ) | 0x80;
            d4[1] = ( counter & 0xFF ) as u8;
            d4[2] = node_id[0];
            d4[3] = node_id[1];
            d4[4] = node_id[2];
            d4[5] = node_id[3];
            d4[6] = node_id[4];
            d4[7] = node_id[5];

            Uuid::from_fields( time_high, time_mid, time_low_and_version, &d4 )
        }

        pub const fn decode_sorted_gregorian_timestamp( uuid:&Uuid ) -> ( u64, u16 )
        {
            let bytes = uuid.as_bytes();
            let ticks: u64 = (( bytes[0] ) as u64 ) << 52
            | ( bytes[1] as u64 ) << 44
            | ( bytes[2] as u64 ) << 36
            | ( bytes[3] as u64 ) << 28
            | ( bytes[4] as u64 ) << 20
            | ( bytes[5] as u64 ) << 12
            | ( ( bytes[6] & 0xF ) as u64 ) << 8
            | ( bytes[7] as u64 );

            let counter: u16 = (( bytes[8] & 0x3F ) as u16 ) << 8 | ( bytes[9] as u16  );

            ( ticks, counter )
        }

        pub const fn encode_unix_timestamp_millis(  millis: u64, counter_random_bytes:&[u8; 10] ) -> Uuid
        {
            let millis_high = (( millis >> 16 ) & 0xFFFF_FFFF ) as u32;
            let millis_low = ( millis & 0xFFFF ) as u16;

            let counter_random_version = ( counter_random_bytes[1] as u16
            | ( ( counter_random_bytes[0] as u16 ) << 8 ) & 0x0FFF )
            | ( 0x7 << 12 );

            let mut d4 = [0; 8];

            d4[0] = ( counter_random_bytes[2] & 0x3F ) | 0x80;
            d4[1] = counter_random_bytes[3];
            d4[2] = counter_random_bytes[4];
            d4[3] = counter_random_bytes[5];
            d4[4] = counter_random_bytes[6];
            d4[5] = counter_random_bytes[7];
            d4[6] = counter_random_bytes[8];
            d4[7] = counter_random_bytes[9];

            Uuid::from_fields( millis_high, millis_low, counter_random_version, &d4 )
        }

        pub const fn decode_unix_timestamp_millis( uuid:&Uuid ) -> u64
        {
            let bytes = uuid.as_bytes();

            let millis: u64 = ( bytes[0] as u64 ) << 40
            | ( bytes[1] as u64 ) << 32
            | ( bytes[2] as u64 ) << 24
            | ( bytes[3] as u64 ) << 16
            | ( bytes[4] as u64 ) << 8
            | ( bytes[5] as u64 );

            millis
        }
        
        fn now() -> ( u64, u32 )
        {
            let dur = ::time::std::SystemTime::UNIX_EPOCH.elapsed()
            .expect( "Getting elapsed time since UNIX_EPOCH. If this fails, we've somehow violated causality",  );

            ( dur.as_secs(), dur.subsec_nanos() )
        }

        pub trait ClockSequence
        {

            type Output;
            fn generate_sequence( &self, seconds: u64, subsec_nanos: u32 ) -> Self::Output;
            fn generate_timestamp_sequence
            ( 
                &self,
                seconds:u64,
                subsec_nanos:u32
            ) -> ( Self::Output, u64, u32 )
            {
                ( 
                    self.generate_sequence( seconds, subsec_nanos ),
                    seconds,
                    subsec_nanos,
                )
            }
            /*
            The number of usable bits from the least significant bit in the result of 
            `ClockSequence::generate_sequence` or `ClockSequence::generate_timestamp_sequence`. */
            fn usable_bits( &self ) -> usize where
            Self::Output: Sized
            {
                cmp::min( 128, ::mem::size_of::<Self::Output>() )
            }
        }

        impl<'a, T:ClockSequence + ?Sized> ClockSequence for &'a T
        {
            type Output = T::Output;
            fn generate_sequence( &self, seconds: u64, subsec_nanos: u32 ) -> Self::Output
            { ( **self ).generate_sequence( seconds, subsec_nanos ) }

            fn generate_timestamp_sequence
            ( 
                &self,
                seconds: u64,
                subsec_nanos: u32
            ) -> ( Self::Output, u64, u32 )
            { ( **self ).generate_timestamp_sequence( seconds, subsec_nanos ) }

            fn usable_bits( &self ) -> usize where
            Self::Output: Sized
            { ( **self ).usable_bits() }
        }

        pub mod context
        {
            use super::ClockSequence;

            #[derive( Debug, Clone, Copy, Default )]
            pub struct NoContext;

            impl ClockSequence for NoContext
            {
                type Output = u16;
                fn generate_sequence( &self, _seconds: u64, _nanos: u32 ) -> Self::Output { 0 }

                fn usable_bits( &self ) -> usize { 0 }
            }
        }
    } pub use self::timestamp::{ context::NoContext, ClockSequence, Timestamp };
    /*
    */

    pub type Bytes = [u8; 16];

    #[repr( u8 )] #[non_exhaustive] #[derive( Clone, Copy, Debug, PartialEq )]
    pub enum Version
    {

        Nil = 0u8,
        Mac = 1,
        Dce = 2,
        Md5 = 3,
        Random = 4,
        Sha1 = 5,
        SortMac = 6,
        SortRand = 7,
        Custom = 8,
        Max = 0xff,
    }

    #[repr( u8 )] #[non_exhaustive] #[derive( Clone, Copy, Debug, PartialEq )]
    pub enum Variant
    {

        NCS = 0u8,
        RFC4122,
        Microsoft,
        Future,
    }

    #[repr( transparent )] #[derive( Clone, Copy, Eq, Ord, PartialEq, PartialOrd )]
    pub struct Uuid( Bytes );

    impl Uuid
    {

        pub const NAMESPACE_DNS: Self = Uuid
        ( [
            0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
        ] );

        pub const NAMESPACE_OID: Self = Uuid
        ( [
            0x6b, 0xa7, 0xb8, 0x12, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
        ] );

        pub const NAMESPACE_URL: Self = Uuid
        ( [
            0x6b, 0xa7, 0xb8, 0x11, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
        ] );

        pub const NAMESPACE_X500: Self = Uuid
        ( [
            0x6b, 0xa7, 0xb8, 0x14, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8,
        ] );

        pub const fn get_variant( &self ) -> Variant
        {
            match self.as_bytes()[8] 
            {
                x if x & 0x80 == 0x00 => Variant::NCS,
                x if x & 0xc0 == 0x80 => Variant::RFC4122,
                x if x & 0xe0 == 0xc0 => Variant::Microsoft,
                x if x & 0xe0 == 0xe0 => Variant::Future,
                _ => Variant::Future,
            }
        }

        pub const fn get_version_num( &self ) -> usize
        {
            ( self.as_bytes()[6] >> 4 ) as usize
        }

        pub const fn get_version( &self ) -> Option<Version>
        {
            match self.get_version_num()
            {
                0 if self.is_nil() => Some( Version::Nil ),
                1 => Some( Version::Mac ),
                2 => Some( Version::Dce ),
                3 => Some( Version::Md5 ),
                4 => Some( Version::Random ),
                5 => Some( Version::Sha1 ),
                6 => Some( Version::SortMac ),
                7 => Some( Version::SortRand ),
                8 => Some( Version::Custom ),
                0xf => Some( Version::Max ),
                _ => None,
            }
        }

        pub fn as_fields( &self ) -> ( u32, u16, u16, &[u8; 8] )
        {
            let bytes = self.as_bytes();

            let d1 = ( bytes[0] as u32 ) << 24
            | ( bytes[1] as u32 ) << 16
            | ( bytes[2] as u32 ) << 8
            | ( bytes[3] as u32 );

            let d2 = ( bytes[4] as u16 ) << 8 | ( bytes[5] as u16 );

            let d3 = ( bytes[6] as u16 ) << 8 | ( bytes[7] as u16 );

            let d4:&[u8; 8] = convert::TryInto::try_into( &bytes[8..16] ).unwrap();
            ( d1, d2, d3, d4 )
        }

        pub fn to_fields_le( &self ) -> ( u32, u16, u16, &[u8; 8] )
        {
            let d1 = ( self.as_bytes()[0] as u32 )
            | ( self.as_bytes()[1] as u32 ) << 8
            | ( self.as_bytes()[2] as u32 ) << 16
            | ( self.as_bytes()[3] as u32 ) << 24;

            let d2 = ( self.as_bytes()[4] as u16 ) | ( self.as_bytes()[5] as u16 ) << 8;

            let d3 = ( self.as_bytes()[6] as u16 ) | ( self.as_bytes()[7] as u16 ) << 8;

            let d4:&[u8; 8] = convert::TryInto::try_into( &self.as_bytes()[8..16] ).unwrap();
            ( d1, d2, d3, d4 )
        }

        pub const fn as_u128( &self ) -> u128 { u128::from_be_bytes( *self.as_bytes() ) }

        pub const fn to_u128_le( &self ) -> u128 { u128::from_le_bytes( *self.as_bytes() ) }

        pub const fn as_u64_pair( &self ) -> ( u64, u64 )
        {
            let value = self.as_u128();
            ( ( value >> 64 ) as u64, value as u64 )
        }

        #[inline] pub const fn as_bytes( &self ) -> &Bytes { &self.0 }

        #[inline] pub const fn into_bytes( self ) -> Bytes { self.0 }

        pub const fn to_bytes_le( &self ) -> Bytes
        {[
            self.0[3], self.0[2], self.0[1], self.0[0], self.0[5], self.0[4], self.0[7], self.0[6], 
            self.0[8], self.0[9], self.0[10], self.0[11], self.0[12], self.0[13], self.0[14], self.0[15],
        ]}

        pub const fn is_nil( &self ) -> bool { self.as_u128() == u128::MIN }

        pub const fn is_max( &self ) -> bool { self.as_u128() == u128::MAX }

        pub const fn encode_buffer() -> [ u8; fmt::Urn::LENGTH ] { [0; fmt::Urn::LENGTH] }

        pub const fn get_timestamp( &self ) -> Option<Timestamp>
        {
            match self.get_version()
            {
                Some( Version::Mac ) =>
                {
                    let ( ticks, counter ) = timestamp::decode_gregorian_timestamp( self );
                    Some( Timestamp::from_gregorian( ticks, counter ) )
                }

                Some( Version::SortMac ) =>
                {
                    let ( ticks, counter ) = timestamp::decode_sorted_gregorian_timestamp( self );
                    Some( Timestamp::from_gregorian( ticks, counter ) )
                }

                Some( Version::SortRand ) =>
                {
                    let millis = timestamp::decode_unix_timestamp_millis( self );
                    let seconds = millis / 1000;
                    let nanos = (( millis % 1000 ) * 1_000_000 ) as u32;
                    Some( Timestamp::from_unix_time( seconds, nanos, 0, 0 ) )
                }

                _ => None,
            }
        }

        pub const fn get_node_id( &self ) -> Option<[u8; 6]>
        {
            match self.get_version()
            {
                Some( Version::Mac ) | Some( Version::SortMac ) =>
                {
                    let mut node_id = [0; 6];
                    node_id[0] = self.0[10];
                    node_id[1] = self.0[11];
                    node_id[2] = self.0[12];
                    node_id[3] = self.0[13];
                    node_id[4] = self.0[14];
                    node_id[5] = self.0[15];
                    Some( node_id )
                }
                _ => None,
            }
        }

        pub fn new_v4() -> Uuid
        {
            Uuid::from_u128( uuid::rng::u128() & 0xFFFFFFFFFFFF4FFFBFFFFFFFFFFFFFFF | 0x40008000000000000000 )
        }
    }

    impl Hash for Uuid
    {
        fn hash<H:Hasher>( &self, state:&mut H ) { state.write( &self.0  ); }
    }

    impl Default for Uuid
    {
        #[inline] fn default() -> Self { Uuid::nil() }
    }

    impl AsRef<Uuid> for Uuid
    {
        #[inline] fn as_ref( &self ) -> &Uuid { self }
    }

    impl AsRef<[u8]> for Uuid
    {
        #[inline] fn as_ref( &self ) -> &[u8] { &self.0 }
    }
    
    impl From<Uuid> for Vec<u8>
    {
        fn from( value: Uuid ) -> Self { value.0.to_vec() }
    }
    
    impl ::convert::TryFrom<Vec<u8>> for Uuid
    {
        type Error = error::Error;
        fn try_from( value:Vec<u8> ) -> Result<Self, Self::Error> { Uuid::from_slice( &value ) }
    }
}

pub mod values
{
    /*!
    */
    use ::
    {
        arrays::{ self, Arr },
        error::{ OverError },
        fmt::{ Format },
        num::
        {
            big::BigInt,
            rational::BigRational,
            traits::ToPrimitive,
        },
        objects::{ self, Obj },
        result::{ OverResult },
        tuples::{ self, Tup },
        types::{ Type },
        *,
    };
    /*
    
    use crate::{OverResult, INDENT_STEP};
    */
    macro_rules! get_fn
    {
        ( $doc:expr, $name:tt, $type:ty, $variant:ident ) =>
        {
            #[doc=$doc]
            pub fn $name( &self ) -> OverResult<$type> {
                if let Value::$variant( ref inner ) = *self {
                    Ok( inner.clone() )
                } else {
                    Err( OverError::TypeMismatch( Type::$variant, self.get_type() ) )
                }
            }
        }
    }

    macro_rules! impl_eq
    {
        ( $valtype:ident, $type:ty ) =>
        {
            impl PartialEq<$type> for Value
            {
                fn eq( &self, other:&$type ) -> bool
                {
                    match *self
                    {
                        Value::$valtype( ref value ) => value == other,
                        _ => false,
                    }
                }
            }
            
            impl PartialEq<Value> for $type
            {
                fn eq( &self, other:&Value ) -> bool
                {
                    match *other
                    {
                        Value::$valtype( ref value ) => value == self,
                        _ => false,
                    }
                }
            }
        };
    }
    
    macro_rules! impl_eq_int
    {
        ( $type:ty, $fn:tt ) =>
        {
            impl PartialEq<$type> for Value
            {
                fn eq( &self, other:&$type ) -> bool
                {
                    match *self
                    {
                        Value::Int( ref value ) => match value.$fn()
                        {
                            Some( value ) => value == *other,
                            None => false,
                        },
                        _ => false,
                    }
                }
            }
            
            impl PartialEq<Value> for $type
            {
                fn eq( &self, other:&Value ) -> bool
                {
                    match *other
                    {
                        Value::Int( ref value ) => match value.$fn()
                        {
                            Some( value ) => value == *self,
                            None => false,
                        },
                        _ => false,
                    }
                }
            }
        };
    }

    macro_rules! impl_from
    {
        ( $type:ty, $fn:tt ) =>
        {
            impl From<$type> for Value
            {
                fn from( inner: $type ) -> Self { Value::$fn( inner.into() ) }
            }
        };
    }

    #[derive( Clone, Debug, PartialEq )]
    pub enum Value
    {

        Null,
        Bool( bool ),
        Int( BigInt ),
        Integer( i32 ),
        Frac( BigRational ),
        Char( char ),
        Str( String ),
        Strand( String ),
        Arr( Arr ),
        Tup( Tup ),
        Obj( Obj ),
    }

    impl Value
    {
        pub fn is_null( &self ) -> bool 
        {
            if let Value::Null = *self { true }
            else { false }
        }

        pub fn get_type( &self ) -> Type
        {
            use self::Value::*;

            match *self
            {
                Null => Type::Null,
                Bool( _ ) => Type::Bool,
                Int( _ ) => Type::Int,
                Integer( _ ) => Type::Integer,
                Frac( _ ) => Type::Frac,
                Char( _ ) => Type::Char,
                Str( _ ) => Type::Str,
                Strand( _ ) => Type::Strand,
                Arr( ref arr ) => Type::Arr( Box::new( arr.inner_type() ) ),
                Tup( ref tup ) => Type::Tup( tup.inner_type_vec() ),
                Obj( _ ) => Type::Obj,
            }
        }

        get_fn!( r#"Returns the `bool` contained in this `Value`."#, get_bool, bool, Bool  );        
        get_fn! ( "Returns the `BigInt` contained in this `Value`.", get_int, BigInt, Int  );

        pub fn get_frac( &self ) -> OverResult<BigRational>
        {
            match *self 
            {
                Value::Frac( ref inner ) => Ok( inner.clone() ),
                Value::Int( ref inner ) => Ok( frac!( inner.clone(), 1 ) ),
                _ => Err( OverError::TypeMismatch( Type::Frac, self.get_type() ) ),
            }
        }

        get_fn!( "Returns the `char` contained in this `Value`.", get_char, char, Char  );        
        get_fn!( r#"Returns the `String` contained in this `Value`."#, get_str, String, Str  );        
        get_fn!( "Returns the `Obj` contained in this `Value`.", get_obj, objects::Obj, Obj  );

        pub fn get_arr( &self ) -> OverResult<arrays::Arr>
        {
            if let Value::Arr( ref inner ) = *self { Ok( inner.clone() ) }
            else
            {
                Err
                ( 
                    OverError::TypeMismatch
                    ( 
                        Type::Arr( Box::new( Type::Any ) ),
                        self.get_type(),
                    )
                )
            }
        }

        pub fn get_tup( &self ) -> OverResult<tuples::Tup>
        {
            if let Value::Tup( ref inner ) = *self { Ok( inner.clone() ) }
            else { Err( OverError::TypeMismatch( Type::Tup( vec![] ), self.get_type() ) ) }
        }
    }

    impl From<()> for Value
    {
        fn from( _: () ) -> Self { Value::Bool( true ) }
    }
    
    impl fmt::Display for Value
    {
        fn fmt( &self, f:&mut fmt::Formatter ) -> fmt::Result
        {
            write!( f, "{}", self.format( true, INDENT_STEP ) )
        }
    }

    impl_eq!( Bool, bool );
    impl_eq!( Int, BigInt );
    impl_eq!( Frac, BigRational );
    impl_eq!( Char, char );
    impl_eq!( Arr, arrays::Arr );
    impl_eq!( Tup, tuples::Tup );
    impl_eq!( Obj, objects::Obj );

    impl<'a> PartialEq<&'a str> for Value
    {
        fn eq( &self, other:&&str ) -> bool
        {
            match *self
            {
                Value::Str( ref value ) => value == &other.replace( "\r\n","\n" ),
                _ => false,
            }
        }
    }

    impl<'a> PartialEq<Value> for &'a str
    {
        fn eq( &self, other:&Value ) -> bool
        {
            match *other
            {
                Value::Str( ref value ) => value == &self.replace( "\r\n","\n" ),
                _ => false,
            }
        }
    }

    impl PartialEq<String> for Value
    {
        fn eq( &self, other:&String ) -> bool
        {
            &other.as_str() == self
        }
    }

    impl PartialEq<Value> for String
    {
        fn eq( &self, other:&Value ) -> bool
        {
            &self.as_str() == other
        }
    }

    impl_eq_int!( usize, to_usize );
    impl_eq_int!( u8, to_u8 );
    impl_eq_int!( u16, to_u16 );
    impl_eq_int!( u32, to_u32 );
    impl_eq_int!( u64, to_u64 );
    impl_eq_int!( i8, to_i8 );
    impl_eq_int!( i16, to_i16 );
    impl_eq_int!( i32, to_i32 );
    impl_eq_int!( i64, to_i64 );
    
    impl<'a> From<&'a str> for Value 
    {
        fn from( inner:&str ) -> Self 
        {
            Value::Str( inner.into() )
        }
    }

    impl_from!( bool, Bool );
    impl_from!( usize, Int );
    impl_from!( u8, Int );
    impl_from!( u16, Int );
    impl_from!( u32, Int );
    impl_from!( u64, Int );
    impl_from!( i8, Int );
    impl_from!( i16, Int );
    impl_from!( i32, Int );
    impl_from!( i64, Int );
    impl_from!( BigInt, Int );
    impl_from!( BigRational, Frac );
    impl_from!( char, Char );
    impl_from!( String, Str );
    impl_from!( arrays::Arr, Arr  );
    impl_from!( tuples::Tup, Tup  );
    impl_from!( objects::Obj, Obj  );
}

pub mod vec
{
    pub use std::vec::{ * };
}
/// Indent step in .over files.
pub const INDENT_STEP: usize = 4;

pub fn main() -> Result<(), error::parse::ParseError>
{
    unsafe
    {
        use ::system::api::{ * };

        let _ = ::system::common::build()?;
        let document = ::parses::load_from_str( ::system::common::DATABASE.as_str() )?;
        println!
        ( 
            r#"{}"#,
            //::system::common::INFORMATION
            document.read( "aliases" )?,
         );

        signal( SIG_PIPE, SIG_DFL );
        signal( SIG_TSTP, SIG_IGN );
        signal( SIG_QUIT, SIG_IGN );

        env::initialize_paths();

        let mut sh = shell::Shell::new();
        let args:Vec<String> = env::args().collect();

        if is::login( &args )
        {
            rc::file::run( &mut sh );
            sh.is_login = true;
        }
        
        highlights::initialize();
        highlights::update( &sh );
        
        if is::script( &args )
        {
            //log!( "run script: {:?} ", &args );
            let status = scripts::run( &mut sh, &args );
            ::process::exit( status );
        }
        
        if is::command_string( &args )
        {
            let line = env::args_to_command_line();
            now::run_command_line( &mut sh, &line, false, false );
            ::process::exit( sh.previous_status );
        }

        if is::non_tty()
        {
            now::run_procs_for_non_tty( &mut sh );
            return;
        }

        let mut rl;
        match ::system::interface::Interface::new( "cicada" )
        {
            Ok( x ) => rl = x,
            Err( e ) => 
            {
                println!( ":: lineread error: {}", e );
                return;
            }
        }
        
        rl.define_function( "enter-function", ::sync::Arc::new( prompts::EnterFunction ) );
        rl.bind_sequence( "\r", types::Command::from_str( "enter-function" ) );
    }
    /*
    let document = ::parses::load_from_str
    ( 
        r#"receipt: "Oz-Ware Purchase Invoice"
            date:    "2012-08-06"
            customer: {
                first_name:  "Dorothy"
                family_name: "Gale"
            }

            items: [
                    {
                    part_no:  "A4786"
                    descrip:  "Water Bucket ( Filled )"
                    price:    01.47
                    quantity: 4
                    }
                    {
                    part_no:  "E1628"
                    descrip:  "High Heeled \"Ruby\" Slippers"
                    size:     8
                    price:    133.70
                    quantity: 1
                    }
                ]

            bill_to: {
                street:
                # A multi-line string. Can also be written as "123 Tornado Alley\nSuite16"
            "123 Tornado Alley
            Suite 16"
                city:  "East Centerville"
                state: "KS"
            }

            ship_to: bill_to

            specialDelivery:
            "Follow the Yellow Brick Road to the Emerald City. Pay no attention to the man behind the curtain."
    "# )?;
    
    assert_eq!( document.read( "receipt" )?, "Oz-Ware Purchase Invoice" );
    assert_eq!( document.read( "date"    )?, "2012-08-06"               );
    assert_eq!
    ( 
        document.read( "customer" )?,
        obj!
        { 
            "first_name"  => "Dorothy", 
            "family_name" => "Gale"
        }
     );

    assert_eq!
    ( 
        document.read( "items" )?,
        arr!
        [
            obj!
            {
                "part_no" => "A4786",
                "descrip" => "Water Bucket ( Filled )",
                "price" => frac!( 147,100 ),
                "quantity" => 4
            },
            obj!
            {
                "part_no" => "E1628",
                "descrip" => "High Heeled \"Ruby\" Slippers",
                "size" => 8,
                "price" => frac!( 1337,10 ),
                "quantity" => 1
            },
        ]
     );

    assert_eq!
    ( 
        document.read( "bill_to" )?,
        obj!
        {
            "street" => "123 Tornado Alley\nSuite 16",
            "city" => "East Centerville",
            "state" => "KS",
        }
     );

    assert_eq!
    ( 
        document.read( "ship_to" )?,
        document.read( "bill_to" )?,
     );

    assert_eq!
    ( 
        document.read( "specialDelivery" )?,
        r#"Follow the Yellow Brick Road to the Emerald City.
        Pay no attention to the man behind the curtain."#
     ); */

    /*
    */
    Ok( () )
}
// 70947 /////////////////////////////////////////////////////////////////////////////////////////////////////////////
